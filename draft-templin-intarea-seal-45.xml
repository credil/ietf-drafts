<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict='yes'?>
<?rfc iprnotified='no'?>
<rfc category="info" docName="draft-templin-intarea-seal-45.txt"
     ipr="trust200902">
  <front>
    <title abbrev="SEAL">The Subnetwork Encapsulation and Adaptation Layer
    (SEAL)</title>

    <author fullname="Fred L. Templin" initials="F. L." role="editor"
            surname="Templin">
      <organization>Boeing Research &amp; Technology</organization>

      <address>
        <postal>
          <street>P.O. Box 3707</street>

          <city>Seattle</city>

          <region>WA</region>

          <code>98124</code>

          <country>USA</country>
        </postal>

        <email>fltemplin@acm.org</email>
      </address>
    </author>

    <date day="25" month="June" year="2012" />

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <abstract>
      <t>For the purpose of this document, a subnetwork is defined as a
      virtual topology configured over a connected IP network routing region
      and bounded by encapsulating border nodes. These virtual topologies are
      manifested by tunnels that may span multiple IP and/or sub-IP layer
      forwarding hops, and can introduce failure modes due to packet
      duplication, packet reordering, source address spoofing and traversal of
      links with diverse Maximum Transmission Units (MTUs). This document
      specifies a Subnetwork Encapsulation and Adaptation Layer (SEAL) that
      addresses these issues.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>As Internet technology and communication has grown and matured, many
      techniques have developed that use virtual topologies (including tunnels
      of one form or another) over an actual network that supports the
      Internet Protocol (IP) <xref target="RFC0791"></xref><xref
      target="RFC2460"></xref>. Those virtual topologies have elements that
      appear as one hop in the virtual topology, but are actually multiple IP
      or sub-IP layer hops. These multiple hops often have quite diverse
      properties that are often not even visible to the endpoints of the
      virtual hop. This introduces failure modes that are not dealt with well
      in current approaches.</t>

      <t>The use of IP encapsulation (also known as "tunneling") has long been
      considered as the means for creating such virtual topologies. However,
      the encapsulation headers often include insufficiently provisioned
      per-packet identification values. This can present issues for duplicate
      packet detection and detection of packet reordering within the
      subnetwork. IP encapsulation also allows an attacker to produce
      encapsulated packets with spoofed source addresses even if the source
      address in the encapsulating header cannot be spoofed. A
      denial-of-service vector that is not possible in non-tunneled
      subnetworks is therefore presented.</t>

      <t>Additionally, the insertion of an outer IP header reduces the
      effective path MTU visible to the inner network layer. When IPv6 is used
      as the encapsulation protocol, original sources expect to be informed of
      the MTU limitation through IPv6 Path MTU discovery (PMTUD) <xref
      target="RFC1981"></xref>. When IPv4 is used, this reduced MTU can be
      accommodated through the use of IPv4 fragmentation, but unmitigated
      in-the-network fragmentation has been found to be harmful through
      operational experience and studies conducted over the course of many
      years <xref target="FRAG"></xref><xref target="FOLK"></xref><xref
      target="RFC4963"></xref>. Additionally, classical IPv4 PMTUD <xref
      target="RFC1191"></xref> has known operational issues that are
      exacerbated by in-the-network tunnels <xref
      target="RFC2923"></xref><xref target="RFC4459"></xref>.</t>

      <t>The following subsections present further details on the motivation
      and approach for addressing these issues.</t>

      <section title="Motivation">
        <t>Before discussing the approach, it is necessary to first understand
        the problems. In both the Internet and private-use networks today, IP
        is ubiquitously deployed as the Layer 3 protocol. The primary
        functions of IP are to provide for routing, addressing, and a
        fragmentation and reassembly capability used to accommodate links with
        diverse MTUs. While it is well known that the IP address space is
        rapidly becoming depleted, there is a lesser-known but growing
        consensus that other IP protocol limitations have already or may soon
        become problematic.</t>

        <t>First, the Internet historically provided no means for discerning
        whether the source addresses of IP packets are authentic. This
        shortcoming is being addressed more and more through the deployment of
        site border router ingress filters <xref target="RFC2827"></xref>,
        however the use of encapsulation provides a vector for an attacker to
        circumvent filtering for the encapsulated packet even if filtering is
        correctly applied to the encapsulation header. Secondly, the IP header
        does not include a well-behaved identification value unless the source
        has included a fragment header for IPv6 or unless the source permits
        fragmentation for IPv4. These limitations preclude an efficient means
        for routers to detect duplicate packets and packets that have been
        re-ordered within the subnetwork.</t>

        <t>For IPv4 encapsulation, when fragmentation is permitted the header
        includes a 16-bit Identification field, meaning that at most 2^16
        unique packets with the same (source, destination, protocol)-tuple can
        be active in the Internet at the same time <xref
        target="I-D.ietf-intarea-ipv4-id-update"></xref>. (When middleboxes
        such as Network Address Translators (NATs) re-write the Identification
        field to random values, the number of unique packets is even further
        reduced.) Due to the escalating deployment of high-speed links,
        however, these numbers have become too small by several orders of
        magnitude for high data rate packet sources such as tunnel endpoints
        <xref target="RFC4963"></xref>.</t>

        <t>Furthermore, there are many well-known limitations pertaining to
        IPv4 fragmentation and reassembly &ndash; even to the point that it
        has been deemed &ldquo;harmful&rdquo; in both classic and modern-day
        studies (see above). In particular, IPv4 fragmentation raises issues
        ranging from minor annoyances (e.g., in-the-network router
        fragmentation <xref target="RFC1981"></xref>) to the potential for
        major integrity issues (e.g., mis-association of the fragments of
        multiple IP packets during reassembly <xref
        target="RFC4963"></xref>).</t>

        <t>As a result of these perceived limitations, a
        fragmentation-avoiding technique for discovering the MTU of the
        forward path from a source to a destination node was devised through
        the deliberations of the Path MTU Discovery Working Group (PMTUDWG)
        during the late 1980&rsquo;s through early 1990&rsquo;s (see Appendix
        D). In this method, the source node provides explicit instructions to
        routers in the path to discard the packet and return an ICMP error
        message if an MTU restriction is encountered. However, this approach
        has several serious shortcomings that lead to an overall
        &ldquo;brittleness&rdquo; <xref target="RFC2923"></xref>.</t>

        <t>In particular, site border routers in the Internet have been known
        to discard ICMP error messages coming from the outside world. This is
        due in large part to the fact that malicious spoofing of error
        messages in the Internet is trivial since there is no way to
        authenticate the source of the messages <xref
        target="RFC5927"></xref>. Furthermore, when a source node that
        requires ICMP error message feedback when a packet is dropped due to
        an MTU restriction does not receive the messages, a path MTU-related
        black hole occurs. This means that the source will continue to send
        packets that are too large and never receive an indication from the
        network that they are being discarded. This behavior has been
        confirmed through documented studies showing clear evidence of PMTUD
        failures for both IPv4 and IPv6 in the Internet today <xref
        target="TBIT"></xref><xref target="WAND"></xref><xref
        target="SIGCOMM"></xref>.</t>

        <t>The issues with both IP fragmentation and this
        &ldquo;classical&rdquo; PMTUD method are exacerbated further when IP
        tunneling is used <xref target="RFC4459"></xref>. For example, an
        ingress tunnel endpoint (ITE) may be required to forward encapsulated
        packets into the subnetwork on behalf of hundreds, thousands, or even
        more original sources. If the ITE allows IP fragmentation on the
        encapsulated packets, persistent fragmentation could lead to
        undetected data corruption due to Identification field wrapping and/or
        reassembly congestion at the ETE. If the ITE instead uses classical IP
        PMTUD it must rely on ICMP error messages coming from the subnetwork
        that may be suspect, subject to loss due to filtering middleboxes, or
        insufficiently provisioned for translation into error messages to be
        returned to the original sources.</t>

        <t>Although recent works have led to the development of a robust
        end-to-end MTU determination scheme <xref target="RFC4821"></xref>,
        they do not excuse tunnels from delivering PMTUD feedback when packets
        are lost due to size restrictions. Moreover, in current practice
        existing tunneling protocols mask the MTU issues by selecting a
        "lowest common denominator" MTU that may be much smaller than
        necessary for most paths and difficult to change at a later date.
        Therefore, a new approach to accommodate tunnels over links with
        diverse MTUs is necessary.</t>
      </section>

      <section title="Approach">
        <t>For the purpose of this document, a subnetwork is defined as a
        virtual topology configured over a connected network routing region
        and bounded by encapsulating border nodes. Example connected network
        routing regions include Mobile Ad hoc Networks (MANETs), enterprise
        networks and the global public Internet itself. Subnetwork border
        nodes forward unicast and multicast packets over the virtual topology
        across multiple IP and/or sub-IP layer forwarding hops that may
        introduce packet duplication and/or traverse links with diverse
        Maximum Transmission Units (MTUs).</t>

        <t>This document introduces a Subnetwork Encapsulation and Adaptation
        Layer (SEAL) for tunneling inner network layer protocol packets over
        IP subnetworks that connect Ingress and Egress Tunnel Endpoints
        (ITEs/ETEs) of border nodes. It provides a modular specification
        designed to be tailored to specific associated tunneling protocols. A
        transport-mode of operation is also possible, and described in
        Appendix C.</t>

        <t>SEAL provides a mid-layer encapsulation that accommodates links
        with diverse MTUs, and allows routers in the subnetwork to perform
        efficient duplicate packet and packet reordering detection. The
        encapsulation further ensures data origin authentication, packet
        header integrity and anti-replay in environments in which these
        functions are necessary.</t>

        <t>SEAL treats tunnels that traverse the subnetwork as ordinary links
        that must support network layer services. Moreover, SEAL provides
        dynamic mechanisms to ensure a maximal path MTU over the tunnel. This
        is in contrast to static approaches which avoid MTU issues by
        selecting a lowest common denominator MTU value that may be overly
        conservative for the vast majority of tunnel paths and difficult to
        change even when larger MTUs become available.</t>

        <t>The following sections provide the SEAL normative specifications,
        while the appendices present non-normative additional
        considerations.</t>
      </section>
    </section>

    <section title="Terminology and Requirements">
      <t>The following terms are defined within the scope of this
      document:</t>

      <t><list style="hanging">
          <t hangText="subnetwork"><vspace />a virtual topology configured
          over a connected network routing region and bounded by encapsulating
          border nodes.</t>

          <t hangText="IP"><vspace />used to generically refer to either
          Internet Protocol (IP) version, i.e., IPv4 or IPv6.</t>

          <t hangText="Ingress Tunnel Endpoint (ITE)"><vspace />a virtual
          interface over which an encapsulating border node (host or router)
          sends encapsulated packets into the subnetwork.</t>

          <t hangText="Egress Tunnel Endpoint (ETE)"><vspace />a virtual
          interface over which an encapsulating border node (host or router)
          receives encapsulated packets from the subnetwork.</t>

          <t hangText="ETE Link Path"><vspace />a subnetwork path from an ITE
          to an ETE beginning with an underlying link of the ITE as the first
          hop. Note that, if the ITE's interface connection to the underlying
          link assigns multiple IP addresses, each address represents a
          separate ETE link path.</t>

          <t hangText="inner packet"><vspace />an unencapsulated network layer
          protocol packet (e.g., IPv4 <xref target="RFC0791"></xref>, OSI/CLNP
          <xref target="RFC0994"></xref>, IPv6 <xref target="RFC2460"></xref>,
          etc.) before any outer encapsulations are added. Internet protocol
          numbers that identify inner packets are found in the IANA Internet
          Protocol registry <xref target="RFC3232"></xref>. SEAL protocol
          packets that incur an additional layer of SEAL encapsulation are
          also considered inner packets.</t>

          <t hangText="outer IP packet"><vspace />a packet resulting from
          adding an outer IP header (and possibly other outer headers) to a
          SEAL-encapsulated inner packet.</t>

          <t hangText="packet-in-error"><vspace />the leading portion of an
          invoking data packet encapsulated in the body of an error control
          message (e.g., an ICMPv4 <xref target="RFC0792"></xref> error
          message, an ICMPv6 <xref target="RFC4443"></xref> error message,
          etc.).</t>

          <t hangText="Packet Too Big (PTB) message"><vspace />a control plane
          message indicating an MTU restriction (e.g., an ICMPv6 "Packet Too
          Big" message <xref target="RFC4443"></xref>, an ICMPv4
          "Fragmentation Needed" message <xref target="RFC0792"></xref>,
          etc.).</t>

          <t hangText="Don't Fragment (DF) bit"><vspace />a bit that indicates
          whether the packet may be fragmented by the network. The DF bit is
          explicitly included in the IPv4 header <xref
          target="RFC0791"></xref> and may be set to '0' to allow
          fragmentation or '1' to disallow fragmentation. The bit is absent
          from the IPv6 header <xref target="RFC2460"></xref>, but implicitly
          set to '1'.</t>
        </list></t>

      <t>The following abbreviations correspond to terms used within this
      document and/or elsewhere in common Internetworking nomenclature:</t>

      <t><list>
          <t>ETE - Egress Tunnel Endpoint<vspace /></t>

          <t>HLEN - the length of the SEAL header plus outer
          headers<vspace /></t>

          <t>ICV - Integrity Check Vector<vspace /></t>

          <t>ITE - Ingress Tunnel Endpoint<vspace /></t>

          <t>MTU - Maximum Transmission Unit<vspace /></t>

          <t>SCMP - the SEAL Control Message Protocol<vspace /></t>

          <t>SDU - SCMP Destination Unreachable message<vspace /></t>

          <t>SPP - SCMP Parameter Problem message<vspace /></t>

          <t>SPTB - SCMP Packet Too Big message<vspace /></t>

          <t>SEAL - Subnetwork Encapsulation and Adaptation
          Layer<vspace /></t>

          <t>TE - Tunnel Endpoint (i.e., either ingress or egress)
          <vspace /></t>

          <t>VET - Virtual Enterprise Traversal<vspace /></t>
        </list></t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>. When used in lower case (e.g., must, must not,
      etc.), these words MUST NOT be interpreted as described in <xref
      target="RFC2119"></xref>, but are rather interpreted as they would be in
      common English.</t>
    </section>

    <section title="Applicability Statement">
      <t>SEAL was originally motivated by the specific case of subnetwork
      abstraction for Mobile Ad hoc Networks (MANETs), however the domain of
      applicability also extends to subnetwork abstractions over enterprise
      networks, ISP networks, SOHO networks, the global public Internet
      itself, and any other connected network routing region. SEAL, along with
      the Virtual Enterprise Traversal (VET) <xref
      target="I-D.templin-intarea-vet"></xref> tunnel virtual interface
      abstraction, are the functional building blocks for the Internet Routing
      Overlay Network (IRON) <xref target="I-D.templin-ironbis"></xref> and
      Routing and Addressing in Networks with Global Enterprise Recursion
      (RANGER) <xref target="RFC5720"></xref><xref target="RFC6139"></xref>
      architectures.</t>

      <t>SEAL provides a network sublayer for encapsulation of an inner
      network layer packet within outer encapsulating headers. SEAL can also
      be used as a sublayer within a transport layer protocol data payload,
      where transport layer encapsulation is typically used for Network
      Address Translator (NAT) traversal as well as operation over subnetworks
      that give preferential treatment to certain "core" Internet protocols
      (e.g., TCP, UDP, etc.). The SEAL header is processed the same as for
      IPv6 extension headers, i.e., it is not part of the outer IP header but
      rather allows for the creation of an arbitrarily extensible chain of
      headers in the same way that IPv6 does.</t>

      <t>To accommodate MTU diversity, the Egress Tunnel Endpoint (ETE) acts
      as a passive observer that simply informs the Ingress Tunnel Endpoint
      (ITE) of any packet size limitations. This allows the ITE to return
      appropriate PMTUD feedback even if the network path between the ITE and
      ETE filters ICMP messages.</t>

      <t>SEAL further provides mechanisms to ensure data origin
      authentication, packet header integrity, and anti-replay. The SEAL
      framework is therefore similar to the IP Security (IPsec) Authentication
      Header (AH) <xref target="RFC4301"></xref><xref
      target="RFC4302"></xref>, however it provides only minimal hop-by-hop
      authenticating services while leaving full data integrity,
      authentication and confidentiality services as an end-to-end
      consideration. While SEAL performs data origin authentication, the
      origin site must also perform the necessary ingress filtering in order
      to provide full source address verification <xref
      target="I-D.ietf-savi-framework"></xref>.</t>

      <t>In many aspects, SEAL also very closely resembles the Generic Routing
      Encapsulation (GRE) framework <xref target="RFC1701"></xref>. SEAL can
      therefore be applied in the same use cases that are traditionally
      addressed by GRE, and can also provide additional capabilities as
      described in this document.</t>
    </section>

    <section title="SEAL Specification">
      <t>The following sections specify the operation of SEAL:</t>

      <section title="VET Interface Model">
        <t>SEAL is an encapsulation sublayer used within VET non-broadcast,
        multiple access (NBMA) tunnel virtual interfaces. Each VET interface
        is configured over one or more underlying interfaces attached to
        subnetwork links. The VET interface connects an ITE to one or more ETE
        "neighbors" via tunneling across an underlying subnetwork, where the
        tunnel neighbor relationship may be either unidirectional or
        bidirectional.</t>

        <t>A unidirectional tunnel neighbor relationship allows the near end
        ITE to send data packets forward to the far end ETE, while the ETE
        only returns control messages when necessary. A bidirectional tunnel
        neighbor relationship is one over which both TEs can exchange both
        data and control messages.</t>

        <t>Implications of the VET unidirectional and bidirectional models are
        discussed in <xref target="I-D.templin-intarea-vet"></xref>.</t>
      </section>

      <section title="SEAL Model of Operation">
        <t>SEAL-enabled ITEs encapsulate each inner packet in a SEAL header
        and any outer header encapsulations as shown in <xref
        target="encaps1"></xref>:</t>

        <t><figure anchor="encaps1" title="SEAL Encapsulation">
            <artwork><![CDATA[                             +--------------------+  
                             ~   outer IP header  ~
                             +--------------------+
                             ~  other outer hdrs  ~
                             +--------------------+
                             ~    SEAL Header     ~
+--------------------+       +--------------------+
|                    |  -->  |                    |
~        Inner       ~  -->  ~        Inner       ~
~       Packet       ~  -->  ~       Packet       ~
|                    |  -->  |                    |
+--------------------+       +----------+---------+
]]></artwork>
          </figure></t>

        <t>The ITE inserts the SEAL header according to the specific tunneling
        protocol. For simple encapsulation of an inner network layer packet
        within an outer IP header, the ITE inserts the SEAL header following
        the outer IP header and before the inner packet as: IP/SEAL/{inner
        packet}.</t>

        <t>For encapsulations over transports such as UDP, the ITE inserts the
        SEAL header following the outer transport layer header and before the
        inner packet, e.g., as IP/UDP/SEAL/{inner packet}. In that case, the
        UDP header is seen as an "other outer header" as depicted in <xref
        target="encaps1"></xref>.</t>

        <t>SEAL supports both "nested" tunneling and "re-encapsulating"
        tunneling. Nested tunneling occurs when a first tunnel is encapsulated
        within a second tunnel, which may then further be encapsulated within
        additional tunnels. Nested tunneling can be useful, and stands in
        contrast to "recursive" tunneling which is an anomalous condition
        incurred due to misconfiguration or a routing loop. Considerations for
        nested tunneling are discussed in Section 4 of <xref
        target="RFC2473"></xref>.</t>

        <t>Re-encapsulating tunneling occurs when a packet arrives at a first
        ETE, which then acts as an ITE to re-encapsulate and forward the
        packet to a second ETE connected to the same subnetwork. In that case
        each ITE/ETE transition represents a segment of a bridged path between
        the ITE nearest the source and the ETE nearest the destination.
        Combinations of nested and re-encapsulating tunneling are also
        naturally supported by SEAL.</t>

        <t>The SEAL ITE considers each underlying interface as the ingress
        attachment point to a subnetwork link path to the ETE. The ITE
        therefore may experience different path MTUs on different ETE link
        paths.</t>

        <t>Finally, the SEAL ITE ensures that the inner network layer protocol
        will see a minimum MTU of 1500 bytes over each ETE link path
        regardless of the outer network layer protocol version, i.e., even if
        a small amount of fragmentation and reassembly are necessary. This is
        necessary to avoid path MTU "black holes" for the minimum MTU
        configured by the vast majority of links in the Internet.</t>
      </section>

      <section title="SEAL Header and Trailer Format">
        <t>The SEAL header is formatted as follows:</t>

        <t><figure anchor="minimal" title="SEAL Header Format ">
            <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |VER|C|A|R|L|I|V|X|M|   Offset  |    NEXTHDR    | LINK_ID |LEVEL|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Identification (optional)                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              Integrity Check Vector (ICV) (optional)          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure></t>

        <t><list style="hanging">
            <t hangText="VER (2)"><vspace />a 2-bit version field. This
            document specifies Version 0 of the SEAL protocol, i.e., the VER
            field encodes the value 0.</t>

            <t hangText="C (1)"><vspace />the "Control/Data" bit. Set to 1 by
            the ITE in SEAL Control Message Protocol (SCMP) control messages,
            and set to 0 in ordinary data packets.</t>

            <t hangText="A (1)"><vspace />the "Acknowledgement Requested" bit.
            Set to 1 by the ITE in SEAL data packets for which it wishes to
            receive an explicit acknowledgement from the ETE.</t>

            <t hangText="R (1)"><vspace />the "Redirects Permitted" bit. For
            data packets, set to 1 by the ITE to inform the ETE that the
            source is accepting Redirects (see:<xref
            target="I-D.templin-intarea-vet"> </xref>).</t>

            <t hangText="L (1)"><vspace />the "Rate Limit" bit for IPv4 ETE
            link paths. Reserved for future use for IPv6 ETE link paths.</t>

            <t hangText="I (1)"><vspace />the "Identification Included"
            bit.</t>

            <t hangText="V (1)"><vspace />the "ICV included" bit.</t>

            <t hangText="X (1)">a 1-bit reserved field.</t>

            <t hangText="M (1)">the "More Segments" bit. Set to 1 in a
            non-final segment and set to 0 in the final segment of the SEAL
            packet.</t>

            <t hangText="Offset (6)">a 6-bit Offset field. Set to 0 in the
            first segment of a segmented SEAL packet. Set to an integral
            number of 32 byte blocks in subsequent segments (e.g., an Offset
            of 10 indicates a block that begins at the 320th byte in the
            packet).</t>

            <t hangText="NEXTHDR (8)">an 8-bit field that encodes the next
            header Internet Protocol number the same as for the IPv4 protocol
            and IPv6 next header fields.</t>

            <t hangText="LINK_ID (5)"><vspace />a 5-bit link identification
            value, set to a unique value by the ITE for each link path over
            which it will send encapsulated packets to the ETE (up to 32 link
            paths per ETE are therefore supported). Note that, if the ITE's
            interface connection to the underlying link assigns multiple IP
            addresses, each address represents a separate ETE link path that
            must be assigned a separate LINK_ID.</t>

            <t hangText="LEVEL (3)"><vspace />a 3-bit nesting level; use to
            limit the number of tunnel nesting levels. Set to an integer value
            up to 7 in the innermost SEAL encapsulation, and decremented by 1
            for each successive additional SEAL encapsulation nesting level.
            Up to 8 levels of nesting are therefore supported.</t>

            <t hangText="Identification (32)"><vspace />an optional 32-bit
            per-packet identification field; present when I==1. Set to a
            monotonically-incrementing 32-bit value for each SEAL packet
            transmitted to this ETE, beginning with 0.</t>

            <t hangText="Integrity Check Vector (ICV) (32)"><vspace />an
            optional 32-bit header integrity check value; present when V==1.
            Covers the leading 128 bytes of the packet beginning with the SEAL
            header. The value 128 is chosen so that at least the SEAL header
            as well as the inner packet network and transport layer headers
            are covered by the integrity check.</t>
          </list></t>
      </section>

      <section title="ITE Specification">
        <section title="IP Protocol Constants">
          <t>SEAL observes the IP protocol constants for minimum link MTU
          (MINMTU) and minimum reassembly buffer (MINMRU) sizes.</t>

          <t>For IPv6, the ITE sets MINMTU=1280 and MINMRU=1500 (see: <xref
          target="RFC2460"></xref>).</t>

          <t>For IPv4, the ITE sets both MINMTU=576 and MINMRU=576 (see: <xref
          target="RFC1122"></xref>) i.e., even though the true MINMTU for IPv4
          is only 68 bytes (see: <xref target="RFC0791"></xref>).</t>
        </section>

        <section title="Tunnel Interface MTU">
          <t>The tunnel interface must present a constant MTU value to the
          inner network layer as the size for admission of inner packets into
          the interface. Since VET NBMA tunnel virtual interfaces may support
          a large set of ETE link paths that accept widely varying maximum
          packet sizes, however, a number of factors should be taken into
          consideration when selecting a tunnel interface MTU.</t>

          <t>Due to the ubiquitous deployment of standard Ethernet and similar
          networking gear, the nominal Internet cell size has become 1500
          bytes; this is the de facto size that end systems have come to
          expect will either be delivered by the network without loss due to
          an MTU restriction on the path or a suitable ICMP Packet Too Big
          (PTB) message returned. When large packets sent by end systems incur
          additional encapsulation at an ITE, however, they may be dropped
          silently within the tunnel since the network may not always deliver
          the necessary PTBs <xref target="RFC2923"></xref>. The ITE should
          therefore set a tunnel interface MTU of at least 1500 bytes.</t>

          <t>The inner network layer protocol consults the tunnel interface
          MTU when admitting a packet into the interface. For non-SEAL inner
          IPv4 packets with the IPv4 Don't Fragment (DF) bit set to 0, if the
          packet is larger than the tunnel interface MTU the inner IPv4 layer
          uses IPv4 fragmentation to break the packet into fragments no larger
          than the tunnel interface MTU. The ITE then admits each fragment
          into the interface as an independent packet.</t>

          <t>For all other inner packets, the inner network layer admits the
          packet if it is no larger than the tunnel interface MTU; otherwise,
          it drops the packet and sends a PTB error message to the source with
          the MTU value set to the tunnel interface MTU. The message contains
          as much of the invoking packet as possible without the entire
          message exceeding the network layer MINMTU size.</t>

          <t>The ITE can alternatively set an indefinite MTU on the tunnel
          interface such that all inner packets are admitted into the
          interface regardless of their size. For ITEs that host applications
          that use the tunnel interface directly, this option must be
          carefully coordinated with protocol stack upper layers since some
          upper layer protocols (e.g., TCP) derive their packet sizing
          parameters from the MTU of the outgoing interface and as such may
          select too large an initial size. This is not a problem for upper
          layers that use conservative initial maximum segment size estimates
          and/or when the tunnel interface can reduce the upper layer's
          maximum segment size, e.g., by reducing the size advertised in the
          MSS option of outgoing TCP messages (sometimes known as "MSS
          clamping").</t>

          <t>In light of the above considerations, the ITE should configure an
          indefinite MTU on tunnel *router* interfaces so that subnetwork
          adaptation is handled from within the interface. The ITE can instead
          set a smaller MTU on tunnel *host* interfaces (e.g., the smallest
          MTU among all of the underlying links minus the size of the
          encapsulation headers) but should not set an MTU smaller than 1500
          bytes.</t>
        </section>

        <section title="Tunnel Neighbor Soft State">
          <t>The tunnel virtual interface maintains a number of soft state
          variables for each ETE and for each ETE link path.</t>

          <t>When per-packet identification is required, the ITE maintains a
          per ETE window of Identification values for the packets it has
          recently sent to this ETE. The ITE then sets a variable "USE_ID" to
          TRUE, and includes an Identification in each packet it sends to this
          ETE; otherwise, it sets USE_ID to FALSE.</t>

          <t>When data origin authentication and integrity checking is
          required, the ITE also maintains a per ETE integrity check vector
          (ICV) calculation algorithm and a symmetric secret key to calculate
          the ICV in each packet it will send to this ETE. The ITE then sets a
          variable "USE_ICV" to TRUE, and includes an ICV in each packet it
          sends to this ETE; otherwise, it sets USE_ICV to FALSE.</t>

          <t>For IPv4 ETE link paths, the ITE further maintains a variable
          "RATE_LIMIT" initialized to FALSE. If the link path subsequently
          exhibits unavoidable IPv4 fragmentation the ETE sets RATE_LIMIT to
          TRUE.</t>

          <t>For each ETE link path, the ITE must also account for
          encapsulation header lengths. The ITE therefore maintains the per
          ETE link path constant values "SHLEN" set to the length of the SEAL
          header, "THLEN" set to the length of the outer encapsulating
          transport layer headers (or 0 if outer transport layer encapsulation
          is not used), "IHLEN" set to the length of the outer IP layer
          header, and "HLEN" set to (SHLEN+THLEN+IHLEN). (The ITE must include
          the length of the uncompressed headers even if header compression is
          enabled when calculating these lengths.) In addition, the ITE
          maintains a per ETE link path variable "PATH_MTU" initialized to the
          maximum of 1500 bytes and the MTU of the underlying link minus HLEN.
          (Thereafter, the ITE must not reduce PATH_MTU to a value smaller
          than 1500 bytes.)</t>

          <t>The ITE may instead maintain the packet sizing variables and
          constants as per ETE (rather than per ETE link path) values. In that
          case, the values reflect the lowest-common-denominator size across
          all of the ETE's link paths.</t>
        </section>

        <section title="Pre-Encapsulation">
          <t>For each inner packet admitted into the tunnel interface, if the
          packet is itself a SEAL packet (i.e., one with the port number for
          SEAL in the transport layer header or one with the protocol number
          for SEAL in the IP layer header) and the LEVEL field of the SEAL
          header contains the value 0, the ITE silently discards the
          packet.</t>

          <t>Otherwise, for non-atomic inner packets (i.e., a non-SEAL packet
          with (DF==0 || MF!=0 || Offset !=0) in the IP header), if the packet
          is larger than (MINMTU-HLEN) bytes the ITE fragments the packet into
          N roughly equal-length pieces, where N is minimized and each
          fragment is no larger than (MINMTU-HLEN). (For IPv6 SEAL packets
          that are no larger than 1500 bytes, SEAL segmentation based on the
          SEAL header is used rather than the outer IPv6 fragmentation.) The
          ITE then submits each inner fragment for SEAL encapsulation as
          specified in Section 4.4.5.</t>

          <t>For atomic inner packets (i.e., a SEAL packet and/or a packet
          with (DF==1 &amp;&amp; MF==0 &amp;&amp; Offset==0)), if the packet
          is larger than (MINMTU-HLEN) but no larger than 1500 bytes the ITE
          must ensure that it will traverse the tunnel using SEAL segmentation
          as specified in Section 4.4.5. For SEAL packets, the ITE then sends
          a SEAL PTB (SPTB) message toward the source address of the inner
          packet and the previous hop SEAL ITE will reduce the size of the
          SEAL segments it is sending. For non-SEAL IPv6 packets, the ITE
          sends an ICMPv6 PTB message toward the source and the original
          source will include an IPv6 fragment header in subsequent packets
          that it sends. The ITE writes (MINMTU-HLEN) in the MTU field of the
          PTB message.</t>

          <t>For atomic inner packets larger than 1500 bytes, if the packet is
          no larger than PATH_MTU for the corresponding ETE link path, the ITE
          submits it for SEAL encapsulation. Otherwise, the ITE drops the
          packet and sends a PTB error message toward the source address of
          the inner packet. To send the PTB message, the ITE first checks its
          forwarding tables to discover the previous hop toward the source
          address of the inner packet. If the previous hop is reached via the
          same tunnel interface, the ITE sends an SCMP PTB (SPTB) message to
          the previous hop (see: Section 4.6.1.1) with the MTU field set to
          PATH_MTU. Otherwise, the ITE sends an ordinary PTB message
          appropriate to the inner protocol version with the MTU field set to
          PATH_MTU. (For IPv4 SEAL packets with DF==0, the ITE should set DF=1
          and re-calculate the IPv4 header checksum before generating the PTB
          message in order to avoid bogon filters.) After sending the (S)PTB
          message, the ITE discards the inner packet.</t>
        </section>

        <section title="SEAL Encapsulation">
          <t>For each inner packet/fragment submitted for SEAL encapsulation,
          the ITE next encapsulates the packet in a SEAL header formatted as
          specified in Section 4.3. The SEAL header includes an Identification
          field when USE_ID is TRUE, followed by an ICV field when USE_ICV is
          TRUE.</t>

          <t>The ITE next sets C=0 in the SEAL header. The ITE also sets A=1
          if necessary for ETE reachability determination (see: Section 4.4.6)
          or for stateful MTU determination (see Section 4.4.9). Otherwise,
          the ITE sets A=0. Next, when RATE_LIMIT is TRUE the ITE sets L=1;
          otherwise, it sets L=0. The ITE also sets X=0.</t>

          <t>The ITE then sets R=1 if redirects are permitted (see: <xref
          target="I-D.templin-intarea-vet"></xref>). (Note that if this
          process is entered via re-encapsulation (see: Section 4.5.4), R is
          instead copied from the SEAL header of the re-encapsulated packet.
          This implies that the R value is propagated across a
          re-encapsulating chain of ITE/ETEs.)</t>

          <t>The ITE then sets LINK_ID to the value assigned to the underlying
          ETE link path, and sets NEXTHDR to the protocol number corresponding
          to the address family of the encapsulated inner packet. For example,
          the ITE sets NEXTHDR to the value '4' for encapsulated IPv4 packets
          <xref target="RFC2003"></xref>, '41' for encapsulated IPv6 packets
          <xref target="RFC2473"></xref><xref target="RFC4213"></xref>, '80'
          for encapsulated OSI/CLNP packets <xref target="RFC1070"></xref>,
          etc.</t>

          <t>Next, if the inner packet is not itself a SEAL packet the ITE
          sets LEVEL to an integer value between 0 and 7 as a specification of
          the number of additional layers of nested SEAL encapsulations
          permitted. If the inner packet is a SEAL packet that is undergoing
          nested encapsulation, the ITE instead sets LEVEL to the value that
          appears in the inner packet's SEAL header minus 1. If the inner
          packet is undergoing SEAL re-encapsulation, the ITE instead copies
          the LEVEL value from the SEAL header of the packet to be
          re-encapsulated.</t>

          <t>Next, if the inner packet is no larger than (MINMTU-HLEN) or
          larger than 1500, the ITE sets (M=0; Offset=0). Otherwise, the ITE
          breaks the packet into N roughly equal-length pieces that are no
          larger than (MINMTU-HLEN) and appends a clone of the SEAL header
          from the first piece onto the head of each additional piece. The ITE
          then sets (M=1; Offset=0) in the first piece, sets (M=0/1; Offset=i)
          in the second piece, sets (M=0/1; Offset=2i) n the third piece (if
          needed), etc., then finally sets (M=0; Offset=(N-1)i) in the final
          piece.</t>

          <t>When USE_ID is FALSE, the ITE next sets I=0. Otherwise, the ITE
          sets I=1 and writes a monotonically-increasing integer value for
          this ETE in the Identification field beginning with 0 in the first
          packet transmitted. (For SEAL packets that have been split into
          multiple pieces, the ITE writes the same Identification value in
          each piece.)</t>

          <t>When USE_ICV is FALSE, the ITE next sets V=0. Otherwise, the ITE
          sets V=1 and calculates the packet header ICV value using an
          algorithm agreed on by the ITE and ETE. When data origin
          authentication is required, the algorithm uses a symmetric secret
          key so that the ETE can verify that the ICV was generated by the
          ITE. Beginning with the SEAL header, the ITE calculates the ICV over
          the leading 128 bytes of the packet (or up to the end of the packet
          if there are fewer than 128 bytes) and places result in the ICV
          field. (For SEAL packets that have been split into two pieces, each
          piece calculates its own ICV value.)</t>

          <t>The ITE then adds the outer encapsulating headers as specified in
          Section 4.4.6.</t>
        </section>

        <section title="Outer Encapsulation">
          <t>Following SEAL encapsulation, the ITE next encapsulates each
          packet in the requisite outer transport (when necessary) and IP
          layer headers. When a transport layer header is included, the ITE
          writes the port number for SEAL in the transport destination service
          port field and writes the protocol number of the transport protocol
          in the outer IP header protocol field. Otherwise, the ITE writes the
          protocol number for SEAL in the outer IP header protocol field.</t>

          <t>The ITE then sets the other fields of the outer transport and IP
          layer headers as specified in Sections 5.5.4 and 5.5.5 of<xref
          target="I-D.templin-intarea-vet"> </xref>. If this process is
          entered via re-encapsulation (see: Section 4.5.4), the ITE instead
          follows the re-encapsulation procedures specified in Section 5.5.6
          of <xref target="I-D.templin-intarea-vet"></xref>.</t>

          <t>For IPv4 ETE link paths, the ITE sets DF=0 in the IPv4 header to
          allow the packet to be fragmented if it encounters a restricting
          link. (For IPv6 link paths, the DF bit is implicitly set to 1.)</t>

          <t>The ITE then sends each outer packet/fragment via the underlying
          link corresponding to LINK_ID. For IPv4 ETE link paths with
          RATE_LIMIT=TRUE, the ITE sends the packet subject to rate limiting
          so that the IPv4 Identification value is not repeated within the
          IPv4 Maximum Segment Lifetime (i.e., 120 seconds) <xref
          target="RFC1122"></xref>.</t>
        </section>

        <section title="Path Probing and ETE Reachability Verification">
          <t>All SEAL data packets sent by the ITE are considered implicit
          probes. SEAL data packets will elicit an SCMP message from the ETE
          if it needs to acknowledge a probe and/or report an error condition.
          SEAL data packets may also be dropped by either the ETE or a router
          on the path, which will return an ICMP message.</t>

          <t>The ITE can also send an SCMP Router/Neighbor Solicitation
          message to elicit an SCMP Router/Neighbor Advertisement response
          (see: <xref target="I-D.templin-intarea-vet"></xref>) as
          verification that the ETE is still reachable via a specific link
          path.</t>

          <t>The ITE processes ICMP messages as specified in Section
          4.4.7.</t>

          <t>The ITE processes SCMP messages as specified in Section
          4.6.2.</t>
        </section>

        <section title="Processing ICMP Messages">
          <t>When the ITE sends SEAL packets, it may receive ICMP error
          messages <xref target="RFC0792"></xref><xref
          target="RFC4443"></xref> from an ordinary router within the
          subnetwork or from another ITE on the path to the ETE (i.e., in case
          of nested encapsulations). Each ICMP message includes an outer IP
          header, followed by an ICMP header, followed by a portion of the
          SEAL data packet that generated the error (also known as the
          "packet-in-error") beginning with the outer IP header.</t>

          <t>The ITE should process ICMPv4 Protocol Unreachable messages and
          ICMPv6 Parameter Problem messages with Code "Unrecognized Next
          Header type encountered" as a hint that the ETE does not implement
          the SEAL protocol. The ITE can also process other ICMP messages that
          do not include sufficient information in the packet-in-error as a
          hint that the ETE link path may be failing. Specific actions that
          the ITE may take in these cases are out of scope.</t>

          <t>For other ICMP messages, the ITE should use any outer header
          information available as a first-pass authentication filter (e.g.,
          to determine if the source of the message is within the same
          administrative domain as the ITE) and discards the message if first
          pass filtering fails.</t>

          <t>Next, the ITE examines the packet-in-error beginning with the
          SEAL header. If the value in the Identification field (if present)
          is not within the window of packets the ITE has recently sent to
          this ETE, or if the value in the SEAL header ICV field (if present)
          is incorrect, the ITE discards the message.</t>

          <t>Next, if the received ICMP message is a PTB the ITE sets the
          temporary variable "PMTU" for this ETE link path to the MTU value in
          the PTB message. If PMTU==0, the ITE consults a plateau table (e.g.,
          as described in <xref target="RFC1191"></xref>) to determine PMTU
          based on the length field in the outer IP header of the
          packet-in-error. For example, if the ITE receives a PTB message with
          MTU==0 and length 4KB, it can set PMTU=2KB. If the ITE subsequently
          receives a PTB message with MTU==0 and length 2KB, it can set
          PMTU=1792, etc. to a minimum value of PMTU=(1500+HLEN). If the ITE
          is performing stateful MTU determination for this ETE link path (see
          Section 4.4.9), the ITE next sets PATH_MTU=MAX((PMTU-HLEN),
          1500).</t>

          <t>If the ICMP message was not discarded, the ITE then transcribes
          it into a message to return to the previous hop. If the previous hop
          toward the inner source address within the packet-in-error is
          reached via the same tunnel interface the SEAL data packet was sent
          on, the ITE transcribes the ICMP message into an SCMP message.
          Otherwise, the ITE transcribes the ICMP message into a message
          appropriate for the inner protocol version.</t>

          <t>To transcribe the message, the ITE extracts the inner packet from
          within the ICMP message packet-in-error field and uses it to
          generate a new message corresponding to the type of the received
          ICMP message. For SCMP messages, the ITE generates the message the
          same as described for ETE generation of SCMP messages in Section
          4.6.1. For (S)PTB messages, the ITE writes (PMTU-HLEN) in the MTU
          field.</t>

          <t>The ITE finally forwards the transcribed message to the previous
          hop toward the inner source address.</t>
        </section>

        <section title="IPv4 Middlebox Reassembly Testing">
          <t>The ITE can perform a qualification exchange to ensure that the
          subnetwork correctly delivers fragments to the ETE. This procedure
          can be used, e.g., to determine whether there are middleboxes on the
          path that violate the <xref target="RFC1812"></xref>, Section 5.2.6
          requirement that: "A router MUST NOT reassemble any datagram before
          forwarding it".</t>

          <t>The ITE should use knowledge of its topological arrangement as an
          aid in determining when middlebox reassembly testing is necessary.
          For example, if the ITE is aware that the ETE is located somewhere
          in the public Internet, middlebox reassembly testing should not be
          necessary. If the ITE is aware that the ETE is located behind a NAT
          or a firewall, however, then middlebox reassembly testing is
          recommended.</t>

          <t>The ITE can perform a middlebox reassembly test by selecting a
          data packet to be used as a probe. While performing the test with
          real data packets, the ITE should select only inner packets that are
          no larger than (1500-HLEN) bytes for testing purposes. The ITE can
          also construct a dummy probe packet instead of using ordinary SEAL
          data packets.</t>

          <t>To generate a dummy probe packet, the ITE creates a packet buffer
          beginning with the same outer headers, SEAL header and inner network
          layer header that would appear in an ordinary data packet, then pads
          the packet with random data to a length that is at least 128 bytes
          but no longer than (1500-HLEN) bytes. The ITE then writes the value
          '0' in the inner network layer TTL (for IPv4) or Hop Limit (for
          IPv6) field.</t>

          <t>The ITE then sets (C=0; R=0) in the SEAL header of the probe
          packet and sets the NEXTHDR field to the inner network layer
          protocol type. (The ITE may also set A=1 if it requires a positive
          acknowledgement; otherwise, it sets A=0.) Next, the ITE sets LINK_ID
          and LEVEL to the appropriate values for this ETE link path, sets
          Identification and I=1 (when USE_ID is TRUE), then finally
          calculates the ICV and sets V=1(when USE_ICV is TRUE).</t>

          <t>The ITE then encapsulates the probe packet in the appropriate
          outer headers, splits it into two outer IPv4 fragments, then sends
          both fragments over the same ETE link path.</t>

          <t>The ITE should send a series of probe packets (e.g., 3-5 probes
          with 1sec intervals between tests) instead of a single isolated
          probe in case of packet loss. If the ETE returns an SCMP PTB message
          with MTU != 0, then the ETE link path correctly supports
          fragmentation; otherwise, the ITE enables stateful MTU determination
          for this ETE link path as specified in Section 4.4.9.</t>

          <t>(Examples of middleboxes that may perform reassembly include
          stateful NATs and firewalls. Such devices could still allow for
          stateless MTU determination if they gather the fragments of a
          fragmented IPv4 SEAL data packet for packet analysis purposes but
          then forward the fragments on to the final destination rather than
          forwarding the reassembled packet.)</t>
        </section>

        <section title="Stateful MTU Determination">
          <t>SEAL supports a stateless MTU determination capability, however
          the ITE may in some instances wish to impose a stateful MTU limit on
          a particular ETE link path. For example, when the ETE is situated
          behind a middlebox that performs IPv4 reassembly (see: Section
          4.4.8) it is imperative that fragmentation be avoided. In other
          instances (e.g., when the ETE link path includes
          performance-constrained links), the ITE may deem it necessary to
          cache a conservative static MTU in order to avoid sending large
          packets that would only be dropped due to an MTU restriction
          somewhere on the path.</t>

          <t>To determine a static MTU value, the ITE can send a series of
          dummy probe packets of various sizes to the ETE with A=1 in the SEAL
          header and DF=1 in the outer IP header. The ITE can then cache the
          size 'S' of the largest packet for which it receives a probe reply
          from the ETE by setting PATH_MTU=MAX((S-HLEN), 1500) for this ETE
          link path.</t>

          <t>For example, the ITE could send probe packets of 4KB, followed by
          2KB, followed by 1792 bytes, etc. While probing, the ITE processes
          any ICMP PTB message it receives as a potential indication of probe
          failure then discards the message.</t>
        </section>

        <section title="Detecting Path MTU Changes">
          <t>When stateful determination is used, the ITE can periodically
          reset PATH_MTU and/or re-probe the path to determine whether
          PATH_MTU has increased. If the path still has a too-small MTU, the
          ITE will receive a PTB message that reports a smaller size.</t>

          <t>For IPv4 ETE link paths, when the path correctly implements
          fragmentation and RATE_LIMIT is TRUE, the ITE can periodically reset
          RATE_LIMIT=FALSE to determine whether the path still requires rate
          limiting. If the ITE receives an SPTB message it should again set
          RATE_LIMIT=TRUE.</t>
        </section>
      </section>

      <section title="ETE Specification">
        <section title="Tunnel Neighbor Soft State">
          <t>When data origin authentication and integrity checking is
          required, the ETE maintains a per-ITE ICV calculation algorithm and
          a symmetric secret key to verify the ICV. When per-packet
          identification is required, the ETE also maintains a window of
          Identification values for the packets it has recently received from
          this ITE.</t>

          <t>When the tunnel neighbor relationship is bidirectional, the ETE
          further maintains a per ETE link path mapping of outer IP and
          transport layer addresses to the LINK_ID that appears in packets
          received from the ITE.</t>
        </section>

        <section title="IP-Layer Reassembly">
          <t>The ETE should maintain conservative reassembly cache high- and
          low-water marks. When the size of the reassembly cache exceeds this
          high-water mark, the ETE should actively discard stale incomplete
          reassemblies (e.g., using an Active Queue Management (AQM) strategy)
          until the size falls below the low-water mark. The ETE should also
          actively discard any pending reassemblies that clearly have no
          opportunity for completion, e.g., when a considerable number of new
          fragments have arrived before a fragment that completes a pending
          reassembly arrives.</t>

          <t>The ETE processes non-SEAL IP packets as specified in the
          normative references, i.e., it performs any necessary IP reassembly
          then discards the packet if it is larger than the reassembly buffer
          size or delivers the (fully-reassembled) packet to the appropriate
          upper layer protocol module.</t>

          <t>For SEAL packets, the ITE performs any necessary IP reassembly
          then submits the packet for SEAL decapsulation as specified in
          Section 4.5.3. (Note that if the packet is larger than the
          reassembly buffer size, the ITE still returns the leading portion of
          the (partially) reassembled packet.)</t>
        </section>

        <section title="Decapsulation and Re-Encapsulation">
          <t>For each SEAL packet accepted for decapsulation, when I==1 the
          ETE first examines the Identification field. If the Identification
          is not within the window of acceptable values for this ITE, the ETE
          silently discards the packet.</t>

          <t>Next, if V==1 the ETE verifies the ICV value (with the ICV field
          itself reset to 0) and silently discards the packet if the value is
          incorrect.</t>

          <t>Next, if the packet arrived as multiple IPv4 fragments and L ==0,
          the ETE sends an SPTB message back to the ITE with MTU set to the
          size of the largest fragment received minus HLEN (see: Section
          4.6.1.1).</t>

          <t>Next, if the packet arrived as multiple IP fragments and the
          inner packet is larger than 1500 bytes, the ETE silently discards
          the packet; otherwise, it continues to process the packet.</t>

          <t>Next, if there is an incorrect value in a SEAL header field
          (e.g., an incorrect "VER" field value), the ETE discards the packet.
          If the SEAL header has C==0, the ETE also returns an SCMP "Parameter
          Problem" (SPP) message (see Section 4.6.1.2).</t>

          <t>Next, if the SEAL header has C==1, the ETE processes the packet
          as an SCMP packet as specified in Section 4.6.2. Otherwise, the ETE
          continues to process the packet as a SEAL data packet.</t>

          <t>Next, if the SEAL header has (M==1 || Offset!==0) the ETE checks
          to see if the other segments of this already-segmented SEAL packet
          have arrived, i.e., by looking for additional segments that have the
          same outer IP source address, source transport port number (if
          present) and SEAL Identification value. If the other segments have
          already arrived, the ETE discards the SEAL header and other outer
          headers from the non-initial segments and appends them onto the end
          of the first segment. Otherwise, the ETE caches the segment for at
          most 60 seconds while awaiting the arrival of its partners. To
          support this process, the ETE must be able to buffer segmented SEAL
          packets up to (1500+HLEN) bytes in length.</t>

          <t>Next, if the SEAL header in the (reassembled) packet has A==1,
          the ETE sends an SPTB message back to the ITE with MTU=0 (see:
          Section 4.6.1.1).</t>

          <t>Finally, the ETE discards the outer headers and processes the
          inner packet according to the header type indicated in the SEAL
          NEXTHDR field. If the inner (TTL / Hop Limit) field encodes the
          value 0, the ETE silently discards the packet. Otherwise, if the
          next hop toward the inner destination address is via a different
          interface than the SEAL packet arrived on, the ETE discards the SEAL
          header and delivers the inner packet either to the local host or to
          the next hop interface if the packet is not destined to the local
          host.</t>

          <t>If the next hop is on the same interface the SEAL packet arrived
          on, however, the ETE submits the packet for SEAL re-encapsulation
          beginning with the specification in Section 4.4.3 above and without
          decrementing the value in the inner (TTL / Hop Limit) field. In this
          process, the packet remains within the tunnel (i.e., it does not
          exit and then re-enter the tunnel); hence, the packet is not
          discarded if the LEVEL field in the SEAL header contains the value
          0.</t>
        </section>
      </section>

      <section title="The SEAL Control Message Protocol (SCMP)">
        <t>SEAL provides a companion SEAL Control Message Protocol (SCMP) that
        uses the same message types and formats as for the Internet Control
        Message Protocol for IPv6 (ICMPv6) <xref target="RFC4443"></xref>. As
        for ICMPv6, each SCMP message includes a 32-bit header and a
        variable-length body. The ITE encapsulates the SCMP message in a SEAL
        header and outer headers as shown in <xref
        target="scmpencaps"></xref>:</t>

        <t><figure anchor="scmpencaps" title="SCMP Message Encapsulation">
            <artwork><![CDATA[                                    +--------------------+
                                    ~   outer IP header  ~
                                    +--------------------+
                                    ~  other outer hdrs  ~
                                    +--------------------+
                                    ~    SEAL Header     ~
       +--------------------+       +--------------------+
       | SCMP message header|  -->  | SCMP message header|
       +--------------------+       +--------------------+
       |                    |  -->  |                    |
       ~  SCMP message body ~  -->  ~  SCMP message body ~
       |                    |  -->  |                    |
       +--------------------+       +--------------------+
 
            SCMP Message                  SCMP Packet
        before encapsulation          after encapsulation]]></artwork>
          </figure></t>

        <t>The following sections specify the generation, processing and
        relaying of SCMP messages.</t>

        <section title="Generating SCMP Error Messages">
          <t>ETEs generate SCMP error messages in response to receiving
          certain SEAL data packets using the format shown in <xref
          target="control2"></xref>:</t>

          <t><figure anchor="control2" title="SCMP Error Message Format">
              <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |     Code      |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Type-Specific Data                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      As much of the invoking SEAL data packet as possible     |
   ~       (beginning with the SEAL header) without the SCMP       ~
   |             packet exceeding MINMTU bytes (*)                 |

   (*) also known as the "packet-in-error"]]></artwork>
            </figure>The error message includes the 32-bit SCMP message
          header, followed by a 32-bit Type-Specific Data field, followed by
          the leading portion of the invoking SEAL data packet beginning with
          the SEAL header as the "packet-in-error". The packet-in-error
          includes as much of the invoking packet as possible extending to a
          length that would not cause the entire SCMP packet following outer
          encapsulation to exceed MINMTU bytes.</t>

          <t>When the ETE processes a SEAL data packet for which the
          Identification and ICV values are correct but an error must be
          returned, it prepares an SCMP error message as shown in <xref
          target="control2"></xref>. The ETE sets the Type and Code fields to
          the same values that would appear in the corresponding ICMPv6
          message <xref target="RFC4443"></xref>, but calculates the Checksum
          beginning with the SCMP message header using the algorithm specified
          for ICMPv4 in <xref target="RFC0792"></xref>.</t>

          <t>The ETE next encapsulates the SCMP message in the requisite SEAL
          and outer headers as shown in <xref target="scmpencaps"></xref>.
          During encapsulation, the ETE sets the outer destination
          address/port numbers of the SCMP packet to the values associated
          with the ITE and sets the outer source address/port numbers to its
          own outer address/port numbers.</t>

          <t>The ETE then sets (C=1; A=0; R=0; L=0; X=0; M=0; Offset=0) in the
          SEAL header, then sets I, V, NEXTHDR and LEVEL to the same values
          that appeared in the SEAL header of the data packet. If the neighbor
          relationship between the ITE and ETE is unidirectional, the ETE next
          sets the LINK_ID field to the same value that appeared in the SEAL
          header of the data packet. Otherwise, the ETE sets the LINK_ID field
          to the value it would use in sending a SEAL packet to this ITE.</t>

          <t>When I==1, the ETE next sets the Identification field to an
          appropriate value for the ITE. If the neighbor relationship between
          the ITE and ETE is unidirectional, the ETE sets the Identification
          field to the same value that appeared in the SEAL header of the data
          packet. Otherwise, the ETE sets the Identification field to the
          value it would use in sending the next SEAL packet to this ITE.</t>

          <t>When V==1, the ETE then calculates and sets the ICV field the
          same as specified for SEAL data packet encapsulation in Section
          4.4.4.</t>

          <t>Finally, the ETE sends the resulting SCMP packet to the ITE the
          same as specified for SEAL data packets in Section 4.4.5.</t>

          <t>The following sections describe additional considerations for
          various SCMP error messages:</t>

          <section title="Generating SCMP Packet Too Big (SPTB) Messages">
            <t>An ETE generates an SCMP "Packet Too Big" (SPTB) message when
            it receives a SEAL data packet that arrived as multiple outer IPv4
            fragments and for which L==0. The ETE prepares the SPTB message
            the same as for the corresponding ICMPv6 PTB message, and writes
            the length of the largest outer IP fragment received minus HLEN in
            the MTU field of the message.</t>

            <t>An ETE also generates an SPTB message when it needs to segment
            a SEAL packet that was prepared by an earlier SEAL ITE (see
            Section 4.4.4). The ITE writes the value (MINMTU-HLEN) in the MTU
            field.</t>

            <t>Finally, the ETE also generates an SPTB message when it accepts
            a SEAL protocol data packet with A==1 in the SEAL header. The ETE
            prepares the SPTB message the same as above, except that it writes
            the value 0 in the MTU field.</t>
          </section>

          <section title="Generating Other SCMP Error Messages">
            <t>An ETE generates an SCMP "Destination Unreachable" (SDU)
            message under the same circumstances that an IPv6 system would
            generate an ICMPv6 Destination Unreachable message.</t>

            <t>An ETE generates an SCMP "Parameter Problem" (SPP) message when
            it receives a SEAL packet with an incorrect value in the SEAL
            header.</t>

            <t>TEs generate other SCMP message types using methods and
            procedures specified in other documents. For example, SCMP message
            types used for tunnel neighbor coordinations are specified in VET
            <xref target="I-D.templin-intarea-vet"></xref>.</t>
          </section>
        </section>

        <section title="Processing SCMP Error Messages">
          <t>An ITE may receive SCMP messages with C==1 in the SEAL header
          after sending packets to an ETE. The ITE first verifies that the
          outer addresses of the SCMP packet are correct, and (when I==1) that
          the Identification field contains an acceptable value. The ITE next
          verifies that the SEAL header fields are set correctly as specified
          in Section 4.6.1. When V==1, the ITE then verifies the ICV value.
          The ITE next verifies the Checksum value in the SCMP message header.
          If any of these values are incorrect, the ITE silently discards the
          message; otherwise, it processes the message as follows:</t>

          <section title="Processing SCMP PTB Messages">
            <t>After an ITE sends a SEAL data packet to an ETE, it may receive
            an SPTB message with a packet-in-error containing the leading
            portion of the packet (see: Section 4.6.1.1). For IP SPTB messages
            with MTU==0, the ITE processes the message as confirmation that
            the ETE received a SEAL data packet with A==1 in the SEAL header.
            The ITE then discards the message.</t>

            <t>For SPTB messages with MTU != 0, the ITE processes the message
            as an indication of a packet size limitation as follows. If the
            inner packet is itself a SEAL packet, and the inner packet length
            is less than 1500, the ITE reduces its MINMTU value for this ITE.
            If the inner packet is a non-SEAL IPv4 packet and the inner packet
            length is less than 1500, the ITE instead sets RATE_LIMIT=1. For
            all other cases, if the inner packet is larger than 1500 and the
            MTU value is not substantially less than 1500 bytes, the value is
            likely to reflect the true MTU of the restricting link on the path
            to the ETE; otherwise, a router on the path may be generating runt
            fragments.</t>

            <t>In that case, the ITE can consult a plateau table (e.g., as
            described in <xref target="RFC1191"></xref>) to rewrite the MTU
            value to a reduced size. For example, if the ITE receives an IPv4
            SPTB message with MTU==256 and inner packet length 4KB, it can
            rewrite the MTU to 2KB. If the ITE subsequently receives an IPv4
            SPTB message with MTU==256 and inner packet length 2KB, it can
            rewrite the MTU to 1792, etc., to a minimum of 1500 bytes. If the
            ITE is performing stateful MTU determination for this ETE link
            path, it then writes the new MTU value minus HLEN in PATH_MTU.</t>

            <t>The ITE then checks its forwarding tables to discover the
            previous hop toward the source address of the inner packet. If the
            previous hop is reached via the same tunnel interface the SPTB
            message arrived on, the ITE relays the message to the previous
            hop. In order to relay the message, the first writes zero in the
            Identification and ICV fields of the SEAL header within the
            packet-in-error. The ITE next rewrites the outer SEAL header
            fields with values corresponding to the previous hop and
            recalculates the ICV using the ICV calculation parameters
            associated with the previous hop. Next, the ITE replaces the
            SPTB's outer headers with headers of the appropriate protocol
            version and fills in the header fields as specified in Sections
            5.5.4-5.5.6 of <xref target="I-D.templin-intarea-vet"></xref>,
            where the destination address/port correspond to the previous hop
            and the source address/port correspond to the ITE. The ITE then
            sends the message to the previous hop the same as if it were
            issuing a new SPTB message. (Note that, in this process, the
            values within the SEAL header of the packet-in-error are
            meaningless to the previous hop and therefore cannot be used by
            the previous hop for authentication purposes.)</t>

            <t>If the previous hop is not reached via the same tunnel
            interface, the ITE instead transcribes the message into a format
            appropriate for the inner packet (i.e., the same as described for
            transcribing ICMP messages in Section 4.4.7) and sends the
            resulting transcribed message to the original source. (NB: if the
            inner packet within the SPTB message is an IPv4 SEAL packet with
            DF==0, the ITE should set DF=1 and re-calculate the IPv4 header
            checksum while transcribing the message in order to avoid bogon
            filters.) The ITE then discards the SPTB message.</t>
          </section>

          <section title="Processing Other SCMP Error Messages">
            <t>An ITE may receive an SDU message with an appropriate code
            under the same circumstances that an IPv6 node would receive an
            ICMPv6 Destination Unreachable message. The ITE either transcribes
            or relays the message toward the source address of the inner
            packet within the packet-in-error the same as specified for SPTB
            messages in Section 4.6.2.1.</t>

            <t>An ITE may receive an SPP message when the ETE receives a SEAL
            packet with an incorrect value in the SEAL header. The ITE should
            examine the SEAL header within the packet-in-error to determine
            whether a different setting should be used in subsequent packets,
            but does not relay the message further.</t>

            <t>TEs process other SCMP message types using methods and
            procedures specified in other documents. For example, SCMP message
            types used for tunnel neighbor coordinations are specified in VET
            <xref target="I-D.templin-intarea-vet"></xref>.</t>
          </section>
        </section>
      </section>
    </section>

    <section title="Link Requirements">
      <t>Subnetwork designers are expected to follow the recommendations in
      Section 2 of <xref target="RFC3819"></xref> when configuring link
      MTUs.</t>
    </section>

    <section title="End System Requirements">
      <t>End systems are encouraged to implement end-to-end MTU assurance
      (e.g., using Packetization Layer PMTUD per <xref
      target="RFC4821"></xref>) even if the subnetwork is using SEAL.</t>
    </section>

    <section title="Router Requirements">
      <t>Routers within the subnetwork are expected to observe the router
      requirements found in the normative references, including the
      implementation of IP fragmentation and reassembly <xref
      target="RFC1812"></xref><xref target="RFC2460"></xref> as well as the
      generation of ICMP messages <xref target="RFC0792"></xref><xref
      target="RFC4443"></xref>.</t>
    </section>

    <section title="Nested Encapsulation Considerations">
      <t>SEAL supports nested tunneling for up to 8 layers of encapsulation.
      In this model, the SEAL ITE has a tunnel neighbor relationship only with
      ETEs at its own nesting level, i.e., it does not have a tunnel neighbor
      relationship with other ITEs, nor with ETEs at other nesting levels.</t>

      <t>Therefore, when an ITE 'A' within an inner nesting level needs to
      return an error message to an ITE 'B' within an outer nesting level, it
      generates an ordinary ICMP error message the same as if it were an
      ordinary router within the subnetwork. 'B' can then perform message
      validation as specified in Section 4.4.7, but full message origin
      authentication is not possible.</t>

      <t>Since ordinary ICMP messages are used for coordinations between ITEs
      at different nesting levels, nested SEAL encapsulations should only be
      used when the ITEs are within a common administrative domain and/or when
      there is no ICMP filtering middlebox such as a firewall or NAT between
      them. An example would be a recursive nesting of mobile networks, where
      the first network receives service from an ISP, the second network
      receives service from the first network, the third network receives
      service from the second network, etc.</t>

      <t>NB: As an alternative, the SCMP protocol could be extended to allow
      ITE 'A' to return an SCMP message to ITE 'B' rather than return an ICMP
      message. This would conceptually allow the control messages to pass
      through firewalls and NATs, however it would give no more message origin
      authentication assurance than for ordinary ICMP messages. It was
      therefore determined that the complexity of extending the SCMP protocol
      was of little value within the context of the anticipated use cases for
      nested encapsulations.</t>
    </section>

    <section title="IANA Considerations">
      <t>The IANA is instructed to allocate a System Port number for "SEAL" in
      the 'port-numbers' registry for the TCP, UDP, DCCP and SCTP
      protocols.</t>

      <t>The IANA is further instructed to allocate an IP protocol number for
      "SEAL" in the "protocol-numbers" registry.</t>

      <t>Considerations for port and protocol number assignments appear in
      <xref target="RFC2780"></xref><xref target="RFC5226"></xref><xref
      target="RFC6335"></xref>.</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>SEAL provides a segment-by-segment data origin authentication and
      anti-replay service across the (potentially) multiple segments of a
      re-encapsulating tunnel. It further provides a segment-by-segment
      integrity check of the headers of encapsulated packets, but does not
      verify the integrity of the rest of the packet beyond the headers unless
      fragmentation is unavoidable. SEAL therefore considers full message
      integrity checking, authentication and confidentiality as end-to-end
      considerations in a manner that is compatible with securing mechanisms
      such as TLS/SSL <xref target="RFC5246"></xref>.</t>

      <t>An amplification/reflection/buffer overflow attack is possible when
      an attacker sends IP fragments with spoofed source addresses to an ETE
      in an attempt to clog the ETE's reassembly buffer and/or cause the ETE
      to generate a stream of SCMP messages returned to a victim ITE. The SCMP
      message ICV, Identification, as well as the inner headers of the
      packet-in-error, provide mitigation for the ETE to detect and discard
      SEAL segments with spoofed source addresses.</t>

      <t>The SEAL header is sent in-the-clear the same as for the outer IP and
      other outer headers. In this respect, the threat model is no different
      than for IPv6 extension headers. Unlike IPv6 extension headers, however,
      the SEAL header can be protected by an integrity check that also covers
      the inner packet headers.</t>

      <t>Security issues that apply to tunneling in general are discussed in
      <xref target="RFC6169"></xref>.</t>
    </section>

    <section title="Related Work">
      <t>Section 3.1.7 of <xref target="RFC2764"></xref> provides a high-level
      sketch for supporting large tunnel MTUs via a tunnel-level segmentation
      and reassembly capability to avoid IP level fragmentation.</t>

      <t>Section 3 of <xref target="RFC4459"> </xref> describes inner and
      outer fragmentation at the tunnel endpoints as alternatives for
      accommodating the tunnel MTU.</t>

      <t>Section 4 of <xref target="RFC2460"></xref> specifies a method for
      inserting and processing extension headers between the base IPv6 header
      and transport layer protocol data. The SEAL header is inserted and
      processed in exactly the same manner.</t>

      <t>IPsec/AH is <xref target="RFC4301"></xref><xref
      target="RFC4301"></xref> is used for full message integrity verification
      between tunnel endpoints, whereas SEAL only ensures integrity for the
      inner packet headers. The AYIYA proposal <xref
      target="I-D.massar-v6ops-ayiya"></xref> uses similar means for providing
      message authentication and integrity.</t>

      <t>The concepts of path MTU determination through the report of
      fragmentation and extending the IPv4 Identification field were first
      proposed in deliberations of the TCP-IP mailing list and the Path MTU
      Discovery Working Group (MTUDWG) during the late 1980's and early
      1990's. An historical analysis of the evolution of these concepts, as
      well as the development of the eventual PMTUD mechanism, appears in
      Appendix D of this document.</t>
    </section>

    <section title="Implementation Status">
      <t>An early implementation of the first revision of SEAL <xref
      target="RFC5320"></xref> is available at:
      http://isatap.com/seal/pre-rfc5320.txt</t>
    </section>

    <section anchor="acknowledge" title="Acknowledgments">
      <t>The following individuals are acknowledged for helpful comments and
      suggestions: Jari Arkko, Fred Baker, Iljitsch van Beijnum, Oliver
      Bonaventure, Teco Boot, Bob Braden, Brian Carpenter, Steve Casner, Ian
      Chakeres, Noel Chiappa, Remi Denis-Courmont, Remi Despres, Ralph Droms,
      Aurnaud Ebalard, Gorry Fairhurst, Washam Fan, Dino Farinacci, Joel
      Halpern, Sam Hartman, John Heffner, Thomas Henderson, Bob Hinden,
      Christian Huitema, Eliot Lear, Darrel Lewis, Joe Macker, Matt Mathis,
      Erik Nordmark, Dan Romascanu, Dave Thaler, Joe Touch, Mark Townsley, Ole
      Troan, Margaret Wasserman, Magnus Westerlund, Robin Whittle, James
      Woodyatt, and members of the Boeing Research &amp; Technology NST
      DC&amp;NT group.</t>

      <t>Discussions with colleagues following the publication of <xref
      target="RFC5320"></xref> have provided useful insights that have
      resulted in significant improvements to this, the Second Edition of
      SEAL.</t>

      <t>Path MTU determination through the report of fragmentation was first
      proposed by Charles Lynn on the TCP-IP mailing list in 1987. Extending
      the IP identification field was first proposed by Steve Deering on the
      MTUDWG mailing list in 1989.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.0791"?>

      <?rfc include="reference.RFC.0792"?>

      <?rfc include="reference.RFC.1122"?>

      <?rfc include="reference.RFC.4443"?>

      <?rfc include="reference.RFC.3971"?>

      <?rfc include="reference.RFC.4861"?>

      <?rfc include="reference.RFC.2119"?>

      <?rfc include="reference.RFC.2460"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1063"?>

      <?rfc include="reference.RFC.0994"?>

      <?rfc include="reference.RFC.1146"?>

      <?rfc include="reference.RFC.1191"?>

      <?rfc include="reference.RFC.1701"?>

      <?rfc include="reference.RFC.1981"?>

      <?rfc include="reference.RFC.2003"?>

      <?rfc include="reference.RFC.2473"?>

      <?rfc include="reference.RFC.2827"?>

      <?rfc include="reference.RFC.2923"?>

      <?rfc include="reference.RFC.3366"?>

      <?rfc include="reference.RFC.3819"?>

      <?rfc include="reference.RFC.4213"?>

      <?rfc include="reference.RFC.1812"?>

      <?rfc include="reference.RFC.2780"?>

      <?rfc include="reference.RFC.4301"?>

      <?rfc include="reference.RFC.4302"?>

      <?rfc include="reference.RFC.5246"?>

      <?rfc include="reference.RFC.4459"?>

      <?rfc include="reference.RFC.4821"?>

      <?rfc include="reference.RFC.4963"?>

      <?rfc include="reference.RFC.2764"?>

      <?rfc include="reference.RFC.2675"?>

      <?rfc include="reference.RFC.5445"?>

      <?rfc include="reference.RFC.1070"?>

      <?rfc include="reference.RFC.3232"?>

      <?rfc include="reference.RFC.4191"?>

      <?rfc include="reference.RFC.4987"?>

      <?rfc include="reference.RFC.5720"?>

      <?rfc include="reference.RFC.5226"?>

      <?rfc include="reference.RFC.5320"?>

      <?rfc include="reference.RFC.6335"?>

      <?rfc include="reference.I-D.templin-intarea-vet"?>

      <?rfc include="reference.I-D.ietf-savi-framework"?>

      <?rfc include="reference.I-D.templin-ironbis"?>

      <?rfc include="reference.RFC.6139"?>

      <?rfc include="reference.RFC.5927"?>

      <?rfc include="reference.RFC.6169"?>

      <?rfc include="reference.I-D.ietf-intarea-ipv4-id-update"?>

      <?rfc include="reference.I-D.templin-aero"?>

      <?rfc include="reference.I-D.massar-v6ops-ayiya"?>

      <reference anchor="FRAG">
        <front>
          <title>Fragmentation Considered Harmful</title>

          <author fullname="Christopher Kent" initials="C" surname="Kent">
            <organization></organization>
          </author>

          <author fullname="Jeffrey Mogul" initials="J" surname="Mogul">
            <organization></organization>
          </author>

          <date month="October" year="1987" />
        </front>
      </reference>

      <reference anchor="FOLK">
        <front>
          <title>Beyond Folklore: Observations on Fragmented Traffic</title>

          <author fullname="Colleen Shannon" initials="C" surname="Shannon">
            <organization></organization>
          </author>

          <author fullname="David Moore" initials="D" surname="Moore">
            <organization></organization>
          </author>

          <author fullname="k claffy" initials="k" surname="claffy">
            <organization></organization>
          </author>

          <date month="December" year="2002" />
        </front>
      </reference>

      <reference anchor="MTUDWG">
        <front>
          <title>IETF MTU Discovery Working Group mailing list,
          gatekeeper.dec.com/pub/DEC/WRL/mogul/mtudwg-log, November 1989 -
          February 1995.</title>

          <author fullname="" initials="" surname="">
            <organization></organization>
          </author>

          <date month="" year="" />
        </front>
      </reference>

      <reference anchor="TCP-IP">
        <front>
          <title>Archive/Hypermail of Early TCP-IP Mail List,
          http://www-mice.cs.ucl.ac.uk/multimedia/misc/tcp_ip/, May 1987 - May
          1990.</title>

          <author fullname="" initials="" surname="">
            <organization></organization>
          </author>

          <date month="" year="" />
        </front>
      </reference>

      <reference anchor="TBIT">
        <front>
          <title>Measuring Interactions Between Transport Protocols and
          Middleboxes</title>

          <author fullname="Alberto Medina" initials="A" surname="Medina">
            <organization></organization>
          </author>

          <author fullname="Mark Allman" initials="M" surname="Allman">
            <organization></organization>
          </author>

          <author fullname="Sally Floyd" initials="S" surname="Floyd">
            <organization></organization>
          </author>

          <date month="October" year="2004" />
        </front>
      </reference>

      <reference anchor="WAND">
        <front>
          <title>Inferring and Debugging Path MTU Discovery Failures</title>

          <author fullname="Matthew Luckie" initials="M" surname="Luckie">
            <organization></organization>
          </author>

          <author fullname="Kenjiro Cho" initials="K" surname="Cho">
            <organization></organization>
          </author>

          <author fullname="Bill Owens" initials="B" surname="Owens">
            <organization></organization>
          </author>

          <date month="October" year="2005" />
        </front>
      </reference>

      <reference anchor="SIGCOMM">
        <front>
          <title>Measuring Path MTU Discovery Behavior</title>

          <author fullname="Matthew Luckie" initials="M" surname="Luckie">
            <organization></organization>
          </author>

          <author fullname="Ben Stasiewicz" initials="B" surname="Stasiewicz">
            <organization></organization>
          </author>

          <date month="November" year="2010" />
        </front>
      </reference>
    </references>

    <section title="Reliability">
      <t>Although a SEAL tunnel may span an arbitrarily-large subnetwork
      expanse, the IP layer sees the tunnel as a simple link that supports the
      IP service model. Links with high bit error rates (BERs) (e.g., IEEE
      802.11) use Automatic Repeat-ReQuest (ARQ) mechanisms <xref
      target="RFC3366"></xref> to increase packet delivery ratios, while links
      with much lower BERs typically omit such mechanisms. Since SEAL tunnels
      may traverse arbitrarily-long paths over links of various types that are
      already either performing or omitting ARQ as appropriate, it would
      therefore be inefficient to require the tunnel endpoints to also perform
      ARQ.</t>
    </section>

    <section title="Integrity">
      <t>The SEAL header includes an integrity check field that covers the
      SEAL header and at least the inner packet headers. This provides for
      header integrity verification on a segment-by-segment basis for a
      segmented re-encapsulating tunnel path.</t>

      <t>Fragmentation and reassembly schemes must also consider
      packet-splicing errors, e.g., when two fragments from the same packet
      are concatenated incorrectly, when a fragment from packet X is
      reassembled with fragments from packet Y, etc. The primary sources of
      such errors include implementation bugs and wrapping IPv4 ID fields.</t>

      <t>In particular, the IPv4 16-bit ID field can wrap with only 64K
      packets with the same (src, dst, protocol)-tuple alive in the system at
      a given time <xref target="RFC4963"></xref>. When the IPv4 ID field is
      re-written by a middlebox such as a NAT or Firewall, ID field wrapping
      can occur with even fewer packets alive in the system.</t>

      <t>When outer IPv4 fragmentation is unavoidable, SEAL institutes rate
      limiting so that the number of packets admitted into the tunnel by the
      ITE does not exceed the number of unique packets that may be alive
      within the Internet.</t>
    </section>

    <section title="Transport Mode">
      <t>SEAL can also be used in "transport-mode", e.g., when the inner layer
      comprises upper-layer protocol data rather than an encapsulated IP
      packet. For instance, TCP peers can negotiate the use of SEAL (e.g., by
      inserting an unspecified 'SEAL_OPTION' TCP option during connection
      establishment) for the carriage of protocol data encapsulated as
      IP/SEAL/TCP. In this sense, the "subnetwork" becomes the entire
      end-to-end path between the TCP peers and may potentially span the
      entire Internet.</t>

      <t>If both TCPs agree on the use of SEAL, their protocol messages will
      be carried as IP/SEAL/TCP and the connection will be serviced by the
      SEAL protocol using TCP (instead of an encapsulating tunnel endpoint) as
      the transport layer protocol. The SEAL protocol for transport mode
      otherwise observes the same specifications as for Section 4.</t>
    </section>

    <section title="Historic Evolution of PMTUD">
      <t>The topic of Path MTU discovery (PMTUD) saw a flurry of discussion
      and numerous proposals in the late 1980's through early 1990. The
      initial problem was posed by Art Berggreen on May 22, 1987 in a message
      to the TCP-IP discussion group <xref target="TCP-IP"></xref>. The
      discussion that followed provided significant reference material for
      [FRAG]. An IETF Path MTU Discovery Working Group <xref
      target="MTUDWG"></xref> was formed in late 1989 with charter to produce
      an RFC. Several variations on a very few basic proposals were
      entertained, including:</t>

      <t><list style="numbers">
          <t>Routers record the PMTUD estimate in ICMP-like path probe
          messages (proposed in [FRAG] and later <xref
          target="RFC1063"></xref>)</t>

          <t>The destination reports any fragmentation that occurs for packets
          received with the "RF" (Report Fragmentation) bit set (Steve
          Deering's 1989 adaptation of Charles Lynn's Nov. 1987 proposal)</t>

          <t>A hybrid combination of 1) and Charles Lynn's Nov. 1987 (straw
          RFC draft by McCloughrie, Fox and Mogul on Jan 12, 1990)</t>

          <t>Combination of the Lynn proposal with TCP (Fred Bohle, Jan 30,
          1990)</t>

          <t>Fragmentation avoidance by setting "IP_DF" flag on all packets
          and retransmitting if ICMPv4 "fragmentation needed" messages occur
          (Geof Cooper's 1987 proposal; later adapted into <xref
          target="RFC1191"></xref> by Mogul and Deering).</t>
        </list></t>

      <t>Option 1) seemed attractive to the group at the time, since it was
      believed that routers would migrate more quickly than hosts. Option 2)
      was a strong contender, but repeated attempts to secure an "RF" bit in
      the IPv4 header from the IESG failed and the proponents became
      discouraged. 3) was abandoned because it was perceived as too
      complicated, and 4) never received any apparent serious consideration.
      Proposal 5) was a late entry into the discussion from Steve Deering on
      Feb. 24th, 1990. The discussion group soon thereafter seemingly lost
      track of all other proposals and adopted 5), which eventually evolved
      into <xref target="RFC1191"></xref> and later <xref
      target="RFC1981"></xref>.</t>

      <t>In retrospect, the "RF" bit postulated in 2) is not needed if a
      "contract" is first established between the peers, as in proposal 4) and
      a message to the MTUDWG mailing list from jrd@PTT.LCS.MIT.EDU on Feb 19.
      1990. These proposals saw little discussion or rebuttal, and were
      dismissed based on the following the assertions:</t>

      <t><list style="symbols">
          <t>routers upgrade their software faster than hosts</t>

          <t>PCs could not reassemble fragmented packets</t>

          <t>Proteon and Wellfleet routers did not reproduce the "RF" bit
          properly in fragmented packets</t>

          <t>Ethernet-FDDI bridges would need to perform fragmentation (i.e.,
          "translucent" not "transparent" bridging)</t>

          <t>the 16-bit IP_ID field could wrap around and disrupt reassembly
          at high packet arrival rates</t>
        </list>The first four assertions, although perhaps valid at the time,
      have been overcome by historical events. The final assertion is
      addressed by the mechanisms specified in SEAL.</t>
    </section>
  </back>
</rfc>
