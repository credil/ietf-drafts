<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" ipr="trust200902" docName="draft-ietf-jose-json-web-encryption-18">

  <front>
    <title abbrev="JWE">JSON Web Encryption (JWE)</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
      <organization abbrev="RTFM">RTFM, Inc.</organization>
      <address>
        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <email>jhildebr@cisco.com</email>
      </address>
    </author>

    <date day="12" month="November" year="2013" />

    <area>Security</area>
    <workgroup>JOSE Working Group</workgroup>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <keyword>JSON Object Signing and Encryption</keyword>
    <keyword>JOSE</keyword>
    <keyword>JSON Web Signature</keyword>
    <keyword>JWS</keyword>
    <keyword>JSON Web Encryption</keyword>
    <keyword>JWE</keyword>
    <keyword>JSON Web Key</keyword>
    <keyword>JWK</keyword>
    <keyword>JSON Web Algorithms</keyword>
    <keyword>JWA</keyword>

    <abstract>
      <t>
	JSON Web Encryption (JWE) represents encrypted content
	using JavaScript Object Notation (JSON) based data structures.
	Cryptographic algorithms and identifiers for use with this
	specification are described in the separate
	JSON Web Algorithms (JWA) specification
	and IANA registries defined by that specification.
	Related digital signature and MAC capabilities are described
	in the separate JSON Web Signature (JWS) specification.
      </t>
    </abstract>

  </front>

  <middle>
    <section title="Introduction" anchor="Introduction">
      <t>
	JSON Web Encryption (JWE) represents encrypted content
	using JavaScript Object Notation (JSON) <xref target="RFC4627"/>
	based data structures.
	The JWE cryptographic mechanisms encrypt and provide integrity protection for
	an arbitrary sequence of octets.
      </t>
      <t>
	Two closely related serializations for JWE objects are defined.
	The JWE Compact Serialization is a compact, URL-safe representation
	intended for space constrained environments such as HTTP
	Authorization headers and URI query parameters.
	The JWE JSON Serialization represents JWE objects as JSON objects and
	enables the same content to be encrypted to multiple parties.
	Both share the same cryptographic underpinnings.
      </t>
      <t>
	Cryptographic algorithms and identifiers for use with this
	specification are described in the separate
	JSON Web Algorithms (JWA) <xref target="JWA" /> specification
	and IANA registries defined by that specification.
	Related digital signature and MAC capabilities are described
	in the separate JSON Web Signature (JWS) <xref target="JWS" />
	specification.
      </t>
      <t>
	Names defined by this specification are short because a core goal is
	for the resulting representations to be compact.
      </t>

      <section title="Notational Conventions" anchor="NotationalConventions">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in
	  Key words for use in RFCs to Indicate Requirement Levels <xref target='RFC2119' />.
	  If these words are used without being spelled in uppercase then
	  they are to be interpreted with their normal natural language meanings.
        </t>
	<t>
	  BASE64URL(OCTETS) denotes the base64url encoding of OCTETS,
	  per <xref target="Terminology"/>.
	</t>
	<t>
	  UTF8(STRING) denotes the octets of the
	  UTF-8 <xref target="RFC3629"/> representation of STRING.
	</t>
	<t>
	  ASCII(STRING) denotes the octets of the
	  ASCII <xref target="USASCII"/> representation of STRING.
	</t>
	<t>
	  The concatenation of two values A and B
	  is denoted as A&nbsp;||&nbsp;B.
	</t>
      </section>

    </section>

    <section title="Terminology" anchor="Terminology">

      <t>
	These terms defined by the
	JSON Web Signature (JWS) <xref target="JWS"/>
	specification are incorporated into this specification:
	"JSON Web Signature (JWS)",
	"Base64url Encoding",
	"Collision-Resistant Name", and
	"StringOrURI".
      </t>

      <t>
	These terms are defined for use by this specification:
      </t>

      <t>
	<list style="hanging">

          <t hangText="JSON Web Encryption (JWE)">
	    A data structure representing an encrypted and integrity protected message.
	  </t>

	  <t hangText="Authenticated Encryption with Associated Data (AEAD)">
	    An AEAD algorithm is one that encrypts the Plaintext,
	    allows Additional Authenticated Data to be specified,
	    and provides an integrated content integrity check
	    over the Ciphertext and Additional Authenticated Data.
	    AEAD algorithms accept two inputs, the Plaintext and the
	    Additional Authenticated Data value, and produce two outputs,
	    the Ciphertext and the Authentication Tag value.
	    AES Galois/Counter Mode (GCM) is one such algorithm.
	  </t>

	  <t hangText="Plaintext">
	    The sequence of octets to be encrypted -- a.k.a., the message.
	    The plaintext can contain an arbitrary sequence of octets.
	  </t>
	  <t hangText="Ciphertext">
	    An encrypted representation of the Plaintext.
	  </t>
	  <t hangText="Additional Authenticated Data (AAD)">
	    An input to an AEAD operation that
	    is integrity protected but not encrypted.
	  </t>
	  <t hangText="Authentication Tag">
	    An output of an AEAD operation that
	    ensures the integrity of
	    the Ciphertext
	    and the Additional Authenticated Data.
	    Note that some algorithms may not use an Authentication Tag,
	    in which case this value is the empty octet sequence.
	  </t>

	  <t hangText="Content Encryption Key (CEK)">
	    A symmetric key for the AEAD algorithm
	    used to encrypt the Plaintext for the
	    recipient to produce the Ciphertext and the Authentication Tag.
	  </t>

          <t hangText="JWE Header">
	    A JSON object
	    (or JSON objects, when using the JWE JSON Serialization)
	    that describes the
	    encryption operations applied to create the JWE Encrypted
	    Key, the JWE Ciphertext, and the JWE Authentication Tag.
	    The members of the JWE Header object(s) are Header Parameters.
	  </t>
          <t hangText="JWE Encrypted Key">
	    The result of encrypting the Content Encryption Key (CEK) with the
	    intended recipient's key using the specified algorithm.
	    Note that for some algorithms, the JWE Encrypted Key
	    value is specified as being the empty octet sequence.
	  </t>
          <t hangText="JWE Initialization Vector">
	    A sequence of octets containing the Initialization Vector used
	    when encrypting the Plaintext.
	    Note that some algorithms may not use an Initialization Vector,
	    in which case this value is the empty octet sequence.
	  </t>
          <t hangText="JWE Ciphertext">
	    A sequence of octets containing the Ciphertext for a JWE.
	  </t>
	  <t hangText="JWE Authentication Tag">
	    A sequence of octets containing the Authentication Tag for a JWE.
	  </t>

          <t hangText="JWE Protected Header">
	    A JSON object that contains the portion of the
	    JWE Header that is integrity protected.
	    For the JWE Compact Serialization, this comprises the entire JWE Header.
	    For the JWE JSON Serialization, this is one component of the JWE Header.
	  </t>

	  <t hangText="Header Parameter">
	    A name/value pair that is member of the JWE Header.
	  </t>

	  <t hangText="JWE Compact Serialization">
	    A representation of the JWE as a compact, URL-safe string.
	  </t>

	  <t hangText="JWE JSON Serialization">
	    A representation of the JWE as a JSON object.
	    Unlike the JWE Compact Serialization,
	    the JWE JSON Serialization
	    enables the same content to be encrypted to multiple parties.
	    This representation is neither compact nor URL-safe.
	  </t>

	  <t hangText="Key Management Mode">
	    A method of determining the Content Encryption Key (CEK) value to use.
	    Each algorithm used for determining the CEK value uses a specific Key Management Mode.
	    Key Management Modes employed by this specification are
	    Key Encryption,
	    Key Wrapping,
	    Direct Key Agreement,
	    Key Agreement with Key Wrapping, and
	    Direct Encryption.
	  </t>

	  <t hangText="Key Encryption">
	    A Key Management Mode in which the Content Encryption Key (CEK) value
	    is encrypted to the intended recipient using an asymmetric encryption algorithm.
	  </t>

	  <t hangText="Key Wrapping">
	    A Key Management Mode in which the Content Encryption Key (CEK) value
	    is encrypted to the intended recipient using a symmetric key wrapping algorithm.
	  </t>

	  <t hangText="Direct Key Agreement">
	    A Key Management Mode in which a key agreement algorithm is used to agree upon
	    the Content Encryption Key (CEK) value.
	  </t>

	  <t hangText="Key Agreement with Key Wrapping">
	    A Key Management Mode in which a key agreement algorithm is used to agree upon
	    a symmetric key used to encrypt the Content Encryption Key (CEK) value
	    to the intended recipient using a symmetric key wrapping algorithm.
	  </t>

	  <t hangText="Direct Encryption">
	    A Key Management Mode in which the Content Encryption Key (CEK) value
	    used is the secret symmetric key value shared between the parties.
	  </t>

        </list>
      </t>
    </section>

    <section title="JSON Web Encryption (JWE) Overview" anchor="Overview">

      <t>
	JWE represents encrypted content using JSON data
	structures and base64url encoding.
	A JWE represents these logical values:
	<list style="hanging">
	  <t hangText="JWE Header">
	    JSON object containing the parameters
	    describing the cryptographic operations and parameters employed.
	    The JWE Header members are the union of the members of
	    the JWE Protected Header,
	    the JWE Shared Unprotected Header, and
	    the JWE Per-Recipient Unprotected Header, as described below.
	  </t>
          <t hangText="JWE Encrypted Key">
	    Encrypted Content Encryption Key (CEK) value.
	  </t>
          <t hangText="JWE Initialization Vector">
	    Initialization Vector value used
	    when encrypting the plaintext.
	  </t>
	  <t hangText="JWE Ciphertext">
	    Ciphertext value resulting from authenticated encryption of the plaintext.
	  </t>
	  <t hangText="JWE Authentication Tag">
	    Authentication Tag value resulting from authenticated encryption
	    of the plaintext with additional associated data.
	  </t>
	  <t hangText="JWE AAD">
	    Additional value to be integrity protected by
	    the authenticated encryption operation.
	  </t>
	</list>
	The JWE Header represents the combination of these logical values:
	<list style="hanging">
	  <t hangText="JWE Protected Header">
	    JSON object containing some of the parameters
	    describing the cryptographic operations and parameters employed.
	    These parameters apply to all recipients of the JWE.
	    This value is integrity protected in the
	    digital signature or MAC calculation of the JWE Signature.
	  </t>
	  <t hangText="JWE Shared Unprotected Header">
	    JSON object containing some of the parameters
	    describing the cryptographic operations and parameters employed.
	    These parameters apply to all recipients of the JWE.
	    This value is not integrity protected in
	    the authenticated encryption operation.
	  </t>
	  <t hangText="JWE Per-Recipient Unprotected Header">
	    JSON object containing some of the parameters
	    describing the cryptographic operations and parameters employed.
	    These parameters apply to a single recipient of the JWE.
	    This value is not integrity protected in
	    the authenticated encryption operation.
	  </t>
	</list>
      </t>
      <t>
	This document defines two serializations for JWE objects:
	a compact, URL-safe serialization called the JWE Compact Serialization
	and a JSON serialization called the JWE JSON Serialization.
	In both serializations, the
	JWE Protected Header,
	JWE Encrypted Key,
	JWE Initialization Vector,
	JWE Ciphertext, and
	JWE Authentication Tag
	are base64url encoded for transmission,
	since JSON lacks a way to directly represent octet sequences.
	When present, the JWE AAD is also base64url encoded for transmission.
      </t>
      <t>
	In the JWE Compact Serialization, no JWE Shared Unprotected Header or
	JWE Per-Recipient Unprotected Header are used.
	In this case, the JWE Header and the JWE Protected Header are the same.
      </t>
      <t>
	In the JWE Compact Serialization, a JWE object is represented as the
	combination of these five string values,
	<?rfc subcompact="yes"?>
	<list style="empty">
	  <t>BASE64URL(UTF8(JWE Protected Header)),</t>
	  <t>BASE64URL(JWE Encrypted Key),</t>
	  <t>BASE64URL(JWE Initialization Vector),</t>
	  <t>BASE64URL(JWE Ciphertext), and</t>
	  <t>BASE64URL(JWE Authentication Tag),</t>
	</list>
	<?rfc subcompact="no"?>
	concatenated in that order,
	with the five strings being separated by four period ('.') characters.
      </t>
      <t>
	In the JWE JSON Serialization, one or more of the JWE Protected Header,
	JWE Shared Unprotected Header, and
	JWE Per-Recipient Unprotected Header MUST be present.
	In this case, the members of the JWE Header are the combination of
	the members of the JWE Protected Header,
	JWE Shared Unprotected Header, and
	JWE Per-Recipient Unprotected Header
	values that are present.
      </t>
      <t>
	In the JWE JSON Serialization, a JWE object is represented as the
	combination of these eight values,
	<?rfc subcompact="yes"?>
	<list style="empty">
	  <t>BASE64URL(UTF8(JWE Protected Header)),</t>
	  <t>JWE Shared Unprotected Header,</t>
	  <t>JWE Per-Recipient Unprotected Header,</t>
	  <t>BASE64URL(JWE Encrypted Key),</t>
	  <t>BASE64URL(JWE Initialization Vector),</t>
	  <t>BASE64URL(JWE Ciphertext),</t>
	  <t>BASE64URL(JWE Authentication Tag), and</t>
	  <t>BASE64URL(JWE AAD),</t>
	</list>
	<?rfc subcompact="no"?>
	with the six base64url encoding result strings
	and the two unprotected JSON object values
	being represented as members within a JSON object.
	The inclusion of some of these values is OPTIONAL.
	The JWE JSON Serialization can also
	encrypt the plaintext to multiple recipients.
	See <xref target="JSONSerialization"/> for more information
	about the JWE JSON Serialization.
      </t>
      <t>
	JWE utilizes authenticated encryption to ensure the confidentiality
	and integrity of the Plaintext
	and the integrity of the JWE Protected Header and the JWE AAD.
      </t>

      <section title="Example JWE" anchor="OAEPGCMIntro">
	<t>
	  This example encrypts the plaintext
	  "The true sign of intelligence is not knowledge but imagination."
	  to the recipient using RSAES OAEP for key encryption
	  and AES GCM for content encryption.
	</t>
	<t>
	  The following example JWE Protected Header declares that:
	  <list style="symbols">
	    <t>
	      the Content Encryption Key is encrypted to the recipient
	      using the RSAES OAEP algorithm to produce
	      the JWE Encrypted Key and
	    </t>
	    <t>
	      the Plaintext is encrypted using the AES GCM
	      algorithm with a 256 bit key to produce the Ciphertext.
	    </t>
	  </list>
	</t>

	<figure><artwork><![CDATA[
  {"alg":"RSA-OAEP","enc":"A256GCM"}
]]></artwork></figure>

	<t>
	  Encoding this JWE Protected Header as
	  BASE64URL(UTF8(JWE Protected Header)) gives this value:
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ
]]></artwork></figure>
	
	<t>
	  The remaining steps to finish creating this JWE are:
	  <list style="symbols">
	    <t>
	      Generate a random Content Encryption Key (CEK).
	    </t>
	    <t>
	      Encrypt the CEK with the recipient's public key using the RSAES OAEP
	      algorithm to produce the JWE Encrypted Key.
	    </t>
	    <t>
	      Base64url encode the JWE Encrypted Key.
	    </t>
	    <t>
	      Generate a random JWE Initialization Vector.
	    </t>
	    <t>
	      Base64url encode the JWE Initialization Vector.
	    </t>
	    <t>
	      Let the Additional Authenticated Data encryption parameter be
	      ASCII(BASE64URL(UTF8(JWE Protected Header))).
	    </t>
	    <t>
	      Encrypt the Plaintext with AES GCM
	      using the CEK as the encryption key,
	      the JWE Initialization Vector,
	      and the Additional Authenticated Data value,
	      requesting a 128 bit Authentication Tag output.
	    </t>
	    <t>
	      Base64url encode the Ciphertext.
	    </t>
	    <t>
	      Base64url encode the Authentication Tag.
	    </t>
	    <t>
	      Assemble the final representation:
	      The Compact Serialization of this result is the string
	      BASE64URL(UTF8(JWE Protected Header))
	      || '.' || BASE64URL(JWE Encrypted Key)
	      || '.' || BASE64URL(JWE Initialization Vector)
	      || '.' || BASE64URL(JWE Ciphertext)
	      || '.' || BASE64URL(JWE Authentication Tag).
	    </t>
	  </list>

	  The final result in this example
	  (with line breaks for display purposes only) is:
	</t>
	<figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.
  OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe
  ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb
  Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV
  mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8
  1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi
  6UklfCpIMfIjf7iGdXKHzg.
  48V1_ALb6US04U3b.
  5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji
  SdiwkIr3ajwQzaBtQD_A.
  XFBoMYUZodetZdvTiFvSkQ
]]></artwork></figure>

	<t>
	  See <xref target="OAEPGCMExample"/> for the complete details of computing this JWE.
	  See <xref target="JWEExamples"/> for additional examples.
	</t>
      </section>

    </section>

    <section title="JWE Header" anchor="Header">

      <t>
	The members of the JSON object(s) representing the JWE Header
	describe the encryption applied to the Plaintext and optionally
	additional properties of the JWE.
	The Header Parameter names within the JWE Header MUST be unique;
	recipients MUST either reject JWEs with duplicate Header Parameter names
	or use a JSON parser that returns only the lexically last duplicate member name,
	as specified in Section 15.12 (The JSON Object) of
	ECMAScript 5.1 <xref target="ECMAScript"/>.
      </t>
      <t>
	Implementations are required to understand
	the specific Header Parameters defined by this specification 
	that are designated as "MUST be understood"
	and process them in the manner defined in this specification.
	All other Header Parameters defined by this specification that
	are not so designated MUST be ignored when not understood.
	Unless listed as a critical Header Parameter, per <xref target="critDef"/>,
	all Header Parameters not defined by this specification
	MUST be ignored when not understood.
      </t>
      <t>
        There are three classes of Header Parameter names:
	Registered Header Parameter names, Public Header Parameter names,
	and Private Header Parameter names.
      </t>

      <section title="Registered Header Parameter Names" anchor="RegisteredHeaderParameterName">
	<t>
	  The following Header Parameter names are registered
	  in the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  defined in
	  <xref target="JWS"/>,
	  with meanings as defined below.
	</t>
	<t>
	  As indicated by the common registry, JWSs and JWEs share a
	  common Header Parameter space; when a parameter is used by
	  both specifications, its usage must be compatible
	  between the specifications.
	</t>

	<section title='"alg" (Algorithm) Header Parameter' anchor="algDef">
	  <t>
	    This parameter has the same meaning, syntax, and processing rules as the
	    <spanx style="verb">alg</spanx> Header Parameter defined in
	    Section 4.1.1 of <xref target="JWS" />, except that
	    the Header Parameter identifies the cryptographic algorithm used to
	    encrypt or determine the value of the Content Encryption Key (CEK).
	    The encrypted content is not usable if the <spanx style="verb">alg</spanx>
	    value does not represent a supported algorithm, or if the recipient does
	    not have a key that can be used with that algorithm.
	  </t>
	  <t>
	    A list of defined <spanx style="verb">alg</spanx> values
	    for this use can be found
	    in the IANA JSON Web Signature and Encryption Algorithms registry
	    defined in
	    <xref target="JWA" />;
	    the initial contents of this registry are the values defined in
	    Section 4.1 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	  </t>
	</section>

	<section title='"enc" (Encryption Method) Header Parameter' anchor="encDef">
	  <t>
	    The <spanx style="verb">enc</spanx> (encryption method)
	    Header Parameter identifies the content encryption algorithm
	    used to encrypt the Plaintext to produce the Ciphertext.
	    This algorithm MUST be an AEAD algorithm with a specified key length.
	    The recipient MUST reject the JWE if the <spanx style="verb">enc</spanx>
	    value does not represent a supported algorithm.
	    <spanx style="verb">enc</spanx> values should either be
	    registered in the IANA
	    JSON Web Signature and Encryption Algorithms registry
	    defined in
	    <xref target="JWA" /> or be
	    a value that contains a Collision-Resistant Name.
	    The <spanx style="verb">enc</spanx> value is a case-sensitive string
	    containing a StringOrURI value.
	    This Header Parameter MUST be present
	    and MUST be understood and processed by implementations.
	  </t>
	  <t>
	    A list of defined <spanx style="verb">enc</spanx> values
	    for this use can be found
	    in the IANA JSON Web Signature and Encryption Algorithms registry
	    defined in
	    <xref target="JWA" />;
	    the initial contents of this registry are the values defined in
	    Section 5.1 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	  </t>
	</section>

	<section title='"zip" (Compression Algorithm) Header Parameter' anchor="zipDef">
	  <t>
	    The <spanx style="verb">zip</spanx> (compression algorithm)
	    applied to the Plaintext before encryption, if any.
	    The <spanx style="verb">zip</spanx> value defined by this specification is:
	    <list style='symbols'>
	      <t>
		<spanx style="verb">DEF</spanx>
		- Compression with the DEFLATE <xref target="RFC1951" /> algorithm
	      </t>
	    </list>
	    Other values MAY be used.
	    Compression algorithm values can be registered in the IANA
	    JSON Web Encryption Compression Algorithm registry
	    defined in
	    <xref target="JWA"/>.
	    The <spanx style="verb">zip</spanx> value is a case-sensitive string.
	    If no <spanx style="verb">zip</spanx> parameter is present,
	    no compression is applied to the Plaintext before encryption.
	    This Header Parameter MUST be integrity protected, and therefore
	    MUST occur only within the JWE Protected Header, when used.
	    Use of this Header Parameter is OPTIONAL.
	    This Header Parameter MUST be understood and processed by implementations.
	  </t>
	</section>

	<section title='"jku" (JWK Set URL) Header Parameter' anchor="jkuDef">
	  <t>
	    This parameter has the same meaning, syntax, and processing rules as the
	    <spanx style="verb">jku</spanx> Header Parameter defined in
	    Section 4.1.2 of <xref target="JWS" />, except that
	    the JWK Set resource contains
	    the public key to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	  </t>
	</section>

	<section title='"jwk" (JSON Web Key) Header Parameter' anchor="jwkDef">
	  <t>
	    This parameter has the same meaning, syntax, and processing rules as the
	    <spanx style="verb">jwk</spanx> Header Parameter defined in
	    Section 4.1.3 of <xref target="JWS" />, except that
	    the key is
	    the public key to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	  </t>
	</section>

	<section title='"x5u" (X.509 URL) Header Parameter' anchor="x5uDef">
	  <t>
	    This parameter has the same meaning, syntax, and processing rules as the
	    <spanx style="verb">x5u</spanx> Header Parameter defined in
	    Section 4.1.4 of <xref target="JWS" />, except that
	    the X.509 public key certificate or certificate chain
	    <xref target="RFC5280"/> contains the public key
	    to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	  </t>
	</section>

	<section title='"x5t" (X.509 Certificate SHA-1 Thumbprint) Header Parameter' anchor="x5tDef">
	  <t>
	    This parameter has the same meaning, syntax, and processing rules as the
	    <spanx style="verb">x5t</spanx> Header Parameter defined in
	    Section 4.1.5 of <xref target="JWS" />, except that
	    certificate referenced by the thumbprint contains
	    the public key to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	  </t>
	</section>

	<section title='"x5c" (X.509 Certificate Chain) Header Parameter' anchor="x5cDef">
	  <t>
	    This parameter has the same meaning, syntax, and processing rules as the
	    <spanx style="verb">x5c</spanx> Header Parameter defined in
	    Section 4.1.6 of <xref target="JWS" />, except that
	    the X.509 public key certificate or certificate chain
	    <xref target="RFC5280"/> contains the public key
	    to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	  </t>
	  <t>
	    See Appendix B of <xref target="JWS"/> for an example
	    <spanx style="verb">x5c</spanx> value.
	  </t>
	</section>

	<section title='"kid" (Key ID) Header Parameter' anchor="kidDef">
	  <t>
	    This parameter has the same meaning, syntax, and processing rules as the
	    <spanx style="verb">kid</spanx> Header Parameter defined in
	    Section 4.1.7 of <xref target="JWS" />, except that
	    the key hint references
	    the public key to which the JWE was encrypted;
	    this can be used to determine the private key needed to decrypt the JWE.
	    This parameter allows originators to explicitly signal a change of
	    key to JWE recipients.
	  </t>
	</section>

	<section title='"typ" (Type) Header Parameter' anchor="typDef">

	  <t>
	    This parameter has the same meaning, syntax, and processing rules as the
	    <spanx style="verb">typ</spanx> Header Parameter defined in
	    Section 4.1.8 of <xref target="JWS" />, except that
	    the type is of this complete JWE object.
	  </t>

	</section>

	<section title='"cty" (Content Type) Header Parameter' anchor="ctyDef">

	  <t>
	    This parameter has the same meaning, syntax, and processing rules as the
	    <spanx style="verb">cty</spanx> Header Parameter defined in
	    Section 4.1.9 of <xref target="JWS" />, except that
	    the type is of the secured content (the payload).
	  </t>

	</section>

	<section title='"crit" (Critical) Header Parameter' anchor="critDef">
	  <t>
	    This parameter has the same meaning, syntax, and processing rules as the
	    <spanx style="verb">crit</spanx> Header Parameter defined in
	    Section 4.1.10 of <xref target="JWS" />, except that
	    JWE Header Parameters are being referred to, rather than
	    JWS Header Parameters.
	  </t>
	</section>

      </section>

      <section title="Public Header Parameter Names" anchor="PublicHeaderParameterName">

        <t>
	  Additional Header Parameter names can be defined by those
	  using JWEs. However, in order to prevent collisions, any new
	  Header Parameter name should either be registered in the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  defined in
	  <xref target="JWS" /> or be a Public Name:
	  a value that contains a Collision-Resistant Name.
	  In each case, the definer of the name
	  or value needs to take reasonable precautions to make sure they
	  are in control of the part of the namespace they use to
	  define the Header Parameter name.
	</t>
	<t>
	  New Header Parameters should be introduced sparingly, as
	  they can result in non-interoperable JWEs.
	</t>
      </section>

      <section title="Private Header Parameter Names" anchor="PrivateHeaderParameterName">

	<t>
	  A producer and consumer of a JWE may agree to use Header Parameter names
	  that are Private Names:  names that are
	  not Registered Header Parameter names <xref target="RegisteredHeaderParameterName"></xref>
	  or Public Header Parameter names <xref target="PublicHeaderParameterName"></xref>.
	  Unlike Public Header Parameter names,
	  Private Header Parameter names are subject to collision and
	  should be used with caution.
	</t>

      </section>
    </section>

    <section title="Producing and Consuming JWEs" anchor="JWERules">

      <section title="Message Encryption" anchor="Encryption">
	<t>
	  The message encryption process is as follows.
	  The order of the steps is not significant in cases where
	  there are no dependencies between the inputs and outputs of the steps.
	</t>

	<t>
	  <list style="numbers">
	    <t>
	      Determine the Key Management Mode employed by the algorithm
	      used to determine the Content Encryption Key (CEK) value.
	      (This is the algorithm recorded in the
	      <spanx style="verb">alg</spanx> (algorithm)
	      Header Parameter of the resulting JWE.)
	    </t>
	    <t>
	      When Key Wrapping, Key Encryption,
	      or Key Agreement with Key Wrapping are employed,
	      generate a random Content Encryption Key (CEK) value.
	      See <xref target="RFC4086">RFC 4086</xref> for
	      considerations on generating random values.
	      The CEK MUST have a length equal to that
	      required for the content encryption algorithm.
	    </t>
	    <t>
	      When Direct Key Agreement or Key Agreement with Key Wrapping
	      are employed, use the key agreement algorithm
	      to compute the value of the agreed upon key.
	      When Direct Key Agreement is employed,
	      let the Content Encryption Key (CEK) be the agreed upon key.
	      When Key Agreement with Key Wrapping is employed,
	      the agreed upon key will be used to wrap the CEK.
	    </t>
	    <t>
	      When Key Wrapping, Key Encryption,
	      or Key Agreement with Key Wrapping are employed,
	      encrypt the CEK to the recipient and let the result be the
	      JWE Encrypted Key.
	    </t>
	    <t>
	      When Direct Key Agreement or Direct Encryption are employed,
	      let the JWE Encrypted Key be the empty octet sequence.
	    </t>
	    <t>
	      When Direct Encryption is employed,
	      let the Content Encryption Key (CEK) be the shared symmetric key.
	    </t>
	    <t>
	      Compute the encoded key value BASE64URL(JWE Encrypted Key).
	    </t>
	    <t>
	      If the JWE JSON Serialization is being used, repeat this process
	      (steps 1-7) <!-- TBD Make sure that these numbers are correct -->
	      for each recipient.
	    </t>
	    <t>
	      Generate a random JWE Initialization Vector of the correct size
	      for the content encryption algorithm (if required for the algorithm);
	      otherwise, let the JWE Initialization Vector be the empty octet sequence.
	    </t>
	    <t>
	      Compute the encoded initialization vector value
	      BASE64URL(JWE Initialization Vector).
	    </t>
	    <t>
	      If a <spanx style="verb">zip</spanx> parameter was included,
	      compress the Plaintext using the specified compression algorithm.
	    </t>
	    <t>
	      Serialize the (compressed) Plaintext into an octet sequence M.
	    </t>
	    <t>
	      Create the JSON object(s) containing the desired set of Header Parameters,
	      which together comprise the JWE Header:
	      the JWE Protected Header, and if the JWE JSON Serialization is being used,
	      the JWE Shared Unprotected Header and
	      the JWE Per-Recipient Unprotected Header.
	    </t>
	    <t>
	      Compute the Encoded Protected Header value
	      BASE64URL(UTF8(JWE Protected Header)).
	      If the JWE Protected Header is not present
	      (which can only happen when using the JWE JSON Serialization
	      and no <spanx style="verb">protected</spanx> member is present),
	      let this value be the empty string.
	    </t>
	    <t>
	      Let the Additional Authenticated Data encryption parameter be
	      ASCII(Encoded Protected Header).
	      However if a JWE AAD value is present
	      (which can only be the case when using the JWE JSON Serialization),
	      instead let the Additional Authenticated Data encryption parameter be
	      ASCII(Encoded Protected Header || '.' || BASE64URL(JWE AAD)).
	    </t>
	    <t>
	      Encrypt M using the CEK, the JWE Initialization Vector, and
	      the Additional Authenticated Data value
	      using the specified content encryption algorithm
	      to create the JWE Ciphertext value and the JWE Authentication Tag
	      (which is the Authentication Tag output from the encryption operation).
	    </t>
	    <t>
	      Compute the encoded ciphertext value BASE64URL(JWE Ciphertext).
	    </t>
	    <t>
	      Compute the encoded authentication tag value
	      BASE64URL(JWE Authentication Tag).
	    </t>
	    <t>
	      The five encoded values are used in both the
	      JWE Compact Serialization and the JWE JSON Serialization representations.
	    </t>
	    <t>
	      If a JWE AAD value is present,
	      compute the encoded AAD value BASE64URL(JWE AAD).
	    </t>

	    <t>
	      Create the desired serialized output.
	      The Compact Serialization of this result is the string
	      BASE64URL(UTF8(JWE Protected Header))
	      || '.' || BASE64URL(JWE Encrypted Key)
	      || '.' || BASE64URL(JWE Initialization Vector)
	      || '.' || BASE64URL(JWE Ciphertext)
	      || '.' || BASE64URL(JWE Authentication Tag).
	      The JWE JSON Serialization is described in <xref target="JSONSerialization"/>.
	    </t>
	  </list>
	</t>
      </section>

      <section title="Message Decryption" anchor="Decryption">
	<t>
	  The message decryption process is the reverse of the
	  encryption process.
	  The order of the steps is not significant in cases where
	  there are no dependencies between the inputs and outputs of the steps.
	  If any of these steps fails, the encrypted content cannot be validated.
	</t>
	<t>
	  It is an application decision which recipients' encrypted content
	  must successfully validate for the JWE to be accepted.
	  In some cases, encrypted content for all recipients must successfully validate
	  or the JWE will be rejected.
	  In other cases, only the encrypted content for a single recipient
	  needs to be successfully validated.
	  However, in all cases, the encrypted content for at least one recipient
	  MUST successfully validate or the JWE MUST be rejected.
	</t>
	<t>
	  <list style="numbers">
	    <t>
	      Parse the JWE representation to extract the serialized values
	      for the components of the JWE --
	      when using the JWE Compact Serialization,
	      the base64url encoded representations of
	      the JWE Protected Header,
	      the JWE Encrypted Key,
	      the JWE Initialization Vector,
	      the JWE Ciphertext, and
	      the JWE Authentication Tag,
	      and when using the JWE JSON Serialization,
	      also the base64url encoded representation of
	      the JWE AAD and the unencoded
	      JWE Shared Unprotected Header and
	      JWE Per-Recipient Unprotected Header values.
	      When using the JWE Compact Serialization,
	      the JWE Protected Header,
	      the JWE Encrypted Key,
	      the JWE Initialization Vector,
	      the JWE Ciphertext, and
	      the JWE Authentication Tag
	      are represented as base64url encoded values in that order,
	      separated by four period ('.') characters.
	      The JWE JSON Serialization
	      is described in <xref target="JSONSerialization"/>.
	    </t>
	    <t>
	      The encoded representations of
	      the JWE Protected Header,
	      the JWE Encrypted Key,
	      the JWE Initialization Vector,
	      the JWE Ciphertext,
	      the JWE Authentication Tag, and
	      the JWE AAD
	      MUST be successfully base64url decoded following the
	      restriction that no padding characters have been used.
	    </t>
	    <t>
	      The octet sequence resulting from decoding the encoded JWE Protected Header
	      MUST be a UTF-8 encoded representation of
	      a completely valid JSON object
	      conforming to <xref target="RFC4627">RFC 4627</xref>,
	      which is the JWE Protected Header.
	    </t>
	    <t>
	      If using the JWE Compact Serialization, let the JWE Header be the
	      JWE Protected Header;
	      otherwise, when using the JWE JSON Serialization,
	      let the JWE Header be the union of
	      the members of the JWE Protected Header,
	      the JWE Shared Unprotected Header and
	      the corresponding JWE Per-Recipient Unprotected Header,
	      all of which must be completely valid JSON objects.
	    </t>
	    <t>
	      The resulting JWE Header MUST NOT contain duplicate
	      Header Parameter names.
	      When using the JWE JSON Serialization, this restriction includes
	      that the same Header Parameter name also MUST NOT occur in
	      distinct JSON object values that together comprise the JWE Header.
	    </t>
	    <t>
	      Verify that the implementation understands and can process
	      all fields that it is required to support,
	      whether required by this specification,
	      by the algorithms being used,
	      or by the <spanx style="verb">crit</spanx> Header Parameter value,
	      and that the values of those parameters are also understood and supported.
	    </t>
	    <t>
	      Determine the Key Management Mode employed by the algorithm
	      specified by the
	      <spanx style="verb">alg</spanx> (algorithm) Header Parameter.
	    </t>
	    <t>
	      Verify that the JWE uses a key known to the recipient.
	    </t>
	    <t>
	      When Direct Key Agreement or Key Agreement with Key Wrapping
	      are employed, use the key agreement algorithm
	      to compute the value of the agreed upon key.
	      When Direct Key Agreement is employed,
	      let the Content Encryption Key (CEK) be the agreed upon key.
	      When Key Agreement with Key Wrapping is employed,
	      the agreed upon key will be used to decrypt the JWE Encrypted Key.
	    </t>
	    <t>
	      When Key Wrapping, Key Encryption,
	      or Key Agreement with Key Wrapping are employed,
	      decrypt the JWE Encrypted Key to produce the Content Encryption Key (CEK).
	      The CEK MUST have a length equal to that
	      required for the content encryption algorithm.
	      Note that when there are multiple recipients,
	      each recipient will only be able decrypt any JWE Encrypted Key values
	      that were encrypted to a key in that recipient's possession.
	      It is therefore normal to only be able to decrypt one of the
	      per-recipient JWE Encrypted Key values to obtain the CEK value.
	      To mitigate the attacks described in <xref target="RFC3218">RFC 3218</xref>,
	      the recipient MUST NOT distinguish between format, padding, and
	      length errors of encrypted keys.  It is strongly recommended,
	      in the event of receiving an improperly formatted key,
	      that the receiver substitute a randomly generated
	      CEK and proceed to the next step, to mitigate timing attacks.
	    </t>
	    <t>
	      When Direct Key Agreement or Direct Encryption are employed,
	      verify that the JWE Encrypted Key value is empty octet sequence.
	    </t>
	    <t>
	      When Direct Encryption is employed,
	      let the Content Encryption Key (CEK) be the shared symmetric key.
	    </t>
	    <t>
	      If the JWE JSON Serialization is being used, repeat this process
	      (steps 1-12) <!-- TBD Make sure that these numbers are correct -->
	      for each recipient contained in the representation
	      until the CEK value has been determined.
	    </t>
	    <t>
	      Compute the Encoded Protected Header value
	      BASE64URL(UTF8(JWE Protected Header)).
	      If the JWE Protected Header is not present
	      (which can only happen when using the JWE JSON Serialization
	      and no <spanx style="verb">protected</spanx> member is present),
	      let this value be the empty string.
	    </t>
	    <t>
	      Let the Additional Authenticated Data encryption parameter be
	      ASCII(Encoded Protected Header).
	      However if a JWE AAD value is present
	      (which can only be the case when using the JWE JSON Serialization),
	      instead let the Additional Authenticated Data encryption parameter be
	      ASCII(Encoded Protected Header || '.' || BASE64URL(JWE AAD)).
	    </t>
	    <t>
	      Decrypt the JWE Ciphertext using the CEK, the JWE Initialization Vector,
	      the Additional Authenticated Data value,
	      and the JWE Authentication Tag
	      (which is the Authentication Tag input to the calculation)
	      using the specified content encryption algorithm,
	      returning the decrypted plaintext and verifying the JWE Authentication Tag
	      in the manner specified for the algorithm,
	      rejecting the input without emitting any decrypted output
	      if the JWE Authentication Tag is incorrect.
	    </t>
	    <t>
	      If a <spanx style="verb">zip</spanx> parameter was included,
	      uncompress the decrypted plaintext using the specified compression algorithm.
	    </t>
	    <t>
	      If all the previous steps succeeded, output the resulting Plaintext.
	    </t>
	  </list>
	</t>
      </section>

      <section title="String Comparison Rules" anchor="StringComparison">

	<t>
	  The string comparison rules for this specification are the same as
	  those defined in
	  Section 5.3 of <xref target="JWS" />.
	</t>
      </section>

    </section>

    <section title="Key Identification" anchor="IDingKeys">
      <t>
	The key identification methods for this specification are the same as
	those defined in
	Section 6 of <xref target="JWS" />, except that
	the key being identified is
	the public key to which the JWE was encrypted.
      </t>
    </section>

    <section title="Serializations" anchor="Serializations">

      <t>
	JWE objects use one of two serializations, the
	JWE Compact Serialization
	or the
	JWE JSON Serialization.
	Applications using this specification need to specify what serialization
	and serialization features are used for that application.
	For instance, applications might specify
	that only the JWE JSON Serialization is used,
	that only JWE JSON Serialization support for a single recipient is used,
	or that support for multiple recipients is used.
	JWE implementations only need to implement the features needed
	for the applications they are designed to support.
      </t>

      <section title="JWE Compact Serialization" anchor="CompactSerialization">

	<t>
	  The JWE Compact Serialization represents encrypted
	  content as a compact URL-safe string.
	  This string is
	  BASE64URL(UTF8(JWE Protected Header))
	  || '.' || BASE64URL(JWE Encrypted Key)
	  || '.' || BASE64URL(JWE Initialization Vector)
	  || '.' || BASE64URL(JWE Ciphertext)
	  || '.' || BASE64URL(JWE Authentication Tag).
	  Only one recipient is supported by the JWE Compact Serialization
	  and it provides no syntax to represent
	  JWE Shared Unprotected Header,
	  JWE Per-Recipient Unprotected Header,
	  or JWE AAD values.
	</t>

      </section>

      <section title="JWE JSON Serialization" anchor="JSONSerialization">

	<t>
	  The JWE JSON Serialization represents encrypted
	  content as a JSON object.
	  Unlike the JWE Compact Serialization, content using
	  the JWE JSON Serialization can be encrypted to more than one recipient.
	</t>
	<t>
	  The representation is closely related to that used in the
	  JWE Compact Serialization,
	  with the following differences for the
	  JWE JSON Serialization:
	  <list style="symbols">
	    <t>
	      Values in the JWE JSON Serialization are represented as members of
	      a JSON object, rather than as base64url encoded strings
	      separated by period ('.') characters.
	      (However binary values and values that are integrity protected
	      are still base64url encoded.)
	    </t>
	    <t>
	      The value BASE64URL(UTF8(JWE Protected Header)), if non-empty, is stored in the
	      <spanx style="verb">protected</spanx> member.
	    </t>
	    <t>
	      The value BASE64URL(UTF8(JWE Shared Unprotected Header)), if non-empty, is stored in the
	      <spanx style="verb">unprotected</spanx> member.
	    </t>
	    <t>
	      The value BASE64URL(JWE Initialization Vector), if non-empty, is stored in the
	      <spanx style="verb">iv</spanx> member.
	    </t>
	    <t>
	      The value BASE64URL(JWE Ciphertext) is stored in the
	      <spanx style="verb">ciphertext</spanx> member.
	    </t>
	    <t>
	      The value BASE64URL(JWE Authentication Tag), if non-empty, is stored in the
	      <spanx style="verb">tag</spanx> member.
	    </t>
	    <t>
	      The JWE can be encrypted to multiple recipients, rather than just one.
	      A JSON array in the <spanx style="verb">recipients</spanx> member
	      is used to hold values that are specific to a particular
	      recipient, with one array element
	      per recipient represented.
	      These array elements are JSON objects.
	    </t>
	    <t>
	      Each value BASE64URL(JWE Encrypted Key), if non-empty, is stored in the
	      <spanx style="verb">encrypted_key</spanx> member of a JSON object
	      that is an element of the <spanx style="verb">recipients</spanx> array.
	    </t>
	    <t>
	      Some Header Parameter values, such as the <spanx style="verb">alg</spanx>
	      value and parameters used for selecting keys, can also differ for different
	      recipient computations.
	      JWE Per-Recipient Unprotected Header values, if present, are stored in the
	      <spanx style="verb">header</spanx> members of the same JSON objects
	      that are elements of the <spanx style="verb">recipients</spanx> array.
	    </t>
	    <t>
	      Some Header Parameters, including the <spanx style="verb">alg</spanx>
	      parameter, can be shared among all recipient computations.
	      Header Parameters in the JWE Protected Header and
	      JWE Shared Unprotected Header values are shared among all recipients.
	    </t>
	    <t>
	      Not all Header Parameters are integrity protected.
	      The shared Header Parameters in the JWE Protected Header value
	      member are integrity protected, and are base64url encoded for transmission.
	      The per-recipient Header Parameters in the
	      JWE Per-Recipient Unprotected Header values
	      and the shared Header Parameters in the
	      JWE Shared Unprotected Header value are not integrity protected.
	      These JSON objects containing Header Parameters that are
	      not integrity protected are not base64url encoded.
	    </t>
	    <t>
	      The Header Parameter values used when creating or validating
	      per-recipient Ciphertext and Authentication Tag values are
	      the union of the three sets of Header Parameter values that may be present:
	      (1) the JWE Protected Header values represented in the
	      <spanx style="verb">protected</spanx> member,
	      (2) the JWE Shared Unprotected Header values represented in the
	      <spanx style="verb">unprotected</spanx> member, and
	      (3) the JWE Per-Recipient Unprotected Header values represented in the
	      <spanx style="verb">header</spanx>
	      member of the recipient's array element.
	      The union of these sets of Header Parameters comprises the JWE Header.
	      The Header Parameter names in the three locations MUST be disjoint.
	    </t>
	    <t>
	      A JWE AAD value
	      can be included to supply a base64url encoded value
	      to be integrity protected but not encrypted.
	      (Note that this can also be achieved when using either serialization
	      by including the AAD value as a protected Header Parameter value,
	      but at the cost of the value being double base64url encoded.)
	      If a JWE AAD value is present,
	      the value BASE64URL(JWE AAD)) is stored in the
	      <spanx style="verb">aad</spanx> member.
	    </t>
	    <t>
	      The <spanx style="verb">recipients</spanx> array MUST always be present,
	      even if the array elements contain only the empty JSON object
	      <spanx style="verb">{}</spanx>
	      (which can happen when all Header Parameter values are shared
	      between all recipients and when no encrypted key is used,
	      such as when doing Direct Encryption).
	    </t>
	  </list>
	</t>

	<figure>
	  <preamble>
	    The syntax of a JWE using the JWE JSON Serialization is as follows:
	  </preamble>
	  <artwork><![CDATA[
  {"protected":<integrity-protected shared header contents>",
   "unprotected":<non-integrity-protected shared header contents>",
   "recipients":[
    {"header":"<per-recipient unprotected header 1 contents>",
     "encrypted_key":"<encrypted key 1 contents>"},
    ...
    {"header":"<per-recipient unprotected header N contents>",
     "encrypted_key":"<encrypted key N contents>"}],
   "aad":"<additional authenticated data contents>",
   "iv":"<initialization vector contents>",
   "ciphertext":"<ciphertext contents>",
   "tag":"<authentication tag contents>"
  }
]]></artwork></figure>

	<t>
	  Of these members, only the
	  <spanx style="verb">ciphertext</spanx>
	  member MUST be present.
	  The
	  <spanx style="verb">iv</spanx>,
	  <spanx style="verb">tag</spanx>,
	  and <spanx style="verb">encrypted_key</spanx>
	  members MUST be present when corresponding
	  JWE Initialization Vector,
	  JWE Authentication Tag,
	  and JWE Encrypted Key
	  values are non-empty.
	  The <spanx style="verb">recipients</spanx> member MUST be present when any
	  <spanx style="verb">header</spanx> or <spanx style="verb">encrypted_key</spanx>
	  members are needed for recipients.
	  At least one of the
	  <spanx style="verb">header</spanx>,
	  <spanx style="verb">protected</spanx>,
	  and <spanx style="verb">unprotected</spanx>
	  members MUST be present so that <spanx style="verb">alg</spanx>
	  and <spanx style="verb">enc</spanx>
	  Header Parameter values are conveyed for each recipient computation.
	</t>
	<t>
	  The contents of the
	  JWE Encrypted Key,
	  JWE Initialization Vector,
	  JWE Ciphertext, and
	  JWE Authentication Tag
	  values are exactly as defined in the rest of this specification.
	  They are interpreted and validated in the same manner,
	  with each corresponding
	  JWE Encrypted Key,
	  JWE Initialization Vector,
	  JWE Ciphertext,
	  JWE Authentication Tag, and
	  set of Header Parameter values
	  being created and validated together.
	  The JWE Header values used are the union of the Header Parameters in the
	  JWE Protected Header,
	  JWE Shared Unprotected Header, and
	  corresponding JWE Per-Recipient Unprotected Header values,
	  as described earlier.
	</t>
	<t>
	  Each JWE Encrypted Key value is computed using the
	  parameters of the corresponding JWE Header value
	  in the same manner as for the JWE Compact Serialization.
	  This has the desirable property that each
	  JWE Encrypted Key value
	  in the <spanx style="verb">recipients</spanx> array
	  is identical to the value
	  that would have been computed for the same parameter
	  in the JWE Compact Serialization.
	  Likewise, the JWE Ciphertext and JWE Authentication Tag values
	  match those produced for the JWE Compact Serialization,
	  provided that the JWE Protected Header value
	  (which represents the integrity-protected Header Parameter values)
	  matches that used in
	  the JWE Compact Serialization.
	</t>
	<t>
	  All recipients use the same
	  JWE Protected Header,
	  JWE Initialization Vector,
	  JWE Ciphertext,
	  and JWE Authentication Tag values, resulting in
	  potentially significant space savings if the message is large.
	  Therefore, all Header Parameters that specify the treatment of
	  the Plaintext value MUST be the same for all recipients.
	  This primarily means that the <spanx
	  style="verb">enc</spanx> (encryption method) Header Parameter
	  value in the JWE Header for each recipient
	  and any parameters of that algorithm MUST be the same.
	</t>
	<t>
	  See <xref target="JSONSerializationExample"/> for an example
	  of computing a JWE using the JWE JSON Serialization.
	</t>

      </section>

    </section>

     <section anchor="TLS_requirements" title="TLS Requirements">

      <t>
	The TLS requirements for this specification are the same as
	those defined in
	Section 8 of <xref target="JWS" />.
      </t>
    </section>

    <section title="Distinguishing Between JWS and JWE Objects" anchor="Distinguishing">

      <t>
	There are several ways of distinguishing whether an object is a
	JWS or JWE object.
	All these methods will yield the same result for all legal input values;
	they may yield different results for malformed inputs.

	<list style='symbols'>
	  <t>
	    If the object is using the JWS Compact Serialization or
	    the JWE Compact Serialization, the number of base64url encoded segments
	    separated by period ('.') characters differs for JWSs and JWEs.
	    JWSs have three segments separated by two period ('.') characters.
	    JWEs have five segments separated by four period ('.') characters.
	  </t>
	  <t>
	    If the object is using the JWS JSON Serialization or
	    the JWE JSON Serialization, the members used will be different.
	    JWSs have a <spanx style="verb">signatures</spanx> member and JWEs do not.
	    JWEs have a <spanx style="verb">recipients</spanx> member and JWSs do not.
	  </t>
	  <t>
	    A JWS Header can be distinguished from a JWE header by
	    examining the <spanx style="verb">alg</spanx>
	    (algorithm) Header Parameter value.
	    If the value represents a digital signature or MAC algorithm,
	    or is the value <spanx style="verb">none</spanx>, it is for a JWS;
	    if it represents a Key Encryption, Key Wrapping, Direct Key Agreement,
	    Key Agreement with Key Wrapping, or Direct Encryption algorithm, it is for a JWE.
	    (Extracting the <spanx style="verb">alg</spanx> value to examine is
	    straightforward when using the JWS Compact Serialization or
	    the JWE Compact Serialization and may be more difficult when
	    using the JWS JSON Serialization or the JWE JSON Serialization.)
	  </t>
	  <t>
	    A JWS Header can also be distinguished from a JWE header by
	    determining whether an
	    <spanx style="verb">enc</spanx> (encryption method) member exists.
	    If the <spanx style="verb">enc</spanx> member exists, it is a JWE;
	    otherwise, it is a JWS.
	  </t>
	</list>
      </t>
    </section>

    <section title="IANA Considerations" anchor="IANA">

      <section title="JSON Web Signature and Encryption Header Parameters Registration" anchor="HdrReg">
	<t>
	  This specification registers the Header Parameter names defined in
	  <xref target="RegisteredHeaderParameterName"/> in the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  defined in
	  <xref target="JWS" />.
	</t>

        <section title="Registry Contents" anchor="HdrContents">
          <t> <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">alg</spanx>
              </t>
              <t>
                Header Parameter Description: Algorithm
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="algDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">enc</spanx>
              </t>
              <t>
                Header Parameter Description: Encryption Method
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="encDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">zip</spanx>
              </t>
              <t>
                Header Parameter Description: Compression Algorithm
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="zipDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">jku</spanx>
              </t>
              <t>
                Header Parameter Description: JWK Set URL
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="jkuDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">jwk</spanx>
              </t>
              <t>
                Header Parameter Description: JSON Web Key
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification document(s): <xref target="jwkDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5u</spanx>
              </t>
              <t>
                Header Parameter Description: X.509 URL
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="x5uDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5t</spanx>
              </t>
              <t>
                Header Parameter Description: X.509 Certificate SHA-1 Thumbprint
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="x5tDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5c</spanx>
              </t>
              <t>
                Header Parameter Description: X.509 Certificate Chain
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="x5cDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">kid</spanx>
              </t>
              <t>
                Header Parameter Description: Key ID
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="kidDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">typ</spanx>
              </t>
              <t>
                Header Parameter Description: Type
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="typDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">cty</spanx>
              </t>
              <t>
                Header Parameter Description: Content Type
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="ctyDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">crit</spanx>
              </t>
              <t>
                Header Parameter Description: Critical
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="critDef"/> of [[ this document ]]
              </t>
            </list>
          </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

    </section>

    <section title="Security Considerations" anchor="Security">
      <t>
	All of the security issues faced by any cryptographic application
	must be faced by a JWS/JWE/JWK agent.  Among these issues are protecting
	the user's private and symmetric keys, preventing various attacks, and helping the
	user avoid mistakes such as inadvertently encrypting a message for
	the wrong recipient.  The entire list of security considerations is
	beyond the scope of this document.
      </t>
      <t>
	All the security considerations in the JWS specification
	also apply to this specification.
	Likewise, all the security considerations in
	<xref target="W3C.CR-xmlenc-core1-20120313">XML Encryption 1.1</xref>
	also apply, other than those that are XML specific.
      </t>
      <t>
	When decrypting, particular care must be taken not to allow
	the JWE recipient to be used as an oracle for decrypting messages.
	<xref target="RFC3218">RFC 3218</xref> should be consulted for specific
	countermeasures to attacks on RSAES-PKCS1-V1_5.
	An attacker might modify the contents of the <spanx style="verb">alg</spanx>
	parameter from <spanx style="verb">RSA-OAEP</spanx> to
	<spanx style="verb">RSA1_5</spanx> in order to generate a
	formatting error that can be detected and used to recover the CEK
	even if RSAES OAEP was used to encrypt the CEK.
	It is therefore particularly important to report all
	formatting errors to the CEK, Additional Authenticated Data,
	or ciphertext as a single error when the encrypted content is rejected.
      </t>
      <t>
	Additionally, this type of attack can be prevented by the use of "key tainting".
	This method restricts the use of a key to a limited set of algorithms
	-- usually one.
	This means, for instance, that if the key is marked as being for
	<spanx style="verb">RSA-OAEP</spanx> only, any attempt to decrypt a message
	using the <spanx style="verb">RSA1_5</spanx> algorithm with that key would
	fail immediately due to invalid use of the key.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.1951.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml' ?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-xmlenc-core1-20120313.xml" ?>

      <reference anchor="JWS">
        <front>
          <title>JSON Web Signature (JWS)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	    </address>
	  </author>

	  <date day="12" month="November" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-signature" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-signature" type="HTML" />
      </reference>

      <reference anchor="JWK">
        <front>
	  <title>JSON Web Key (JWK)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="12" month="November" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-key" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-key" type="HTML" />
      </reference>

      <reference anchor="JWA">
        <front>
	  <title>JSON Web Algorithms (JWA)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="12" month="November" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-algorithms" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms" type="HTML" />
      </reference>

      <reference anchor="USASCII">
	<front>
	  <title>Coded Character Set -- 7-bit American Standard Code for Information Interchange</title>
	  <author>
	    <organization>American National Standards Institute</organization>
	  </author>
	  <date year="1986"/>
	</front>
	<seriesInfo name="ANSI" value="X3.4"/>
      </reference>

      <reference anchor="ECMAScript">
	<front>
	  <title>ECMAScript Language Specification, 5.1 Edition</title>
	  <author>
	    <organization>Ecma International</organization>
	  </author>
	  <date month="June" year="2011"/>
	</front>
	<seriesInfo name="ECMA" value="262"/>
	<format target="http://www.ecma-international.org/ecma-262/5.1/" type="HTML" />
	<format target="http://www.ecma-international.org/ecma-262/5.1/ECMA-262.pdf" type="PDF" />
      </reference>

    </references>

    <references title="Informative References">
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3218.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5652.xml' ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-rescorla-jsms-00.xml" ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-mcgrew-aead-aes-cbc-hmac-sha2-01.xml" ?>

      <reference anchor="JSE">
        <front>
          <title>JSON Simple Encryption</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization abbrev="NRI">Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/enc/1.0/" type="HTML" />
      </reference>

    </references>


    <section title="JWE Examples" anchor="JWEExamples">

      <t>
	This section provides examples of JWE computations.
      </t>


      <section title="Example JWE using RSAES OAEP and AES GCM" anchor="OAEPGCMExample">
	<t>
	  This example encrypts the plaintext
	  "The true sign of intelligence is not knowledge but imagination."
	  to the recipient using RSAES OAEP for key encryption
	  and AES GCM for content encryption.
	  The representation of this plaintext is:
	</t>
	<t>
[84, 104, 101, 32, 116, 114, 117, 101, 32, 115, 105, 103, 110, 32, 111, 102,
 32, 105, 110, 116, 101, 108, 108, 105, 103, 101, 110, 99, 101, 32, 105, 115,
 32, 110, 111, 116, 32, 107, 110, 111, 119, 108, 101, 100, 103, 101, 32, 98,
 117, 116, 32, 105, 109, 97, 103, 105, 110, 97, 116, 105, 111, 110, 46]
	</t>

	<section title="JWE Header" anchor="OAEPGCMHeader">
	  <t>
	    The following example JWE Protected Header declares that:
	    <list style="symbols">
	      <t>
		the Content Encryption Key is encrypted to the recipient
		using the RSAES OAEP algorithm to produce
		the JWE Encrypted Key and
	      </t>
	      <t>
		the Plaintext is encrypted using the AES GCM
		algorithm with a 256 bit key to produce the Ciphertext.
	      </t>
	    </list>
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RSA-OAEP","enc":"A256GCM"}
]]></artwork></figure>

	  <t>
	    Encoding this JWE Protected Header as
	    BASE64URL(UTF8(JWE Protected Header)) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ
]]></artwork></figure>
	</section>

	<section title="Content Encryption Key (CEK)" anchor="OAEPGCMCEK">
	  <t>
	    Generate a 256 bit random Content Encryption Key (CEK).
	    In this example, the value is:
	  </t>
	  <t>
[177, 161, 244, 128, 84, 143, 225, 115, 63, 180, 3, 255, 107, 154, 212, 246,
 138, 7, 110, 91, 112, 46, 34, 105, 47, 130, 203, 46, 122, 234, 64, 252]
	  </t>
	</section>

	<section title="Key Encryption" anchor="OAEPGCEKeyEncryption">
	  <t>
	    Encrypt the CEK with the recipient's public key using the RSAES OAEP
	    algorithm to produce the JWE Encrypted Key.
	    This example uses the RSA key
	    represented in JSON Web Key <xref target="JWK" /> format below
	    (with line breaks for display purposes only):
	  </t>
	  <figure><artwork><![CDATA[
  {"kty":"RSA",
   "n":"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW
        cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S
        psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a
        sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS
        tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj
        YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw",
   "e":"AQAB",
   "d":"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N
        WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9
        3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk
        qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl
        t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd
        VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ"
  }
]]></artwork></figure>

	  <t>
	    The resulting JWE Encrypted Key value is:
	  </t>
	  <t>
[56, 163, 154, 192, 58, 53, 222, 4, 105, 218, 136, 218, 29, 94, 203, 22,
 150, 92, 129, 94, 211, 232, 53, 89, 41, 60, 138, 56, 196, 216, 82, 98,
 168, 76, 37, 73, 70, 7, 36, 8, 191, 100, 136, 196, 244, 220, 145, 158,
 138, 155, 4, 117, 141, 230, 199, 247, 173, 45, 182, 214, 74, 177, 107, 211,
 153, 11, 205, 196, 171, 226, 162, 128, 171, 182, 13, 237, 239, 99, 193, 4,
 91, 219, 121, 223, 107, 167, 61, 119, 228, 173, 156, 137, 134, 200, 80, 219,
 74, 253, 56, 185, 91, 177, 34, 158, 89, 154, 205, 96, 55, 18, 138, 43,
 96, 218, 215, 128, 124, 75, 138, 243, 85, 25, 109, 117, 140, 26, 155, 249,
 67, 167, 149, 231, 100, 6, 41, 65, 214, 251, 232, 87, 72, 40, 182, 149,
 154, 168, 31, 193, 126, 215, 89, 28, 111, 219, 125, 182, 139, 235, 195, 197,
 23, 234, 55, 58, 63, 180, 68, 202, 206, 149, 75, 205, 248, 176, 67, 39,
 178, 60, 98, 193, 32, 238, 122, 96, 158, 222, 57, 183, 111, 210, 55, 188,
 215, 206, 180, 166, 150, 166, 106, 250, 55, 229, 72, 40, 69, 214, 216, 104,
 23, 40, 135, 212, 28, 127, 41, 80, 175, 174, 168, 115, 171, 197, 89, 116,
 92, 103, 246, 83, 216, 182, 176, 84, 37, 147, 35, 45, 219, 172, 99, 226,
 233, 73, 37, 124, 42, 72, 49, 242, 35, 127, 184, 134, 117, 114, 135, 206]
	  </t>

	  <t>
	    Encoding this JWE Encrypted Key as
	    BASE64URL(JWE Encrypted Key) gives this value
	    (with line breaks for display purposes only):
	  </t>
<figure><artwork><![CDATA[
  OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe
  ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb
  Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV
  mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8
  1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi
  6UklfCpIMfIjf7iGdXKHzg
]]></artwork></figure>
	</section>

	<section title="Initialization Vector" anchor="OAEPGCMIV">
	  <t>
	    Generate a random 96 bit JWE Initialization Vector.
	    In this example, the value is:
	  </t>
	  <t>
	    [227, 197, 117, 252, 2, 219, 233, 68, 180, 225, 77, 219]
	  </t>
	  <t>
	    Encoding this JWE Initialization Vector as
	    BASE64URL(JWE Initialization Vector) gives this value:
	  </t>
<figure><artwork><![CDATA[
  48V1_ALb6US04U3b
]]></artwork></figure>
	</section>

	<section title='Additional Authenticated Data' anchor="OAEPGCMAAD">
	  <t>
	    Let the Additional Authenticated Data encryption parameter be
	    ASCII(BASE64URL(UTF8(JWE Protected Header))).
	    This value is:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 48, 69, 116,
 84, 48, 70, 70, 85, 67, 73, 115, 73, 109, 86, 117, 89, 121, 73, 54,
 73, 107, 69, 121, 78, 84, 90, 72, 81, 48, 48, 105, 102, 81]
	  </t>
	</section>

	<section title="Content Encryption" anchor="OAEPGCMEncryption">
	  <t>
	    Encrypt the Plaintext with AES GCM
	    using the CEK as the encryption key,
	    the JWE Initialization Vector,
	    and the Additional Authenticated Data value above,
	    requesting a 128 bit Authentication Tag output.
	    The resulting Ciphertext is:
	  </t>
	  <t>
[229, 236, 166, 241, 53, 191, 115, 196, 174, 43, 73, 109, 39, 122, 233, 96,
 140, 206, 120, 52, 51, 237, 48, 11, 190, 219, 186, 80, 111, 104, 50, 142,
 47, 167, 59, 61, 181, 127, 196, 21, 40, 82, 242, 32, 123, 143, 168, 226,
 73, 216, 176, 144, 138, 247, 106, 60, 16, 205, 160, 109, 64, 63, 192]
	  </t>
	  <t>
	    The resulting Authentication Tag value is:
	  </t>
	  <t>
[92, 80, 104, 49, 133, 25, 161, 215, 173, 101, 219, 211, 136, 91, 210, 145]
	  </t>

	  <t>
	    Encoding this JWE Ciphertext as
	    BASE64URL(JWE Ciphertext) gives this value
	    (with line breaks for display purposes only):
	  </t>
<figure><artwork><![CDATA[
  5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji
  SdiwkIr3ajwQzaBtQD_A
]]></artwork></figure>

	  <t>
	    Encoding this JWE Authentication Tag as
	    BASE64URL(JWE Authentication Tag) gives this value:
	  </t>
<figure><artwork><![CDATA[
  XFBoMYUZodetZdvTiFvSkQ
]]></artwork></figure>
	</section>

	<section title="Complete Representation" anchor="OAEPGCMComplete">
	  <t>
	    Assemble the final representation:
	    The Compact Serialization of this result is the string
	    BASE64URL(UTF8(JWE Protected Header))
	    || '.' || BASE64URL(JWE Encrypted Key)
	    || '.' || BASE64URL(JWE Initialization Vector)
	    || '.' || BASE64URL(JWE Ciphertext)
	    || '.' || BASE64URL(JWE Authentication Tag).
	  </t>
	  <t>
	    The final result in this example
	    (with line breaks for display purposes only) is:
	  </t>
	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.
  OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe
  ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb
  Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV
  mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8
  1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi
  6UklfCpIMfIjf7iGdXKHzg.
  48V1_ALb6US04U3b.
  5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji
  SdiwkIr3ajwQzaBtQD_A.
  XFBoMYUZodetZdvTiFvSkQ
]]></artwork></figure>
	</section>

	<section title="Validation" anchor="OAEPGCMValidation">
	  <t>
	    This example illustrates the process of creating a JWE with
	    RSAES OAEP for key encryption
	    and AES GCM for content encryption.
	    These results can be used to validate JWE decryption implementations for these algorithms.
	    Note that since the RSAES OAEP computation includes random values,
	    the encryption results above will not be completely reproducible.
	    However, since the AES GCM computation is deterministic, the JWE Encrypted Ciphertext
	    values will be the same for all encryptions performed using these inputs.
	  </t>
	</section>
      </section>


      <section title="Example JWE using RSAES-PKCS1-V1_5 and AES_128_CBC_HMAC_SHA_256" anchor="RSACBCExample">
	<t>
	  This example encrypts the plaintext
	  "Live long and prosper."
	  to the recipient using RSAES-PKCS1-V1_5 for key encryption
	  and AES_128_CBC_HMAC_SHA_256 for content encryption.
	  The representation of this plaintext is:
	</t>
	<t>
[76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32, 112, 114,
 111, 115, 112, 101, 114, 46]
	</t>

	<section title="JWE Header" anchor="RSACBCHeader">
	  <t>
	    The following example JWE Protected Header declares that:
	    <list style="symbols">
	      <t>
		the Content Encryption Key is encrypted to the recipient
		using the RSAES-PKCS1-V1_5 algorithm to produce
		the JWE Encrypted Key and
	      </t>
	      <t>
		the Plaintext is encrypted using the AES_128_CBC_HMAC_SHA_256
		algorithm to produce the Ciphertext.
	      </t>
	    </list>
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RSA1_5","enc":"A128CBC-HS256"}
]]></artwork></figure>

	  <t>
	    Encoding this JWE Protected Header as
	    BASE64URL(UTF8(JWE Protected Header)) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0
]]></artwork></figure>
	</section>

	<section title="Content Encryption Key (CEK)" anchor="RSACBCCEK">
	  <t>
	    Generate a 256 bit random Content Encryption Key (CEK).
	    In this example, the key value is:
	  </t>
	  <t>
[4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,
 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207]
	  </t>
	</section>

	<section title="Key Encryption" anchor="RSACBCKeyEncryption">
	  <t>
	    Encrypt the CEK with the recipient's public key using the RSAES-PKCS1-V1_5
	    algorithm to produce the JWE Encrypted Key.
	    This example uses the RSA key
	    represented in JSON Web Key <xref target="JWK" /> format below
	    (with line breaks for display purposes only):
	  </t>
	  <figure><artwork><![CDATA[
  {"kty":"RSA",
   "n":"sXchDaQebHnPiGvyDOAT4saGEUetSyo9MKLOoWFsueri23bOdgWp4Dy1Wl
        UzewbgBHod5pcM9H95GQRV3JDXboIRROSBigeC5yjU1hGzHHyXss8UDpre
        cbAYxknTcQkhslANGRUZmdTOQ5qTRsLAt6BTYuyvVRdhS8exSZEy_c4gs_
        7svlJJQ4H9_NxsiIoLwAEk7-Q3UXERGYw_75IDrGA84-lA_-Ct4eTlXHBI
        Y2EaV7t7LjJaynVJCpkv4LKjTTAumiGUIuQhrNhZLuF_RJLqHpM2kgWFLU
        7-VTdL1VbC2tejvcI2BlMkEpk1BzBZI0KQB0GaDWFLN-aEAw3vRw",
   "e":"AQAB",
   "d":"VFCWOqXr8nvZNyaaJLXdnNPXZKRaWCjkU5Q2egQQpTBMwhprMzWzpR8Sxq
        1OPThh_J6MUD8Z35wky9b8eEO0pwNS8xlh1lOFRRBoNqDIKVOku0aZb-ry
        nq8cxjDTLZQ6Fz7jSjR1Klop-YKaUHc9GsEofQqYruPhzSA-QgajZGPbE_
        0ZaVDJHfyd7UUBUKunFMScbflYAAOYJqVIVwaYR5zWEEceUjNnTNo_CVSj
        -VvXLO5VZfCUAVLgW4dpf1SrtZjSt34YLsRarSb127reG_DUwg9Ch-Kyvj
        T1SkHgUWRVGcyly7uvVGRSDwsXypdrNinPA4jlhoNdizK2zF2CWQ"
  }
]]></artwork></figure>

	  <t>
	    The resulting JWE Encrypted Key value is:
	  </t>
	  <t>
[80, 104, 72, 58, 11, 130, 236, 139, 132, 189, 255, 205, 61, 86, 151, 176,
 99, 40, 44, 233, 176, 189, 205, 70, 202, 169, 72, 40, 226, 181, 156, 223,
 120, 156, 115, 232, 150, 209, 145, 133, 104, 112, 237, 156, 116, 250, 65, 102,
 212, 210, 103, 240, 177, 61, 93, 40, 71, 231, 223, 226, 240, 157, 15, 31,
 150, 89, 200, 215, 198, 203, 108, 70, 117, 66, 212, 238, 193, 205, 23, 161,
 169, 218, 243, 203, 128, 214, 127, 253, 215, 139, 43, 17, 135, 103, 179, 220,
 28, 2, 212, 206, 131, 158, 128, 66, 62, 240, 78, 186, 141, 125, 132, 227,
 60, 137, 43, 31, 152, 199, 54, 72, 34, 212, 115, 11, 152, 101, 70, 42,
 219, 233, 142, 66, 151, 250, 126, 146, 141, 216, 190, 73, 50, 177, 146, 5,
 52, 247, 28, 197, 21, 59, 170, 247, 181, 89, 131, 241, 169, 182, 246, 99,
 15, 36, 102, 166, 182, 172, 197, 136, 230, 120, 60, 58, 219, 243, 149, 94,
 222, 150, 154, 194, 110, 227, 225, 112, 39, 89, 233, 112, 207, 211, 241, 124,
 174, 69, 221, 179, 107, 196, 225, 127, 167, 112, 226, 12, 242, 16, 24, 28,
 120, 182, 244, 213, 244, 153, 194, 162, 69, 160, 244, 248, 63, 165, 141, 4,
 207, 249, 193, 79, 131, 0, 169, 233, 127, 167, 101, 151, 125, 56, 112, 111,
 248, 29, 232, 90, 29, 147, 110, 169, 146, 114, 165, 204, 71, 136, 41, 252]
	  </t>

	  <t>
	    Encoding this JWE Encrypted Key as
	    BASE64URL(JWE Encrypted Key) gives this value
	    (with line breaks for display purposes only):
	  </t>
<figure><artwork><![CDATA[
  UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-kFm
  1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKxGHZ7Pc
  HALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3YvkkysZIF
  NPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPhcCdZ6XDP0_F8
  rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPgwCp6X-nZZd9OHBv
  -B3oWh2TbqmScqXMR4gp_A
]]></artwork></figure>
	</section>

	<section title="Initialization Vector" anchor="RSACBCIV">
	  <t>
	    Generate a random 128 bit JWE Initialization Vector.
	    In this example, the value is:
	  </t>
	  <t>
	    [3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104, 101]
	  </t>
	  <t>
	    Encoding this JWE Initialization Vector as
	    BASE64URL(JWE Initialization Vector) gives this value:
	  </t>
<figure><artwork><![CDATA[
  AxY8DCtDaGlsbGljb3RoZQ
]]></artwork></figure>
	</section>

	<section title='Additional Authenticated Data' anchor="RSACBCAAD">
	  <t>
	    Let the Additional Authenticated Data encryption parameter be
	    ASCII(BASE64URL(UTF8(JWE Protected Header))).
	    This value is:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 48, 69, 120,
 88, 122, 85, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50,
 73, 110, 48]
	  </t>
	</section>

	<section title="Content Encryption" anchor="RSACBCEncryption">
	  <t>
	    Encrypt the Plaintext with AES_128_CBC_HMAC_SHA_256
	    using the CEK as the encryption key,
	    the JWE Initialization Vector,
	    and the Additional Authenticated Data value above.
	    The steps for doing this using the values from <xref target="WrapExample"/>
	    are detailed in <xref target="CBC_HMAC_Example"/>.
	    The resulting Ciphertext is:
	  </t>
	  <t>
[40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6, 75,
 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143, 112, 56, 102]
	  </t>
	  <t>
	    The resulting Authentication Tag value is:
	  </t>
	  <t>
[246, 17, 244, 190, 4, 95, 98, 3, 231, 0, 115, 157, 242, 203, 100, 191]
	  </t>

	  <t>
	    Encoding this JWE Ciphertext as
	    BASE64URL(JWE Ciphertext) gives this value:
	  </t>
<figure><artwork><![CDATA[
  KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY
]]></artwork></figure>

	  <t>
	    Encoding this JWE Authentication Tag as
	    BASE64URL(JWE Authentication Tag) gives this value:
	  </t>
<figure><artwork><![CDATA[
  9hH0vgRfYgPnAHOd8stkvw
]]></artwork></figure>
	</section>

	<section title="Complete Representation" anchor="RSACBCComplete">
	  <t>
	    Assemble the final representation:
	    The Compact Serialization of this result is the string
	    BASE64URL(UTF8(JWE Protected Header))
	    || '.' || BASE64URL(JWE Encrypted Key)
	    || '.' || BASE64URL(JWE Initialization Vector)
	    || '.' || BASE64URL(JWE Ciphertext)
	    || '.' || BASE64URL(JWE Authentication Tag).
	  </t>
	  <t>
	    The final result in this example
	    (with line breaks for display purposes only) is:
	  </t>
	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.
  UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-kFm
  1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKxGHZ7Pc
  HALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3YvkkysZIF
  NPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPhcCdZ6XDP0_F8
  rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPgwCp6X-nZZd9OHBv
  -B3oWh2TbqmScqXMR4gp_A.
  AxY8DCtDaGlsbGljb3RoZQ.
  KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.
  9hH0vgRfYgPnAHOd8stkvw
]]></artwork></figure>
	</section>

	<section title="Validation" anchor="RSACBCValidation">
	  <t>
	    This example illustrates the process of creating a JWE with
	    RSAES-PKCS1-V1_5 for key encryption
	    and AES_CBC_HMAC_SHA2 for content encryption.
	    These results can be used to validate JWE decryption implementations for these algorithms.
	    Note that since the RSAES-PKCS1-V1_5 computation includes random values,
	    the encryption results above will not be completely reproducible.
	    However, since the AES CBC computation is deterministic, the JWE Encrypted Ciphertext
	    values will be the same for all encryptions performed using these inputs.
	  </t>
	</section>
      </section>


      <section title="Example JWE using AES Key Wrap and AES_128_CBC_HMAC_SHA_256" anchor="WrapExample">
	<t>
	  This example encrypts the plaintext
	  "Live long and prosper."
	  to the recipient using AES Key Wrap for key encryption
	  and AES GCM for content encryption.
	  The representation of this plaintext is:
	</t>
	<t>
[76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32, 112, 114,
 111, 115, 112, 101, 114, 46]
	</t>

	<section title="JWE Header" anchor="WrapHeader">
	  <t>
	    The following example JWE Protected Header declares that:
	    <list style="symbols">
	      <t>
		the Content Encryption Key is encrypted to the recipient
		using the AES Key Wrap algorithm with a 128 bit key to produce
		the JWE Encrypted Key and
	      </t>
	      <t>
		the Plaintext is encrypted using the AES_128_CBC_HMAC_SHA_256
		algorithm to produce the Ciphertext.
	      </t>
	    </list>
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"A128KW","enc":"A128CBC-HS256"}
]]></artwork></figure>

	  <t>
	    Encoding this JWE Protected Header as
	    BASE64URL(UTF8(JWE Protected Header)) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0
]]></artwork></figure>
	</section>

	<section title="Content Encryption Key (CEK)" anchor="WrapCEK">
	  <t>
	    Generate a 256 bit random Content Encryption Key (CEK).
	    In this example, the value is:
	  </t>
	  <t>
[4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,
 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207]
	  </t>
	</section>

	<section title="Key Encryption" anchor="WrapKeyEncryption">
	  <t>
	    Encrypt the CEK with the shared symmetric key using the AES Key Wrap
	    algorithm to produce the JWE Encrypted Key.
	    This example uses the symmetric key
	    represented in JSON Web Key <xref target="JWK" /> format below:
	  </t>
	  <figure><artwork><![CDATA[
  {"kty":"oct",
   "k":"GawgguFyGrWKav7AX4VKUg"
  }
]]></artwork></figure>

	  <t>
	    The resulting JWE Encrypted Key value is:
	  </t>
	  <t>
[232, 160, 123, 211, 183, 76, 245, 132, 200, 128, 123, 75, 190, 216, 22, 67,
 201, 138, 193, 186, 9, 91, 122, 31, 246, 90, 28, 139, 57, 3, 76, 124,
 193, 11, 98, 37, 173, 61, 104, 57]
	  </t>

	  <t>
	    Encoding this JWE Encrypted Key as
	    BASE64URL(JWE Encrypted Key) gives this value:
	  </t>
<figure><artwork><![CDATA[
  6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ
]]></artwork></figure>
	</section>

	<section title="Initialization Vector" anchor="WrapIV">
	  <t>
	    Generate a random 128 bit JWE Initialization Vector.
	    In this example, the value is:
	  </t>
	  <t>
	    [3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104, 101]
	  </t>
	  <t>
	    Encoding this JWE Initialization Vector as
	    BASE64URL(JWE Initialization Vector) gives this value:
	  </t>
<figure><artwork><![CDATA[
  AxY8DCtDaGlsbGljb3RoZQ
]]></artwork></figure>
	</section>

	<section title='Additional Authenticated Data' anchor="WrapAAD">
	  <t>
	    Let the Additional Authenticated Data encryption parameter be
	    ASCII(BASE64URL(UTF8(JWE Protected Header))).
	    This value is:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,
 83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50,
 73, 110, 48]
	  </t>
	</section>

	<section title="Content Encryption" anchor="WrapEncryption">
	  <t>
	    Encrypt the Plaintext with AES_128_CBC_HMAC_SHA_256
	    using the CEK as the encryption key,
	    the JWE Initialization Vector,
	    and the Additional Authenticated Data value above.
	    The steps for doing this using the values from this example
	    are detailed in <xref target="CBC_HMAC_Example"/>.
	    The resulting Ciphertext is:
	  </t>
	  <t>
[40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6, 75,
 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143, 112, 56, 102]
	  </t>
	  <t>
	    The resulting Authentication Tag value is:
	  </t>
	  <t>
[83, 73, 191, 98, 104, 205, 211, 128, 201, 189, 199, 133, 32, 38, 194, 85]
	  </t>

	  <t>
	    Encoding this JWE Ciphertext as
	    BASE64URL(JWE Ciphertext) gives this value:
	  </t>
<figure><artwork><![CDATA[
  KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY
]]></artwork></figure>

	  <t>
	    Encoding this JWE Authentication Tag as
	    BASE64URL(JWE Authentication Tag) gives this value:
	  </t>
<figure><artwork><![CDATA[
  U0m_YmjN04DJvceFICbCVQ
]]></artwork></figure>
	</section>

	<section title="Complete Representation" anchor="WrapComplete">
	  <t>
	    Assemble the final representation:
	    The Compact Serialization of this result is the string
	    BASE64URL(UTF8(JWE Protected Header))
	    || '.' || BASE64URL(JWE Encrypted Key)
	    || '.' || BASE64URL(JWE Initialization Vector)
	    || '.' || BASE64URL(JWE Ciphertext)
	    || '.' || BASE64URL(JWE Authentication Tag).
	  </t>
	  <t>
	    The final result in this example
	    (with line breaks for display purposes only) is:
	  </t>
	  <figure><artwork><![CDATA[
  eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.
  6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.
  AxY8DCtDaGlsbGljb3RoZQ.
  KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.
  U0m_YmjN04DJvceFICbCVQ
]]></artwork></figure>
	</section>

	<section title="Validation" anchor="WrapValidation">
	  <t>
	    This example illustrates the process of creating a JWE with
	    AES Key Wrap for key encryption
	    and AES GCM for content encryption.
	    These results can be used to validate JWE decryption implementations for these algorithms.
	    Also, since both the AES Key Wrap and AES GCM computations are deterministic,
	    the resulting JWE value will be the same for all encryptions performed using these inputs.
	    Since the computation is reproducible, these results can also be used to validate
	    JWE encryption implementations for these algorithms.
	  </t>
	</section>
      </section>

      <section title="Example JWE using JWE JSON Serialization" anchor="JSONSerializationExample">
	<t>
	  This section contains an example using the JWE JSON Serialization.
	  This example demonstrates the capability for
	  encrypting the same plaintext to multiple recipients.
	</t>
	<t>
	  Two recipients are present in this example.
	  The algorithm and key used for the first recipient
	  are the same as that used in <xref target="RSACBCExample"/>.
	  The algorithm and key used for the second recipient
	  are the same as that used in <xref target="WrapExample"/>.
	  The resulting JWE Encrypted Key values are therefore the same;
	  those computations are not repeated here.
	</t>
	<t>
	  The Plaintext, the Content Encryption Key (CEK), Initialization Vector,
	  and JWE Protected Header are shared by all recipients
	  (which must be the case, since the Ciphertext and
	  Authentication Tag are also shared).
	</t>

	<section title="JWE Per-Recipient Unprotected Headers" anchor="JSRecipientHeaders">
	  <t>
	    The first recipient uses the RSAES-PKCS1-V1_5 algorithm
	    to encrypt the Content Encryption Key (CEK).
	    The second uses AES Key Wrap to encrypt the CEK.
	    Key ID values are supplied for both keys.
	    The two per-recipient header values used to represent
	    these algorithms and Key IDs are:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RSA1_5","kid":"2011-04-29"}
]]></artwork></figure>

	  <t>
	    and
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"A128KW","kid":"7"}
]]></artwork></figure>
	</section>

	<section title="JWE Protected Header" anchor="JSProtectedHeader">
	  <t>
	    The Plaintext is encrypted using the AES_128_CBC_HMAC_SHA_256 algorithm
	    to produce the common JWE Ciphertext and JWE Authentication Tag values.
	    The JWE Protected Header value representing this is:
	  </t>

	  <figure><artwork><![CDATA[
  {"enc":"A128CBC-HS256"}
]]></artwork></figure>

	  <t>
	    Encoding this JWE Protected Header as
	    BASE64URL(UTF8(JWE Protected Header)) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0
]]></artwork></figure>

	</section>

	<section title="JWE Unprotected Header" anchor="JSUnprotectedHeader">
	  <t>
	    This JWE uses the <spanx style="verb">jku</spanx> Header Parameter
	    to reference a JWK Set.
	    This is represented in the following JWE Unprotected Header value as:
	  </t>

	  <figure><artwork><![CDATA[
  {"jku":"https://server.example.com/keys.jwks"}
]]></artwork></figure>

	</section>

	<section title="Complete JWE Header Values" anchor="JSHeader">
	  <t>
	    Combining the per-recipient, protected, and unprotected header values
	    supplied, the JWE Header values used for the first and second recipient
	    respectively are:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RSA1_5",
   "kid":"2011-04-29",
   "enc":"A128CBC-HS256",
   "jku":"https://server.example.com/keys.jwks"}
]]></artwork></figure>

	  <t>
	    and
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"A128KW",
   "kid":"7",
   "enc":"A128CBC-HS256",
   "jku":"https://server.example.com/keys.jwks"}
]]></artwork></figure>

	</section>

	<section title='Additional Authenticated Data' anchor="JSAAD">
	  <t>
	    Let the Additional Authenticated Data encryption parameter be
	    ASCII(BASE64URL(UTF8(JWE Protected Header))).
	    This value is:
	  </t>
	  <t>
	    [101, 121, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66, 77, 84, 73, 52,
	    81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50, 73, 110, 48]
	  </t>
	</section>

	<section title="Content Encryption" anchor="JSEncryption">
	  <t>
	    Encrypt the Plaintext with AES_128_CBC_HMAC_SHA_256
	    using the CEK as the encryption key,
	    the JWE Initialization Vector,
	    and the Additional Authenticated Data value above.
	    The steps for doing this using the values from <xref target="WrapExample"/>
	    are detailed in <xref target="CBC_HMAC_Example"/>.
	    The resulting Ciphertext is:
	  </t>
	  <t>
	    [40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6, 75,
	    129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143, 112, 56, 102]
	  </t>
	  <t>
	    The resulting Authentication Tag value is:
	  </t>
	  <t>
	    [51, 63, 149, 60, 252, 148, 225, 25, 92, 185, 139, 245, 35, 2, 47, 207]
	  </t>

	  <t>
	    Encoding this JWE Ciphertext as
	    BASE64URL(JWE Ciphertext) gives this value:
	  </t>
	  <figure><artwork><![CDATA[
  KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY
]]></artwork></figure>

	  <t>
	    Encoding this JWE Authentication Tag as
	    BASE64URL(JWE Authentication Tag) gives this value:
	  </t>
	  <figure><artwork><![CDATA[
  Mz-VPPyU4RlcuYv1IwIvzw
]]></artwork></figure>
	</section>

	<section title="Complete JWE JSON Serialization Representation" anchor="JSComplete">

	  <t>
	    The complete JSON Web Encryption JSON Serialization
	    for these values is as follows
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  {"protected":
    "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
   "unprotected":
    {"jku":"https://server.example.com/keys.jwks"},
   "recipients":[
    {"header":
      {"alg":"RSA1_5"},
     "encrypted_key":
      "UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-
       kFm1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKx
       GHZ7PcHALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3
       YvkkysZIFNPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPh
       cCdZ6XDP0_F8rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPg
       wCp6X-nZZd9OHBv-B3oWh2TbqmScqXMR4gp_A"},
    {"header":
      {"alg":"A128KW"},
     "encrypted_key":
      "6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ"}],
   "iv":
    "AxY8DCtDaGlsbGljb3RoZQ",
   "ciphertext":
    "KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY",
   "tag":
    "Mz-VPPyU4RlcuYv1IwIvzw"
  }
]]></artwork></figure>
	</section>

      </section>

    </section>

    <section title="Example AES_128_CBC_HMAC_SHA_256 Computation"
	     anchor="CBC_HMAC_Example">
      <t>
	This example shows the steps in the AES_128_CBC_HMAC_SHA_256
	authenticated encryption computation using the values from
	the example in <xref target="WrapExample"/>.
	As described where this algorithm is defined in
	Sections 4.8 and 4.8.3 of JWA, the AES_CBC_HMAC_SHA2 family
	of algorithms are implemented using
	Advanced Encryption Standard (AES) in Cipher Block Chaining (CBC) mode with PKCS #5 padding
	to perform the encryption and
	an HMAC SHA-2 function to perform the integrity calculation
	- in this case, HMAC SHA-256.
      </t>

      <section title="Extract MAC_KEY and ENC_KEY from Key" anchor="ExtractKeys">
	<t>
	  The 256 bit AES_128_CBC_HMAC_SHA_256 key K used in this example is:
	</t>
	<t>
	  [4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,
 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207]
	</t>
	<t>
	  Use the first 128 bits of this key as the HMAC SHA-256 key MAC_KEY, which is:
	</t>
	<t>
	  [4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206]
	</t>
	<t>
	  Use the last 128 bits of this key as the AES CBC key ENC_KEY, which is:
	</t>
	<t>
	  [107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207]
	</t>
	<t>
	  Note that the MAC key comes before the encryption key in the input key K;
	  this is in the opposite order of the algorithm names in
	  the identifiers "AES_128_CBC_HMAC_SHA_256" and
	  <spanx style="verb">A128CBC-HS256</spanx>.
	</t>
      </section>

      <section title="Encrypt Plaintext to Create Ciphertext"
	       anchor="EncryptWithCBC">
	<t>
	  Encrypt the Plaintext with
	  AES in Cipher Block Chaining (CBC) mode using PKCS #5 padding
	  using the ENC_KEY above.
	  The Plaintext in this example is:
	</t>
	<t>
[76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32, 112, 114,
 111, 115, 112, 101, 114, 46]
	</t>
	<t>
	  The encryption result is as follows, which is the Ciphertext output:
	</t>
	<t>
[40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6, 75,
 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143, 112, 56, 102]
	</t>
      </section>

      <section title="64 Bit Big Endian Representation of AAD Length"
	       anchor="CreateAL">
	<t>
	  The Additional Authenticated Data (AAD) in this example is:
	</t>
	<t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,
 83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50,
 73, 110, 48]
	</t>
	<t>
	  This AAD is 51 bytes long, which is 408 bits long.
	  The octet string AL, which is the number of bits in AAD
	  expressed as a big endian 64 bit unsigned integer is:
	</t>
	<t>
	  [0, 0, 0, 0, 0, 0, 1, 152]
	</t>
      </section>

      <section title="Initialization Vector Value" anchor="IVValue">
	<t>
	  The Initialization Vector value used in this example is:
	</t>
	<t>
[3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104, 101]
	</t>
      </section>

      <section title="Create Input to HMAC Computation" anchor="HMACInput">
	<t>
	  Concatenate
	  the AAD,
	  the Initialization Vector,
	  the Ciphertext,
	  and the AL value.
	  The result of this concatenation is:
	</t>
	<t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,
 83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50,
 73, 110, 48, 3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111,
 116, 104, 101, 40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152,
 230, 6, 75, 129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,
 112, 56, 102, 0, 0, 0, 0, 0, 0, 1, 152]
	</t>
      </section>

      <section title="Compute HMAC Value" anchor="DoHMAC">
	<t>
	  Compute the HMAC SHA-256 of the concatenated value above.  This result M is:
	</t>
	<t>
[83, 73, 191, 98, 104, 205, 211, 128, 201, 189, 199, 133, 32, 38, 194, 85,
 9, 84, 229, 201, 219, 135, 44, 252, 145, 102, 179, 140, 105, 86, 229, 116]
	</t>
      </section>

      <section title="Truncate HMAC Value to Create Authentication Tag"
	       anchor="DoTruncate">
	<t>
	  Use the first half (128 bits) of the HMAC output M as
	  the Authentication Tag output T. This truncated value is:
	</t>
	<t>
[83, 73, 191, 98, 104, 205, 211, 128, 201, 189, 199, 133, 32, 38, 194, 85]
	</t>
      </section>
    
    </section>


    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>
	Solutions for encrypting JSON content were also explored by
	<xref target="JSE">JSON Simple Encryption</xref> and
	<xref target="I-D.rescorla-jsms">JavaScript Message Security
	Format</xref>, both of which significantly influenced this draft.
	This draft attempts to explicitly reuse as many of the relevant concepts from
	<xref target="W3C.CR-xmlenc-core1-20120313">XML Encryption 1.1</xref>
	and <xref target="RFC5652">RFC 5652</xref> as possible,
	while utilizing simple, compact JSON-based data structures.
      </t>
      <t>
	Special thanks are due to John Bradley and Nat Sakimura for
	the discussions that helped inform the content of this
	specification and to Eric Rescorla and Joe Hildebrand for
	allowing the reuse of text from <xref
	target="I-D.rescorla-jsms"/> in this document.
      </t>
      <t>
	Thanks to Axel Nennker, Emmanuel Raviart, Brian Campbell, and Edmund Jay
	for validating the examples in this specification.
      </t>
      <t>
        This specification is the work of the JOSE Working Group,
	which includes dozens of active and dedicated participants.
	In particular, the following individuals contributed ideas,
        feedback, and wording that influenced this specification:
      </t>
      <t>
	Richard Barnes,
	John Bradley,
	Brian Campbell,
	Breno de Medeiros,
	Dick Hardt,
	Jeff Hodges,
	Edmund Jay,
	James Manger,
	Matt Miller,
	Tony Nadalin,
	Axel Nennker,
	Emmanuel Raviart,
	Nat Sakimura,
	Jim Schaad,
	Hannes Tschofenig,
	and Sean Turner.
      </t>
      <t>
	Jim Schaad and Karen O'Donoghue chaired the JOSE working group and
	Sean Turner and Stephen Farrell served as Security area directors
	during the creation of this specification.
      </t>
    </section>

    <section title="Document History" anchor="History">
      <t>
	[[ to be removed by the RFC Editor before publication as an RFC ]]
      </t>

      <t>
	-18
	<list style='symbols'>
	  <t>
	    Updated the mandatory-to-implement (MTI) language to say that
	    applications using this specification need to specify what serialization
	    and serialization features are used for that application,
	    addressing issue #176.	    
	  </t>
	  <t>
	    Changes to address editorial and minor issues
	    #89, #135, #165, #174, #175, #177, #179, and #180.
	  </t>
	  <t>
	    Used Header Parameter Description registry field.
	  </t>
	</list>
      </t>

      <t>
	-17
	<list style='symbols'>
	  <t>
	    Refined the <spanx style="verb">typ</spanx> and
	    <spanx style="verb">cty</spanx> definitions to always be
	    MIME Media Types, with the omission of "application/"
	    prefixes recommended for brevity,
	    addressing issue #50.
	  </t>
	  <t>
	    Updated the mandatory-to-implement (MTI) language to say
	    that general-purpose implementations must implement the
	    single recipient case for both serializations
	    whereas special-purpose implementations can implement
	    just one serialization if that meets the needs of
	    the use cases the implementation is designed for,
	    addressing issue #176.
	  </t>
	  <t>
	    Explicitly named all the logical components of a JWE
	    and defined the processing rules and serializations
	    in terms of those components,
	    addressing issues #60, #61, and #62.
	  </t>
	  <t>
	    Replaced verbose repetitive phases such as
	    "base64url encode the octets of the UTF-8 representation of X"
	    with mathematical notation such as "BASE64URL(UTF8(X))".
	  </t>
	  <t>
	    Header Parameters and processing rules occurring in both
	    JWS and JWE are now referenced in JWS by JWE, rather than duplicated,
	    addressing issue #57.
	  </t>
	  <t>
	    Terms used in multiple documents are now defined in
	    one place and incorporated by reference.
	    Some lightly used or obvious terms were also removed.
	    This addresses issue #58.
	  </t>
	</list>
      </t>

      <t>
	-16
	<list style='symbols'>
	  <t>
	    Changes to address editorial and minor issues
	    #163, #168, #169, #170, #172, and #173.
	  </t>
	</list>
      </t>

      <t>
	-15
	<list style='symbols'>
	  <t>
	    Clarified that it is an application decision which
	    recipients' encrypted content
	    must successfully validate for the JWE to be accepted,
	    addressing issue #35.
	  </t>
	  <t>
	    Changes to address editorial issues
	    #34, #164, and #169.
	  </t>
	</list>
      </t>

      <t>
	-14
	<list style='symbols'>
	  <t>
	    Clarified that the <spanx style="verb">protected</spanx>,
	    <spanx style="verb">unprotected</spanx>, <spanx style="verb">header</spanx>,
	    <spanx style="verb">iv</spanx>, <spanx style="verb">tag</spanx>,
	    and <spanx style="verb">encrypted_key</spanx>
	    parameters are to be omitted in the JWE JSON Serialization
	    when their values would be empty.
	    Stated that the <spanx style="verb">recipients</spanx>
	    array must always be present.
	  </t>
	</list>
      </t>

      <t>
	-13
	<list style='symbols'>
	  <t>
	    Added an <spanx style="verb">aad</spanx> (Additional Authenticated Data) member
	    for the JWE JSON Serialization, enabling Additional Authenticated Data
	    to be supplied that is not double base64url encoded,
	    addressing issue #29.
	  </t>
	</list>
      </t>

      <t>
	-12
	<list style='symbols'>
	  <t>
	    Clarified that the <spanx style="verb">typ</spanx> and
	    <spanx style="verb">cty</spanx> header parameters are used
	    in an application-specific manner
	    and have no effect upon the JWE processing.
	  </t>
	  <t>
	    Replaced the MIME types
	    <spanx style="verb">application/jwe+json</spanx> and
	    <spanx style="verb">application/jwe</spanx> with
	    <spanx style="verb">application/jose+json</spanx> and
	    <spanx style="verb">application/jose</spanx>.
	  </t>
	  <t>
	    Stated that recipients MUST either reject JWEs with
	    duplicate Header Parameter Names
	    or use a JSON parser that returns only
	    the lexically last duplicate member name.
	  </t>
	  <t>
	    Moved the
	    <spanx style="verb">epk</spanx>,
	    <spanx style="verb">apu</spanx>, and
	    <spanx style="verb">apv</spanx>
	    Header Parameter definitions to be with
	    the algorithm descriptions that use them.
	  </t>
	  <t>
	    Added a Serializations section with parallel treatment of the
	    JWE Compact Serialization
	    and the
	    JWE JSON Serialization
	    and also moved the former Implementation Considerations content there.
	  </t>
	  <t>
	    Restored use of the term "AEAD".
	  </t>
	  <t>
	    Changed terminology from "block encryption" to "content encryption".
	  </t>
	</list>
      </t>

      <t>
	-11
	<list style='symbols'>
	  <t>
	    Added Key Identification section.
	  </t>
	  <t>
	    Removed the Encrypted Key value from the AAD computation since it is
	    already effectively integrity protected by the encryption process.
	    The AAD value now only contains the representation of the JWE Encrypted Header.
	  </t>
	  <t>
	    For the JWE JSON Serialization, enable Header Parameter values
	    to be specified in any of three parameters:
	    the <spanx style="verb">protected</spanx> member that is
	    integrity protected and shared among all recipients,
	    the <spanx style="verb">unprotected</spanx> member that is
	    not integrity protected and shared among all recipients,
	    and the <spanx style="verb">header</spanx> member that is
	    not integrity protected and specific to a particular recipient.
	    (This does not affect the JWE Compact Serialization, in which all
	    Header Parameter values are in a single integrity protected JWE Header value.)
	  </t>
	  <t>
	    Shortened the names <spanx style="verb">authentication_tag</spanx> to
	    <spanx style="verb">tag</spanx> and
	    <spanx style="verb">initialization_vector</spanx> to
	    <spanx style="verb">iv</spanx> in the JWE JSON Serialization,
	    addressing issue #20.
	  </t>
	  <t>
	    Removed <spanx style="verb">apv</spanx> (agreement PartyVInfo)
	    since it is no longer used.
	  </t>
	  <t>
	    Removed suggested compact serialization for multiple recipients.
	  </t>
	  <t>
	    Changed the MIME type name <spanx style="verb">application/jwe-js</spanx>
	    to <spanx style="verb">application/jwe+json</spanx>,
	    addressing issue #22.
	  </t>
	  <t>
	    Tightened the description of the
	    <spanx style="verb">crit</spanx> (critical) header parameter.
	  </t>
	</list>
      </t>
      <t>
	-10
	<list style='symbols'>
	  <t>
	    Changed the JWE processing rules for multiple recipients so that
	    a single AAD value contains the header parameters and encrypted key
	    values for all the recipients,
	    enabling AES GCM to be safely used for multiple recipients.
	  </t>
	  <t>
	    Added an appendix suggesting a possible compact serialization
	    for JWEs with multiple recipients.
	  </t>
	</list>
      </t>
      <t>
	-09
	<list style='symbols'>
	  <t>
	    Added JWE JSON Serialization, as specified by
	    draft-jones-jose-jwe-json-serialization-04.
	  </t>
	  <t>
	    Registered <spanx style="verb">application/jwe-js</spanx> MIME type
	    and <spanx style="verb">JWE-JS</spanx> typ header parameter value.
	  </t>
	  <t>
	    Defined that the default action for header parameters that
	    are not understood is to ignore them unless specifically
	    designated as "MUST be understood" or included in the new
	    <spanx style="verb">crit</spanx> (critical) header parameter list.
	    This addressed issue #6.
	  </t>
	  <t>
	    Corrected <spanx style="verb">x5c</spanx> description.
	    This addressed issue #12.
	  </t>
	  <t>
	    Changed from using the term "byte" to "octet" when referring to 8 bit values.
	  </t>
	  <t>
	    Added Key Management Mode definitions to terminology section
	    and used the defined terms to provide clearer key management instructions.
	    This addressed issue #5.
	  </t>
	  <t>
	    Added text about preventing the recipient from behaving as an oracle
	    during decryption, especially when using RSAES-PKCS1-V1_5.
	  </t>
	  <t>
	    Changed from using the term "Integrity Value" to "Authentication Tag".
	  </t>
	  <t>
	    Changed member name from <spanx style="verb">integrity_value</spanx> to
	    <spanx style="verb">authentication_tag</spanx> in the JWE JSON Serialization.
	  </t>
	  <t>
	    Removed Initialization Vector from the AAD value since it is already
	    integrity protected by all of the authenticated encryption algorithms
	    specified in the JWA specification.
	  </t>
	  <t>
	    Replaced <spanx style="verb">A128CBC+HS256</spanx>
	    and <spanx style="verb">A256CBC+HS512</spanx>
	    with <spanx style="verb">A128CBC-HS256</spanx>
	    and <spanx style="verb">A256CBC-HS512</spanx>.
	    The new algorithms perform the same cryptographic computations as
	    <xref target="I-D.mcgrew-aead-aes-cbc-hmac-sha2"/>,
	    but with the Initialization Vector and Authentication Tag values remaining
	    separate from the Ciphertext value in the output representation.
	    Also deleted the header parameters
	    <spanx style="verb">epu</spanx> (encryption PartyUInfo) and
	    <spanx style="verb">epv</spanx> (encryption PartyVInfo),
	    since they are no longer used.
	  </t>
	</list>
      </t>
      <t>
	-08
	<list style='symbols'>
	  <t>
	    Replaced uses of the term "AEAD" with "Authenticated Encryption", since
	    the term AEAD in the RFC 5116 sense implied the use of a particular
	    data representation, rather than just referring to the class of
	    algorithms that perform authenticated encryption with associated data.
	  </t>
	  <t>
	    Applied editorial improvements suggested by
	    Jeff Hodges and Hannes Tschofenig.
	    Many of these simplified the terminology used.
	  </t>
	  <t>
	    Clarified statements of the form "This header parameter is OPTIONAL"
	    to "Use of this header parameter is OPTIONAL".
	  </t>
	  <t>
	    Added a Header Parameter Usage Location(s) field to the
	    IANA JSON Web Signature and Encryption Header Parameters registry.
	  </t>
	  <t>
	    Added seriesInfo information to Internet Draft references.
	  </t>
	</list>
      </t>
      <t>
	-07
	<list style='symbols'>
	  <t>
	    Added a data length prefix to PartyUInfo and PartyVInfo values.
	  </t>
	  <t>
	    Updated values for example AES CBC calculations.
	  </t>
	  <t>
	    Made several local editorial changes to clean up loose ends
	    left over from to the decision to only support
	    block encryption methods providing integrity.
	    One of these changes was to explicitly state that the
	    <spanx style="verb">enc</spanx> (encryption method) algorithm
	    must be an Authenticated Encryption algorithm with a specified key length.
	  </t>
	</list>
      </t>
      <t>
	-06
	<list style='symbols'>
	  <t>
	    Removed the <spanx style="verb">int</spanx> and
	    <spanx style="verb">kdf</spanx> parameters and defined the new composite
	    Authenticated Encryption algorithms <spanx style="verb">A128CBC+HS256</spanx> and
	    <spanx style="verb">A256CBC+HS512</spanx> to replace the former
	    uses of AES CBC, which required the use of separate integrity
	    and key derivation functions.
	  </t>
	  <t>
	    Included additional values in the Concat KDF calculation -- the
	    desired output size and the algorithm value,
	    and optionally PartyUInfo and PartyVInfo values.
	    Added the optional header parameters
	    <spanx style="verb">apu</spanx> (agreement PartyUInfo),
	    <spanx style="verb">apv</spanx> (agreement PartyVInfo),
	    <spanx style="verb">epu</spanx> (encryption PartyUInfo), and
	    <spanx style="verb">epv</spanx> (encryption PartyVInfo).
	    Updated the KDF examples accordingly.
	  </t>
	  <t>
	    Promoted Initialization Vector from being a header parameter to being
	    a top-level JWE element.
	    This saves approximately 16 bytes in the compact serialization,
	    which is a significant savings for some use cases.
	    Promoting the Initialization Vector out of the header also avoids repeating
	    this shared value in the JSON serialization.
	  </t>
	  <t>
	    Changed <spanx style="verb">x5c</spanx> (X.509 Certificate Chain)
	    representation from being a single string to being an array of strings,
	    each containing a single base64 encoded DER certificate value,
	    representing elements of the certificate chain.
	  </t>
	  <t>
	    Added an AES Key Wrap example.
	  </t>
	  <t>
	    Reordered the encryption steps so CMK creation is first, when required.
	  </t>
	  <t>
	    Correct statements in examples about which algorithms produce
	    reproducible results.
	  </t>
	</list>
      </t>
      <t>
	-05
	<list style='symbols'>
	  <t>
	    Support both direct encryption using a
	    shared or agreed upon symmetric key, and the use of a
	    shared or agreed upon symmetric key to key wrap the CMK.
	  </t>
	  <t>
	    Added statement that
	    "StringOrURI values are compared as case-sensitive strings
	    with no transformations or canonicalizations applied".
	  </t>
	  <t>
	    Updated open issues.
	  </t>
	  <t>
	    Indented artwork elements to better distinguish them from the body text.
	  </t>
	</list>
      </t>
      <t>
	-04
	<list style='symbols'>
	  <t>
	    Refer to the registries as the primary sources of defined
	    values and then secondarily reference the sections
	    defining the initial contents of the registries.
	  </t>
	  <t>
	    Normatively reference
	    <xref target="W3C.CR-xmlenc-core1-20120313">XML Encryption 1.1</xref>
	    for its security considerations.
	  </t>
	  <t>
	    Reference draft-jones-jose-jwe-json-serialization
	    instead of draft-jones-json-web-encryption-json-serialization.
	  </t>
	  <t>
	    Described additional open issues.
	  </t>
	  <t>
	    Applied editorial suggestions.
	  </t>
	</list>
      </t>
      <t>
        -03
        <list style='symbols'>
	  <t>
	    Added the <spanx style="verb">kdf</spanx> (key derivation function) header parameter
	    to provide crypto agility for key derivation.
	    The default KDF remains the Concat KDF with the SHA-256 digest function.
	  </t>
	  <t>
	    Reordered encryption steps so that the Encoded JWE Header
	    is always created before it is needed as an input to the Authenticated Encryption
	    "additional authenticated data" parameter.
	  </t>
	  <t>
	    Added the <spanx style="verb">cty</spanx> (content type) header parameter
	    for declaring type information about the secured content,
	    as opposed to the <spanx style="verb">typ</spanx> (type) header parameter,
	    which declares type information about this object.
	  </t>
	  <t>
	    Moved description of how to determine whether a header is
	    for a JWS or a JWE from the JWT spec to the JWE spec.
	  </t>
	  <t>
	    Added complete encryption examples for both Authenticated Encryption and non-Authenticated Encryption algorithms.
	  </t>
	  <t>
	    Added complete key derivation examples.
	  </t>
	  <t>
	    Added "Collision Resistant Namespace" to the terminology section.
	  </t>
	  <t>
	    Reference ITU.X690.1994 for DER encoding.
	  </t>
	  <t>
	    Added Registry Contents sections to populate registry values.
	  </t>
	  <t>
	    Numerous editorial improvements.
	  </t>
        </list>
      </t>
      <t>
        -02
        <list style='symbols'>
	  <t>
	    When using Authenticated Encryption algorithms (such as AES GCM),
	    use the "additional authenticated data" parameter
	    to provide integrity for the header, encrypted key, and
	    ciphertext and use the resulting "authentication tag"
	    value as the JWE Authentication Tag.
	  </t>
	  <t>
	    Defined KDF output key sizes.
	  </t>
	  <t>
	    Generalized text to allow key agreement to be employed
	    as an alternative to key wrapping or key encryption.
	  </t>
	  <t>
	    Changed compression algorithm from gzip to DEFLATE.
	  </t>
	  <t>
	    Clarified that it is an error when a <spanx style="verb">kid</spanx>
	    value is included and no matching key is found.
	  </t>
	  <t>
	    Clarified that JWEs with duplicate Header Parameter Names
	    MUST be rejected.
	  </t>
	  <t>
	    Clarified the relationship between
	    <spanx style="verb">typ</spanx> header parameter values
	    and MIME types.
	  </t>
	  <t>
	    Registered application/jwe MIME type and "JWE" typ header parameter value.
	  </t>
	  <t>
	    Simplified JWK terminology to get replace the "JWK Key Object" and
	    "JWK Container Object" terms with simply "JSON Web Key (JWK)"
	    and "JSON Web Key Set (JWK Set)" and to eliminate potential
	    confusion between single keys and sets of keys.
	    As part of this change, the Header Parameter Name for a
	    public key value was changed from
	    <spanx style="verb">jpk</spanx> (JSON Public Key) to
	    <spanx style="verb">jwk</spanx> (JSON Web Key).
	  </t>
	  <t>
	    Added suggestion on defining additional header parameters
	    such as <spanx style="verb">x5t#S256</spanx> in the future
	    for certificate thumbprints using hash algorithms other
	    than SHA-1.
	  </t>
	  <t>
	    Specify RFC 2818 server identity validation, rather than
	    RFC 6125 (paralleling the same decision in the OAuth specs).
	  </t>
	  <t>
	    Generalized language to refer to Message Authentication Codes (MACs)
	    rather than Hash-based Message Authentication Codes (HMACs)
	    unless in a context specific to HMAC algorithms.
	  </t>
          <t>
            Reformatted to give each header parameter its own section heading.
          </t>
        </list>
      </t>
      <t>
        -01
        <list style='symbols'>
          <t>
           Added an integrity check for non-Authenticated Encryption algorithms.
          </t>
	  <t>
	    Added <spanx style="verb">jpk</spanx> and <spanx
	    style="verb">x5c</spanx> header parameters for including
	    JWK public keys and X.509 certificate chains directly in
	    the header.
	  </t>
	  <t>
	    Clarified that this specification is defining the JWE
	    Compact Serialization.  Referenced the new JWE-JS spec,
	    which defines the JWE JSON Serialization.
	  </t>
	  <t>
	    Added text "New header parameters should be introduced
	    sparingly since an implementation that does not understand
	    a parameter MUST reject the JWE".
	  </t>
	  <t>
	    Clarified that the order of the encryption and decryption
	    steps is not significant in cases where there are no
	    dependencies between the inputs and outputs of the steps.
	  </t>
	  <t>
	    Made other editorial improvements suggested by JOSE
	    working group participants.
	  </t>
        </list>
      </t>
      <t>
        -00
        <list style='symbols'>
          <t>
            Created the initial IETF draft based upon
            draft-jones-json-web-encryption-02 with no normative
            changes.
          </t>
	  <t>
	    Changed terminology to no longer call both digital
	    signatures and HMACs "signatures".
	  </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
