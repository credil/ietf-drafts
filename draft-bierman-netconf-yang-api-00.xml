<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?rfc toc="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no"?>
<?rfc strict="yes"?>
<rfc ipr="trust200902" category="std" docName="draft-bierman-netconf-yang-api-00" >
    <front>
    <title abbrev="YANG-API">YANG-API Protocol</title>

    <author initials="A" surname="Bierman" fullname='Andy Bierman' >
      <organization>YumaWorks</organization>
      <address>
        <email>andy@yumaworks.com</email>
      </address>
    </author>
    <author initials="M" surname="Bjorklund" fullname='Martin Bjorklund' >
      <organization>Tail-f Systems</organization>
      <address>
        <email>mbj@tail-f.com</email>
      </address>
    </author>
	<date/>
    <abstract>
	<t>
This document describes a RESTful protocol that provides 
a programmatic interface over HTTP for accessing data
defined in YANG, using the datastores defined in NETCONF.
	</t>
</abstract>
</front>
<middle>
<section title="Introduction">
    <t>
There is a need for standard mechanisms to allow WEB applications
to access the configuration data, operational data, and
data-model specific RPC operations within
a networking device, in a modular and extensible manner.
    </t>
    <t>
This document describes a RESTful protocol called YANG-API,
running over HTTP <xref target="RFC2616"/>, for accessing data defined
in YANG <xref target="RFC6020"/>, using datastores defined in NETCONF <xref target="RFC6241"/>.
    </t>
    <t>
The NETCONF protocol defines configuration datastores and
a set of Create, Retrieve, Update, Delete (CRUD) operations 
that can be used to access these datastores.  The YANG language
defines the syntax and semantics of datastore content
and operational data. RESTful operations are used to
access the hierarchical data within a datastore.
    </t>
    <t>
A RESTful API can be created that provides CRUD operations on a
NETCONF datastore containing YANG-defined data.  This can be done in a
simplified manner, compatible with HTTP and RESTful design principles.
Since NETCONF protocol operations are not relevant, the user should
not need any prior knowledge of NETCONF in order to use the RESTful
API.
    </t>
    <t>
Configuration data and state data are exposed as resources that
can be retrieved with the GET method.  
Resources representing configuration data
can be modified with the DELETE, PATCH, POST, and PUT methods.
Data-model specific RPC operations defined with
the YANG &quot;rpc&quot; statement can be invoked with the POST method.
    </t>
    <t>
The framework and meta-model used for a RESTful API does not need to
mirror those used by the NETCONF protocol. It just needs to be compatible
with NETCONF.  A simplified framework and protocol is needed
that aligns with the three NETCONF datastores (candidate, running, startup).
A simplified yet more powerful transaction model is needed that
exposes the proper functionality without over-restricting server design.
    </t>
    <t>
The RESTful API is not intended to replace NETCONF, but rather provide
an additional simplified interface that follows RESTful principles and
is compatible with a resource-oriented device abstraction.  It is
expected that applications that need the full feature set of NETCONF
such as notifications will continue to use NETCONF.
    </t>
    <t>
The following figure shows the system components:
    </t>
	<figure>
	    <artwork><![CDATA[
      +-----------+           +-----------------+
      |  WEB app  | <-------> |                 |
      +-----------+   HTTP    | network device  |
                              |                 |
      +-----------+           |   +-----------+ |
      |  NMS app  | <-------> |   | datastore | |
      +-----------+  NETCONF  |   +-----------+ |
                              +-----------------+
	    ]]></artwork>
	</figure>
<section title="Terminology">
    <t>
The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
&quot;OPTIONAL&quot; in this document are to be interpreted as described in BCP
14, <xref target="RFC2119"/>.
    </t>
<section title="NETCONF">
    <t>
The following terms are defined in <xref target="RFC6241"/>:
    </t>
<t>
 <list style="symbols">
 <t>
candidate configuration datastore
 </t>
 <t>
client
 </t>
 <t>
configuration data
 </t>
 <t>
datastore
 </t>
 <t>
configuration datastore
 </t>
 <t>
protocol operation
 </t>
 <t>
running configuration datastore
 </t>
 <t>
server
 </t>
 <t>
startup configuration datastore
 </t>
 <t>
state data
 </t>
 <t>
user
 </t>
 </list>
</t>
</section>
<section title="HTTP">
    <t>
The following terms are defined in <xref target="RFC2616"/>:
    </t>
<t>
 <list style="symbols">
 <t>
entity tag
 </t>
 <t>
fragment
 </t>
 <t>
header line
 </t>
 <t>
message body
 </t>
 <t>
method
 </t>
 <t>
path
 </t>
 <t>
query
 </t>
 <t>
request URI
 </t>
 <t>
response body
 </t>
 </list>
</t>
</section>
<section title="YANG">
    <t>
The following terms are defined in <xref target="RFC6020"/>:
    </t>
<t>
 <list style="symbols">
 <t>
container
 </t>
 <t>
data node
 </t>
 <t>
key leaf
 </t>
 <t>
leaf
 </t>
 <t>
leaf-list
 </t>
 <t>
list
 </t>
 <t>
presence container (or P-container)
 </t>
 <t>
RPC operation
 </t>
 <t>
non-presence container (or NP-container)
 </t>
 <t>
ordered-by system
 </t>
 <t>
ordered-by user
 </t>
 </list>
</t>
</section>
<section title="Terms">
    <t>
The following terms are used within this document:
    </t>
<t>
 <list style="symbols">
 <t>
API resource: a resource with the media type 
&quot;application/vnd.yang.api+xml&quot; or &quot;&quot;application/vnd.yang.api+json&quot;.
 </t>
 <t>
data resource: a resource with the media type 
&quot;application/vnd.yang.data+xml&quot; or &quot;application/vnd.yang.data+json&quot;.
 </t>
 <t>
datastore resource: a resource with the media type 
&quot;application/vnd.yang.datastore+xml&quot; or 
&quot;application/vnd.yang.datastore+json&quot;
 </t>
 <t>
edit operation: a YANG-API operation on a data resource
using the POST, PUT, PATCH, or DELETE method.
 </t>
 <t>
operation: the conceptual YANG-API operation for a message, derived from the
method, request URI, headers, and message body.
 </t>
 <t>
operation resource: a resource with the media type 
&quot;vnd.yang.operation+xml&quot; or &quot;vnd.yang.operation+json&quot;
 </t>
 <t>
optional key: a key leaf for a YANG list data node,
which MAY be omitted by the client when an instance of the list
is created.
 </t>
 <t>
query parameter: a parameter (and its value if any),
encoded within the query portion of the request URI.
 </t>
 <t>
resource: a conceptual object representing a manageable 
component within a device.
 </t>
 <t>
retrieval request: an operation using the GET or HEAD methods.
 </t>
 <t>
target resource: the resource that is associated with
a particular message, identified by the &quot;path&quot; component
of the request URI.
 </t>
 <t>
transaction resource: a resource with the media type 
&quot;vnd.yang.transaction+xml&quot; or &quot;vnd.yang.transaction+json&quot;
 </t>
 </list>
</t>
</section>
</section>
<section title="Overview">
    <t>
This document defines the YANG-API protocol, a RESTful API for accessing
conceptual datastores
containing data defined with YANG language.
YANG-API provides an application framework and meta-model,
using HTTP operations.
    </t>
    <t>
The YANG-API resources are accessed via a set of 
URIs defined in this document.  
The set of YANG modules supported by the server
will determine the additional data model specific operations 
and top-level data node resources available on the server.
    </t>
    <t>
Not all YANG-API defined resources are mandatory-to-implement.
The server implementor may choose the specific editing model
and persistence model that is supported.  The specific
subset is identified and accessible via 3 capability fields.
Refer to <xref target="capabilities"/> for more details.
    </t>
<section title="Resource URI Map">
    <t>
The URI hierarchy for the YANG-API resources
consists of an entry point
and up to 6 top-level resources and/or fields.
Refer to <xref target="resources"/> for details on each URI.
    </t>
	<figure>
	    <artwork><![CDATA[
  /yang-api
     /capabilities
        /edit-model
        /persist-model
        /transaction-model
     /datastore
        /<top-level-data-nodes> (config=true or false)
     /modules
        /module
     /operations
        /lock-datastore
        /save-datastore
        /unlock-datastore
        /<operations>
     /transaction
        /<transaction-id>
           /commit
           /datastore
              /<top-level-data-nodes> (config=true)
           /discard-changes
           /exclusive-mode
           /update
           /validate
     /version
	    ]]></artwork>
	</figure>
</section>
<section title="YANG-API Message Examples" anchor="main-examples">
    <t>
The examples within this document use the non-normative
example YANG module defined in <xref target="example-module"/>.
    </t>
    <t>
This section shows some typical YANG-API message exchanges.
    </t>
    <t>
In these examples, the server capabilities are as follows:
    </t>
<t>
 <list style="symbols">
 <t>
the edit-model is &quot;direct&quot;
 </t>
 <t>
the persist-model is &quot;manual&quot;
 </t>
 <t>
the transaction-model is &quot;none&quot;
 </t>
 </list>
</t>
<section title="Retrieve the Top-level API Resource">
    <t>
By default, when a resource is retrieved, all of its fields are
returned, but none (if any) of the nested resources are
returned. Also, the default encoding is JSON.  Data resources are
encoded according to the encoding rules in <xref target="I-D.lhotka-yang-json"/>.
    </t>
    <t>
The client starts by retrieving the top-level
API resource, using the entry point URI &quot;/yang&#8209;api&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows.
The &quot;module&quot; lines below are split for display
purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Content-Type: application/vnd.yang.api+json

   {
     "yang-api": {
       "capabilities": {
         "edit-model": "direct",
         "persist-model": "automatic",
         "transaction-model": "none"
       },
       "modules": {
         "module": [
           "urn:ietf:params:xml:ns:yang:ietf-yang-api
              ?module=ietf-yang-api&revision=2012-05-27",
           "example.com?module=example-jukebox
              &revision=2012-05-30"
         ]
       },
       "version": "1.0"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
To request that the response content to be encoded in XML,
the &quot;Accept&quot; header can be used, as in this example request:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.api+xml
	    ]]></artwork>
	</figure>
    <t>
An alternate approach is provided using the &quot;format&quot; query
parameter, as in this example request:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api?format=xml HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server will return the same response either way,
which might be as follows :
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/vnd.yang.api+xml
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   <yang-api>
     <capabilities>
       <edit-model>direct</edit-model>
       <persist-model>automatic</persist-model>
       <transaction-model>none</transaction-model>
     </capabilities>
     <modules> <!-- wrapped for display only -->
       <module>urn:ietf:params:xml:ns:yang:ietf-yang-api
          ?module=ietf-yang-api
          &amp;revision=2012-05-27</module>
       <module>example.com?module=example-jukebox
           &amp;revision=2012-05-30</module>        
     </modules>
     <version>1.0</version>
   </yang-api>
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="get"/> for details on the GET operation.
    </t>
</section>
<section title="Create New Data Resources">
    <t>
To create a new &quot;jukebox&quot; resource, the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/datastore/jukebox HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Location: http://example.com/yang-api/datastore/jukebox
   Last-Modified: Mon, 23 Apr 2012 17:01:00 GMT
   ETag: b3a3e673be2
	    ]]></artwork>
	</figure>
    <t>
To create a new &quot;artist&quot; resource within the &quot;jukebox&quot;
resource, the client might send the following request,
Note that the arbitrary integer &quot;index&quot; is not provided,
since it is an optional key:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/datastore/jukebox/artist HTTP/1.1
   Host: example.com
   Content-Type: application/vnd.yang.data+json

   {
     "artist" : {
       "name" : "The Foo Fighters"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:02:00 GMT
   Server: example-server
   Location: http://example.com/yang-api/datastore/jukebox/artist/1
   Last-Modified: Mon, 23 Apr 2012 17:02:00 GMT
   ETag: b3830f23a4c
	    ]]></artwork>
	</figure>
    <t>
To create a new &quot;album&quot; resource for this artist within the &quot;jukebox&quot;
resource, the client might send the following request,
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/datastore/jukebox/artist/1/album HTTP/1.1
   Host: example.com
   Content-Type: application/vnd.yang.data+json

   {
     "album" : {
       "name" : "Wasting Light",
       "genre" : "example-jukebox:Alternative",
       "year" : 2012
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond
as follows.  Note that the &quot;Location&quot; header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:03:00 GMT
   Server: example-server
   Location: http://example.com/yang-api/datastore/
     jukebox/artist/1/album/Wasting%20Light
   Last-Modified: Mon, 23 Apr 2012 17:03:00 GMT
   ETag: b8389233a4c
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="post"/> for details on the POST operation.
    </t>
</section>
<section title="Replace an Existing Data Resource">
    <t>
Note: replacing a resource is a fairly drastic operation.
The PATCH operation is often more appropriate.
    </t>
    <t>
The album sub-resource is re-added here for example
purposes only.
To replace the &quot;artist&quot; resource contents,
the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   PUT /yang-api/datastore/jukebox/artist/1 HTTP/1.1
   Host: example.com
   If-Match: b3830f23a4c
   Content-Type: application/vnd.yang.data+json

   {
     "artist" : {
       "name" : "Foo Fighters",
       "album" : {
         "name" : "Wasting Light",
         "genre" : "example-jukebox:Alternative",
         "year" : 2012
       }
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is updated, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:04:00 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:04:00 GMT
   ETag: b27480aeda4c
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="put"/> for details on the PUT operation.
    </t>
</section>
<section title="Patch an Existing Data Resource">
    <t>
To replace just the &quot;year&quot; field in the &quot;album&quot; resource,
the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   PATCH /yang-api/datastore/jukebox/artist/1/album/
      Wasting%20Light/year HTTP/1.1
   Host: example.com
   If-Match: b8389233a4c
   Content-Type: application/vnd.yang.data+json

   { "year" : 2011 }
	    ]]></artwork>
	</figure>
    <t>
If the resource is updated, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:49:30 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:49:30 GMT
   ETag: b2788923da4c
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="patch"/> for details on the PATCH operation.
    </t>
</section>
<section title="Delete an Existing Data Resource">
    <t>
To delete a resource such as the &quot;album&quot; resource,
the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   DELETE /yang-api/datastore/jukebox/artist/1/album/
      Wasting%20Light HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
If the resource is deleted, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:49:40 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="delete"/> for details on the DELETE operation.
    </t>
</section>
<section title="Invoke a Data Model Specific Operation">
    <t>
To invoke a global operation, such as the &quot;save&#8209;datastore&quot;
operation resource, the POST operation is used.
A client might send a &quot;save&#8209;datastore&quot; request as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/operations/save-datastore HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:50:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="protocol-ops"/> for details on using the POST operation
with operation resources.
    </t>
</section>
</section>
</section>
</section>
<section title="Framework">
    <t>
The YANG-API protocol defines a framework
that can be used to implement a common API for
configuration management.  This section describes
the components of the YANG-API framework.
    </t>
<section title="Message Model">
    <t>
The YANG-API protocol uses HTTP entities for messages.
A single HTTP message corresponds to a single protocol operation in NETCONF.
A message can perform a single task on a single resource,
such as retrieving a resource or editing a resource.  It cannot be used
to combine multiple tasks.  The client cannot provide
multiple (possibly unrelated) edit operations within a single request,
like the NETCONF &lt;edit&#8209;config&gt; protocol operation.
    </t>
</section>
<section title="Resource Model">
    <t>
The YANG-API protocol operates on a hierarchy of resources,
starting with the top-level API resource itself. Each resource represents
a manageable component within the device.
    </t>
    <t>
A resource can be considered a collection of conceptual data 
and the set of allowed operations on that data.  It can contain
child nodes that are either &quot;fields&quot; or other resources.
The child resource types and operations allowed on them
are data-model specific.
    </t>
    <t>
A resource has its own media type identifier, represented
by the &quot;Content&#8209;Type&quot; header in the HTTP response message.
A resource can contain zero or more fields and zero or
more resources. A resource can be
created and deleted independently of its 
parent resource, as long as the parent resource exist.
    </t>
    <t>
A field is a child node defined within a resource.
A field can contain zero or more fields and zero or
more resources.  A field cannot be
created and deleted independently of its parent resource.
    </t>
    <t>
All YANG-API resources and fields are defined in this document except
datastore contents and RPC operations.  These resource types are
defined with YANG data definition statements and the &quot;rpc&quot; statement.
A default mapping is defined to differentiate sub-resources from fields
within data resources.
    </t>
<section title="YANG-API Resource Types">
    <t>
The YANG-API protocol defines some application specific media types
to identify each of the available resource types.  The following table
summarizes the purpose of each resource.
    </t>
<?rfc compact="yes"?><texttable title="YANG-API Media Types">
<ttcol align='left'> Resource</ttcol>
<ttcol align='left'>Media Type</ttcol>
<c>API</c>
<c>application/vnd.yang.api</c>
<c>Datastore</c>
<c>application/vnd.yang.datastore</c>
<c>Data</c>
<c>application/vnd.yang.data</c>
<c>Operation</c>
<c>application/vnd.yang.operation</c>
<c>Transaction</c>
<c>application/vnd.yang.transaction</c>
</texttable>
<?rfc compact="no"?>    <t>
These resources are described in <xref target="resources"/>.
    </t>
</section>
<section title="Resource Discovery" anchor="resource-discovery">
    <t>
A client SHOULD start by retrieving the top-level
API resource, using the entry point URI &quot;/yang&#8209;api&quot;.
    </t>
    <t>
The YANG-API protocol does not include a
resource discovery mechanism.  Instead, the definitions
within the YANG modules advertised by the server
are used to construct a predictable operation or data
resource identifier. 
    </t>
    <t>
The &quot;depth&quot; query parameter can be used to control how many 
descendant levels should be included when retrieving
sub-resources. This parameter can be used with the GET operation
to discover sub-resources within a particular resource.
    </t>
    <t>
Refer to <xref target="depth-param"/> for more details on the &quot;depth&quot; parameter.
    </t>
</section>
</section>
<section title="Datastore Model">
    <t>
A conceptual &quot;unified datastore&quot; is used to simplify resource
management for the client. The YANG-API datastore is a
combination of the running configuration and any
non-configuration data supported by the device.
By default only configuration data is returned
by a GET operation on the datastore contents.
    </t>
    <t>
The underlying NETCONF datastores can be used
to implement the unified datastore, but the server design
is not limited to the exact datastore procedures defined
in NETCONF.
    </t>
    <t>
Instead of a separate candidate configuration datastore
to use as a globally shared scratchpad to collect edits,
an optional transaction mechanism is provided (see <xref target="transaction-model"/>).
    </t>
    <t>
Instead of a separate startup configuration datastore, a simplified
persistence model is used (see <xref target="persistence-model"/>).
    </t>
<section title="Content Model">
    <t>
The YANG-API protocol operates on a conceptual datastore defined with
the YANG data modeling language.  The server lists each YANG module it
supports in the &quot;/yang&#8209;api/modules/module&quot; field in the
top-level API resource type, using the YANG module capability
URI format defined in RFC 6020.
    </t>
    <t>
The conceptual datastore contents and data-model-specific
operations are identified by the set of
YANG module capability URIs.  All YANG-API content identified 
as either a data resource or an operation resource
is defined with the YANG language.
    </t>
    <t>
The classification of data as configuration or
non-configuration is derived from the YANG &quot;config&quot; statement.
Data retrieval with the GET operation can be filtered
in several ways, including the &quot;config&quot; parameter
to retrieve configuration or non-configuration data.
    </t>
    <t>
The classification of data as a resource or field within
a resource is derived from the rules specified in <xref target="identify-yang"/>.
    </t>
    <t>
Data ordering behavior is derived from the YANG &quot;ordered&#8209;by&quot;
statement.  Editing mechanisms are provided to allow
list or leaf-list resources to be inserted or moved
in the same manner as NETCONF, and defined in YANG.
    </t>
    <t>
The server is not required to maintain system ordered data 
in any particular persistent order. The server SHOULD
maintain the same data ordering for system ordered data
until the next reboot or termination of the server.
    </t>
</section>
<section title="Editing Model">
    <t>
The YANG-API datastore editing model is compatible with
the NETCONF protocol but not exactly the same.
    </t>
    <t>
If the running configuration datastore is written directly,
then each change takes place right away.   This
can have a negative impact on network behavior if
multiple inter-related resources need to be edited at once,
in order to achieve the new desired network state.
    </t>
    <t>
To address this problem, an optional transaction mechanism
is defined (similar to the NETCONF :candidate capability)
to allow multiple edits to be collected and validated,
before being applied all-or-nothing to the running
configuration datastore.
    </t>
    <t>
Private and shared transactions are supported.  If the server uses a
single shared datastore resource, or if multiple clients use the same
private transaction, then it is often useful to know if the data
resources being edited have changed (relative to the resource versions
the client thinks are on the server).
    </t>
    <t>
This can be achieved in YANG-API using the edit collision detection
mechanisms described in <xref target="edit-collision"/>.  If a collision is
detected, then the client can retrieve the resource before proceeding
with the edit.
    </t>
<section title="Edit Operation Discovery">
    <t>
Sometimes a server does not implement every operation
for every resource.  Sometimes data model requirements
cause a node to implement a subset of the edit operations.
For example, a server may not allow modification of a
particular configuration data node after the 
parent resource has been created.
    </t>
    <t>
The OPTIONS operation can be used to identify which
operations are supported by the server for a particular
resource.  For example, if the server will allow a data resource 
node to be created then the POST operation will be
returned in the response.
    </t>
</section>
<section title="Edit Collision Detection" anchor="edit-collision">
    <t>
Two &quot;edit collision detection&quot; mechanisms are provided
in YANG-API, for datastore and data resources.
    </t>
<t>
 <list style="symbols">
 <t>
timestamp: the last change time is maintained and the
&quot;Last&#8209;Modified&quot; and &quot;Date&quot; headers are returned in the
response for a retrieval request. 
The &quot;If&#8209;Unmodified&#8209;Since&quot; header can be used
in edit operation requests to cause the server
to reject the request if the resource has been modified
since the specified timestamp.
 </t>
 <t>
entity tag: a unique opaque string is maintained and
the &quot;ETag&quot; header is returned in the
response for a retrieval request. 
The &quot;If&#8209;Match&quot; header can be used
in edit operation requests to cause the server
to reject the request if the resource entity tag
does not match the specified value.
 </t>
 </list>
</t>
    <t>
Note that the server is only required to maintain these fields
for a datastore resource, not for individual data resources.
    </t>
    <t>
Example:
    </t>
    <t>
In this example, the server just supports the
mandatory datastore last-changed timestamp.
The client has previously retrieved the &quot;Last&#8209;Modified&quot;
header and has some value cached to provide in
the following request to replace a list entry
with key value &quot;11&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
   PATCH /yang-api/datastore/jukebox/artist/1/album/
     Wasting%20Light/year HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.data+json
   If-Unmodified-Since: Mon, 23 Apr 2012 17:01:00 GMT
   Content-Type: application/vnd.yang.data+json   

   { "year" : "2011" }
	    ]]></artwork>
	</figure>
    <t>
In this example the datastore resource has changed
since the time specified in the &quot;If&#8209;Unmodified&#8209;Since&quot;
header.  The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 304 Not Modified
   Date: Mon, 23 Apr 2012 19:01:00 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:45:00 GMT
   ETag: b34aed893a4c
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Locking Model">
    <t>
Datastore locking is needed in order to allow a client to 
make several changes to the running configuration datastore
contents in sequence, without disturbance from other clients.
    </t>
    <t>
The &quot;lock&#8209;datastore&quot; and &quot;unlock&#8209;datastore&quot; operations 
MUST be supported by the server.
These correspond to the global locks defined in NETCONF.
Only the running configuration datastore can be locked and unlocked
in this manner.  If the datastore is locked, then direct edits
and transaction commits by other clients will fail.
    </t>
    <t>
The editing model allows for concurrent transactions to
occur without locking, using the transaction &quot;update&quot; operation.
This is similar to the &quot;discard&#8209;changes&quot; operation,
except that the running configuration datastore is merged
into the current transaction datastore
(instead of replacing the contents).  If the &quot;update&quot; cannot be
done, a conflict error report is generated so the client
can manually resolve the differences.
    </t>
    <t>
A client can request exclusive write access when a
transaction resource is created.  This is comparable to
a global lock on the candidate configuration datastore
if the server &quot;transaction&#8209;model&quot; capability field is set to &quot;shared&quot;.
In this case, the creation of the new transaction resource will fail
if another exclusive transaction already exists.
    </t>
    <t>
There is no partial datastore locking
(i.e., per-resource or per YANG data node) at this time.
Explicit partial locks are difficult to use and
easy to misuse.  Transactions are easier for a client
to use, and allow more server design freedom as well.
    </t>
</section>
<section title="Persistence Model" anchor="persistence-model">
    <t>
A client must be aware of how the server saves configuration
data to non-volatile storage, so the server advertises its
persistence model (either &quot;automatic&quot; or &quot;manual&quot;).
    </t>
    <t>
If manual persistence of the running configuration datastore is
required, then the &quot;persist&quot; operation MUST be supported
by the server and MUST be used by the client to save
the running configuration datastore contents to non-volatile
storage.  
    </t>
    <t>
If automatic persistence of the running configuration datastore is
supported by the server, then the non-volatile storage
of configuration changes is handled automatically by the server,
and the &quot;persist&quot; operation MUST NOT be supported by the server.
    </t>
</section>
<section title="Defaults Model">
    <t>
NETCONF has a rather complex defaults handling model for
leafs.  YANG-API attempts to avoid this complexity by
restricting the operations that can be applied to
a resource and fields within that resource.
    </t>
    <t>
The GET method returns only nodes that exist, which will
be determined by the server.  There is no mechanism for
the client to ask the server for the default values
that would be used for any nodes not present, but some
default value is in use by the server. 
If a leaf definition has a default value, and the leaf has not been
given a value yet, the server SHOULD NOT return any value
for the leaf in the response for a GET operation.
    </t>
</section>
</section>
<section title="Transaction Model" anchor="transaction-model">
    <t>
The &quot;/yang&#8209;api/transaction&quot; resource will be present if the server
supports transactions. If so, the server MUST support at least one
transaction at a time and MAY support multiple concurrent
transactions, either by one client or multiple clients.
    </t>
    <t>
The &quot;/yang&#8209;api/capabilities/transaction&#8209;model&quot; field in the top-level
API resource identifies which type of transactions the server
supports, either &quot;none&quot;, &quot;shared&quot;, or &quot;private&quot;.  If shared, then all
clients are sharing the same &quot;/yang&#8209;api/transaction/&lt;id&gt;/datastore&quot;
resource.  If &quot;private&quot; then each instance of a
&quot;/yang&#8209;api/transaction/&lt;id&gt;/datastore&quot; resource is independent of each
another.
    </t>
    <t>
There are a small number of operations supported for a transaction resource.
    </t>
<t>
 <list style="symbols">
 <t>
commit: attempt to commit the transaction.
 </t>
 <t>
discard-changes: replace the contents of the transaction datastore to
the contents of the running configuration datastore.
 </t>
 <t>
update:  merge the contents of the
running configuration datastore into the transaction datastore.
 </t>
 <t>
validate: Run commit validation tests against
the running configuration datastore contents, according to
section 8.3.3 of <xref target="RFC6020"/>.
 </t>
 </list>
</t>
    <t>
Refer to <xref target="transaction-ops"/> for more details on these operations.
    </t>
</section>
<section title="Extensibility Model">
    <t>
The YANG-API protocol is designed to be extensible for
datastore content and data-model specific RPC operations.
New RPC operations can be added without changing
the entry point if they are optional and do not alter
any existing operations.
    </t>
    <t>
Separate namespaces for each YANG module are used.
Content encoded in XML will indicate the module
using the &quot;namespace&quot; URI value in the YANG module.
Content encoded in JSON will indicate the module
using the module name specified in the YANG module.
JSON encoding rules for module namespaces are specified 
in <xref target="I-D.lhotka-yang-json"/>.
    </t>
</section>
<section title="Versioning Model">
    <t>
The version of a resource instance is identified with an entity tag,
as defined by HTTP.
The version identifiers in this section apply to the 
version of the schema definition of a resource.
There are two types of schema versioning information used
in the YANG-API protocol:
    </t>
<t>
 <list style="symbols">
 <t>
the YANG-API protocol version
 </t>
 <t>
data and operation resource definition versions
 </t>
 </list>
</t>
    <t>
The protocol version is identified by the string used for the 
well-known URI entry point &quot;/yang&#8209;api&quot;.
This would be changed (e.g., &quot;/yang&#8209;api2&quot;) 
if non-backward compatible changes are ever needed.  
Minor version changes that do not break
backward-compatibility will not cause the entry point to change.
    </t>
    <t>
The API &quot;yang&#8209;api/version&quot; field can be used by the client to identify
the exact version of the YANG-API protocol implemented by the server.
This value will include the complete YANG-API protocol version.
The &quot;/yang&#8209;api&quot; entry point will only change (e.g., &quot;/yang&#8209;api2&quot;)
if non-backward compatible changes are made to the protocol.
The &quot;/yang&#8209;api/version&quot; field MUST be updated every time
the protocol specification is republished.
    </t>
    <t>
The resource definition version for a data or operation 
resource is a date string,
which is the revision date of the YANG module that defines the resource.
The resource version for all other resource types is a numeric string,
defined by the &quot;/yang&#8209;api/version&quot; field.
    </t>
</section>
<section title="Retrieval Filtering Model">
    <t>
There are four types of filtering for retrieval of data resources
in the YANG-API protocol.
    </t>
<t>
 <list style="symbols">
 <t>
conditional all-or-nothing: use some conditional test
mechanism in the request headers and retrieve either a
complete &quot;200 OK&quot; response if the condition is met,
or a &quot;304 Not Modified&quot; Status-Line if the condition is not met.
 </t>
 <t>
data classification: request configuration or non-configuration data.
 </t>
 <t>
subset: request a subset of all possible instances of a
list or leaf-list data resource.
 </t>
 <t>
filter: request a subset of all possible descendant nodes
within the target resource.  The &quot;select&quot; query parameter can be used
for this purpose.
 </t>
 </list>
</t>
    <t>
Refer to <xref target="data-retrieval"/> for details on data retrieval filtering.
    </t>
</section>
<section title="Access Control Model">
    <t>
The YANG-API protocol provides no granular access control for any
content except for operation and data resources.  The NETCONF
Access Control Model (NACM) is defined in <xref target="RFC6536"/>.
There is a specific mapping between YANG-API operations
and NETCONF edit operations, defined in <xref target="table-crud-operations"/>.
The resource path also needs to be converted internally
by the server to the corresponding YANG instance-identifier.
Using this information, the server can apply the NACM
access control rules to YANG-API messages.
    </t>
    <t>
The server MUST NOT allow any operation to any resources that
the client is not authorized to access.  
    </t>
</section>
</section>
<section title="Operations" anchor="operations">
    <t>
The YANG-API protocol uses HTTP methods to identify
the CRUD operation requested for a particular resource
or field within a resource.  The following table
shows how the YANG-API operations relate to NETCONF 
protocol operations:
    </t>
<?rfc compact="yes"?><texttable anchor="table-crud-operations" title="CRUD Operations in YANG-API">
<ttcol align='left'> YANG-API</ttcol>
<ttcol align='left'>NETCONF</ttcol>
<c>OPTIONS</c>
<c>none</c>
<c>HEAD</c>
<c>none</c>
<c>GET</c>
<c>&lt;get-config&gt;, &lt;get&gt;</c>
<c>POST</c>
<c>&lt;edit-config&gt; (operation=&quot;create&quot;)</c>
<c>PUT</c>
<c>&lt;edit-config&gt; (operation=&quot;replace&quot;)</c>
<c>PATCH</c>
<c>&lt;edit-config&gt; (operation=&quot;merge&quot;)</c>
<c>DELETE</c>
<c>&lt;edit-config&gt; (operation=&quot;delete&quot;)</c>
</texttable>
<?rfc compact="no"?>    <t>
The NETCONF &quot;remove&quot; operation attribute is not supported
by the HTTP DELETE method. The resource must exist or
the DELETE operation will fail.
    </t>
    <t>
This section defines the YANG-API protocol usage for
each HTTP method.
    </t>
<section title="OPTIONS" anchor="options">
    <t>
The OPTIONS method is sent by the client to
discover which methods are supported by the server
for a specific resource, or field within a resource.
It is supported for all media types.
Note that implementation
of this operation is part of HTTP, and this section does
not introduce any additional requirements.
    </t>
    <t>
The request MUST contain a request URI
that contains at least the entry point component.
    </t>
    <t>
The server will return a &quot;Status&#8209;Line&quot; header containing &quot;204 No Content&quot;.
and include the &quot;Allow&quot; header in the response.
This header will be filled in, based on the target resource media type.
Other headers MAY also be included in the response.
    </t>
    <t>
Example 1:
    </t>
    <t>
A client might request the methods supported for a data
resource called &quot;library&quot;
    </t>
	<figure>
	    <artwork><![CDATA[
   OPTIONS /yang-api/datastore/jukebox/library HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond (for a config=true list):
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Allow: OPTIONS,HEAD,GET,POST,PUT,PATCH,DELETE
	    ]]></artwork>
	</figure>
    <t>
Example 2:
    </t>
    <t>
A client might request the methods supported for a 
non-configuration leaf within a data resource:
    </t>
	<figure>
	    <artwork><![CDATA[
   OPTIONS /yang-api/datastore/jukebox/library/
       song-count HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:02:00 GMT
   Server: example-server
   Allow: OPTIONS,HEAD,GET
	    ]]></artwork>
	</figure>
    <t>
Example 3:
    </t>
    <t>
A client might request the methods supported for an
operation resource called &quot;play&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
   OPTIONS /yang-api/operations/play HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:02:00 GMT
   Server: example-server
   Allow: POST
	    ]]></artwork>
	</figure>
</section>
<section title="HEAD" anchor="head">
    <t>
The HEAD operation is sent by the client to
retrieve just the headers that would be returned
for the comparable GET operation, without the response body.
The HTTP HEAD method is used for this operation.
It is supported for all resource types, except operation resources.
    </t>
    <t>
The request MUST contain a request URI
that contains at least the entry point component.
    </t>
    <t>
The same query parameters supported by the GET operation
are supported by the HEAD operation.  For example,
the &quot;select&quot; query parameter can be used to
specify a field within the target resource.
    </t>
    <t>
The access control behavior is enforced
as if the method was GET instead of HEAD.
The server MUST respond the same as if the method
was GET instead of HEAD, except that no
response body is included.
    </t>
    <t>
Example:
    </t>
    <t>
The client might request the response headers for the default
(JSON) representation of the &quot;library&quot; resource:
    </t>
	<figure>
	    <artwork><![CDATA[
   HEAD /yang-api/datastore/jukebox/library HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:02:40 GMT
   Server: example-server
   Content-Type: application/vnd.yang.data+json
   Cache-Control: no-cache
   Pragma: no-cache
   ETag: a74eefc993a2b
   Last-Modified: Mon, 23 Apr 2012 11:02:14 GMT
	    ]]></artwork>
	</figure>
</section>
<section title="GET" anchor="get">
    <t>
The GET operation is sent by the client to
retrieve data and meta-data for a resource or
field within a resource.
The HTTP GET method is used for this operation.
It is supported for all resource types, except operation resources.
The request MUST contain a request URI
that contains at least the entry point component.
    </t>
    <t>
The following query parameters are supported
by the GET operation:
    </t>
<?rfc compact="yes"?><texttable title="GET Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Section</ttcol>
<ttcol align='left'>Description</ttcol>
<c>config</c>
<c><xref format="counter" target="config-param"/></c>
<c>Request either configuration or non-configuration data</c>
<c>depth</c>
<c><xref format="counter" target="depth-param"/></c>
<c>Control the depth of a retrieval request</c>
<c>format</c>
<c><xref format="counter" target="format-param"/></c>
<c>Request either JSON or XML content in the response</c>
<c>select</c>
<c><xref format="counter" target="select-param"/></c>
<c>Specify a field within the target resource</c>
</texttable>
<?rfc compact="no"?>    <t>
The server MUST NOT return any data resources or fields within
any data resources for which the user does not have read privileges. 
    </t>
    <t>
If the user is not authorized to read any portion of
the target resource, an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  
    </t>
    <t>
If the user is authorized to read some but not all of
the target resource, the unauthorized content is omitted
from the response message body, and the authorized content
is returned to the client.
    </t>
    <t>
Example:
    </t>
    <t>
The client might request the response headers for a
JSON representation of the &quot;library&quot; resource:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api/datastore/jukebox/library/artist/
     1/album HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:02:40 GMT
   Server: example-server
   Content-Type: application/vnd.yang.data+json
   Cache-Control: no-cache
   Pragma: no-cache
   ETag: a74eefc993a2b
   Last-Modified: Mon, 23 Apr 2012 11:02:14 GMT

   {
     "album" : {
       "name" : "Wasting Light",
       "genre" : "example-jukebox:Alternative",
       "year" : 2011
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="POST" anchor="post">
    <t>
The POST operation is sent by the client for various
reasons.  The HTTP POST method is used for this purpose.
The request MUST contain a request URI
that contains a target resource that
identifies one of the following resource types:
    </t>
<?rfc compact="yes"?><texttable title="Resource Types that Support POST">
<ttcol align='left'> Type</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Data</c>
<c>Create a configuration data resource</c>
<c>Operation</c>
<c>Invoke RPC operation</c>
<c>Transaction</c>
<c>Create a new transaction</c>
</texttable>
<?rfc compact="no"?>    <t>
The following query parameters are supported
by the POST operation:
    </t>
<?rfc compact="yes"?><texttable title="POST Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Section</ttcol>
<ttcol align='left'>Description</ttcol>
<c>insert</c>
<c><xref format="counter" target="insert-param"/></c>
<c>Specify where to insert a resource</c>
<c>point</c>
<c><xref format="counter" target="point-param"/></c>
<c>Specify the insert point for a resource</c>
</texttable>
<?rfc compact="no"?>    <t>
If the POST operation succeeds, a &quot;200 OK&quot; Status-Line
is returned if there is no response message body, and
a &quot;204 No Content&quot; Status-Line is returned if there is
a response message body.
    </t>
    <t>
If the user is not authorized to invoke the target (operation) resource,
or create the target resource,
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="PUT" anchor="put">
    <t>
The PUT operation is sent by the client to replace
the target resource.
    </t>
    <t>
The HTTP PUT method is used for this purpose.
The request MUST contain a request URI
that contains a target resource that
identifies the data resource to replace.
    </t>
    <t>
The following query parameters are supported
by the PUT operation:
    </t>
<?rfc compact="yes"?><texttable title="PUT Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Section</ttcol>
<ttcol align='left'>Description</ttcol>
<c>insert</c>
<c><xref format="counter" target="insert-param"/></c>
<c>Specify where to move a resource</c>
<c>point</c>
<c><xref format="counter" target="point-param"/></c>
<c>Specify the move point for a resource</c>
</texttable>
<?rfc compact="no"?>    <t>
If the PUT operation succeeds, a &quot;200 OK&quot; Status-Line
is returned, and there is no response message body.
    </t>
    <t>
If the user is not authorized to replace the target resource
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="PATCH" anchor="patch">
    <t>
The PATCH operation uses the HTTP PATCH method defined
in <xref target="RFC5789"/> to provide a &quot;merge&quot; editing mode for
data resources.  Instead of replacing all or part of the
target resource, the supplied values are merged into the
target resource.
    </t>
    <t>
If the PATCH operation succeeds, a &quot;200 OK&quot; Status-Line
is returned, and there is no response message body.
    </t>
    <t>
If the user is not authorized to alter the target resource
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="DELETE" anchor="delete">
    <t>
The DELETE operation uses the HTTP DELETE method
to delete the target resource.
    </t>
    <t>
If the DELETE operation succeeds, a &quot;200 OK&quot; Status-Line
is returned, and there is no response message body.
    </t>
    <t>
If the user is not authorized to delete the target resource then
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="Query Parameters" anchor="query-parameters">
    <t>
Each YANG-API operation allows zero or more query
parameters to be present in the request URI.
Refer to <xref target="operations"/>
for details on the query parameters used
in the definition of each operation.
    </t>
    <t>
Query parameters can be given in any order.
Each parameter can appear zero or one time.
A default value may apply if the parameter is missing.
    </t>
    <t>
This section defines all the YANG-API query parameters.
    </t>
<section title="&quot;config&quot; Parameter" anchor="config-param">
    <t>
The &quot;config&quot; parameter is used to specify whether 
configuration or non-configuration data is requested.
    </t>
    <t>
This parameter is only supported for the GET and HEAD methods.
It is also only supported if the target resource is a data resource.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: config= true | false
     default: true
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
This example request by the client
would retrieve only the non-configuration data nodes
that exist within the second-level &quot;library&quot; resource.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api/datastore/jukebox/library?config=false HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.data+xml
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/vnd.yang.data+json

   {
     "library" : {
        "artist-count" : 42,
        "album-count" : 59,
        "song-count" : 374
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;depth&quot; Parameter" anchor="depth-param">
    <t>
The &quot;depth&quot; parameter is used to specify the number
of nest levels returned in a response for a GET operation.
A nest-level consists of the target resource and any
child nodes which are optional data nodes (anyxml, leaf, or 
leaf-list).  A non-presence container
is transparent when determining the nest level.  
A child node (which is not a non-presence container)
within a non-presence container is used to determine the nest-level.
    </t>
    <t>
The start level is determined by the target resource
for the operation.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: depth=<range: 1..max> | unbounded
     default: 1
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
This example operation would retrieve 2 levels of configuration data nodes
that exist within the top-level &quot;jukebox&quot; resource.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api/datastore/jukebox?depth=2 HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.data+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:11:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/vnd.yang.data+json

   {
     "jukebox" : {
       "library" : {
         "artist" : {
           "index" : 1,
           "name" : "Foo Fighters"
         }
       },
       "player" : {
         "gap" : 0.5
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;format&quot; Parameter" anchor="format-param">
    <t>
The &quot;format&quot; parameter is used to specify the format
of any content returned in the response.  Note that
the &quot;Accept&quot; header MAY be used instead of this
parameter to identify the format desired in the response.
For example:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api/datastore/routing HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.data+xml
	    ]]></artwork>
	</figure>
    <t>
This example request would retrieve only the configuration data nodes
that exist within the top-level &quot;routing&quot; resource, and retrieve
them in XML encoding instead of JSON encoding.
    </t>
    <t>
The &quot;format&quot; parameter is only supported for the GET and HEAD methods.
It is supported for all YANG-API media types.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: format= xml | json
     default: json
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api/datastore/routing?format=xml HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
This example URI would retrieve only the configuration data nodes
that exist within the top-level &quot;routing&quot; resource, and retrieve
them in XML encoding instead of JSON encoding.
    </t>
</section>
<section title="&quot;insert&quot; Parameter" anchor="insert-param">
    <t>
The &quot;insert&quot; parameter is used to specify how a
resource should be inserted (or moved) within
the user-ordered list or leaf-list data resource.
    </t>
    <t>
This parameter is only supported for the POST and PUT methods.
It is also only supported if the target resource is
a data resource, and that data represents
a YANG list or leaf-list that is ordered by the user, not the system.
    </t>
    <t>
If the values &quot;before&quot; or &quot;after&quot; are used, then a &quot;point&quot;
parameter for the insertion parameter MUST also be present.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: insert= first | last | before | after
     default: last
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   POST /yang-api/datastore/jukebox/library/artist/1/album
      /Wasting%20Light/song?insert=first HTTP/1.1
   Host: example.com
   Content-Type: application/vnd.yang.data+json

   {
     "song" : {
        "name" : "Bridge Burning",
        "location" : "/media/bridge_burning.mp3",
        "format" : "MP3",
        "length" : 286
     }
   }

 Response from server:  201 status

   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT

   Location: http://example.com/yang-api/datastore/jukebox
      /library/artist/1/album?Wasting%20Light/song/1
   ETag: eeeada438af
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;point&quot; Parameter" anchor="point-param">
    <t>
The &quot;point&quot; parameter is used to specify the insertion point
for a data resource that is being created or moved within
a user ordered list or leaf-list.  It is ignored unless the &quot;insert&quot;
query parameter is also present, and has the value &quot;before&quot; or &quot;after&quot;.
    </t>
    <t>
This parameter contains the instance identifier of the
resource, or field within a resource, to be used as the
insertion point for a POST or PUT operation.  It is
encoded according to the rules defined in <xref target="uri-encoding"/>.
There is no default for this parameter.
    </t>
	<figure>
	    <artwork><![CDATA[
   syntax: point= <instance-identifier of insertion point node>
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
In this example, the client is moving an existing &quot;song&quot; resource
within an &quot;album&quot; resource after another song.
The request URI is split for display purposes only.
    </t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   PUT /yang-api/datastore/jukebox/library/artist/1/album/
     Wasting%20Light/song/2?insert=after
     &point=/yang-api/datastore/jukebox/library/artist/1/
     album/Wasting%20Light/song/4   HTTP/1.1
   Host: example.com

 Response from server:

   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT
   ETag: abcada438af
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;select&quot; Parameter" anchor="select-param">
    <t>
The &quot;select&quot; query parameter is used to specify an
expression which can represent a subset of all data nodes
within the target resource. It contains a relative
path expression, using the target resource as the context node.
    </t>
    <t>
It is supported for all resource types except operation resources.
The contents are encoded according to the &quot;api&#8209;select&quot;
rule defined in <xref target="uri-encoding"/>.  This parameter is only allowed
for GET and HEAD operations.
    </t>
    <t>
[FIXME: the syntax of the select string is still TBD;
XPath, schema-identifier, regular expressions, something else]
    </t>
    <t>
Refer to <xref target="main-examples"/> for example request messages
using the &quot;select&quot; parameter.
    </t>
</section>
</section>
<section title="RPC Operations" anchor="protocol-ops">
    <t>
The YANG-API also allows RPC operations to be invoked
using the POST method.  The media type 
&quot;vnd.yang.operation+xml&quot; or &quot;vnd.yang.operation+json&quot;
MUST be used in the &quot;Content&#8209;Type&quot; field in the message header.
    </t>
    <t>
The following datastore specific operations are defined:
    </t>
<?rfc compact="yes"?><texttable title="YANG-API Datastore Operations">
<ttcol align='left'> Operation</ttcol>
<ttcol align='left'>Description</ttcol>
<c>lock-datastore</c>
<c>Lock the /yang-api/datastore resource for writing</c>
<c>save-datastore</c>
<c>Save the /yang-api/datastore resource to NV-storage</c>
<c>unlock-datastore</c>
<c>Unlock the /yang-api/datastore resource</c>
</texttable>
<?rfc compact="no"?>    <t>
Refer to <xref target="datastore-resource"/> for details on these operations.
    </t>
    <t>
The following transaction specific operations are defined:
    </t>
<?rfc compact="yes"?><texttable title="YANG-API Transaction Operations">
<ttcol align='left'> Operation</ttcol>
<ttcol align='left'>Description</ttcol>
<c>commit</c>
<c>Commit the transaction to the running config</c>
<c>discard-changes</c>
<c>replace transaction data with current running config</c>
<c>update</c>
<c>merge current running config into transaction data</c>
<c>validate</c>
<c>validate transaction datastore</c>
</texttable>
<?rfc compact="no"?>    <t>
Refer to <xref target="transactions"/> for details on these operations.
    </t>
<section title="Data Model Specific Operations">
    <t>
Data model specific operations are supported.
The syntax and semantics of these operations
exactly correspond to the YANG rpc statement definition
for the operation.
    </t>
    <t>
Any input for a RPC operation is encoded in an element
called &quot;input&quot;, which corresponds to the &lt;input&gt; element
in a NETCONF message.  The child nodes of the &quot;input&quot;
element are encoded according to the data definition statements
in the input section of the rpc statement.
    </t>
    <t>
Any output for a RPC operation is encoded in an element
called &quot;output&quot;, which corresponds to the &lt;rpc&#8209;reply&gt; element
in a NETCONF message.  The child nodes of the &quot;output&quot;
element are encoded according to the data definition statements
in the output section of the rpc statement.
    </t>
</section>
</section>
</section>
<section title="Messages" anchor="messages">
    <t>
This section describes the messages that are used in the YANG-API
protocol.
    </t>
<section title="Request URI Structure">
    <t>
Resources are represented with URIs following the structure
for generic URIs in <xref target="RFC3986"/>.
    </t>
    <t>
A YANG-API operation is derived from the HTTP method
and the request URI, using the following conceptual fields:
    </t>
	<figure>
	    <artwork><![CDATA[
     <OP> /yang-api/<path>?<query>#<fragment>
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
      ^      ^       ^        ^         ^   
      |      |       |        |         |   
    method entry  resource  query    fragment

      M       M        O        O         I


    M=mandatory, O=optional, I=ignored
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
    <text> replaced by client with real values
	    ]]></artwork>
	</figure>
<t>
 <list style="symbols">
 <t>
method: the HTTP method identifying the YANG-API operation
requested by the client, to act upon the target resource
specified in the request URI.  YANG-API operation details are
described in <xref target="operations"/>.
 </t>
 <t>
entry: the well-known YANG-API entry point (&quot;/yang&#8209;api&quot;).
 </t>
 <t>
resource: the path expression identifying the resource
that is being accessed by the operation.
If this field is not present, then the target resource
is the API itself, represented by the media type &quot;vnd.yang.api&quot;.
 </t>
 <t>
query: the set of parameters associated with the YANG-API
message. These have the familiar form of &quot;name=value&quot; pairs.
There is a specific set of parameters defined,
although the server MAY choose to support additional
parameters not defined in this document.
 </t>
 <t>
fragment: This field is not used by the YANG-API protocol.
 </t>
 </list>
</t>
    <t>
The client SHOULD NOT assume the final structure of
a URI path for a resource.  Instead, existing resources can
be discovered with the GET operation.  When new resources
are created by the client, a &quot;Location&quot; header
is returned, which identifies the path of the newly created resource.
The client MUST use this exact path identifier to access
the resource once it has been created.
    </t>
    <t>
The &quot;target&quot; of an operation is a resource.
The &quot;path&quot; field in the request URI represents
the target resource for the operation.  
    </t>
</section>
<section title="Message Headers">
    <t>
There are several HTTP header lines utilized in YANG-API messages.
Messages are not limited to the HTTP headers listed in this section.
    </t>
    <t>
HTTP defines which header lines are required for particular circumstances.
Refer to each operation definition section in <xref target="operations"/>
for examples on how particular headers are used.
    </t>
    <t>
There are some request headers that are used within YANG-API,
usually applied to data resources.
The following tables summarize the headers most relevant
in YANG-API message requests:
    </t>
<?rfc compact="yes"?><texttable title="YANG-API Request Headers">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Accept</c>
<c>Response Content-Types that are acceptable</c>
<c>Content-Type</c>
<c>The media type of the request body</c>
<c>Host</c>
<c>The host address of the server</c>
<c>If-Match</c>
<c>Only perform the action if the entity matches ETag</c>
<c>If-Modified-Since</c>
<c>Only perform the action if modified since time</c>
<c>If-Range</c>
<c>Only retrieve range if resource unchanged</c>
<c>If-Unmodified-Since</c>
<c>Only perform the action if un-modified since time</c>
<c>Range</c>
<c>Specify a range of data resource entries</c>
</texttable>
<?rfc compact="no"?>    <t>
The following tables summarize the headers most relevant
in YANG-API message responses:
    </t>
<?rfc compact="yes"?><texttable title="YANG-API Response Headers">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Allow</c>
<c>Valid actions when 405 error returned</c>
<c>Content-Type</c>
<c>The media type of the response body</c>
<c>Date</c>
<c>The date and time the message was sent</c>
<c>ETag</c>
<c>An identifier for a specific version of a resource</c>
<c>Last-Modified</c>
<c>The last modified date and time of a resource</c>
<c>Location</c>
<c>The resource identifier for a newly created resource</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Message Encoding">
    <t>
YANG-API messages are encoded in HTTP according to RFC 2616.
The &quot;utf&#8209;8&quot; character set is used for all messages.
YANG-API message content is sent in the HTTP message body.
    </t>
    <t>
Content is encoded in either JSON or XML format.
    </t>
    <t>
XML encoding rules for data nodes are defined in <xref target="RFC6020"/>.
The same encoding rules are used for all XML content.
XML attributes are not used and will be ignored if present
in an XML-encoded message.
    </t>
    <t>
JSON encoding rules are defined in <xref target="I-D.lhotka-yang-json"/>.
Special encoding rules are needed to handle multiple
module namespaces and provide consistent data type processing.
    </t>
    <t>
Request input content encoding format is identified with the Content-Type
header.  This field MUST be present if message input is sent
by the client.
    </t>
    <t>
Response output content encoding format is identified with the Accept
header, the &quot;format&quot; query parameter, or if
neither is specified, the request input encoding format is used.
If there was no request input, then the default output encoding is JSON.
File extensions encoded in the request are not used to identify
format encoding.
    </t>
</section>
<section title="Return Status">
    <t>
Each message represents some sort of resource access.
An HTTP &quot;Status&#8209;Line&quot; header line is returned for each request.
If a 4xx or 5xx range status code is returned in the Status-Line,
then the error information will be returned in the response,
according to the format defined in <xref target="errors"/>.
    </t>
</section>
<section title="Message Caching">
    <t>
Since the datastore contents change at unpredictable times,
responses from a YANG-API server generally SHOULD NOT be cached.
    </t>
    <t>
The server SHOULD include a &quot;Cache&#8209;Control&quot; header in every response
that specifies whether the response should be cached.
A &quot;Pragma&quot; header specifying &quot;no&#8209;cache&quot; MAY also be sent
in case the &quot;Cache&#8209;Control&quot; header is not supported.
    </t>
    <t>
Instead of using HTTP caching, the client SHOULD track the &quot;ETag&quot;
and/or &quot;Last&#8209;Modified&quot; headers returned by the server for the
datastore resource (or data resource if the server supports it).
    </t>
    <t>
A retrieval request for a resource can include headers 
such as &quot;If&#8209;None&#8209;Match&quot; or &quot;If&#8209;Modified&#8209;Since&quot; which
will cause the server to return a &quot;304 Not Modified&quot; Status-Line
if the resource has not changed.
    </t>
    <t>
The client MAY use the HEAD operation to retrieve just
the message headers, which SHOULD include the &quot;ETag&quot; 
and &quot;Last&#8209;Modified&quot; headers, if this meta-data is maintained
for the target resource.
    </t>
</section>
</section>
<section title="Resources" anchor="resources">
    <t>
The resources used in the YANG-API protocol are identified
by the &quot;path&quot; component in the request URI.  Each operation
is performed on a target resource.
    </t>
<section title="API Resource (/yang-api) ">
    <t>
The API resource contains the state and access points for
the YANG-API features.
    </t>
    <t>
It is the top-level resource and has the media type 
&quot;application/vnd.yang.api+xml&quot; or &quot;application/vnd.yang.api+json&quot;.
It is accessible through the well-known URI &quot;/yang&#8209;api&quot;.
    </t>
    <t>
This resource has the following fields:
    </t>
<?rfc compact="yes"?><texttable title="YANG-API Resource Fields">
<ttcol align='left'> Field Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>capabilities</c>
<c>Server capabilities</c>
<c>datastore</c>
<c>Link to &quot;datastore&quot; resource</c>
<c>operations</c>
<c>Global operations</c>
<c>modules</c>
<c>YANG modules</c>
<c>transaction</c>
<c>Link to &quot;transaction&quot; resource</c>
</texttable>
<?rfc compact="no"?><section title="/yang-api/capabilities" anchor="capabilities">
    <t>
This mandatory field represents the YANG-API server
capabilities.  The child nodes are read-only fields that MUST NOT change
while the server is running, but MAY change after a reboot.
    </t>
    <t>
Example:
    </t>
    <t>
To retrieve just the YANG-API capabilities, the
client might send the following request:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api?select=capabilities HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:10:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/vnd.yang.api+json

   {
     "yang-api": {
       "capabilities": {
         "edit-model": "transaction",
         "persist-model": "manual",
         "transaction-model": "private"
       }
     }
   }
	    ]]></artwork>
	</figure>
<section title="/yang-api/capabilities/edit-model">
    <t>
The &quot;edit&#8209;model&quot; capability field is used to identify the editing
model used by the server.  There are 4 supported models:
    </t>
<t>
 <list style="symbols">
 <t>
none:  A server within a constrained device MAY choose
to provide a read-only implementation, in which case
no editing model is supported.  
 </t>
 <t>
direct: A device MAY allow the running configuration
datastore to only be modified directly, and therefore will not 
support transactions.
 </t>
 <t>
transaction: A device SHOULD support the transaction mechanism
defined in this document.  Datastore edits are collected
in the transaction datastore and applied to the running
configuration datastore with the &quot;commit&quot; operation.
 </t>
 <t>
both: A device MAY support both the direct and transaction
editing models, by allowing direct editing operations on the
datastore and supporting the transaction mechanism.
 </t>
 </list>
</t>
    <t>
The server SHOULD support 1 of the 2 datastore editing models,
and MAY support both datastore editing models.
If both are supported, then the client can decide
which editing model it prefers.
    </t>
    <t>
This field is encoded with the rules for a &quot;bits&quot; data type,
using the following leaf definition:
    </t>
	<figure>
	    <artwork><![CDATA[
   leaf edit-model {
     config false;
     type bits {
       bit direct {
         description 
           "Direct writing to the datastore resource is allowed.";
       }
       bit transaction {
         description 
           "Writing to the datastore via transactions is allowed.";
       }
     }
   }
	    ]]></artwork>
	</figure>
    <t>
There is no default. The server MUST set zero, one, or both
of these bits in the &quot;edit&#8209;model&quot; capability field.
    </t>
</section>
<section title="/yang-api/capabilities/persist-model">
    <t>
The &quot;persist&#8209;model&quot; capability field is used to identify the persistence
model used by the server.  There are two supported models:
    </t>
<t>
 <list style="symbols">
 <t>
automatic: The server will automatically save the running configuration
datastore contents to non-volatile storage.
 </t>
 <t>
manual: The client must manually save the running configuration
datastore contents to non-volatile storage.
 </t>
 </list>
</t>
    <t>
This field is encoded with the rules for an &quot;enumeration&quot; data type,
using the following leaf definition:
    </t>
	<figure>
	    <artwork><![CDATA[
   leaf persist-model {
     config false;
     type enumeration {
       enum automatic {
         description 
           "The server will automatically save the 
            running configuration";
       }
       enum manual {
         description 
           "The client must manually save the running
            configuration";
       }
     }
   }
	    ]]></artwork>
	</figure>
    <t>
There is no default. The server MUST set one enumeration
value in the &quot;persist&#8209;model&quot; capability field.
    </t>
</section>
<section title="/yang-api/capabilities/transaction-model">
    <t>
The &quot;transaction&#8209;model&quot; capability field is used to identify the
transaction model used by the server.  There are 3 supported models:
    </t>
<t>
 <list style="symbols">
 <t>
none: The server does not support transactions.
 </t>
 <t>
shared: All clients are sharing the same 
conceptual transaction datastore (similar to NETCONF :candidate
capability).
 </t>
 <t>
private: Each transaction datastore resource
is independent of one another.
 </t>
 </list>
</t>
    <t>
This field is encoded with the rules for an &quot;enumeration&quot; data type,
using the following leaf definition:
    </t>
	<figure>
	    <artwork><![CDATA[
   leaf transaction-model {
     config false;
     type enumeration {
       enum none {
         description 
           "The server does not support transactions.";
       }
       enum shared {
         description 
           "The server supports a shared transaction datastore 
            resource.";
       }
       enum private {
         description 
           "The server supports a private transaction datastore 
            resource.";
       }
     }
   }
	    ]]></artwork>
	</figure>
    <t>
There is no default. The server MUST set one enumeration
value in the &quot;transaction&#8209;model&quot; capability field.
    </t>
</section>
</section>
<section title="/yang-api/datastore">
    <t>
This mandatory resource represents the running configuration
datastore and any non-configuration data available.
It may be retrieved and edited directly or indirectly (via transactions).
It cannot be created or deleted by the client.
This resource type is defined in <xref target="datastore-resource"/>.
    </t>
</section>
<section title="/yang-api/operations ">
    <t>
This optional field provides access to the global datastore 
and data-model specific RPC operations supported by the server.
The datastore operation resources will be available depending 
on the server capabilities.
If the server does not support any global operations,
then this field SHOULD NOT not be present.
    </t>
    <t>
There are 3 global operations defined by YANG-API.
    </t>
<t>
 <list style="symbols">
 <t>
lock-datastore
 </t>
 <t>
save-datastore
 </t>
 <t>
unlock-datastore
 </t>
 </list>
</t>
    <t>
Any data-model specific global operations derived from
YANG modules supported by the server will also be
available through child node resources within the &quot;operations&quot; field.
The YANG-API defined global operations are described in this section.
    </t>
<section title="/yang-api/operations/lock-datastore">
    <t>
The &quot;lock&#8209;datastore&quot; operation resource is used to lock
the datastore resource represented by the URI &quot;/yang&#8209;api/datastore&quot;.
It behaves exactly the same as the NETCONF &lt;lock&gt; operation
on the running configuration datastore.
    </t>
    <t>
If the operation succeeds, a &quot;204 No Content&quot; value in the 
&quot;Status&#8209;Line&quot; is sent in the response.  If the operation fails, the
appropriate error code is set according to the rules
in <xref target="error-reporting"/>, and the error report
is sent in the response, according to the format defined in <xref target="errors"/>.
    </t>
    <t>
The &quot;lock&#8209;datastore&quot; operation does not take any parameters.
The YANG &quot;rpc&quot; statement definition for this operation
is defined in <xref target="module"/>.
    </t>
    <t>
Example:
    </t>
    <t>
The client might request a lock on the running configuration
datastore as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/operations/lock-datastore HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
If the operation succeeds the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:03:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
    <t>
If the operation fails the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:03:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
</section>
<section title="/yang-api/operations/save-datastore">
    <t>
The &quot;save&#8209;datastore&quot; operation resource is used to save
the datastore resource represented by the URI &quot;/yang&#8209;api/datastore&quot;
to non-volatile storage.
It behaves exactly the same as the NETCONF &lt;copy&#8209;config&gt; operation
when used to copy the running configuration datastore
to the startup configuration datastore.
    </t>
    <t>
If the operation succeeds, a &quot;204 No Content&quot; value in the 
&quot;Status&#8209;Line&quot; is sent in the response.
If the operation fails, the
appropriate error code is set according to the rules
in <xref target="error-reporting"/>, and the error report
is sent in the response, according to the format defined in <xref target="errors"/>.
    </t>
    <t>
The &quot;save&#8209;datastore&quot; operation does not take any parameters.
The YANG &quot;rpc&quot; statement definition for this operation
is defined in <xref target="module"/>.
    </t>
    <t>
Example:
    </t>
    <t>
The client might request that the running configuration
datastore be saved in non-volatile storage as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/operations/save-datastore HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
If the operation succeeds the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:03:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
    <t>
If the operation fails the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:03:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
</section>
<section title="/yang-api/operations/unlock-datastore">
    <t>
The &quot;unlock&#8209;datastore&quot; operation resource is used to unlock
the datastore resource represented by the URI &quot;/yang&#8209;api/datastore&quot;.
It behaves exactly the same as the NETCONF &lt;unlock&gt; operation
on the running configuration datastore.
    </t>
    <t>
If the operation succeeds, a &quot;204 No Content&quot; value in the 
&quot;Status&#8209;Line&quot; is sent in the response. 
If the operation fails, the
appropriate error code is set according to the rules
in <xref target="error-reporting"/>, and the error report
is sent in the response, according to the format defined in <xref target="errors"/>.
    </t>
    <t>
The &quot;unlock&#8209;datastore&quot; operation does not take any parameters.
The YANG &quot;rpc&quot; statement definition for this operation
is defined in <xref target="module"/>.
    </t>
    <t>
Example:
    </t>
    <t>
The client might release a lock on the running configuration
datastore as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/operations/unlock-datastore HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
If the operation succeeds the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:03:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
    <t>
If the operation fails the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:03:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="/yang-api/modules">
    <t>
This mandatory field contains the identifiers 
for the YANG data model modules supported by the server.
There MUST be exactly one instance of this field.
    </t>
    <t>
The server MUST maintain a last-modified timestamp for this 
field, and return the &quot;Last&#8209;Modified&quot; header when this 
field is retrieved with the GET or HEAD methods.
    </t>
<section title="/yang-api/modules/module">
    <t>
This mandatory field contains one URI string
for each YANG data model module supported by the server.
There MUST be an instance of this field for every
YANG module that is accessible via an operation resource
or a data resource.
    </t>
    <t>
The server MAY maintain a last-modified timestamp for 
each instance of this resource, and return the 
&quot;Last&#8209;Modified&quot; header when this resource is retrieved 
with the GET or HEAD methods.  If not supported
then the timestamp for the parent &quot;modules&quot; field
MUST NOT be used instead.
    </t>
    <t>
The contents of this field are encoded with the &quot;uri&quot;
derived type from the &quot;ietf&#8209;iana&#8209;types&quot; modules
in <xref target="RFC6021"/>.  
    </t>
    <t>
There are additional encoding requirements for this field.
The URI MUST follow the YANG module capability URI formatting
defined in section 5.6.4 of <xref target="RFC6020"/>.
    </t>
</section>
<section title="Retrieval Example">
    <t>
In this example the client is retrieving the modules field
from the server in the default JSON format:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api?select=modules HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.api+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows.
Note that the content below is split across multiple
lines for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Last-Modified: Sun, 22 Apr 2012 01:00:14 GMT
   Content-Type: application/vnd.yang.api+json

   {
     "yang-api": {
       "modules": {
         "module": [
           "example.com?module=foo&revision=2012-01-02",
           "example.com?module=bar&revision=2011-10-10"
           "example.com?module=itf&revision=2011-10-10
               &feature=restore"
         ]
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="/yang-api/transaction">
    <t>
This optional resource will be supported if the
server implements transactions, identified by the 
&quot;/yang&#8209;api/capabilities/edit&#8209;model&quot; field
in the API resource.
It is used to allow one or more individual edits to
be applied (all-or-nothing) to the running configuration datastore,
and to facilitate concurrent editing transactions
with a mechanism to update the transaction datastore
contents with the latest running configuration datastore
contents.  
    </t>
    <t>
This resource is defined in <xref target="transactions"/>.
    </t>
</section>
<section title="/yang-api/version">
    <t>
This mandatory field identifies the specific version
of the YANG-API protocol implemented by the server.
    </t>
    <t>
The same server-wide response MUST be returned
each time this field is retrieved.  It is assigned
by the server when the server is started.
The server MUST return the value &quot;1.0&quot; for this
version of the YANG-API protocol.
    </t>
    <t>
This field is encoded with the rules for an &quot;enumeration&quot; data type,
using the following leaf definition:
    </t>
	<figure>
	    <artwork><![CDATA[
   leaf version {
     config false;
     type enum {
       enum "1.0" {
         description 
           "Version 1.0 of the YANG-API protocol.";
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Datastore Resource" anchor="datastore-resource">
    <t>
A datastore resource represents the conceptual root
of a tree of data resources.
    </t>
    <t>
The server MUST maintain a last-modified timestamp for this 
resource, and return the &quot;Last&#8209;Modified&quot; header when this 
resource is retrieved with the GET or HEAD methods.
Only changes to configuration data resources within
the datastore affect this timestamp.
    </t>
    <t>
The server SHOULD maintain a resource entity tag for this 
resource, and return the &quot;ETag&quot; header when this 
resource is retrieved with the GET or HEAD methods.
The resource entity tag SHOULD be changed to a new
previously unused value if changes to any configuration
data resources within the datastore are made.
    </t>
    <t>
A datastore resource can be retrieved with the GET operation,
to retrieve either configuration data resources or non-configuration
data resources within the datastore.  The &quot;config&quot; query
parameter is used to choose between them.
Refer to <xref target="config-param"/> for more details.
    </t>
    <t>
The depth of the subtrees returned in retrieval operations
can be controlled with the &quot;depth&quot; query parameter.
The number of nest levels, starting at the target resource,
can be specified, or an unlimited number can be returned.
Refer to <xref target="depth-param"/> for more details.
    </t>
    <t>
A datastore resource cannot be written directly with
any edit operation. Only the configuration data resources
within the datastore resource can be edited.
    </t>
</section>
<section title="Data Resource" anchor="data-resource">
    <t>
A data resource represents a YANG data node that is a descendant
node of a datastore resource.
    </t>
    <t>
For configuration data resources,
the server MAY maintain a last-modified timestamp for the
resource, and return the &quot;Last&#8209;Modified&quot; header when it
is retrieved with the GET or HEAD methods.
    </t>
    <t>
For configuration data resources,
the server MAY maintain a resource entity tag for the
resource, and return the &quot;ETag&quot; header when it
is retrieved as the target resource with the GET or HEAD methods.
The resource entity tag SHOULD be changed to a new
previously unused value if changes to the resource
or any configuration field within the resource is altered.
    </t>
    <t>
A data resource can be retrieved with the GET operation,
to retrieve either configuration data resources or non-configuration
data resources within the target resource.  The &quot;config&quot; query
parameter is used to choose between them.
Refer to <xref target="config-param"/> for more details.
    </t>
    <t>
The depth of the subtrees returned in retrieval operations
can be controlled with the &quot;depth&quot; query parameter.
The number of nest levels, starting at the target resource,
can be specified, or an unlimited number can be returned.
Refer to <xref target="depth-param"/> for more details.
    </t>
    <t>
A configuration data resource can be altered by the client
with some of all of the edit operations, depending on the
target resource and the specific operation. Refer to <xref target="operations"/>
for more details on edit operations.
    </t>
<section title="Encoding YANG Instance Identifiers in the Request URI" anchor="uri-encoding">
    <t>
In YANG, data nodes are named with an absolute
XPath expression, from the document root to the target resource.
In YANG-API, URL friendly path expressions are used instead.
    </t>
    <t>
The YANG &quot;instance&#8209;identifier&quot; (i-i) data type is represented
in YANG-API with the path expression format defined
in this section. 
    </t>
<?rfc compact="yes"?><texttable title="YANG-API instance-identifier Type Conversion">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Comments</ttcol>
<c>point</c>
<c>Insertion point is always a full i-i</c>
<c>path</c>
<c>Request URI path is a full or partial i-i</c>
</texttable>
<?rfc compact="no"?>    <t>
The &quot;path&quot; component of the request URI contains the
absolute path expression that identifies the
target resource.  The &quot;select&quot; query parameter is
used to optionally identify the requested data nodes
within the target resource to be retrieved in a GET operation.
    </t>
    <t>
A predictable location for a data resource
is important, since applications will code to the YANG
data model module, which uses static naming and defines an
absolute path location for all data nodes.
    </t>
    <t>
A YANG-API data resource identifier is not an XPath expression.
It is encoded from left to right, starting with the top-level
data node, according to the &quot;api&#8209;path&quot; rule in <xref target="path-abnf"/>.
The node name of each ancestor of the target resource node
is encoded in order, ending with the node name for the
target resource.
    </t>
    <t>
If the &quot;select&quot; is present, it is encoded,
starting with a child node of the target resource,
according to the &quot;api&#8209;select&quot; rule defined in <xref target="path-abnf"/>.
    </t>
    <t>
If a data node in the path expression is a YANG list node,
then the key values for the list (if any) are encoded
according to the &quot;key&#8209;value&quot; rule.  If the list node
is the target resource, then the key values MAY be omitted,
according to the operation.  For example, the POST
operation to create a new data resource for a list node
does not allow the key values to be present in the request URI.
    </t>
    <t>
The key leaf values for a data resource representing a YANG list
MUST be encoded as follows:
    </t>
<t>
 <list style="symbols">
 <t>
The value of each leaf identified in the &quot;key&quot; statement
is encoded in order.
 </t>
 <t>
All the components in the &quot;key&quot; statement MUST be encoded.
Partial instance identifiers are not supported.
 </t>
 <t>
Each value is encoded using the &quot;key&#8209;value&quot; rule in <xref target="path-abnf"/>,
according to the encoding rules for the data type of the key leaf.
 </t>
 <t>
An empty string can be a valid key value
(e.g., &quot;/top/list/key1//key3&quot;).
 </t>
 <t>
The &quot;/&quot; character MUST be URL-encoded (i.e., &quot;%2F&quot;).
 </t>
 <t>
All whitespace MUST be URL-encoded.
 </t>
 <t>
A &quot;null&quot; value is not allowed since the &quot;empty&quot; data type is
not allowed for key leafs.
 </t>
 <t>
The XML encoding is defined in <xref target="RFC6020"/>.
 </t>
 <t>
The JSON encoding is defined in <xref target="I-D.lhotka-yang-json"/>.
 </t>
 <t>
The entire &quot;key&#8209;value&quot; MUST be properly URL-encoded,
according to the rules defined in <xref target="RFC3986"/>.
 </t>
 </list>
</t>
    <t>
Examples:
    </t>
	<figure>
	    <artwork><![CDATA[
  /yang-api/datastore/jukebox/library/artist/17&select=name

  /yang-api/datastore/newlist/17&select=nextlist/22/44/myleaf

  /yang-api/datastore/somelist/fred%20and%20wilma

  /yang-api/datastore/somelist/fred%20and%20wilma/address
	    ]]></artwork>
	</figure>
<section title="ABNF For Data Resource Identifiers" anchor="path-abnf">
    <t>
The following ABNF syntax is used to construct YANG-API
path identifiers:
    </t>
	<figure>
	    <artwork><![CDATA[
    api-path = "/" api-identifier
                    0*("/" (api-identifier | key-value ))

    [FIXME: the syntax for the select string is still TBD]
    api-select = api-identifier
                    0*("/" (api-identifier | key-value ))

    api-identifier = [module-name ":"] identifier

    module-name = identifier

    key-value = string 

    ;; An identifier MUST NOT start with 
    ;; (('X'|'x') ('M'|'m') ('L'|'l'))
    identifier  = (ALPHA / "_")
                  *(ALPHA / DIGIT / "_" / "-" / ".")

    string = <an unquoted string>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Identifying YANG-defined Data Resources" anchor="identify-yang">
    <t>
The data resources used in YANG-API are
defined with YANG data definition statements.
    </t>
    <t>
Not every data node defined in a YANG module
should be treated as a resource. The YANG-API needs to know
which YANG data nodes are resources, and which are fields
within a resource.
    </t>
    <t>
For data resources, YANG-API uses a simple algorithm for defining
resource boundaries, within the conceptual sub-trees
described by YANG data definition statements.
    </t>
    <t>
All top-level data nodes are considered to
be resources. For nodes within a top-level resource:
    </t>
<t>
 <list style="symbols">
 <t>
a presence container starts a new resource
 </t>
 <t>
a list starts a new resource
 </t>
 <t>
an optional terminal node (anyxml, leaf, or leaf-list) starts a new resource
 </t>
 <t>
a data node of type &quot;anyxml&quot; cannot have any sub-resources
 </t>
 </list>
</t>
    <t>
A non-configuration data node cannot be a separate resource
from its parent.  Only top-level data nodes are considered
to be resources (which only support retrieval methods).
    </t>
</section>
<section title="Identifying Optional Keys" anchor="optional-keys">
    <t>
It is sometimes useful to have the server assign
the key(s) for a new resource.  The &quot;Location&quot;
header will indicate the key value(s) that the server
selected, so the client does not need to provide all the key leaf
values.
    </t>
    <t>
It is useful to identify in the YANG data model module
which key leafs are optional to provide, and which are not.
The YANG extension statement &quot;optional&#8209;key&quot; is provided
to indicate that the leaf definition represents
an optional key.
    </t>
    <t>
The client MAY provide a value for a key leaf 
in a POST operation.  Refer to <xref target="module"/> for details
on the &quot;optional&#8209;key&quot; extension.  Refer to <xref target="example-module"/>
for usage examples of this YANG extension statement.
    </t>
</section>
<section title="Data Resource Retrieval" anchor="data-retrieval">
    <t>
There are four types of filtering for retrieval of data resources.
This section defines each mode.
    </t>
<section title="Conditional Retrieval">
    <t>
The HTTP headers (such as &quot;If&#8209;Modified&#8209;Since&quot; and &quot;If&#8209;Match&quot;)
can by used in for a request message for a GET operation
to check a condition within the server state, such as the
last time the datastore resource was modified, or the resource entity tag
of the target resource.  
    </t>
    <t>
If the condition is met according to the header
definition, a &quot;200 OK&quot; Status-Line and the data requested is 
returned in the response message.
If the condition is not met, a &quot;304 Not Modified&quot;
Status-Line is returned in response message instead.
    </t>
</section>
<section title="Data Classification Retrieval">
    <t>
The &quot;config&quot; query parameter
can be used with the GET operation to specify whether
configuration or non-configuration data is requested.
Refer to <xref target="config-param"/> for more details on the &quot;config&quot;
query parameter.
    </t>
</section>
<section title="Subset Retrieval">
    <t>
The &quot;Range&quot; header is used to request a specific
subset of the instances of a list or leaf-list 
data resource that are returned by the
server for a retrieval operation.  Normally, if the target resource
in a request message does not specify an instance,
then all instances are returned.
    </t>
    <t>
The YANG-API protocol uses the token &quot;entries&quot; instead
of &quot;bytes&quot; as the range units.
    </t>
    <t>
The entries are numbered
starting from &quot;0&quot;.  A list or leaf-list can change order
between requests so the client needs to be aware of
the data model semantics, and whether the list contents
are stable enough to use the subset retrieval mechanism.
    </t>
    <t>
If the requested range cannot be returned
because the range specification includes index
values for entries that do not exist,
then an error occurs, and the server MUST return
a &quot;416 Requested range not satisfiable&quot; Status-Line.
    </t>
    <t>
If the range request can be satisfied, then a &quot;200 OK&quot;
Status-Line is returned, and the response MUST include
a &quot;Content&#8209;Range&quot; header indicating which entries are
returned.  The response message body contains the
data for the requested range of entries.
    </t>
    <t>
Example:
    </t>
    <t>
In this example, the client is requesting 5 &quot;artist&quot;
resource entries, starting with the 10th entry:
    </t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   GET /yang-api/datastore/jukebox/library/artist HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.data+json
   Range: entries 10-14

 Response from server:

   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/vnd.yang.data+json
   Content-Range: entries 10-14
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 02:12:20 GMT
   ETag: abcada438af

   {
     "artist" : {
         // content removed for brevity
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="Filtered Retrieval">
    <t>
The &quot;select&quot; query parameter is used to specify a filter
that should be applied to the target resource to
request a subset of all possible descendant nodes
within the target resource.
    </t>
    <t>
The format of the &quot;select&quot; parameter string is defined
in <xref target="select-param"/>.  The set of nodes selected by the
filter expression is applied to each context node
identified by the target resource.
    </t>
</section>
</section>
</section>
<section title="Operation Resource ">
    <t>
An operation resource represents an RPC operation
defined with the YANG &quot;rpc&quot; statement.
    </t>
    <t>
All operation resources share the same module namespace
as any top-level data resources, so the name of an operation
resource cannot conflict with the name of a top-level
data resource defined within the same module.
    </t>
    <t>
If 2 different YANG modules define the same &quot;rpc&quot; identifier,
then the module name MUST be used in the request URI.
For example, if &quot;module&#8209;A&quot; and &quot;module&#8209;B&quot; both defined
a &quot;reset&quot; operation, then invoking the operation from &quot;module&#8209;A&quot;
would be requested as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/operations/module-A:reset HTTP/1.1
   Server example.com
	    ]]></artwork>
	</figure>
    <t>
Any usage of an operation resource from the same module,
with the same name, refers to the same &quot;rpc&quot; statement
definition.  This behavior can be used to design RPC operations
that perform the same general function on different
resource types.
    </t>
    <t>
If the &quot;rpc&quot; statement has an &quot;input&quot; section, then a message body
MAY be sent by the client in the request, otherwise the request
message MUST NOT include a message body.
If the &quot;rpc&quot; statement has an &quot;output&quot; section, then a message body
MAY be sent by the server in the response. Otherwise the 
server MUST NOT include a message body in the response message,
and MUST send a &quot;204 No Content&quot; Status-Line instead.
    </t>
<section title="Encoding Operation Input Parameters">
    <t>
If the &quot;rpc&quot; statement has an &quot;input&quot; section, then
the &quot;input&quot; node is provided in the message body,
corresponding to the YANG data definition statements
within the &quot;input&quot; section.
    </t>
    <t>
Example:
    </t>
    <t>
The following YANG definition is used for the examples in this
section.
    </t>
	<figure>
	    <artwork><![CDATA[
    rpc reboot {
      input {
        leaf delay {
          units seconds;
          type uint32;
          default 0;
        }
        leaf message { type string; }
        leaf language { type string; }
      }
    }
	    ]]></artwork>
	</figure>
    <t>
The client might send the following POST request message:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/datastore/operations/reboot HTTP/1.1
   Host: example.com
   Content-Type: application/vnd.yang.data+json

   {
     "input" : {
       "delay" : 600,
       "message" : "Going down for system maintenance",
       "language" : "en-US"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 25 Apr 2012 11:01:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
</section>
<section title="Encoding Operation Output Parameters">
    <t>
If the &quot;rpc&quot; statement has an &quot;output&quot; section, then
the &quot;output&quot; node is provided in the message body,
corresponding to the YANG data definition statements
within the &quot;output&quot; section.
    </t>
    <t>
Example:
    </t>
    <t>
The following YANG definition is used for the examples in this
section.
    </t>
	<figure>
	    <artwork><![CDATA[
    rpc get-reboot-info {
      input {
        leaf reboot-time {
          units seconds;
          type uint32;
        }
        leaf message { type string; }
        leaf language { type string; }
      }
    }
	    ]]></artwork>
	</figure>
    <t>
The client might send the following POST request message:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/datastore/operations/get-reboot-info HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 25 Apr 2012 11:10:30 GMT
   Server: example-server
   Content-Type: application/vnd.yang.data+json

   {
     "output" : {
       "reboot-time" : 30,
       "message" : "Going down for system maintenance",
       "language" : "en-US"
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="Identifying YANG-defined Operation Resources" anchor="identify-yang-op">
    <t>
The operation resources used in YANG-API are
defined with YANG &quot;rpc&quot; statements.
All &quot;rpc&quot; statements within a YANG module that are
supported by the server are available as operation resources.
    </t>
</section>
</section>
<section title="Transaction Resource" anchor="transactions">
    <t>
The &quot;transaction&quot; resource type is used to
construct a set of one or more edit operations
on data resources within a &quot;scratchpad&quot; datastore
resource.  The transaction can be committed
when the client decides the data resource edits are complete.
The transaction can also be reverted and updated,
as described later in this section.
    </t>
    <t>
This resource type will only be supported if the
&quot;edit&#8209;model&quot; capabilities field in the API resource
includes the value &quot;transaction&quot;.
If transactions are supported, then the server
will allow the client to create, use, and delete
transaction resources.
    </t>
    <t>
The POST operation is used to create a new transaction resource.
The DELETE operation is used to cleanup and delete an
existing transaction resource.  The PUT and PATCH operations
are not supported for this resource type.
    </t>
    <t>
The media type for the transaction resource type is
either &quot;application/vnd.yang.transaction+xml&quot;
or &quot;application/vnd.yang.transaction+json&quot;.
    </t>
    <t>
The procedures for editing the transaction datastore contents
are the same as those for editing the running configuration
datastore except the changes do not take effect right away
and the datastore integrity validation tests are not
done until the transaction is committed to running
configuration datastore.
    </t>
    <t>
The following steps are typically followed to use transaction
resources:
    </t>
<t>
 <list style="symbols">
 <t>
create a transaction resource using the URI &quot;/yang&#8209;api/transaction&quot;.
 </t>
 <t>
the server will allocate a new transaction and return its resource ID.
 </t>
 <t>
add/alter/delete data resources within the scratchpad datastore
 </t>
 <t>
commit the transaction to the running configuration datastore.
 </t>
 <t>
delete the transaction resource
 </t>
 </list>
</t>
<section title="Creating a Transaction Resource">
    <t>
In order to reduce the complexity of query parameters and
allow easier extensibility of transaction resource creation,
the configuration parameters for the transaction are
sent in the request message for the POST operation.
    </t>
    <t>
The only parameter at this time is the &quot;exclusive&#8209;mode&quot; parameter,
which is used by the client to request that no other transactions
or direct edits are allowed to alter the running configuration datastore
while the exclusive mode transaction resource exists.
An exclusive mode transaction if the server transaction-model
is &quot;shared&quot; is conceptually equivalent in NETCONF to
global locks on both the &quot;candidate&quot; and &quot;running&quot; datastores.
    </t>
    <t>
The following YANG leaf definition is used for the &quot;exclusive&#8209;mode&quot;
parameter, for encoding purposes:
    </t>
	<figure>
	    <artwork><![CDATA[
    leaf exclusive-mode {
      type boolean;
      default false;
      description "Exclusive transaction mode";
    }
	    ]]></artwork>
	</figure>
    <t>
When a transaction resource is created by the client,
the server will generate an opaque string to
identify the transaction.  This transaction ID will be
used by the server in the resource ID for the new transaction.
    </t>
    <t>
If the server uses a shared transaction model, then the
transaction ID MAY be the same for multiple transaction resources.
Otherwise the server SHOULD use a unique identifier for each
transaction resource.
    </t>
    <t>
The server does not ensure exclusive access to a particular
transaction.  The access control mechanisms for sharing
transactions is out of scope for this document.
    </t>
    <t>
After a transaction has been successfully created, 
it can be accessed via the &quot;Location&quot; header returned
in the response message.
    </t>
    <t>
Example:
    </t>
    <t>
The following message shows an exclusive transaction
resource request. The client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/transaction HTTP/1.1
   Host: example.com
   Content-Type: application/vnd.yang.transaction+json

   {
     "transaction" : {
       "exclusive-mode" : true
     }
   }
	    ]]></artwork>
	</figure>
    <t>
The server might reply:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Location: http://example.com/yang-api/transaction/12345
   Last-Modified: Mon, 23 Apr 2012 19:48:00 GMT
   ETag: b38830de24c
	    ]]></artwork>
	</figure>
</section>
<section title="Editing a Transaction Datastore">
    <t>
When a transaction resource is created,
the server will create a child datastore resource,
which is a conceptual scratchpad for collecting
edits to later be applied all at once to the running
configuration datastore.  The initial contents
of this datastore are the contents of the running
configuration datastore at the time the transaction
is created.
    </t>
    <t>
After a transaction has been successfully created, 
it can be accessed by using the previously retrieved
&quot;Location&quot; header value in the request URI of
new request messages.
This datastore resource is a child node
of the resource ID node, identified by a URI.
    </t>
    <t>
For example, the &quot;path&quot; component of a request URI
for a datastore resource (for transaction ID &quot;12345&quot;) would be:
    </t>
	<figure>
	    <artwork><![CDATA[
   "/yang-api/transaction/12345/datastore"
	    ]]></artwork>
	</figure>
    <t>
The client can add, edit, or delete the data resources
within the transaction datastore.  Refer to <xref target="data-resource"/>
for details on editing data resources.
    </t>
    <t>
Example:
    </t>
    <t>
The following message shows the creation of a new
&quot;artist&quot; resource within the &quot;jukebox&quot; resource.
The request URI is split across lines for display purposes only.
    </t>
    <t>
The client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/transaction/12345/datastore/jukebox/
      library/artist HTTP/1.1
   Host: example.com
   Content-Type: application/vnd.yang.data+json

   {
     "artist" : {
       "name" : "Miles Davis"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
The server might reply as follows.
The &quot;Location&quot; header is split across lines for display purposes only.
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 24 Apr 2012 11:01:00 GMT
   Server: example-server
   Location: http://example.com/yang-api/transaction/
     12345/datastore/jukebox/library/artist/2
   Last-Modified: Mon, 24 Apr 2012 11:01:00 GMT
   ETag: b38830de24c
	    ]]></artwork>
	</figure>
</section>
<section title="Deleting a Transaction Resource">
    <t>
Once a client is finished with a transaction resource,
it SHOULD be deleted by the client.
A transaction resource is not deleted when a commit
is completed.  The DELETE operation is used to
terminate the transaction, and discard the transaction database
and all its data resource contents.
    </t>
    <t>
Example:
    </t>
    <t>
The following message shows the deletion of an
existing transaction resource.
    </t>
    <t>
The client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   DELETE /yang-api/transaction/12345
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might reply as follows.
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 24 Apr 2012 12:01:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
</section>
<section title="Transaction Operations" anchor="transaction-ops">
    <t>
There are a small number of operation resources available
for transaction resources.  These are protocol operations
beyond the basic CRUD operations allowed for the
data resources within the transaction datastore.
    </t>
<section title="commit">
    <t>
The &quot;commit&quot; operation is used to apply the contents of
the transaction datastore to the running configuration datastore.
    </t>
    <t>
If this operation succeeds then a &quot;204 No Content&quot; Status-Line
is sent in the response message.
If the operation fails, the
appropriate error code is set according to the rules
in <xref target="error-reporting"/>, and the error report
is sent in the response, according to the format defined in <xref target="errors"/>.
    </t>
    <t>
Example:
    </t>
    <t>
The following message exchange shows a commit operation.
The client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/transaction/12345/commit
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might reply as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 25 Apr 2012 01:21:00 GMT
   Server: example-server
   Last-Modified: Mon, 25 Apr 2012 01:21:00 GMT
   ETag: ab34530de24c
	    ]]></artwork>
	</figure>
</section>
<section title="discard-changes">
    <t>
The &quot;discard&#8209;changes&quot; operation is used to replace the contents of
the transaction datastore with the contents
of the running configuration datastore.
    </t>
    <t>
If this operation succeeds then a &quot;204 No Content&quot; Status-Line
is sent in the response message.
If the operation fails, the
appropriate error code is set according to the rules
in <xref target="error-reporting"/>, and the error report
is sent in the response, according to the format defined in <xref target="errors"/>.
    </t>
    <t>
Example:
    </t>
    <t>
The following message exchange shows a discard-changes operation.
The client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/transaction/12345/discard-changes
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might reply as follows.
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 25 Apr 2012 01:22:00 GMT
   Server: example-server
   Last-Modified: Mon, 25 Apr 2012 01:22:00 GMT
   ETag: ee3498de24c
	    ]]></artwork>
	</figure>
</section>
<section title="update">
    <t>
The &quot;update&quot; operation is used to merge the contents of
the running configuration datastore into the transaction datastore.
If any editing conflicts are detected that cannot
be resolved by the server, then the update operation MUST fail,
and the transaction datastore contents MUST remain unchanged
after the operation is completed.
    </t>
    <t>
If this operation succeeds then a &quot;204 No Content&quot; Status-Line
is sent in the response message.
If the operation fails, the
appropriate error code is set according to the rules
in <xref target="error-reporting"/>, and the error report
is sent in the response, according to the format defined in <xref target="errors"/>.
    </t>
    <t>
Example:
    </t>
    <t>
The following message exchange shows an update operation.
The client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/transaction/12345/update
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might reply as follows.
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 25 Apr 2012 01:32:00 GMT
   Server: example-server
   Last-Modified: Mon, 25 Apr 2012 01:32:00 GMT
   ETag: ab23984de125
	    ]]></artwork>
	</figure>
</section>
<section title="validate">
    <t>
The &quot;validate&quot; operation is used to validate the contents of
the transaction datastore.  The server will verify
that the transaction datastore can be committed
to the running configuration datastore.
If any editing conflicts are detected which cannot
be resolved by the server, then the update operation MUST fail.
    </t>
    <t>
If this operation succeeds then a &quot;204 No Content&quot; Status-Line
is sent in the response message.
If the operation fails, the
appropriate error code is set according to the rules
in <xref target="error-reporting"/>, and the error report
is sent in the response, according to the format defined in <xref target="errors"/>.
    </t>
    <t>
Example:
    </t>
    <t>
The following message exchange shows a validate operation.
The client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/transaction/12345/validate
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might reply as follows.
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 25 Apr 2012 01:42:00 GMT
   Server: example-server
   Last-Modified: Mon, 25 Apr 2012 01:32:00 GMT
   ETag: ab23984de125
	    ]]></artwork>
	</figure>
</section>
</section>
</section>
</section>
<section title="Error Reporting" anchor="error-reporting">
    <t>
HTTP Status-Lines are used to report success or failure
for YANG-API operations.
The &lt;rpc&#8209;error&gt; element returned in NETCONF error responses
contains some useful information.  This error information
is adapted for use in YANG-API, and error information
is returned for &quot;4xx&quot; class of status codes.
    </t>
    <t>
The following table summarizes the return status codes
used specifically by YANG-API operations:
    </t>
<?rfc compact="yes"?><texttable title="HTTP Status Codes used in YANG-API">
<ttcol align='left'> Status-Line</ttcol>
<ttcol align='left'>Description</ttcol>
<c>100 Continue</c>
<c>POST accepted, 201 should follow</c>
<c>200 OK</c>
<c>Success with response body</c>
<c>201 Created</c>
<c>POST to create a resource success</c>
<c>202 Accepted</c>
<c>POST to create a resource accepted</c>
<c>204 No Content</c>
<c>Success without response body</c>
<c>304 Not Modified</c>
<c>Conditional operation not done</c>
<c>400 Bad Request</c>
<c>Invalid request message</c>
<c>403 Forbidden</c>
<c>Access to resource denied</c>
<c>404 Not Found</c>
<c>Resource target or resource node not found</c>
<c>405 Method Not Allowed</c>
<c>Method not allowed for target resource</c>
<c>409 Conflict</c>
<c>Resource or lock in use</c>
<c>413 Request Entity Too Large</c>
<c>too-big error</c>
<c>414 Request-URI Too Large</c>
<c>too-big error</c>
<c>415 Unsupported Media Type</c>
<c>non YANG-API media type</c>
<c>416 Requested range not satisfiable</c>
<c>If-Range error</c>
<c>500 Internal Server Error</c>
<c>operation-failed</c>
<c>501 Not Implemented</c>
<c>unknown-operation</c>
<c>503 Service Unavailable</c>
<c>Recoverable server error</c>
</texttable>
<?rfc compact="no"?>    <t>
Since an operation resource is defined with a YANG &quot;rpc&quot;
statement, a mapping between the NETCONF &lt;error&#8209;tag&gt; value
and the HTTP status code is needed.   The specific error
condition and response code to use are data-model specific
and might be contained in the YANG &quot;description&quot; statement
for the &quot;rpc&quot; statement.
    </t>
<?rfc compact="yes"?><texttable title="Mapping from error-tag to status code">
<ttcol align='left'> &lt;error&#8209;tag&gt;</ttcol>
<ttcol align='left'>status code</ttcol>
<c>in-use</c>
<c>409</c>
<c>invalid-value</c>
<c>400</c>
<c>too-big</c>
<c>413</c>
<c>missing-attribute</c>
<c>400</c>
<c>bad-attribute</c>
<c>400</c>
<c>unknown-attribute</c>
<c>400</c>
<c>bad-element</c>
<c>400</c>
<c>unknown-element</c>
<c>400</c>
<c>unknown-namespace</c>
<c>400</c>
<c>access-denied</c>
<c>403</c>
<c>lock-denied</c>
<c>409</c>
<c>resource-denied</c>
<c>409</c>
<c>rollback-failed</c>
<c>500</c>
<c>data-exists</c>
<c>409</c>
<c>data-missing</c>
<c>409</c>
<c>operation-not-supported</c>
<c>501</c>
<c>operation-failed</c>
<c>500</c>
<c>partial-operation</c>
<c>500</c>
<c>malformed-message</c>
<c>400</c>
</texttable>
<?rfc compact="no"?><section title="Error Response Message" anchor="errors">
    <t>
When an error occurs for a request message on a data resource
or an operation resource, and a &quot;4xx&quot; class of status codes
(except for status code &quot;403&quot;),
then the server SHOULD send a response body containing
the information described by the following YANG data definition
statement:
    </t>
	<figure>
	    <artwork><![CDATA[
    container errors {
      config false;

      list error {
        reference "RFC 6241, Section 4.3";
        leaf error-type { 
          mandatory true;
          type enumeration {
            enum transport;
            enum rpc;
            enum protocol;
            enum application;
          }
        }
        leaf error-tag { 
          mandatory true;
          type string;
        }
        leaf error-app-tag { 
          type string;
        }
        leaf error-path { 
          type string;  // YANG-API encoded instance-identifier
        }
        leaf error-message { 
          type string;
        }
        container error-info { 
           // anyxml content here
        }
      }
    }
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
The following example shows an error returned for
an &quot;lock&#8209;denied&quot; error on a datastore resource.
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/operations/lock-datastore HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 409 Conflict
   Date: Mon, 23 Apr 2012 17:11:00 GMT
   Server: example-server
   Content-Type: application/vnd.yang.api+json

   {
     "errors": {
       "error": {
         "error-type": "protocol",
         "error-tag": "lock-denied",
         "error-message": "Lock failed, lock is already held",
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="RelaxNG Grammar">
    <t>
TBD
    </t>
</section>
<section title="YANG-API module" anchor="module">
    <t>
RFC Ed.: update the date below with the date of RFC publication and
remove this note.
    </t>
<t>&lt;CODE BEGINS> file "ietf-yang-api@2012-05-27.yang"</t>
	<figure>
	    <artwork><![CDATA[
module ietf-yang-api {
  namespace "urn:ietf:params:xml:ns:yang:ietf-yang-api";
  prefix "api";

  organization
    "IETF NETCONF (Network Configuration) Working Group";

  contact
    "Editor:   Andy Bierman
               <mailto:andy@yumaworks.com>

     Editor:   Martin Bjorklund
               <mailto:mbj@tail-f.com>";
  
  description
    "This module contains a collection of YANG language extensions
     to describe REST API Resources using YANG data definition 
     statements.

     Copyright (c) 2012 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.";

  // RFC Ed.: replace XXXX with actual RFC number and remove this
  // note.

  // RFC Ed.: remove this note
  // Note: extracted from draft-bierman-netconf-yang-api-00.txt

  // RFC Ed.: update the date below with the date of RFC publication
  // and remove this note.
  revision 2012-05-27 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: YANG-API Protocol.";
  }
  
  /*
   * Extensions
   */ 

  extension optional-key {
    description 
      "This extension is used to allow the client to create
       a new instance of a resource without providing a
       value for the key leaf containing this statement.
       This extension is ignored for NETCONF, and only
       applies to YANG-API resources and fields.
       This extension is ignored unless it appears
       directly within a 'leaf' data definition statement.";
  }


  /*
   * Operations
   */

  rpc lock-datastore {
    description
      "Lock the running configuration datastore for writing.";
  }

  rpc save-datastore {
    description
      "Save the running configuration datastore to non-volatile
       storage.";
  }

  rpc unlock-datastore {
    description
      "Unlock the running configuration datastore.";
  }

  rpc commit {
    description
      "Commit the transaction datastore contents to
       the running configuration datastore.";
  }

  rpc discard-changes {
    description
      "Replace the transaction datastore contents with
       the running configuration datastore contents.";
  }

  rpc update {
    description
      "Attempt to merge the running configuration datastore
       contents into the transaction datastore contents.";
  }

  rpc validate {
    description
      "Validate the transaction datastore contents.";
  }
  
}

	    ]]></artwork>
	</figure>
<t>&lt;CODE ENDS></t>
</section>
<section title="IANA Considerations" anchor="iana">
    <t>
TBD
    </t>
</section>
<section title="Security Considerations">
    <t>
TBD
    </t>
</section>
<section title="Open Issues">
<t>
 <list style="symbols">
 <t>
Resource creation order and other dependencies between resources
are not well identified in YANG.
YANG has leafrefs and instance-identifiers, which can be used 
to identify some order dependencies.
Are any new mechanisms needed in YANG-API needed to identify
resource creation order and other dependency requirements?
 </t>
 <t>
There is no &quot;message&#8209;id&quot; field in a YANG-API message.
Is a message identifier needed?  If so, should either the &quot;Message&#8209;ID&quot;
or &quot;Content&#8209;ID&quot; header from RFC 2392 be used for this purpose?
 </t>
 <t>
The non-configuration data resources are combined with the
configuration data resources within the YANG-API datastore.
The &quot;config&quot; query parameter is used to pick 1 or the
other for GET operations.  Is this the best way to deal with
YANG config-stmt?  Should YANG-API follow the same data
classifications as YANG (i.e. config=true|false),
or create something new?  Note that transactions are config=true
only, like the candidate datastore in NETCONF.
 </t>
 <t>
Should confirmed commit be added? If so, how?
Should NETCONF &quot;confirmed&#8209;commit&quot; procedure be used exactly
for the transaction commit operation, or should a new
procedure be defined?
 </t>
 <t>
Should datastore operations be added 
for &quot;backup&quot; and &quot;restore&quot; functionality?
 </t>
 </list>
</t>
<t>
 <list style="symbols">
 <t>
Should sessions be used or not?
Should &quot;reusable sessions&quot; be used? Better for auditing?
How does locking of the /yang-api/datastore resource
work for multiple edits if a session is 1 operation?
When does the server release the lock and decide it has
been abandoned or client was disconnected?
 </t>
 <t>
What syntax should be used for the &quot;select&quot; query parameter?
 </t>
 <t>
Should the &quot;/yang&#8209;api/modules&quot; field within the API resource
be a separate resource, with its own timestamp?  Currently the
API timestamp is coupled to any changes to the list of loaded
modules.  Should the API resource be static and cacheable?
 </t>
 <t>
How should resource discovery be done?
 </t>
 <t>
What to do about no REMOVE operation, just DELETE?
The effect is local to the request; in a NETCONF
edit-config it is worse, since the netconf request might
create/delete/modify many nodes
 </t>
 <t>
Should every YANG data node be a data resource and every YANG RPC 
statement an operation resource? Is a YANG extension needed to
allow data modeler control of resource boundaries?
 </t>
 <t>
Encoding of leafrefs?  Is there some additional meta-data needed?
Do leafref nodes need to be identified in responses (RFC 5988) or
is the YANG module definition sufficient to provide this meta-data?
 </t>
 <t>
What should the default algorithm be for defining data resources?
Should the default for an augment from another namespace be to
start a new resource? Top-level data node defaults as a resource OK?
 </t>
 <t>
Is the token &quot;entries&quot; legal in the YANG-API usage of Range?
What units should be used?  &quot;bytes&quot; is the only token defined by HTTP.
 </t>
 <t>
How should private transaction conflicts be handled?
Currently up to the server to decide how to
handle conflicts.  What happens if there are transactions A and B.  A commits.
Next, B commits w/o updating.  Will A&apos;s changes be lost?  Maybe.
Detecting conflicts may require a very resource-intensive implementation on the
server - may force the server to create a copy of the entire datastore
for each transaction.  Want to allow a transaction to be just a diff-set
towards the datastore, so transactions are cheap.
 </t>
 <t>
Does the shared transaction work like the candidate wrt to locks?
I.e. will an exclusive transaction start fail if there are
uncommitted changes?
 </t>
 <t>
Need to specify the update/commit procedure in more detail
so that there is some server flexibility and client can tell
what the server will do? E.g., what causes a conflict?
When is update required before commit?
 </t>
 <t>
Are all header lines used by YANG-API supported by common application
frameworks, such as FastCGI and WSGI?  If not, then should
query parameters be used instead, since the QUERY_STRING is
widely available to WEB applications?
 </t>
 <t>
Should the &lt;errors&gt; element returned in error responses
be a separate media type?
 </t>
 <t>
Locks tied to sessions, but if don&apos;t have sessions,
then how do locks work?
 </t>
 <t>
Should locks be modeled as resources as operations.
I.e., remove lock-datastore and unlock-datastore operations.
and transactions will be required (exclusive mode) to
write more than one operation at a time with exclusive access.
 </t>
 <t>
Should the writable-running (direct mode) be removed
and just have transaction resources, which will 
hide writes to running config?
 </t>
 <t>
Should POST to create a new transaction for a shared
candidate be needed? Could get the same transaction ID back
each ime? Predictable resource needed instead?
 </t>
 <t>
Do changes to the shared transaction show up in all copies
when the change is made?
 </t>
 <t>
How can private transactions be shared securely?
Are any new access control mechanisms needed?
 </t>
 </list>
</t>
</section>
<section title="Example YANG Module" anchor="example-module">
	<figure>
	    <artwork><![CDATA[
module example-jukebox {

   namespace "http://example.com/ns/example-jukebox";
   prefix "jbox";

   import ietf-yang-api { prefix api; }

   organization "Example, Inc.";
   description "Example Jukebox Data Model Module";
   revision "2012-05-30";


   identity genre {
     description "Base for all genre types";
   }

   // abbreviated list of genre classifications
   identity Alternative {
     base genre;
   }
   identity Blues {
     base genre;
   }
   identity Country {
     base genre;
   }
   identity Jazz {
     base genre;
   }
   identity Pop {
     base genre;
   }
   identity Rock {
     base genre;
   }

   container jukebox {
     presence 
       "An empty container indicates that the jukebox
        service is available";

     container library {
       list artist {
         key index;
         unique name;

         leaf index {
           api:optional-key;
           type uint32;
           description
             "Optional key used instead of natural key for
              example. Also rare but possible artists with
              the same name are really different entities.";
         }
         leaf name {
           type string;
         }

         list album {
           key name;
           leaf name {
             type string {
               length "1 .. max";
             }
           }
           leaf genre {
             type identityref { base genre; }
           }
           leaf year {
             type uint16 {
               range "1900 .. max";
             }
           }
           list song {
             api:optional-key;
             key index;
             ordered-by user;
             leaf index {
               type uint32;
             }
             leaf name {
               mandatory true;
               type string;
             }
             leaf location {
               mandatory true;
               type string;
             }
             leaf format {
               type string;
             }
             leaf length {
               units "seconds";
               type uint32;
             }
           }
         }
       }
       leaf artist-count {
          config false;
          type uint32;
          units "songs";
          description "Number of artists in the library";
       }
       leaf album-count {
          config false;
          type uint32;
          units "albums";
          description "Number of albums in the library";
       }
       leaf song-count {
          type uint32;
          units "songs";
          description "Number of songs in the library";
       }
     }
  
     list playlist {
       description 
         "Example configuration data resource";
       key name;
       leaf name {
         type string;
       }
       leaf description {
         type string;
       }
       list song {
         description 
           "Example nested configuration data resource";
         ordered-by user;
         key index;
         leaf index {
           api:optional-key;
           type uint32;
         }
         leaf id {
           mandatory true;
           type instance-identifier;
           description 
             "Song identifier. Must identify an instance of
              /jukebox/library/artist/album/song.

              The id is not the key to allow duplicates
              in a playlist";
         }
       }
     }
  
     container player {
       leaf gap {
         description "Time gap between each song";
         units "tenths of seconds";
         type decimal64 {
           fraction-digits 1;
           range "0.0 .. 2.0";
         }
       }
     }
   }

   rpc play {
     description "Control function for the jukebox player";
     input {
       leaf playlist {           
         type string;
         mandatory true;
         description "playlist name";
       }
       leaf song-number {
         type uint32;
         mandatory true;
         description "Song number in playlist to play";
       }
     }
   }         
}

	    ]]></artwork>
	</figure>
</section>
</middle>
<back>
<references title="Normative References">

  <reference anchor="RFC2119">
    <front>
      <title>Key words for use in RFCs to Indicate Requirement Levels</title>
      <author initials="S." surname="Bradner" fullname="S.  Bradner">
        <organization>Harvard University</organization>
      </author>
      <date month="March" year="1997"/>
      <abstract>
        <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.</t>
      </abstract>
    </front>
    <seriesInfo name="BCP" value="14"/>
    <seriesInfo name="RFC" value="2119"/>
    <format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
  </reference>


<reference anchor="RFC2616">

<front>
<title abbrev="HTTP/1.1">Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization abbrev="UC Irvine">Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials="J." surname="Gettys" fullname="James Gettys">
<organization abbrev="Compaq/W3C">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
<organization abbrev="Compaq">Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization abbrev="Xerox">Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials="P." surname="Leach" fullname="Paul J. Leach">
<organization abbrev="Microsoft">Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date year="1999" month="June"/>
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers . A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>

<seriesInfo name="RFC" value="2616"/>
<format type="TXT" octets="422317" target="http://www.rfc-editor.org/rfc/rfc2616.txt"/>
<format type="PS" octets="5529857" target="http://www.rfc-editor.org/rfc/rfc2616.ps"/>
<format type="PDF" octets="550558" target="http://www.rfc-editor.org/rfc/rfc2616.pdf"/>
<format type="HTML" octets="636125" target="http://xml.resource.org/public/rfc/html/rfc2616.html"/>
<format type="XML" octets="493420" target="http://xml.resource.org/public/rfc/xml/rfc2616.xml"/>
</reference>  

<!--
  <reference anchor='RFC3688'>
    <front>
      <title>The IETF XML Registry</title>
      <author initials='M.' surname='Mealling' fullname='M. Mealling'>
        <organization /></author>
      <date year='2004' month='January' />
      <abstract>
        <t>This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas.</t></abstract></front>
    
    <seriesInfo name='BCP' value='81' />
    <seriesInfo name='RFC' value='3688' />
    <format type='TXT' octets='17325' target='http://www.rfc-editor.org/rfc/rfc3688.txt' />
  </reference>
  
-->

<reference anchor="RFC3986">

<front>
<title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>Massachusetts Institute of Technology</street>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>USA</country></postal>
<phone>+1-617-253-5702</phone>
<facsimile>+1-617-258-5999</facsimile>
<email>timbl@w3.org</email>
<uri>http://www.w3.org/People/Berners-Lee/</uri></address></author>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization abbrev="Day Software">Day Software</organization>
<address>
<postal>
<street>5251 California Ave., Suite 110</street>
<city>Irvine</city>
<region>CA</region>
<code>92617</code>
<country>USA</country></postal>
<phone>+1-949-679-2960</phone>
<facsimile>+1-949-679-2972</facsimile>
<email>fielding@gbiv.com</email>
<uri>http://roy.gbiv.com/</uri></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization abbrev="Adobe Systems">Adobe Systems Incorporated</organization>
<address>
<postal>
<street>345 Park Ave</street>
<city>San Jose</city>
<region>CA</region>
<code>95110</code>
<country>USA</country></postal>
<phone>+1-408-536-3024</phone>
<email>LMM@acm.org</email>
<uri>http://larry.masinter.net/</uri></address></author>
<date year="2005" month="January"/>
<area>Applications</area>
<keyword>uniform resource identifier</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>URN</keyword>
<keyword>WWW</keyword>
<keyword>resource</keyword>
<abstract>
<t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t></abstract></front>

<seriesInfo name="STD" value="66"/>
<seriesInfo name="RFC" value="3986"/>
<format type="TXT" octets="141811" target="http://www.rfc-editor.org/rfc/rfc3986.txt"/>
<format type="HTML" octets="213584" target="http://xml.resource.org/public/rfc/html/rfc3986.html"/>
<format type="XML" octets="163534" target="http://xml.resource.org/public/rfc/xml/rfc3986.xml"/>
</reference>


<reference anchor="RFC5789">

<front>
<title>PATCH Method for HTTP</title>
<author initials="L." surname="Dusseault" fullname="L. Dusseault">
<organization/></author>
<author initials="J." surname="Snell" fullname="J. Snell">
<organization/></author>
<date year="2010" month="March"/>
<abstract>
<t>Several applications extending the Hypertext Transfer Protocol (HTTP) require a feature to do partial resource modification.  The existing HTTP PUT method only allows a complete replacement of a document.  This proposal adds a new HTTP method, PATCH, to modify an existing HTTP resource. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name="RFC" value="5789"/>
<format type="TXT" octets="21706" target="http://www.rfc-editor.org/rfc/rfc5789.txt"/>
</reference>



  <reference anchor='RFC6241'>
      <front>
        <title>Network Configuration Protocol (NETCONF)</title>
        <author initials='R.' surname='Enns' fullname='R. Enns' role="editor">
          <organization/>
        </author>
        <author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role="editor">
          <organization/>
        </author>
        <author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder' role="editor">
          <organization/>
        </author>
        <author initials='A.' surname='Bierman' fullname='A. Bierman' role="editor">
          <organization/>
        </author>
        <date year='2011' month='June'/>
      </front>
      <seriesInfo name='RFC' value='6241'/>
  </reference>


  <reference anchor="RFC6020">
    <front>
      <title>YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)</title>
      <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
        <organization/>
      </author>
      <date year="2010" month="October"/>
      <abstract>
        <t>YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications. [STANDARDS TRACK]</t>
      </abstract>
    </front>
    <seriesInfo name="RFC" value="6020"/>
    <format type="TXT" octets="324178" target="http://www.rfc-editor.org/rfc/rfc6020.txt"/>
  </reference>

    <reference anchor='RFC6021'>
      <front>
        <title>Common YANG Data Types</title>
        <author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder'>
          <organization/>
        </author>
        <date year='2010' month='October'/>
      </front>
      <seriesInfo name='RFC' value='6021'/>
    </reference>


<reference anchor="RFC6536">

<front>
<title>Network Configuration Protocol (NETCONF) Access Control Model</title>
<author initials="A." surname="Bierman" fullname="A. Bierman">
<organization/></author>
<author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
<organization/></author>
<date year="2012" month="March"/>
<abstract>
<t>The standardization of network configuration interfaces for use with the Network Configuration Protocol (NETCONF) requires a structured and secure operating environment that promotes human usability and multi-vendor interoperability.  There is a need for standard mechanisms to restrict NETCONF protocol access for particular users to a pre-configured subset of all available NETCONF protocol operations and content.  This document defines such an access control model. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name="RFC" value="6536"/>
<format type="TXT" octets="90803" target="http://www.rfc-editor.org/rfc/rfc6536.txt"/>
</reference>


  <reference anchor="I-D.lhotka-yang-json">
    <front>
      <title>Modeling JSON Text with YANG</title>
      <author initials="L." surname="Lhotka" fullname="L. Lhotka">
        <organization>CZ.NIC</organization>
      </author>
      <date year="2012" month="April"/>
    </front>
    <seriesInfo name="Internet-Draft"
                value="draft-lhotka-yang-json-00"/>
    <format type='TXT'
    target='http://www.ietf.org/internet-drafts/draft-lhotka-yang-json-00.txt'/>

  </reference>

</references>

</back></rfc>
