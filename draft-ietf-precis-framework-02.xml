<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc compact="yes"?>
<?rfc iprnotified="no" ?>
<?rfc sortrefs="yes"?>
<?rfc strict="yes"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>

<rfc category="std" ipr="trust200902" docName="draft-ietf-precis-framework-02" obsoletes="3454">

  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <front>
    <title abbrev="PRECIS Framework">PRECIS Framework: Handling Internationalized Strings in Protocols</title>

    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>1899 Wynkoop Street, Suite 600</street>
          <city>Denver</city>
          <region>CO</region>
          <code>80202</code>
          <country>USA</country>
        </postal>
        <phone>+1-303-308-3282</phone>
        <email>psaintan@cisco.com</email>
      </address>
    </author>

    <author initials="M." surname="Blanchet" fullname="Marc Blanchet">
      <organization>Viagenie</organization>
      <address>
        <postal>
          <street>246 Aberdeen</street>
          <city>Quebec</city>
          <region>QC</region>
          <code>G1R 2E1</code>
          <country>Canada</country>
        </postal>
        <email>Marc.Blanchet@viagenie.ca</email>
        <uri>http://www.viagenie.ca/</uri>
      </address>
    </author>

    <date day="12" month="March" year="2012"/>

    <abstract>
      <t>Application protocols using Unicode code points in protocol strings need to prepare such strings in order to perform comparison operations (e.g., for purposes of authentication or authorization).  This document defines a framework enabling application protocols to use various classes of strings in a way that depends on the properties of Unicode code points.  A specification using this framework can either directly use the base string classes or can subclass the base string classes as needed.  This framework uses an approach similar to the revised internationalized domain names in applications (IDNA) technology (RFC 5890, RFC 5891, RFC 5892, RFC 5893, RFC 5894) and thus adheres to the high-level design goals described in RFC 4690, albeit for application technologies other than the Domain Name System (DNS).  This document obsoletes the previous framework, named Stringprep, as defined in RFC 3454.</t>
    </abstract>

  </front>

  <middle>

    <section title="Introduction" anchor='intro'>
      <t>As described in <xref target='I-D.ietf-precis-problem-statement'/>, many IETF protocols use the Stringprep <xref target='RFC3454'/> framework as the basis for preparing and comparing protocol strings that contain Unicode code points <xref target='UNICODE'/>.  The Stringprep framework was defined during work on the original technology for internationalized domain names (IDNs), IDNA2003 <xref target='RFC3490'/>, as a way to enable other protocols to use the same or similar method by defining a Stringprep profile to prepare and compare strings and identifiers in these protocols.  Nameprep <xref target="RFC3491"/> was such a profile for the IDN case.  Since then, issues were documented <xref target='RFC4690'/> related to the IDN and Nameprep cases.  The new IDN specifications, named IDNA2008 (<xref target='RFC5890'/>, <xref target='RFC5891'/>, <xref target='RFC5892'/>, <xref target='RFC5893'/>, <xref target='RFC5894'/>), do not use Stringprep and Nameprep anymore.  This migration away from Stringprep for internationalized domain names has prompted other "customers" of Stringprep to consider new approaches to the preparation and comparison of internationalized strings ("PRECIS"), as described in <xref target='I-D.ietf-precis-problem-statement'/>.</t>
      <t>This document defines a technical framework for a post-stringprep approach to the preparation and comparison of internationalized strings in application protocols.  The framework is based on several principles:</t>
      <t>
        <list style='numbers'>
          <t>Define a small set of base string classes appropriate for common application protocol constructs such as usernames and free-form strings.<vspace blankLines='1'/></t>
          <t>Define each base string class in terms of Unicode code points and their properties, specifying whether each code point or character category is valid, disallowed, or unassigned.<vspace blankLines='1'/></t>
          <t>Enable application protocols to subclass the base string classes, mainly to disallow particular code points that are currently disallowed in the relevant application protocol (e.g., characters with special or reserved meaning, such as "@" and "/" when used as separators within identifiers).<vspace blankLines='1'/></t>
          <t>Leave various mapping operations (e.g., case preservation or lowercasing, Unicode normalization, right-to-left characters) as the responsibility of application protocols, as was done for IDNA2008 via <xref target='RFC5895'/>.</t>
        </list>
      </t>
      <t>It is expected that this framework will yield the following benefits:</t>
      <t>
        <list style="symbols">
          <t>Application protocols will be more version-agile with regard to the Unicode database.</t>
          <t>Implementers will be able to share code point tables and software code across application protocols, most likely by means of software libraries.</t>
          <t>End users will be able to acquire more accurate expectations about the code points that are acceptable in various contexts.  Given this more uniform set of string classes, it is also expected that copy/paste operations between software implementing different application protocols will be more predictable and coherent.</t>
        </list>
      </t>
      <t>Although this framework is similar to IDNA2008 and borrows some of the character categories defined in <xref target='RFC5892'/>, it defines additional string classes and character categories to meet the needs of common application protocols.</t>
    </section>

    <section title="Terminology" anchor="terms">
      <t>Many important terms used in this document are defined in <xref target='I-D.ietf-precis-problem-statement'/>, <xref target='RFC6365'/>, <xref target='RFC5890'/>, and <xref target='UNICODE'/>.</t>
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target='RFC2119'/>.</t>
    </section>

    <section title="String Classes" anchor='classes'>
      <t>IDNA2008 essentially defines a base string class of internationalized domain name, although it does not use the term "string class".  (This document does not define a string class for domain names, and application protocols are strongly encouraged to use IDNA2008 as the appropriate method to prepare domain names and hostnames.)</t>
      <t>We propose the following additional base string classes for use in application protocols:</t>
      <t>
        <list style='hanging'>
          <t hangText="NameClass:">a sequence of letters, numbers, and symbols that is used to identify or address a network entity such as a user account, a venue (e.g., a chatroom), an information source (e.g., a data feed), or a collection of data (e.g., a file).<vspace blankLines='1'/></t>
          <t hangText="FreeClass:">a sequence of letters, numbers, symbols, spaces, and other code points that is used for free-form strings, including passwords and passphrases as well as display elements such as a human-friendly nickname in a chatroom.</t>
        </list>
      </t>
      <t>The following subsections discuss these string classes in more detail, with reference to the dimensions described in Section 3 of <xref target='I-D.ietf-precis-problem-statement'/>.</t>
      <t>Each string class is defined by the following behavioral rules:</t>
      <t>
        <list style='hanging'>
          <t hangText='Valid:'>defines which code points and character categories are treated as valid input to preparation of the string.<vspace blankLines='1'/></t>
          <t hangText='Disallowed:'>defines which code points and character categories are treated as disallowed during preparation of the string.<vspace blankLines='1'/></t>
          <t hangText='Unassigned:'>defines application behavior in the presence of code points that are unassigned, i.e. unknown for the version of Unicode the application is built upon.<vspace blankLines='1'/></t>
          <t hangText='Directionality:'>defines application behavior in the presence of code points that have directionality, in particular right-to-left code points as defined in the Unicode database (see <xref target='UAX9'/>).<vspace blankLines='1'/></t>
          <t hangText='Casemapping:'>defines if case mapping is used for this class (instead of case preservation), and how the mapping is done.<vspace blankLines='1'/></t>
          <t hangText='Normalization:'>defines which Unicode normalization form (D, KD, C, or KC) is to be applied (see <xref target='UAX15'/>).</t>
        </list>
      </t>
      <t>This document defines the valid, disallowed, and unassigned rules.  Application protocols that use the PRECIS string classes MUST define the directionality, casemapping, and normalization rules, as further described under <xref target='iana-usage'/>.</t>

      <section title="NameClass" anchor="classes-name">
        <t>Most application technologies need a special class of strings that can be used to refer to, include, or communicate things like usernames, file names, data feed names, and chatroom names.  We group such things into a bucket called "NameClass" having the following features.</t>
        <section title='Valid' anchor='classes-name-valid'>
          <t>
            <list style='symbols'>
              <t>Letters and numbers, i.e., the LetterDigits ("A") category first defined in <xref target='RFC5892'/> and listed here under <xref target='A'/>.</t>
              <t>Code points in the range U+0021 through U+007E, i.e., the ASCII7 ("K") rule defined under <xref target='K'/>.  These code points are valid even if they would otherwise be disallowed according to the property-based rules specified in the next section.</t>
            </list>
          </t>
        </section>
        <section title='Disallowed' anchor='classes-name-disallowed'>
          <t>
            <list style='symbols'>
              <t>Control characters, i.e., the Controls ("L") category defined under <xref target='L'/>.</t>
              <t>Ignorable characters, i.e., the PrecisIgnorableProperties ("M") category defined under <xref target='M'/>.</t>
              <t>Space characters, i.e., the Spaces ("N") category defined under <xref target='N'/>.</t>
              <t>Symbol characters, i.e., the Symbols ("O") category defined under <xref target='O'/>.</t>
              <t>Punctuation characters, i.e., the Punctuation ("P") category defined under <xref target='P'/>.</t>
              <t>Any character that has a compatibility equivalent, i.e., the HasCompat ("Q") category defined under <xref target='Q'/>.  These code points are disallowed even if they would otherwise be valid according to the property-based rules specified in the previous section.</t>
            </list>
          </t>
        </section>
        <section title='Unassigned' anchor='classes-name-unassigned'>
          <t>Any code points that are not yet assigned in the Unicode character set SHALL be considered Unassigned for purposes of the NameClass.</t>
        </section>
        <section title='Directionality' anchor='classes-name-directionality'>
          <t>The directionality rule MUST be specified by each application protocol that uses or subclasses the NameClass.</t>
        </section>
        <section title='Case Mapping' anchor='classes-name-mapping'>
          <t>The casemapping rule MUST be specified by each application protocol that uses or subclasses the NameClass.</t>
        </section>
        <section title='Normalization' anchor='classes-name-normalization'>
          <t>The normalization form MUST be specified by each application protocol that uses or subclasses the NameClass.</t>
          <t>However, in accordance with <xref target='RFC5198'/>, normalization form C (NFC) is RECOMMENDED.</t>
        </section>
      </section>

      <section title="FreeClass" anchor="classes-free">
        <t>Some application technologies need a special class of strings that can be used in a free-form way, e.g., as a passphrase in an authentication exchange (see <xref target='I-D.melnikov-precis-saslprepbis'/> or a nickname in a chatroom (see <xref target='I-D.saintandre-precis-nickname'/>).  We group such things into a bucket called "FreeClass" having the following features.</t>
        <t>NOTE: Consult <xref target='security-secrets'/> for relevant security considerations when strings conforming to the FreeClass, or a subclass thereof, are used as passwords or passphrases.</t>
        <section title='Valid' anchor='classes-free-valid'>
          <t>
            <list style='symbols'>
              <t>Letters and numbers, i.e., the LetterDigits ("A") category first defined in <xref target='RFC5892'/> and listed here under <xref target='A'/>.</t>
              <t>Code points in the range U+0021 through U+007E, i.e., the ASCII7 ("K") rule defined under <xref target='K'/>.</t>
              <t>Any character that has a compatibility equivalent, i.e., the HasCompat ("Q") category defined under <xref target='Q'/>.</t>
              <t>Space characters, i.e., the Spaces ("N") category defined under <xref target='N'/>.</t>
              <t>Symbol characters, i.e., the Symbols ("O") category defined under <xref target='O'/>.</t>
              <t>Punctuation characters, i.e., the Punctuation ("P") category defined under <xref target='P'/>.</t>
            </list>
          </t>
        </section>
        <section title='Disallowed' anchor='classes-free-disallowed'>
          <t>
            <list style='symbols'>
              <t>Control characters, i.e., the Controls ("L") category defined under <xref target='L'/>.</t>
              <t>Ignorable characters, i.e., the PrecisIgnorableProperties ("M") category defined under <xref target='M'/>.</t>
            </list>
          </t>
        </section>
        <section title='Unassigned' anchor='classes-free-unassigned'>
          <t>Any code points that are not yet assigned in the Unicode character set SHALL be considered Unassigned for purposes of the FreeClass.</t>
        </section>
        <section title='Directionality' anchor='classes-free-directionality'>
          <t>The directionality rule MUST be specified by each application protocol that uses or subclasses the FreeClass.</t>
        </section>
        <section title='Case Mapping' anchor='classes-free-mapping'>
          <t>The casemapping rule MUST be specified by each application protocol that uses or subclasses the FreeClass.</t>
          <t>In general, case preservation is NOT RECOMMENDED for application protocols that perform case-insensitive comparison of internationalized strings; instead, application protocols SHOULD either (a) not preserve case but perform case-insensitive matching or (b) preserve case but perform case-sensitive comparison.</t>
          <t>In order to maximize entropy, it is NOT RECOMMENDED for application protocols to map uppercase and titlecase code points to their lowercase equivalents when strings conforming to the FreeClass, or a subclass thereof, are used in passwords or passphrases; instead, it is RECOMMENDED to preserve the case of all code points contained in such strings.</t>
        </section>
        <section title='Normalization' anchor='classes-free-normalization'>
          <t>The normalization form MUST be specified by each application protocol that uses or subclasses the FreeClass.</t>
          <t>However, in accordance with <xref target='RFC5198'/>, normalization form C (NFC) is RECOMMENDED.</t>
        </section>
      </section>
    </section>

    <section title="Use of PRECIS String Classes" anchor="use">
      <section title="Principles" anchor="use-principles">
        <t>This document defines the valid, disallowed, and unassigned rules.  Application protocols that use the PRECIS string classes MUST define the directionality, casemapping, and normalization rules.  Such definitions MUST at a minimum specify the following:</t>
        <t>
          <list style='hanging'>
            <t hangText='Directionality:'>Whether any instance of the class that contains a right-to-left code point is to be considered a right-to-left string, or whether some other rule is to be applied (e.g., the "Bidi Rule" from <xref target='RFC5893'/>).<vspace blankLines='1'/></t>
            <t hangText='Casemapping:'>Whether uppercase and titlecase code points are to be (a) preserved or (b) mapped to lowercase.<vspace blankLines='1'/></t>
            <t hangText='Normalization:'>Which Unicode normalization form (D, KD, C, or KC) is to be applied (see <xref target='UAX15'/> for background information); in accordance with <xref target='RFC5198'/>, NFC is RECOMMENDED.</t>
          </list>
        </t>
      </section>
      <section title="Subclassing" anchor="use-subclassing">
        <t>Application protocols are allowed to subclass the base string classes specified in this document.  As the word "subclass" implies, a subclass MUST NOT add as valid any code points or character categories that are disallowed by the base string class.  However, a subclass MAY do either of the following:</t>
        <t>
          <list style='numbers'>
            <t>Exclude specific code points that are included in the base string class.</t>
            <t>Exclude characters matching certain Unicode properties (e.g., math symbols) that are included in the base string class.</t>
          </list>
        </t>
      </section>
      <section title="Registration" anchor="use-registration">
        <t>Application protocols that use the PRECIS string classes MUST register with the IANA as described under <xref target='iana-usage'/>.  This is especially important for protocols that subclass the PRECIS string classes.</t>
      </section>
    </section>

    <section title="Code Point Properties">
      <t>In order to implement the string classes described above, this document does the following:</t>
      <t>
        <list style='numbers'>
          <t>Reviews and classifies the collections of code points in the Unicode character set by examining various code point properties.<vspace blankLines='1'/></t>
          <t>Defines an algorithm for determining a derived property value, which can vary depending on the string class being used by the relevant application protocol.</t>
         </list>
       </t>
      <t>This document is not intended to specify precisely how derived property values are to be applied in protocol strings.  That information should be defined in the protocol specification that uses or subclasses a base string class from this document.</t>
      <t>The value of the property is to be interpreted as follows.</t> 
      <t>
        <list style="hanging">
          <t hangText='PROTOCOL VALID'>Those code points that are allowed to be used in any PRECIS string class (NameClass and FreeClass).  Code points with this property value are permitted for general use in any string class.  The abbreviated term PVALID is used to refer to this value in the remainder of this document.<vspace blankLines='1'/></t>
          <t hangText='SPECIFIC CLASS PROTOCOL VALID'>Those code points that are allowed to be used in specific string classes. Code points with this property value are permitted for use in specific string classes.  In the remainder of this document, the abbreviated term *_PVAL is used, where * = (NAME | FREE), i.e., either FREE_PVAL or NAME_PVAL.<vspace blankLines='1'/></t>
          <t hangText='CONTEXTUAL RULE REQUIRED'>Some characteristics of the character, such as its being invisible in certain contexts or problematic in others, require that it not be used in labels unless specific other characters or properties are present.  The abbreviated term CONTEXT is used to refer to this value in the remainder of this document.  There are two subdivisions of CONTEXTUAL RULE REQUIRED, the first for Join_controls (called CONTEXTJ) and the second for other characters (called CONTEXTO).<vspace blankLines='1'/></t>
          <t hangText='DISALLOWED'>Those code points that must not be included in any string class.  Code points with this property value are not permitted in any string class.<vspace blankLines='1'/></t>
          <t hangText='SPECIFIC CLASS DISALLOWED'>Those code points that are not to be included in a specific string class.  Code points with this property value are not permitted in one of the string classes but might be permitted in others.  In the remainder of this document, the abbreviated term *_DIS is used, where * = (NAME | FREE), i.e., either FREE_DIS or NAME_DIS.<vspace blankLines='1'/></t>
          <t hangText='UNASSIGNED'>Those code points that are not designated (i.e. are unassigned) in the Unicode Standard.</t>
        </list>
      </t>
      <t>The mechanisms described here allow determination of the value of the property for future versions of Unicode (including characters added after Unicode 5.2 or 6.1 depending on the category, since some categories in this document are reused from IDNA2008 and therefore were defined at the time of Unicode 5.2).  Changes in Unicode properties that do not affect the outcome of this process do not affect this framework.  For example, a character can have its Unicode General_Category value <xref target='UNICODE'/> change from So to Sm, or from Lo to Ll, without affecting the algorithm results.  Moreover, even if such changes were to result, the <xref target="G">BackwardCompatible list</xref> can be adjusted to ensure the stability of the results.</t>
      <t>Some code points need to be allowed in exceptional circumstances, but should be excluded in all other cases; these rules are also described in other documents.  The most notable of these are the Join Control characters, U+200D ZERO WIDTH JOINER and U+200C ZERO WIDTH NON-JOINER.  Both of them have the derived property value CONTEXTJ.  A character with the derived property value CONTEXTJ or CONTEXTO (CONTEXTUAL RULE REQUIRED) is not to be used unless an appropriate rule has been established and the context of the character is consistent with that rule.  It is invalid to generate a string containing these characters unless such a contextual rule is found and satisfied.  PRECIS does not define its own contextual rules, but instead re-uses the contextual rules defined for IDNA2008; please see Appendix A of <xref target='RFC5892'/> for more information.</t>
    </section>

    <section anchor="categories" title="Category Definitions Used to Calculate Derived Property Value">
      <t>The derived property obtains its value based on a two-step procedure:</t>
      <t>
        <list style='numbers'>
          <t>Characters are placed in one or more character categories either (1) based on core properties defined by the Unicode Standard or (2) by treating the code point as an exception and addressing the code point as its code point value.  These categories are not mutually exclusive.<vspace blankLines='1'/></t>
          <t>Set operations are used with these categories to determine the values for a property that is specific to a given string class. These operations are specified under <xref target="PropertyCalculation" />.</t>
        </list>
      </t>
      <t>(NOTE: Unicode property names and property value names might have short abbreviations, such as "gc" for the General_Category property and "Ll" for the Lowercase_Letter property value of the gc property.)</t>
      <t>In the following specification of character categories, the operation that returns the value of a particular Unicode character property for a code point is designated by using the formal name of that property (from the Unicode <eref target="http://unicode.org/Public/UNIDATA/PropertyAliases.txt">PropertyAliases.txt</eref>) followed by '(cp)' for "code point".  For example, the value of the General_Category property for a code point is indicated by General_Category(cp).</t>
      <t>The first ten categories (A-J) shown below were previously defined for IDNA2008 and are copied directly from <xref target='RFC5892'/>.  Some of these categories are reused in PRECIS and some of them are not; however, the lettering of categories is retained to prevent overlap and to ease implementation of both IDNA2008 and PRECIS in a single software application.  The next seven categories (K-Q) are specific to PRECIS.</t>
        <section anchor="A" title="LetterDigits (A)">
          <t>NOTE: This category is defined in <xref target='RFC5892'/> and copied here for use in PRECIS.</t>
          <figure>
            <artwork>
A: General_Category(cp) is in {Ll, Lu, Lo, Nd, Lm, Mn, Mc}
            </artwork>
          </figure>
          <t>These rules identify characters commonly used in mnemonics and often informally described as "language characters".</t>
          <t>For more information, see section 4.5 of <xref target='UNICODE'/>.</t>
          <t>The categories used in this rule are:
            <list style="symbols">
              <t>Ll - Lowercase_Letter</t>
              <t>Lu - Uppercase_Letter</t>
              <t>Lo - Other_Letter</t>
              <t>Nd - Decimal_Number</t>
              <t>Lm - Modifier_Letter</t>
              <t>Mn - Nonspacing_Mark</t>
              <t>Mc - Spacing_Mark</t>
            </list>
          </t>
        </section>
        <section anchor="B" title="Unstable (B)">
          <t>NOTE: This category is defined in <xref target='RFC5892'/> but not used in PRECIS.</t>
          <!--
          <figure>
            <artwork>
B: toNFKC(toCaseFold(toNFKC(cp))) != cp
            </artwork>
          </figure>
          <t>This category is used to group the characters that are not stable under normalization form K (NFKC) and case folding.  In general, these code points are not suitable for use for IDN.
          <t>The toCaseFold() operation is defined in Section 3.13 of <xref target='UNICODE'/>.</t>
          <t>The toNFKC() operation returns the code point in normalization form KC.  For more information, see Section 5 of <xref target='UAX15'/>.</t>
          -->
        </section>
        <section anchor="C" title="IgnorableProperties (C)">
          <t>NOTE: This category is defined in <xref target='RFC5892'/> but not used in PRECIS.  See the "PrecisIgnorableProperties (M)" category below for a more inclusive category used in PRECIS identifiers.</t>
          <!--
          <figure>
            <artwork>
C: Default_Ignorable_Code_Point(cp) = True or
   White_Space(cp) = True or
   Noncharacter_Code_Point(cp) = True
            </artwork>
          </figure>
          <t>This category is used to group code points that are not recommended for use in identifiers.</t>
          <t>The definition for Default_Ignorable_Code_Point can be found in the Unicode <eref target="http://unicode.org/Public/UNIDATA/DerivedCoreProperties.txt">DerivedCoreProperties.txt</eref> file, and is at the time of Unicode 5.2:</t>
          <figure>
            <artwork>
  Other_Default_Ignorable_Code_Point 
+ Cf (Format characters)
+ Variation_Selector 
- White_Space 
- FFF9..FFFB (Annotation Characters) 
- 0600..0603, 06DD, 070F (exceptional Cf characters 
                          that should be visible)
            </artwork>
          </figure>
          -->
        </section>
        <section anchor="D" title="IgnorableBlocks (D)">
          <t>NOTE: This category is defined in <xref target='RFC5892'/> but not used in PRECIS.</t>
          <!--
          <figure>
            <artwork>
D: Block(cp) is in {Combining Diacritical Marks for Symbols,
                    Musical Symbols, Ancient Greek Musical 
                    Notation}
            </artwork>
          </figure>
          <t>This category is used to identifying code points that are not useful in mnemonics but may be useful for some string classes.</t>
          <t>The definition of blocks can be found in <eref target="http://unicode.org/Public/UNIDATA/Blocks.txt">Blocks.txt</eref>.</t>
          -->
        </section>
        <section anchor="E" title="LDH (E)">
          <t>NOTE: This category is defined in <xref target='RFC5892'/> but not used in PRECIS.  See the "ASCII7 (K)" category below for a more inclusive category used in PRECIS identifiers.</t>
          <!--
          <figure>
            <artwork>
E: cp is in {002D, 0030..0039, 0061..007A}
            </artwork>
          </figure>
          <t>This category is used in the second step to preserve the traditional "hostname" (LDH) characters ('-', 0-9 and a-z). In general, these code points are suitable for use for identifiers.</t>
          -->
        </section>
        <section anchor="F" title="Exceptions (F)">
          <t>NOTE: This category is defined in <xref target='RFC5892'/> and might be used in a future version of this specification.</t>
          <figure>
            <artwork>
F: cp is in {00B7, 00DF, 0375, 03C2, 05F3, 05F4, 0640, 0660,
             0661, 0662, 0663, 0664, 0665, 0666, 0667, 0668,
             0669, 06F0, 06F1, 06F2, 06F3, 06F4, 06F5, 06F6,
             06F7, 06F8, 06F9, 06FD, 06FE, 07FA, 0F0B, 3007,
             302E, 302F, 3031, 3032, 3033, 3034, 3035, 303B,
             30FB}
            </artwork>
          </figure>
          <t>This category explicitly lists code points for which the category cannot be assigned using only the core property values that exist in the Unicode standard.  The values are according to the table below:</t>
          <figure>
            <artwork>
PVALID -- Would otherwise have been DISALLOWED

00DF; PVALID     # LATIN SMALL LETTER SHARP S
03C2; PVALID     # GREEK SMALL LETTER FINAL SIGMA
06FD; PVALID     # ARABIC SIGN SINDHI AMPERSAND
06FE; PVALID     # ARABIC SIGN SINDHI POSTPOSITION MEN
0F0B; PVALID     # TIBETAN MARK INTERSYLLABIC TSHEG
3007; PVALID     # IDEOGRAPHIC NUMBER ZERO

CONTEXTO -- Would otherwise have been DISALLOWED

00B7; CONTEXTO   # MIDDLE DOT
0375; CONTEXTO   # GREEK LOWER NUMERAL SIGN (KERAIA)
05F3; CONTEXTO   # HEBREW PUNCTUATION GERESH
05F4; CONTEXTO   # HEBREW PUNCTUATION GERSHAYIM
30FB; CONTEXTO   # KATAKANA MIDDLE DOT

CONTEXTO -- Would otherwise have been PVALID

0660; CONTEXTO   # ARABIC-INDIC DIGIT ZERO
0661; CONTEXTO   # ARABIC-INDIC DIGIT ONE
0662; CONTEXTO   # ARABIC-INDIC DIGIT TWO
0663; CONTEXTO   # ARABIC-INDIC DIGIT THREE
0664; CONTEXTO   # ARABIC-INDIC DIGIT FOUR
0665; CONTEXTO   # ARABIC-INDIC DIGIT FIVE
0666; CONTEXTO   # ARABIC-INDIC DIGIT SIX
0667; CONTEXTO   # ARABIC-INDIC DIGIT SEVEN
0668; CONTEXTO   # ARABIC-INDIC DIGIT EIGHT
0669; CONTEXTO   # ARABIC-INDIC DIGIT NINE
06F0; CONTEXTO   # EXTENDED ARABIC-INDIC DIGIT ZERO
06F1; CONTEXTO   # EXTENDED ARABIC-INDIC DIGIT ONE
06F2; CONTEXTO   # EXTENDED ARABIC-INDIC DIGIT TWO
06F3; CONTEXTO   # EXTENDED ARABIC-INDIC DIGIT THREE
06F4; CONTEXTO   # EXTENDED ARABIC-INDIC DIGIT FOUR
06F5; CONTEXTO   # EXTENDED ARABIC-INDIC DIGIT FIVE
06F6; CONTEXTO   # EXTENDED ARABIC-INDIC DIGIT SIX
06F7; CONTEXTO   # EXTENDED ARABIC-INDIC DIGIT SEVEN
06F8; CONTEXTO   # EXTENDED ARABIC-INDIC DIGIT EIGHT
06F9; CONTEXTO   # EXTENDED ARABIC-INDIC DIGIT NINE

DISALLOWED -- Would otherwise have been PVALID

0640; DISALLOWED # ARABIC TATWEEL
07FA; DISALLOWED # NKO LAJANYALAN
302E; DISALLOWED # HANGUL SINGLE DOT TONE MARK
302F; DISALLOWED # HANGUL DOUBLE DOT TONE MARK
3031; DISALLOWED # VERTICAL KANA REPEAT MARK
3032; DISALLOWED # VERTICAL KANA REPEAT WITH VOICED SOUND MARK
3033; DISALLOWED # VERTICAL KANA REPEAT MARK UPPER HALF
3034; DISALLOWED # VERTICAL KANA REPEAT WITH VOICED SOUND MARK 
                   UPPER HA
3035; DISALLOWED # VERTICAL KANA REPEAT MARK LOWER HALF
303B; DISALLOWED # VERTICAL IDEOGRAPHIC ITERATION MARK
            </artwork>
          </figure>
        </section>
        <section anchor="G" title="BackwardCompatible (G)">
          <t>NOTE: This category is defined in <xref target='RFC5892'/> and copied here for use in PRECIS.  Because of how the PRECIS string classes are defined, only changes that would result in code points being added to or removed from the LetterDigits ("A") category would result in backward-incompatible modifications to code point assignments.  Therefore, management of this category is handled via the processes specified in <xref target='RFC5892'/>.</t>
          <figure>
            <artwork>
G: cp is in {}
            </artwork>
          </figure>
          <t>This category includes the code points for which property values in versions of Unicode after 5.2 have changed in such a way that the derived property value would no longer be PVALID or DISALLOWED.  If changes are made to future versions of Unicode so that code points might change property value from PVALID or DISALLOWED, then this table can be updated and keep special exception values so that the property values for code points stay stable.</t>
        </section>
        <section anchor="H" title="JoinControl (H)">
          <t>NOTE: This category is defined in <xref target='RFC5892'/> and copied here for use in PRECIS.</t>
          <figure>
            <artwork>
H: Join_Control(cp) = True
            </artwork>
          </figure>
          <t>This category consists of Join Control characters (i.e., they are not in <xref target="A">LetterDigits</xref>) but are still required in strings under some circumstances.</t>
        </section>
        <section anchor="I" title="OldHangulJamo (I)">
          <t>NOTE: This category is defined in <xref target='RFC5892'/> and copied here for use in PRECIS.</t>
          <figure>
            <artwork>
I: Hangul_Syllable_Type(cp) is in {L, V, T}
            </artwork>
          </figure>
          <t>This category consists of all conjoining Hangul Jamo (Leading Jamo, Vowel Jamo, and Trailing Jamo).</t>
          <t>Elimination of conjoining Hangul Jamos from the set of PVALID characters results in restricting the set of Korean PVALID characters just to preformed, modern Hangul syllable characters.  Old Hangul syllables, which must be spelled with sequences of conjoining Hangul Jamos, are not PVALID for string classes.</t>
        </section>
        <section anchor="J" title="Unassigned (J)">
          <t>NOTE: This category is defined in <xref target='RFC5892'/> and copied here for use in PRECIS.</t>
          <figure>
            <artwork>
J: General_Category(cp) is in {Cn} and
   Noncharacter_Code_Point(cp) = False
            </artwork>
          </figure>
          <t>This category consists of code points in the Unicode character set that are not (yet) assigned. It should be noted that Unicode distinguishes between 'unassigned code points' and 'unassigned characters'. The unassigned code points are all but (Cn - Noncharacters), while the unassigned *characters* are all but (Cn + Cs).</t>
        </section>
        <section anchor="K" title="ASCII7 (K)">
          <t>This PRECIS-specific category exempts most characters in the ASCII-7 range from other rules that might be applied during PRECIS processing, on the assumption that these code points are in such wide use that disallowing them would be counter-productive.</t>
          <figure>
            <artwork>
K: cp is in {0021..007E}
            </artwork>
          </figure>
        </section>
        <section anchor="L" title="Controls (L)">
          <figure>
            <artwork>
L: Control(cp) = True
            </artwork>
          </figure>
        </section>
        <section anchor="M" title="PrecisIgnorableProperties (M)">
          <t>This PRECIS-specific category is used to group code points that are not recommended for use in PRECIS string classes.</t>
          <figure>
            <artwork>
M: Default_Ignorable_Code_Point(cp) = True or
   Noncharacter_Code_Point(cp) = True
            </artwork>
          </figure>
          <t>The definition for Default_Ignorable_Code_Point can be found in the <eref target="http://unicode.org/Public/UNIDATA/DerivedCoreProperties.txt">DerivedCoreProperties.txt</eref> file, and at the time of Unicode 6.1 is as follows:</t>
          <figure>
            <artwork>
  Other_Default_Ignorable_Code_Point 
+ Cf (Format characters)
+ Variation_Selector 
- White_Space 
- FFF9..FFFB (Annotation Characters) 
- 0600..0604, 06DD, 070F, 110BD (exceptional Cf characters 
                                 that should be visible)
            </artwork>
          </figure>
        </section>
        <section anchor="N" title="Spaces (N)">
          <t>This PRECIS-specific category is used to group code points that are space characters.</t>
          <figure>
            <artwork>
N: General_Category(cp) is in {Zs}
            </artwork>
          </figure>
        </section>
        <section anchor="O" title="Symbols (O)">
          <t>This PRECIS-specific category is used to group code points that are symbols.</t>
          <figure>
            <artwork>
O: General_Category(cp) is in {Sm, Sc, Sk, So}
            </artwork>
          </figure>
        </section>
        <section anchor="P" title="Punctuation (P)">
          <t>This PRECIS-specific category is used to group code points that are punctuation characters.</t>
          <figure>
            <artwork>
P: General_Category(cp) is in {Pc, Pd, Ps, Pe, Pi, Pf, Po}
            </artwork>
          </figure>
        </section>
        <section anchor="Q" title="HasCompat (Q)">
          <t>This PRECIS-specific category is used to group code points that have compatibility equivalents as explained in Chapter 2 and Chapter 3 of <xref target='UNICODE'/>.</t>
          <figure>
            <artwork>
Q: toNFKC(cp) != cp
            </artwork>
          </figure>
          <t>The toNFKC() operation returns the code point in normalization form KC.  For more information, see Section 5 of <xref target='UAX15'/>.</t>
        </section>
      </section>
      <section anchor="PropertyCalculation" title="Calculation of the Derived Property">
        <t>Possible values of the derived property are:</t>
        <t>
          <list style="symbols">
            <t>PVALID</t>
            <t>NAME_PVAL</t>
            <t>FREE_PVAL</t>
            <t>CONTEXTJ</t>
            <t>CONTEXTO</t>
            <t>DISALLOWED</t>
            <t>NAME_DIS</t>
            <t>FREE_DIS</t>
            <t>UNASSIGNED</t>
          </list>
        </t>
        <t>NOTE: In some instances, the value of the derived property calculated depends on the string class (e.g., if an identifier used in an application protocol is defined as using or subclassing the PRECIS NameClass, then a space character would be assigned to NAME_DIS).</t>
        <t>The algorithm to calculate the value of the derived property is as follows. (NOTE: Use of the name of a rule (such as "Exception") implies the set of code points that the rule defines, whereas the same name as a function call (such as "Exception(cp)") implies the value that the code point has in the Exceptions table.)</t>
        <figure>
          <artwork>
If .cp. .in. Exceptions Then Exceptions(cp);
Else If .cp. .in. BackwardCompatible Then BackwardCompatible(cp);
Else If .cp. .in. Unassigned Then UNASSIGNED;
Else If .cp. .in. ASCII7 Then PVALID;
Else If .cp. .in. JoinControl Then CONTEXTJ;
Else If .cp. .in. PrecisIgnorableProperties Then DISALLOWED;
Else If .cp. .in. Controls Then DISALLOWED;
Else If .cp. .in. OldHangulJamo Then DISALLOWED;
Else If .cp. .in. LetterDigits Then PVALID;
Else If .cp. .in. Spaces Then NAME_DIS 
                  or FREE_PVAL;
Else If .cp. .in. Symbols Then NAME_DIS 
                  or FREE_PVAL;
Else If .cp. .in. Punctuation Then NAME_DIS 
                  or FREE_PVAL;
Else If .cp. .in. HasCompat Then NAME_DIS 
                  or FREE_PVAL;
Else DISALLOWED;
            </artwork>
          </figure>
      </section>

    <section anchor="codepointexplain" title="Code Points">
      <t>The Categories and Rules defined in <xref target="categories" /> and <xref target="PropertyCalculation" /> apply to all Unicode code points. The table in <xref target="codepoints" /> shows, for illustrative purposes, the consequences of the categories and classification rules, and the resulting property values.</t>
      <t>The list of code points that can be found in <xref target="codepoints" /> is non-normative.  Instead, the rules defined by <xref target="categories"/> and <xref target="PropertyCalculation"/> are normative, and any tables are derived from the rules.</t>
    </section>

    <section title="IANA Considerations" anchor='iana'>

      <section anchor="iana-derived" title="PRECIS Derived Property Value Registry">
        <t>IANA is requested to create a PRECIS-specific registry with the Derived Properties for the versions of Unicode that are released after (and including) version 6.1.  The derived property value is to be calculated in cooperation with a designated expert <xref target='RFC5226'/> according to the specifications in <xref target="categories" /> and <xref target="PropertyCalculation" />, and not by copying the non-normative table found in <xref target="codepoints" />.</t>
        <t>If during this process (creation of the table of derived property values) followed by a designated expert review, either backward-incompatible changes to the table of derived properties are discovered, or otherwise problems arise during the creation of the table, that is to be flagged to the IESG. Changes to the rules (as specified in <xref target="categories" /> and <xref target="PropertyCalculation" />) require IETF Review, as described in <xref target='RFC5226'/>.</t>
      </section>

      <section anchor="iana-usage" title="PRECIS Usage Registry">
        <t>IANA is requested to create a registry of application protocols that use the base string classes.  The registry will include one entry for each use (e.g., if a protocol uses both the NameClass and the FreeClass then the specification for that protocol would submit two registrations).  In accordance with <xref target='RFC5226'/>, the registration policy is "First Come First Served".</t>
        <t>The registration template is as follows:</t>
        <t>
          <list style='hanging'>
            <t hangText='Application Protocol:'>[the application protocol that is using or subclassing the PRECIS string class]</t>
            <t hangText='Base Class:'>[which base class is being used]</t>
            <t hangText='Subclassing:'>[whether the base class is being subclassed and, if so, where documentation of the subclassing can be found]</t>
            <t hangText='Directionality:'>[the behavioral rule for handling of right-to-left code points]</t>
            <t hangText='Casemapping:'>[the behavioral rule for handling of case]</t>
            <t hangText='Normalization:'>[which Unicode normalization form is applied]</t>
            <t hangText='Specification:'>[a pointer to relevant documentation, such as an RFC or Internet-Draft]</t>
          </list>
        </t>
      </section>

    </section>

    <section title="Security Considerations" anchor='security'>
      <section title="General Issues" anchor='security-gen'>
        <t>The security of applications that use this framework can depend in part on the proper preparation and comparison of internationalized strings.  For example, such strings can be used to make authentication and authorization decisions, and the security of an application could be compromised if an entity providing a given string is connected to the wrong account or online resource based on different interpretations of the string.</t>
        <t>Specifications of application protocols that use this framework are encouraged to describe how internationalized strings are used in the protocol, including the security implications of any false positives and false negatives that might result from various comparison operations.  For some helpful guidelines, refer to <xref target='I-D.iab-identifier-comparison'/>, <xref target='RFC5890'/>, <xref target='UTR36'/>, and <xref target='UTR39'/>.</t>
      </section>
      <section title="Local Character Set Issues" anchor='security-charset'>
        <t>When systems use local character sets other than ASCII and Unicode, these specifications leave the problem of converting between the local character set and Unicode up to the application or local system.  If different applications (or different versions of one application) implement different rules for conversions among coded character sets, they could interpret the same name differently and contact different application servers or other network entities.  This problem is not solved by security protocols, such as Transport Layer Security (TLS) <xref target='RFC5246'/> and the Simple Authentication and Security Layer (SASL) <xref target='RFC4422'/>, that do not take local character sets into account.</t>
      </section>
      <section title="Visually Similar Characters" anchor='security-confusables'>
        <t>Some characters are visually similar and thus can cause confusion among humans.  Such characters are often called "confusable characters" or "confusables".</t>
        <t>The problem of confusable characters is not necessarily caused by the use of Unicode code points outside the US-ASCII range.  For example, in some presentations and to some individuals the string "ju1iet" (spelled with the Arabic numeral one as the third character) might appear to be the same as "juliet" (spelled with the lowercase version of the letter "L"), especially on casual visual inspection.  This phenomenon is sometimes called "typejacking".</t>
        <t>However, the problem is made more serious by introducing the full range of Unicode code points into protocol strings.  For example, the characters U+13DA U+13A2 U+13B5 U+13AC U+13A2 U+13AC U+13D2 from the Cherokee block look similar to the US-ASCII characters "STPETER" as they might look when presented in a "creative" font.</t>
        <t>In some examples of confusable characters, it is unlikely that the average human could tell the difference between the real string and the fake string.  (Indeed, there is no programmatic way to distinguish with full certainty which is the fake string and which is the real string; in some contexts, the string formed of Cherokee characters might be the real string and the string formed of US-ASCII characters might be the fake string.)  Because PRECIS-compliant strings can contain almost any properly encoded Unicode code point, it can be relatively easy to fake or mimic some strings in systems that use the PRECIS framework.  The fact that some strings are easily confused introduces security vulnerabilities of the kind that have also plagued the World Wide Web, specifically the phenomenon known as phishing.</t>
        <t>Despite the fact that some specific suggestions about identification and handling of confusable characters appear in the Unicode Security Considerations <xref target='UTR36'/>, it is also true (as noted in <xref target='RFC5890'/>) that "there are no comprehensive technical solutions to the problems of confusable characters".  Because it is impossible to map visually similar characters without a great deal of context (such as knowing the fonts used), the PRECIS framework does nothing to map similar-looking characters together, nor does it prohibit some characters because they look like others.</t>
        <t>However, specifications for application protocols that use this framework MUST describe how confusable characters can be used to compromise the security of systems that use the protocol in question, and any protocol-specific suggestions for overcoming those threats.  In particular, software implementations and service deployments that use PRECIS-based technologies are strongly encouraged to define and implement consistent policies regarding the registration, storage, and presentation of visually similar characters.  The following recommendations are appropriate:</t>
        <t>
          <list style='numbers'>
            <t>An application service SHOULD define a policy that specifies the scripts or blocks of characters that the service will allow to be registered (e.g., in an account name) or stored (e.g., in a file name).  Such a policy SHOULD be informed by the languages and scripts that are used to write registered account names; in particular, to reduce confusion, the service SHOULD forbid registration or storage of stings that contain characters from more than one script and to restrict registrations to characters drawn from a very small number of scripts (e.g., scripts that are well-understood by the administrators of the service, to improve manageability).<vspace blankLines='1'/></t>
            <t>User-oriented application software SHOULD define a policy that specifies how internationalized strings will be presented to a human user.  Because every human user of such software has a preferred language or a small set of preferred languages, the software SHOULD gather that information either explicitly from the user or implicitly via the operating system of the user's device.  Furthermore, because most languages are typically represented by a single script or a small set of scripts, and because and most scripts are typically contained in one or more blocks of characters, the software SHOULD warn the user when presenting a string that mixes characters from more than one script or block, or that uses characters outside the normal range of the user's preferred language(s).  (Such a recommendation is not intended to discourage communication across different communities of language users; instead, it recognizes the existence of such communities and encourages due caution when presenting unfamiliar scripts or characters to human users.)</t>
          </list>
        </t>
      </section>
      <section title="Security of Passwords and Passphrases" anchor='security-secrets'>
        <t>One goal of passwords and passphrases is to maximize the amount of entropy, for example by allowing a wide range of code points and by ensuring that secrets are not prepared in such a way that code points are compared aggressively.  Therefore, it is NOT RECOMMENDED for application protocols to subclass the FreeClass for use in passwords and passphrases in a way that removes entire categories (e.g., by disallowing symbols or punctuation).  Furthermore, it is NOT RECOMMENDED for application protocols to map uppercase and titlecase code points to their lowercase equivalents in such strings; instead, it is RECOMMENDED to preserve the case of all code points contained in such strings.</t>
        <t>That said, software implementers need to be aware that there exist tradeoffs between entropy and usability.  For example, allowing a user to establish a password containing "uncommon" code points might make it difficult for the user to access an application when using an unfamiliar or constrained input device.</t>
        <t>Some application protocols use passwords and passphrases directly, whereas others reuse technologies that themselves process passwords (one example is the Simple Authentication and Security Layer <xref target='RFC4422'/>).  Moreover, passwords are often carried by a sequence of protocols with backends authentication systems or data storage systems such as RADIUS <xref target='RFC2865'/> and LDAP <xref target='RFC4510'/>.  Developers of application protocols are encouraged to look into reusing these profiles instead of defining new ones, so that end-user expectations about passwords are consistent no matter which application protocol is used.</t>
      </section>
    </section>

    <section title="Interoperability Considerations" anchor='interop'>
      <t>Although strings that are consumed in PRECIS-based application protocols are often encoded using UTF-8 <xref target='RFC3629'/>, the exact encoding is a matter for the using protocol, not the PRECIS framework.</t>
      <t>It is known that some existing systems are unable to support the full Unicode character set, or even any characters outside the US-ASCII range.  If two (or more) applications need to interoperate when exchanging data (e.g., for the purpose of authenticating a username or password), they will naturally need have in common at least one coded character set (as defined by <xref target='RFC6365'/>).  Establishing such a baseline is a matter for the using protocol, not the PRECIS framework.</t>
    </section>

  </middle>

  <back>
    <references title="Normative References">

<reference anchor="RFC2119">
<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass.  Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date month='March' year='1997' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL
      NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and
      &quot;OPTIONAL&quot; in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>
<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='14486' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5661' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>

<reference anchor='RFC5198'>
<front>
<title>Unicode Format for Network Interchange</title>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<author initials='M.' surname='Padlipsky' fullname='M. Padlipsky'>
<organization /></author>
<date year='2008' month='March' />
<abstract>
<t>The Internet today is in need of a standardized form for the transmission of internationalized "text" information, paralleling the specifications for the use of ASCII that date from the early days of the ARPANET.  This document specifies that format, using UTF-8 with normalization and specific line-ending sequences. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5198' />
<format type='TXT' octets='45708' target='http://www.rfc-editor.org/rfc/rfc5198.txt' />
</reference>

<reference anchor="UNICODE" target="http://www.unicode.org/versions/Unicode6.0.0/">
  <front>
    <title>The Unicode Standard, Version 6.0</title>
    <author>
      <organization>The Unicode Consortium</organization>
    </author>
    <date year="2010" />
  </front>
</reference>

    </references>
    <references title="Informative References">

<reference anchor='I-D.iab-identifier-comparison'>
<front>
<title>Issues in Identifier Comparison for Security Purposes</title>
<author initials='D' surname='Thaler' fullname='Dave Thaler'>
    <organization />
</author>
<date month='July' day='2' year='2011' />
<abstract><t>Identifiers such as hostnames, URIs/IRIs, and email addresses are often used in security contexts to identify security principals and resources.  In such contexts, an identifier supplied via some protocol is often compared against some policy to make security decisions such as whether the principal may access the resource, what level of authentication or encryption is required, etc.  If the parties involved in a security decision use different algorithms to compare identifiers, then failure scenarios ranging from denial of service to elevation of privilege can result.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-iab-identifier-comparison-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-iab-identifier-comparison-00.txt' />
</reference>

<reference anchor='I-D.ietf-precis-problem-statement'>
<front>
<title>Stringprep Revision Problem Statement</title>
<author initials='A' surname='Sullivan' fullname='Andrew Sullivan'>
    <organization />
</author>
<author initials='M' surname='Blanchet' fullname='Marc Blanchet'>
    <organization />
</author>
<date month='January' day='13' year='2012' />
<abstract><t>Using Unicode codepoints in protocol strings that expect comparison with other strings requires preparation of the string that contains the Unicode codepoints.  Internationalizing Domain Names in Applications (IDNA2003) defined and used Stringprep and Nameprep. Other protocols subsequently defined Stringprep profiles.  A new approach different from Stringprep and Nameprep is used for a revision of IDNA2003 (called IDNA2008).  Other Stringprep profiles need to be similarly updated or a replacement of Stringprep needs to be designed.  This document outlines the issues to be faced by those designing a Stringprep replacement.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-precis-problem-statement-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-precis-problem-statement-04.txt' />
</reference>

<reference anchor='I-D.ietf-xmpp-6122bis'>
<front>
<title>Extensible Messaging and Presence Protocol (XMPP): Address Format</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='November' day='17' year='2011' />
<abstract><t>This document defines the address format for the Extensible Messaging and Presence Protocol (XMPP), including support for code points outside the US-ASCII range.  This document obsoletes RFC 6122.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-xmpp-6122bis-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-xmpp-6122bis-00.txt' />
</reference>

<reference anchor='I-D.melnikov-precis-saslprepbis'>
<front>
<title>Username and Password Preparation Algorithms</title>
<author initials='A' surname='Melnikov' fullname='Alexey Melnikov'>
    <organization />
</author>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='March' day='5' year='2012' />
<abstract><t>This document describes how to prepare Unicode strings representing user names and passwords, primarily for purposes of comparison.  This profile is intended to be used by Simple Authentication and Security Layer (SASL) mechanisms (such as PLAIN and SCRAM-SHA-1), as well as other protocols that exchange simple user names or passwords.  This document obsoletes RFC 4013.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-melnikov-precis-saslprepbis-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-melnikov-precis-saslprepbis-00.txt' />
</reference>

<reference anchor='I-D.saintandre-precis-nickname'>
<front>
<title>Preparation and Comparison of Nicknames</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='March' day='5' year='2012' />
<abstract><t>This document describes how to prepare and compare Unicode strings representing nicknames, primarily as used within textual chatrooms. This profile is intended to be used by chatroom technologies based on both the Extensible Messaging and Presence Protocol (XMPP) and the Message Session Relay Protocol (MSRP).</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-saintandre-precis-nickname-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-saintandre-precis-nickname-00.txt' />
</reference>

<reference anchor='RFC2865'>
<front>
<title>Remote Authentication Dial In User Service (RADIUS)</title>
<author initials='C.' surname='Rigney' fullname='C. Rigney'>
<organization /></author>
<author initials='S.' surname='Willens' fullname='S. Willens'>
<organization /></author>
<author initials='A.' surname='Rubens' fullname='A. Rubens'>
<organization /></author>
<author initials='W.' surname='Simpson' fullname='W. Simpson'>
<organization /></author>
<date year='2000' month='June' />
<abstract>
<t>This document describes a protocol for carrying authentication, authorization, and configuration information between a Network Access Server which desires to authenticate its links and a shared Authentication Server. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='2865' />
<format type='TXT' octets='146456' target='http://www.rfc-editor.org/rfc/rfc2865.txt' />
</reference>

<reference anchor='RFC3454'>
<front>
<title>Preparation of Internationalized Strings ("stringprep")</title>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<author initials='M.' surname='Blanchet' fullname='M. Blanchet'>
<organization /></author>
<date year='2002' month='December' />
<abstract>
<t>This document describes a framework for preparing Unicode text strings in order to increase the likelihood that string input and string comparison work in ways that make sense for typical users throughout the world.  The stringprep protocol is useful for protocol identifier values, company and personal names, internationalized domain names, and other text strings.  This document does not specify how protocols should prepare text strings.  Protocols must create profiles of stringprep in order to fully specify the processing options. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='3454' />
<format type='TXT' octets='138684' target='http://www.rfc-editor.org/rfc/rfc3454.txt' />
</reference>

<reference anchor='RFC3490'>
<front>
<title>Internationalizing Domain Names in Applications (IDNA)</title>
<author initials='P.' surname='Faltstrom' fullname='P. Faltstrom'>
<organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<author initials='A.' surname='Costello' fullname='A. Costello'>
<organization /></author>
<date year='2003' month='March' />
<abstract>
<t>Until now, there has been no standard method for domain names to use characters outside the ASCII repertoire.  This document defines internationalized domain names (IDNs) and a mechanism called Internationalizing Domain Names in Applications (IDNA) for handling them in a standard fashion.  IDNs use characters drawn from a large repertoire (Unicode), but IDNA allows the non-ASCII characters to be represented using only the ASCII characters already allowed in so-called host names today.  This backward-compatible representation is required in existing protocols like DNS, so that IDNs can be introduced with no changes to the existing infrastructure.  IDNA is only meant for processing domain names, not free text. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='3490' />
<format type='TXT' octets='51943' target='http://www.rfc-editor.org/rfc/rfc3490.txt' />
</reference>

<reference anchor='RFC3491'>
<front>
<title>Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)</title>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<author initials='M.' surname='Blanchet' fullname='M. Blanchet'>
<organization /></author>
<date year='2003' month='March' />
<abstract>
<t>This document describes how to prepare internationalized domain name (IDN) labels in order to increase the likelihood that name input and name comparison work in ways that make sense for typical users throughout the world.  This profile of the stringprep protocol is used as part of a suite of on-the-wire protocols for internationalizing the Domain Name System (DNS). [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='3491' />
<format type='TXT' octets='10316' target='http://www.rfc-editor.org/rfc/rfc3491.txt' />
</reference>

<reference anchor='RFC3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'>
<organization /></author>
<date year='2003' month='November' />
<abstract>
<t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract></front>
<seriesInfo name='STD' value='63' />
<seriesInfo name='RFC' value='3629' />
<format type='TXT' octets='33856' target='http://www.rfc-editor.org/rfc/rfc3629.txt' />
</reference>

<reference anchor='RFC4422'>
<front>
<title>Simple Authentication and Security Layer (SASL)</title>
<author initials='A.' surname='Melnikov' fullname='A. Melnikov'>
<organization /></author>
<author initials='K.' surname='Zeilenga' fullname='K. Zeilenga'>
<organization /></author>
<date year='2006' month='June' />
<abstract>
<t>The Simple Authentication and Security Layer (SASL) is a framework for providing authentication and data security services in connection-oriented protocols via replaceable mechanisms. It provides a structured interface between protocols and mechanisms. The resulting framework allows new protocols to reuse existing mechanisms and allows old protocols to make use of new mechanisms. The framework also provides a protocol for securing subsequent protocol exchanges within a data security layer.&lt;/t>&lt;t> This document describes how a SASL mechanism is structured, describes how protocols include support for SASL, and defines the protocol for carrying a data security layer over a connection. In addition, this document defines one SASL mechanism, the EXTERNAL mechanism.&lt;/t>&lt;t> This document obsoletes RFC 2222. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='4422' />
<format type='TXT' octets='73206' target='http://www.rfc-editor.org/rfc/rfc4422.txt' />
</reference>

<reference anchor='RFC4510'>
<front>
<title>Lightweight Directory Access Protocol (LDAP): Technical Specification Road Map</title>
<author initials='K.' surname='Zeilenga' fullname='K. Zeilenga'>
<organization /></author>
<date year='2006' month='June' />
<abstract>
<t>The Lightweight Directory Access Protocol (LDAP) is an Internet protocol for accessing distributed directory services that act in accordance with X.500 data and service models.  This document provides a road map of the LDAP Technical Specification. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='4510' />
<format type='TXT' octets='12354' target='http://www.rfc-editor.org/rfc/rfc4510.txt' />
</reference>

<reference anchor='RFC4690'>
<front>
<title>Review and Recommendations for Internationalized Domain Names (IDNs)</title>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<author initials='P.' surname='Faltstrom' fullname='P. Faltstrom'>
<organization /></author>
<author initials='C.' surname='Karp' fullname='C. Karp'>
<organization /></author>
<author>
<organization>IAB</organization></author>
<date year='2006' month='September' />
<abstract>
<t>This note describes issues raised by the deployment and use of Internationalized Domain Names.  It describes problems both at the time of registration and for use of those names in the DNS.  It recommends that IETF should update the RFCs relating to IDNs and a framework to be followed in doing so, as well as summarizing and identifying some work that is required outside the IETF.  In particular, it proposes that some changes be investigated for the Internationalizing Domain Names in Applications (IDNA) standard and its supporting tables, based on experience gained since those standards were completed.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='4690' />
<format type='TXT' octets='100929' target='http://www.rfc-editor.org/rfc/rfc4690.txt' />
</reference>

<reference anchor='RFC5226'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'>
<organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
<organization /></author>
<date year='2008' month='May' />
<abstract>
<t>Many protocols make use of identifiers consisting of constants and other well-known values. Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec). To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority. For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).&lt;/t>&lt;t> In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made. If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role. This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.&lt;/t>&lt;t> This document obsoletes RFC 2434. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>
<seriesInfo name='BCP' value='26' />
<seriesInfo name='RFC' value='5226' />
<format type='TXT' octets='66160' target='http://www.rfc-editor.org/rfc/rfc5226.txt' />
</reference>

<reference anchor='RFC5246'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='http://www.rfc-editor.org/rfc/rfc5246.txt' />
</reference>

<reference anchor='RFC5890'>
<front>
<title>Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework</title>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<date year='2010' month='August' />
<abstract>
<t>This document is one of a collection that, together, describe the protocol and usage context for a revision of Internationalized Domain Names for Applications (IDNA), superseding the earlier version.  It describes the document collection and provides definitions and other material that are common to the set. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5890' />
<format type='TXT' octets='54245' target='http://www.rfc-editor.org/rfc/rfc5890.txt' />
</reference>

<reference anchor='RFC5891'>
<front>
<title>Internationalized Domain Names in Applications (IDNA): Protocol</title>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<date year='2010' month='August' />
<abstract>
<t>This document is the revised protocol definition for Internationalized Domain Names (IDNs).  The rationale for changes, the relationship to the older specification, and important terminology are provided in other documents.  This document specifies the protocol mechanism, called Internationalized Domain Names in Applications (IDNA), for registering and looking up IDNs in a way that does not require changes to the DNS itself.  IDNA is only meant for processing domain names, not free text. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5891' />
<format type='TXT' octets='38105' target='http://www.rfc-editor.org/rfc/rfc5891.txt' />
</reference>

<reference anchor='RFC5892'>
<front>
<title>The Unicode Code Points and Internationalized Domain Names for Applications (IDNA)</title>
<author initials='P.' surname='Faltstrom' fullname='P. Faltstrom'>
<organization /></author>
<date year='2010' month='August' />
<abstract>
<t>This document specifies rules for deciding whether a code point, considered in isolation or in context, is a candidate for inclusion in an Internationalized Domain Name (IDN).&lt;/t>&lt;t> It is part of the specification of Internationalizing Domain Names in Applications 2008 (IDNA2008). [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5892' />
<format type='TXT' octets='187370' target='http://www.rfc-editor.org/rfc/rfc5892.txt' />
</reference>

<reference anchor='RFC5893'>
<front>
<title>Right-to-Left Scripts for Internationalized Domain Names for Applications (IDNA)</title>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
<organization /></author>
<author initials='C.' surname='Karp' fullname='C. Karp'>
<organization /></author>
<date year='2010' month='August' />
<abstract>
<t>The use of right-to-left scripts in Internationalized Domain Names (IDNs) has presented several challenges.  This memo provides a new Bidi rule for Internationalized Domain Names for Applications (IDNA) labels, based on the encountered problems with some scripts and some shortcomings in the 2003 IDNA Bidi criterion. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5893' />
<format type='TXT' octets='38870' target='http://www.rfc-editor.org/rfc/rfc5893.txt' />
</reference>

<reference anchor='RFC5894'>
<front>
<title>Internationalized Domain Names for Applications (IDNA): Background, Explanation, and Rationale</title>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<date year='2010' month='August' />
<abstract>
<t>Several years have passed since the original protocol for Internationalized Domain Names (IDNs) was completed and deployed.  During that time, a number of issues have arisen, including the need to update the system to deal with newer versions of Unicode.  Some of these issues require tuning of the existing protocols and the tables on which they depend.  This document provides an overview of a revised system and provides explanatory material for its components.  This document is not an Internet Standards Track specification; it is published for informational purposes.</t></abstract></front>
<seriesInfo name='RFC' value='5894' />
<format type='TXT' octets='115174' target='http://www.rfc-editor.org/rfc/rfc5894.txt' />
</reference>

<reference anchor='RFC5895'>
<front>
<title>Mapping Characters for Internationalized Domain Names in Applications (IDNA) 2008</title>
<author initials='P.' surname='Resnick' fullname='P. Resnick'>
<organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<date year='2010' month='September' />
<abstract>
<t>In the original version of the Internationalized Domain Names in Applications (IDNA) protocol, any Unicode code points taken from user input were mapped into a set of Unicode code points that "made sense", and then encoded and passed to the domain name system (DNS).  The IDNA2008 protocol (described in RFCs 5890, 5891, 5892, and 5893) presumes that the input to the protocol comes from a set of "permitted" code points, which it then encodes and passes to the DNS, but does not specify what to do with the result of user input.  This document describes the actions that can be taken by an implementation between receiving user input and passing permitted code points to the new IDNA protocol.  This document is not an Internet Standards Track specification; it is published for informational purposes.</t></abstract></front>
<seriesInfo name='RFC' value='5895' />
<format type='TXT' octets='16556' target='http://www.rfc-editor.org/rfc/rfc5895.txt' />
</reference>

<reference anchor='RFC6365'>
<front>
<title>Terminology Used in Internationalization in the IETF</title>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<date year='2011' month='September' />
<abstract>
<t>This document provides a list of terms used in the IETF when discussing internationalization.  The purpose is to help frame discussions of internationalization in the various areas of the IETF and to help introduce the main concepts to IETF participants.  This memo documents an Internet Best Current Practice.</t></abstract></front>
<seriesInfo name='BCP' value='166' />
<seriesInfo name='RFC' value='6365' />
<format type='TXT' octets='103155' target='http://www.rfc-editor.org/rfc/rfc6365.txt' />
</reference>

<reference anchor="UAX9" target='http://unicode.org/reports/tr9/'>
  <front>
    <title>Unicode Standard Annex #9: Unicode Bidirectional Algorithm</title>
    <author>
      <organization>The Unicode Consortium</organization>
    </author>
    <date month="September" year="2010" />
  </front>
</reference>

<reference anchor="UAX15" target='http://unicode.org/reports/tr15/'>
  <front>
    <title>Unicode Standard Annex #15: Unicode Normalization Forms</title>
    <author>
      <organization>The Unicode Consortium</organization>
    </author>
    <date month="September" year="2010" />
  </front>
</reference>

<reference anchor="UTR36" target='http://unicode.org/reports/tr36/'>
  <front>
    <title>Unicode Technical Report #36: Unicode Security Considerations</title>
    <author>
      <organization>The Unicode Consortium</organization>
    </author>
    <date month="August" year="2010" />
  </front>
</reference>

<reference anchor="UTR39" target='http://unicode.org/reports/tr39/'>
  <front>
    <title>Unicode Technical Report #39: Unicode Security Mechanisms</title>
    <author>
      <organization>The Unicode Consortium</organization>
    </author>
    <date month="August" year="2010" />
  </front>
</reference>

    </references>

    <section anchor="codepoints" title="Codepoints 0x0000 - 0x10FFFF">
      <t>To follow.</t>
      <t>If one applies <xref target="PropertyCalculation">the rules</xref> to the code points 0x0000 to 0x10FFFF to Unicode 6.1, the result is as follows.</t>
      <t>NOTE: This list is non-normative, and only included for illustrative purposes.  Specifically, what is displayed in the third column is not necessarily the formal name of the code point (as defined in <xref target='UNICODE'/>).  There are differences, for example with regard to the code points that have the code point value as part of the name (example: CJK UNIFIED IDEOGRAPH-4E00) and the naming of Hangul syllables.  However, for many code points, what you see is the official name.</t>

      <section title="Codepoints in Unicode Character Database (UCD) format">
        <t>In progress...</t>
        <figure><artwork><![CDATA[
0000..001F  ; DISALLOWED           # <control>
0020        ; FREE_PVAL, NAME_DIS  # SPACE
0021..007E  ; PVALID               # EXCLAMATION MARK .. TILDE
007F..009F  ; DISALLOWED           # <control>
00A0..00A9  ; FREE_PVAL, NAME_DIS  # NO-BREAK SPACE .. COPYRIGHT SIGN
00AA        ; PVALID               # FEMININE ORDINAL INDICATOR
00AB..00AC  ; FREE_PVAL, NAME_DIS  # NO-BREAK SPACE .. NOT SIGN
00AD        ; DISALLOWED           # SOFT HYPHEN
00AE..00B6  ; FREE_PVAL, NAME_DIS  # REGISTERED SIGN .. PILCROW SIGN
00B7        ; CONTEXTO             # MIDDLE DOT
00B8..00BF  ; FREE_PVAL, NAME_DIS  # CEDILLA..INVERTED QUESTION IND
00C0..00D6  ; PVALID               # LAT CAP LET A W GRAV..LAT CAP O
00D7        ; FREE_PVAL, NAME_DIS  # MULTIPLICATION SIGN
00D8..00F6  ; PVALID               # LAT CAP LET O W STROKE..LAT SM 
00F7        ; FREE_PVAL, NAME_DIS  # DIVISION SIGN
00F8..0131  ; PVALID               # LAT SM LET O W STROKE..LAT SM LET
0132..0133  ; FREE_PVAL, NAME_DIS  # LAT CAP LIG IJ..LAT SM LIB IJ
0134..013E  ; PVALID               # LAT CAP LET J W CIRCUM..LAT SM LET
013F..0140  ; FREE_PVAL, NAME_DIS  # LAT CAP LET L W MID DOT..LAT SM LET
0141..0148  ; PVALID               # LAT CAP LET L W STROKE..LAT SM LET
0149        ; FREE_PVAL, NAME_DIS  # LAT SM LET N PRECEDED BY APOSTROPHE
014A..017E  ; PVALID               # LAT CAP LET ENG..LAT SM LET Z W CA
017F        ; FREE_PVAL, NAME_DIS  # LATIN SMALL LETTER LONG S
0180..01C3  ; PVALID               # LAT SM LET B W STROKE..LAT LET RETR
01C4..01CC  ; FREE_PVAL, NAME_DIS  # LAT CAP LET DZ W CARON..LATIN SM
01CD..01F0  ; PVALID               # LAT CAP LET A W CARON..LAT SM LET J
01F1..01F3  ; FREE_PVAL, NAME_DIS  # LAT CAP LET DZ..LAT SM LET DZ
01F4..02AF  ; PVALID               # LAT CAP LET G WITH ACUTE..LAT SM
02B0..02B8  ; FREE_PVAL, NAME_DIS  # MOD LET SM H..MOD LET SM Y
02B9..02C1  ; PVALID               # MOD LET PRIME..MOD LET REV GLOT ST
02C2..02C5  ; FREE_PVAL, NAME_DIS  # MOD LET L ARROW..MOD LET D ARROW
02C6..02D1  ; PVALID               # MOD LET CIRCUM ACC..MOD LET HALF TR
02D2..02EB  ; FREE_PVAL, NAME_DIS  # MOD LET CENT R HALF RING..MOD LET Y
02EC        ; PVALID               # MODIFIER LETTER VOICING
02ED        ; FREE_PVAL, NAME_DIS  # MODIFIER LETTER UNASPIRATED
02EE        ; PVALID               # MODIFIER LETTER DOUBLE APOSTROPHE
02EF..02FF  ; FREE_PVAL, NAME_DIS  # MOD LET LOW D ARR..MOD LET LOW L AR
0300..0374  ; PVALID               # COMB GRAVE ACCENT..GREEK NUM SIGN
0375        ; CONTEXTO             # GREEK LOWER NUMERAL SIGN
0376..0377  ; PVALID               # GR CAP LET PAMPHYLIAN DIGAMMA..GR S
0378..0379  ; UNASSIGNED           # <reserved>..<reserved>
037A..037D  ; PVALID               # GR YPOGEGRAMMENI..GR SM REV DOT LUN
037E        ; FREE_PVAL, NAME_DIS  # GREEK QUESTION MARK
037F..0383  ; UNASSIGNED           # <reserved>..<reserved>
0384..0385  ; FREE_PVAL, NAME_DIS  # GREEK TONOS..GREEK DIALYTIKA TONOS
0386        ; PVALID               # GR CAP LET ALPHA WITH TONOS
0387        ; FREE_PVAL, NAME_DIS  # GREEK ANO TELEIA
0388..038A  ; PVALID               # GR CAP LET EPSILON W TONOS..GR CAP
038B        ; UNASSIGNED           # <reserved>
038C        ; PVALID               # GR CAP LET OMICRON WITH TONOS
038D        ; UNASSIGNED           # <reserved>
038E..03A1  ; PVALID               # GR CAP LET EPSILON W TONOS..GR CAP
03A2        ; UNASSIGNED           # <reserved>
03A3..03CF  ; PVALID               # GREEK CAPITAL LETTER SIGMA..GR CAP
03D0..03D2  ; FREE_PVAL, NAME_DIS  # GR BETA SYMBOL..GR UPSILON W HOOK
03D3..03D4  ; PVALID               # GR UPSILON W ACUTE AND HOOK..GR UP
03D5..03D6  ; FREE_PVAL, NAME_DIS  # GR PHI SYMBOL..GR PI SYMBOL
03D7..03EF  ; PVALID               # GR KAI SYMBOL..COPTIC SM LET DEI
03F0..03F2  ; FREE_PVAL, NAME_DIS  # GR KAPPA SYMBOL..GR LUNATE SIGMA
03F3        ; PVALID               # GREEK LETTER YOT
03F4..03F6  ; FREE_PVAL, NAME_DIS  # GR CAP THETA..GR REV LUNATE EPSILON
03F7..03F8  ; PVALID               # GR CAP LET SHO..GR SM LET SHO
03F9        ; FREE_PVAL, NAME_DIS  # GREEK CAPITAL LUNATE SIGMA SYMBOL
03FA..0481  ; PVALID               # GR CAP LET SAN..CYR SML LET KOPPA
0482        ; FREE_PVAL, NAME_DIS  # CYRILLIC THOUSANDS SIGN
0483..0487  ; PVALID               # COMB CYR TITLO..COMB CYRILLIC POK
0488..048A  ; FREE_PVAL, NAME_DIS  # COMB CYR HUNDRED THOUSANDS SIGN..C
048B..0527  ; PVALID               # CYR SM LET SHORT I WITH TAIL..CYR S
0528..0530  ; UNASSIGNED           # <reserved>..<reserved>
0531..0556  ; PVALID               # ARM CAP LET AYB..ARM CAP LET FEH
0557..0558  ; UNASSIGNED           # <reserved>..<reserved>
0559        ; PVALID               # ARM MOD LET LEFT HALF RING
055A..055F  ; FREE_PVAL, NAME_DIS  # ARM APOS..ARM ABBREV
0560        ; UNASSIGNED           # <reserved>
0561..0586  ; PVALID               # ARM SM LET AYB..ARMENIAN SMALL LE
0587        ; FREE_PVAL, NAME_DIS  # ARM SM LIGATURE ECH YIWN
0588        ; UNASSIGNED           # <reserved>
0589..058A  ; FREE_PVAL, NAME_DIS  # ARMENIAN FULL STOP..ARMENIAN HYPHEN
058B..058E  ; UNASSIGNED           # <reserved>..<reserved>
058F        ; FREE_PVAL, NAME_DIS  # ARMENIAN DRAM SIGN
0590        ; UNASSIGNED           # <reserved>
0591..05BD  ; PVALID               # HEBR ACC ETNAHTA..HEBR PNT ME
05BE        ; FREE_PVAL, NAME_DIS  # HEBR PUNCT MAQAF
05BF        ; PVALID               # HEBR PNT RAFE
05C0        ; FREE_PVAL, NAME_DIS  # HEBR PUNCT PASEQ
05C1..05C2  ; PVALID               # HEBR PNT SHIN DOT..HEBR PNT SIN DOT
05C3        ; FREE_PVAL, NAME_DIS  # HEBR PUNCT SOF PASUQ
05C4..05C5  ; PVALID               # HEBR MARK UP DOT..HEBR MARK LOW DOT
05C6        ; FREE_PVAL, NAME_DIS  # HEBR PUNCT NUN HAFUKHA
05C7        ; PVALID               # HEBR PNT QAMATS QATAN
05C8..05CF  ; UNASSIGNED           # <reserved>..<reserved>
05D0..05EA  ; PVALID               # HEBR LET ALEF..HEBR LET TAV
05EB..05EF  ; UNASSIGNED           # <reserved>..<reserved>
05F0..05F2  ; PVALID               # HEBR LIG YIDDISH DOUBLE VAV..HEBR L
05F3..05F4  ; CONTEXTO             # HEBR PUNCT GERESH..HEBR PUNCTUATIO
05F5..05FF  ; UNASSIGNED           # <reserved>..<reserved>
0600..0604  ; DISALLOWED           # ARABIC NUMBER SIGN..ARABIC SIGN SAM
0605        ; UNASSIGNED           # <reserved>..<reserved>
0606..060F  ; FREE_PVAL, NAME_DIS  # AR-IND CUBE ROOT..ARABIC SIGN MISRA
0610..061A  ; PVALID               # ARABIC SIGN SALLALLAHOU ALAYHE ..AR
061B        ; FREE_PVAL, NAME_DIS  # ARABIC SEMICOLON
061C..061D  ; UNASSIGNED           # <reserved>..<reserved>
061E..061F  ; FREE_PVAL, NAME_DIS  # ARABIC TRIPLE DOT PUNCT MARK..ARABI
0620        ; UNASSIGNED           # <reserved>
0621..063F  ; PVALID               # ARABIC LET HAMZA..ARABIC LET FARSI
0640        ; DISALLOWED           # ARABIC TATWEEL
0641..065F  ; PVALID               # ARABIC LET FEH..ARABIC WAVY HAMZA B
0660..0669  ; CONTEXTO             # AR-IND DIG ZERO..AR-IND DIG
066A..066D  ; FREE_PVAL, NAME_DIS  # ARABIC PCT SIGN..ARABIC FIVE PNTED
066E..0674  ; PVALID               # ARABIC LET DOTLESS BEH..ARABIC LET
0675..0678  ; FREE_PVAL, NAME_DIS  # ARABIC LET HIGH HAMZA ALEF..ARABIC
0679..06D3  ; PVALID               # ARABIC LET TTEH..ARABIC LET YEH BAR
06D4        ; FREE_PVAL, NAME_DIS  # ARABIC FULL STOP
06D5..06DC  ; PVALID               # ARABIC LET AE..ARABIC SM HIGH SEEN
06DD        ; DISALLOWED           # ARABIC END OF AYAH
06DE        ; FREE_PVAL, NAME_DIS  # ARABIC START OF RUB EL HIZB
06DF..06E8  ; PVALID               # ARABIC SM HIGH ROUNDED ZERO..ARABI
06E9        ; FREE_PVAL, NAME_DIS  # ARABIC PLACE OF SAJDAH
06EA..06EF  ; PVALID               # ARABIC EMPTY CENTRE LOW STOP..ARABI
06F0..06F9  ; CONTEXTO             # EXT AR-IND DIG ZERO..EXT A
06FA..06FF  ; PVALID               # ARABIC LET SHEEN W DOT BEL..ARABIC
0700..070D  ; FREE_PVAL, NAME_DIS  # SYR END OF PARA..SYR HARKLEAN AST
070E        ; UNASSIGNED           # <reserved>
070F        ; DISALLOWED           # SYR ABBR MARK
0710..07B1  ; PVALID               # SYR LET ALAPH..THAANA LET N
07B2..07BF  ; UNASSIGNED           # <reserved>..<reserved>
07C0..07F5  ; PVALID               # NKO DIG ZERO..NKO LOW TONE APOS
07F6..07FA  ; FREE_PVAL, NAME_DIS  # NKO SYMBOL OO DENNEN..NKO LAJANYA
07FB..07FF  ; UNASSIGNED           # <reserved>..<reserved>
0800..082D  ; PVALID               # SAMAR LET ALAF..SAMAR MARK NEQUDA
082E..082F  ; UNASSIGNED           # <reserved>..<reserved>
0830..083E  ; FREE_PVAL, NAME_DIS  # SAMAR PUNCT NEQUDAA..SAMAR PUN
083F        ; UNASSIGNED           # <reserved>
0840..085B  ; PVALID               # MANDAIC LET HALQA..MANDAIC GEM
085C..085D  ; UNASSIGNED           # <reserved>..<reserved>
085E        ; FREE_PVAL, NAME_DIS  # MANDAIC PUNCTUATION
08A0..08AC  ; PVALID               # ARABIC LET BEH W SM V BEL..ARABIC
08AD..08E3  ; UNASSIGNED           # <reserved>..<reserved>
08E4..08FE  ; PVALID               # ARABIC CURLY FATHA..ARABIC DAMMA W 
08FF        ; UNASSIGNED           # <reserved>
0900..0963  ; PVALID               # DEVAN SIGN INV CANDRABINDU..DEVAN V
0964..0965  ; FREE_PVAL, NAME_DIS  # DEVAN DANDA..DEVAN DOUBLE DANDA
0966..096F  ; PVALID               # DEVAN DIG ZERO..DEVAN DIG NINE
0970        ; FREE_PVAL, NAME_DIS  # DEVAN ABBR SIGN
0971..097F  ; PVALID               # DEVAN SIGN HIGH SPACING DOT..DEVAN
0980        ; UNASSIGNED           # <reserved>
0981..0983  ; PVALID               # BENG SIGN CANDRABINDU..BENG SIGN V
0984        ; UNASSIGNED           # <reserved>
0985..098C  ; PVALID               # BENG LET A..BENG LET VOCALIC L
098D..098E  ; UNASSIGNED           # <reserved>..<reserved>
098F..0990  ; PVALID               # BENG LET E..BENG LET AI
0991..0992  ; UNASSIGNED           # <reserved>..<reserved>
0993..09A8  ; PVALID               # BENG LET O..BENG LET NA
09A9        ; UNASSIGNED           # <reserved>
09AA..09B0  ; PVALID               # BENG LET PA..BENG LET RA
09B1        ; UNASSIGNED           # <reserved>
09B2        ; PVALID               # BENG LET LA
09B3..09B5  ; UNASSIGNED           # <reserved>..<reserved>
09B6..09B9  ; PVALID               # BENG LET SHA..BENG LET HA
09BA..09BB  ; UNASSIGNED           # <reserved>..<reserved>
09BC..09C4  ; PVALID               # BENG SIGN NUKTA..BENG VOWEL SIGN VO
09C5..09C6  ; UNASSIGNED           # <reserved>..<reserved>
09C7..09C8  ; PVALID               # BENG VOWEL SIGN E..BENG VOWEL SIGN
09C9..09CA  ; UNASSIGNED           # <reserved>..<reserved>
09CB..09CE  ; PVALID               # BENG VOWEL SIGN O..BENG LET KHANDA
09CF..09D6  ; UNASSIGNED           # <reserved>..<reserved>
09D7        ; PVALID               # BENG AU LENGTH MARK
09D8..09DB  ; UNASSIGNED           # <reserved>..<reserved>
09DC..09DD  ; PVALID               # BENG LET RRA..BENG LET RHA
09DE        ; UNASSIGNED           # <reserved>
09DF..09E3  ; PVALID               # BENG LET YYA..BENG VOWEL SIG
09E4..09E5  ; UNASSIGNED           # <reserved>..<reserved>
09E6..09F1  ; PVALID               # BENG DIG ZERO..BENG LET RA W L
09F2..09F3  ; FREE_PVAL, NAME_DIS  # BENG RUPEE MARK..BENG RUPEE SIGN
09F4..09FB  ; DISALLOWED           # BENG CURR NUM ONE..BENG GANDA MARK
09FC..0A00  ; UNASSIGNED           # <reserved>..<reserved>
0A01..10FFFF; TBD! 
        ]]></artwork></figure>
      </section>
    </section>

    <section title="Acknowledgements">
      <t>The authors would like to acknowledge the comments and contributions of the following individuals: David Black, Mark Davis, Alan DeKok, Martin Duerst, Patrik Faltstrom, Ted Hardie, Joe Hildebrand, Paul Hoffman, Jeffrey Hutzelman, Simon Josefsson, John Klensin, Alexey Melnikov, Yoav Nir, Mike Parker, Pete Resnick, Andrew Sullivan, Dave Thaler, and Yoshiro Yoneya.</t>
      <t>Some algorithms and textual descriptions have been borrowed from <xref target='RFC5892'/>.  Some text regarding security has been borrowed from <xref target='RFC5890'/> and <xref target='I-D.ietf-xmpp-6122bis'/>.</t>
    </section>

  </back>
</rfc>
