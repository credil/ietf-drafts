<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" ipr="trust200902" docName="draft-ietf-jose-json-web-signature-00">

  <front>
    <title>JSON Web Signature (JWS)</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>independent</organization>
      <address>
	<email>ve7jtb@ve7jtb.com</email>
      </address>
    </author>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>Nomura Research Institute</organization>
      <address>
	<email>n-sakimura@nri.co.jp</email>
      </address>
    </author>

    <date day="16" month="January" year="2012" />

    <area>Security</area>
    <workgroup>JOSE Working Group</workgroup>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>Assertion</keyword>
    <keyword>Simple Web Token</keyword>
    <keyword>Security Token</keyword>
    <keyword>SWT</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>JSON Web Signature</keyword>
    <keyword>JWS</keyword>
    <keyword>JSON Web Encryption</keyword>
    <keyword>JWE</keyword>
    <keyword>JSON Web Key</keyword>
    <keyword>JWK</keyword>
    <keyword>JSON Web Algorithms</keyword>
    <keyword>JWA</keyword>

    <abstract>
      <t>
	JSON Web Signature (JWS) is a means of
	representing content secured with digital signatures or
	Hash-based Message Authentication Codes (HMACs)
	using JSON data structures.
	Cryptographic algorithms and identifiers used with this
	specification are enumerated in the separate
	JSON Web Algorithms (JWA) specification.
	Related encryption capabilities are described in the separate
	JSON Web Encryption (JWE) specification.
      </t>
    </abstract>

    <note title="Requirements Language">
      <t>
	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
	NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
	"OPTIONAL" in this document are to be interpreted as described
	in <xref target="RFC2119">RFC 2119</xref>.
      </t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	JSON Web Signature (JWS) is a compact format for
	representing content secured with digital signatures or
	Hash-based Message Authentication Codes (HMACs)
	intended for space constrained environments such as HTTP
	Authorization headers and URI query parameters.  It represents
	this content using JSON <xref target="RFC4627" /> data
	structures.  The JWS digital signature and HMAC mechanisms are independent of
	the type of content being secured, allowing arbitrary content
	to be secured.
	Cryptographic algorithms and identifiers used with this
	specification are enumerated in the separate
	JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	Related encryption capabilities are described in the separate
	JSON Web Encryption (JWE) <xref target="JWE" /> specification.
      </t>
    </section>

    <section title="Terminology">
      <t>
	<list style="hanging">

          <t hangText="JSON Web Signature (JWS)">
	    A data structure cryptographically securing a JWS Header
	    and a JWS Payload with a JWS Signature value.
	  </t>

          <t hangText="JWS Header">
	    A string representing a JSON object that describes the
	    digital signature or HMAC applied to the JWS Header and the JWS Payload to
	    create the JWS Signature value.
	  </t>
          <t hangText="JWS Payload">
	    The bytes to be secured - a.k.a., the message.
	  </t>
          <t hangText="JWS Signature">
	    A byte array containing the cryptographic
	    material that secures the contents of the JWS Header
	    and the JWS Payload.
	  </t>

          <t hangText="Encoded JWS Header">
	    Base64url encoding of the bytes of the
	    UTF-8 <xref target="RFC3629">RFC 3629</xref>
	    representation of the JWS Header.
	  </t>
          <t hangText="Encoded JWS Payload">
	    Base64url encoding of the JWS Payload.
	  </t>
          <t hangText="Encoded JWS Signature">
	    Base64url encoding of the JWS Signature.
	  </t>

	  <t hangText="JWS Secured Input">
	    The concatenation of the Encoded JWS Header, a period ('.')
	    character, and the Encoded JWS Payload.
	  </t>

	  <t hangText="Header Parameter Names">
	    The names of the members within the JSON object
	    represented in a JWS Header.
	  </t>
	  <t hangText="Header Parameter Values">
	    The values of the members within the JSON object
	    represented in a JWS Header.
	  </t>

          <t hangText="Base64url Encoding">
	    For the purposes of this specification, this term always
	    refers to the URL- and filename-safe Base64 encoding
	    described in <xref target="RFC4648">RFC 4648</xref>,
	    Section 5, with the (non URL-safe) '=' padding characters
	    omitted, as permitted by Section 3.2.  (See <xref
	    target="base64urlnotes" /> for notes on implementing
	    base64url encoding without padding.)
	  </t>
        </list>
      </t>
    </section>

    <section title="JSON Web Signature (JWS) Overview">

      <t>
	JWS represents digitally signed or HMACed content using JSON data
	structures and base64url encoding. The representation
	consists of three parts: the JWS Header, the JWS Payload,
	and the JWS Signature.  The three parts are
	base64url-encoded for transmission, and typically represented
	as the concatenation of the encoded strings in that order,
	with the three strings being separated by period ('.')
	characters.
      </t>
      <t>
        The JWS Header describes the signature or HMAC method and parameters employed.
	The JWS Payload is the message content to be secured.
	The JWS Signature ensures the integrity of
	both the JWS Header and the JWS Payload.
      </t>

      <section title="Example JWS" anchor="ExampleJWS">

	<t>
	  The following example JWS Header declares that the
	  encoded object is a JSON Web Token (JWT) <xref target="JWT" />
	  and the JWS Header and the JWS Payload are
	  secured using the HMAC SHA-256 algorithm:
	</t>

	<figure><artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork></figure>

	<t>
	  Base64url encoding the bytes of the UTF-8 representation of
	  the JWS Header yields this Encoded JWS Header value:
	</t>

	<figure><artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork></figure>

	<t>
	  The following is an example of a JSON object that can be
	  used as a JWS Payload.  (Note that the payload can be any
	  content, and need not be a representation of a JSON object.)
	</t>

	<figure><artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork></figure>

	<t>
	  Base64url encoding the bytes of the UTF-8 representation of the JSON
	  object yields the following Encoded JWS Payload
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	<t>
	  Computing the HMAC of the UTF-8 representation of the JWS Secured Input
	  (the concatenation of the Encoded JWS Header, a period ('.')
	  character, and the Encoded JWS Payload) with the HMAC
	  SHA-256 algorithm and base64url encoding the result, as per
	  <xref target="HMACSHA256Example" />,
	  yields this Encoded JWS Signature value:
	</t>

	<figure><artwork><![CDATA[dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork></figure>

	<t>
	  Concatenating these parts in the order
	  Header.Payload.Signature with period characters between the
	  parts yields this complete JWS representation
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork></figure>

	<t>
	  This computation is illustrated in more detail in <xref
	  target="HMACSHA256Example"></xref>.
	</t>

      </section>
    </section>

    <section title="JWS Header">

      <t>
	The members of the JSON object represented by the JWS Header describe the
	digital signature or HMAC applied to the
	Encoded JWS Header and the Encoded JWS Payload and optionally
	additional properties of the JWS.
	The Header Parameter Names within this object MUST be unique.
	Implementations MUST
	understand the entire contents of the header; otherwise, the
	JWS MUST be rejected.
      </t>
      <t>
	The JWS Header MUST contain an <spanx style="verb">alg</spanx> (algorithm)
	parameter, the value of
	which is a string that unambiguously identifies the algorithm
	used to secure the JWS Header and the JWS Payload to
	produce the JWS Signature.
      </t>

      <t>
        There are three classes of Header Parameter Names:
	Reserved Header Parameter Names, Public Header Parameter Names,
	and Private Header Parameter Names.
      </t>

      <section title="Reserved Header Parameter Names" anchor="ReservedHeaderParameterName">
	<t>
	  The following header parameter names are reserved.  All
	  the names are short because a core goal of JWSs is for the
	  representations to be compact.
	</t>

	<texttable title="Reserved Header Parameter Definitions" anchor="HeaderParameterTable">

	  <ttcol align="left">Header Parameter Name</ttcol>
	  <ttcol align="left">JSON Value Type</ttcol>
	  <ttcol align="left">Header Parameter Syntax</ttcol>
	  <ttcol align="left">Header Parameter Semantics</ttcol>

	  <c>alg</c>
	  <c>string</c>
	  <c>StringOrURI</c>
	  <c>
	    The <spanx style="verb">alg</spanx> (algorithm) header
	    parameter identifies the cryptographic algorithm used to
	    secure the JWS.  A list of defined
	    <spanx style="verb">alg</spanx> values is presented in
	    Section 3, Table 1 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	    The processing of the <spanx
	    style="verb">alg</spanx> header parameter
	    requires that the value MUST be one that
	    is both supported and for which there exists a key for use
	    with that algorithm associated with the
	    party that digitally signed or HMACed the content.
	    The <spanx style="verb">alg</spanx> parameter value is case sensitive.
	    This header parameter is REQUIRED.
	  </c>

	  <c>typ</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">typ</spanx> (type) header
	    parameter is used to declare the type of the secured
	    content.
	    The <spanx style="verb">typ</spanx> value is case sensitive.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>jku</c>
	  <c>string</c>
	  <c>URL</c>
	  <c>
	    The <spanx style="verb">jku</spanx> (JSON Web Key URL)
	    header parameter is an absolute URL that refers to a
	    resource for a set of JSON-encoded public keys, one of
	    which corresponds to the key that was used to
	    digitally sign the JWS.
	    The keys MUST be encoded as described in the JSON Web Key
	    (JWK) <xref target="JWK" /> specification.
	    The protocol used to acquire the resource MUST provide
	    integrity protection.  An HTTP GET request to retrieve the
	    certificate MUST use TLS <xref target="RFC2818">RFC
	    2818</xref> <xref target="RFC5246">RFC 5246</xref> with
	    server authentication <xref target="RFC6125">RFC
	    6125</xref>.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>kid</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">kid</spanx> (key ID) header
	    parameter is a hint indicating which specific key owned by
	    the signer should be used to validate the digital signature.  This
	    allows signers to explicitly signal a change of key to
	    recipients.  The interpretation of the
	    contents of the <spanx style="verb">kid</spanx> parameter
	    is unspecified.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>x5u</c>
	  <c>string</c>
	  <c>URL</c>
	  <c>
	    The <spanx style="verb">x5u</spanx> (X.509 URL) header
	    parameter is an absolute URL that refers to a resource for
	    the X.509 public key certificate or certificate chain
	    corresponding to the key used to digitally sign the JWS.
	    The identified resource MUST provide a representation of
	    the certificate or certificate chain that conforms to
	    <xref target="RFC5280">RFC 5280</xref> in PEM encoded form
	    <xref target="RFC1421">RFC 1421</xref>.
	    The protocol used to acquire the resource MUST provide
	    integrity protection.  An HTTP GET request to retrieve the
	    certificate MUST use TLS <xref target="RFC2818">RFC
	    2818</xref> <xref target="RFC5246">RFC 5246</xref> with
	    server authentication <xref target="RFC6125">RFC
	    6125</xref>.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>x5t</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">x5t</spanx> (x.509 certificate
	    thumbprint) header parameter provides a base64url encoded
	    SHA-1 thumbprint (a.k.a. digest) of the DER encoding of an
	    X.509 certificate that can be used to match the certificate.
	    This header parameter is OPTIONAL.
	  </c>

	</texttable>

	<t>
	  Additional reserved header parameter names MAY be defined
	  via the IANA JSON Web Signature Header Parameters registry,
	  as per <xref target="IANA" />.  The syntax values used above
	  are defined as follows:
	</t>

	<texttable title="Header Parameter Syntax Definitions" anchor="SyntaxDefinitions">
	  <ttcol align="left">Syntax Name</ttcol>
	  <ttcol align="left">Syntax Definition</ttcol>

	  <c>IntDate</c>
	  <c>
	    The number of seconds from 1970-01-01T0:0:0Z as measured
	    in UTC until the desired date/time. See <xref
	    target="RFC3339">RFC 3339</xref> for details regarding
	    date/times in general and UTC in particular.
	  </c>

	  <c>String</c>
	  <c>
	    Any string value MAY be used.
	  </c>

	  <c>StringOrURI</c>
	  <c>
	    Any string value MAY be used but a value containing a ":"
	    character MUST be a URI as defined in <xref
	    target="RFC3986">RFC 3986</xref>.
	  </c>

	  <c>URL</c>
	  <c>
	    A URL as defined in <xref target="RFC1738">RFC 1738</xref>.
	  </c>
	</texttable>

      </section>

      <section title="Public Header Parameter Names" anchor="PublicHeaderParameterName">

        <t>
	  Additional header parameter names can be defined by those
	  using JWSs. However, in order to prevent collisions, any new
	  header parameter name or algorithm value SHOULD either be
	  defined in the IANA JSON Web Signature Header Parameters
	  registry or be defined as a URI that contains a collision
	  resistant namespace.  In each case, the definer of the name
	  or value needs to take reasonable precautions to make sure they
	  are in control of the part of the namespace they use to
	  define the header parameter name.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWSs.
	</t>
      </section>

      <section title="Private Header Parameter Names" anchor="PrivateHeaderParameterName">

	<t>
	  A producer and consumer of a JWS may agree to any header
	  parameter name that is not a Reserved Name <xref
	  target="ReservedHeaderParameterName"></xref> or a Public
	  Name <xref
	  target="PublicHeaderParameterName"></xref>. Unlike Public
	  Names, these private names are subject to collision and
	  should be used with caution.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWSs.
	</t>

      </section>
    </section>

    <section title="Rules for Creating and Validating a JWS">
      <t>
	To create a JWS, one MUST perform these steps:

        <list style="numbers">

	  <t>
	    Create the content to be used as the JWS Payload.
	  </t>
          <t>
	    Base64url encode the bytes of the JWS Payload.  This
	    encoding becomes the Encoded JWS Payload.
	  </t>
	  <t>
	    Create a JWS Header containing the desired set of header
	    parameters.  Note that white space is explicitly allowed
	    in the representation and no canonicalization is performed
	    before encoding.
	  </t>
	  <t>
	    Base64url encode the bytes of the UTF-8 representation of
	    the JWS Header to create the Encoded JWS Header.
	  </t>
          <t>
	    Compute the JWS Signature in the manner defined for
	    the particular algorithm being used.  The JWS Secured Input
	    is always the concatenation of the Encoded JWS Header,
	    a period ('.') character, and the Encoded JWS Payload.
	    (Note that if the JWS represents a JWT, this corresponds
	    to the portion of the JWT representation preceding the
	    second period character.)
	    The <spanx style="verb">alg</spanx> (algorithm) header parameter MUST be
	    present in the JSON Header, with the algorithm value
	    accurately representing the algorithm used to construct
	    the JWS Signature.
	  </t>
	  <t>
	    Base64url encode the representation of the JWS Signature
	    to create the Encoded JWS Signature.
	  </t>
        </list>
      </t>
      <t>
	When validating a JWS, the following steps MUST be taken. If
	any of the listed steps fails, then the JWS MUST be
	rejected.
      </t>
      <t>
	<list style="numbers">
          <t>
	    The Encoded JWS Header MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  </t>
          <t>
	    The JWS Header MUST be completely valid
	    JSON syntax conforming to <xref target="RFC4627">RFC
	    4627</xref>.
	  </t>
          <t>
	    The JWS Header MUST be validated to only include
	    parameters and values whose syntax and semantics are both
	    understood and supported.
	  </t>
          <t>
	    The Encoded JWS Payload MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  </t>
          <t>
	    The Encoded JWS Signature MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  </t>
          <t>
	    The JWS Signature MUST be successfully validated
	    against the JWS Header and JWS Payload
	    in the manner defined for the algorithm being used, which
	    MUST be accurately represented by the value of the <spanx style="verb">alg</spanx> (algorithm)
	    header parameter, which MUST be present.
	  </t>
        </list>
      </t>

      <t>
	Processing a JWS inevitably requires comparing known strings
	to values in the header. For example, in checking what the
	algorithm is, the Unicode string encoding <spanx style="verb">alg</spanx> will be
	checked against the member names in the JWS Header
	to see if there is a matching header parameter
	name. A similar process occurs when determining if the value
	of the <spanx style="verb">alg</spanx> header parameter represents a supported
	algorithm.
      </t>
      <t>
	Comparisons between JSON strings and other Unicode strings
	MUST be performed as specified below:

	<list style="numbers">

          <t>
	    Remove any JSON applied escaping to produce an array of
	    Unicode code points.
	  </t>
          <t>
	    <xref target="USA15">Unicode Normalization</xref> MUST NOT
	    be applied at any point to either the JSON string or to
	    the string it is to be compared against.
	  </t>
          <t>
	    Comparisons between the two strings MUST be performed as a
	    Unicode code point to code point equality comparison.
	  </t>

        </list>
      </t>

    </section>

    <section title="Securing JWSs with Cryptographic Algorithms" anchor="Signing">

      <t>
	JWS uses cryptographic algorithms to digitally sign or HMAC the contents
	of the JWS Header and the JWS Payload.  The
	JSON Web Algorithms (JWA) <xref target="JWA" />
	specification enumerates a set of cryptographic algorithms and
	identifiers to be used with this specification.
	Specifically, Section 3, Table 1 enumerates a set of
	<spanx style="verb">alg</spanx> (algorithm) header parameter values
	intended for use this specification.
	It also describes the semantics and operations that are
	specific to these algorithms and algorithm families.
      </t>
      <t>
	Public keys employed for digital signing can be identified using the
	Header Parameter methods described in <xref
	target="ReservedHeaderParameterName" /> or can be distributed
	using methods that are outside the scope of this
	specification.
      </t>

    </section>

    <section title="IANA Considerations" anchor="IANA">
      <t>
	This specification calls for:

        <list style="symbols">

          <t>
	    A new IANA registry entitled "JSON Web Signature Header
	    Parameters" for reserved header parameter names is defined
	    in <xref target="ReservedHeaderParameterName"></xref>.
	    Inclusion in the registry is RFC Required in the <xref
	    target="RFC5226">RFC 5226</xref> sense for reserved JWS
	    header parameter names that are intended to be
	    interoperable between implementations.  The registry will
	    just record the reserved header parameter name and a
	    pointer to the RFC that defines it. This specification
	    defines inclusion of the header parameter names defined in
	    <xref target="HeaderParameterTable"></xref>.
	  </t>
        </list>
      </t>
    </section>

    <section title="Security Considerations" anchor="Security">
      <t>
	TBD: Lots of work to do here. We need to remember to look into
	any issues relating to security and JSON parsing. One wonders
	just how secure most JSON parsing libraries are. Were they
	ever hardened for security scenarios? If not, what kind of
	holes does that open up? Also, we need to walk through the
	JSON standard and see what kind of issues we have especially
	around comparison of names.  For instance, comparisons of
	header parameter names and other parameters must occur after
	they are unescaped. Need to also put in text about: Importance
	of keeping secrets secret. Rotating keys. Strengths and
	weaknesses of the different algorithms.
      </t>
      <t>
	TBD: Need to put in text about why strict JSON validation is
	necessary.  Basically, that if malformed JSON is received then
	the intent of the sender is impossible to reliably discern.
	One example of malformed JSON that MUST be rejected is
	an object in which the same member name occurs multiple times.
      </t>
      <t>
	TBD: Write security considerations about the implications of
	using a SHA-1 hash (for compatibility reasons) for the
	<spanx style="verb">x5t</spanx> (x.509 certificate
	thumbprint).
      </t>

      <t>
	When utilizing TLS to retrieve information, the authority
	providing the resource MUST be authenticated and the
	information retrieved MUST be free from modification.
      </t>

      <section title="Unicode Comparison Security Issues">

        <t>
	  Header parameter names in JWSs are Unicode strings.  For
	  security reasons, the representations of these names must be
	  compared verbatim after performing any escape processing (as
	  per <xref target="RFC4627">RFC 4627</xref>, Section 2.5).
	</t>
        <t>
	  This means, for instance, that these JSON strings must
	  compare as being equal ("sig", "\u0073ig"), whereas these
	  must all compare as being not equal to the first set or to
	  each other ("SIG", "Sig", "si\u0047").
	</t>
	<t>
	  JSON strings MAY contain characters outside the Unicode
	  Basic Multilingual Plane.  For instance, the G clef
	  character (U+1D11E) may be represented in a JSON string as
	  "\uD834\uDD1E".  Ideally, JWS implementations SHOULD ensure
	  that characters outside the Basic Multilingual Plane are
	  preserved and compared correctly; alternatively, if this is
	  not possible due to these characters exercising limitations
	  present in the underlying JSON implementation, then input
	  containing them MUST be rejected.
	</t>

      </section>
    </section>

    <section title="Open Issues and Things To Be Done (TBD)" anchor="TBD">

      <t>
	The following items remain to be done in this draft:

	<list style="symbols">

	  <t>
	    Clarify the optional ability to provide type information in
	    the JWS header.  Specifically, clarify the intended use of
	    the <spanx style="verb">typ</spanx> Header Parameter,
	    whether it conveys syntax or semantics, and indeed, whether
	    this is the right approach.  Also clarify the relationship
	    between these type values and <xref
	    target="RFC2045">MIME</xref> types.
	  </t>
	  <t>
	    Clarify the semantics of the <spanx style="verb">kid</spanx>
	    (key ID) header parameter.  Open issues include: What
	    happens if a <spanx style="verb">kid</spanx> header is
	    received with an unrecognized value? Is that an error?
	    Should it be treated as if it's empty? What happens if the
	    header has a recognized value but the value doesn't match
	    the key associated with that value, but it does match
	    another key that is associated with the issuer? Is that an
	    error?
	  </t>
	  <t>
	    Consider whether a key type parameter should also be introduced.
	  </t>
	  <t>
	    Add Security Considerations text on timing attacks.
	  </t>
	  <t>
	    It would be good to have a confirmation method element so
	    it could be used with holder-of-key.
	  </t>
	  <t>
	    Consider whether to add parameters for directly including
	    keys in the header, either as JWK Key Objects, or X.509
	    cert values, or both.
	  </t>
	  <t>
	    Consider whether to add version numbers.
	  </t>
	  <t>
	    Think about how to best describe the concept currently
	    described as "the bytes of the UTF-8 representation of".
	    Possible terms to use instead of "bytes of" include "byte
	    sequence", "octet series", and "octet sequence".  Also
	    consider whether we want to add an overall clarifying
	    statement somewhere in each spec something like "every
	    place we say 'the UTF-8 representation of X', we mean 'the
	    bytes of the UTF-8 representation of X'".  That would
	    potentially allow us to omit the "the bytes of" part
	    everywhere else.
	  </t>
	  <t>
	    Finish the Security Considerations section.
	  </t>
	  <t>
	    Add an example in which the payload is not a base64url
	    encoded JSON object.
	  </t>

	</list>
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.1421.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.1738.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125.xml' ?>

      <reference anchor="USA15">
        <front>
          <title>Unicode Normalization Forms</title>

          <author fullname="Mark Davis" initials="M." surname="Davis">
            <address>
              <email>markdavis@google.com</email>
            </address>
          </author>

          <author fullname="Ken Whistler" initials="K." surname="Whistler">
            <address>
              <email>ken@unicode.org</email>
            </address>
          </author>

          <author fullname="Martin D&uuml;rst" initials="M."
                  surname="D&uuml;rst"></author>

          <date day="03" month="09" year="2009" />
        </front>

        <seriesInfo name="Unicode Standard Annex" value="15" />
      </reference>

      <reference anchor="JWK">
        <front>
	  <title>JSON Web Key (JWK)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="16" month="January" year="2012" />
        </front>
        <format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-key" type="HTML" />
      </reference>

      <reference anchor="JWA">
        <front>
	  <title>JSON Web Algorithms (JWA)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="16" month="January" year="2012" />
        </front>
        <format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms" type="HTML" />
      </reference>

    </references>

    <references title="Informative References">

      <reference anchor="JWT">
        <front>
          <title>JSON Web Token (JWT)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
	    <organization>Google</organization>
	    <address>
	      <email>balfanz@google.com</email>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	    </address>
	  </author>

	  <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland">
	    <organization>Microsoft</organization>
	    <address>
	      <email>yarong@microsoft.com</email>
	    </address>
	  </author>

	  <author fullname="John Panzer" initials="J." surname="Panzer">
	    <organization>Google</organization>
	    <address>
	      <email>jpanzer@google.com</email>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization>Nomura Research Institute</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	    </address>
	  </author>

	  <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
	    <organization>Facebook</organization>
	    <address>
	      <email>pt@fb.com</email>
	    </address>
	  </author>

	  <date day="13" month="December" year="2011" />
        </front>
        <format target="http://tools.ietf.org/html/draft-jones-json-web-token" type="HTML" />
      </reference>

      <reference anchor="MagicSignatures">
        <front>
          <title>Magic Signatures</title>

          <author fullname="John Panzer (editor)" initials="J." surname="Panzer (editor)"></author>

          <author fullname="Ben Laurie" initials="B." surname="Laurie"></author>

          <author fullname="Dirk Balfanz" initials="D." surname="Balfanz"></author>

          <date month="August" year="2010" />
        </front>
        <format target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-experimental-00.html" type="HTML" />
      </reference>

      <reference anchor="JSS">
        <front>
          <title>JSON Simple Sign</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization>Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/jss/1.0/" type="HTML" />
      </reference>

      <reference anchor="CanvasApp">
        <front>
          <title>Canvas Applications</title>

          <author fullname="Facebook" surname="Facebook"></author>

          <date year="2010" />
        </front>
        <format target="http://developers.facebook.com/docs/authentication/canvas" type="HTML" />
      </reference>

      <reference anchor="JWE">
        <front>
          <title>JSON Web Encryption (JWE)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
	    <organization>RTFM, Inc.</organization>
	    <address>
	      <email>ekr@rtfm.com</email>
	    </address>
	  </author>

	  <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
	    <organization>Cisco Systems, Inc.</organization>
	    <address>
	      <email>jhildebr@cisco.com</email>
	    </address>
	  </author>

	  <date day="16" month="January" year="2012" />
        </front>
        <format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-encryption" type="HTML" />
      </reference>

    </references>

    <section title="JWS Examples" anchor="JWSExamples">

      <t>
	This section provides several examples of JWSs.  While these
	examples all represent JSON Web Tokens (JWTs) <xref
	target="JWT" />, the payload can be any base64url encoded
	content.
      </t>

      <section title="JWS using HMAC SHA-256" anchor="HMACSHA256Example">
	<section title="Encoding">
	  <t>
	    The following example JWS Header declares that the
	    data structure is a JSON Web Token (JWT) <xref target="JWT" />
	    and the JWS Secured Input is secured using
	    the HMAC SHA-256 algorithm.  Note that white space is
	    explicitly allowed in JWS Header strings and
	    no canonicalization is performed before encoding.
	  </t>

	  <figure><artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork></figure>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the JWS Header:
	  </t>
	  <t>

[123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34, 44, 13, 10, 32, 34, 97, 108, 103, 34, 58, 34, 72, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example
	    follows.  (Note that the payload can be any base64url
	    encoded content, and need not be a base64url encoded JSON
	    object.)
	  </t>

	  <figure><artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork></figure>

	  <t>
	     The following byte array contains the UTF-8 characters
	     for the JWS Payload:
	  </t>
	  <t>

[123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10, 32, 34, 101, 120, 112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56, 48, 44, 13, 10, 32, 34, 104, 116, 116, 112, 58, 47, 47, 101, 120, 97, 109, 112, 108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111, 111, 116, 34, 58, 116, 114, 117, 101, 125]

	  </t>
	  <t>
	    Base64url encoding the above yields the Encoded JWS Payload value
	    (with line breaks for display purposes only):
	  </t>

          <figure><artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	  <t>
	    Concatenating the Encoded JWS Header, a period character,
	    and the Encoded JWS Payload yields this JWS Secured Input
	    value (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	  <t>
	    The UTF-8 representation of the JWS Secured Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 48, 101, 88, 65, 105, 79, 105, 74, 75, 86, 49, 81, 105, 76, 65, 48, 75, 73, 67, 74, 104, 98, 71, 99, 105, 79, 105, 74, 73, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    HMACs are generated using keys. This example uses the key
	    represented by the following byte array:
	  </t>
	  <t>

[3, 35, 53, 75, 43, 15, 165, 188, 131, 126, 6, 101, 119, 123, 166, 143, 90, 179, 40, 230, 240, 84, 201, 40, 169, 15, 132, 178, 210, 80, 46, 191, 211, 251, 90, 146, 210, 6, 71, 239, 150, 138, 180, 195, 119, 98, 61, 34, 61, 46, 33, 114, 5, 46, 79, 8, 192, 205, 154, 245, 103, 208, 128, 163]

	  </t>
	  <t>
	    Running the HMAC SHA-256 algorithm on the UTF-8
	    representation of the JWS Secured Input with this key
	    yields the following byte array:
	  </t>
	  <t>

[116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173, 187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83, 132, 141, 121]

	  </t>
	  <t>
	    Base64url encoding the above HMAC output yields the
	    Encoded JWS Signature value:
	  </t>

	  <figure><artwork><![CDATA[dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork></figure>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWS first requires removing the base64url
	    encoding from the Encoded JWS Header, the Encoded JWS Payload,
	    and the Encoded JWS Signature. We base64url decode
	    the inputs and
	    turn them into the corresponding byte arrays.  We
	    translate the header input byte array containing UTF-8
	    encoded characters into the JWS Header
	    string.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Next we validate the decoded results.  Since the <spanx style="verb">alg</spanx>
	    parameter in the header is "HS256", we validate the HMAC
	    SHA-256 value contained in the JWS Signature.  If
	    any of the validation steps fail, the JWS MUST be
	    rejected.
	  </t>
	  <t>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  </t>
          <t>
	    To validate the HMAC value, we repeat the previous process
	    of using the correct key and the UTF-8 representation of
	    the JWS Secured Input as input to a SHA-256 HMAC function
	    and then taking the output and determining if it matches
	    the JWS Signature.  If it matches exactly,
	    the HMAC has been validated.
	  </t>
	</section>
      </section>

      <section title="JWS using RSA SHA-256" anchor="RSASHA256Example">

	<section title="Encoding">
	  <t>
	    The JWS Header in this example is different
	    from the previous example in two ways:  First, because a
	    different algorithm is being used, the <spanx style="verb">alg</spanx> value is
	    different.  Second, for illustration purposes only, the
	    optional "typ" parameter is not used.  (This difference is
	    not related to the algorithm employed.)  The
	    JWS Header used is:
	  </t>

	  <figure><artwork><![CDATA[{"alg":"RS256"}]]></artwork></figure>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the JWS Header:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example, which
	    follows, is the same as in the previous example.  Since
	    the Encoded JWS Payload will therefore be the same, its
	    computation is not repeated here.
	  </t>

	  <figure><artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork></figure>

	  <t>
	    Concatenating the Encoded JWS Header, a period character,
	    and the Encoded JWS Payload yields this JWS Secured Input
	    value (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	  <t>
	    The UTF-8 representation of the JWS Secured Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    The RSA key consists of a public part (n, e), and a
	    private exponent d.  The values of the RSA key used in
	    this example, presented as the byte arrays representing
	    big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>n</c>
	    <c>

[161, 248, 22, 10, 226, 227, 201, 180, 101, 206, 141, 45, 101, 98, 99, 54, 43, 146, 125, 190, 41, 225, 240, 36, 119, 252, 22, 37, 204, 144, 161, 54, 227, 139, 217, 52, 151, 197, 182, 234, 99, 221, 119, 17, 230, 124, 116, 41, 249, 86, 176, 251, 138, 143, 8, 154, 220, 75, 105, 137, 60, 193, 51, 63, 83, 237, 208, 25, 184, 119, 132, 37, 47, 236, 145, 79, 228, 133, 119, 105, 89, 75, 234, 66, 128, 211, 44, 15, 85, 191, 98, 148, 79, 19, 3, 150, 188, 110, 155, 223, 110, 189, 210, 189, 163, 103, 142, 236, 160, 198, 104, 247, 1, 179, 141, 191, 251, 56, 200, 52, 44, 226, 254, 109, 39, 250, 222, 74, 90, 72, 116, 151, 157, 212, 185, 207, 154, 222, 196, 199, 91, 5, 133, 44, 44, 15, 94, 248, 165, 193, 117, 3, 146, 249, 68, 232, 237, 100, 193, 16, 198, 182, 71, 96, 154, 164, 120, 58, 235, 156, 108, 154, 215, 85, 49, 48, 80, 99, 139, 131, 102, 92, 111, 111, 122, 130, 163, 150, 112, 42, 31, 100, 27, 130, 211, 235, 242, 57, 34, 25, 73, 31, 182, 134, 135, 44, 87, 22, 245, 10, 248, 53, 141, 154, 139, 157, 23, 195, 64, 114, 143, 127, 135, 216, 154, 24, 216, 252, 171, 103, 173, 132, 89, 12, 46, 207, 117, 147, 57, 54, 60, 7, 3, 77, 111, 96, 111, 158, 33, 224, 84, 86, 202, 229, 233, 161]

	    </c>

	    <c>e</c>
	    <c>

[1, 0, 1]

	    </c>

	    <c>d</c>
	    <c>

[18, 174, 113, 164, 105, 205, 10, 43, 195, 126, 82, 108, 69, 0, 87, 31, 29, 97, 117, 29, 100, 233, 73, 112, 123, 98, 89, 15, 157, 11, 165, 124, 150, 60, 64, 30, 63, 207, 47, 44, 211, 189, 236, 136, 229, 3, 191, 198, 67, 155, 11, 40, 200, 47, 125, 55, 151, 103, 31, 82, 19, 238, 216, 193, 90, 37, 216, 213, 206, 160, 2, 94, 227, 171, 46, 139, 127, 121, 33, 111, 198, 59, 234, 86, 39, 83, 180, 6, 68, 198, 161, 81, 39, 217, 178, 149, 69, 64, 160, 187, 225, 163, 5, 86, 152, 45, 78, 159, 222, 95, 100, 37, 241, 77, 75, 113, 52, 65, 181, 93, 199, 59, 155, 74, 237, 204, 146, 172, 227, 146, 126, 55, 245, 125, 12, 253, 94, 117, 129, 250, 81, 44, 143, 73, 97, 169, 235, 11, 128, 248, 168, 7, 70, 114, 138, 85, 255, 70, 71, 31, 52, 37, 6, 59, 157, 83, 100, 47, 94, 222, 30, 132, 214, 19, 8, 26, 250, 92, 34, 208, 81, 40, 91, 214, 59, 148, 59, 86, 93, 137, 138, 5, 104, 84, 19, 229, 60, 60, 108, 101, 37, 255, 31, 227, 78, 61, 220, 112, 240, 213, 100, 80, 253, 164, 139, 161, 46, 16, 78, 157, 235, 159, 184, 24, 129, 225, 196, 189, 242, 93, 146, 71, 244, 80, 200, 101, 146, 121, 104, 231, 115, 52, 244, 65, 79, 117, 167, 80, 225, 57, 84, 110, 58, 138, 115, 157]

	    </c>
	  </texttable>

	  <t>
	    The RSA private key (n, d) is then passed to the RSA
	    signing function, which also takes the hash type, SHA-256,
	    and the UTF-8 representation of the JWS Secured Input as
	    inputs.  The result of the digital signature is a byte array S,
	    which represents a big endian integer.  In this example, S
	    is:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>S</c>
	    <c>

[112, 46, 33, 137, 67, 232, 143, 209, 30, 181, 216, 45, 191, 120, 69, 243, 65, 6, 174, 27, 129, 255, 247, 115, 17, 22, 173, 209, 113, 125, 131, 101, 109, 66, 10, 253, 60, 150, 238, 221, 115, 162, 102, 62, 81, 102, 104, 123, 0, 11, 135, 34, 110, 1, 135, 237, 16, 115, 249, 69, 229, 130, 173, 252, 239, 22, 216, 90, 121, 142, 232, 198, 109, 219, 61, 184, 151, 91, 23, 208, 148, 2, 190, 237, 213, 217, 217, 112, 7, 16, 141, 178, 129, 96, 213, 248, 4, 12, 167, 68, 87, 98, 184, 31, 190, 127, 249, 217, 46, 10, 231, 111, 36, 242, 91, 51, 187, 230, 244, 74, 230, 30, 177, 4, 10, 203, 32, 4, 77, 62, 249, 18, 142, 212, 1, 48, 121, 91, 212, 189, 59, 65, 238, 202, 208, 102, 171, 101, 25, 129, 253, 228, 141, 247, 127, 55, 45, 195, 139, 159, 175, 221, 59, 239, 177, 139, 93, 163, 204, 60, 46, 176, 47, 158, 58, 65, 214, 18, 202, 173, 21, 145, 18, 115, 160, 95, 35, 185, 232, 56, 250, 175, 132, 157, 105, 132, 41, 239, 90, 30, 136, 121, 130, 54, 195, 212, 14, 96, 69, 34, 165, 68, 200, 242, 122, 122, 45, 184, 6, 99, 209, 108, 247, 202, 234, 86, 222, 64, 92, 178, 33, 90, 69, 178, 194, 85, 102, 181, 90, 193, 167, 72, 160, 112, 223, 200, 163, 42, 70, 149, 67, 208, 25, 238, 251, 71]

	    </c>
	  </texttable>

	  <t>
	    Base64url encoding the digital signature produces this value for
	    the Encoded JWS Signature
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7
AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4
BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K
0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv
hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB
p0igcN_IoypGlUPQGe77Rw]]></artwork></figure>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWS from this example requires processing the
	    Encoded JWS Header and Encoded JWS Payload exactly as
	    done in the first example.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> parameter in the header is "RS256", we
	    validate the RSA SHA-256 digital signature contained in the JWS Signature.  If any of the validation steps fail, the
	    JWS MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  </t>
	  <t>
	    Validating the JWS Signature is a little different
	    from the previous example. First, we base64url decode the
	    Encoded JWS Signature to produce a digital signature S to check.  We
	    then pass (n, e), S and the UTF-8 representation of the
	    JWS Secured Input to an RSA signature verifier that has
	    been configured to use the SHA-256 hash function.
	  </t>

	</section>
      </section>

      <section title="JWS using ECDSA P-256 SHA-256" anchor="ECDSASHA256Example">
	<section title="Encoding">
	  <t>
	    The JWS Header for this example differs from
	    the previous example because a different algorithm is
	    being used.  The JWS Header used is:
	  </t>

	  <figure><artwork><![CDATA[{"alg":"ES256"}]]></artwork></figure>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the JWS Header:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example, which
	    follows, is the same as in the previous examples.  Since
	    the Encoded JWS Payload will therefore be the same, its
	    computation is not repeated here.
	  </t>

	  <figure><artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork></figure>

	  <t>
	    Concatenating the Encoded JWS Header, a period character,
	    and the Encoded JWS Payload yields this JWS Secured Input
	    value (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	  <t>
	    The UTF-8 representation of the JWS Secured Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    The ECDSA key consists of a public part, the EC point (x,
	    y), and a private part d.  The values of the ECDSA key
	    used in this example, presented as the byte arrays
	    representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>x</c>
	    <c>

[127, 205, 206, 39, 112, 246, 196, 93, 65, 131, 203, 238, 111, 219, 75, 123, 88, 7, 51, 53, 123, 233, 239, 19, 186, 207, 110, 60, 123, 209, 84, 69]

	    </c>

	    <c>y</c>
	    <c>

[199, 241, 68, 205, 27, 189, 155, 126, 135, 44, 223, 237, 185, 238, 185, 244, 179, 105, 93, 110, 169, 11, 36, 173, 138, 70, 35, 40, 133, 136, 229, 173]

	    </c>

	    <c>d</c>
	    <c>

[142, 155, 16, 158, 113, 144, 152, 191, 152, 4, 135, 223, 31, 93, 119, 233, 203, 41, 96, 110, 190, 210, 38, 59, 95, 87, 194, 19, 223, 132, 244, 178]

	    </c>
	  </texttable>

	  <t>
	    The ECDSA private part d is then passed to an ECDSA
	    signing function, which also takes the curve type, P-256,
	    the hash type, SHA-256, and the UTF-8 representation of
	    the JWS Secured Input as inputs.  The result of the
	    digital signature is the EC point (R, S), where R and S are
	    unsigned integers.  In this example, the R and S values,
	    given as byte arrays representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>R</c>
	    <c>

[14, 209, 33, 83, 121, 99, 108, 72, 60, 47, 127, 21, 88, 7, 212, 2, 163, 178, 40, 3, 58, 249, 124, 126, 23, 129, 154, 195, 22, 158, 166, 101]

	    </c>

	    <c>S</c>
	    <c>

[197, 10, 7, 211, 140, 60, 112, 229, 216, 241, 45, 175, 8, 74, 84, 128, 166, 101, 144, 197, 242, 147, 80, 154, 143, 63, 127, 138, 131, 163, 84, 213]

	    </c>
	  </texttable>

	  <t>
	    Concatenating the S array to the end of the R array and
	    base64url encoding the result produces this value for the
	    Encoded JWS Signature
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA
pmWQxfKTUJqPP3-Kg6NU1Q]]></artwork></figure>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWS from this example requires processing the
	    Encoded JWS Header and Encoded JWS Payload exactly as
	    done in the first example.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> parameter in the header is "ES256", we
	    validate the ECDSA P-256 SHA-256 digital signature contained in
	    the JWS Signature.  If any of the validation steps
	    fail, the JWS MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  </t>
	  <t>
	    Validating the JWS Signature is a little different
	    from the first example. First, we base64url decode the Encoded JWS Signature as in the previous examples but we then
	    need to split the 64 member byte array that must result
	    into two 32 byte arrays, the first R and the second S. We
	    then pass (x, y), (R, S) and the UTF-8 representation of
	    the JWS Secured Input to an ECDSA signature verifier that
	    has been configured to use the P-256 curve with the
	    SHA-256 hash function.
	  </t>
	  <t>
	    As explained in Section 3.3 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification, the
	    use of the k value in ECDSA means that we cannot validate
	    the correctness of the digital signature in the same way we
	    validated the correctness of the HMAC. Instead,
	    implementations MUST use an ECDSA validator to validate
	    the digital signature.
	  </t>

	</section>
      </section>

    </section>

    <section title="Notes on implementing base64url encoding without padding" anchor="base64urlnotes">

      <t>
	This appendix describes how to implement base64url encoding
	and decoding functions without padding based upon standard
	base64 encoding and decoding functions that do use padding.
      </t>
      <t>
	To be concrete, example C# code implementing these functions
	is shown below.  Similar code could be used in other
	languages.
      </t>

      <figure><artwork><![CDATA[static string base64urlencode(byte [] arg)
{
  string s = Convert.ToBase64String(arg); // Standard base64 encoder
  s = s.Split('=')[0]; // Remove any trailing '='s
  s = s.Replace('+', '-'); // 62nd char of encoding
  s = s.Replace('/', '_'); // 63rd char of encoding
  return s;
}

static byte [] base64urldecode(string arg)
{
  string s = arg;
  s = s.Replace('-', '+'); // 62nd char of encoding
  s = s.Replace('_', '/'); // 63rd char of encoding
  switch (s.Length % 4) // Pad with trailing '='s
  {
    case 0: break; // No pad chars in this case
    case 2: s += "=="; break; // Two pad chars
    case 3: s += "="; break; // One pad char
    default: throw new System.Exception(
      "Illegal base64url string!");
  }
  return Convert.FromBase64String(s); // Standard base64 decoder
}]]></artwork></figure>

      <t>
	As per the example code above, the number of '=' padding
	characters that needs to be added to the end of a base64url
	encoded string without padding to turn it into one with
	padding is a deterministic function of the length of the
	encoded string.  Specifically,

	if the length mod 4 is 0, no padding is added;
	if the length mod 4 is 2, two '=' padding characters are added;
	if the length mod 4 is 3, one '=' padding character is added;
	if the length mod 4 is 1, the input is malformed.
      </t>
      <t>
	An example correspondence between unencoded and encoded values
	follows.  The byte sequence below encodes into the string
	below, which when decoded, reproduces the byte sequence.
      </t>

      <figure><artwork>3 236 255 224 193</artwork></figure>

      <figure><artwork>A-z_4ME</artwork></figure>
    </section>

    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>
	Solutions for signing JSON content were previously explored by
	<xref target="MagicSignatures">Magic Signatures</xref>, <xref
	target="JSS">JSON Simple Sign</xref>, and <xref
	target="CanvasApp">Canvas Applications</xref>, all of which
	influenced this draft.
	Dirk Balfanz, Yaron Y. Goland, John Panzer, and Paul Tarjan
	all made significant contributions to the design of this
	specification.
      </t>

    </section>

    <section title='Document History'>
      <t>
        -00
        <list style='symbols'>
          <t>
            Created the initial IETF draft based upon
            draft-jones-json-web-signature-04 with no normative
            changes.
          </t>
	  <t>
	    Changed terminology to no longer call both digital
	    signatures and HMACs "signatures".
	  </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
