<?xml version="1.0" encoding="UTF-8"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629xslt/rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->

<!-- Normative References -->
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"> <!-- MUST, SHOULD, MAY -->
<!ENTITY RFC5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml"> <!-- Guidelines for Writing an IANA Considerations Section in RFCs -->
<!ENTITY RFC6143 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6143.xml"> <!-- RFB -->
<!ENTITY RFC6455 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6455.xml"> <!-- WebSocket -->
<!-- Informative References -->
<!ENTITY RFC2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml"> <!-- HTTP -->
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml"> <!-- TLS -->
<!ENTITY RFC6265 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6265.xml"> <!-- HTTP State Management -->
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<?rfc tocappendix="yes" ?>

<rfc category="info" docName="draft-garnero-rfb-websocket-00" ipr="trust200902" >
<!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->
<!-- should have been in "std" category but RFC6143 (RFB) itself is "Informational" -->
  <!-- ***** FRONT MATTER ***** -->

  <front>

    <!-- The abbreviated title is used in the page header - it is only necessary if the
         full title is longer than 39 characters -->
    <title abbrev="WebSocket as a Transport for RFB">The WebSocket Protocol as a Transport for the Remote Framebuffer Protocol (RFB)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Pierre Garnero" initials="P.G." surname="Garnero">
      <organization>Villamicro</organization>
      <address>
        <postal>
          <street></street>
          <code>06130</code>
          <city>Grasse</city>
          <region></region>
          <country>France</country>
        </postal>
        <email>pierre.garnero@villamicro.fr</email>
      </address>
    </author>

    <date month="June" year="2013" />
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
         in the current day and month for you. If the year is not the current one, it is
         necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
         purpose of calculating the expiry date).  With drafts it is normally sufficient to
         specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
         If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>RFB</keyword>
    <keyword>VNC</keyword>
    <keyword>WebSocket</keyword>
    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>The WebSocket protocol enables two-way realtime communication between clients and servers in web-based applications. This document specifies a WebSocket sub-protocol as a reliable transport mechanism between RFB (Remote Framebuffer Protocol) entities to enable usage of RFB in web-oriented deployments.</t>
    </abstract>

  </front>


  <middle>

    <section title="Introduction" anchor="introduction">

      <t>The WebSocket <xref target="RFC6455"/> protocol enables message exchange between clients and servers on top of a persistent TCP connection (optionally secured with TLS <xref target="RFC5246"/>). The initial protocol handshake makes use of HTTP <xref target="RFC2616"/> semantics, allowing the WebSocket protocol to reuse existing HTTP infrastructure.</t>

      <t>Modern web browsers include a WebSocket client stack complying with the WebSocket API <xref target="WS-API"/> as specified by the W3C. It is expected that other client applications (those running in personal computers and devices such as smartphones) will also make a WebSocket client stack available. The specification in this document enables usage of RFB in these scenarios.</t>

      <t>This specification defines a WebSocket sub-protocol (as defined in section 1.9 in <xref target="RFC6455"/>) for transporting RFB messages between a WebSocket client and server, a reliable and (as far as possible) message-boundary preserving transport for RFB and procedures for RFB entities implementing the WebSocket transport. </t>

    </section>

    <section title="Terminology" anchor="terminology">

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

      <section title="Definitions" anchor="definitions">
        <t>
          <list style="hanging" hangIndent="6">
            <t hangText="RFB WebSocket Client:">A RFB entity capable of opening outbound connections to WebSocket servers and communicating using the WebSocket RFB sub-protocol as defined by this document.</t>
            <t hangText="RFB WebSocket Server:">A RFB entity capable of listening for inbound connections from WebSocket clients and communicating using the WebSocket RFB sub-protocol as defined by this document.</t>
          </list>
        </t>
      </section>

    </section>


    <section title="The WebSocket Protocol" anchor="the_websocket_protocol">

      <t>The WebSocket protocol <xref target="RFC6455"/> is a transport layer on top of TCP (optionally secured with TLS <xref target="RFC5246"/>) in which both client and server exchange message units in both directions. The protocol defines a connection handshake, WebSocket sub-protocol and extensions negotiation, a frame format for sending application and control data, a masking mechanism, and status codes for indicating disconnection causes.</t>

      <t>The WebSocket connection handshake is based on HTTP <xref target="RFC2616"/> and utilizes the HTTP GET method with an "Upgrade" request. This is sent by the client and then answered by the server (if the negotiation succeeded) with an HTTP 101 status code. Once the handshake is completed the connection upgrades from HTTP to the WebSocket protocol. This handshake procedure is designed to reuse the existing HTTP infrastructure. During the connection handshake, client and server agree on the application protocol to use on top of the WebSocket transport. Such application protocol (also known as a "WebSocket sub-protocol") defines the format and semantics of the messages exchanged by the endpoints. This could be a custom protocol or a standardized one (as the WebSocket RFB sub-protocol defined in this document). Once the HTTP 101 response is processed both client and server reuse the underlying TCP connection for sending WebSocket messages and control frames to each other. Unlike plain HTTP, this
connection is persistent and can be used for multiple message exchanges.</t>

      <t>WebSocket defines message units to be used by applications for the exchange of data, so it provides a message boundary-preserving transport layer. These message units can contain either UTF-8 text or binary data, and can be split into multiple WebSocket text/binary transport frames as needed by the WebSocket stack.
        <list style="empty">
          <t>The <xref target="WS-API">WebSocket API</xref> for web browsers only defines callbacks to be invoked upon receipt of an entire message unit, regardless of whether it was received in a single Websocket frame or split across multiple frames.</t>
        </list>
      </t>

    </section>


    <section title="The WebSocket RFB Sub-Protocol" anchor="the_websocket_rfb_subprotocol">

      <t>The term WebSocket sub-protocol refers to an application-level protocol layered on top of a WebSocket connection. This document specifies the WebSocket RFB sub-protocol for carrying RFB messages through a WebSocket connection.</t>

      <section title="Handshake" anchor="handshake">

        <t>The RFB WebSocket Client and RFB WebSocket Server negotiate usage of the WebSocket RFB sub-protocol during the WebSocket handshake procedure as defined in section 1.3 of <xref target="RFC6455"/>. The Client MUST include the value "rfb" in the Sec-WebSocket-Protocol header in its handshake request. The 101 reply from the Server MUST contain "rfb" in its corresponding Sec-WebSocket-Protocol header.
        </t>

        <t>Below is an example of a WebSocket handshake in which the Client requests the WebSocket RFB sub-protocol support from the Server:<figure><artwork><![CDATA[
  GET / HTTP/1.1
  Host: rfb-ws.example.com
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
  Origin: http://www.example.com
  Sec-WebSocket-Protocol: rfb
  Sec-WebSocket-Version: 13
]]></artwork></figure>
        </t>

        <t>The handshake response from the Server accepting the WebSocket RFB sub-protocol would look as follows:<figure><artwork><![CDATA[
  HTTP/1.1 101 Switching Protocols
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
  Sec-WebSocket-Protocol: rfb
]]></artwork></figure>
        </t>

        <t>Once the negotiation has been completed, the WebSocket connection is established and can be used for the transport of RFB messages. The WebSocket messages transmitted over this connection MUST conform to the negotiated WebSocket sub-protocol.</t>

      </section>

      <section title="RFB Encoding" anchor="rfb_encoding">

        <t>WebSocket messages can be transported in either UTF-8 text frames or binary frames. RFB <xref target="RFC6143"/> defines binary bodies in RFB messages. Therefore RFB WebSocket Clients and RFB WebSocket Servers MUST accept binary frames and MUST NOT accept text frames.</t>
        <t>Encoding of RFB messages over WebSocket transport remains identical to the encoding defined in <xref target="RFC6143"/> </t>  
      </section>

    </section>

    <section title="RFB WebSocket Transport" anchor="rfb_websocket_transport">

      <section title="General" anchor="general">

        <t>WebSocket <xref target="RFC6455"/> is a reliable protocol and therefore the RFB WebSocket sub-protocol defined by this document is a reliable RFB transport.</t>

        <t>Each RFB message, excepted FramebufferUpdate message, MUST be carried within a single WebSocket message, and a WebSocket message MUST NOT contain more than one RFB message. 
          <list style="empty">
            <t>Because the WebSocket transport preserves message boundaries, this simplifies decoding of (most) RFB messages for both clients and servers.</t>
            <t>However, FramebufferUpdate message SHOULD be handled differently for performance reasons.</t>
          </list>
        </t>

      </section>
      
      <section title="FramebufferUpdate Server-to-Client message handling" anchor="framebuffer_message_handle">
        <t>
        According to <xref target="RFC6143"/> section 7.6.1 "FramebufferUpdate", a framebuffer update consists of a sequence of rectangles of pixel data that the client should put 
        into its framebuffer.
        Therefore a RFB Websocket Server should have to transfer a certain number of rectangles of pixel data to a remote RFB Websocket Client. 
        The amount of data could be quite large depending on the number of rectangles, the number of pixel in each rectangle and the encoding
        of the pixels.
        It could make sense for the RFB Websocket Server to avoid to wait to gather the full amount of rectangles before starting to transfer 
        the data to the remote RFB Websocket Client.
        That way, the remote RFB Websocket Client could start to process "small" parts of the framebuffer update in a timely manner instaed of 
        processing the full amount of data in one time, which could be a really CPU intensive process.        
        Then, preservation of message boundaries is no more required for this RFB message and such an RFB message could be transfered by mean of
        several WebSocket messages.
        </t>
        <t>
        Of course, due to the fact that <xref target="RFC6143"/> define a TCP transport, the nature of the Remote Framebuffer Protocol
        let it easily support a non preservation of message boundaries.
        </t>
        <t>
        However, the RFB Websocket Server should respect the following principles:
        <list style="hanging">
          <t>The RFB Websocket Server SHOULD elect to send an RFB FramebufferUpdate in a single WebSocket message</t>

          <t>Or the RFB Websocket Server SHOULD elect to send an RFB FramebufferUpdate in multiple WebSocket messages. In that case:</t>
            <t>
              <list style="hanging">
                <t>It MUST send the RFB FramebufferUpdate content in a set of consecutive WebSocket messages. That is, It MUST NOT transfer any other RFB message until the RFB FramebufferUpdate full message is transfered.</t>
                <t>It MUST send the RFB FramebufferUpdate header (see <xref target="RFC6143"/> section 7.6.1 "FramebufferUpdate") in a single WebSocket message.
                   This WebSocket message should be the first message related to the transfert of the full RFB FramebufferUpdate content.           
                   The RFB FramebufferUpdate header should be alone in the WebSocket message, without any rectangle information.</t>
                <t>It MUST send RFB FramebufferUpdate rectangle header (<xref target="RFC6143"/> section 7.6.1 "FramebufferUpdate") in a single WebSocket message, potentially with a part or all of the pixel data associated to this rectangle</t>
                <t>It MUST send rectangle pixel data in a single WebSocket message or several consecutive WebSocket messages.</t>
                <t>It MUST NOT mix information related to different rectangles in the same WebSocket message.</t>
              </list>
            </t>
        </list>
        </t>
      </section>
    </section>
    
    <section title="Connection Keep-Alive" anchor="connection_keep_alive">

      <t>RFB WebSocket Clients and Servers may keep their WebSocket connections open by sending periodic WebSocket "Ping" frames as described in <xref target="RFC6455"/> section 5.5.2.
        <list style="empty">
          <t>The WebSocket API <xref target="WS-API"/> does not provide a mechanism for applications running in a web browser to control whether or not periodic WebSocket "Ping" frames are sent to the server. The implementation of such a keep-alive feature is the decision of each web browser manufacturer and may also depend on the configuration of the web browser.</t>
        </list>
      </t>

    </section>

    <section title="Authentication" anchor="authentication">
       <t>Authentication process is fully described in <xref target="RFC6143" /> and remains valid if WebSocket transport is used.</t>
    </section>

    <section title="Security Considerations" anchor="security_considerations">

      <section title="Secure WebSocket Connection">
        <t>It is recommended that the RFB traffic transported over a WebSocket communication be protected by using a secure WebSocket connection (using TLS <xref target="RFC5246"/> over TCP).</t>

        <t>When establishing a connection using RFB over secure WebSocket transport, the client MUST authenticate the server using the server's certificate according to the WebSocket validation procedure in <xref target="RFC6455"/>.
        </t>
      </section>

    </section>

    <section title="IANA Considerations" anchor="iana_considerations">
      <t>RFC Editor Note: Please set the RFC number assigned for this document in the sub-sections below and remove this note.</t>

      <section title="Registration of the WebSocket RFB Sub-Protocol">
        <t>This specification requests IANA to register the WebSocket RFB sub-protocol under the "WebSocket Subprotocol Name" Registry with the following data:
          <list style="hanging">
            <t hangText="Subprotocol Identifier:">rfb</t>
            <t hangText="Subprotocol Common Name:">WebSocket Transport for RFB (Remote Framebuffer Protocol)</t>
            <t hangText="Subprotocol Definition:">Included in this cocument.</t>
          </list>
        </t>
      </section>
    </section>


  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml"?-->
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6455.xml"?-->
      &RFC2119;
      &RFC5226;
      &RFC6455;
    </references>

    <references title="Informative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml"?-->
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml"?-->
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6143.xml"?-->
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6265.xml"?-->
      &RFC2616;
      &RFC5246;
      &RFC6143;
      &RFC6265;

      <reference anchor="WS-API">
        <front>
          <title>The WebSocket API</title>
          <author>
            <organization>W3C</organization>
          </author>
          <author initials="I." surname="Hickson" fullname="Ian Hickson" role="editor">
            <organization>Google, Inc.</organization>
          </author>
          <date month="April" year="2013" />
        </front>
      </reference>

    </references>

  </back>

</rfc>
