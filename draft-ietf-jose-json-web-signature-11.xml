<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" ipr="trust200902" docName="draft-ietf-jose-json-web-signature-11">

  <front>
    <title>JSON Web Signature (JWS)</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization abbrev="Ping Identity">Ping Identity</organization>
      <address>
	<email>ve7jtb@ve7jtb.com</email>
      </address>
    </author>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization abbrev="NRI">Nomura Research Institute</organization>
      <address>
	<email>n-sakimura@nri.co.jp</email>
      </address>
    </author>

    <date day="28" month="May" year="2013" />

    <area>Security</area>
    <workgroup>JOSE Working Group</workgroup>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>JSON Web Signature</keyword>
    <keyword>JWS</keyword>
    <keyword>JSON Web Encryption</keyword>
    <keyword>JWE</keyword>
    <keyword>JSON Web Key</keyword>
    <keyword>JWK</keyword>
    <keyword>JSON Web Algorithms</keyword>
    <keyword>JWA</keyword>

    <abstract>
      <t>
	JSON Web Signature (JWS) is a means of
	representing content secured with digital signatures or
	Message Authentication Codes (MACs)
	using JavaScript Object Notation (JSON) based data structures.
	Cryptographic algorithms and identifiers for use with this
	specification are described in the separate
	JSON Web Algorithms (JWA) specification.
	Related encryption capabilities are described in the separate
	JSON Web Encryption (JWE) specification.
      </t>
    </abstract>

  </front>

  <middle>
    <section title="Introduction" anchor="Introduction">
      <t>
	JSON Web Signature (JWS) is a means of
	representing content secured with digital signatures or
	Message Authentication Codes (MACs)
	using JavaScript Object Notation (JSON) <xref target="RFC4627"/>
	based data structures.
	The JWS cryptographic mechanisms provide integrity protection for
	arbitrary sequences of octets.
      </t>
      <t>
	Two closely related representations for JWS objects are defined.
	The JWS Compact Serialization is a compact, URL-safe representation
	intended for space constrained environments such as HTTP
	Authorization headers and URI query parameters.
	The JWS JSON Serialization represents JWS objects as JSON objects and
	enables multiple signatures and/or MACs to be applied to the same content.
	Both share the same cryptographic underpinnings.
      </t>
      <t>
	Cryptographic algorithms and identifiers for use with this
	specification are described in the separate
	JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	Related encryption capabilities are described in the separate
	JSON Web Encryption (JWE) <xref target="JWE" /> specification.
      </t>

      <section title="Notational Conventions" anchor="NotationalConventions">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in
	  Key words for use in RFCs to Indicate Requirement Levels <xref target='RFC2119' />.
        </t>
      </section>

    </section>

    <section title="Terminology" anchor="Terminology">
      <t>
	<list style="hanging">

          <t hangText="JSON Web Signature (JWS)">
	    A data structure representing a digitally signed or MACed message.
	    The structure represents three values:
	    the JWS Header,
	    the JWS Payload, and
	    the JWS Signature.
	  </t>

 	  <t hangText="JSON Text Object">
	    A UTF-8 <xref target="RFC3629"/>
	    encoded text string representing a JSON object;
	    the syntax of JSON objects is defined in
	    Section 2.2 of <xref target="RFC4627"/>.
	  </t>

          <t hangText="JWS Header">
	    A JSON Text Object
	    (or JSON Text Objects, when using the JWS JSON Serialization)
	    that describes the
	    digital signature or MAC operation applied to
	    create the JWS Signature value.
	    The members of the JWS Header object(s) are Header Parameters.
	  </t>
          <t hangText="JWS Payload">
	    The sequence of octets to be secured -- a.k.a., the message.
	    The payload can contain an arbitrary sequence of octets.
	  </t>
          <t hangText="JWS Signature">
	    A sequence of octets containing the cryptographic material that
	    ensures the integrity of
	    the JWS Protected Header
	    and the JWS Payload.
	    The JWS Signature value is a digital signature or MAC value
	    calculated over the JWS Signing Input using the parameters
	    specified in the JWS Header.
	  </t>

          <t hangText="JWS Protected Header">
	    A JSON Text Object that contains the portion of the
	    JWS Header that is integrity protected.
	    For the JWS Compact Serialization, this comprises the entire JWS Header.
	    For the JWS JSON Serialization, this is one component of the JWS Header.
	  </t>

	  <t hangText="Header Parameter">
	    A name/value pair that is member of the JWS Header.
	  </t>
	  <t hangText="Header Parameter Name">
	    The name of a member of the JWS Header.
	  </t>
	  <t hangText="Header Parameter Value">
	    The value of a member of the JWS Header.
	  </t>

          <t hangText="Base64url Encoding">
	    The URL- and filename-safe Base64 encoding
	    described in <xref target="RFC4648">RFC 4648</xref>,
	    Section 5, with the (non URL-safe) '=' padding characters
	    omitted, as permitted by Section 3.2.  (See <xref
	    target="base64urlnotes" /> for notes on implementing
	    base64url encoding without padding.)
	  </t>

          <t hangText="Encoded JWS Header">
	    Base64url encoding of the JWS Protected Header.
	  </t>
          <t hangText="Encoded JWS Payload">
	    Base64url encoding of the JWS Payload.
	  </t>
          <t hangText="Encoded JWS Signature">
	    Base64url encoding of the JWS Signature.
	  </t>

	  <t hangText="JWS Signing Input">
	    The concatenation of the Encoded JWS Header, a period ('.')
	    character, and the Encoded JWS Payload.
	  </t>

	  <t hangText="JWS Compact Serialization">
	    A representation of the JWS as the concatenation of
	    the Encoded JWS Header,
	    the Encoded JWS Payload, and
	    the Encoded JWS Signature
	    in that order, with the three strings being separated
	    by two period ('.') characters.
	    This representation is compact and URL-safe.
	  </t>

	  <t hangText="JWS JSON Serialization">
	    A representation of the JWS as a JSON structure containing
	    JWS Header,
	    Encoded JWS Payload, and
	    Encoded JWS Signature values.
	    Unlike the JWS Compact Serialization,
	    the JWS JSON Serialization
	    enables multiple digital signatures and/or MACs to
	    be applied to the same content.
	    This representation is neither compact nor URL-safe.
	  </t>

	  <t hangText="Collision Resistant Namespace">
	    A namespace that allows names to be allocated in a manner
	    such that they are highly unlikely to collide with other names.
	    For instance, collision resistance can be achieved through
	    administrative delegation of portions of the namespace or
	    through use of collision-resistant name allocation functions.
	    Examples of Collision Resistant Namespaces include:
	    Domain Names,
	    Object Identifiers (OIDs) as defined in the ITU-T X.660
	    and X.670 Recommendation series, and
	    Universally Unique IDentifiers (UUIDs)
	    <xref target="RFC4122"/>.
	    When using an administratively delegated namespace,
	    the definer of a name needs to take
	    reasonable precautions to ensure they are in control of
	    the portion of the namespace they use to define the name.
	  </t>

	  <t hangText="StringOrURI">
	    A JSON string value, with the additional requirement that
	    while arbitrary string values MAY be used, any value
	    containing a ":" character MUST be a URI
	    <xref target="RFC3986"/>.
	    StringOrURI values are compared as case-sensitive strings
	    with no transformations or canonicalizations applied.
	  </t>

        </list>
      </t>
    </section>

    <section title="JSON Web Signature (JWS) Overview" anchor="Overview">

      <t>
	JWS represents digitally signed or MACed content using JSON data
	structures and base64url encoding.
	Three values are represented in a JWS:
	the JWS Header,
	the JWS Payload, and
	the JWS Signature.
	In the Compact Serialization, the three values are
	base64url-encoded for transmission, and represented
	as the concatenation of the encoded strings in that order,
	with the three strings being separated by two period ('.') characters.
	A JSON Serialization for this information is also defined in
	<xref target="JSONSerialization"/>.
      </t>
      <t>
        The JWS Header describes the signature or MAC method and parameters employed.
	The JWS Payload is the message content to be secured.
	The JWS Signature ensures the integrity of
	both the JWS Protected Header and the JWS Payload.
      </t>

      <section title="Example JWS" anchor="ExampleJWS">

	<t>
	  The following example JWS Header declares that the
	  encoded object is a JSON Web Token (JWT) <xref target="JWT" />
	  and the JWS Header and the JWS Payload are
	  secured using the HMAC SHA-256 algorithm:
	</t>

	<figure><artwork><![CDATA[
  {"typ":"JWT",
   "alg":"HS256"}
]]></artwork></figure>

	<t>
	  Base64url encoding the octets of the UTF-8 representation of
	  the JWS Header yields this Encoded JWS Header value:
	</t>

	<figure><artwork><![CDATA[
  eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
]]></artwork></figure>

	<t>
	  The following is an example of a JSON object that can be
	  used as a JWS Payload.  (Note that the payload can be any
	  content, and need not be a representation of a JSON object.)
	</t>

	<figure><artwork><![CDATA[
  {"iss":"joe",
   "exp":1300819380,
   "http://example.com/is_root":true}
]]></artwork></figure>

	<t>
	  Base64url encoding the octets of the UTF-8 representation of the JSON
	  object yields the following Encoded JWS Payload
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	<t>
	  Computing the HMAC of the octets of the ASCII <xref target="USASCII"/>
	  representation of the JWS Signing Input
	  (the concatenation of the Encoded JWS Header, a period ('.')
	  character, and the Encoded JWS Payload)
	  with the HMAC SHA-256 algorithm
	  using the key specified in <xref target="HS256Example" />
	  and base64url encoding the result
	  yields this Encoded JWS Signature value:
	</t>

	<figure><artwork><![CDATA[
  dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
]]></artwork></figure>

	<t>
	  Concatenating these values in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS representation
	  using the JWS Compact Serialization
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
  dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
]]></artwork></figure>

	<t>
	  This computation is illustrated in more detail in <xref
	  target="HS256Example"></xref>.
	  See <xref target="JWSExamples"/> for additional examples.
	</t>

      </section>
    </section>

    <section title="JWS Header" anchor="Header">

      <t>
	The members of the JSON object(s) represented by the JWS Header describe the
	digital signature or MAC applied to the
	Encoded JWS Header and the Encoded JWS Payload and optionally
	additional properties of the JWS.
	The Header Parameter Names within the JWS Header MUST be unique;
	JWSs with duplicate Header Parameter Names MUST be rejected.
      </t>
      <t>
	Implementations are required to understand
	the specific header parameters defined by this specification 
	that are designated as "MUST be understood"
	and process them in the manner defined in this specification.
	All other header parameters defined by this specification that
	are not so designated MUST be ignored when not understood.
	Unless listed as a critical header parameter, per <xref target="critDef"/>,
	all other header parameters MUST be ignored when not understood.
      </t>
      <t>
        There are three classes of Header Parameter Names:
	Reserved Header Parameter Names, Public Header Parameter Names,
	and Private Header Parameter Names.
      </t>

      <section title="Reserved Header Parameter Names" anchor="ReservedHeaderParameterName">
	<t>
	  The following Header Parameter Names are reserved
	  with meanings as defined below.
	  All the names are short because a core goal of this specification
	  is for the resulting representations
	  using the JWS Compact Serialization to be compact.
	</t>
	<t>
	  Additional reserved Header Parameter Names can be defined
	  via the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  <xref target="HdrReg"/>.
	  As indicated by the common registry, JWSs and JWEs share a
	  common header parameter space; when a parameter is used by
	  both specifications, its usage must be compatible
	  between the specifications.
	</t>

	<section title='"alg" (Algorithm) Header Parameter' anchor="algDef">
	  <t>
	    The <spanx style="verb">alg</spanx> (algorithm) header
	    parameter identifies the cryptographic algorithm used to
	    secure the JWS.
	    The algorithm specified by the <spanx style="verb">alg</spanx> value
	    MUST be supported by the implementation
	    and there MUST be a key for use with that algorithm associated with the
	    party that digitally signed or MACed the content
	    or the JWS MUST be rejected.
	    <spanx style="verb">alg</spanx> values SHOULD either be
	    registered in the IANA
	    JSON Web Signature and Encryption Algorithms registry
	    <xref target="JWA" /> or be
	    a value that contains a Collision Resistant Namespace.
	    The <spanx style="verb">alg</spanx> value is a case sensitive string
	    containing a StringOrURI value.
	    Use of this header parameter is REQUIRED.
	    This header parameter MUST be understood by implementations.
	  </t>
	  <t>
	    A list of defined <spanx style="verb">alg</spanx> values can be found
	    in the IANA JSON Web Signature and Encryption Algorithms registry
	    <xref target="JWA" />;
	    the initial contents of this registry are the values defined in
	    Section 3.1 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	  </t>
	</section>

	<section title='"jku" (JWK Set URL) Header Parameter' anchor="jkuDef">
	  <t>
	    The <spanx style="verb">jku</spanx> (JWK Set URL)
	    header parameter is a URI <xref target="RFC3986"/> that refers to a
	    resource for a set of JSON-encoded public keys, one of which
	    corresponds to the key
	    used to digitally sign the JWS.
	    The keys MUST be encoded as a JSON Web Key Set (JWK Set) <xref target="JWK" />.
	    The protocol used to acquire the resource MUST provide
	    integrity protection; an HTTP GET request to retrieve the
	    certificate MUST use TLS <xref target="RFC2818"/> <xref target="RFC5246"/>;
	    the identity of the server MUST be validated, as per
	    Section 3.1 of HTTP Over TLS <xref target='RFC2818'/>.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"jwk" (JSON Web Key) Header Parameter' anchor="jwkDef">
	  <t>
	    The <spanx style="verb">jwk</spanx> (JSON Web Key)
	    header parameter is the public key
	    that corresponds to the key
	    used to digitally sign the JWS.
	    This key is represented as a JSON Web Key <xref target="JWK" />.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"x5u" (X.509 URL) Header Parameter' anchor="x5uDef">
	  <t>
	    The <spanx style="verb">x5u</spanx> (X.509 URL) header
	    parameter is a URI <xref target="RFC3986"/> that refers to a resource for
	    the X.509 public key certificate or certificate chain <xref target="RFC5280"/>
	    corresponding to the key
	    used to digitally sign the JWS.
	    The identified resource MUST provide a representation of
	    the certificate or certificate chain that conforms to
	    <xref target="RFC5280">RFC 5280</xref> in PEM encoded form
	    <xref target="RFC1421"/>.
	    The certificate containing the public key
	    corresponding to the key
	    used to digitally sign the JWS
	    MUST be the first certificate.
	    This MAY be followed by additional certificates, with each
	    subsequent certificate being the one used to certify the
	    previous one.
	    The protocol used to acquire the resource MUST provide
	    integrity protection; an HTTP GET request to retrieve the
	    certificate MUST use TLS <xref target="RFC2818"/> <xref target="RFC5246"/>;
	    the identity of the server MUST be validated, as per
	    Section 3.1 of HTTP Over TLS <xref target='RFC2818'/>.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"x5t" (X.509 Certificate Thumbprint) Header Parameter' anchor="x5tDef">
	  <t>
	    The <spanx style="verb">x5t</spanx> (X.509 Certificate Thumbprint)
	    header parameter is a base64url encoded
	    SHA-1 thumbprint (a.k.a. digest) of the DER encoding of
	    the X.509 certificate <xref target="RFC5280"/>
	    corresponding to the key
	    used to digitally sign the JWS.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    If, in the future, certificate thumbprints need to be
	    computed using hash functions other than SHA-1, it is
	    suggested that additional related header parameters be
	    defined for that purpose.  For example, it is suggested
	    that a new <spanx style="verb">x5t#S256</spanx> (X.509
	    Certificate Thumbprint using SHA-256) header parameter
	    could be defined by registering it in the IANA
	    JSON Web Signature and Encryption Header Parameters
	    registry <xref target="HdrReg" />.
	  </t>
	</section>

	<section title='"x5c" (X.509 Certificate Chain) Header Parameter' anchor="x5cDef">
	  <t>
	    The <spanx style="verb">x5c</spanx> (X.509 Certificate Chain)
	    header parameter contains the X.509 public key
	    certificate or certificate chain <xref target="RFC5280"/>
	    corresponding to the key
	    used to digitally sign the JWS.
	    The certificate or certificate chain is represented as
	    a JSON array of certificate value strings.
	    Each string in the array is a base64 encoded
	    (<xref target="RFC4648"/> Section 4 -- not base64url encoded)
	    DER <xref target="ITU.X690.1994"/> PKIX certificate value.
	    The certificate containing the public key
	    corresponding to the key
	    used to digitally sign the JWS
	    MUST be the first certificate.
	    This MAY be followed by additional certificates, with each
	    subsequent certificate being the one used to certify the
	    previous one.
	    The recipient MUST verify the certificate chain according
	    to <xref target="RFC5280"/> and reject the JWS if any
	    validation failure occurs.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    See <xref target="x5cExample"/> for an example
	    <spanx style="verb">x5c</spanx> value.
	  </t>
	</section>

	<section title='"kid" (Key ID) Header Parameter' anchor="kidDef">
	  <t>
	    The <spanx style="verb">kid</spanx> (key ID) header
	    parameter is a hint indicating which key
	    was used to secure the JWS.
	    This parameter allows originators to explicitly signal a change of
	    key to recipients.
	    Should the recipient be unable to locate a key
	    corresponding to the <spanx style="verb">kid</spanx>
	    value, they SHOULD treat that condition as an error.
	    The interpretation of the
	    <spanx style="verb">kid</spanx> value is unspecified.
	    Its value MUST be a string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    When used with a JWK, the <spanx style="verb">kid</spanx>
	    value can be used to match a JWK <spanx style="verb">kid</spanx>
	    parameter value.
	  </t>
	</section>

	<section title='"typ" (Type) Header Parameter' anchor="typDef">
	  <t>
	    The <spanx style="verb">typ</spanx> (type) header
	    parameter is used to declare the type of this object.
	    The type value <spanx style="verb">JWS</spanx> is used
	    to indicate that this object is a JWS using the JWS Compact Serialization.
	    The type value <spanx style="verb">JWS+JSON</spanx> is used
	    to indicate that this object is a JWS using the JWS JSON Serialization.
	    Other type values MAY be used, and if not understood, SHOULD be ignored.
	    The <spanx style="verb">typ</spanx> value is a case sensitive string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    MIME Media Type <xref target="RFC2046"/>
	    values MAY be used as <spanx style="verb">typ</spanx> values.
	  </t>
	  <t>
	    <spanx style="verb">typ</spanx> values SHOULD either be
	    registered in the IANA
	    JSON Web Signature and Encryption Type Values registry
	    <xref target="TypReg" /> or be
	    a value that contains a Collision Resistant Namespace.
	  </t>
	</section>

	<section title='"cty" (Content Type) Header Parameter' anchor="ctyDef">
	  <t>
	    The <spanx style="verb">cty</spanx> (content type) header
	    parameter is used to declare the type of the secured
	    content (the Payload).
	    For example, the JSON Web Token (JWT) <xref target="JWT" />
	    specification uses the <spanx style="verb">cty</spanx> value
	    <spanx style="verb">JWT</spanx>
	    to indicate that the Payload is a JSON Web Token (JWT).
	    Content type values that are not understood SHOULD be ignored.
	    The <spanx style="verb">cty</spanx> value is a case sensitive string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    The values used for the <spanx style="verb">cty</spanx>
	    header parameter come from the same value space as the
	    <spanx style="verb">typ</spanx> header parameter,
	    with the same rules applying.
	  </t>
	</section>

	<section title='"crit" (Critical) Header Parameter' anchor="critDef">
	  <t>
	    The <spanx style="verb">crit</spanx> (critical) header parameter
	    indicates that extensions to [[ this specification ]] are being used
	    that MUST be understood and processed.
	    Its value is an array listing the header parameter names defined
	    by those extensions that are used in the JWS Header.
	    If any of the listed extension header parameters are not
	    understood and supported by the receiver, it MUST reject the JWS.
	    Senders MUST NOT include header parameter names defined by
	    [[ this specification ]], duplicate names, or
	    names that do not occur as header parameter names within the JWS Header
	    in the <spanx style="verb">crit</spanx> list.
	    Senders MUST not use the empty list <spanx style="verb">[]</spanx>
	    as the <spanx style="verb">crit</spanx> value.
	    Recipients MAY reject the JWS if the critical list
	    contains any header parameter names defined by [[ this specification ]]
	    or any other constraints on its use are violated.
	    This header parameter MUST be integrity protected, and therefore
	    MUST occur only with the JWS Protected Header, when used.
	    Use of this header parameter is OPTIONAL.
	    This header parameter MUST be understood by implementations.
	  </t>
	  <t>
	    <figure>
	      <preamble>
		An example use, along with a hypothetical
		<spanx style="verb">exp</spanx> (expiration-time) field is:
	      </preamble>
	      <artwork><![CDATA[
  {"alg":"ES256",
   "crit":["exp"],
   "exp":1363284000
  }
]]></artwork>
	    </figure>
	  </t>
	</section>

      </section>

      <section title="Public Header Parameter Names" anchor="PublicHeaderParameterName">

        <t>
	  Additional Header Parameter Names can be defined by those
	  using JWSs. However, in order to prevent collisions, any new
	  Header Parameter Name SHOULD either be registered in the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  <xref target="HdrReg" /> or be a Public Name:
	  a value that contains a Collision Resistant Namespace.
	  In each case, the definer of the name
	  or value needs to take reasonable precautions to make sure they
	  are in control of the part of the namespace they use to
	  define the Header Parameter Name.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWSs.
	</t>
      </section>

      <section title="Private Header Parameter Names" anchor="PrivateHeaderParameterName">

	<t>
	  A producer and consumer of a JWS may agree to use Header Parameter Names
	  that are Private Names:  names that are
	  not Reserved Names <xref target="ReservedHeaderParameterName"></xref>
	  or Public Names <xref target="PublicHeaderParameterName"></xref>.
	  Unlike Public Names, Private Names are subject to collision and
	  should be used with caution.
	</t>

      </section>
    </section>

    <section title="Producing and Consuming JWSs" anchor="JWSRules">

      <section title="Message Signing or MACing" anchor="MessageSigning">
	<t>
	  To create a JWS, one MUST perform these steps.
	  The order of the steps is not significant in cases where
	  there are no dependencies between the inputs and outputs of the steps.

	  <list style="numbers">

	    <t>
	      Create the content to be used as the JWS Payload.
	    </t>
	    <t>
	      Base64url encode the octets of the JWS Payload.  This
	      encoding becomes the Encoded JWS Payload.
	    </t>
	    <t>
	      Create a JWS Header containing the desired set of header
	      parameters.  Note that white space is explicitly allowed
	      in the representation and no canonicalization need be performed
	      before encoding.
	    </t>
	    <t>
	      Base64url encode the octets of the UTF-8 representation of
	      the JWS Protected Header to create the Encoded JWS Header.
	      If the JWS Protected Header is not present
	      (which can only happen when using the JWS JSON Serialization),
	      let the Encoded JWS Header be the empty string.
	    </t>
	    <t>
	      Compute the JWS Signature in the manner defined for
	      the particular algorithm being used over the JWS Signing Input
	      (the concatenation of the Encoded JWS Header,
	      a period ('.') character, and the Encoded JWS Payload).
	      The <spanx style="verb">alg</spanx> (algorithm) header parameter MUST be
	      present in the JWS Header, with the algorithm value
	      accurately representing the algorithm used to construct
	      the JWS Signature.
	    </t>
	    <t>
	      Base64url encode the representation of the JWS Signature
	      to create the Encoded JWS Signature.
	    </t>
	    <t>
	      The three encoded parts are result values used in both the
	      JWS Compact Serialization and the JWS JSON Serialization representations.
	    </t>
	    <t>
	      If the JWS JSON Serialization is being used, repeat this process
	      for each digital signature or MAC value being applied.
	    </t>
	    <t>
	      Create the desired serialized output.
	      The JWS Compact Serialization of this result is the
	      concatenation of
	      the Encoded JWS Header,
	      the Encoded JWS Payload, and
	      the Encoded JWS Signature
	      in that order, with the three strings
	      being separated by two period ('.') characters.
	      The JWS JSON Serialization is described in <xref target="JSONSerialization"/>.
	    </t>
	  </list>
	</t>
      </section>

      <section title="Message Signature or MAC Validation" anchor="MessageValidation">
	<t>
	  When validating a JWS, the following steps MUST be taken.
	  The order of the steps is not significant in cases where
	  there are no dependencies between the inputs and outputs of the steps.
	  If any of the listed steps fails, then the JWS MUST be rejected.
	</t>
	<t>
	  <list style="numbers">
	    <t>
	      Parse the serialized input to determine the values of
	      the JWS Header,
	      the Encoded JWS Payload, and
	      the Encoded JWS Signature.
	      When using the JWS Compact Serialization,
	      the Encoded JWS Header,
	      the Encoded JWS Payload, and
	      the Encoded JWS Signature
	      are represented as text strings in that order,
	      separated by two period ('.') characters.
	      The JWS JSON Serialization
	      is described in <xref target="JSONSerialization"/>.
	    </t>
	    <t>
	      The Encoded JWS Header MUST be successfully base64url
	      decoded following the restriction given in this specification that
	      no padding characters have been used.
	    </t>
	    <t>
	      Let the JWS Protected Header value be the result of
	      base64url decoding the Encoded JWS Header.
	    </t>
	    <t>
	      The resulting JWS Protected Header MUST be a completely valid
	      JSON object conforming to <xref target="RFC4627">RFC 4627</xref>.
	    </t>
	    <t>
	      If using the JWS Compact Serialization, let the JWS Header be the
	      JWS Protected Header;
	      otherwise, when using the JWS JSON Serialization,
	      let the JWS Header be the union of the members of the JWS Protected Header,
	      the members of the <spanx style="verb">unprotected</spanx> value, and
	      the members of the corresponding <spanx style="verb">header</spanx> value,
	      all of which must be completely valid JSON objects.
	    </t>
	    <t>
	      The resulting JWS Header MUST NOT contain duplicate
	      Header Parameter Names.
	      When using the JWS JSON Serialization, this restriction includes
	      that the same Header Parameter Name also MUST NOT occur in
	      distinct JSON Text Object values that together comprise the JWS Header.
	    </t>
	    <t>
	      The resulting JWS Header MUST be validated to only include
	      parameters and values whose syntax and semantics are both
	      understood and supported
	      or that are specified as being ignored when not understood.
	    </t>
	    <t>
	      The Encoded JWS Payload MUST be successfully base64url
	      decoded following the restriction given in this specification that
	      no padding characters have been used.
	    </t>
	    <t>
	      The Encoded JWS Signature MUST be successfully base64url
	      decoded following the restriction given in this specification that
	      no padding characters have been used.
	    </t>
	    <t>
	      The JWS Signature MUST be successfully validated
	      against the JWS Signing Input (the concatenation of the
	      Encoded JWS Header, a period ('.') character, and the
	      Encoded JWS Payload)
	      in the manner defined for the algorithm being used, which
	      MUST be accurately represented by the value of the <spanx style="verb">alg</spanx> (algorithm)
	      header parameter, which MUST be present.
	    </t>
	    <t>
	      If the JWS JSON Serialization is being used, repeat this process
	      for each digital signature or MAC value contained in the representation.
	    </t>
	  </list>
	</t>
      </section>

      <section title="String Comparison Rules" anchor="StringComparison">

	<t>
	  Processing a JWS inevitably requires comparing known strings
	  to values in JSON objects. For example, in checking what the
	  algorithm is, the Unicode string encoding
	  <spanx style="verb">alg</spanx> will be
	  checked against the member names in the JWS Header
	  to see if there is a matching Header Parameter Name.
	  A similar process occurs when determining if the value
	  of the <spanx style="verb">alg</spanx> header parameter
	  represents a supported algorithm.
	</t>
	<t>
	  Comparisons between JSON strings and other Unicode strings
	  MUST be performed as specified below:

	  <list style="numbers">

	    <t>
	      Remove any JSON escaping from the input JSON string and
	      convert the string into a sequence of Unicode code points.
	    </t>
	    <t>
	      Likewise, convert the string to be compared against into
	      a sequence of Unicode code points.
	    </t>
	    <t>
	      Unicode Normalization <xref target="USA15"/> MUST NOT
	      be applied at any point to either the JSON string or to
	      the string it is to be compared against.
	    </t>
	    <t>
	      Comparisons between the two strings MUST be performed as a
	      Unicode code point to code point equality comparison.
	      (Note that values that originally used different Unicode encodings
	      (UTF-8, UTF-16, etc.) may result in the same code point values.)
	    </t>

	  </list>
	</t>
	<t>
	  Also, see the JSON security considerations in <xref target="JSONSecCon"/> and
	  the Unicode security considerations in <xref target="UnicodeSecCon"/>.
	</t>
      </section>

    </section>

    <section title="Cryptographic Algorithms" anchor="CryptoAlgs">

      <t>
	JWS uses cryptographic algorithms to digitally sign or MAC
	the JWS Protected Header and the JWS Payload.
	The JSON Web Algorithms (JWA) <xref target="JWA" />
	specification describes a set of cryptographic algorithms and
	identifiers to be used with this specification.
	Specifically, Section 3.1 specifies a set of
	<spanx style="verb">alg</spanx> (algorithm) header parameter values
	intended for use this specification.
	It also describes the semantics and operations that are
	specific to these algorithms.
      </t>

    </section>

    <section title="Key Identification" anchor="IDingKeys">
      <t>
	It is necessary for the recipient of a JWS to be able to determine
	the key that was employed for the digital signature or MAC operation.
	The key employed can be identified using the
	Header Parameter methods described in <xref
	target="ReservedHeaderParameterName" /> or can be identified
	using methods that are outside the scope of this specification.
	Specifically, the Header Parameters
	<spanx style="verb">jku</spanx>,
	<spanx style="verb">jwk</spanx>,
	<spanx style="verb">x5u</spanx>,
	<spanx style="verb">x5t</spanx>,
	<spanx style="verb">x5c</spanx>,
	and <spanx style="verb">kid</spanx>
	can be used to identify the key used.
	The sender SHOULD include sufficient information in the Header Parameters
	to identify the key used, unless the application uses another means
	or convention to determine the key used.
	Recipients MUST reject the input when
	the algorithm used requires a key
	(which is true of all algorithms except for <spanx style="verb">none</spanx>) and
	the key used cannot be determined.
      </t>
    </section>

    <section title="JWS JSON Serialization" anchor="JSONSerialization">

      <t>
	The JWS JSON Serialization represents digitally signed or MACed
	content as a JSON object.
	Unlike the JWS Compact Serialization, content using
	the JWS JSON Serialization can be secured with more than one
	digital signature and/or MAC value.
      </t>
      <t>
	The representation is closely related to that used in the
	JWS Compact Serialization,
	with the following differences for the
	JWS JSON Serialization:
	<list style="symbols">
	  <t>
	    Values in the JWS JSON Serialization are represented as members of
	    a JSON object, rather than as base64url encoded strings
	    separated by period ('.') characters.
	    (However binary values and values that are integrity protected
	    are still base64url encoded.)
	  </t>
	  <t>
	    The Encoded JWS Header value, if non-empty, is stored in the
	    <spanx style="verb">protected</spanx> member.
	  </t>
	  <t>
	    The Encoded JWS Payload value is stored in the
	    <spanx style="verb">payload</spanx> member.
	  </t>
	  <t>
	    There can be multiple signature and/or MAC values, rather than just one.
	    A JSON array in the <spanx style="verb">signatures</spanx> member
	    is used to hold values that are specific to a particular
	    signature or MAC computation, with one array element
	    per signature/MAC represented.
	    These array elements are JSON objects.
	  </t>
	  <t>
	    Each Encoded JWS Signature value is stored in the
	    <spanx style="verb">signature</spanx> member of a JSON object
	    that is an element of the <spanx style="verb">signatures</spanx> array.
	  </t>
	  <t>
	    Some header parameter values, such as the <spanx style="verb">alg</spanx>
	    value and parameters used for selecting keys, can also differ for different
	    signature/MAC computations.
	    Per-signature/MAC header parameter values are stored in the
	    <spanx style="verb">header</spanx> members of the same JSON objects
	    that are elements of the <spanx style="verb">signatures</spanx> array.
	  </t>
	  <t>
	    Some header parameters, including the <spanx style="verb">alg</spanx>
	    parameter, can be shared among all signature/MAC computations.
	    These header parameters are stored in either of two
	    top-level member(s) of the JSON object:
	    the <spanx style="verb">protected</spanx> member and
	    the <spanx style="verb">unprotected</spanx> member.
	    The values of these members are JSON Text Objects containing
	    Header Parameters.
	  </t>
	  <t>
	    Not all header parameters are integrity protected.
	    The shared header parameters in the <spanx style="verb">protected</spanx>
	    member are integrity protected, and are base64url encoded.
	    The per-signature/MAC header parameters in the
	    <spanx style="verb">header</spanx> array element members
	    and the shared header parameters in the
	    <spanx style="verb">unprotected</spanx> member are not integrity protected.
	    These JSON Text Objects containing header parameters that are
	    not integrity protected are not base64url encoded.
	  </t>
	  <t>
	    The header parameter values used when creating or validating
	    individual signature or MAC values are
	    the union of the three sets of header parameter values that may be present:
	    (1) the per-signature/MAC values in the <spanx style="verb">header</spanx>
	    member of the signature/MAC's array element,
	    (2) the shared integrity-protected values in the
	    <spanx style="verb">protected</spanx> member, and
	    (3) the shared non-integrity-protected values in the
	    <spanx style="verb">unprotected</spanx> member.
	    The union of these sets of header parameters comprises the JWS Header.
	    The header parameter names in the three locations MUST be disjoint.
	  </t>
	</list>
      </t>

      <figure>
	<preamble>
	  The syntax of a JWS using the JWS JSON Serialization is as follows:
	</preamble>
	<artwork><![CDATA[
  {"protected":<integrity-protected shared header contents>",
   "unprotected":<non-integrity-protected shared header contents>",
   "payload":"<payload contents>"
   "signatures":[
    {"header":"<per-signature unprotected header 1 contents>",
     "signature":"<signature 1 contents>"},
    ...
    {"header":"<per-signature unprotected header N contents>",
     "signature":"<signature N contents>"}],
  }
]]></artwork></figure>

      <t>
	Of these members, only the
	<spanx style="verb">payload</spanx>,
	<spanx style="verb">signatures</spanx>,
	and <spanx style="verb">signature</spanx>
	members MUST be present.
	At least one of the
	<spanx style="verb">header</spanx>,
	<spanx style="verb">protected</spanx>,
	and <spanx style="verb">unprotected</spanx>
	members MUST be present so that an <spanx style="verb">alg</spanx>
	header parameter value is conveyed for each signature/MAC computation.
      </t>
      <t>
	The contents of the
	Encoded JWS Payload and
	Encoded JWS Signature
	values are exactly as defined in the rest of this specification.
	They are interpreted and validated in the same manner,
	with each corresponding
	Encoded JWS Signature and 
	set of header parameter values
	being created and validated together.
	The JWS Header values used are the union of the header parameters in the
	<spanx style="verb">protected</spanx>,
	<spanx style="verb">unprotected</spanx>, and
	corresponding <spanx style="verb">header</spanx> members,
	as described earlier.
      </t>
      <t>
	Each JWS Signature value is computed on the
	JWS Signing Input using the
	parameters of the corresponding JWS Header value
	in the same manner as for the JWS Compact Serialization.
	This has the desirable property that each
	Encoded JWS Signature value
	in the <spanx style="verb">signatures</spanx> array
	is identical to the value
	that would have been computed for the same parameter
	in the JWS Compact Serialization,
	provided that the Encoded JWS Header value
	(which represents the integrity-protected header parameter values)
	matches that used in
	the JWS Compact Serialization.
      </t>
      <t>
	See <xref target="JSONSerializationExample"/> for an example
	of computing a JWS using the JWS JSON Serialization.
      </t>

    </section>

    <section title="Implementation Considerations" anchor="ImplementationConsiderations">
      <t>
	The JWS Compact Serialization is mandatory to implement.
	Implementation of the JWS JSON Serialization is OPTIONAL.
      </t>
    </section>

    <section title="IANA Considerations" anchor="IANA">
      <t>
	The following registration procedure is used for all the
	registries established by this specification.
      </t>
      <t>
	Values are registered with a Specification Required
	<xref target="RFC5226"/> after a two-week review period on the [TBD]@ietf.org mailing
	list, on the advice of one or more Designated Experts. However, to allow for the
	allocation of values prior to publication, the Designated Expert(s) may approve
	registration once they are satisfied that such a specification will be published.
      </t>
      <t>
	Registration requests must be sent to the [TBD]@ietf.org mailing list for review and
	comment, with an appropriate subject (e.g., "Request for access token type: example").
	[[ Note to RFC-EDITOR: The name of the mailing list should be determined in consultation
	with the IESG and IANA. Suggested name: jose-reg-review. ]]
      </t>
      <t>
	Within the review period, the Designated Expert(s) will either approve or
	deny the registration request, communicating this decision to the review list and IANA.
	Denials should include an explanation and, if applicable, suggestions as to how to make
	the request successful.
      </t>
      <t>
	IANA must only accept registry updates from the Designated Expert(s) and should direct
	all requests for registration to the review mailing list.
      </t>

      <section title="JSON Web Signature and Encryption Header Parameters Registry" anchor="HdrReg">
	<t>
	  This specification establishes the
	  IANA JSON Web Signature and Encryption Header Parameters registry
	  for reserved JWS and JWE Header Parameter Names.
	  The registry records the reserved Header Parameter Name
	  and a reference to the specification that defines it.
	  The same Header Parameter Name MAY be registered multiple times,
	  provided that the parameter usage is compatible
	  between the specifications.
	  Different registrations of the same Header Parameter Name
	  will typically use different
	  Header Parameter Usage Location(s) values.
	</t>

        <section title="Registration Template" anchor="HdrTemplate">
          <t>
            <list style='hanging'>
              <t hangText='Header Parameter Name:'>
                <vspace />
                The name requested (e.g., "example").
		This name is case sensitive.  Names that match other registered names
		in a case insensitive manner SHOULD NOT be accepted.
              </t>
              <t hangText='Header Parameter Usage Location(s):'>
                <vspace />
                The header parameter usage locations, which should be one or more of the values
		<spanx style="verb">JWS</spanx> or
		<spanx style="verb">JWE</spanx>.
              </t>
              <t hangText='Change Controller:'>
                <vspace />
                For Standards Track RFCs, state "IETF". For others, give the name of the
                responsible party. Other details (e.g., postal address, email address, home page
                URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace />
                Reference to the document(s) that specify the parameter, preferably including URI(s) that
                can be used to retrieve copies of the document(s). An indication of the relevant
                sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>

        <section title="Initial Registry Contents" anchor="HdrContents">
	  <t>
	    This specification registers the Header Parameter Names defined in
	    <xref target="ReservedHeaderParameterName"/> in this registry.
	  </t>
	  <t> <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">alg</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="algDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">jku</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="jkuDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">jwk</spanx>
              </t>
              <t>
		Header Parameter Usage Location(s): JWS
	      </t>
	      <t>
                Change Controller: IETF
              </t>
              <t>
                Specification document(s): <xref target="jwkDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5u</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="x5uDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5t</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="x5tDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5c</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="x5cDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">kid</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="kidDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">typ</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="typDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">cty</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="ctyDef"/> of [[ this document ]]
              </t>
            </list>
          </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">crit</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="critDef"/> of [[ this document ]]
              </t>
            </list>
          </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

      <section title="JSON Web Signature and Encryption Type Values Registry" anchor="TypReg">
	<t>
	  This specification establishes the
	  IANA JSON Web Signature and Encryption Type Values registry
	  for values of the JWS and JWE
	  <spanx style="verb">typ</spanx> (type)
	  header parameter.
	  It is RECOMMENDED that all registered <spanx
	  style="verb">typ</spanx> values also include a
	  MIME Media Type <xref target="RFC2046"/>
	  value that the registered value is a short name for.
	  The registry records the
	  <spanx style="verb">typ</spanx> value,
	  the MIME type value that it is an abbreviation for (if any),
	  and a reference to the specification that defines it.
	</t>
	<t>
	  MIME Media Type <xref target="RFC2046"/>
	  values MUST NOT be directly registered as new
	  <spanx style="verb">typ</spanx> values; rather, new
	  <spanx style="verb">typ</spanx> values MAY be registered
	  as short names for MIME types.
	</t>

        <section title="Registration Template" anchor="TypTemplate">
          <t>
            <list style='hanging'>
              <t hangText='"typ" Header Parameter Value:'>
                <vspace />
                The name requested (e.g., "example").
		This name is case sensitive.  Names that match other registered names
		in a case insensitive manner SHOULD NOT be accepted.
              </t>
              <t hangText='Abbreviation for MIME Type:'>
                <vspace />
                The MIME type that this name is an abbreviation for (e.g., "application/example").
              </t>
              <t hangText='Change Controller:'>
                <vspace />
                For Standards Track RFCs, state "IETF". For others, give the name of the
                responsible party. Other details (e.g., postal address, email address, home page
                URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace />
                Reference to the document(s) that specify the parameter, preferably including URI(s) that
                can be used to retrieve copies of the document(s). An indication of the relevant
                sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>

	<section title="Initial Registry Contents" anchor="TypContents">
	  <t>
	    This specification registers the <spanx style='verb'>JWS</spanx>
	    and <spanx style='verb'>JWS+JSON</spanx>
	    type values in this registry:
	  </t>
	  <t> <?rfc subcompact="yes"?>
	    <list style='symbols'>
	      <t>
		"typ" Header Parameter Value: <spanx style='verb'>JWS</spanx>
	      </t>
	      <t>
		Abbreviation for MIME type: application/jws
	      </t>
	      <t>
		Change Controller: IETF
	      </t>
	      <t>
		Specification Document(s): <xref target="typDef"/> of [[ this document ]]
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		"typ" Header Parameter Value: <spanx style='verb'>JWS+JSON</spanx>
	      </t>
	      <t>
		Abbreviation for MIME type: application/jws+json
	      </t>
	      <t>
		Change Controller: IETF
	      </t>
	      <t>
		Specification Document(s): <xref target="typDef"/> of [[ this document ]]
	      </t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

      <section title="Media Type Registration" anchor="MediaReg">
	<section title="Registry Contents" anchor="MediaContents">
	  <t>
	    This specification registers the
	    <spanx style="verb">application/jws</spanx> and
	    <spanx style="verb">application/jws+json</spanx>
	    Media Types <xref target="RFC2046"/>
	    in the MIME Media Type registry <xref target="RFC4288"/>
	    to indicate, respectively, that the content is
	    a JWS using the JWS Compact Serialization or
	    a JWS using the JWS JSON Serialization.
	  </t>
	  <t> <?rfc subcompact="yes"?>
	    <list style="symbols">
	      <t>
		Type name: application
	      </t>
	      <t>
		Subtype name: jws
	      </t>
	      <t>
		Required parameters: n/a
	      </t>
	      <t>
		Optional parameters: n/a
	      </t>
	      <t>
		Encoding considerations: JWS values are encoded as a
		series of base64url encoded values (some of which may be the
		empty string) separated by period ('.') characters
	      </t>
	      <t>
		Security considerations: See the Security Considerations section of [[ this document ]]
	      </t>
	      <t>
		Interoperability considerations: n/a
	      </t>
	      <t>
		Published specification: [[ this document ]]
	      </t>
	      <t>
		Applications that use this media type:
		OpenID Connect, Mozilla Persona, Salesforce, Google, numerous others that use signed JWTs
	      </t>
	      <t>
		Additional information:
		Magic number(s): n/a,
		File extension(s): n/a,
		Macintosh file type code(s): n/a
	      </t>
	      <t>
		Person &amp; email address to contact for further information:
		Michael B. Jones, mbj@microsoft.com
	      </t>
	      <t>
		Intended usage: COMMON
	      </t>
	      <t>
		Restrictions on usage: none
	      </t>
	      <t>
		Author: Michael B. Jones, mbj@microsoft.com
	      </t>
	      <t>
		Change Controller: IETF
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		Type name: application
	      </t>
	      <t>
		Subtype name: jws+json
	      </t>
	      <t>
		Required parameters: n/a
	      </t>
	      <t>
		Optional parameters: n/a
	      </t>
	      <t>
		Encoding considerations:
		application/jws+json values are represented as a JSON Object;
		UTF-8 encoding SHOULD be employed for the JSON object.
	      </t>
	      <t>
		Security considerations: See the Security Considerations section of [[ this document ]]
	      </t>
	      <t>
		Interoperability considerations: n/a
	      </t>
	      <t>
		Published specification: [[ this document ]]
	      </t>
	      <t>
		Applications that use this media type:
		TBD
	      </t>
	      <t>
		Additional information:
		Magic number(s): n/a,
		File extension(s): n/a,
		Macintosh file type code(s): n/a
	      </t>
	      <t>
		Person &amp; email address to contact for further information:
		Michael B. Jones, mbj@microsoft.com
	      </t>
	      <t>
		Intended usage: COMMON
	      </t>
	      <t>
		Restrictions on usage: none
	      </t>
	      <t>
		Author: Michael B. Jones, mbj@microsoft.com
	      </t>
	      <t>
		Change Controller: IETF
	      </t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

    </section>

    <section title="Security Considerations" anchor="Security">

      <section title="Cryptographic Security Considerations" anchor="CryptoSecCon">
	<t>
	  All of the security issues faced by any cryptographic application
	  must be faced by a JWS/JWE/JWK agent.  Among these issues are protecting
	  the user's private and symmetric keys, preventing various attacks, and helping the
	  user avoid mistakes such as inadvertently encrypting a message for
	  the wrong recipient.  The entire list of security considerations is
	  beyond the scope of this document, but some significant concerns are
	  listed here.
	</t>
	<t>
	  All the security considerations in
	  <xref target="W3C.CR-xmldsig-core2-20120124">XML DSIG 2.0</xref>,
	  also apply to this specification, other than those that are XML specific.
	  Likewise, many of the best practices documented in
	  <xref target="W3C.WD-xmldsig-bestpractices-20110809">XML Signature Best Practices</xref>
	  also apply to this specification,
	  other than those that are XML specific.
	</t>
	<t>
	  Keys are only as strong as the amount of entropy used to
	  generate them.  A minimum of 128 bits of entropy should be
	  used for all keys, and depending upon the application context,
	  more may be required.
	  In particular, it may be difficult to generate sufficiently
	  random values in some browsers and application environments.
	</t>
	<t>
	  Creators of JWSs should not allow third parties to insert
	  arbitrary content into the message without adding entropy
	  not controlled by the third party.
	</t>
	<t>
	  When utilizing TLS to retrieve information, the authority
	  providing the resource MUST be authenticated and the
	  information retrieved MUST be free from modification.
	</t>
	<t>
	  When cryptographic algorithms are implemented in such a way
	  that successful operations take a different amount of time
	  than unsuccessful operations, attackers may be able to
	  use the time difference to obtain information about the keys
	  employed.  Therefore, such timing differences must be avoided.
	</t>
	<t>
	  A SHA-1 hash is used when computing
	  <spanx style="verb">x5t</spanx> (x.509 certificate thumbprint) values,
	  for compatibility reasons.  Should an effective means of producing
	  SHA-1 hash collisions be developed, and should an attacker wish to
	  interfere with the use of a known certificate on a given system,
	  this could be accomplished by creating another certificate whose
	  SHA-1 hash value is the same and adding it to the certificate
	  store used by the intended victim.  A prerequisite to this
	  attack succeeding is the attacker having write access to the
	  intended victim's certificate store.
	</t>
	<t>
	  If, in the future, certificate thumbprints need to be
	  computed using hash functions other than SHA-1, it is
	  suggested that additional related header parameters be
	  defined for that purpose.  For example, it is suggested
	  that a new <spanx style="verb">x5t#S256</spanx> (X.509
	  Certificate Thumbprint using SHA-256) header parameter
	  could be defined and used.
	</t>
      </section>

      <section title="JSON Security Considerations" anchor="JSONSecCon">
	<t>
	  Strict JSON validation is a security requirement.
	  If malformed JSON is received, then the intent of the sender
	  is impossible to reliably discern.
	  Ambiguous and potentially exploitable situations could arise
	  if the JSON parser used does not reject malformed JSON syntax.
	</t>
	<t>
	  Section 2.2 of the JavaScript Object Notation (JSON)
	  specification <xref target="RFC4627"/> states "The names
	  within an object SHOULD be unique", whereas this specification states that
	  "Header Parameter Names within this object MUST be unique;
	  JWSs with duplicate Header Parameter Names MUST be rejected".
	  Thus, this specification requires that the Section 2.2 "SHOULD"
	  be treated as a "MUST".
	  Ambiguous and potentially exploitable situations could arise
	  if the JSON parser used does not enforce the uniqueness of member names.
	</t>
	<t>
	  Some JSON parsers might not reject input that contains extra
	  significant characters after a valid input.  For instance,
	  the input <spanx style="verb">{"tag":"value"}ABCD</spanx>
	  contains a valid JSON object followed by
	  the extra characters <spanx style="verb">ABCD</spanx>.
	  Such input MUST be rejected in its entirety.
	</t>
      </section>

      <section title="Unicode Comparison Security Considerations" anchor="UnicodeSecCon">
        <t>
	  Header Parameter Names and algorithm names are Unicode strings.  For
	  security reasons, the representations of these names must be
	  compared verbatim after performing any escape processing (as
	  per <xref target="RFC4627">RFC 4627</xref>, Section 2.5).
	  This means, for instance, that these JSON strings must
	  compare as being equal ("sig", "\u0073ig"), whereas these
	  must all compare as being not equal to the first set or to
	  each other ("SIG", "Sig", "si\u0047").
	</t>
	<t>
	  JSON strings can contain characters outside the Unicode
	  Basic Multilingual Plane.  For instance, the G clef
	  character (U+1D11E) may be represented in a JSON string as
	  "\uD834\uDD1E".  Ideally, JWS implementations SHOULD ensure
	  that characters outside the Basic Multilingual Plane are
	  preserved and compared correctly; alternatively, if this is
	  not possible due to these characters exercising limitations
	  present in the underlying JSON implementation, then input
	  containing them MUST be rejected.
	</t>

      </section>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.1421.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2046.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4288.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml' ?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml2/reference.ITU.X690.1994.xml' ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml4/reference.W3C.WD-xmldsig-bestpractices-20110809.xml" ?>

      <reference anchor="USA15">
        <front>
          <title>Unicode Normalization Forms</title>

          <author fullname="Mark Davis" initials="M." surname="Davis">
            <address>
              <email>markdavis@google.com</email>
            </address>
          </author>

          <author fullname="Ken Whistler" initials="K." surname="Whistler">
            <address>
              <email>ken@unicode.org</email>
            </address>
          </author>

          <author fullname="Martin Deurst" initials="M."
                  surname="Deurst"></author>

          <date day="03" month="09" year="2009" />
        </front>

        <seriesInfo name="Unicode Standard Annex" value="15" />
      </reference>

      <reference anchor="JWK">
        <front>
	  <title>JSON Web Key (JWK)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="28" month="May" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-key" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-key" type="HTML" />
      </reference>

      <reference anchor="JWA">
        <front>
	  <title>JSON Web Algorithms (JWA)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="28" month="May" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-algorithms" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms" type="HTML" />
      </reference>

      <reference anchor="USASCII">
	<front>
	  <title>Coded Character Set -- 7-bit American Standard Code for Information Interchange</title>
	  <author>
	    <organization>American National Standards Institute</organization>
	  </author>
	  <date year="1986"/>
	</front>
	<seriesInfo name="ANSI" value="X3.4"/>
      </reference>

    </references>

    <references title="Informative References">

      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4122.xml' ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-xmldsig-core2-20120124.xml" ?>

      <reference anchor="JWT">
        <front>
          <title>JSON Web Token (JWT)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	    </address>
	  </author>

	  <date day="28" month="May" year="2013" />

        </front>
        <seriesInfo value="draft-ietf-oauth-json-web-token" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token" type="HTML" />
      </reference>

      <reference anchor="MagicSignatures">
        <front>
          <title>Magic Signatures</title>

          <author fullname="John Panzer (editor)" initials="J." surname="Panzer (editor)"></author>

          <author fullname="Ben Laurie" initials="B." surname="Laurie"></author>

          <author fullname="Dirk Balfanz" initials="D." surname="Balfanz"></author>

          <date day="7" month="January" year="2011" />
        </front>
        <format target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-01.html" type="HTML" />
      </reference>

      <reference anchor="JSS">
        <front>
          <title>JSON Simple Sign</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization abbrev="NRI">Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/jss/1.0/" type="HTML" />
      </reference>

      <reference anchor="CanvasApp">
        <front>
          <title>Canvas Applications</title>

          <author fullname="Facebook" surname="Facebook"></author>

          <date year="2010" />
        </front>
        <format target="http://developers.facebook.com/docs/authentication/canvas" type="HTML" />
      </reference>

      <reference anchor="JWE">
        <front>
          <title>JSON Web Encryption (JWE)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
	    <organization abbrev="RTFM">RTFM, Inc.</organization>
	    <address>
	      <email>ekr@rtfm.com</email>
	    </address>
	  </author>

	  <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
	    <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
	    <address>
	      <email>jhildebr@cisco.com</email>
	    </address>
	  </author>

	  <date day="28" month="May" year="2013" />
        </front>
	<seriesInfo value="draft-ietf-jose-json-web-encryption" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-encryption" type="HTML" />
      </reference>

    </references>

    <section title="JWS Examples" anchor="JWSExamples">

      <t>
	This section provides several examples of JWSs.  While these
	examples all represent JSON Web Tokens (JWTs) <xref
	target="JWT" />, the payload can be any base64url encoded
	content.
      </t>

      <section title="Example JWS using HMAC SHA-256" anchor="HS256Example">
	<section title="Encoding" anchor="HS256Encoding">
	  <t>
	    The following example JWS Header declares that the
	    data structure is a JSON Web Token (JWT) <xref target="JWT" />
	    and the JWS Signing Input is secured using
	    the HMAC SHA-256 algorithm.
	  </t>

	  <figure><artwork><![CDATA[
  {"typ":"JWT",
   "alg":"HS256"}
]]></artwork></figure>

	  <t>
	    The following octet sequence contains the UTF-8 representation of
	    the JWS Header:
	  </t>
	  <t>

[123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34, 44, 13, 10, 32, 34, 97, 108, 103, 34, 58, 34, 72, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding these octets yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example
	    is the octets of the UTF-8 representation of the JSON object below.
	    (Note that the payload can be any base64url
	    encoded octet sequence, and need not be a base64url encoded JSON
	    object.)
	  </t>

	  <figure><artwork><![CDATA[
  {"iss":"joe",
   "exp":1300819380,
   "http://example.com/is_root":true}
]]></artwork></figure>

	  <t>
	     The following octet sequence, which is the UTF-8 representation
	     of the JSON object above, is the JWS Payload:
	  </t>
	  <t>

[123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10, 32, 34, 101, 120, 112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56, 48, 44, 13, 10, 32, 34, 104, 116, 116, 112, 58, 47, 47, 101, 120, 97, 109, 112, 108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111, 111, 116, 34, 58, 116, 114, 117, 101, 125]

	  </t>
	  <t>
	    Base64url encoding the above yields the Encoded JWS Payload value
	    (with line breaks for display purposes only):
	  </t>

          <figure><artwork><![CDATA[
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	  <t>
	    Concatenating the Encoded JWS Header, a period ('.') character,
	    and the Encoded JWS Payload yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	  <t>
	    The ASCII representation of the JWS Signing Input
	    is the following octet sequence:
	  </t>
	  <t>

[101, 121, 74, 48, 101, 88, 65, 105, 79, 105, 74, 75, 86, 49, 81, 105, 76, 65, 48, 75, 73, 67, 74, 104, 98, 71, 99, 105, 79, 105, 74, 73, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    HMACs are generated using keys. This example uses the key
	    represented by the following octet sequence:
	  </t>
	  <t>

[3, 35, 53, 75, 43, 15, 165, 188, 131, 126, 6, 101, 119, 123, 166, 143, 90, 179, 40, 230, 240, 84, 201, 40, 169, 15, 132, 178, 210, 80, 46, 191, 211, 251, 90, 146, 210, 6, 71, 239, 150, 138, 180, 195, 119, 98, 61, 34, 61, 46, 33, 114, 5, 46, 79, 8, 192, 205, 154, 245, 103, 208, 128, 163]

	  </t>
	  <t>
	    Running the HMAC SHA-256 algorithm on the octets of the ASCII representation
	    of the JWS Signing Input
	    with this key yields the following octet sequence:
	  </t>
	  <t>

[116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173, 187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83, 132, 141, 121]

	  </t>
	  <t>
	    Base64url encoding the above HMAC output yields the
	    Encoded JWS Signature value:
	  </t>

	  <figure><artwork><![CDATA[
  dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
]]></artwork></figure>

	<t>
	  Concatenating these values in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS representation
	  using the JWS Compact Serialization
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
  dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
]]></artwork></figure>

	</section>
	<section title="Decoding" anchor="HS256Decoding">

	  <t>
	    Decoding the JWS requires base64url decoding the Encoded JWS Header,
	    Encoded JWS Payload, and Encoded JWS Signature to produce the
	    JWS Header, JWS Payload, and JWS Signature octet sequences.
	    The octet sequence containing the UTF-8 representation
	    of the JWS Header is decoded into the JWS Header string.
	  </t>

	</section>
	<section title="Validating" anchor="HS256Validating">

	  <t>
	    Next we validate the decoded results.  Since the <spanx style="verb">alg</spanx>
	    parameter in the header is "HS256", we validate the HMAC SHA-256
	    value contained in the JWS Signature.
	    If any of the validation steps fail, the JWS MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  </t>
          <t>
	    To validate the HMAC value, we repeat the previous process
	    of using the correct key and the ASCII representation of
	    the JWS Signing Input
	    as input to the HMAC SHA-256 function
	    and then taking the output and determining if it matches
	    the JWS Signature.  If it matches exactly,
	    the HMAC has been validated.
	  </t>
	</section>
      </section>

      <section title="Example JWS using RSASSA-PKCS-v1_5 SHA-256" anchor="RS256Example">

	<section title="Encoding" anchor="RS256Encoding">
	  <t>
	    The JWS Header in this example is different
	    from the previous example in two ways:  First, because a
	    different algorithm is being used, the <spanx style="verb">alg</spanx> value is
	    different.  Second, for illustration purposes only, the
	    optional "typ" parameter is not used.  (This difference is
	    not related to the algorithm employed.)  The
	    JWS Header used is:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RS256"}
]]></artwork></figure>

	  <t>
	    The following octet sequence contains the UTF-8 representation of
	    the JWS Header:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding these octets yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSUzI1NiJ9
]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example, which
	    follows, is the same as in the previous example.  Since
	    the Encoded JWS Payload will therefore be the same, its
	    computation is not repeated here.
	  </t>

	  <figure><artwork><![CDATA[
  {"iss":"joe",
   "exp":1300819380,
   "http://example.com/is_root":true}
]]></artwork></figure>

	  <t>
	    Concatenating the Encoded JWS Header, a period ('.') character,
	    and the Encoded JWS Payload yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	  <t>
	    The ASCII representation of the JWS Signing Input
	    is the following octet sequence:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    The RSA key consists of a public part (Modulus, Exponent), and a
	    Private Exponent.  The values of the RSA key used in
	    this example, presented as the octet sequences representing
	    big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>Modulus</c>
	    <c>

[161, 248, 22, 10, 226, 227, 201, 180, 101, 206, 141, 45, 101, 98, 99, 54, 43, 146, 125, 190, 41, 225, 240, 36, 119, 252, 22, 37, 204, 144, 161, 54, 227, 139, 217, 52, 151, 197, 182, 234, 99, 221, 119, 17, 230, 124, 116, 41, 249, 86, 176, 251, 138, 143, 8, 154, 220, 75, 105, 137, 60, 193, 51, 63, 83, 237, 208, 25, 184, 119, 132, 37, 47, 236, 145, 79, 228, 133, 119, 105, 89, 75, 234, 66, 128, 211, 44, 15, 85, 191, 98, 148, 79, 19, 3, 150, 188, 110, 155, 223, 110, 189, 210, 189, 163, 103, 142, 236, 160, 198, 104, 247, 1, 179, 141, 191, 251, 56, 200, 52, 44, 226, 254, 109, 39, 250, 222, 74, 90, 72, 116, 151, 157, 212, 185, 207, 154, 222, 196, 199, 91, 5, 133, 44, 44, 15, 94, 248, 165, 193, 117, 3, 146, 249, 68, 232, 237, 100, 193, 16, 198, 182, 71, 96, 154, 164, 120, 58, 235, 156, 108, 154, 215, 85, 49, 48, 80, 99, 139, 131, 102, 92, 111, 111, 122, 130, 163, 150, 112, 42, 31, 100, 27, 130, 211, 235, 242, 57, 34, 25, 73, 31, 182, 134, 135, 44, 87, 22, 245, 10, 248, 53, 141, 154, 139, 157, 23, 195, 64, 114, 143, 127, 135, 216, 154, 24, 216, 252, 171, 103, 173, 132, 89, 12, 46, 207, 117, 147, 57, 54, 60, 7, 3, 77, 111, 96, 111, 158, 33, 224, 84, 86, 202, 229, 233, 161]

	    </c>

	    <c>Exponent</c>
	    <c>

[1, 0, 1]

	    </c>

	    <c>Private Exponent</c>
	    <c>

[18, 174, 113, 164, 105, 205, 10, 43, 195, 126, 82, 108, 69, 0, 87, 31, 29, 97, 117, 29, 100, 233, 73, 112, 123, 98, 89, 15, 157, 11, 165, 124, 150, 60, 64, 30, 63, 207, 47, 44, 211, 189, 236, 136, 229, 3, 191, 198, 67, 155, 11, 40, 200, 47, 125, 55, 151, 103, 31, 82, 19, 238, 216, 193, 90, 37, 216, 213, 206, 160, 2, 94, 227, 171, 46, 139, 127, 121, 33, 111, 198, 59, 234, 86, 39, 83, 180, 6, 68, 198, 161, 81, 39, 217, 178, 149, 69, 64, 160, 187, 225, 163, 5, 86, 152, 45, 78, 159, 222, 95, 100, 37, 241, 77, 75, 113, 52, 65, 181, 93, 199, 59, 155, 74, 237, 204, 146, 172, 227, 146, 126, 55, 245, 125, 12, 253, 94, 117, 129, 250, 81, 44, 143, 73, 97, 169, 235, 11, 128, 248, 168, 7, 70, 114, 138, 85, 255, 70, 71, 31, 52, 37, 6, 59, 157, 83, 100, 47, 94, 222, 30, 132, 214, 19, 8, 26, 250, 92, 34, 208, 81, 40, 91, 214, 59, 148, 59, 86, 93, 137, 138, 5, 104, 84, 19, 229, 60, 60, 108, 101, 37, 255, 31, 227, 78, 61, 220, 112, 240, 213, 100, 80, 253, 164, 139, 161, 46, 16, 78, 157, 235, 159, 184, 24, 129, 225, 196, 189, 242, 93, 146, 71, 244, 80, 200, 101, 146, 121, 104, 231, 115, 52, 244, 65, 79, 117, 167, 80, 225, 57, 84, 110, 58, 138, 115, 157]

	    </c>
	  </texttable>

	  <t>
	    The RSA private key (Modulus, Private Exponent) is then passed to the RSA
	    signing function, which also takes the hash type, SHA-256,
	    and the octets of the ASCII representation of the JWS Signing Input
	    as inputs.  The result of the digital signature is an octet sequence,
	    which represents a big endian integer.  In this example, it
	    is:
	  </t>
	  <t>
[112, 46, 33, 137, 67, 232, 143, 209, 30, 181, 216, 45, 191, 120, 69, 243, 65, 6, 174, 27, 129, 255, 247, 115, 17, 22, 173, 209, 113, 125, 131, 101, 109, 66, 10, 253, 60, 150, 238, 221, 115, 162, 102, 62, 81, 102, 104, 123, 0, 11, 135, 34, 110, 1, 135, 237, 16, 115, 249, 69, 229, 130, 173, 252, 239, 22, 216, 90, 121, 142, 232, 198, 109, 219, 61, 184, 151, 91, 23, 208, 148, 2, 190, 237, 213, 217, 217, 112, 7, 16, 141, 178, 129, 96, 213, 248, 4, 12, 167, 68, 87, 98, 184, 31, 190, 127, 249, 217, 46, 10, 231, 111, 36, 242, 91, 51, 187, 230, 244, 74, 230, 30, 177, 4, 10, 203, 32, 4, 77, 62, 249, 18, 142, 212, 1, 48, 121, 91, 212, 189, 59, 65, 238, 202, 208, 102, 171, 101, 25, 129, 253, 228, 141, 247, 127, 55, 45, 195, 139, 159, 175, 221, 59, 239, 177, 139, 93, 163, 204, 60, 46, 176, 47, 158, 58, 65, 214, 18, 202, 173, 21, 145, 18, 115, 160, 95, 35, 185, 232, 56, 250, 175, 132, 157, 105, 132, 41, 239, 90, 30, 136, 121, 130, 54, 195, 212, 14, 96, 69, 34, 165, 68, 200, 242, 122, 122, 45, 184, 6, 99, 209, 108, 247, 202, 234, 86, 222, 64, 92, 178, 33, 90, 69, 178, 194, 85, 102, 181, 90, 193, 167, 72, 160, 112, 223, 200, 163, 42, 70, 149, 67, 208, 25, 238, 251, 71]
	  </t>
	  <t>
	    Base64url encoding the digital signature produces this value for
	    the Encoded JWS Signature
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7
  AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4
  BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K
  0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv
  hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB
  p0igcN_IoypGlUPQGe77Rw
]]></artwork></figure>

	<t>
	  Concatenating these values in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS representation
	  using the JWS Compact Serialization
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJSUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
  cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7
  AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4
  BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K
  0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv
  hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB
  p0igcN_IoypGlUPQGe77Rw
]]></artwork></figure>

	</section>
	<section title="Decoding" anchor="RS256Decoding">

	  <t>
	    Decoding the JWS requires base64url decoding the Encoded JWS Header,
	    Encoded JWS Payload, and Encoded JWS Signature to produce the
	    JWS Header, JWS Payload, and JWS Signature octet sequences.
	    The octet sequence containing the UTF-8 representation
	    of the JWS Header is decoded into the JWS Header string.
	  </t>

	</section>
	<section title="Validating" anchor="RS256Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> parameter in the header is "RS256", we
	    validate the RSASSA-PKCS-v1_5 SHA-256 digital signature contained in the JWS Signature.
	    If any of the validation steps fail, the JWS MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  </t>
	  <t>
	    Validating the JWS Signature is a little different
	    from the previous example. First, we base64url decode the
	    Encoded JWS Signature to produce a digital signature S to check.  We
	    then pass (n, e), S and the octets of the ASCII representation of the
	    JWS Signing Input
	    to an RSASSA-PKCS-v1_5 signature verifier that has
	    been configured to use the SHA-256 hash function.
	  </t>

	</section>
      </section>

      <section title="Example JWS using ECDSA P-256 SHA-256" anchor="ES256Example">
	<section title="Encoding" anchor="ES256Encoding">
	  <t>
	    The JWS Header for this example differs from
	    the previous example because a different algorithm is
	    being used.  The JWS Header used is:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"ES256"}
]]></artwork></figure>

	  <t>
	    The following octet sequence contains the UTF-8 representation of
	    the JWS Header:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding these octets yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJFUzI1NiJ9
]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example, which
	    follows, is the same as in the previous examples.  Since
	    the Encoded JWS Payload will therefore be the same, its
	    computation is not repeated here.
	  </t>

	  <figure><artwork><![CDATA[
  {"iss":"joe",
   "exp":1300819380,
   "http://example.com/is_root":true}
]]></artwork></figure>

	  <t>
	    Concatenating the Encoded JWS Header, a period ('.') character,
	    and the Encoded JWS Payload yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJFUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	  <t>
	    The ASCII representation of the JWS Signing Input
	    is the following octet sequence:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    The ECDSA key consists of a public part, the EC point (x,
	    y), and a private part d.  The values of the ECDSA key
	    used in this example, presented as the octet sequences
	    representing three 256 bit big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>x</c>
	    <c>

[127, 205, 206, 39, 112, 246, 196, 93, 65, 131, 203, 238, 111, 219, 75, 123, 88, 7, 51, 53, 123, 233, 239, 19, 186, 207, 110, 60, 123, 209, 84, 69]

	    </c>

	    <c>y</c>
	    <c>

[199, 241, 68, 205, 27, 189, 155, 126, 135, 44, 223, 237, 185, 238, 185, 244, 179, 105, 93, 110, 169, 11, 36, 173, 138, 70, 35, 40, 133, 136, 229, 173]

	    </c>

	    <c>d</c>
	    <c>

[142, 155, 16, 158, 113, 144, 152, 191, 152, 4, 135, 223, 31, 93, 119, 233, 203, 41, 96, 110, 190, 210, 38, 59, 95, 87, 194, 19, 223, 132, 244, 178]

	    </c>
	  </texttable>

	  <t>
	    The ECDSA private part d is then passed to an ECDSA
	    signing function, which also takes the curve type, P-256,
	    the hash type, SHA-256, and the octets of the ASCII representation of
	    the JWS Signing Input
	    as inputs.  The result of the
	    digital signature is the EC point (R, S), where R and S are
	    unsigned integers.  In this example, the R and S values,
	    given as octet sequences representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>R</c>
	    <c>

[14, 209, 33, 83, 121, 99, 108, 72, 60, 47, 127, 21, 88, 7, 212, 2, 163, 178, 40, 3, 58, 249, 124, 126, 23, 129, 154, 195, 22, 158, 166, 101]

	    </c>

	    <c>S</c>
	    <c>

[197, 10, 7, 211, 140, 60, 112, 229, 216, 241, 45, 175, 8, 74, 84, 128, 166, 101, 144, 197, 242, 147, 80, 154, 143, 63, 127, 138, 131, 163, 84, 213]

	    </c>
	  </texttable>

	  <t>
	    Concatenating the S array to the end of the R array and
	    base64url encoding the result produces this value for the
	    Encoded JWS Signature
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA
  pmWQxfKTUJqPP3-Kg6NU1Q
]]></artwork></figure>

	<t>
	  Concatenating these values in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS representation
	  using the JWS Compact Serialization
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJFUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
  DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA
  pmWQxfKTUJqPP3-Kg6NU1Q
]]></artwork></figure>

	</section>
	<section title="Decoding" anchor="ES256Decoding">

	  <t>
	    Decoding the JWS requires base64url decoding the Encoded JWS Header,
	    Encoded JWS Payload, and Encoded JWS Signature to produce the
	    JWS Header, JWS Payload, and JWS Signature octet sequences.
	    The octet sequence containing the UTF-8 representation
	    of the JWS Header is decoded into the JWS Header string.
	  </t>

	</section>
	<section title="Validating" anchor="ES256Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> parameter in the header is "ES256", we
	    validate the ECDSA P-256 SHA-256 digital signature contained in
	    the JWS Signature.
	    If any of the validation steps fail, the JWS MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  </t>
	  <t>
	    Validating the JWS Signature is a little different
	    from the first example. First, we base64url decode the Encoded JWS Signature as in the previous examples but we then
	    need to split the 64 member octet sequence that must result
	    into two 32 octet sequences, the first R and the second S. We
	    then pass (x, y), (R, S) and the octets of the ASCII representation of
	    the JWS Signing Input
	    to an ECDSA signature verifier that
	    has been configured to use the P-256 curve with the
	    SHA-256 hash function.
	  </t>
	  <t>
	    As explained in Section 3.4 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification, the
	    use of the K value in ECDSA means that we cannot validate
	    the correctness of the digital signature in the same way we
	    validated the correctness of the HMAC. Instead,
	    implementations MUST use an ECDSA validator to validate
	    the digital signature.
	  </t>

	</section>
      </section>


      <section title="Example JWS using ECDSA P-521 SHA-512" anchor="ES512Example">
	<section title="Encoding" anchor="ES512Encoding">
	  <t>
	    The JWS Header for this example differs from
	    the previous example because a different ECDSA curve
	    and hash function are used.  The JWS Header used is:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"ES512"}
]]></artwork></figure>

	  <t>
	    The following octet sequence contains the UTF-8 representation of
	    the JWS Header:
	  </t>
	  <t>
[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 53, 49, 50, 34, 125]
	  </t>
	  <t>
	    Base64url encoding these octets yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJFUzUxMiJ9
]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example, is the ASCII string "Payload".
	    The representation of this string is the octet sequence:
	  </t>
	  <t>
[80, 97, 121, 108, 111, 97, 100]
	  </t>
	  <t>
	    Base64url encoding these octets yields the Encoded JWS Payload value:
	  </t>

	  <figure><artwork><![CDATA[
  UGF5bG9hZA
]]></artwork></figure>

	  <t>
	    Concatenating the Encoded JWS Header, a period ('.') character,
	    and the Encoded JWS Payload yields this JWS Signing Input
	    value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJFUzUxMiJ9.UGF5bG9hZA
]]></artwork></figure>

	  <t>
	    The ASCII representation of the JWS Signing Input
	    is the following octet sequence:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 85, 120, 77, 105, 74, 57, 46, 85, 71, 70, 53, 98, 71, 57, 104, 90, 65]
	  </t>
	  <t>
	    The ECDSA key consists of a public part, the EC point (x,
	    y), and a private part d.  The values of the ECDSA key
	    used in this example, presented as the octet sequences
	    representing three 521 bit big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>x</c>
	    <c>
[1, 233, 41, 5, 15, 18, 79, 198,
 188, 85, 199, 213, 57, 51, 101, 223, 157, 239, 74, 176, 194, 44, 178, 87,
 152, 249, 52, 235, 4, 227, 198, 186, 227, 112, 26, 87, 167, 145, 14, 157,
 129, 191, 54, 49, 89, 232, 235, 203, 21, 93, 99, 73, 244, 189, 182, 204,
 248, 169, 76, 92, 89, 199, 170, 193, 1, 164]
	    </c>

	    <c>y</c>
	    <c>
[0, 52, 166, 68, 14, 55,
 103, 80, 210, 55, 31, 209, 189, 194, 200, 243, 183, 29, 47, 78, 229, 234,
 52, 50, 200, 21, 204, 163, 21, 96, 254, 93, 147, 135, 236, 119, 75, 85,
 131, 134, 48, 229, 203, 191, 90, 140, 190, 10, 145, 221, 0, 100, 198, 153,
 154, 31, 110, 110, 103, 250, 221, 237, 228, 200, 200, 246]
	    </c>

	    <c>d</c>
	    <c>
[1, 142, 105, 111,
 176, 52, 80, 88, 129, 221, 17, 11, 72, 62, 184, 125, 50, 206, 73, 95,
 227, 107, 55, 69, 237, 242, 216, 202, 228, 240, 242, 83, 159, 70, 21, 160,
 233, 142, 171, 82, 179, 192, 197, 234, 196, 206, 7, 81, 133, 168, 231, 187,
 71, 222, 172, 29, 29, 231, 123, 204, 246, 97, 53, 230, 61, 130]
	    </c>
	  </texttable>

	  <t>
	    The ECDSA private part d is then passed to an ECDSA
	    signing function, which also takes the curve type, P-521,
	    the hash type, SHA-512, and the octets of the ASCII representation of
	    the JWS Signing Input
	    as inputs.  The result of the
	    digital signature is the EC point (R, S), where R and S are
	    unsigned integers.  In this example, the R and S values,
	    given as octet sequences representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>R</c>
	    <c>
[1, 220, 12, 129, 231, 171, 194, 209, 232, 135, 233, 117, 247, 105, 122, 210,
 26, 125, 192, 1, 217, 21, 82, 91, 45, 240, 255, 83, 19, 34, 239, 71,
 48, 157, 147, 152, 105, 18, 53, 108, 163, 214, 68, 231, 62, 153, 150, 106,
 194, 164, 246, 72, 143, 138, 24, 50, 129, 223, 133, 206, 209, 172, 63, 237,
 119, 109]
	    </c>

	    <c>S</c>
	    <c>
[0, 111, 6, 105, 44, 5, 41, 208, 128, 61, 152, 40, 92, 61,
 152, 4, 150, 66, 60, 69, 247, 196, 170, 81, 193, 199, 78, 59, 194, 169,
 16, 124, 9, 143, 42, 142, 131, 48, 206, 238, 34, 175, 83, 203, 220, 159,
 3, 107, 155, 22, 27, 73, 111, 68, 68, 21, 238, 144, 229, 232, 148, 188,
 222, 59, 242, 103]
	    </c>
	  </texttable>

	  <t>
	    Concatenating the S array to the end of the R array and
	    base64url encoding the result produces this value for the
	    Encoded JWS Signature
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  AdwMgeerwtHoh-l192l60hp9wAHZFVJbLfD_UxMi70cwnZOYaRI1bKPWROc-mZZq
  wqT2SI-KGDKB34XO0aw_7XdtAG8GaSwFKdCAPZgoXD2YBJZCPEX3xKpRwcdOO8Kp
  EHwJjyqOgzDO7iKvU8vcnwNrmxYbSW9ERBXukOXolLzeO_Jn
]]></artwork></figure>

	<t>
	  Concatenating these values in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS representation
	  using the JWS Compact Serialization
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJFUzUxMiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
  AdwMgeerwtHoh-l192l60hp9wAHZFVJbLfD_UxMi70cwnZOYaRI1bKPWROc-mZZq
  wqT2SI-KGDKB34XO0aw_7XdtAG8GaSwFKdCAPZgoXD2YBJZCPEX3xKpRwcdOO8Kp
  EHwJjyqOgzDO7iKvU8vcnwNrmxYbSW9ERBXukOXolLzeO_Jn
]]></artwork></figure>

	</section>
	<section title="Decoding" anchor="ES512Decoding">

	  <t>
	    Decoding the JWS requires base64url decoding the Encoded JWS Header,
	    Encoded JWS Payload, and Encoded JWS Signature to produce the
	    JWS Header, JWS Payload, and JWS Signature octet sequences.
	    The octet sequence containing the UTF-8 representation
	    of the JWS Header is decoded into the JWS Header string.
	  </t>

	</section>
	<section title="Validating" anchor="ES512Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> parameter in the header is "ES512", we
	    validate the ECDSA P-521 SHA-512 digital signature contained in
	    the JWS Signature.
	    If any of the validation steps fail, the JWS MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  </t>
	  <t>
	    Validating the JWS Signature is similar to the previous example.
	    First, we base64url decode the Encoded JWS Signature as in the previous examples but we then
	    need to split the 132 member octet sequence that must result
	    into two 66 octet sequences, the first R and the second S. We
	    then pass (x, y), (R, S) and the octets of the ASCII representation of
	    the JWS Signing Input
	    to an ECDSA signature verifier that
	    has been configured to use the P-521 curve with the
	    SHA-512 hash function.
	  </t>
	  <t>
	    As explained in Section 3.4 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification, the
	    use of the K value in ECDSA means that we cannot validate
	    the correctness of the digital signature in the same way we
	    validated the correctness of the HMAC. Instead,
	    implementations MUST use an ECDSA validator to validate
	    the digital signature.
	  </t>

	</section>
      </section>

      <section title="Example Plaintext JWS" anchor="ExamplePlaintextJWS">

	<t>
	  The following example JWS Header declares that the
	  encoded object is a Plaintext JWS:
	</t>

	<figure><artwork><![CDATA[
  {"alg":"none"}
]]></artwork></figure>

	<t>
	  Base64url encoding the octets of the UTF-8 representation of
	  the JWS Header yields this Encoded JWS Header:
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJub25lIn0
]]></artwork></figure>

	<t>
	  The JWS Payload used in this example, which
	  follows, is the same as in the previous examples.  Since
	  the Encoded JWS Payload will therefore be the same, its
	  computation is not repeated here.
	</t>

	<figure><artwork><![CDATA[
  {"iss":"joe",
   "exp":1300819380,
   "http://example.com/is_root":true}
]]></artwork></figure>

	<t>
	  The Encoded JWS Signature is the empty string.
	</t>

	<t>
	  Concatenating these parts in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS (with line breaks for
	  display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJub25lIn0
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
]]></artwork></figure>
      </section>

      <section title="Example JWS Using JWS JSON Serialization" anchor="JSONSerializationExample">
	<t>
	  This section contains an example using the JWS JSON Serialization.
	  This example demonstrates the capability for
	  conveying multiple digital signatures and/or MACs for the
	  same payload.
	</t>
	<t>
	  The Encoded JWS Payload used in this example is the same as
	  that used in the examples in <xref target="RS256Example"/>
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	<t>
	  Two digital signatures are used in this example: both using
	  RSASSA-PKCS-v1_5 SHA-256.
	  For the first, the JWS Protected Header and key
	  are the same as in <xref target="RS256Example"/>,
	  resulting in the same JWS Signature value;
	  therefore, its computation is not repeated here.
	  For the second a different key is used, which is
	  provided in <xref target="RS256_2_Key"/>;
	  its computation follows the same procedure as the first,
	  so it is not detailed here either, other than including
	  the resulting Encoded JWS Signature value.
	</t>

	<section title="JWS Protected Header" anchor="JSProtectedHeader">

	  <t>
	    The JWS Protected Header value used for both computations is:
	  </t>
	  
	  <figure><artwork><![CDATA[
  {"alg":"RS256"}
]]></artwork></figure>

	  <t>
	    Base64url encoding these octets yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSUzI1NiJ9
]]></artwork></figure>
	</section>

	<section title="JWS Per-Signature Unprotected Headers" anchor="JSRecipientHeaders">
	  <t>
	    Key ID values are supplied for both keys using per-signature
	    header parameters.
	    The two values used to represent these Key IDs are:
	  </t>

	  <figure><artwork><![CDATA[
  {"kid":"2010-12-29"}
]]></artwork></figure>

	  <t>
	    and:
	  </t>

	  <figure><artwork><![CDATA[
  {"kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"}
]]></artwork></figure>
	</section>

	<section title="Complete JWS Header Values" anchor="JSHeader">
	  <t>
	    Combining the protected and per-signature header values
	    supplied, the JWS Header values used for the first and second
	    signatures respectively are:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RS256",
   "kid":"2010-12-29"}
]]></artwork></figure>

	  <t>
	    and:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RS256",
   "kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"}
]]></artwork></figure>

	</section>


	<section title="Complete JWS JSON Serialization Representation" anchor="JSComplete">

	  <t>
	    The complete JSON Web Signature JSON Serialization
	    for these values is as follows
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  {"protected":"eyJhbGciOiJSUzI1NiJ9",
   "payload":
    "eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGF
     tcGxlLmNvbS9pc19yb290Ijp0cnVlfQ",
   "signatures":[
    {"header":
      {"kid":"2010-12-29"},
     "signature":
      "cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZ
       mh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjb
       KBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHl
       b1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZES
       c6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AX
       LIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw"},
    {"header":
      {"kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"},
     "signature":
      "m2nhGPQGjPEDIotJnzcnlhUZnXeg0xzLVbh6NZzthY8yU3klJYaENE1aLAUtL
       cq-TmEeYIr30ruGH2kNFqW4-oc7LcTQu9-7ItRhfi0kKeN1zNAAUemfNYXaXA
       1JayiiCl7m9ylhLKIsvdXhFvV7XDSbUMnVoO9Yu5_ROKOJMkeU6ywR8DDcHmu
       B2KcLMfpHn1FqnUnojxwfOg1Eqyb_ppeDTm9t_h8FoQgHqRpNgsTTvxI9vSPE
       ZrWTkSf_D4ci6p06DM_nE6FbptYF3ENHF8NpGgncv_D_h9AIrZU5-6ee2HB24
       jtN9qOHw2pkVrvhtxdsSJdeG6uJqiFs0ArwQQ"}]
  }
]]></artwork></figure>
	</section>

	<section anchor="RS256_2_Key" title="RSA Key Used for Second Signature">
	  <t>
	    The values of the RSA key used for the second signature in this
	    this example, presented as the octet sequences representing
	    big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>Modulus</c>
	    <c>

[160, 120, 137, 109, 191, 13, 24, 29, 15, 217, 68, 35, 164, 152, 33, 179,
 62, 22, 51, 134, 60, 228, 112, 172, 11, 62, 57, 16, 26, 162, 213, 250,
 199, 183, 56, 103, 101, 172, 20, 178, 226, 124, 116, 135, 195, 195, 124, 91,
 174, 65, 218, 196, 113, 82, 132, 161, 145, 71, 8, 117, 240, 109, 116, 40,
 196, 26, 174, 135, 43, 175, 40, 166, 223, 157, 5, 188, 92, 7, 52, 219,
 11, 157, 96, 99, 25, 65, 151, 108, 25, 104, 206, 147, 63, 1, 157, 154,
 58, 111, 200, 251, 54, 202, 96, 220, 42, 196, 21, 252, 193, 58, 205, 44,
 89, 217, 58, 164, 99, 3, 76, 195, 180, 76, 19, 103, 110, 26, 2, 122,
 173, 211, 45, 218, 134, 212, 26, 198, 156, 110, 213, 139, 31, 135, 227, 43,
 0, 45, 192, 39, 206, 176, 194, 154, 217, 10, 185, 227, 143, 142, 179, 117,
 171, 238, 187, 88, 12, 185, 36, 110, 100, 76, 34, 39, 20, 145, 184, 44,
 14, 100, 21, 77, 15, 82, 150, 53, 156, 46, 196, 231, 156, 152, 152, 85,
 145, 184, 195, 213, 134, 107, 75, 10, 117, 233, 76, 215, 62, 205, 95, 170,
 6, 234, 221, 139, 4, 241, 239, 203, 28, 32, 95, 192, 24, 164, 172, 132,
 10, 193, 239, 45, 140, 153, 198, 140, 117, 17, 223, 12, 26, 5, 47, 223,
 211, 151, 120, 15, 230, 60, 42, 51, 104, 119, 46, 41, 242, 177, 76, 33]

	    </c>

	    <c>Exponent</c>
	    <c>

[1, 0, 1]

	    </c>

	    <c>Private Exponent</c>
	    <c>

[118, 50, 242, 255, 124, 119, 87, 168, 168, 112, 223, 168, 229, 103, 13, 131,
 170, 154, 205, 206, 245, 241, 74, 48, 223, 131, 48, 162, 245, 11, 182, 83,
 167, 98, 4, 208, 220, 106, 25, 64, 254, 100, 175, 173, 4, 252, 108, 16,
 87, 213, 184, 31, 116, 93, 84, 198, 113, 109, 2, 5, 101, 88, 41, 244,
 145, 38, 26, 34, 4, 130, 91, 142, 55, 45, 192, 248, 210, 76, 152, 153,
 51, 255, 242, 236, 107, 193, 13, 153, 25, 74, 66, 198, 224, 228, 254, 194,
 136, 130, 168, 102, 170, 31, 253, 162, 142, 121, 170, 188, 103, 84, 57, 166,
 142, 115, 220, 167, 19, 43, 110, 18, 197, 46, 56, 40, 186, 71, 188, 68,
 152, 43, 159, 81, 123, 128, 103, 167, 243, 139, 188, 90, 36, 142, 151, 217,
 213, 244, 149, 183, 9, 16, 149, 119, 233, 161, 201, 107, 151, 185, 157, 124,
 238, 147, 50, 51, 170, 188, 190, 154, 92, 239, 46, 37, 178, 49, 74, 209,
 220, 56, 19, 186, 34, 52, 152, 130, 86, 56, 237, 1, 186, 225, 244, 29,
 248, 57, 21, 1, 10, 55, 176, 110, 145, 149, 4, 137, 13, 121, 236, 87,
 186, 48, 218, 3, 78, 218, 2, 244, 95, 168, 218, 217, 247, 252, 81, 13,
 22, 210, 219, 26, 149, 32, 217, 211, 144, 231, 104, 240, 69, 73, 237, 1,
 14, 28, 161, 202, 222, 209, 156, 108, 27, 207, 126, 40, 77, 102, 93, 1]

	    </c>
	  </texttable>
	</section>
      </section>

    </section>

    <section title='"x5c" (X.509 Certificate Chain) Example' anchor="x5cExample">
      <t>
	The JSON array below is an example of a certificate chain
	that could be used as the value of an
	<spanx style="verb">x5c</spanx> (X.509 Certificate Chain) header parameter,
	per <xref target="x5cDef"/>.
	Note that since these strings contain base64 encoded (not base64url encoded)
	values, they are allowed to contain white space and line breaks.
      </t>

      <figure><artwork><![CDATA[
  ["MIIE3jCCA8agAwIBAgICAwEwDQYJKoZIhvcNAQEFBQAwYzELMAkGA1UEBhMCVVM
    xITAfBgNVBAoTGFRoZSBHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR2
    8gRGFkZHkgQ2xhc3MgMiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNjExM
    TYwMTU0MzdaFw0yNjExMTYwMTU0MzdaMIHKMQswCQYDVQQGEwJVUzEQMA4GA1UE
    CBMHQXJpem9uYTETMBEGA1UEBxMKU2NvdHRzZGFsZTEaMBgGA1UEChMRR29EYWR
    keS5jb20sIEluYy4xMzAxBgNVBAsTKmh0dHA6Ly9jZXJ0aWZpY2F0ZXMuZ29kYW
    RkeS5jb20vcmVwb3NpdG9yeTEwMC4GA1UEAxMnR28gRGFkZHkgU2VjdXJlIENlc
    nRpZmljYXRpb24gQXV0aG9yaXR5MREwDwYDVQQFEwgwNzk2OTI4NzCCASIwDQYJ
    KoZIhvcNAQEBBQADggEPADCCAQoCggEBAMQt1RWMnCZM7DI161+4WQFapmGBWTt
    wY6vj3D3HKrjJM9N55DrtPDAjhI6zMBS2sofDPZVUBJ7fmd0LJR4h3mUpfjWoqV
    Tr9vcyOdQmVZWt7/v+WIbXnvQAjYwqDL1CBM6nPwT27oDyqu9SoWlm2r4arV3aL
    GbqGmu75RpRSgAvSMeYddi5Kcju+GZtCpyz8/x4fKL4o/K1w/O5epHBp+YlLpyo
    7RJlbmr2EkRTcDCVw5wrWCs9CHRK8r5RsL+H0EwnWGu1NcWdrxcx+AuP7q2BNgW
    JCJjPOq8lh8BJ6qf9Z/dFjpfMFDniNoW1fho3/Rb2cRGadDAW/hOUoz+EDU8CAw
    EAAaOCATIwggEuMB0GA1UdDgQWBBT9rGEyk2xF1uLuhV+auud2mWjM5zAfBgNVH
    SMEGDAWgBTSxLDSkdRMEXGzYcs9of7dqGrU4zASBgNVHRMBAf8ECDAGAQH/AgEA
    MDMGCCsGAQUFBwEBBCcwJTAjBggrBgEFBQcwAYYXaHR0cDovL29jc3AuZ29kYWR
    keS5jb20wRgYDVR0fBD8wPTA7oDmgN4Y1aHR0cDovL2NlcnRpZmljYXRlcy5nb2
    RhZGR5LmNvbS9yZXBvc2l0b3J5L2dkcm9vdC5jcmwwSwYDVR0gBEQwQjBABgRVH
    SAAMDgwNgYIKwYBBQUHAgEWKmh0dHA6Ly9jZXJ0aWZpY2F0ZXMuZ29kYWRkeS5j
    b20vcmVwb3NpdG9yeTAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggE
    BANKGwOy9+aG2Z+5mC6IGOgRQjhVyrEp0lVPLN8tESe8HkGsz2ZbwlFalEzAFPI
    UyIXvJxwqoJKSQ3kbTJSMUA2fCENZvD117esyfxVgqwcSeIaha86ykRvOe5GPLL
    5CkKSkB2XIsKd83ASe8T+5o0yGPwLPk9Qnt0hCqU7S+8MxZC9Y7lhyVJEnfzuz9
    p0iRFEUOOjZv2kWzRaJBydTXRE4+uXR21aITVSzGh6O1mawGhId/dQb8vxRMDsx
    uxN89txJx9OjxUUAiKEngHUuHqDTMBqLdElrRhjZkAzVvb3du6/KFUJheqwNTrZ
    EjYx8WnM25sgVjOuH0aBsXBTWVU+4=",
   "MIIE+zCCBGSgAwIBAgICAQ0wDQYJKoZIhvcNAQEFBQAwgbsxJDAiBgNVBAcTG1Z
    hbGlDZXJ0IFZhbGlkYXRpb24gTmV0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIE
    luYy4xNTAzBgNVBAsTLFZhbGlDZXJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb
    24gQXV0aG9yaXR5MSEwHwYDVQQDExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8x
    IDAeBgkqhkiG9w0BCQEWEWluZm9AdmFsaWNlcnQuY29tMB4XDTA0MDYyOTE3MDY
    yMFoXDTI0MDYyOTE3MDYyMFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRoZS
    BHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR28gRGFkZHkgQ2xhc3MgM
    iBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAwDQYJKoZIhvcNAQEBBQADggEN
    ADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWizV3GgXne77ZtJ6XC
    APVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HFiH7Eux
    6wwdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLO
    tXiEqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWo
    riMYavx4A6lNf4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZ
    Eewo+YihfukEHU1jPEX44dMX4/7VpkI+EdOqXG68CAQOjggHhMIIB3TAdBgNVHQ
    4EFgQU0sSw0pHUTBFxs2HLPaH+3ahq1OMwgdIGA1UdIwSByjCBx6GBwaSBvjCBu
    zEkMCIGA1UEBxMbVmFsaUNlcnQgVmFsaWRhdGlvbiBOZXR3b3JrMRcwFQYDVQQK
    Ew5WYWxpQ2VydCwgSW5jLjE1MDMGA1UECxMsVmFsaUNlcnQgQ2xhc3MgMiBQb2x
    pY3kgVmFsaWRhdGlvbiBBdXRob3JpdHkxITAfBgNVBAMTGGh0dHA6Ly93d3cudm
    FsaWNlcnQuY29tLzEgMB4GCSqGSIb3DQEJARYRaW5mb0B2YWxpY2VydC5jb22CA
    QEwDwYDVR0TAQH/BAUwAwEB/zAzBggrBgEFBQcBAQQnMCUwIwYIKwYBBQUHMAGG
    F2h0dHA6Ly9vY3NwLmdvZGFkZHkuY29tMEQGA1UdHwQ9MDswOaA3oDWGM2h0dHA
    6Ly9jZXJ0aWZpY2F0ZXMuZ29kYWRkeS5jb20vcmVwb3NpdG9yeS9yb290LmNybD
    BLBgNVHSAERDBCMEAGBFUdIAAwODA2BggrBgEFBQcCARYqaHR0cDovL2NlcnRpZ
    mljYXRlcy5nb2RhZGR5LmNvbS9yZXBvc2l0b3J5MA4GA1UdDwEB/wQEAwIBBjAN
    BgkqhkiG9w0BAQUFAAOBgQC1QPmnHfbq/qQaQlpE9xXUhUaJwL6e4+PrxeNYiY+
    Sn1eocSxI0YGyeR+sBjUZsE4OWBsUs5iB0QQeyAfJg594RAoYC5jcdnplDQ1tgM
    QLARzLrUc+cb53S8wGd9D0VmsfSxOaFIqII6hR8INMqzW/Rn453HWkrugp++85j
    09VZw==",
   "MIIC5zCCAlACAQEwDQYJKoZIhvcNAQEFBQAwgbsxJDAiBgNVBAcTG1ZhbGlDZXJ
    0IFZhbGlkYXRpb24gTmV0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIEluYy4xNT
    AzBgNVBAsTLFZhbGlDZXJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb24gQXV0a
    G9yaXR5MSEwHwYDVQQDExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8xIDAeBgkq
    hkiG9w0BCQEWEWluZm9AdmFsaWNlcnQuY29tMB4XDTk5MDYyNjAwMTk1NFoXDTE
    5MDYyNjAwMTk1NFowgbsxJDAiBgNVBAcTG1ZhbGlDZXJ0IFZhbGlkYXRpb24gTm
    V0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIEluYy4xNTAzBgNVBAsTLFZhbGlDZ
    XJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb24gQXV0aG9yaXR5MSEwHwYDVQQD
    ExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8xIDAeBgkqhkiG9w0BCQEWEWluZm9
    AdmFsaWNlcnQuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDOOnHK5a
    vIWZJV16vYdA757tn2VUdZZUcOBVXc65g2PFxTXdMwzzjsvUGJ7SVCCSRrCl6zf
    N1SLUzm1NZ9WlmpZdRJEy0kTRxQb7XBhVQ7/nHk01xC+YDgkRoKWzk2Z/M/VXwb
    P7RfZHM047QSv4dk+NoS/zcnwbNDu+97bi5p9wIDAQABMA0GCSqGSIb3DQEBBQU
    AA4GBADt/UG9vUJSZSWI4OB9L+KXIPqeCgfYrx+jFzug6EILLGACOTb2oWH+heQ
    C1u+mNr0HZDzTuIYEZoDJJKPTEjlbVUjP9UNV+mWwD5MlM/Mtsq2azSiGM5bUMM
    j4QssxsodyamEwCW/POuZ6lcg5Ktz885hZo+L7tdEy8W9ViH0Pd"]
]]></artwork></figure>
    </section>


    <section title="Notes on implementing base64url encoding without padding" anchor="base64urlnotes">

      <t>
	This appendix describes how to implement base64url encoding
	and decoding functions without padding based upon standard
	base64 encoding and decoding functions that do use padding.
      </t>
      <t>
	To be concrete, example C# code implementing these functions
	is shown below.  Similar code could be used in other
	languages.
      </t>

      <figure><artwork><![CDATA[
  static string base64urlencode(byte [] arg)
  {
    string s = Convert.ToBase64String(arg); // Regular base64 encoder
    s = s.Split('=')[0]; // Remove any trailing '='s
    s = s.Replace('+', '-'); // 62nd char of encoding
    s = s.Replace('/', '_'); // 63rd char of encoding
    return s;
  }

  static byte [] base64urldecode(string arg)
  {
    string s = arg;
    s = s.Replace('-', '+'); // 62nd char of encoding
    s = s.Replace('_', '/'); // 63rd char of encoding
    switch (s.Length % 4) // Pad with trailing '='s
    {
      case 0: break; // No pad chars in this case
      case 2: s += "=="; break; // Two pad chars
      case 3: s += "="; break; // One pad char
      default: throw new System.Exception(
        "Illegal base64url string!");
    }
    return Convert.FromBase64String(s); // Standard base64 decoder
  }
]]></artwork></figure>

      <t>
	As per the example code above, the number of '=' padding
	characters that needs to be added to the end of a base64url
	encoded string without padding to turn it into one with
	padding is a deterministic function of the length of the
	encoded string.  Specifically,

	if the length mod 4 is 0, no padding is added;
	if the length mod 4 is 2, two '=' padding characters are added;
	if the length mod 4 is 3, one '=' padding character is added;
	if the length mod 4 is 1, the input is malformed.
      </t>
      <t>
	An example correspondence between unencoded and encoded values
	follows.  The octet sequence below encodes into the string
	below, which when decoded, reproduces the octet sequence.
      </t>

      <figure><artwork>3 236 255 224 193</artwork></figure>

      <figure><artwork>A-z_4ME</artwork></figure>
    </section>

    <section title='Negative Test Case for "crit" Header Parameter' anchor="critTest">
      <t>
	Conforming implementations must reject input containing critical extensions
	that are not understood or cannot be processed.  The following JWS must
	be rejected by all implementations, because it uses an extension
	header parameter name <spanx style="verb">http://example.com/UNDEFINED</spanx>
	that they do not understand.
	Any other similar input, in which the use of the value
	<spanx style="verb">http://example.com/UNDEFINED</spanx> is substituted for
	any other header parameter name not understood by the implementation,
	must also be rejected.

	<figure>
	  <preamble>
	    The JWS Header value for this JWS is:
	  </preamble>
	  <artwork><![CDATA[
  {"alg":"none",
   "crit":["http://example.com/UNDEFINED"],
   "http://example.com/UNDEFINED":true
  }
]]></artwork>
	</figure>

	<figure>
	  <preamble>
	    The complete JWS that must be rejected is as follows
	    (with line breaks for display purposes only):
	  </preamble>
	  <artwork><![CDATA[
  eyJhbGciOiJub25lIiwNCiAiY3JpdCI6WyJodHRwOi8vZXhhbXBsZS5jb20vVU5ERU
  ZJTkVEIl0sDQogImh0dHA6Ly9leGFtcGxlLmNvbS9VTkRFRklORUQiOnRydWUNCn0.
  RkFJTA.
]]></artwork>
	</figure>
      </t>
    </section>

    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>
	Solutions for signing JSON content were previously explored by
	<xref target="MagicSignatures">Magic Signatures</xref>, <xref
	target="JSS">JSON Simple Sign</xref>, and <xref
	target="CanvasApp">Canvas Applications</xref>, all of which
	influenced this draft.
      </t>
      <t>
	Thanks to Axel Nennker for his early implementation
	and feedback on the JWS and JWE specifications.
      </t>
      <t>
        This specification is the work of the JOSE Working Group,
	which includes dozens of active and dedicated participants.
	In particular, the following individuals contributed ideas,
        feedback, and wording that influenced this specification:
      </t>
      <t>
	Dirk Balfanz,
	Richard Barnes,
	Brian Campbell,
	Breno de Medeiros,
	Dick Hardt,
	Joe Hildebrand,
	Jeff Hodges,
	Edmund Jay,
	Yaron Y. Goland,
	Ben Laurie,
	James Manger,
	Matt Miller,
	Tony Nadalin,
	Axel Nennker,
	John Panzer,
	Emmanuel Raviart,
	Eric Rescorla,
	Jim Schaad,
	Paul Tarjan,
	Hannes Tschofenig,
	and Sean Turner.
      </t>
      <t>
	Jim Schaad and Karen O'Donoghue chaired the JOSE working group and
	Sean Turner and Stephen Farrell served as Security area directors
	during the creation of this specification.
      </t>
    </section>

    <section title="Document History" anchor="History">
      <t>
	[[ to be removed by the RFC editor before publication as an RFC ]]
      </t>

      <t>
	-11
	<list style='symbols'>
	  <t>
	    Added Key Identification section.
	  </t>
	  <t>
	    For the JWS JSON Serialization, enable header parameter values
	    to be specified in any of three parameters:
	    the <spanx style="verb">protected</spanx> member that is
	    integrity protected and shared among all recipients,
	    the <spanx style="verb">unprotected</spanx> member that is
	    not integrity protected and shared among all recipients,
	    and the <spanx style="verb">header</spanx> member that is
	    not integrity protected and specific to a particular recipient.
	    (This does not affect the JWS Compact Serialization, in which all
	    header parameter values are in a single integrity protected JWE Header value.)
	  </t>
	  <t>
	    Removed suggested compact serialization for multiple
	    digital signatures and/or MACs.
	  </t>
	  <t>
	    Changed the MIME type name <spanx style="verb">application/jws-js</spanx>
	    to <spanx style="verb">application/jws+json</spanx>,
	    addressing issue #22.
	  </t>
	  <t>
	    Tightened the description of the
	    <spanx style="verb">crit</spanx> (critical) header parameter.
	  </t>
	  <t>
	    Added a negative test case for the
	    <spanx style="verb">crit</spanx> header parameter
	  </t>
	</list>
      </t>
      <t>
	-10
	<list style='symbols'>
	  <t>
	    Added an appendix suggesting a possible compact serialization
	    for JWSs with multiple digital signatures and/or MACs.
	  </t>
	</list>
      </t>
      <t>
	-09
	<list style='symbols'>
	  <t>
	    Added JWS JSON Serialization, as specified by
	    draft-jones-jose-jws-json-serialization-04.
	  </t>
	  <t>
	    Registered <spanx style="verb">application/jws-js</spanx> MIME type
	    and <spanx style="verb">JWS-JS</spanx> typ header parameter value.
	  </t>
	  <t>
	    Defined that the default action for header parameters that
	    are not understood is to ignore them unless specifically
	    designated as "MUST be understood" or included in the new
	    <spanx style="verb">crit</spanx> (critical) header parameter list.
	    This addressed issue #6.
	  </t>
	  <t>
	    Changed term "JWS Secured Input" to "JWS Signing Input".
	  </t>
	  <t>
	    Changed from using the term "byte" to "octet" when referring to 8 bit values.
	  </t>
	  <t>
	    Changed member name from <spanx style="verb">recipients</spanx> to
	    <spanx style="verb">signatures</spanx> in the JWS JSON Serialization.
	  </t>
	  <t>
	    Added complete values using the JWS Compact Serialization
	    for all examples.
	  </t>
	</list>
      </t>
      <t>
	-08
	<list style='symbols'>
	  <t>
	    Applied editorial improvements suggested by
	    Jeff Hodges and Hannes Tschofenig.
	    Many of these simplified the terminology used.
	  </t>
	  <t>
	    Clarified statements of the form "This header parameter is OPTIONAL"
	    to "Use of this header parameter is OPTIONAL".
	  </t>
	  <t>
	    Added a Header Parameter Usage Location(s) field to the
	    IANA JSON Web Signature and Encryption Header Parameters registry.
	  </t>
	  <t>
	    Added seriesInfo information to Internet Draft references.
	  </t>
	</list>
      </t>
      <t>
	-07
	<list style='symbols'>
	  <t>
	    Updated references.
	  </t>
	</list>
      </t>
      <t>
	-06
	<list style='symbols'>
	  <t>
	    Changed <spanx style="verb">x5c</spanx> (X.509 Certificate Chain)
	    representation from being a single string to being an array of strings,
	    each containing a single base64 encoded DER certificate value,
	    representing elements of the certificate chain.
	  </t>
	  <t>
	    Applied changes made by the RFC Editor to RFC 6749's registry language
	    to this specification.
	  </t>
	</list>
      </t>
      <t>
	-05
	<list style='symbols'>
	  <t>
	    Added statement that
	    "StringOrURI values are compared as case-sensitive strings
	    with no transformations or canonicalizations applied".
	  </t>
	  <t>
	    Indented artwork elements to better distinguish them from the body text.
	  </t>
	</list>
      </t>
      <t>
	-04
	<list style='symbols'>
	  <t>
	    Completed JSON Security Considerations section, including
	    considerations about rejecting input with duplicate member names.
	  </t>
	  <t>
	    Completed security considerations on the use of a SHA-1 hash when computing
	    <spanx style="verb">x5t</spanx> (x.509 certificate thumbprint) values.
	  </t>
	  <t>
	    Refer to the registries as the primary sources of defined
	    values and then secondarily reference the sections
	    defining the initial contents of the registries.
	  </t>
	  <t>
	    Normatively reference
	    <xref target="W3C.CR-xmldsig-core2-20120124">XML DSIG 2.0</xref>
	    for its security considerations.
	  </t>
	  <t>
	    Added this language to Registration Templates:
	    "This name is case sensitive.  Names that match other registered names
	    in a case insensitive manner SHOULD NOT be accepted."
	  </t>
	  <t>
	    Reference draft-jones-jose-jws-json-serialization
	    instead of draft-jones-json-web-signature-json-serialization.
	  </t>
	  <t>
	    Described additional open issues.
	  </t>
	  <t>
	    Applied editorial suggestions.
	  </t>
	</list>
      </t>
      <t>
        -03
        <list style='symbols'>
	  <t>
	    Added the <spanx style="verb">cty</spanx> (content type) header parameter
	    for declaring type information about the secured content,
	    as opposed to the <spanx style="verb">typ</spanx> (type) header parameter,
	    which declares type information about this object.
	  </t>
	  <t>
	    Added "Collision Resistant Namespace" to the terminology section.
	  </t>
	  <t>
	    Reference ITU.X690.1994 for DER encoding.
	  </t>
	  <t>
	    Added an example JWS using ECDSA P-521 SHA-512.  This has particular
	    illustrative value because of the use of the 521 bit integers
	    in the key and signature values.
	    This is also an example in which the payload is not a base64url
	    encoded JSON object.
	  </t>
	  <t>
	    Added an example <spanx style="verb">x5c</spanx> value.
	  </t>
	  <t>
	    No longer say "the UTF-8 representation of the JWS Secured Input
	    (which is the same as the ASCII representation)".  Just call it
	    "the ASCII representation of the JWS Secured Input".
	  </t>
	  <t>
	    Added Registration Template sections for defined registries.
	  </t>
	  <t>
	    Added Registry Contents sections to populate registry values.
	  </t>
	  <t>
	    Changed name of the JSON Web Signature and Encryption "typ" Values registry
	    to be the JSON Web Signature and Encryption Type Values registry, since
	    it is used for more than just values of the
	    <spanx style="verb">typ</spanx> parameter.
	  </t>
	  <t>
	    Moved registries
	    JSON Web Signature and Encryption Header Parameters and
	    JSON Web Signature and Encryption Type Values
	    to the JWS specification.
	  </t>
	  <t>
	    Numerous editorial improvements.
	  </t>
        </list>
      </t>
      <t>
        -02
        <list style='symbols'>
	  <t>
	    Clarified that it is an error when a <spanx style="verb">kid</spanx>
	    value is included and no matching key is found.
	  </t>
	  <t>
	    Removed assumption that <spanx style="verb">kid</spanx> (key ID)
	    can only refer to an asymmetric key.
	  </t>
	  <t>
	    Clarified that JWSs with duplicate Header Parameter Names
	    MUST be rejected.
	  </t>
	  <t>
	    Clarified the relationship between
	    <spanx style="verb">typ</spanx> header parameter values
	    and MIME types.
	  </t>
	  <t>
	    Registered application/jws MIME type and "JWS" typ header parameter value.
	  </t>
	  <t>
	    Simplified JWK terminology to get replace the "JWK Key Object" and
	    "JWK Container Object" terms with simply "JSON Web Key (JWK)"
	    and "JSON Web Key Set (JWK Set)" and to eliminate potential
	    confusion between single keys and sets of keys.
	    As part of this change, the Header Parameter Name for a
	    public key value was changed from
	    <spanx style="verb">jpk</spanx> (JSON Public Key) to
	    <spanx style="verb">jwk</spanx> (JSON Web Key).
	  </t>
	  <t>
	    Added suggestion on defining additional header parameters
	    such as <spanx style="verb">x5t#S256</spanx> in the future
	    for certificate thumbprints using hash algorithms other
	    than SHA-1.
	  </t>
	  <t>
	    Specify RFC 2818 server identity validation, rather than
	    RFC 6125 (paralleling the same decision in the OAuth specs).
	  </t>
	  <t>
	    Generalized language to refer to Message Authentication Codes (MACs)
	    rather than Hash-based Message Authentication Codes (HMACs)
	    unless in a context specific to HMAC algorithms.
	  </t>
          <t>
            Reformatted to give each header parameter its own section heading.
          </t>
        </list>
      </t>
      <t>
        -01
        <list style='symbols'>
          <t>
	    Moved definition of Plaintext JWSs (using "alg":"none")
	    here from the JWT specification since this functionality is
	    likely to be useful in more contexts that just for JWTs.
          </t>
	  <t>
	    Added <spanx style="verb">jpk</spanx> and <spanx
	    style="verb">x5c</spanx> header parameters for including
	    JWK public keys and X.509 certificate chains directly in
	    the header.
	  </t>
	  <t>
	    Clarified that this specification is defining the JWS
	    Compact Serialization.  Referenced the new JWS-JS spec,
	    which defines the JWS JSON Serialization.
	  </t>
	  <t>
	    Added text "New header parameters should be introduced
	    sparingly since an implementation that does not understand
	    a parameter MUST reject the JWS".
	  </t>
	  <t>
	    Clarified that the order of the creation and validation
	    steps is not significant in cases where there are no
	    dependencies between the inputs and outputs of the steps.
	  </t>
	  <t>
	    Changed "no canonicalization is performed" to "no
	    canonicalization need be performed".
	  </t>
          <t>
	    Corrected the Magic Signatures reference.
          </t>
	  <t>
	    Made other editorial improvements suggested by JOSE
	    working group participants.
	  </t>
        </list>
      </t>
      <t>
        -00
        <list style='symbols'>
          <t>
            Created the initial IETF draft based upon
            draft-jones-json-web-signature-04 with no normative
            changes.
          </t>
	  <t>
	    Changed terminology to no longer call both digital
	    signatures and HMACs "signatures".
	  </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
