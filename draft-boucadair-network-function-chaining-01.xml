<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="yes"?>
<rfc category="std" docName="draft-boucadair-network-function-chaining-01"
     ipr="trust200902" updates="">
  <front>
    <title abbrev="NLFC">Differentiated Network-Located Function Chaining
    Framework</title>

    <author fullname="Mohamed Boucadair" initials="M." surname="Boucadair">
      <organization>France Telecom</organization>

      <address>
        <postal>
          <street></street>

          <city>Rennes</city>

          <region></region>

          <code>35000</code>

          <country>France</country>
        </postal>

        <email>mohamed.boucadair@orange.com</email>
      </address>
    </author>

    <author fullname="Christian Jacquenet" initials="C." surname="Jacquenet">
      <organization>France Telecom</organization>

      <address>
        <postal>
          <street></street>

          <city>Rennes</city>

          <region></region>

          <code>35000</code>

          <country>France</country>
        </postal>

        <email>christian.jacquenet@orange.com</email>
      </address>
    </author>

    <author fullname="Ron Parker" initials="R." surname="Parker">
      <organization>Affirmed Networks</organization>

      <address>
        <postal>
          <street></street>

          <city>Acton,</city>

          <region></region>

          <code>MA</code>

          <country>USA</country>
        </postal>

        <email>Ron_Parker@affirmednetworks.com</email>
      </address>
    </author>

    <author fullname="Diego R. Lopez" initials="D. R." surname="Lopez">
      <organization>Telefonica I+D</organization>

      <address>
        <postal>
          <street>Don Ramon de la Cruz, 82</street>

          <!-- Reorder these if your country does things differently -->

          <city>Madrid</city>

          <region></region>

          <code>28006</code>

          <country>Spain</country>
        </postal>

        <phone>+34 913 129 041</phone>

        <email>diego@tid.es</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Parviz Yegani" initials="P." surname="Yegani">
      <organization>Juniper Networks</organization>

      <address>
        <postal>
          <street>1194 N. Mathilda Ave.</street>

          <city></city>

          <region>Sunnyvale,</region>

          <code>CA 94089</code>

          <country>USA</country>
        </postal>

        <email>pyegani@juniper.net</email>
      </address>
    </author>

    <date day="28" month="June" year="2013" />

    <keyword>network function chaining, overlay, flexibility, adaptability,
    elasticity</keyword>

    <abstract>
      <t>IP networks rely more and more on the combination of advanced
      functions (besides the basic routing and forwarding functions). This
      document defines a solution to enforce Network-Located Function Chaining
      (NLFC) with minimum requirements on the underlying network.</t>

      <t>The proposed solution allows for Differentiated Forwarding
      (DiffForward): packets are classified at the entry point of an
      NLFC-enabled network, and are then forwarded on a per NLFC map
      basis.</t>
    </abstract>

    <note title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t></t>

      <section title="On the Proliferation of Network-Located Functions">
        <t>IP networks rely more and more on the combination of advanced
        functions (besides the basic routing and forwarding functions).
        Typical examples of such functions include firewall (e.g., <xref
        target="RFC6092"></xref>), DPI (Deep Packet Inspection), LI (Lawful
        Intercept) module, NAT44 <xref target="RFC3022"></xref>, NAT64 <xref
        target="RFC6146"></xref>, DS-Lite AFTR <xref target="RFC6333"></xref>,
        NPTv6 <xref target="RFC6296"></xref>, HOST_ID injection, HTTP Header
        Enrichment function, TCP tweaking and optimization functions,
        transparent caching, charging function, load-balancer, etc.</t>

        <t>Such advanced functions are denoted NLF (Network-Located Function)
        in this document.</t>

        <t>The major concern is how to provide differentiated forwarding for
        packets entering a network enabling advanced network functions.
        Differentiation is ensured by tweaking the set of network functions to
        be invoked. How to bind a packet to a forwarding plane is
        policy-based.</t>
      </section>

      <section title="Scope">
        <t>This document defines a framework to enforce Network-Located
        Function Chaining (NLFC) with minimum requirements on the underlying
        network. The proposed solution allows for Differentiated Forwarding
        (DiffForward): packets are classified at the entry point of an
        NLFC-enabled network, and are then forwarded on a per NLFC map
        basis.</t>

        <t>This document does not make any assumption on the deployment
        context. The proposed framework covers both fixed and mobile networks
        (e.g., to rationalize the proliferation of advanced features at the Gi
        Interface <xref target="RFC6459"></xref>).</t>
      </section>

      <section title="Objectives">
        <t>The main objectives of the proposed framework are as follows:<?rfc subcompact="yes" ?><list
            style="symbols">
            <t>Efficiently master the chained activation of network-located
            functions, regardless of the underlying network topology and
            routing policies.</t>

            <t>Allow for differentiated packet forwarding by selecting the set
            of network-located functions to be invoked.</t>

            <t>Allow to easily change the chronology of the activation of
            network-located functions to be invoked.</t>

            <t>Allow to easily change the set of network-located functions to
            be invoked.</t>

            <t>Ease withdrawal of network-located functions and minimize any
            subsequent topology upgrade.</t>

            <t>Automate the overall process of generating and enforcing
            policies to accommodate a set of network connectivity
            objectives.<?rfc subcompact="no" ?></t>
          </list></t>
      </section>

      <section anchor="assumptions" title="Assumptions">
        <t>The following assumptions are made:<?rfc subcompact="yes" ?><list
            style="symbols">
            <t>Not all NLFs can be characterized with a standard definition in
            terms of technical description, detailed specification, etc.</t>

            <t>There is no global nor standard list of NLFs enabled in a given
            administrative domain. The set of NLFs varies on a per deployment
            basis.</t>

            <t>There is no global nor standard NLF chaining logic. The ordered
            set of NLFs that need to be activated to deliver a given
            connectivity service is specific to each administrative
            entity.</t>

            <t>The chaining of NLFs and the criteria to invoke some of them
            are local to each administrative entity that operates a
            connectivity network (also called administrative domain).</t>

            <t>NLF chaining logic and related policies should not be exposed
            outside a given administrative domain.</t>

            <t>Several NLF chaining logics can be simultaneously enforced
            within an administrative domain to meet business requirements.</t>

            <t>No assumption is made on how FIBs and RIBs of involved nodes
            are populated.</t>

            <t>How to bind the traffic to a given NLF chaining is
            policy-based.<?rfc subcompact="no" ?></t>
          </list></t>
      </section>

      <section title="Rationale">
        <t>Given the assumptions listed in <xref target="assumptions"></xref>,
        the rationale of the framework is as follows:<?rfc subcompact="yes" ?><list
            style="symbols">
            <t>The framework separates the dynamic provisioning of required
            NLF functions from packet handling operations (e.g., forwarding
            decisions).</t>

            <t>NLFs are handled as black-boxes; the technical characterization
            of each NLF is not required.</t>

            <t>No IANA registry is required to store the list of NLFs.</t>

            <t>No IANA registry is required to store the NLF chaining
            candidates.</t>

            <t>No frozen NLF chaining is assumed. The definition of NLF chains
            is an information that will be processed by the nodes that
            participate to the delivery of a network service. The set of
            listed/chained NLF functions is generated by each administrative
            entity operating the network.</t>

            <t>NLF handling is policy-based: NLF chains can be updated or
            deleted, new NLFs can be added without any impact on existing
            NLFs, etc. This design choice is compliant with the global
            framework discussed in <xref
            target="I-D.sin-sdnrg-sdn-approach"></xref>.</t>

            <t>For the sake of efficiency, policy enforcement is automated
            (but the policies can be enforced using other methods).</t>

            <t>To minimize fragmentation, a minimal set of information needs
            to be signaled (possibly in data packets).</t>

            <t>Advanced features (e.g., load balancing objectives) are also
            policy-based. Invoked enforcement points are not aware of such
            objectives.</t>

            <t>NLFs can be embedded in nodes that intervene in the transport
            service or be embedded in dedicated nodes (e.g., dedicated
            servers). The decision to implement one of these two models is
            deployment-specific and it is orthogonal to the overall
            procedure.</t>

            <t>Multiple NLFC-enabled domains can be deployed within the same
            administrative domain. Nodes are provisioned with the policy table
            of the NLFC-enabled domain they belong to.</t>

            <t>The overall consistency is ensured by the PDP.</t>

            <t>The PDP can be responsible to enforce other policies than the
            NLFC Policy Tables. <?rfc subcompact="no" ?></t>
          </list></t>
      </section>
    </section>

    <section title="Terminology">
      <t>This document makes use of the following terms:<?rfc subcompact="no" ?><list
          style="symbols">
          <t>DiffForward: refers to the differentiated forwarding procedure as
          specified in this document.</t>

          <t>NLF (Network-Located Function): refers to a function which is
          enabled in the network operated by an administrative entity. NLF can
          be for example: firewall (e.g., <xref target="RFC6092"></xref>), DPI
          (Deep Packet Inspection), LI (Lawful Intercept) module, NAT44 <xref
          target="RFC3022"></xref>, NAT64 <xref target="RFC6146"></xref>,
          DS-Lite AFTR <xref target="RFC6333"></xref>, NPTv6 <xref
          target="RFC6296"></xref>, HOST_ID injection, HTTP Header Enrichment
          function, TCP optimizer, load-balancer, etc. This document does not
          make any assumption on the enabled NLFs.</t>

          <t>NLFC-enabled domain: denotes a network (or a region thereof) that
          implements DiffForward.</t>

          <t>NLF Identifier: is a unique identifier that identifies
          unambiguously a NLF within an NLFC-enabled domain. NLF Identifiers
          are assigned, configured and managed by the administrative entity
          operating an NLFC-enabled domain. NLF identifiers can be structured
          as strings; other formats can be used. NLF Identifiers are not
          required to be globally unique nor be exposed to or used by another
          NLF-enabled domain.</t>

          <t>NLFC Map: refers to an ordered list of NLF identifiers. Each NLFC
          Map is identified with a unique identifier called NLFC Map
          Index.</t>

          <t>NLFC Policy Table: is a table containing a list of NLFC Maps,
          NLFC classification rules and Locators for all NLF Nodes. NLFC
          Policy Table may contain a default NLFC Map.</t>

          <t>NLFC Boundary Node (or Boundary Node): denotes a node that
          connects one NLFC-enabled domain to a node either located in another
          NLFC-enabled domain or in a domain that is NLFC-unaware.</t>

          <t>NLFC Egress Node (or Egress Node): denotes a NLFC Boundary Node
          that handles traffic which leaves the NLFC-enabled domain the Egress
          Node belongs to.</t>

          <t>NLFC Ingress Node (or Ingress Node): denotes a NLFC Boundary Node
          that handles traffic which enters the NLFC-enabled domain the
          ingress Node belongs to.</t>

          <t>NLF Node: denotes any node within an NLFC-enabled domain that
          embeds one or multiple NLFs.</t>

          <t>Legacy Node (Node for short): refers to any node that is not a
          NLF Node nor NLFC Boundary Node. This node can be located within a
          NLFC-enabled domain or outside a NLFC-enabled domain.</t>

          <t>NLFC Classifier (or Classifier): an entity which classifies
          packets based on the content of packet headers according to
          classification rules defined in a NLFC Policy Table. Packets are
          then marked with the corresponding NLFC Map Index. NLFC Classifier
          is embedded in a NLFC Boundary Node. An NLFC Classifier may be
          identified by a dedicated NLF Identifier.</t>
        </list></t>
    </section>

    <section anchor="boot" title="NLFC Provisioning">
      <t></t>

      <section title="Assign NLF Identifiers">
        <t>The administrative entity that operates a NLFC-enabled domain
        maintains a local repository that lists the enabled NLFs. This
        administrative entity assigns a unique NLF identifier for each
        NLF.</t>

        <t>NLF identifiers can be structured as strings or any other format.
        The main constraint on the format is that two NLFs MUST be assigned
        with different identifiers. NLF identifiers are case-sensitive.</t>
      </section>

      <section title="NLF Locator">
        <t>A NLF may be embedded in one or several NLF Nodes. The NLF locator
        is typically the IP address or the FQDN to reach a given NLF Node.</t>

        <t>The use of an IP address is RECOMMENDED to ovoid overloading NLF
        Nodes with name resolution capabilities. Resolution capabilities
        (together with advanced traffic engineering functions) are supported
        by the PDP (Policy Decision Point). In the rest of the document, we
        assume a NLF locator is structured as an IP address (IPv4 or
        IPv6).</t>

        <t>A NLF can be multi-instantiated; as such one or more locators may
        be bound to the same NLF.</t>
      </section>

      <section title="Building NLFC Maps">
        <t>Added-value services delivered to end-user rely on the invocation
        of several NLFs. For each of these services, the administrative entity
        that operates an NLFC-enabled domain builds one or several NLFC Maps.
        Each of these maps characterizes the list of NLFs to be invoked with
        their exact invocation order.</t>

        <t>Each NLFC Map is unambiguously identified with a unique identifier
        called NLFC Map Index. The NLFC Map Index MUST be expressible as an
        unsigned integer.</t>

        <t>Distinct chains can be applied for inbound and outbound traffic.
        The direction of the traffic is not included as an attribute of the
        NLFC Map, but directionality may be implemented using two chains:
        i.e., two NLFC Maps are installed in the NLFC Policy Table. In such
        case, incoming packets are marked with Index_1 while outgoing packets
        will be forwarded according to a distinct NLFC Map identified with
        Index_2.</t>

        <t>An example of NLFC Map to handle IPv6 traffic destined to an IPv4
        remote server is defined as follows: <list style="empty">
            <t>{15, {IPv6_Firewall, HOST_ID_Inject, NAT64}}.</t>
          </list>To handle incoming packets destined to the same IPv6 host,
        the following NLFC Map can be defined:<list style="empty">
            <t>{10, {IPv4_Firewall, NAT64}}.</t>
          </list></t>
      </section>

      <section title="Building NLFC Policy Tables">
        <t>A PDP (Policy Decision Point, <xref target="RFC2753"></xref>) is
        the central entity which is responsible for maintaining NLFC Policy
        Tables, and enforcing appropriate policies in NLF Nodes and NLFC
        Boundary Nodes (see <xref target="pdp"></xref>). Policy enforcement
        can be achieved using a variety of protocols (e.g., NETCONF <xref
        target="RFC6241"></xref>).</t>

        <t>One or multiple NLFC-enabled domains may be under the
        responsibility of the same PDP. Delimiting the scope of each
        NLFC-enabled domain is under the responsibility of the administrative
        entity operating the network. </t>

        <t><figure align="center" anchor="pdp" title="NLFC Policy Enforcement">
            <artwork><![CDATA[o . . . . . . . . . . . . . . . . . . . . . . . o
. NLFC Policy Enforcement                       .
.             +-------+                         .
.             |       |-----------------+       .
.     +-------|  PDP  |                 |       .
.     |       |       |-------+         |       .
.     |       +-------+       |         |       .
o . . | . . . . . | . . . . . | . . . . | . . . o
o . . | . . . . . | . . . . . | . . . . | . . . o
.     |           |           |         |       .
.     v           v           v         v       .
. +---------+ +---------+ +-------+ +-------+   .
. |NLFC_BN_1| |NLFC_BN_n| | NLF_1 | | NLF_m |   .
. +---------+ +---------+ +-------+ +-------+   .
. NLFC-enabled Domain                           .
o . . . . . . . . . . . . . . . . . . . . . . . o

]]></artwork>
          </figure></t>

        <t>The NLF Node MUST be provisioned with the following
        information:<?rfc subcompact="yes" ?><list style="symbols">
            <t>Local NLF Identifier(s): This information is required for an
            NLF to identify itself within an NLFC Map.</t>

            <t>List of NLFC Maps: The PDP may configure the full list (default
            mode) or only as subset of NLFC Maps in which the local NLF is
            involved (see <xref target="litePT"></xref>).</t>

            <t>List of NLF Locators: The PDP may configure the full list of
            locators (default mode) or only the locators of next hop NLFs of
            NLFC Maps in which the local NLF is involved (see <xref
            target="litePT"></xref>).<?rfc subcompact="no" ?></t>
          </list></t>

        <t>Likewise, the NLFC Boundary Node MUST be provisioned with the
        following information:<?rfc subcompact="yes" ?><list style="symbols">
            <t>List of NLFC Maps</t>

            <t>List of NLF Locators</t>

            <t>List of NLFC Map Classification Rules (see Section <xref
            target="classifier"></xref>).<?rfc subcompact="no" ?></t>
          </list></t>

        <t>In addition to the NLFC Policy Table, other NLF-specific policies
        can be installed by the PDP (e.g., configure distinct users
        profiles).</t>

        <t>Policies managed and stored by the PDP may be configured to the PDP
        manually or be triggered by dynamic means (e.g., AAA).</t>

        <t>In the event of any update (e.g., define a new NLFC Map, delete an
        NLFC Map, add a new NLF Locator, update classification policy), the
        PDP MUST enforce the updated policy configuration in all NLF Nodes and
        NLFC Boundary Nodes.</t>

        <t>Load-balancing among several NLF Nodes supporting the same NLF can
        be driven by the PDP. Indeed, the PDP can generate multiple
        classification rules and NLFC Maps to meet load-balancing
        objectives.</t>

        <t>The processing of packets by the nodes that belong to a
        NLFC-enabled domain does not necessarily require any interaction with
        the PDP, depending on the nature of the NLF supported by the nodes and
        the corresponding policies to be enforced. For example, traffic
        conditioning capabilities <xref target="RFC2475"></xref> are typical
        NLF functions that may require additional solicitation to the PDP for
        the NLF node to decide what to do with some out-of-profile
        traffic.</t>
      </section>
    </section>

    <section anchor="overview" title="Theory Of Operation">
      <t>The behavior of each node of a NLFC-enabled domain is specified in
      the following sections. We assume that the provisioning operations
      discussed in <xref target="boot"></xref> have succeeded.</t>

      <section title="NLFC Boundary Node">
        <t>NLFC Boundary Nodes act both as a NLFC Ingress Node and as a NLFC
        Egress Node for the respective directions of the traffic.</t>

        <t>Traffic enters a NLFC-enabled domain at a NLFC Ingress Node (<xref
        target="ingress"></xref>) and exists the domain at a NLFC Egress Node
        (<xref target="egress"></xref>).</t>
      </section>

      <section anchor="classifier" title="Classifier">
        <t>The NLFC Classifier classifies packets based on (some of) the
        contents of the packet header. Concretely, it classifies packets based
        on the value of a combination of one or more header fields, such as
        source address, destination address, DS field, protocol ID, source
        port and destination port numbers, and any other information.</t>

        <t>Each NLFC Map Classification Rule MUST be bound to one single NLFC
        Map (i.e., the classification rule must include only one NLFC Map
        Index).</t>
      </section>

      <section anchor="ingress" title="NLFC Ingress Node">
        <t>When a packet is received through an interface of the NLFC Ingress
        Node that connects to the outside of the NLFC domain, the Ingress Node
        MUST:<?rfc subcompact="yes" ?><list style="symbols">
            <t>Inspect the received packet and strip any existing NLFC Map
            Index.</t>

            <t>Check if the received packet matches an existing classification
            rule (see <xref target="classifier"></xref>).</t>

            <t>If no rule matches, forward the packet to the next hop
            according to legacy forwarding behavior (e.g., based upon the IP
            address conveyed in the DA field of the header).</t>

            <t>If a rule matches, proceed to the following:<list
                style="symbols">
                <t>Retrieve the locator of the first NLF as indicated in the
                NLFC Map entry the rule matches.</t>

                <t>Check whether the corresponding NLF node is an immediate
                neighbor. <list style="symbols">
                    <t>If so, update the packet with the NLFC Map Index of
                    NLFC Map entry it matches and then forward the packet to
                    the corresponding NLF Node.</t>

                    <t>If not, (1) encapsulate the original packet into a new
                    one destined to the corresponding NLF node, (2) update the
                    encapsulated packet with the NLFC Map Index of NLFC Map
                    entry it matches, and (3) forward the packet to the next
                    hop to reach the first NLF node.<?rfc subcompact="no" ?></t>
                  </list></t>
              </list></t>
          </list>As a result of this process, the packet will be sent to an
        NLF Node or an Intermediate Node.</t>
      </section>

      <section anchor="egress" title="NLFC Egress Node">
        <t>When a packet is received through an interface that connects the
        NLFC Egress Node to its NLFC domain, the Egress Node MUST:<?rfc subcompact="yes" ?><list
            style="symbols">
            <t>Strip any existing NLFC Map Index.</t>

            <t>Forward the packet according to legacy forwarding policies.</t>
          </list></t>

        <t><?rfc subcompact="no" ?></t>
      </section>

      <section title="NLF Node">
        <t>This section assumes the NLF Nodes does not embed a Classifier as
        discussed in <xref target="nlfclass"></xref>.</t>

        <t>When a packet is received by a NLF Node, the latter MUST:<?rfc subcompact="yes" ?></t>

        <t><list style="symbols">
            <t>Check if the packet conveys a NLFC Map Index.</t>

            <t>If no NLFC Map Index is included, forward the packet according
            to legacy forwarding policies.</t>

            <t>If the packet conveys a NLFC Map Index, <list style="symbols">
                <t>Retrieve the corresponding NLFC Map from the NLFC Policy
                Table.</t>

                <t>Check if the local NLF Identifier is present in the NLFC
                Map:<list style="symbols">
                    <t>If not, forward the packet according to legacy
                    forwarding policies.</t>

                    <t>If so, the packet is decapsulated (if needed) and then
                    presented as an input to the local NLF. In case several
                    NLFs are co-located in the same node, the packet is
                    processed by all NLFs indicated in the NLFC Map. Once the
                    packet is successfully handled by local NLF(s), the packet
                    is forwarded to the next NLF Node in the list or to an
                    intermediate node (if the local NLFC Node is the last
                    element in the NLFC Map). If the local NLF node is not the
                    last one in the NLFC Map, it retrieves the next NLF Node
                    from the list, retrieve its locator for the NLFC Policy
                    Table, and forwards the packet to the next hop. If the
                    local NLF Node is the last element in the NLFC Map, it
                    forwards the packet to the next hop according to legacy
                    forwarding policies.<?rfc subcompact="no" ?></t>
                  </list></t>
              </list></t>
          </list></t>
      </section>

      <section title="Intermediate Nodes">
        <t>An Intermediate Node is any node that does not support any NLF
        function and which is located within a NLFC-enabled domain.</t>

        <t>No modification is required to intermediate nodes to handle
        incoming packets. In particular, routing and forwarding are achieved
        using legacy procedures.</t>
      </section>
    </section>

    <section title="Protocol Extensions?">
      <t>This section discusses two main protocol issues to be handled in
      order to deploy DiffForward.</t>

      <section anchor="index" title="Transmit NLFC Map Index In a Packet">
        <t></t>

        <section title="NLFC Map Index">
          <t>A NLFC Map Index is an integer that points to a NLFC Map.</t>

          <t>In order to avoid all nodes of a NLFC-enabled domain to be
          NLF-aware, this specification recommends to undertake classifiers at
          boundary nodes while intermediate nodes forward the packets
          according to the NLFC Map Index conveyed in the packet (NLF Node) or
          according to typical forwarding policies (any NLF-unaware node).</t>

          <t>An 8-bit field would be sufficient to accommodate deployment
          contexts with reasonable set of NLFC Maps. A 16-bit (or 32-bit)
          field would provide a comfortable solution (e.g., to accommodate the
          requirement discussed in <xref target="profile"></xref>).</t>
        </section>

        <section title="Why Not SSR?">
          <t>Instead of injecting a Map Index, an alternate solution would be
          to use SSR IP option or any similar solution to indicate a loose or
          strict explicit route. This alternative was not considered because
          of the negative impact on the processing and potential fragmentation
          issues.</t>

          <t>Injecting an 8-bit or even 16-bit field would minimize
          fragmentation issues.</t>
        </section>

        <section title="Where To Store NLFC Map Indexes In A Packet?">
          <t>NLFC Map Indexes can be conveyed in various locations of a
          packet:<?rfc subcompact="yes" ?><list style="symbols">
              <t>At L2 level</t>

              <t>Define a new IP option or a new IPv6 extension header</t>

              <t>Use IPv6 Flow Label</t>

              <t>Re-use an existing field (e.g., DS field)</t>

              <t>TCP option</t>

              <t>GRE Key</t>

              <t>Define a new shim</t>

              <t>Etc.<?rfc subcompact="no" ?></t>
            </list></t>
        </section>
      </section>

      <section title="Force the path to cross a NLF Node">
        <t>A NLFC Ingress Node or an NLF Node MUST be able to forward a packet
        matching an existing NLFC Map to a NLF Node. The locator of the next
        NLF is retrieved from the NLFC Policy Table. In case the next NLF Node
        in the list is not an immediate neighbor, a solution to force the
        packet to cross that NLF Node MUST be supported. This document
        suggests the use of IP-in-IP encapsulation scheme. Other tunneling
        solutions can be considered in the future.</t>
      </section>
    </section>

    <section anchor="depl" title="Deployment Considerations">
      <t></t>

      <section anchor="req" title="Generic Requirements">
        <t>The following deployment considerations should be taken into
        account:<?rfc subcompact="yes" ?><list style="symbols">
            <t>Avoid inducing severe path stretch compared to the path
            followed if no NLF is involved.</t>

            <t>Minimize path computation delays: due to enforcement of
            classification rules in all participating nodes, misconception of
            network-located function chaining, inappropriate choice of nodes
            elected to embed network-located functions, etc.</t>

            <t>Avoid NLF invocation loops: the design of NLF chainings should
            minimize as much as possible NLF invocation loops. Note, means to
            prevent NLF loops may be enabled in each NLF Node (see <xref
            target="loops"></xref>).<?rfc subcompact="no" ?></t>
          </list></t>
      </section>

      <section anchor="profile" title="NLF Profiles">
        <t>Some NLFs may be provisioned with a set of local differentiated
        policies (denoted as profiles). For example, an NLF realizing DPI may
        be configured to block Peer-to-Peer protocols for some group of users
        while authorize it for another group of users.</t>

        <t>The profile selection policy can be local to a NLF or be controlled
        by the PDP. In the latter case, distinct NLF identifiers can be
        assigned for each profile. Doing so, the PDP conveys to the NLF the
        profile to be enforced for received traffic.</t>
      </section>

      <section anchor="nlfclass" title="NLF Node is also a Classifier">
        <t>If NLF Nodes are also configured to behave as Classifiers, NLFC Map
        Index is not required to be explicitly signalled in each packet.
        Concretely, the NLFC Policy Table configured to the NLF Node includes
        also classification rules. These classification rules are enforced to
        determine whether the local NLF must be involved. If an incoming
        packet matches at least one classification rule pointing to an NLFC
        Map in which the NLF Identifier is listed, the NLF Node retrieves the
        next hop NLF from the NLF Map indicated in the classification rule,
        the packet is handled by the local NLF, and then the NLF Node forwards
        the packet to the next hop NLF. If not, the packet is forwarded to the
        next hop following legacy forwarding behavior.</t>

        <t>Let consider the example shown in <xref target="example"></xref>.
        The local NLF Node embeds NLFa. After checking the classification
        rules and the NLFC Maps, the NLF Node concludes NLFa must be invoked
        only when a packet matches Rule 1 and Rule 3. If a packet matches Rule
        1, the next NLF is NLFc. If a packet matches Rule 3, the next NLF is
        NLFh.</t>

        <t><figure align="center" anchor="example">
            <artwork><![CDATA[+-----------------------------------------------+
|                NLFC Policy Table              |
+-----------------------------------------------+
|Local NLF Identifier: NLFa                     |
+-----------------------------------------------+
|Classification Rules                           |
| Rule 1: If DEST=IP1; then NLFC_MAP_INDEX1     |
| Rule 2: If DEST=IP2; then NLFC_MAP_INDEX2     |
| Rule 3: IF DEST=IP3; then NLFC_MAP_INDEX3     |
+-----------------------------------------------+
|NLFC Maps                                      |
| {NLFC_MAP_INDEX1, {NLFa, NLFc}                |
| {NLFC_MAP_INDEX2, {NLFd, NLFb}                |
| {NLFC_MAP_INDEX3, {NLFa, NLFh}                |
+-----------------------------------------------+
]]></artwork>
          </figure></t>
      </section>

      <section anchor="adj" title="Direct Adjacency ">
        <t>NLF Nodes may be enabled in a NLFC-enabled domain so that each of
        them has a direct adjacency with other NLF Nodes. In such
        configuration, no additional encapsulation scheme is needed to
        exchange traffic between these nodes.</t>
      </section>

      <section anchor="loops" title="NLF Loops">
        <t>NLF Nodes use the NLFC Policy Table to detect whether the local NLF
        was already applied for the received packet (i.e., detect NLF Loop).
        The NLF Node MUST invoke the local NLF only if the packet is received
        from a NLFC Boundary Node or a NLF Node having an identifier listed
        before the local NLF in the NLF Map matched by the packet. NLF Loop
        detection SHOULD be a configurable feature.</t>

        <t><xref target="lo"></xref> shows an example of a NLFC Policy Table
        of a NLF Node embedding NLFa. If we consider a packet, received from
        Locb, matches Rule 2. NLFa must not be invoked because NLFb is listed
        after NLFa (see the NLFC Map list). That packet will be forwarded
        without invoking NLFa.</t>

        <t><figure align="center" anchor="lo">
            <artwork><![CDATA[+-----------------------------------------------+
|                NLFC Policy Table              |
+-----------------------------------------------+
|Local NLF Identifier: NLFa                     |
+-----------------------------------------------+
|NLFC Maps                                      |
| {NLFC_MAP_INDEX1, {NLFa, NLFc}                |
| {NLFC_MAP_INDEX2, {NLFd, NLFa, NLFb, NLFh}    |
+-----------------------------------------------+
|NLFC Locators                                  |
| Locator_NLFb: Locb                            |
| Locator_NLFc: Locc                            |
| Locator_NLFd: Locd                            |
| Locator_NLFh: Loch                            |
+-----------------------------------------------+
]]></artwork>
          </figure></t>

        <t>The support of this feature is OPTIONAL.</t>
      </section>

      <section anchor="litePT" title="Lite NLFC Policy Table">
        <t>If NLF loop detection is not activated in an NLFC-enabled domain,
        the PDP may provision to underlying nodes a lite NLFC Policy Table.
        Lite NLFC Policy Table is a subset of the full NLFC Policy Table which
        includes:<?rfc subcompact="yes" ?><list style="symbols">
            <t>Only the NLFC Maps in which the local NLF is involved.</t>

            <t>Only the next hop NLF instead of the full NLF chain.<?rfc subcompact="no" ?></t>
          </list></t>

        <t>An example of lite NLFC Policy Table is shown in <xref
        target="lite"></xref>.</t>

        <t><figure align="center" anchor="lite">
            <artwork><![CDATA[+-----------------------------------------------+
|                NLFC Policy Table              |
+-----------------------------------------------+
|Local NLF Identifier: NLFa                     |
+-----------------------------------------------+
|Lite NLFC Maps                                 |
| NLFC_MAP_INDEX1, Next_Hop_NLF = NLFc          |
| NLFC_MAP_INDEX2, Next_Hop_NLF = NLFb          |
+-----------------------------------------------+
|NLFC Locators                                  |
| Locator_NLFb: Locb                            |
| Locator_NLFc: Locc                            |
+-----------------------------------------------+
]]></artwork>
          </figure></t>
      </section>

      <section title="Liveness Detection of NLFs by the PDP">
        <t>Determination by the PDP of liveness of each NLF in the service
        chain provides a number of benefits. These include:<?rfc subcompact="yes" ?><list
            style="symbols">
            <t>Enhanced status reporting by the PDP (i.e., an operational
            status for any given chain derived from liveness state of its
            NLFs).</t>

            <t>Ability to support various resiliency policies (i.e., bypass
            NLF Node, use alternate NLF Node, use alternate chain, drop
            traffic, etc.) .</t>

            <t>Ability to support simple load balancing across multiple NLF
            instances that provide equivalent function (although more than
            liveness is required for complex load balancing schemes).<?rfc subcompact="no" ?></t>
          </list></t>

        <t>In order to determine liveness of any particular NLF Node, standard
        protocols such as ICMP or BFD (both single-hop <xref
        target="RFC5881"></xref> and multi-hop <xref target="RFC5883"></xref>)
        may be utilized between the PDP and the NLF Nodes.</t>

        <t>For more sophisticated load-balancing support, protocols that allow
        for both liveness determination and the transfer of
        application-specific data, such as SNMP and NETCONF may be utilized
        between the PDP and the NLF Nodes.</t>

        <t>The support of this feature is OPTIONAL.</t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>Required IANA actions will be discussed in future version of the
      document.<?rfc subcompact="no" ?></t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Means to defend NLFC Boundary Nodes and NLF Nodes against broken NLFC
      Policy Table MUST be enabled. For example, authenticated means are to be
      used between a PDP and the underlying NLFC elements.</t>

      <t>NLFC Boundary Nodes MUST strip any existing NLFC Map Index when
      handling an incoming packet. A list of authorized NLFC Map Indexes are
      configured to the underlying NLFC elements.</t>

      <t>NETCONF-related security considerations are discussed in <xref
      target="RFC6146"></xref>.</t>

      <t>Means to defend against denial-of-service must be supported. Means to
      prevent NLF loops should be supported.</t>

      <t>Nodes involved in the same NLFC-enabled domain MUST be provisioned
      with the same NLFC Policy Table. Inconsistencies in this tables will
      result in forwarding mis-behavior.</t>
    </section>

    <section title="Acknowledgments">
      <t>Many thanks to D. Abgrall, D. Minodier, Y. Le Le Goff, and D. Cheng
      for their review and comments.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"
?>

      <?rfc include='reference.RFC.6241'?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.RFC.2475'?>

      <?rfc include='reference.I-D.sin-sdnrg-sdn-approach'?>

      <?rfc include='reference.RFC.6459'?>

      <?rfc include='reference.RFC.5881'?>

      <?rfc include='reference.RFC.5883'?>

      <?rfc include='reference.RFC.6333'?>

      <?rfc include='reference.RFC.6146'?>

      <?rfc include='reference.RFC.3022'?>

      <?rfc include='reference.RFC.2753'?>

      <?rfc include='reference.RFC.6296'?>

      <?rfc include='reference.RFC.6092'?>
    </references>
  </back>
</rfc>
