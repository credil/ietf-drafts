<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?rfc toc="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no"?>
<?rfc strict="yes"?>
<rfc ipr="trust200902"   category="std"
     docName="draft-bierman-netmod-yang-conformance-00" >
    <front>
    <title abbrev="YANG Conformance">YANG Conformance Specification</title>

    <author initials="A" surname="Bierman" fullname='Andy Bierman' >
      <organization>YumaWorks</organization>
      <address>
        <email>andy@yumaworks.com</email>
      </address>
    </author>
	<date/>
    <abstract>
	<t>
This document describes conformance specification
and advertisement mechanisms for NETCONF servers
implementing YANG data model modules.
	</t>
</abstract>
</front>
<middle>
<section title="Introduction">
    <t>
There is a need for standard mechanisms to
allow YANG <xref target="RFC6020"/> data model designers to express more
precise and robust conformance levels for
server implementations of a particular YANG module,
or set of YANG modules.
    </t>
    <t>
There is also a need for standard mechanisms to
allow NETCONF <xref target="RFC6241"/> servers to precisely advertise the 
conformance level of each YANG module it supports.
    </t>
    <t>
This document describes some problems with the current
conformance specifications mechanisms in YANG and
conformance advertisement mechanisms in NETCONF.
Solution proposals are also presented to address these problems.
    </t>
<section title="Terminology">
    <t>
The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
&quot;OPTIONAL&quot; in this document are to be interpreted as described in BCP
14, <xref target="RFC2119"/>.
    </t>
<section title="NETCONF">
    <t>
The following terms are defined in <xref target="RFC6241"/>:
    </t>
<t>
 <list style="symbols">
 <t>
capability
 </t>
 <t>
client
 </t>
 <t>
datastore
 </t>
 <t>
protocol operation
 </t>
 <t>
server
 </t>
 </list>
</t>
</section>
<section title="YANG">
    <t>
The following terms are defined in <xref target="RFC6020"/>:
    </t>
<t>
 <list style="symbols">
 <t>
data node
 </t>
 <t>
extension
 </t>
 <t>
feature
 </t>
 <t>
grouping
 </t>
 <t>
identity
 </t>
 <t>
module
 </t>
 <t>
notification
 </t>
 <t>
submodule
 </t>
 <t>
typedef
 </t>
 </list>
</t>
</section>
<section title="Terms">
    <t>
The following terms are used within this document:
    </t>
<t>
 <list style="symbols">
 <t>
conditional node: An object that
has one or more &quot;if&#8209;feature&quot; sub-statements associated with it.
Note that objects affected by &quot;when&quot; statements are not considered
conditional for conformance purposes.
 </t>
 <t>
conformance profile: A set of requirements that a server must
support to comply with a given service level.  These
requirements can be specified in terms of required
YANG modules (possibly with specific YANG features and objects supported),
other conformance profiles, and/or NETCONF capability URIs
(for server functionality that is not specified in YANG modules).
 </t>
 <t>
import-by-revision: A YANG import statement that includes
a revision-date statement.  This specifies the exact revision
of the YANG module to import, instead of the server picking
the revision to import.
 </t>
 <t>
module base: There is am implied &quot;base&quot; version of the module, which includes
all statements which are not conditional.  The module base may be empty,
a subset of all statements, or the entire module.
 </t>
 <t>
object: a conceptual data structure represented by a 
YANG data, rpc, or notification statement.
 </t>
 <t>
schema tree: The conceptual tree of all objects derived from
the set of all YANG modules supported by the server. This tree
only includes conditional nodes if all corresponding if-feature 
statements are &quot;true&quot;. Any deviation statements have also been
conceptually applied to the schema tree as well.
 </t>
 <t>
YANG feature set: The set of all objects
from a particular module that contain an if-feature statement
that corresponds to a particular YANG feature statement.
 </t>
 <t>
YANG package: A set of conformance profiles that can be extended
over time. Also called &quot;package&quot;.
 </t>
 </list>
</t>
</section>
</section>
</section>
<section title="Problems With YANG Conformance Mechanisms">
    <t>
This section describes some perceived deficiencies with
the current data model conformance specification and 
server conformance advertisement mechanisms used in NETCONF.
    </t>
<section title="YANG Conformance Specification Issues">
    <t>
The YANG data modeling language provides many powerful
data modeling constructs to allow the automation of
network configuration protocol operations.  However it does not
provide enough control over the precise server 
conformance levels that a client can expect.
This has a negative impact on interoperability.
    </t>
    <t>
A YANG module is conceptually divided into the module base
and zero or more purely optional YANG feature sets.  
    </t>
    <t>
This approach does not allow enough flexibility and can
become difficult to use as the module size and
number of YANG feature statements increases.  A set of
boolean flags that are logically combined as an &quot;AND&quot; expression
is too simplistic a mechanism for expressing the criteria for
specifying conditional conformance requirements.
    </t>
<section title="Import by Revision is Unusable for Conformance">
    <t>
YANG provides a mechanism to import an exact revision
of an external module in order to freeze conformance
requirements for a module.  If this is not used then
the YANG compiler will most likely use the latest revision
of the imported module that happens to be implemented
by the server.
    </t>
    <t>
If new data nodes, notifications, or protocol operations are
added to an imported module over time, then it can appear to
a NETCONF client that the new objects are implemented if
the imported module is updated but not all the modules
that import it.  Objects using imported typedefs will
change syntax and semantics if the typedef (or any typedef
it refines) is changed.
    </t>
    <t>
Unless import-by-revision is used everywhere an import is used
within the dependency chain, the exact module definition cannot
really be frozen for conformance purposes.
    </t>
    <t>
A server is not required to support multiple revisions of the same
module at the same time.  This may be very confusing to the client,
and complex to implement as well.  Instead, servers usually allow
only one revision of each module to be implemented within the system.
    </t>
    <t>
If import-by-revision is used, then creating a new revision of 
the imported module requires that the import statements in all
the importing modules be updated to use the new revision
date.  This requires a revision change, so any module that imports
those modules also needs to be updated to specify the new revision
date of those importing modules.  This ripple effect can cause
a lot of modules to be updated.  It may not be possible to
update a module import date in some cases, if that would
incorrectly advertise to the client that new objects
were implemented by the server.
    </t>
</section>
<section title="YANG Conformance Specification is Too Simplistic">
    <t>
Conformance requirements can change over time.
New use cases and new consensus about optionality can occur.
A conformance statement for each use-case is needed, not
just one or more (implied) conformance statements per module.
    </t>
    <t>
There are no mechanisms to clearly specify external module dependencies.
There is no way to indicate that the exact portions
of an imported module which are required to comply with
a particular conformance level for the importing module.
There is no way to specify that multiple modules are required
to provide a high-level service.
    </t>
    <t>
It is impossible to predict all valid use cases at design time.
Partitioning a module into a base plus purely optional features
can only account for the features and use cases known at the
time.  Future designers cannot alter if-feature statements
or add new if-feature statements to an augmented module.
    </t>
    <t>
YANG features are purely optional to implement.
There is no way to specify that a set of objects are
conditionally mandatory, based on some data-model specific
criteria. Conditions could be expressed with XPath must
or when expressions, but this has to be repeated everywhere
it is used and the set of objects with the same conditionally
mandatory properties is un-named and hard for the reader to identify.
    </t>
    <t>
YANG features are too simplistic.
They are good for a small number of use-cases within one module.
Once there are lots of features, interactions between features, and 
refined use-cases, they turn the module into a bowl of boolean spaghetti.
    </t>
    <t>
YANG features are not really purely optional in practice.
Sometimes they are used to express separate roles or service subsets within
the module. It is difficult for the reader to identify the valid combinations
of purely optional YANG features that represent high-level roles.
The YANG if-feature statements are logically combined as a
boolean &quot;AND&quot; expression and not very flexible. YANG description
statements are not really machine parsable, so these high-level
roles or service groupings are not easily identifiable.
    </t>
</section>
<section title="YANG Deviation Statements Do Not Help">
    <t>
YANG deviations could possibly be used as a low-level
conformance solution, but they are undesirable and not used
by server vendors. YANG deviation statements provide a fairly
comprehensive &quot;patch&quot; mechanism to conceptually alter
YANG data definition statements. This alteration,
or declaration of non-implementation, describes how a
server deviates from the standard data definitions.
    </t>
    <t>
These statements are not allowed to appear in standard YANG modules,
and it turns out that vendors would rather not specify
exactly how their server is non-compliant
to a standard YANG module.  A vendor would rarely need a deviation statement
for their own YANG data modules.
    </t>
    <t>
YANG deviation statements are too low-level anyway, even if
vendors were willing to use them. They do not fully address the
future use-case problem because they can only be used
to make specific patches to data statements.
    </t>
</section>
<section title="Single Module Conformance in Not Expressive Enough">
    <t>
YANG conformance applies only to one module.
There are no mechanisms to precisely identify
the conformance relationship between modules.
Since YANG is designed to be modular and reusable,
it is quite likely that a high-level feature or service
will be specified with more than one YANG module.
    </t>
    <t>
All the top-level definitions are imported from a module
whether the importing module uses all the definitions or not.
This is too general from a conformance perspective.
Sometimes modules are imported just for typedefs or
identities, which are always part of the base.
    </t>
    <t>
If a module augments a node in another module,
it does not imply that it supports all other objects
from that module.
YANG conformance does not actually address any relationship
between modules.  There are no mechanisms to express
multi-module conformance requirements.
    </t>
    <t>
It is difficult for a client application developer to
identify the high level server capabilities from a large
set of module capabilities.  There are no formal mechanisms
to identity the definition of a high-level service across
multiple modules.
    </t>
</section>
</section>
<section title="Module Capability Advertisement Issues">
    <t>
NETCONF servers advertise the YANG modules they support
as &lt;capability&gt; URI strings in the &lt;hello&gt; message.
The complete list of modules used by the server needs to
be advertised in order for the client application to correctly parse the
YANG modules and reproduce the schema tree used by the server.
However the client does not really know which modules are advertised
for full conformance, and which are advertised for partial
conformance (such as importing
typedef and identity statements from the module).
    </t>
</section>
</section>
<section title="Solution Overview">
<section title="Objectives">
    <t>
The solution in this document attempts to achieve several objectives:
    </t>
<t>
 <list style="symbols">
 <t>
Provide simple documentation mechanisms that are readable
and easy to understand.
 </t>
 <t>
Provide simple mechanisms that can scale in usage from one module to
thousands of modules.
 </t>
 <t>
Provide per use-case conformance profiles, which allow multiple
conformance levels to be specified for a single module.
 </t>
 <t>
Provide per use-case conformance profiles, which allow multiple
modules to be specified for a single conformance profile.
 </t>
 <t>
Clarify the usage relationship between an augmented module
and the augmenting module.
 </t>
 <t>
Clarify the usage relationship between modules that represent
parts of the same conceptual high-level service.
 </t>
 <t>
Provide the ability to specify a stable conformance definition
that cannot implicitly change if YANG modules are updated.
 </t>
 <t>
Provide the ability to specify the YANG features that must
be supported by a server to meet conformance requirements.
 </t>
 </list>
</t>
</section>
<section title="YANG Package">
    <t>
A YANG package is a conformance definition for zero or more
YANG modules and/or NETCONF protocol capabilities.  Each package
has zero or more conformance profiles that describe the
server implementation requirements to conform to a
specific profile within a package. A YANG package without any
conformance profile statements can be used as a placeholder
to reserve the package name, but it cannot be advertised
as a YANG package capability.
    </t>
    <t>
YANG packages are static representations of YANG conformance,
meaning there
are no server-dependent variables (e.g, set of purely optional
YANG features selected by the server).  Instead a conformance
profile specifies which YANG features a server needs to
support to conform to the profile.
    </t>
    <t>
YANG packages are defined using a text file similar to YANG modules.
However they are separate from YANG modules, since a package can
require more than one YANG module for conformance.
    </t>
    <t>
Unlike YANG modules, YANG package definitions do not represent
content that would appear in a protocol message. They represent
server conformance requirements and are therefore separate
from YANG module definitions.
    </t>
    <t>
A YANG package is advertised with a &lt;capability&gt; URI string,
similar to a YANG module.  A NETCONF server will advertise all
its supported package capability statements in the &lt;hello&gt; message
it sends to each client.
    </t>
</section>
<section title="YANG Package File">
    <t>
A YANG package file consists of UTF-8 characters.
The basic syntax is exactly the same as for YANG modules.
Several YANG statements are &quot;imported&quot; from the YANG ABNF,
and some new statements are defined. Specifically,
YANG package syntax is the same as RFC 6020, sections 6,
6.1, 6.2, and 6.3.
    </t>
    <t>
[FIXME: not all namespaces in sec. 6.2.1 are supported
and a namespace for YANG package names is not defined there.]
    </t>
    <t>
At least one revision statement MUST be present in a YANG
package file. A new revision MUST be added each time the
YANG package file is published.  This requirement is more
strict than RFC 6020 to insure that conformance requirements
can be properly identified for each server implementation.
    </t>
</section>
<section title="Conformance Profile">
    <t>
A conformance profile represents a conceptual set of
server implementation requirements to meet one use-case
or variant of the conceptual service represented by the YANG
package.
    </t>
    <t>
A conformance profile can overlap or even include other
conformance profiles. It is a data-model specific matter
what requirements make operational sense.
    </t>
    <t>
A server can only conform to one conformance profile
within a YANG package. Although profile contents can
overlap, only one profile per package can be active
on a server at a time.
    </t>
</section>
<section title="Conformance Profile Capability">
    <t>
A new NETCONF capability URI is defined to advertise YANG package
conformance. A server will announce conformance for a specific
conformance profile for each YANG package it supports. 
Refer to <xref target="capability"/> for details
on YANG package conformance advertisement.
    </t>
</section>
<section title="YANG Conformance Examples">
    <t>
In this example, 1 conformance profile called &quot;base&quot; is defined
for the YANG package named &quot;ietf&#8209;types&#8209;pkg&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
  package ietf-types-pkg {

    namespace "urn:ietf:params:xml:ns:yang:ietf-types-pkg";
    prefix "typespkg";
    organization
      "IETF NETMOD (NETCONF Data Modeling Language) Working Group";
    contact " ** WG Chairs ** ";
    description 
       "This package defines a conformance profile for the standard
        typedef statements.";

    revision 2013-09-16 {
       description "First revision";
       reference "TBD";
    }

    category general {
      subcategory types;
    }

    profile base {
      description "Basic requirements for YANG types.";

      require-module ietf-yang-types {
        min-revision "2013-07-15";
        require-conformance import;
        description
          "Support for YANG types  is required.";
        reference "RFC 6991, section 3.";
      }

      require-module ietf-inet-types {
        min-revision "2013-07-15";
        require-conformance import;
        description
          "Support for INET types  is required.";
        reference "RFC 6991, section 4.";
      }
    }
  }
	    ]]></artwork>
	</figure>
    <t>
In this example, 3 different conformance profiles are defined
for the YANG package named &quot;ietf&#8209;routing&#8209;pkg&quot;, called
&quot;base&quot;, &quot;ipv4&quot;, and &quot;ipv6&quot;&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
  package ietf-routing-pkg {

    namespace "urn:ietf:params:xml:ns:yang:ietf-routing-pkg";
    prefix "rtpkg";
    organization
      "IETF NETMOD (NETCONF Data Modeling Language) Working Group";
    contact " ** WG Chairs ** ";
    description 
       "This package defines conformance profiles for IPv4 and IPv6
        routers.";
    reference "draft-ietf-netmod-routing-cfg-10.txt";

    revision 2013-09-16 {
       description "First revision";
       reference "TBD";
    }

    category protocols {
      subcategory routing;
      subcategory ip;
    }

    profile base {
      description "Base module requirements for routing";
      reference "draft-ietf-netmod-routing-cfg-10.txt";

      require-package ietf-types-pkg;

      require-module ietf-routing {
         min-revision 2013-07-13; 
         require-conformance full;
         description "The base routing module is required";
      }

      require-module ietf-interfaces {
         min-revision 2013-07-04; 
         require-conformance augment;
         description "The interfaces table is augmented";
      }

    }

    profile ipv4 {
      description "Base module requirements for routing";
      reference "draft-ietf-netmod-routing-cfg-10.txt";

      include-profile base;

      require-module ietf-ipv4-unicast-routing {
         min-revision 2013-07-13; 
         require-conformance full;
      }
    }

    profile ipv6 {
      description "Base module requirements for routing";
      reference "draft-ietf-netmod-routing-cfg-10.txt";

      include-profile base;

      require-module ietf-ipv6-unicast-routing {
         min-revision 2013-07-13; 
         require-conformance full;
      }
    }

  }
	    ]]></artwork>
	</figure>
    <t>
In this example, 5 different conformance profiles are defined
for the YANG package named &quot;ietf&#8209;netconf&#8209;pkg&quot;:
    </t>
<t>
 <list style="symbols">
 <t>
core: core NETCONF functionality.
 </t>
 <t>
running: a server that supports writing directly to
the running datastore.
 </t>
 <t>
startup: a server that supports writing directly to
the running datastore and also has a separate startup
datastore.
 </t>
 <t>
candidate:- running: a server that supports writing
to the candidate datastore and committing all edits
at once to the running datastore.
 </t>
 <t>
confirmed:- running: a server that supports the
candidate conformance profile and also supports
the confirmed commit operations.
 </t>
 </list>
</t>
	<figure>
	    <artwork><![CDATA[
  package ietf-netconf-pkg {

    namespace "urn:ietf:params:xml:ns:yang:ietf-netconf-pkg";
    prefix "ncpkg";
    organization
      "IETF NETMOD (NETCONF Data Modeling Language) Working Group";
    contact " ** WG Chairs ** ";
    description 
       "This package defines some conformance profiles for the
        NETCONF protocol.";

    revision 2013-09-16 {
       description "First revision";
       reference "TBD";
    }

    category protocols {
      subcategory netconf;
    }

    profile core {
      description 
        "Basic requirements for complete NETCONF servers.";

      require-package ietf-type-pkg;

      require-capability "urn:ietf:params:netconf:base:1.1" {
        description "NETCONF base protocol is required.";
        reference "RFC 6241, section 8.1";
      }

      require-capability
        "urn:ietf:params:netconf:capability:xpath:1.0" {
        description "XPath filtering is required.";
        reference "RFC 6241, section 8.9";
      }

      require-capability
        "urn:ietf:params:netconf:capability:validate:1.1" {
        description "NETCONF :validate capability is required.";
        reference "RFC 6241, section 8.6";
      }

      require-capability
        "urn:ietf:params:xml:ns:netconf:partial-lock:1.0" {
        description
          "Partial lock capability is required. The YANG module
           ietf-netconf-partial-lock.yang is non-normative
           so a require-module statement is not used instead.";
        reference "RFC 5717, section 4";
      }

      require-capability
        "urn:ietf:params:netconf:capability:with-defaults:1.0" {
        description
          "With defaults capability advertisement is required.";
        reference "RFC 6243, section 4.3";
      }

      require-capability
        "urn:ietf:params:netconf:capability:notification:1.0" {
        description
          "Notification delivery support is required.";
        reference "RFC 5277, section 3.1";
      }

      require-capability
        "urn:ietf:params:netconf:capability:interleave:1.0" {
        description
          "Interleave of commands is required while notification
           delivery is active .";
        reference "RFC 5277, section 6";
      }

      require-module ietf-netconf-with-defaults {
        description
          "Support for <with-defaults> RPC parameter is required.";
        reference "RFC 6243, section 5";
      }

      require-module ietf-netconf-acm {
        description
          "Base module implementation of NACM is required.";
        reference "RFC 6536, section 3.5.2";
      }

      require-module ietf-netconf-monitoring {
        description
          "Implementation of NETCONF monitoring is required.";
        reference "RFC 6022, section 5";
      }

      require-module ietf-netconf-notifications {
        description
          "Implementation of NETCONF base notifications is
           required.";
        reference "RFC 6470, section 2.2";
      }
    }

    profile running {
      description 
        "Basic requirements for a complete NETCONF server
         that supports writing directly to the the running
         datastore.";

      include-profile core;

      require-capability
        "urn:ietf:params:netconf:capability:writable-running:1.0" {
        description
          "NETCONF :writable-running capability is required.";
        reference "RFC 6241, section 8.2";
      }

      require-capability
        "urn:ietf:params:netconf:capability:rollback-on-error:1.0" {
        description
          "NETCONF :rollback-on-error capability is required.";
        reference "RFC 6241, section 8.5";
      }
    }

    profile startup {
      description 
        "Basic requirements for a complete NETCONF server
         that supports writing directly to the the running
         datastore and also have a distinct startup datastore.";

      include-profile running;

      require-capability
        "urn:ietf:params:netconf:capability:startup:1.0" {
        description
          "NETCONF distinct startup capability is required.";
        reference "RFC 6241, section 8.7";
      }
    }

    profile candidate {
      description 
        "Basic requirements for a complete NETCONF server
         that supports the candidate datastore.";

      include-profile core;

      require-capability
        "urn:ietf:params:netconf:capability:candidate:1.0" {
        description "NETCONF :candidate capability is required.";
        reference "RFC 6241, section 8.3";
      }
    }

    profile confirmed {
      description 
        "Basic requirements for a complete NETCONF server
         that supports the candidate datastore, and confirmed
         commit functionality.";

      include-profile candidate;

      require-capability
        "urn:ietf:params:netconf:capability:confirmed-commit:1.1" {
        description
          "NETCONF :confirmed-commit capability is required.";
        reference "RFC 6241, section 8.4";
      }
    }
  }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="YANG Conformance Statements">
<section title="The package Statement" anchor="package-stmt">
    <t>
The &quot;package&quot; statement defines the YANG package&apos;s name, and contains
all YANG package header information and conformance profile statements.
The &quot;package&quot; statement&apos;s argument is the name of the YANG package,
followed by a block of substatements that hold detailed
package information. The package name follows the rules
for identifiers in RFC 6020, section 6.2.
    </t>
    <t>
A YANG package name is defined in the same conceptual namespace
as YANG module names.  The same rules for selecting non-conflicting
names apply as defined in RFC 6020, section 7.1.
    </t>
    <t>
An IANA registry for YANG package names will be needed,
similar to mechanism described in RFC 6020, section 14.
    </t>
<section title="The package Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> Substatement</ttcol>
<ttcol align='left'>Reference</ttcol>
<ttcol align='left'>Cardinality</ttcol>
<c>category</c>
<c><xref format="counter" target="category-stmt"/></c>
<c>0..1</c>
<c>contact</c>
<c>RFC 6020, 7.1.8</c>
<c>0..1</c>
<c>description</c>
<c>RFC 6020, 7.19.3</c>
<c>0..1</c>
<c>namespace</c>
<c>RFC 6020, 7.1.3</c>
<c>1</c>
<c>organization</c>
<c>RFC 6020, 7.1.7</c>
<c>0..1</c>
<c>prefix</c>
<c>RFC 6020, 7.1.4</c>
<c>1</c>
<c>profile</c>
<c><xref format="counter" target="profile-stmt"/></c>
<c>1..n</c>
<c>reference</c>
<c>RFC 6020, 7.19.4</c>
<c>0..1</c>
<c>revision</c>
<c>RFC 6020, 7.1.9</c>
<c>1..n</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="The category Statement" anchor="category-stmt">
    <t>
The &quot;category&quot; statement, which is optional, takes as
an argument the category identifier that best describes
the type of functionality provided by the YANG package.
    </t>
    <t>
There are no constraints or guidelines on selection
of a classification system at this time.  It is expected
that the IETF will create a classification system for
standard YANG modules. 
    </t>
<section title="The category Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> Substatement</ttcol>
<ttcol align='left'>Reference</ttcol>
<ttcol align='left'>Cardinality</ttcol>
<c>subcategory</c>
<c><xref format="counter" target="subcategory-stmt"/></c>
<c>0..n</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="The subcategory Statement" anchor="subcategory-stmt">
    <t>
The &quot;subcategory&quot; statement, which is optional, takes as
an argument the sub-category identifier that best describes
the type of functionality provided by the YANG package.
Zero or more subcategory statements are allowed
within each category statement;
    </t>
</section>
<section title="The profile Statement" anchor="profile-stmt">
    <t>
The &quot;profile&quot; statement is used to define one conformance profile
within a YANG package. It takes as an argument the profile name,
which is followed by a block of substatements that hold detailed
conformance information. The package name follows the rules
for identifiers in RFC 6020, section 6.2. 
    </t>
<section title="The profile Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> Substatement</ttcol>
<ttcol align='left'>Reference</ttcol>
<ttcol align='left'>Cardinality</ttcol>
<c>description</c>
<c>RFC 6020, 7.19.3</c>
<c>0..1</c>
<c>include-profile</c>
<c><xref format="counter" target="include-profile-stmt"/></c>
<c>0..n</c>
<c>reference</c>
<c>RFC 6020, 7.19.4</c>
<c>0..1</c>
<c>require-capability</c>
<c><xref format="counter" target="require-capability-stmt"/></c>
<c>0..n</c>
<c>require-module</c>
<c><xref format="counter" target="require-module-stmt"/></c>
<c>0..n</c>
<c>require-package</c>
<c><xref format="counter" target="require-package-stmt"/></c>
<c>0..n</c>
<c>status</c>
<c>RFC 6020, 7.19.2</c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="The include-profile Statement" anchor="include-profile-stmt">
    <t>
The &quot;include&#8209;profile&quot; statement is used to combine
multiple conformance profiles from the same YANG package.
It takes as an argument the name of the conformance profile
to include.  There are no substatements defined.
All of the requirements in the included profile
are also required in the profile that contains
the include-profile statement.
    </t>
    <t>
If any require-module, require-package, and/or
require-capability statements overlap due to multiple
included profiles, then they are logically combined
such that all requirements from all profiles are
included.
    </t>
    <t>
A profile MUST NOT include itself or any conformance profile
that would cause itself to be included via a dependency loop.
    </t>
</section>
<section title="The require-module Statement" anchor="require-module-stmt">
    <t>
The &quot;require&#8209;module&quot; statement is used to require
support for some or all of the definitions in a specific module.
It takes as an argument the name of the module
to require, followed by a block of substatements that
hold detailed module server support requirements.
    </t>
    <t>
A require-module statement MUST NOT specify the same module name
as another require-module statement in the same profile statement.
    </t>
    <t>
Submodules are invisible for conformance purposes,
because they are used as an implementation mechanism,
and are not directly accessible from an external module.
    </t>
<section title="The require-module Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> Substatement</ttcol>
<ttcol align='left'>Reference</ttcol>
<ttcol align='left'>Cardinality</ttcol>
<c>description</c>
<c>RFC 6020, 7.19.3</c>
<c>0..1</c>
<c>max-revision</c>
<c><xref format="counter" target="max-revision-stmt"/></c>
<c>0..1</c>
<c>min-revision</c>
<c><xref format="counter" target="min-revision-stmt"/></c>
<c>0..1</c>
<c>reference</c>
<c>RFC 6020, 7.19.4</c>
<c>0..1</c>
<c>require-conformance</c>
<c><xref format="counter" target="require-conformance-stmt"/></c>
<c>0..1</c>
<c>require-feature</c>
<c><xref format="counter" target="require-feature-stmt"/></c>
<c>0..n</c>
<c>require-object</c>
<c><xref format="counter" target="require-object-stmt"/></c>
<c>0..n</c>
</texttable>
<?rfc compact="no"?></section>
</section>
<section title="The min-revision Statement" anchor="min-revision-stmt">
    <t>
The &quot;min&#8209;revision&quot; statement is used to specify the
minimum acceptable revision date for the required module.
It takes as argument a date string in the form &quot;YYYY&#8209;MM&#8209;DD&quot;
where &quot;YYYY&quot; is the year, &quot;MM&quot; is the month, and &quot;DD&quot; is the day.
    </t>
    <t>
It is used in combination with the &quot;max&#8209;revision&quot;
statement to identify a range of release dates
that are acceptable for profile conformance.
    </t>
    <t>
If the min-revision statement is not present,
then there is no minimum revision date in the
acceptable range.
    </t>
    <t>
If the min-revision statement is present,
then only revisions of the required module
released on or after that date are acceptable for
profile conformance.
    </t>
    <t>
If the min-revision statement is present,
and the max-revision statement is also present,
then the min-revision statement MUST represent
a date which is the same or before the max-revision date.
    </t>
    <t>
This statement is needed if the conformance profile
relies on definitions that were added to the required module
in a particular revision.
    </t>
</section>
<section title="The max-revision Statement" anchor="max-revision-stmt">
    <t>
The &quot;max&#8209;revision&quot; statement is used to specify the
maximum acceptable revision date for the required module.
It takes as argument a date string in the form &quot;YYYY&#8209;MM&#8209;DD&quot;
where &quot;YYYY&quot; is the year, &quot;MM&quot; is the month, and &quot;DD&quot; is the day.
    </t>
    <t>
It is used in combination with the &quot;min&#8209;revision&quot;
statement to identify a range of release dates
that are acceptable for profile conformance.
    </t>
    <t>
If the max-revision statement is not present,
then there is no maximum revision date in the
acceptable range.
    </t>
    <t>
If the max-revision statement is present,
then only revisions of the required module
released on or before that date are acceptable for
profile conformance.
    </t>
    <t>
If the max-revision statement is present,
and the min-revision statement is also present,
then the max-revision statement MUST represent
a date which is the same or after the min-revision date.
    </t>
    <t>
This statement is needed if the conformance profile
relies on definitions that have been changed to obsolete
status in the required module, or have been extended or
altered in a manner that is not required in the conformance
profile.
    </t>
</section>
<section title="The require-conformance Statement" anchor="require-conformance-stmt">
    <t>
The &quot;require&#8209;conformance&quot; statement is used to describe the
type of module conformance that is needed to meet
the conformance profile requirements.  Its argument
is an enumerated string value indicating the
type of module conformance required.
    </t>
    <t>
There are 4 types of module conformance supported:
    </t>
<t>
 <list style="symbols">
 <t>
full: Full implementation of the module base is required.
This is the default value if the require-conformance
statement is not present.
 </t>
 <t>
augment: full implementation of the objects that are augmented
in this module (from the augmenting module) is required.
 </t>
 <t>
import: the module is required for meta-data definitions,
which includes extension, typedef, grouping, identity, 
and feature statements. No implementation of any objects
in the module is required.
 </t>
 <t>
ad-hoc: Partial implementation of the module base and/or
some conditional nodes is required. The require-module
statement SHOULD contain &quot;require&#8209;object&quot; statements
to identify the ad-hoc requirements.
 </t>
 </list>
</t>
</section>
<section title="The require-feature Statement" anchor="require-feature-stmt">
    <t>
The &quot;require&#8209;feature&quot; statement is used to indicate that
the specified YANG feature set is required for profile conformance.
It takes as argument the name of YANG feature that is required,
and is followed by a block of substatements that describe the
YANG feature usage within the conformance profile.
    </t>
<section title="The require-feature Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> Substatement</ttcol>
<ttcol align='left'>Reference</ttcol>
<ttcol align='left'>Cardinality</ttcol>
<c>description</c>
<c>RFC 6020, 7.19.3</c>
<c>0..1</c>
<c>reference</c>
<c>RFC 6020, 7.19.4</c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
   require-module ietf-ip {
     min-revision 2013-02-11;
     require-conformance full;
     require-feature ipv4-non-contiguous-netmasks {
       description
         "Configuration of non-contiguous subnet masks
          is required.";
       reference
          "RFC XXXX; Section XXXX";
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The require-object Statement" anchor="require-object-stmt">
    <t>
The &quot;require&#8209;object&quot; statement is used to indicate that
the specified YANG object is required for profile conformance.
It takes as argument the path string identifying the object.
This is similar to a YANG &quot;absolute&#8209;schema&#8209;nodeid&quot; except that
prefixes are not allowed.  Only objects defined in the
required module can be specified with this statement.
    </t>
    <t>
[FIXME: there is no way to specify that the objects that 1 module
adds to another with augment-stmt are required in ad-hoc mode.]
    </t>
<section title="The require-object Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> Substatement</ttcol>
<ttcol align='left'>Reference</ttcol>
<ttcol align='left'>Cardinality</ttcol>
<c>description</c>
<c>RFC 6020, 7.19.3</c>
<c>0..1</c>
<c>reference</c>
<c>RFC 6020, 7.19.4</c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
   require-module ietf-system {
     require-conformance ad-hoc;
     require-object /system-state/clock/current-datetime {
       description
         "The current system time must be provided.";
       reference
          "RFC XXXX; Section XXXX";
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The require-package Statement" anchor="require-package-stmt">
    <t>
The &quot;require&#8209;package&quot; statement is used to require
support for an external YANG package.
It takes as an argument the name of the YANG package
to require, followed by a block of substatements that
hold detailed server support requirements.
    </t>
    <t>
A require-package statement MUST NOT specify the same YANG
package name as another require-package statement in the
same profile statement.
    </t>
<section title="The require-package Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> Substatement</ttcol>
<ttcol align='left'>Reference</ttcol>
<ttcol align='left'>Cardinality</ttcol>
<c>description</c>
<c>RFC 6020, 7.19.3</c>
<c>0..1</c>
<c>max-revision</c>
<c><xref format="counter" target="max-revision-stmt"/></c>
<c>0..1</c>
<c>min-revision</c>
<c><xref format="counter" target="min-revision-stmt"/></c>
<c>0..1</c>
<c>reference</c>
<c>RFC 6020, 7.19.4</c>
<c>0..1</c>
<c>require-profile</c>
<c><xref format="counter" target="require-profile-stmt"/></c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
   require-package ietf-routing-pkg {
     min-revision 2013-09-16;
     require-profile ipv4;
     description
       "Support for IPv4 routing configuration is required.";
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="The require-profile Statement" anchor="require-profile-stmt">
    <t>
The &quot;require&#8209;profile&quot; statement is used to require
support for a specific conformance profile within an external YANG package.
It takes as an argument the name of the conformance profile
to require.
    </t>
</section>
<section title="The require-capability Statement" anchor="require-capability-stmt">
    <t>
The &quot;require&#8209;capability&quot; statement is used to indicate that
the specified NETCONF capability URI is required for profile conformance.
It takes as argument a URI string identifying the NETCONF capability
that is required,
and is followed by a block of substatements that describe the
NETCONF capability usage within the conformance profile.
    </t>
<section title="The require-capability Substatements">
<?rfc compact="yes"?><texttable>
<ttcol align='left'> Substatement</ttcol>
<ttcol align='left'>Reference</ttcol>
<ttcol align='left'>Cardinality</ttcol>
<c>description</c>
<c>RFC 6020, 7.19.3</c>
<c>0..1</c>
<c>reference</c>
<c>RFC 6020, 7.19.4</c>
<c>0..1</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Usage Example">
	<figure>
	    <artwork><![CDATA[
   profile full-notifications {
     description
       "A profile for requiring full standard NETCONF
        notification functionality.";
     require-capability 
       "urn:ietf:params:netconf:capability:notification:1.0" {
       description
         "Support for NETCONF notifications is required.";
       reference "RFC 5277, section 3.1.1";
     }
     require-capability 
       "urn:ietf:params:netconf:capability:interleave:1.0" {
       description
         "Support for the ability to accept <rpc> requests when
          NETCONF notification delivery is active is required.";
       reference "RFC 5277, section 6.3";
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
</section>
<section title="Updating a YANG Package">
    <t>
A YANG conformance profile definition needs to be altered
very carefully after it has been published, in order not
to break old clients that expect certain server behavior.
    </t>
    <t>
When a new revision of a YANG package is published,
the following restrictions apply:
    </t>
<t>
 <list style="symbols">
 <t>
An existing conformance profile definition MAY be altered
to correct errors in the definition.  
 </t>
 <t>
New statements (e.g. new requirements) MAY be added to an existing conformance
profile.
 </t>
 <t>
Existing requirements MUST NOT be removed from a conformance
profile.
 </t>
 <t>
Existing requirements MUST NOT be altered such that the
existing functionality would be take away from clients.
 </t>
 <t>
Existing requirements MAY be altered such that the
existing functionality appears unaffected to existing clients
that are using a previous revision of the conformance profile.
 </t>
 <t>
An existing conformance profile can be split into 
multiple new conformance profiles,
if the existing conformance profile adds &quot;include&#8209;profile&quot;
statements such that the required functionality for any
existing conformance profile does not change.
 </t>
 </list>
</t>
</section>
<section title="YANG Package Conformance Advertisement" anchor="capability">
    <t>
The YANG Package Conformance capability is used to allow the
client to
quickly identify which packages and conformance profiles
are supported by a particular NETCONF server.  The server
will advertise each supported YANG package, similar to
the YANG module conformance advertisement in RFC 6020, section 5.6.4.
    </t>
    <t>
The YANG package namespace URI MUST be advertised as a capability
in the NETCONF &lt;hello&gt; message to indicate support for a
specific conformance profile within the YANG package.
The capability URI MUST be of the form:
    </t>
	<figure>
	    <artwork><![CDATA[
     conf-capability-string   = namespace-uri [ parameter-list ]
     parameter-list      = "?" parameter *( "&" parameter )
     parameter           = package-parameter /
                           revision-parameter /
                           profile-parameter
     package-parameter   = "package=" package-name
     revision-parameter  = "revision=" revision-date
     profile-parameter   = "profile=" profile-name
	    ]]></artwork>
	</figure>
    <t>
Where:
    </t>
<t>
 <list style="symbols">
 <t>
&quot;package&#8209;name&quot; is the name of the YANG package
 </t>
 <t>
&quot;revision&#8209;date&quot; is the revision date of the YANG package
 </t>
 <t>
&quot;profile&#8209;name&quot; is the name of a conformance profile within the YANG package
 </t>
 </list>
</t>
    <t>
All 3 parameters MUST be present in the capability string.
Refer to <xref target="package-stmt"/> for details on the acceptable values
for these parameters.
    </t>
    <t>
Example: (capability string wrapped for display purposes only)
    </t>
	<figure>
	    <artwork><![CDATA[
  <capability>urn:ietf:params:xml:ns:yang:ietf-routing-pkg?
      package=ietf-routing-pkg&revision=2013-09-16&profile=ipv4
  </capability>
	    ]]></artwork>
	</figure>
</section>
<section title="YANG Conformance ABNF">
    <t>
&lt;CODE BEGINS&gt; file &quot;yang&#8209;conformance.abnf&quot;
    </t>
	<figure>
	    <artwork><![CDATA[
   package-stmt     = optsep package-keyword sep identifier-arg-str
                      optsep
                      "{" stmtsep
                          module-header-stmts
                          meta-stmts
                          revision-stmts
                          package-classify-stmts
                          package-body-stmts
                      "}" optsep

    package-classify-stmts = [category-stmt]

    category-stmt = category-keyword sep identifier-arg-str optsep
                    (";" /
                    "{" stmtsep
                        *(subcategory-stmt stmtsep)
                    "}")

    subcategory-stmt = subcategory-keyword sep string stmtend

    package-body-stmts  = *(profile-stmt stmtsep)

    profile-stmt =    profile-keyword sep identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [status-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                           *(include-profile-stmt stmtsep)
                           *(require-package-stmt stmtsep)
                           *(require-capability-stmt stmtsep)
                           *(require-module-stmt stmtsep)
                       "}")

    include-profile-stmt = include-profile-keyword sep 
                           identifier-arg-str stmtend

    require-module-stmt = require-module-keyword sep
                      identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [min-revision-stmt stmtsep]
                           [max-revision-stmt stmtsep]
                           [require-conformance-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                           *(require-feature-stmt stmtsep)
                           *(require-object-stmt stmtsep)
                       "}")

    require-object-stmt = require-object-keyword sep
                      require-object-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                       "}")

    require-object-arg-str = < a string that matches the rule
                              require-object-arg >

    require-object-arg   = pkg-absolute-schema-nodeid

    require-package-stmt = require-package-keyword sep
                      identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [min-revision-stmt stmtsep]
                           [max-revision-stmt stmtsep]
                           [require-profile-stmt stmtsep]
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                       "}")

    require-profile-stmt = require-profile-keyword sep
                      identifier-arg-str stmtend

    require-capability-stmt = require-capability-keyword sep
                      uri-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                       "}")

    min-revision-stmt = min-revision-keyword sep date-arg-str stmtend

    max-revision-stmt = max-revision-keyword sep date-arg-str stmtend

    require-feature-stmt = require-feature-keyword sep
                      identifier-arg-str optsep
                      (";" /
                       "{" stmtsep
                           ;; these stmts can appear in any order
                           [description-stmt stmtsep]
                           [reference-stmt stmtsep]
                       "}")

    require-conformance-stmt = require-conformance-keyword sep
                       require-conformance-arg-str stmtend

    require-conformance-arg-str =
                         < a string that matches the rule 
                          require-conformance-arg >

    require-conformance-arg = full-keyword /
                              augment-keyword /
                              import-keyword /
                              ad-hoc-keyword

    pkg-schema-nodeid   = pkg-absolute-schema-nodeid /
                          pkg-descendant-schema-nodeid

    pkg-absolute-schema-nodeid = 1*("/" pkg-node-identifier)

    pkg-descendant-schema-nodeid =
                          pkg-node-identifier
                          pkg-absolute-schema-nodeid

    pkg-node-identifier = identifier

    ;; new keywords
    ad-hoc-keyword              = 'ad-hoc'
    augment-keyword             = 'augment'
    category-keyword            = 'category'
    conformance-keyword         = 'conformance'
    full-keyword                = 'full'
    include-profile-keyword     = 'include-profile'
    max-revision-keyword        = 'max-revision'
    min-revision-keyword        = 'min-revision'
    package-keyword             = 'package'
    profile-keyword             = 'profile'
    require-capability-keyword  = 'require-capability'
    require-module-keyword      = 'require-module'
    require-feature-keyword     = 'require-feature'
    require-package-keyword     = 'require-package'
    require-profile-keyword     = 'require-profile'
    subcategory-keyword         = 'subcategory'

    ;; all other symbols are defined in RFC 6020, section 12
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
  <CODE ENDS>
	    ]]></artwork>
	</figure>
</section>
<section title="IANA Considerations" anchor="iana">
    <t>
TBD
    </t>
</section>
<section title="Security Considerations">
    <t>
TBD
    </t>
</section>
<section title="Open Issues">
<t>
 <list style="symbols">
 <t>
How can logical OR expressions be supported for modules,
features, and capabilities?  E.g. a &quot;writable&#8209;server&quot;
profile will need a require-capability for the :writable-running
or for the :candidate capabilities.  A server will usually advertise
one of these 2 capabilities, but not both of them.
 </t>
 <t>
Is some sort of &quot;choice&#8209;stmt&quot; needed within a profile-stmt,
to indicate that 1 of N cases of requirements must
be supported? Does the server need to advertise
the selected cases in every choice it supports?
 </t>
 <t>
Can a server support multiple conformance profiles at once?
If so, then multiple profiles per package would need to be advertised
in the YANG package capability exchange.
 </t>
 <t>
What if a server is configurable to support different profiles
from a given package?  Does the server advertise only the
configured profile? What if no profile has been configured yet?
Is a default conformance profile per YANG package needed?
 </t>
 <t>
Should Category be removed? If not, how much structure does it need?
How many category statements should be allowed per package?
Do conformance profiles need category statements?
 </t>
 <t>
What package and profile naming conventions are needed?
Do these identifiers need to share the same namespace as YANG modules?
 </t>
 <t>
Package file name layout conventions are probably needed like
those in RFC 6020, section 5.2.  A file extension for a YANG
package is needed.
 </t>
 <t>
Is a media type for a YANG package needed similar to
the definition in RFC 6020, section 14.1?
 </t>
 </list>
</t>
</section>
</middle>
<back>
<references title="Normative References">

  <reference anchor="RFC2119">
    <front>
      <title>Key words for use in RFCs to Indicate Requirement Levels</title>
      <author initials="S." surname="Bradner" fullname="S.  Bradner">
        <organization>Harvard University</organization>
      </author>
      <date month="March" year="1997"/>
      <abstract>
        <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.</t>
      </abstract>
    </front>
    <seriesInfo name="BCP" value="14"/>
    <seriesInfo name="RFC" value="2119"/>
    <format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
  </reference>


  <reference anchor='RFC6241'>
      <front>
        <title>Network Configuration Protocol (NETCONF)</title>
        <author initials='R.' surname='Enns' fullname='R. Enns' role="editor">
          <organization/>
        </author>
        <author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role="editor">
          <organization/>
        </author>
        <author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder' role="editor">
          <organization/>
        </author>
        <author initials='A.' surname='Bierman' fullname='A. Bierman' role="editor">
          <organization/>
        </author>
        <date year='2011' month='June'/>
      </front>
      <seriesInfo name='RFC' value='6241'/>
  </reference>


  <reference anchor="RFC6020">
    <front>
      <title>YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)</title>
      <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
        <organization/>
      </author>
      <date year="2010" month="October"/>
      <abstract>
        <t>YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications. [STANDARDS TRACK]</t>
      </abstract>
    </front>
    <seriesInfo name="RFC" value="6020"/>
    <format type="TXT" octets="324178" target="http://www.rfc-editor.org/rfc/rfc6020.txt"/>
  </reference>

<!--
    <reference anchor='RFC6021'>
      <front>
        <title>Common YANG Data Types</title>
        <author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder'>
          <organization/>
        </author>
        <date year='2010' month='October'/>
      </front>
      <seriesInfo name='RFC' value='6021'/>
    </reference>
-->

<!--
<reference anchor="RFC6536">

<front>
<title>Network Configuration Protocol (NETCONF) Access Control Model</title>
<author initials="A." surname="Bierman" fullname="A. Bierman">
<organization/></author>
<author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
<organization/></author>
<date year="2012" month="March"/>
<abstract>
<t>The standardization of network configuration interfaces for use with the Network Configuration Protocol (NETCONF) requires a structured and secure operating environment that promotes human usability and multi-vendor interoperability.  There is a need for standard mechanisms to restrict NETCONF protocol access for particular users to a pre-configured subset of all available NETCONF protocol operations and content.  This document defines such an access control model. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name="RFC" value="6536"/>
<format type="TXT" octets="90803" target="http://www.rfc-editor.org/rfc/rfc6536.txt"/>
</reference>
-->

</references>
<!--
<references title="Informative References">

  <reference anchor='RFC3688'>
    <front>
      <title>The IETF XML Registry</title>
      <author initials='M.' surname='Mealling' fullname='M. Mealling'>
        <organization /></author>
      <date year='2004' month='January' />
      <abstract>
        <t>This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas.</t></abstract></front>
    
    <seriesInfo name='BCP' value='81' />
    <seriesInfo name='RFC' value='3688' />
    <format type='TXT' octets='17325' target='http://www.rfc-editor.org/rfc/rfc3688.txt' />
  </reference>

</references>
-->
</back></rfc>
