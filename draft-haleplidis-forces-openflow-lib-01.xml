<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
	 which is available here: http://xml.resource.org.-->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!-- One method to get references from the online citation libraries.
 There has to be one entity for each item to be referenced. 
 An alternate method (rfc include) is described in the references.-->
  <!ENTITY RFC1812 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1812.xml">
  <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
  <!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
  <!ENTITY RFC5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
  <!ENTITY RFC3654 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3654.xml">
  <!ENTITY RFC3746 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3746.xml">
  <!ENTITY RFC5810 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5810.xml">
  <!ENTITY RFC5811 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5811.xml">
  <!ENTITY RFC5812 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5812.xml">
  <!ENTITY RFC5813 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5813.xml">
  <!ENTITY RFC6053 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6053.xml">
  <!ENTITY FORCESLIB SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-forces-lfb-lib-08.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors-->
<!-- For a complete list and description of processing instructions (PIs), 
	 please see http://xml.resource.org/authoring/README.html.-->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
	 (Here they are set differently than their defaults in xml2rfc v1.32)-->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation-->
<!-- control the table of contents (ToC)-->
<?rfc toc="yes"?>
<!-- generate a ToC-->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3-->
<!-- control references-->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1]-->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically-->
<!-- control vertical white space 
	 (using these PIs as follows is recommended by the RFC Editor)-->
<?rfc compact="no" ?>
<!-- Start each main section on a new page-->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items-->
<!-- end of list of popular I-D processing instructions-->
<rfc category="info" docName="draft-haleplidis-forces-openflow-lib-01" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
	 ipr values: full3667, noModification3667, noDerivatives3667
	 you can add the attributes updates="NNNN" and obsoletes="NNNN" 
	 they will automatically be output with "(if approved)"-->
  <!-- ***** FRONT MATTER *****-->
  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
	 full title is longer than 39 characters-->
    <title abbrev="ForCES OpenFlow library">Forwarding and Control Element Separation (ForCES) OpenFlow Model Library</title>
    <!-- add 'role="editor"' below for the editors if appropriate-->
    <!-- Another author who claims to be an editor-->
    <author fullname="Evangelos Haleplidis" initials="E.H." surname="Haleplidis">
      <organization>University of Patras</organization>
      <address>
        <postal>
          <street>Department of Electrical &amp; Computer Engineering</street>
          <!-- Reorder these if your country does things differently -->
          <city>Patras</city>
          <region/>
          <code>26500</code>
          <country>Greece</country>
        </postal>
        <email>ehalep@ece.upatras.gr</email>
        <!-- uri and facsimile elements may also be added-->
      </address>
    </author>
    <author fullname="Omar Cherkaoui" initials="O.C." surname="Cherkaoui">
      <organization>University of Quebec in Montreal</organization>
      <address>
        <postal>
          <street/>
          <!-- Reorder these if your country does things differently -->
          <city>Montreal</city>
          <region/>
          <code/>
          <country>Canada</country>
        </postal>
        <email>cherkaoui.omar@uqam.ca</email>
        <!-- uri and facsimile elements may also be added-->
      </address>
    </author>
    <author fullname="Susan Hares" initials="S.H." surname="Hares">
      <organization>Huawei</organization>
      <address>
        <postal>
          <street/>
          <!-- Reorder these if your country does things differently -->
          <city/>
          <region/>
          <code/>
          <country>USA</country>
        </postal>
        <email>shares@ndzh.com</email>
        <!-- uri and facsimile elements may also be added-->
      </address>
    </author>
    <author fullname="Weiming Wang" initials="W.M.W." surname="Wang">
      <organization>Zhejiang Gongshang University</organization>
      <address>
        <postal>
          <street>18 Xuezheng Str., Xiasha University Town </street>
          <!-- Reorder these if your country does things differently-->
          <city>Hangzhou</city>
          <region/>
          <code>310018</code>
          <country>P.R.China</country>
        </postal>
        <phone>+86-571-28877721</phone>
        <email>wmwang@zjgsu.edu.cn</email>
        <!-- uri and facsimile elements may also be added-->
      </address>
    </author>
    <date year="2012"/>
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill in the current day for you. If only the current year is specified, xml2rfc will fill in the current day and month for you. If the year is not the current one, it is necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the purpose of calculating the expiry date).  With drafts it is normally sufficient to specify just the year.-->
    <!-- Meta-data Declarations-->
    <area>Routing</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <!-- WG name at the upperleft corner of the doc,
	 IETF is fine for individual submissions.  
If this element is not present, the default is "Network Working Group",
	 which is used by the RFC Editor as a nod to the history of the IETF.-->
    <keyword>ForCES</keyword>
    <keyword>OpenFlow</keyword>
    <keyword>Model</keyword>
    <keyword>Library</keyword>
    <!-- Keywords will be incorporated into HTML output
	 files in a meta tag but they have no effect on text or nroff
	 output. If you submit your draft to the RFC Editor, the
	 keywords will be used for the search engine.-->
    <abstract>
      <t>This document describes the OpenFlow switch in Logical Function Blocks (LFBs)
used in the Forwarding and Control Element Separation (ForCES).  The
LFB classes are defined according to the ForCES Forwading Element (FE) model and ForCES
protocol specifications. The library includes the descriptions of the OpenFlow 
LFBs and the XML definitions.</t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction">
      <t>The purpose of this document is to create a library of Logical Functional Blocks that are necessary to describe an OpenFlow switch using the ForCES model. This includes DataTypes, MetaData and of course the LFBs.</t>
      <t>Readers of this document can get a better understanding of what are the internal parts of an OpenFlow switch in a more formal approach. Additionally having a ForCES-defined OpenFlow switch allows developers to build a purely ForCES based solution that understands the OF model or even a middleware so that ForCES-implemented OpenFlow switches may be controlled by an OpenFlow controller, or a ForCES Control Element (CE) may control OpenFlow switches</t>
      <section title="ForCES">
        <t>
          <xref target="RFC3746">ForCES</xref>, focuses on the communication and model necessary to separate control-plane functionality such as routing protocols, signaling protocols, and admission control, from data-forwarding-plane per-packet activities, such as packet forwarding, queuing, and header editing.</t>
        <t>The modeling of FEs is based on an abstraction using distinct Logical Functional Blocks (LFBs), which are interconnected in a directed graph, and receive, process, modify, and transmit packets along with metadata. An LFB is a block of encapsulated fine-grained operation of the forwarding plane. The <xref target="RFC5812">ForCES model</xref> additionally includes both a capability and a state model. One of the advantages of the ForCES Model is that it is independent of the actual implementation of the FE; it only provides a view of its capabilities and state that can be acted upon using the ForCES protocol. It is left to the forwarding plane developers to define how the FE functionality is represented using the model. </t>
        <t>The <xref target="RFC5810">ForCES protocol</xref> was developed to allow the CEs to determine the capabilities of each FE expressed by the FE model, to add and remove entries, parameters, query for statistics, and register for and receive events in a scalable fashion over secure and reliable means. The strength of the ForCES protocol stems from the fact that it is agnostic of the model, as a CE can control any Forwarding Element described with the ForCES model.</t>
      </section>
      <section title="OpenFlow">
        <t>
          <xref target="OpenFlowSpec1.1">OpenFlow</xref> is conceptually similar to ForCES on separating the control and forwarding plane. It provides a protocol that mediates between the controller and the switch. Unlike ForCES, the OpenFlow switch is statically defined to deal with flows and the protocol is aware of the flow components. An OpenFlow Switch consists of one or more flow tables, a group table that performs packet lookups and forwarding, and an OpenFlow channel to an external controller. A flow table is consisted of flow entries, each containing a set of match fields to match against packets, counters and instructions. The controller manages the switch via the OpenFlow protocol. Using this protocol, the controller can add, update, and delete flow and group entries. </t>
      </section>
    </section>
    <section title="Terminology and Conventions">
      <t/>
      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
			"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
			document are to be interpreted as described in [RFC2119].</t>
      </section>
      <section title="Definitions">
        <t>This document follows the terminology defined by ForCES related documents of RFC3654, RFC3746, RFC5810,RFC5811,RFC5812,RFC5812. The definitions are repeated below for clarity. Also additional definitions from the <xref target="OpenFlowSpec1.1">OpenFlow specification 1.1</xref> are also included.</t>
        <t>
          <list style="hanging">
            <t>Control Element (CE) - A logical entity that implements the ForCES
		  protocol and uses it to instruct one or more FEs on how to process
		  packets.  CEs handle functionality such as the execution of
		  control and signaling protocols.</t>
            <t>Forwarding Element (FE) - A logical entity that implements the
		  ForCES protocol.  FEs use the underlying hardware to provide
		  per-packet processing and handling as directed/controlled by one
		  or more CEs via the ForCES protocol.</t>
            <t>LFB (Logical Functional Block) - The basic building block that is
		  operated on by the ForCES protocol.  The LFB is a well defined,
		  logically separable functional block that resides in an FE and is
		  controlled by the CE via the ForCES protocol.  The LFB may reside
		  at the FE's datapath and process packets or may be purely an FE
		  control or configuration entity that is operated on by the CE.
		  Note that the LFB is a functionally accurate abstraction of the
		  FE's processing capabilities, but not a hardware-accurate
		  representation of the FE implementation.</t>
            <t>LFB Class and LFB Instance - LFBs are categorized by LFB Classes.
		  An LFB Instance represents an LFB Class (or Type) existence.
		  There may be multiple instances of the same LFB Class (or Type) in
		  an FE.  An LFB Class is represented by an LFB Class ID, and an LFB
		  Instance is represented by an LFB Instance ID.  As a result, an
		  LFB Class ID associated with an LFB Instance ID uniquely specifies
		  an LFB existence.</t>
            <t>LFB Metadata - Metadata is used to communicate per-packet state
		  from one LFB to another, but is not sent across the network.  The
		  FE model defines how such metadata is identified, produced, and
		  consumed by the LFBs.  It defines the functionality but not how
		  metadata is encoded within an implementation.</t>
            <t>LFB Components - Operational parameters of the LFBs that must be
		  visible to the CEs are conceptualized in the FE model as the LFB
		  components.  The LFB components include, for example, flags,
		  single-parameter arguments, complex arguments, and tables that the
		  CE can read and/or write via the ForCES protocol (see below).</t>
            <t>ForCES Protocol - While there may be multiple protocols used
		  within the overall ForCES architecture, the term "ForCES protocol"
		  and "protocol" refer to the "Fp" reference points in the ForCES
		  framework in [RFC3746].  This protocol does not apply to CE-to-CE
		  communication, FE-to-FE communication, or to communication between
		  FE and CE managers.  Basically, the ForCES protocol works in a
		  master-slave mode in which FEs are slaves and CEs are masters.</t>
            <t>ForCES Protocol Transport Mapping Layer (ForCES TML) - A layer in
		  ForCES protocol architecture that uses the capabilities of
		  existing transport protocols to specifically address protocol
		  message transportation issues, such as how the protocol messages
		  are mapped to different transport media (like TCP, IP, ATM,
		  Ethernet, etc.), and how to achieve and implement reliability,
		  multicast, ordering, etc.  The ForCES TML specifications are
		  detailed in separate ForCES documents, one for each TML.</t>
            <t>Match Field - a field against which a packet is matched, including packet headers, the ingress port,
				  and the metadata value.</t>
            <t>Action - an operation that forwards the packet to a port or modifies the packet, such as decrementing
					the TTL field. Actions may be specified as part of the instruction set associated with a flow entry or
					in an action bucket associated with a group entry.</t>
            <t>Flow entry - an element in a flow table used to match and process packets. It contains a set of match fields for matching packets, a set of counters to track packets, and a set of instructions to apply.</t>
            <t>Instruction - an operation that either contains a set of actions to add to the action set, contains a list
					of actions to apply immediately to the packet, or modifies pipeline processing.</t>
            <t>Flow Table - A stage of the pipeline, contains flow entries.</t>
            <t>OpenFlow pipeline - the set of linked flow tables that provide matching,
				  forwarding, and packet modifications in an OpenFlow switch.</t>
            <t>Groups - a list of action buckets and some means of choosing one or more of those buckets to apply on
a per-packet basis.</t>
            <t>Group Entry - an element in a group table. It contains a group identifier to distinguish groups, a group type to define the type of the group, a set of counters to track packets, and a set of action buckets.</t>
            <t>Action Bucket - a set of actions and associated parameters, defined for groups.</t>
            <t>Action Set - a set of actions associated with the packet that are accumulated while the packet is
					processed by each table and that are executed when the instruction set instructs the packet to exit the
					processing pipeline.</t>
            <t>Ports - where packets enter and exit the OpenFlow pipeline. May be a physical port, a logical port defined by the switch, or a reserved port defined by the specification.</t>
          </list>
        </t>
      </section>
    </section>
    <section title="OpenFlow ForCES library">
      <section title="OpenFlow Specification">
        <t>An OpenFlow switch as described in the <xref target="OpenFlowSpec1.1">OpenFlow Specification document</xref> appears in <xref target="OFDatapath"/>
        </t>
        <figure title="OpenFlow switch datapath" anchor="OFDatapath">
          <artwork align="center"><![CDATA[
+---------+                +---------+                   +---------+
|         |                |         |                   |         |
|  Port   |                |  Group  |                   |  Port   |
|         |                |  Table  |                   |         |
+---------+                +---------+                   +---------+
     | M1                                                     /\
     | M2                                                     |
     \/                                                       |
+---------+      +---------+            +---------+      +---------+
|         | M1   |         | M1         |         | M2   | Execute |
|  Flow   | ---> |  Flow   | -->...---> |  Flow   | ---> |  Action |
| Table 0 | M2   | Table 1 | M2         | Table N |      |   Set   |
+---------+ M3   +---------+ M3         +---------+      +---------+

Legend
M1: Ingress Port
M2: Action Set{}
M3: Metadata
				]]></artwork>
        </figure>
        <t>A packet enters the switch through a Port and is passed on the first Flow Table along with the Ingress Port as a Metadata (M1). Additionally each frame carries around a list of actions, called Action Set (M2), which have initially no actions in it. The Action Set will be executed at the end of the DataPath in the Execute Action Set block. After the first Flow Table another metadata called Metadata (M3) also accompanies the packet. This data inside the metadata maybe written by the Flow Tables when the Write Metadata instruction is applied.</t>
        <t>Each Flow Table performs a match based on certain fields (e.g IP Source Address or Source MAC Address) and then perform a specific instruction if there is a match. If no match occurs, the frame
   is processed based on the Flow Table's configuration. The choices are either:</t>
        <t>
          <list style="letters">
            <t>Forward to the OpenFlow controller</t>
            <t>Send to the next flow table</t>
            <t>Drop the frame</t>
          </list>
        </t>
        <t>The list of instructions a Flow Table may perform upon a match are:</t>
        <t>
          <list style="symbols">
            <t>Apply a List of actions</t>
            <t>Clear the Action Set</t>
            <t>Write actions on the action set</t>
            <t>Write Metadata</t>
            <t>Go to Flow Table (allows a FlowTable X to send the packet and metadata to any FlowTable Y, provided that X>Y)</t>
          </list>
        </t>
        <t>In OpenFlow there are two types of action executions which are independent of each other. The first one refered to as action list and is programmed into the flow table to be executed immediately within the packet pipeline upon a match on a flow table. The second one gets executed at the end of the pipeline in the execute action set. The second type of actions is collected in a metadata refered to as Action Set during the datapath processing with hte Write Actions instruction.</t>
        <t>The type of actions the Flow Table can perform or write in the Action Set is:</t>
        <t>
          <list style="symbols">
            <t>Setting of a field (e.g. IP address, MAC address)</t>
            <t>Push or Pop tags (VLAN, MPLS)</t>
            <t>Copy TTL inwards or outwards</t>
            <t>Decrease TTLs</t>
            <t>Output the packet to ports (a copy of the original packet will be sent to the port)</t>
            <t>Apply QoS to a packet</t>
            <t>Apply the packet to a group (a copy of the original packet will be sent to the group)</t>
          </list>
        </t>
        <t>Additionally a Flow Table may drop the packet. The drop is implicit based on the Flow Table's configuration (e.g. when there are no more instructions).</t>
        <t>An Action Set MUST contains a maximum of one action of each of the following class of types which MUST be executed in the order specified below regardless of the order they were added to the Action Set. The output action in the action set is executed last. If both an output action and a group action are specified in an action set, the output action is ignored and the group action takes precedence. If no output action and no group action were specified in an action set, the packet is dropped.</t>
        <t>
          <list style="numbers">
            <t>Copy TTL inwards</t>
            <t>Pop a tag (maximum one of VLAN tag, MPLS tag)</t>
            <t>Push a tags (maximum one of VLAN tag, MPLS tag)</t>
            <t>Copy TTL outwards</t>
            <t>Decrease TTL</t>
            <t>Setting of a field (maximum one of set IP address, set VLAN ID, etc...)</t>
            <t>Apply QoS to a packet</t>
            <t>Apply the packet to a group</t>
            <t>Output the packet</t>
          </list>
        </t>
        <t>The Group Table contains a set of Group Entries, each of which contains a set of Action Buckets, each of which contains a set of actions which can be applied to a group of packets that don't have the same set of matching fields. This alleviates the problem of having to set up the same set of actions in flow tables for different set of matching fields by having these set of actions in one place only.</t>
      </section>
      <section title="ForCES-based OpenFlow Specification">
        <t>ForCES models FEs using LFBs, fine-grained operations of the forwarding plane. It is logical to have at least the following LFB classes:</t>
        <t>
          <list style="numbers">
            <t>OFPort</t>
            <t>OFFlowTables</t>
            <t>OFGroupTable</t>
            <t>OFActions</t>
            <t>OFQueue</t>
          </list>
        </t>
        <t>Additionally packets may be sent to the controller or the controller may send packets to the switch to be put on the datapath. RedirectIn and RedirectOut are two LFBs defined in the <xref target="I-D.ietf-forces-lfb-lib">Base LFB Library</xref>. However as some more metadata are required for the OpenFlow switch, the OFRedirectIn and OFRedirectOut will be defined by extending the initial LFBs.</t>
        <t>While it may seem that having multiple OFFlowTables instances to represent each Flow Table in the OpenFlow, the authors decided to model the OFFlowTables to contain all the Flow Tables in one instance of the OFFlowTables. On of the OFFlowTables's components is an array of Flow Tables entries and each entry contains its own Flow Entries, Flow Table Counter and Miss Behaviour. The index of the Flow Tables entry represents the Flow Table ID. The rationale behind such a decision is the simplification of the model. With multiple ActionLFBs and multiple FlowTables, the resulting connection graph between Flow Tables and FlowTables and ActionLFBs would be very complex. Addionally this simplifies also the hanlding of two metadatas, the ActionSet Metadata and the Metadata which are now invisible to the model as they are passed only between Flow Tables. <xref target="OFFlowTables"/> shows an example of how the OFFlowTables is internally.</t>
        <t>
          <figure title="FlowTable Internal" anchor="OFFlowTables">
            <artwork align="center"><![CDATA[
     | From          /\To OFOutput        /\To Group    /\To Redirect
     | OFPorts       | Action             | Table        | Out
+----|---------------|--------------------|--------------|----------+
|    |               |                    |              |          |
|    |   +-----------+--------------------+--------------+          |                                       
|    \/  |           |                    |              |          |
| +--------+     +--------+           +--------+       +--------+   |
| |        | --> |        |           |        |       |        |   |
| |  Flow  |     |  Flow  |--+---+--> |  Flow  |-+--+->|  Flow  |   |
| | Table 0|--+  | Table 1|  |   /\   | Table 2| /\ /\ | Table N|   |
| +--------+  |  +--------+  |   |    +--------+ |  |  +--------+   |
|   /\  /\    |    /\  |     |   |      /\  |    |  |       /\      |
|   |   |     |    |   |     +----------|---|----+  |       |       |
|   |   |     |    |   |         |      |   |       |       |       |
|   |   |     +----|---+---------+------|---+-------+       |       |
|   |   |          |                    |                   |       |
|   |   +----------+-------------+------+-------------------+       |
|   |                            |                                  |
+---|----------------------------|----------------------------------+
    |From                        | To/From
    |Redirect In                 \/OFActions
				]]></artwork>
          </figure>
        </t>
        <t>
          <xref target="OFFlowTablesA"/> depicts what an OFFlowTables with its own set of ActionLFBs would look like. <xref target="OFFlowTablesB"/> depicts how the OFFlowTables work with a shared set of ActionLFBs with the OFGroupTable LFB look like.</t>
        <t>
          <figure title="ForCES FlowTable with each own set of ActionLFBs" anchor="OFFlowTablesA">
            <artwork align="center"><![CDATA[
      +------+ M1,M2,M3        M1,M2,M3   +---------+
      | Push | P(2)            P(1)       |   Set   |
      | Vlan |<----------+   +----------->|   IP    |
      |Header|           |   |            | Address |
      +------+           |   |            +---------+
         |               |   |                |
         | P(3),M1     +--------+  P(2),M1    |
         +------------>|        |<------------+
                       |        |
---------------------->| OFFlow |---------------------->
    P                  | Tables |    P(3)
                       |        |    
  +---------+  P,M1,M2 |        |
  |         | <------- |        |       Legend:
  |Decrement|          |        |       P:  Packet
  |  IP TTL |          +--------+       M1: PacketID
  |         |  P(1),M1     /\           M2: LFBClassID
  +---------+ -------------+            M3: ActionIndex
				]]></artwork>
          </figure>
        </t>
        <t>A packet P enters the OFFlowTables from an OFPortLFB. If a match occurs for the packet within the OFFlowTables and if the instruction for that match is an "Apply Action List" then the actions must be performed immediately and in the order specified in the action list. Alongside the packet, some metadata are passed as well. M1, the PacketID required by the OFFlowTables to identify the packet and continue exectution from where it stopped when it returns, M2 the LFBClassID so that the ActionLFB knows the ClassID of the LFB to return the packet and M3 the ActionIndex required in some ActionLFBs to determine parameters for the action. For example in <xref target="OFFlowTablesA"/> let's assume that the action list includes the following four actions:</t>
        <t>
          <list style="numbers">
            <t>Decrement IP TTL</t>
            <t>Set IP Address</t>
            <t>Push VLAN header</t>
            <t>Final Action</t>
          </list>
        </t>
        <t>The packet P will be first sent to the Decrement IP TTL Action LFB. Upon completion it will be returned as P1 to the OFFlowTables and then will be sent to the Set IP Address LFB. Upon return as P2 it will be sent to the Push VLAN Header and returned finally as P3 to the Flow Table LFB. Then depending upon the final action the packet may:</t>
        <t>
          <list style="symbols">
            <t>A copy of P3 will be sent to a Port LFB if it is an output action and the action set will be executed.</t>
            <t>A copy of P3 will be sent to the Group LFB if it is an group action and the action set will be executed.</t>
            <t>Remain in the OFFlowTables and checked for a match in the Flow Table specified by a Goto action if it is a goto action.</t>
          </list>
        </t>
        <t>
          <figure title="ForCES FlowTables and GroupTable with a common ActionLFB" anchor="OFFlowTablesB">
            <artwork align="center"><![CDATA[
     +---------+  P(1),M1,M2,M3
     | Set IP  |<-----------------+
     | Address |                  |
     |         |--------------+   |
     +---------+  P(2),M1     |   |
                              |   | 
                              |   |
                P(2),M1       \/  |
       +------+ M2,M3      +---------+
       | Push |<-----------|  Group  |   P3
       | Vlan |            |  Table  |------->
       |Header|----------->|         |
       +------+   P(3),M1  +---------+
     P  /\  |              P(1) /\   
     M1 |   |                   |    
     M2 |   |P(1),M1            |    
     M3 |   \/                  |    
      +--------+                |          Legend: 
  P   |        |----------------+          P: Packet
----->| OFFlow |                           M1: PacketID
      | Tables |---------------->          M2: LFBClassID
      +--------+   P(1)                    M3: ActionIndex
				]]></artwork>
          </figure>
        </t>
        <t>A packet enters the OFFlowTables from an OFPortLFB. If a match occurs for the packet within the OFFlowTables and if the instruction for that match is an "Apply Action List" then the actions must be performed immediately and in the order specified in the action list. For example in <xref target="OFFlowTablesB"/> let's assume that the action list includes the following three actions:</t>
        <t>
          <list style="numbers">
            <t>Push VLAN Header</t>
            <t>Group</t>
            <t>Output</t>
          </list>
        </t>
        <t>The packet P will be first sent to the Push VLAN header Action LFB and upon completion will be returned as P1 to the OFFlowTables. Then a copy of P1 will be sent to the Group Table LFB and then finally a copy of P1 will be sent to the Port LFB for output and the action set will be executed.</t>
        <t>Let's assume that the following actions will be executed for P1 in the action bucket in the Group Table.</t>
        <t>
          <list style="numbers">
            <t>Set IP Address</t>
            <t>Push Vlan Header</t>
            <t>Output</t>
          </list>
        </t>
        <t>The packet P1 will be sent to the Set IP Address Action LFB and upon completion will be returned as P2 to the Group Table. Then the packet P2 will be sent to the Push Vlan Header Action LFB and be returned as P3 to the Group Table and be sent to the Port LFB for output.</t>
        <t>Regarding the OFActions, when a match occurs in the OFFlowTables or an action bucket must be executed in the OFGroupTable it may contain multiple actions, it seems reasonable to separate each action as an individual LFB that performs that specific action. For every action needed to be executed, the OFFlowTables or the OFGroupTable will send the frame to the appropriate action LFB(s) in the order defined either by the Action Bucket or the instructions in the OFFlowTables's match entry. Once the packet has been processed from an Action LFB, it MUST be returned to the LFB instance that made that call. OFFlowTables and OFGroupTable LFB may either have shared ActionLFBs or separate.</t>
        <t>Current specified Action LFBs are:</t>
        <t>Output Actions</t>
        <t>
          <list style="symbols">
            <t>OFActionOutput</t>
          </list>
        </t>
        <t>Set Queue Actions</t>
        <t>
          <list style="symbols">
            <t>OFActionSetQueue</t>
          </list>
        </t>
        <t>Push/Pop Tag Actions</t>
        <t>
          <list style="symbols">
            <t>OFActionPushVLan</t>
            <t>OFActionPopVLAN</t>
            <t>OFActionPushMPLS</t>
            <t>OFActionPopMPLS</t>
          </list>
        </t>
        <t>Set Actions</t>
        <t>
          <list style="symbols">
            <t>OFActionSetMACSource</t>
            <t>OFActionSetMACDestination</t>
            <t>OFActionSetVLANVID</t>
            <t>OFActionSetVLANPriority</t>
            <t>OFActionSetMPLSLabel</t>
            <t>OFActionSetMPLSTC</t>
            <t>OFActionSetMPLSTTL</t>
            <t>OFActionDecrementMPLSTTL</t>
            <t>OFActionSetIPSource</t>
            <t>OFActionSetIPDestination</t>
            <t>OFActionSetIPTOS</t>
            <t>OFActionSetIPECN</t>
            <t>OFActionSetIPTTL</t>
            <t>OFActionDecrementIPTTL</t>
            <t>OFActionSetTCPSource</t>
            <t>OFActionSetTCPDestination</t>
            <t>OFActionCopyTTLOut</t>
            <t>OFActionCopyTTLIn</t>
          </list>
        </t>
        <t>Experimenter Actions</t>
        <t>
          <list style="symbols">
            <t>OFActionExperimenter</t>
          </list>
        </t>
        <t>Most Action LFBs have data associated with the action, e.g. an IP Address for the SetIPSource or SetIPDestination actions, stored in an array in the LFB. The FlowTable sending the packet needs to send additionally as a metadata an index pointing to the action parameter needed for the execution. Each Action LFB has one group input port that accepts a packet, the LFBClassID of the LFB that sent the packet, so that it can be returned after the action has been performed, and optionally the Action Index. Furthermore, one more metadata is required, the PacketID with which the Flow Table LFB or the Group Table LFB can keep track of a packet's progress. Additionally each Action LFB has one group output port that returns the altered packet to the sender. Since the action LFBs have these ports in common and the ForCES model can support augmentation of LFB classes, similar to inheritance in object oriented programming, an OFActionLFB has been specified from which all Action LFBs are derived from.</t>
        <t>The Action LFBs can be used also by the OFGroupTable using the same input and output port.</t>
        <t>Additionally each OFFlowTables can output a packet to a specific port through the OFOutputAction LFB. <xref target="OFFlowForCES"/> shows an example of a topology and how the various LFBs are interconnected. The controller can obtain the topology information by querying the FEObject's LFBTopology.</t>
        <t>
          <figure title="ForCES OpenFlow Switch example LFB connectivity" anchor="OFFlowForCES">
            <artwork align="center"><![CDATA[
     /\          /\            /\           /\             /\          
     | Out       | Out         | Out        | Out          | Out       
     |           |             |            |              |           
 +-------+    +-------+    +-------+     +-------+      +-------+
 |       |    |       |    |       |     |       |      |       |
 |OFQueue|    |OFQueue|    |OFQueue| ... |OFQueue|      |OFQueue|
 |       |    |       |    |       |     |       |      |       |
 +-------+    +-------+    +-------+     +-------+      +-------+    
     /\           /\           /\           /\             /\
     |            |            |            |              |
     |            +--+---------+            |              |
     |               |                      |              |
   +--------+     +--------+            +--------+     +--------+
In |        |     |        |<--  In  -->|        |     |        | In
-->| OFPort |     | OFPort |            | OFPort |     | OFPort |<--
   |        |     |        |     ...    |        |     |        |
   +--------+     +--------+            +--------+     +--------+
     |   /\         |   /\                |   /\           |  /\     
     |   |          |   |                 |   |            |  |     
     +---|----------+---|-----------------+---|------------+  |
     |   |              |                     |            |  |
     |   +--------------+------+--------------+---------------+
     |                         |
     |                    +----------+       +------------+   
     |                    |          |       |            |To
     |   +--------------->| OFOutput |------>| OFRedirect |-->
     |   |                |  Action  |       |    Out     |Controller
     |   |                +----------+       +------------+ 
     |   |                    /\                    /\ 
     \/  |                    |                     |
  +--------+              +---------+               | 
  |        |------------->|         |               |
  | OFFlow |              | OFGroup |               |
  | Tables |-----+        |  Table  |               |
  +--------+     |        +---------+               |
    /\   /\      |           /\                     |
    |    |       +-----------|----------------------+     
    |    |                   |     
    |    |    +--------------+-------------+--------------+
    |    |    |              |             |              |
    |    +----|----------+---|----------+--|-----------+  |
    |    |    |          |   |          |  |           |  |
    |    \/   \/         \/  \/         \/ \/          \/ \/
    |   +--------+     +--------+     +--------+     +--------+
    |   |        |     |        |     |        |     |        |
    |   |OFAction|     |OFAction|     |OFAction|     |OFAction|
    |   |        |     |        |     |        |     |        |
    |   +--------+     +--------+     +--------+     +--------+
    |
+------------+           
|            |From          
| OFRedirect |<--           
|     In     |Controller    
+------------+           
				]]></artwork>
          </figure>
        </t>
        <t>Regarding the execution of the Action Set, it is considered implementation specific and should be performed internally in the OFFlowTables using the ActionLFBs. Additionally the execution of OpenFlow's PacketOut message which contains a list of actions to be performed on a buffered or a redirected packet in the switch is also implementation specific and should also be performed internally in the OFFlowTables.</t>
        <t>OpenFlow 1.1 provides, with the use of the experimenter concept new instruction or action types. In this model, new instruction types can be modeled by expanding the InstructionTypes datatype definition and new action types can be modeled by creating new ActionLFBs.</t>
      </section>
    </section>
    <section title="OpenFlow Base Types">
      <t>Some datatypes in this LFB library are imported from <xref target="I-D.ietf-forces-lfb-lib">Base LFB Library</xref> as they have already been defined there.</t>
      <section title="Data Types">
        <t>Data types defined in the OpenFlow library are categorized by types of atomic, compound struct, and compound array.</t>
        <section title="Atomic">
          <t>The following data types are defined as atomic data types in the OpenFlow library:</t>
          <texttable title="OpenFlow Atomic Types" align="center">
            <ttcol>Data Type Name</ttcol>
            <ttcol>Brief Description</ttcol>
            <!-- -->
            <c>MPLSLabelValue</c>
            <c>An MPLS label</c>
            <!-- -->
            <c>MPLSTrafficClassValues</c>
            <c>The MPLS Traffic Class</c>
            <!-- -->
            <c>IPv4ToSbits</c>
            <c>TOSBits</c>
            <!-- -->
            <c>ActionType</c>
            <c>The possible actions</c>
            <!-- -->
            <c>InstructionTypes</c>
            <c>Instructions supported</c>
            <!-- -->
            <c>FlowTableMissConfigType</c>
            <c>Types to configure the default behavior of unmatched packets in a Flow Table</c>
            <!-- -->
            <c>PacketInTypes</c>
            <c>Packet In Types</c>
            <!-- -->
            <c>GroupBucketExecuteType</c>
            <c>	To determine which Action Bucket(s) should be executed (all, select, indirect, fast failover)</c>
            <!-- -->
            <c>PortNumberType</c>
            <c>Port Number values</c>
            <!-- -->
            <c>QueuePropertyType</c>
            <c>Property type for a queue</c>
          </texttable>
        </section>
        <section title="Compound Struct">
          <t>The following data types are defined as struct data types in the OpenFlow library:</t>
          <texttable title="OpenFlow Struct Types" align="center">
            <ttcol>Data Type Name</ttcol>
            <ttcol>Brief Description</ttcol>
            <!-- -->
            <c>SwitchDescriptionType</c>
            <c>Fields of the switch description</c>
            <!-- -->
            <c>WildcardsType</c>
            <c>Wildcards for fields</c>
            <!-- -->
            <c>MatchFieldType</c>
            <c>A Match Field Type (contains all possible match fields)</c>
            <!-- -->
            <c>FlowEntry</c>
            <c>A Flow entry type</c>
            <!-- -->
            <c>ActionRowType</c>
            <c>An Action Row for the action table</c>
            <!-- -->
            <c>TableCounterType</c>
            <c>Counter per table</c>
            <!-- -->
            <c>FlowCounterType</c>
            <c>Counter per flow</c>
            <!-- -->
            <c>WriteMetadataTableType</c>
            <c>Metadata and mask for the write metadata instruction per row</c>
            <!-- -->
            <c>GroupCounterType</c>
            <c>Counters per group</c>
            <!-- -->
            <c>BucketCounterType</c>
            <c>Counters per bucket</c>
            <!-- -->
            <c>GroupTableEntry</c>
            <c>A Row of the Group Table</c>
            <!-- -->
            <c>ActionBucket</c>
            <c>An Action Bucket</c>
            <!-- -->
            <c>PortConfigurationType</c>
            <c>Types of configuration for the OpenFlow port</c>
            <!-- -->
            <c>PortStateType</c>
            <c>Current State of the port</c>
            <!-- -->
            <c>PortFeaturesType</c>
            <c>Port Features</c>
            <!-- -->
            <c>PortCounterType</c>
            <c>Counter per port</c>
            <!-- -->
            <c>QueueArrayPropertiesType</c>
            <c>Type Definition for property</c>
            <!-- -->
            <c>QueueCounterType</c>
            <c>Counters per queue</c>
          </texttable>
        </section>
        <section title="Compound Array">
          <t>The following data types are defined as an array data type in the OpenFlow library</t>
          <texttable title="OpenFlow Array Types" align="center">
            <ttcol>Data Type Name</ttcol>
            <ttcol>Brief Description</ttcol>
            <!-- -->
            <c>Actions</c>
            <c>Actions to perform. An Array of ActionRowTypes</c>
          </texttable>
        </section>
      </section>
      <section title="Frame Types">
        <t>No additional frame types are defined in this library</t>
      </section>
      <section title="MetaData Types">
        <t>The following metadata are defined in the OpenFlow type library:</t>
        <texttable title="OpenFlow Metadata Types" align="center">
          <ttcol>MetaData Name</ttcol>
          <ttcol>Brief Description</ttcol>
          <ttcol>MetaData ID</ttcol>
          <ttcol>Metadata Type</ttcol>
          <!--Ingress Port -->
          <c>IngressPort</c>
          <c>The Ingress port the packet has arrived from.</c>
          <c>1024</c>
          <c>uint32</c>
          <!--InPhyPort-->
          <c>InPhyPort</c>
          <c>The Port Index of the Physical interface the frame entered the switch</c>
          <c>1025</c>
          <c>uint32</c>
          <!--PacketID-->
          <c>PacketID</c>
          <c>The PacketID metadata is used to uniquelly identify a packet within the Flow Table or the Group Table to continue processing it after it has been returned from an OFActionLFB.</c>
          <c>1026</c>
          <c>uint32</c>
          <!--ActionIndex-->
          <c>ActionIndex</c>
          <c>The Action Index metadata is used to point the row in the array in an Action LFB</c>
          <c>1027</c>
          <c>uint32</c>
          <!--GroupIndex-->
          <c>GroupIndex</c>
          <c>The Group index metadata is used to point to the row of the array in an Group LFB</c>
          <c>1028</c>
          <c>uint32</c>
          <!--LFBClassIDMetadata-->
          <c>LFBClassIDMetadata</c>
          <c>The LFBClassID</c>
          <c>1029</c>
          <c>uint32</c>
          <!--QueueID-->
          <c>QueueIDMetadata</c>
          <c>The Queue ID the packet should be sent to</c>
          <c>1030</c>
          <c>uint32</c>
          <!--BufferID-->
          <c>BufferID</c>
          <c>The Buffer ID of a stored packet in the switch requried for the PacketOut message</c>
          <c>1031</c>
          <c>uint32</c>
          <!--RedirectReason-->
          <c>RedirectReason</c>
          <c>The reason the packet was redirected to the controller</c>
          <c>1032</c>
          <c>uchar</c>
          <!--FlowTableID-->
          <c>FlowTableID</c>
          <c>The FlowTable ID the packet was sent to the controller from</c>
          <c>1033</c>
          <c>uchar</c>
          <!--ActionListMetadata-->
          <c>ActionListMetadata</c>
          <c>The Action List that may come along with the packet in a PacketOut message</c>
          <c>1032</c>
          <c>octetstring</c>
        </texttable>
      </section>
    </section>
    <section title="OpenFlow LFBs">
      <section title="OpenFlowSwitch">
        <t>Similar to the concept of the FEProtocol LFB and the FEObject LFB, the OpenFlowSwitchLFB contains information and configuration parameters regarding the functionality of the switch but play no role in the datapath processing. Therefore there are no input or output ports.</t>
        <section title="Data Handling">
          <t>This LFB does not handle any data.</t>
        </section>
        <section title="Components">
          <t>The DatapathID component, a unsigned integer of 64 bits,  uniquely identifies a datapath. The lower 48 bits are intended for the switch MAC
address, while the top 16 bits are up to the implementer. </t>
          <t>The MissSendLen component, an unsigned integer of 16 bits, defines the maximum number of bytes of each packet sent to the controller as a result of both flow table misses and flow table hits with the controller as the destination.</t>
          <t>The HandleFragments component, a Boolean, defines what the switch does with fragments. If true the switch will drop fragments. If false there is no special handling.</t>
          <t>The ReassembleFragments component, a Boolean, defines if the switch will reassemble fragments.</t>
          <t>The InvalidTTLtoController component, a Boolean, defines whether the switch will send packets with invalid TTL to the controller.</t>
          <t>The SwitchDescription component, a structure, contains the following information about the switch:</t>
          <t>
            <list style="symbols">
              <t>Manufacturer description</t>
              <t>Hardware description</t>
              <t>Software description</t>
              <t>Serial Number</t>
              <t>Human readable description of datapath</t>
            </list>
          </t>
          <t>Lastly the Ports component is an array which contains in its rows, all the port numbers.</t>
        </section>
        <section title="Capabilities">
          <t>The following capabilities have been defined for the OpenFlowSwitch LFB</t>
          <t>An assortment of Boolean type capabilities to define:</t>
          <t>
            <list style="symbols">
              <t>FlowStatistics. If the switch keeps flow statistics</t>
              <t>TableStatistics. If the switch keep table statistics</t>
              <t>PortStatistics. If the switch keep port statistics</t>
              <t>GroupStatistics. If the switch keep group statistics</t>
              <t>IPReassembly. If the switch can reassemble IP fragments</t>
              <t>QueueStats. If the switch keeps queue statistics</t>
              <t>ARPMatchIP. If the switch matches IP addresses in ARP packets</t>
            </list>
          </t>
          <t>The MaxBufferedPackets capability, an unsigned integer of 32 bits, defines the maximum packets the switch can buffer when sending packets to the controller.</t>
          <t>The TablesSupported capability, an unsigned integer of 8 bits, defines the number of tables supported by the switch, each of which can have a different set of supported wildcard bits and number of entries.</t>
          <t>Additionally the another capability, the ActionSupported, defines the supported actions for the switch.</t>
        </section>
        <section title="Events">
          <t>Three events have been specified regarding the ports. The first event will be triggered when a new port is added to the switch, the second when a port has been removed from the switch and the third when a port has been modified</t>
        </section>
      </section>
      <section title="OFFlowTables">
        <t>An LFB that houses all OpenFlow Flow Tables residing in the switch.</t>
        <section title="Data Handling">
          <t>The OFFlowTables describes the process of selecting packets and classify them into specific flows based on specific match fields assigned by the controller.</t>
          <t>The LFB is expected to receive all types of Ethernet packets through a group input named InputPort from an OFPort along with the IngressPort and the InPhyPort as metadata.</t>
          <t>All Flow Tables reside in an array within the LFB, the index of the array being the Flow Table ID. </t>
          <t>Each Flow Table compares the packet with the MatchFields inside the FlowEntries Table. If there is no match, depending upon the MissBehaviour component, one of the following actions will occur:</t>
          <t><list style="numbers">
            <t>The packet or part of it will be sent to the controller via the singleton output port RedirectPacketOut along with the IngressPort, InPhyPort, RedirectReason and FlowTableID as metadata and optionally the BufferID if the packet is buffered in the switch. How the packet is buffered in the switch is implementation specific.</t>
            <t>The packet will be sent it to the next table in the pipeline (the next flow table row entry in the array).</t>
            <t>The packet will be dropped.</t>
          </list></t>
          <t>If there is a match the LFB will decide based on the InstructionType of the component Instructions inside the matched FlowEntry.</t>
          <t>If the instruction is Apply Actions, the LFB will use the InstructionIndex to find the Actions inside the ApplyActionList. Each row of the ApplyActionList is an array containing rows of ActionRowTypes. For every ActionRowType, the LFB will send the packet to the corresponding Action LFB through the group output ActionPort port alongside with the LFBClassIDMetadata of the LFB, the PacketID and the ActionIndex, if the specific action has any parameters, like the Set MAC Address action. The ActionIndex is used as an index for the table inside the Action LFB. The packet is then returned from the Action LFB through the group input port PacketReturn to continue further processing if exists. The PacketID is an identifier issued by the OFFlowTables LFB that will uniquely identify the packet so that when it returns it will continue processing from whence it stopped.</t>
          <t>One exception to the rule when applying the action list is in regards to the Group action. The OFGroup LFB handles groups. The OFFlowTables using the ActionIndex locates the Group Identifier in the OFFlowTables's GroupTable component. Then it sends a copy of the packet to the GroupTableLFB using the group output ActionPort and the original packet will continue in the Flow Table.</t>
          <t>As the ActionSet metadata is an internal component of the OFFlowTables LFB, unreadable and unsettable by the Controller, both instructions Clear Actions and Write Actions are implementation specific. The same applies with the Write Metadata instruction.</t>
          <t>If the instruction is Goto Table, the LFB will use the InstructionIndex to find the value OFFlowTables InstanceID in the GoToFlowTable table and send the packet to the FLowTables row entry with the index of the FlowTable ID.</t>
          <t>Additionally the OFFlowTables handle packets incoming from the controller expecting either a whole packet through the RedirectPacketIn singleton input port or the buffer ID through the RedirectBufferIn singleton input port from the OFRedirectIn LFB, along with the ActionList and the IngressPort as metadata.</t>
        </section>
        <section title="Components">
          <t>The FlowTables, an array holding all Flow Tables of the switch. Each row of the array is a struct of the FlowEntries, the FlowTableCounter and the MissBehaviour for each flow. The FlowEntries component of the struct is an array and each row of the array is a struct containing the cookie, the MatchFields, the Counters, the Instructions, the Timeouts, the Timers and the priority of the specific flow entry. The FlowTableCounter are the counters of the specific FlowTable and the MissBehaviour component of the struct specifies what the specific Flow Table shall do with the packet if there is no match.</t>
          <t>The ApplyActionList is a component to maintain the actions required per flow. It is an array of Actions, which is an array of a struct of ActionType and ActionTableIndex.</t>
          <t>The WriteActions is a component to maintain the actions to be writen for a write actions instruction. It is an array of Actions, which is an array of a struct of ActionType and ActionTableIndex.</t>
          <t>The WriteMetadataTable is a component to hold the metadata values required for the write metadata value. It is an array of WriteMetadataTableType, which is a struct of the Metadata value and the MetadataMask.</t>
          <t>The GotoFlowTable component contains the FlowTable IDs flows should go to for the goto table action. It is an array of uint32. The value is selected using the InstructionIndex.</t>
          <t>The GroupTable component contains group identifiers. It is an array of group identifiers indexed by the ActionTableIndex.</t>
        </section>
        <section title="Capabilities">
          <t>This LFB has no capabilities specified.</t>
        </section>
        <section title="Events">
          <t>One event has been defined regarding the Flow Table. The event will be triggered when a flow is deleted from the Flow Table whether due to the idle timeout, or to the hard timeout or a flow was deleted by the controller.</t>
        </section>
      </section>
      <section title="OFGroupTable">
        <!--- XXX: Should the group table be an action LFB and derived from that? -->
        <t>The Group LFB contains Action Buckets that can be applied to a packet during its path in the Flow Tables pipeline.</t>
        <section title="Data Handling">
          <t>The OFGroupTable does not take part in the actual handling of the data. Rather, it contains the action per group which are required by all Flow Tables in the pipeline. Packets initially enter this LFB from an OFActionSet LFB or a OFFlowTables via the group input port PacketIn and using the GroupIndex metadata the LFB finds the group requested for this packet. Then the LFB depending on the requested actions sends the packet to the required OFActionLFBs via the group output ActionPort and expects results via the group input PacketReturn.</t>
        </section>
        <section title="Components">
          <t>The LFB has only one component which is the Group Table. This is an array of GroupTableEntry types. Each GroupTableEntry contains a Group Identifier, the type of Group, the required counters and an array of action buckets. </t>
          <t>An action bucket is a struct which contains the Group weight required for select groups, the watch port and watch group required for fast failover groups, the bucket counters and the actions for this bucket.</t>
          <t>The structure of actions in a bucket are identical to the actions in the flow table LFB containing the type of action and an action table index. With the action type and action index the Group LFB can identify the component and index of the action details.</t>
        </section>
        <section title="Capabilities">
          <t>This LFB has no capabilities specified.</t>
        </section>
        <section title="Events">
          <t>This LFB has no events specified.</t>
        </section>
      </section>
      <section title="OFPort">
        <section title="Data Handling">
          <t>This LFB abstract the point where packets enter and exit the OpenFlow switch pipeline. May be a physical port, a virtual port defined by the switch. The LFB handles Ethernet frames coming in or going out to/of the OpenFlow switch. Ethernet frames are received and passed to an OFFlowTables through the singleton output port PacketIn, along with the IngressPortID and InPhyPort metadata.</t>
          <t>When a packet is ready to be send on the wire, it is sent to an OFPort instance through the group input port PacketOut and then depending of whether the packet has been assigned a queue with the QueueID as metadata and then is sent to the OFQueue LFB via the group output port QueueOut.</t>
        </section>
        <section title="Components">
          <t>The PortNumber component uniquely identifies the port within a switch.</t>
          <t>The IEEEMAC component contains the MAC Address of the port.</t>
          <t>The Name component is a human readable name of the port.</t>
          <t>The Configuration component specifies port behaviour. It's a struct component with the following boolean fields. PortDown, NoReceiving, NoForwarding and NoPacket_In.</t>
          <t>The State component defines the current state of the OpenFlow Switch. It is a struct component that defines whether the link is down, the port is blocked or the port can be used for live fast failover.</t>
          <t>The Current Features component describes the current features of the port. It is a struct component and specifies the Speed Types, the Connected Medium, the Auto Negotiation and the Pause Types</t>
          <t>The Advertised Features component describes the advertised features of the port. The component is of the same structure as the current features.</t>
          <!-- XXX:Capability? -->
          <t>The CurrentSpeed component defines the current port bitrate in kbps.</t>
          <t>The MaximumSpeed component defines the maximum port bitrate in kbps.</t>
          <!-- XXX:Capability? -->
          <t>The PortCounter component contains the necessary counters for the port. It is a struct component comprised of counters for Packets Received, Packets Transmitted, Bytes Received, Bytes Transmitted, Drops Received, Transmit Drops, Errors in reception, Errors in transmittion, Frame Alignment Errors received, Received Overrun Errors, CRC Errors in received packets, Collisions.</t>
        </section>
        <section title="Capabilities">
          <t>Two capabilities has been defined for the Port LFB. Supported Features and Peer Features. These include:</t>
          <t>
            <list style="symbols">
              <t>Types of Speed supported</t>
              <t>Medium Connected to the port</t>
              <t>Auto-negotiation</t>
              <t>Pause Types supported of the port</t>
            </list>
          </t>
        </section>
        <section title="Events">
          <t>This LFB has no events specified.</t>
        </section>
      </section>
      <section title="OFQueue">
        <section title="Data Handling">
          <t>This LFB manages the queuing algorithm for handling packets prior to be output from the switch. Multiple OFQueue LFBs can be attached to an OFPort LFB to handle queues. If a packet has been set a QueueID with a Set Queue action, it is sent to the OFQueue LFB after the OFPort LFB and it enters this LFB via the group input port PacketIn where it will be handled according to the LFBs configuration and then be output from the switch.</t>
        </section>
        <section title="Components">
          <t>The QueueID component, a uint32, defines the ID for the specific queue.</t>
          <!-- XXX:Replace by LFBInstanceID? -->
          <t>The Properties component, is an array of Property Types an the length of the property, defines the current queue mode. Current specified modes are none and minimum rate.</t>
          <t>The QueueCounter component, a struct of TransmitPackets, TransmitBytes, TransimtOverrunErrors holds the necessary counter for the LFB.</t>
        </section>
        <section title="Capabilities">
          <t>This LFB has no capabilities specified.</t>
        </section>
        <section title="Events">
          <t>This LFB has no events specified.</t>
        </section>
      </section>
      <section title="OFRedirectIn">
        <t>The OFRedirectIn LFB abstracts the process for the controller to inject data packets into the switch to input data packets into the data path. The LFB is derived from the RedirectIn LFB defined in the <xref target="I-D.ietf-forces-lfb-lib">Base LFB Library</xref>.</t>
        <section title="Data Handling">
          <t>A packet or a bufferID arrives from the controller depending on whether the packet was buffered or not in the switch. If the packet was not buffered or the controller wishes to inject a packet into the switch, the packet will be output from the singleton output port PacketIn along with an ActionList and an IngressPort metadata to be sent to the OFFlowTables for processing. If the packet was buffered in the switch, the no packet is sent from the singleton output port BufferIn but only the BufferID, the ActionList and the IngressPort metadatas.</t>
        </section>
        <section title="Components">
          <t>This LFB has no components specified.</t>
        </section>
        <section title="Capabilities">
          <t>This LFB has no capabilities specified.</t>
        </section>
        <section title="Events">
          <t>This LFB has no events specified.</t>
        </section>
      </section>
      <section title="OFRedirectOut">
        <t>The OFRedirectOut LFB abstracts the process for the switch to deliver data packets to the controller. The LFB is derived from the RedirectIn LFB defined in the <xref target="I-D.ietf-forces-lfb-lib">Base LFB Library</xref>.</t>
        <section title="Data Handling">
          <t>A packet or part of a packet along with the BufferID metadata arrives from the group input port Outgoing from either the OFFlowTables or the OFActionOutput LFBs. Besides the optional BufferID metadata, the IngressPort, the InPhyPort and the RedirectReason and the optional FlowTableID are sent to the Outgoing input port required to be sent to the Controller as metadata.</t>
        </section>
        <section title="Components">
          <t>This LFB has no components specified.</t>
        </section>
        <section title="Capabilities">
          <t>This LFB has no capabilities specified.</t>
        </section>
        <section title="Events">
          <t>This LFB has no events specified.</t>
        </section>
      </section>
      <section title="OFAction">
        <t>This LFB is a template used for create OFActionLFBs. All OFActionLFBs have the input and output port in common but have different components. This LFB defines how input and output port of all OFActionLFBs. Inside OFActionLFBs there is a table with the required attributes where applicable as some OFActionLFBs don't require attributes.</t>
        <section title="Data Handling">
          <t>A packet arrives in an OFActionLFB via the group input PacketIn from an OFFlowTables or an OFGroupTable, along with the LFBClassID metadata, required to uniquely identify the sender, the PacketID and optionally the ActionIndex metadata if the action requires a specific attributes, the IngressPort, the InPhyPort and the QueueID required by the OFActionOutput. Once the packet has been processed it is return to the sender LFB via the group output PacketOut along with the PacketID.</t>
        </section>
        <section title="Components">
          <t>This LFB has no components specified.</t>
        </section>
        <section title="Capabilities">
          <t>This LFB has no capabilities specified.</t>
        </section>
        <section title="Events">
          <t>This LFB has no events specified.</t>
        </section>
      </section>
      <section title="OFActionLFBs">
        <t>As none of the OFActionLFBs have any capabilities or events, these sections are ommited from the draft.</t>
        <section title="OFActionOutput">
          <section title="Data Handling">
            <t>The OFActionOutputLFB does not modify the packet in any way, rather forwards a packet to a specified OFPort. Additionally there are several virtual ports that the OFActionOutputLFB may send the packet to:</t>
            <t>
              <list>
                <t>All -	Group output, sends the packet out all standard ports, but not to the ingress port or ports configured not to forward</t>
                <t>Controller - Sends the packet to the controller</t>
                <t>Table	- Submit the packet to the first flow table so that the packet can be processed through the regular OpenFlow pipeline. Only valid in the action list of a packet-out message</t>
                <t>InPort -	Sends the packet out the ingress port.</t>
                <t>Local	- Sends the packet to the switch's local networking stack</t>
                <t>Normal - Processes the packet using the traditional non-OpenFlow pipeline of the switch.</t>
                <t>Flood	- Floods the packet using the normal pipeline of the switch.</t>
                <!-- XXX: Do we need all these as individual output ports in the xml? Or can we cope with only one group output that connects to all OFPort instances? -->
              </list>
            </t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the OutputActionTable, which is an array of a struct of the port number and optionally the maximum length in bytes, if the receiving end is the controller.</t>
          </section>
        </section>
        <section title="OFActionSetVLANVID">
          <section title="Data Handling">
            <t>The OFActionSetVLANVIDLFB replaces the existing VLAN ID. Only applies to packets with an existing VLAN tag.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetVLANVIDActionTable, which is an array of uint16 VLAN tag values.</t>
          </section>
        </section>
        <section title="OFActionSetVLANPriority">
          <section title="Data Handling">
            <t>The OFActionSetVLANPriorityLFB replaces the existing VLAN priority. Only applies to packets with an existing VLAN tag.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetVLANPriorityActionTable, which is an array of uchar VLAN priority values.</t>
          </section>
        </section>
        <section title="OFActionSetMACSource">
          <section title="Data Handling">
            <t>The OFActionSetMACSourceLFB replaces the existing Ethernet source MAC address.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetMACSourceActionTable, which is an array of IEEEMAC addresses.</t>
          </section>
        </section>
        <section title="OFActionSetMACDestination">
          <section title="Data Handling">
            <t>The OFActionSetMACDestinationLFB replaces the existing Ethernet source MAC address.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetMACSourceActionTable, which is an array of IEEEMAC addresses.</t>
          </section>
        </section>
        <section title="OFActionSetIPSource">
          <section title="Data Handling">
            <t>The OFActionSetIPSourceLFB replaces the existing IP source address with new value and update the IP checksum (and TCP/UDP/SCTP checksum if applicable). This action is only applicable to IPv4 packets.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetIPSourceActionTable, which is an array of IPv4 addresses.</t>
          </section>
        </section>
        <section title="OFActionSetIPDestination">
          <section title="Data Handling">
            <t>The OFActionSetIPDestinationLFB replaces the existing IP destination address with new value and update the IP checksum (and TCP/UDP/SCTP checksum if applicable). This action is only applicable to IPv4 packets.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetIPDestinationActionTable, which is an array of IPv4 addresses.</t>
          </section>
        </section>
        <section title="OFActionSetIPTOS">
          <section title="Data Handling">
            <t>The OFActionSetIPTOSLFB replaces the existing IP TOS value and update the IP checksum. Only applies to IPv4 packets.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetIPTOSActionTable, which is an array of IPv4 uchar TOS values.</t>
          </section>
        </section>
        <section title="OFActionSetIPECN">
          <section title="Data Handling">
            <t>The OFActionSetIPECNLFB replaces the existing IP ECN value and update the IP checksum. Only applies to IPv4 packets.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetIPECNActionTable, which is an array of IPv4 uchar ECN values.</t>
          </section>
        </section>
        <section title="OFActionSetTCPSource">
          <section title="Data Handling">
            <t>The OFActionSetTCPSourceLFB replaces the existing TCP/UDP/SCTP source port with new value and update the TCP/UDP/SCTP checksum. This action is only applicable to TCP, UDP and SCTP packets.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetTCPSourceActionTable, which is an array of uint16 values.</t>
          </section>
        </section>
        <section title="OFActionSetTCPDestination">
          <section title="Data Handling">
            <t>The OFActionSetTCPDestinationLFB replaces the existing TCP/UDP/SCTP destination port with new value and update the TCP/UDP/SCTP checksum. This action is only applicable to TCP, UDP and SCTP packets.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetTCPDestinationActionTable, which is an array of uint16 values.</t>
          </section>
        </section>
        <section title="OFActionCopyTTLOut">
          <section title="Data Handling">
            <t>The OFActionCopyTTLOutLFB copies the TTL from next-to-outermost to outermost header with TTL. Copy can be IP-to-IP, MPLS-to-MPLS, or IP-to-MPLS.</t>
          </section>
          <section title="Components">
            <t>This LFB has no components specified.</t>
          </section>
        </section>
        <section title="OFActionCopyTTLIn">
          <section title="Data Handling">
            <t>The OFActionCopyTTLOutLFB copies the TTL from outermost to next-to-outermost header with TTL. Copy can be IP-to-IP, MPLS-to-MPLS, or IP-to-MPLS.</t>
          </section>
          <section title="Components">
            <t>This LFB has no components specified.</t>
          </section>
        </section>
        <section title="OFActionSetMPLSLabel">
          <section title="Data Handling">
            <t>The OFActionSetMPLSLabelLFB replaces the existing MPLS label. Only applies to packets with an existing MPLS shim header.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetMPLSLabelActionTable, which is an array of uint32 MPLS label values.</t>
          </section>
        </section>
        <section title="OFActionSetMPLSTC">
          <section title="Data Handling">
            <t>The OFActionSetMPLSTCLFB replaces the existing MPLS traffic class. Only applies to packets with an existing MPLS shim header.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetMPLSTCActionTable, which is an array of uchar MPLS label values.</t>
          </section>
        </section>
        <section title="OFActionSetMPLSTTL">
          <section title="Data Handling">
            <t>The OFActionSetMPLSTTLLFB replaces the existing MPLS TTL. Only applies to packets with an existing MPLS shim header.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetMPLSTTLTable, which is an array of uchar MPLS TTL values.</t>
          </section>
        </section>
        <section title="OFActionDecrementMPLSTTL">
          <section title="Data Handling">
            <t>The OFActionDecrementMPLSTTLLFB decrements the MPLS TTL. Only applies to packets with an existing MPLS shim header.</t>
          </section>
          <section title="Components">
            <t>This LFB has no components specified.</t>
          </section>
        </section>
        <section title="OFActionPushVLan">
          <section title="Data Handling">
            <t>The OFActionPushVLanLFB pushes a new VLAN header onto the packet. The Ethertype is used as the Ethertype for the tag. Only Ethertype 0x8100 and 0x88a8 should be used.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the PushVLANTable, which is an array of uint16 ethertypes.</t>
          </section>
        </section>
        <section title="OFActionPopVLAN">
          <section title="Data Handling">
            <t>The OFActionPopVLANLFB pops the outer-most VLAN header from the packet.</t>
          </section>
          <section title="Components">
            <t>This LFB has no components specified.</t>
          </section>
        </section>
        <section title="OFPushMPLSOFAction">
          <section title="Data Handling">
            <t>The OFPushMPLSOFActionLFB pushes a new MPLS shim header onto the packet. The Ethertype is used as the Ethertype for the tag. Only Ethertype 0x8847 and 0x8848 should be used.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the PushMPLSTable, which is an array of uint16 MPLS header values.</t>
          </section>
        </section>
        <section title="OFPopMPLSOFAction">
          <section title="Data Handling">
            <t>The OFPopMPLSOFActionLFB pops the outer-most MPLS tag or shim header from the packet. The Ethertype is used as the Ethertype for the resulting packet (Ethertype for the MPLS payload).</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the PopMPLSTable, which is an array of uint16 ethertype values.</t>
          </section>
        </section>
        <section title="OFSetQueueOFAction">
          <section title="Data Handling">
            <t>The OFSetQueueOFActionLFB sets the queue ID for the packet. This LFB will return the packet along with the QueueID as a metadata.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetQueueTable, which is an array of uint32 queue identifiers.</t>
          </section>
        </section>
        <section title="OFSetIPTTLOFAction">
          <section title="Data Handling">
            <t>The OFSetIPTTLOFActionLFB replaces the existing IP TTL and update the IP checksum. Only applies to IPv4 packets.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetIPTTLTable, which is an array of uchar TTL values.</t>
          </section>
        </section>
        <section title="OFDecrementIPTTLOFAction">
          <section title="Data Handling">
            <t>The OFDecrementIPTTLOFActionLFB decrements the existing IP TTL and update the IP checksum. Only applies to IPv4 packets.</t>
          </section>
          <section title="Components">
            <t>This LFB has no components specified.</t>
          </section>
        </section>
        <section title="OFExperimenterOFAction">
          <section title="Data Handling">
            <t>The OFExperimenterOFActionLFB handles experimenter actions.</t>
          </section>
          <section title="Components">
            <t>This LFB has only one component, the SetIPTTLTable, which is an array of uint32 Experimenter ID values.</t>
          </section>
        </section>
      </section>
    </section>
    <section title="XML for OpenFlow library">
      <t>
        <figure title="OpenFlow XML Library" align="left">
          <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<LFBLibrary xmlns="urn:ietf:params:xml:ns:forces:lfbmodel:1.0"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 provides="OpenFlowLibrary">
 <load library="BaseTypeLibrary"
 location="urn:ietf:params:xml:ns:forces:lfbmodel:1.0"/>
  <dataTypeDefs>
    <!-- Data Type Definition for the OpenFlow Switch -->
    <dataTypeDef>
      <name>SwitchDescriptionType</name>
      <synopsis>The type of the switch description</synopsis>
      <struct>
        <component componentID="1">
          <name>MFR</name>
          <synopsis>Manufacturer description</synopsis>
          <typeRef>string[256]</typeRef>
        </component>
        <component componentID="2">
          <name>HW</name>
          <synopsis>Hardware description</synopsis>
          <typeRef>string[256]</typeRef>
        </component>
        <component componentID="3">
          <name>SF</name>
          <synopsis>Software description</synopsis>
          <typeRef>string[256]</typeRef>
        </component>
        <component componentID="4">
          <name>SerialNum</name>
          <synopsis>Serial Number</synopsis>
          <typeRef>string[32]</typeRef>
        </component>
        <component componentID="5">
          <name>DP</name>
          <synopsis>Human readable description of datapath</synopsis>
          <typeRef>string[256]</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <!-- Data Type Definition for the Flow Match -->
    <dataTypeDef>
      <name>MPLSLabelValue</name>
      <synopsis>An MPLS label.</synopsis>
      <atomic>
        <baseType>uint32</baseType>
        <rangeRestriction>
          <allowedRange min="0" max="1048575"/>
        </rangeRestriction>
      </atomic>
    </dataTypeDef>
    <dataTypeDef>
      <name>MPLSTrafficClassValues</name>
      <synopsis>The MPLS Traffic Class</synopsis>
      <atomic>
        <baseType>uchar</baseType>
        <rangeRestriction>
          <allowedRange min="0" max="7"/>
        </rangeRestriction>
      </atomic>
    </dataTypeDef>
    <dataTypeDef>
      <name>IPv4ToSbits</name>
      <synopsis>TOSBits</synopsis>
      <atomic>
        <baseType>uchar</baseType>
        <rangeRestriction>
          <allowedRange min="0" max="63"/>
        </rangeRestriction>
      </atomic>
    </dataTypeDef>
    <dataTypeDef>
      <name>WildcardsType</name>
      <synopsis>Wildcards for fields</synopsis>
      <struct>
        <component componentID="1">
          <name>InPort</name>
          <synopsis>Input Port Wildcard</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="2">
          <name>VLANID</name>
          <synopsis>Vlan ID Wildcard</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="3">
          <name>VLANPCP</name>
          <synopsis>Vlan priority Wildcard</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="4">
          <name>DLType</name>
          <synopsis>Ethernet frame typ Wildcard</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="5">
          <name>IPToS</name>
          <synopsis>IP ToS Wildcard</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="6">
          <name>IPProtocol</name>
          <synopsis>IP Protocol Wildcard</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="7">
          <name>TPSource</name>
          <synopsis>TCP/UDP/SCTP source port Wildcard</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="8">
          <name>TPDestination</name>
          <synopsis>TCP/UDP/SCTP destination port Wildcard</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="9">
          <name>MPLSLabel</name>
          <synopsis>MPLS label Wildcard</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="10">
          <name>MPLSTC</name>
          <synopsis>MPLS TC Wildcard</synopsis>
          <typeRef>boolean</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>MatchFieldType</name>
      <synopsis>A Match Field Type</synopsis>
      <struct>
        <component componentID="1">
          <name>IngressPort</name>
          <synopsis>Numerical representation of incoming port, starting
          at 1. This may be a physical or switch-defined virtual port.
          </synopsis>
          <typeRef>uint32</typeRef>
        </component>
        <component componentID="2">
          <name>Wildcards</name>
          <synopsis>Wildcards for match fields</synopsis>
          <typeRef>WildcardsType</typeRef>
        </component>
        <component componentID="3">
          <name>EthernetSourceAddress</name>
          <synopsis>Ethernet source address</synopsis>
          <typeRef>IEEEMAC</typeRef>
        </component>
        <component componentID="4">
          <name>EthernetSourceAddressMask</name>
          <synopsis>Ethernet source address mask</synopsis>
          <typeRef>IEEEMAC</typeRef>
        </component>
        <component componentID="5">
          <name>EthernetDestinationAddress</name>
          <synopsis>Ethernet destination address</synopsis>
          <typeRef>IEEEMAC</typeRef>
        </component>
        <component componentID="6">
          <name>EthernetDestinationAddressMask</name>
          <synopsis>Ethernet destination address mask</synopsis>
          <typeRef>IEEEMAC</typeRef>
        </component>
        <component componentID="7">
          <name>VlanID</name>
          <synopsis>VLAN identifier of outermost VLAN tag.</synopsis>
          <typeRef>VlanIDType</typeRef>
        </component>
        <component componentID="8">
          <name>VlanPriority</name>
          <synopsis>VLAN PCP Field of outermost VLAN tag.</synopsis>
          <typeRef>VlanPriorityType</typeRef>
        </component>
        <component componentID="9">
          <name>EtherType</name>
          <synopsis>Ethernet type of the OpenFlow packet payload, after
          VLAN tags. 802.3 frames have special handling.</synopsis>
          <typeRef>uint16</typeRef>
        </component>
        <component componentID="10">
          <name>IPv4TOS</name>
          <synopsis>Specify as 8-bit value and place ToS in upper 6
          bits for match</synopsis>
          <typeRef>IPv4ToSbits</typeRef>
        </component>
        <component componentID="11">
          <name>IPProto</name>
          <synopsis>IP protocol or lower 8 bits of
          ARP opcode. Only the lower 8 bits of the ARP opcode are used
          for the match</synopsis>
          <typeRef>uchar8</typeRef>
        </component>
        <component componentID="12">
          <name>IPv4SourceAddress</name>
          <synopsis>IPv4 Source Address to match</synopsis>
          <typeRef>IPv4Addr</typeRef>
        </component>
        <component componentID="13">
          <name>IPv4SourceAddressMask</name>
          <synopsis>IPv4 Source Address mask</synopsis>
          <typeRef>IPv4Addr</typeRef>
        </component>
        <component componentID="14">
          <name>IPv4DestinationAddress</name>
          <synopsis>IPv4 Destination Address to match</synopsis>
          <typeRef>IPv4Addr</typeRef>
        </component>
        <component componentID="15">
          <name>IPv4DestinationAddressMask</name>
          <synopsis>IPv4 Destination Address mask</synopsis>
          <typeRef>IPv4Addr</typeRef>
        </component>
        <component componentID="16">
          <name>TCPSourcePort</name>
          <synopsis>Source Port for TCP and ICMP to match</synopsis>
          <typeRef>uint16</typeRef>
        </component>
        <component componentID="17">
          <name>TCPDestinationPort</name>
          <synopsis>Destination Port for TCP and ICMP to match
          </synopsis>
          <typeRef>uint16</typeRef>
        </component>
        <component componentID="18">
          <name>MPLSlabel</name>
          <synopsis>Match on outermost MPLS tag.</synopsis>
          <typeRef>MPLSLabelValue</typeRef>
        </component>
        <component componentID="19">
          <name>MPLSTrafficClass</name>
          <synopsis>Match on outermost MPLS tag for traffic class.
          </synopsis>
          <typeRef>MPLSTrafficClassValues</typeRef>
        </component>
        <component componentID="20">
          <name>Metadata</name>
          <synopsis>MetaData</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="21">
          <name>MetadataMask</name>
          <synopsis>MetaData Mask</synopsis>
          <typeRef>uint64</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <!-- Datatype Definition for Flow Table -->
    <dataTypeDef>
      <name>FlowEntry</name>
      <synopsis>A Flow entry</synopsis>
      <struct>
        <component componentID="1">
          <name>Cookie</name>
          <synopsis>Opaque data chosen by controller</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="2">
          <name>MatchFields</name>
          <synopsis>Match Fields: to match against packets. These
          consist of the ingress port and packet headers, and
          optionally metadata specified by a previous table</synopsis>
          <typeRef>MatchFieldType</typeRef>
        </component>
        <component componentID="3">
          <name>Counters</name>
          <synopsis>Counters: to update for matching packets</synopsis>
          <typeRef>FlowCounterType</typeRef>
        </component>
        <component componentID="4">
          <name>Instructions</name>
          <synopsis>Instruction: what to do with the packet of the flow
          </synopsis>
          <array>
            <struct>
              <component componentID="1">
                <name>InstructionType</name>
                <synopsis>The instruction type</synopsis>
                <typeRef>InstructionTypes</typeRef>
              </component>
              <component componentID="2">
                <name>InstructionIndex</name>
                <synopsis>The instruction index.</synopsis>
                <typeRef>uint32</typeRef>
              </component>
            </struct>
            <contentKey contentKeyID="1">
              <contentKeyField>InstructionType</contentKeyField>
            </contentKey>
          </array>
        </component>
        <component componentID="5">
          <name>Timeouts</name>
          <synopsis>Timeouts for the flow entry</synopsis>
          <struct>
            <component componentID="1">
              <name>IdleTimeout</name>
              <synopsis>Timeout to expire if no flows are matched for
              this flow entry</synopsis>
              <typeRef>uint16</typeRef>
            </component>
            <component componentID="2">
              <name>HardTimeout</name>
              <synopsis>Timeout to expire for this flow entry
              regardless of idle timeout</synopsis>
              <typeRef>uint16</typeRef>
            </component>
          </struct>
        </component>
        <component componentID="6">
          <name>Timers</name>
          <synopsis>Timers per flow</synopsis>
          <struct>
            <component componentID="1">
              <name>Duration_Sec</name>
              <synopsis>Time flow has been alive in seconds</synopsis>
              <typeRef>uint32</typeRef>
            </component>
            <component componentID="2">
              <name>Duration_nSec</name>
              <synopsis>Time flow has been alive in nanoseconds beyond
              Duration_Sec</synopsis>
              <typeRef>uint32</typeRef>
            </component>
          </struct>
        </component>
        <component componentID="7">
          <name>Priority</name>
          <synopsis>Priority within the specified flow table</synopsis>
          <typeRef>uint16</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>ActionRowType</name>
      <synopsis>An Action Row for the action table</synopsis>
      <struct>
        <component componentID="1">
          <name>Action</name>
          <synopsis>The type of action</synopsis>
          <typeRef>ActionType</typeRef>
        </component>
        <component componentID="2">
          <name>ActionTableIndex</name>
          <synopsis>Index of the Table this action applies to
          </synopsis>
          <typeRef>uint32</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>ActionType</name>
      <synopsis>The type of action</synopsis>
      <atomic>
        <baseType>uint16</baseType>
        <specialValues>
          <specialValue value="1">
            <name>OUTPUT</name>
            <synopsis>Output to switch port</synopsis>
          </specialValue>
          <specialValue value="2">
            <name>SetVLANVID</name>
            <synopsis>Set the 802.1q VLAN id</synopsis>
          </specialValue>
          <specialValue value="3">
            <name>SetVLANPCP</name>
            <synopsis>Set the 802.1q priority</synopsis>
          </specialValue>
          <specialValue value="4">
            <name>SetDLSrc</name>
            <synopsis>Set Ethernet source address</synopsis>
          </specialValue>
          <specialValue value="5">
            <name>SetDLDst</name>
            <synopsis>Set Ethernet destination address</synopsis>
          </specialValue>
          <specialValue value="6">
            <name>SetIPSrc</name>
            <synopsis>Set IP source address</synopsis>
          </specialValue>
          <specialValue value="7">
            <name>SetIPDst</name>
            <synopsis>Set IP Destination address</synopsis>
          </specialValue>
          <specialValue value="8">
            <name>SetIPTOS</name>
            <synopsis>Set ToS field</synopsis>
          </specialValue>
          <specialValue value="9">
            <name>SetIPECN</name>
            <synopsis>Set ECN field</synopsis>
          </specialValue>
          <specialValue value="10">
            <name>SetTPSource</name>
            <synopsis>TCP/UDP/SCTP source port</synopsis>
          </specialValue>
          <specialValue value="11">
            <name>SetTPDestination</name>
            <synopsis>TCP/UDP/SCTP destination port</synopsis>
          </specialValue>
          <specialValue value="12">
            <name>CopyTTLOut</name>
            <synopsis>Copy TTL "outwards" -- from next-to-outermost to
            outermost</synopsis>
          </specialValue>
          <specialValue value="13">
            <name>CopyTTLIn</name>
            <synopsis>Copy TTL "inwards" -- from outermost to 
            next-to-outermost</synopsis>
          </specialValue>
          <specialValue value="14">
            <name>SetMPLSLabel</name>
            <synopsis>Set MPLS label</synopsis>
          </specialValue>
          <specialValue value="15">
            <name>SetMPLSTC</name>
            <synopsis>Set MPLS TC</synopsis>
          </specialValue>
          <specialValue value="16">
            <name>SetMPLSTTL</name>
            <synopsis>Set MPLS TTL</synopsis>
          </specialValue>
          <specialValue value="17">
            <name>PushVLANTag</name>
            <synopsis>Push a new VLAN tag</synopsis>
          </specialValue>
          <specialValue value="18">
            <name>PopVLANTag</name>
            <synopsis>Pop the outer VLAN tag</synopsis>
          </specialValue>
          <specialValue value="19">
            <name>PushMPLSTag</name>
            <synopsis>Push a new MPLS tag</synopsis>
          </specialValue>
          <specialValue value="20">
            <name>PopMPLSTag</name>
            <synopsis>Pop the outer MPLS tag</synopsis>
          </specialValue>
          <specialValue value="21">
            <name>SetQueue</name>
            <synopsis>Set queue ID when outputting to a port</synopsis>
          </specialValue>
          <specialValue value="22">
            <name>Group</name>
            <synopsis>Apply group</synopsis>
          </specialValue>
          <specialValue value="23">
            <name>SetIPTTL</name>
            <synopsis>Set IP TTL</synopsis>
          </specialValue>
          <specialValue value="24">
            <name>DecIPTTL</name>
            <synopsis>Decrement IP TTL</synopsis>
          </specialValue>
        </specialValues>
      </atomic>
    </dataTypeDef>
    <dataTypeDef>
      <name>TableCounterType</name>
      <synopsis>Counter per table</synopsis>
      <struct>
        <component componentID="1">
          <name>ReferenceCount</name>
          <synopsis>Active Entries</synopsis>
          <typeRef>uint32</typeRef>
        </component>
        <component componentID="2">
          <name>PacketLookups</name>
          <synopsis>Packet Lookups</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="3">
          <name>PacketMatches</name>
          <synopsis>Packet Matches</synopsis>
          <typeRef>uint64</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>Actions</name>
      <synopsis>Actions to perform. An Array of ActionRowTypes
      </synopsis>
      <array>
        <typeRef>ActionRowType</typeRef>
      </array>
    </dataTypeDef>
    <dataTypeDef>
      <name>FlowCounterType</name>
      <synopsis>Counter per flow</synopsis>
      <struct>
        <component componentID="1">
          <name>ReceivedPackets</name>
          <synopsis>Packets Received</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="2">
          <name>ReceivedBytes</name>
          <synopsis>Bytes Received</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="3">
          <name>DurationS</name>
          <synopsis>Duration in seconds</synopsis>
          <typeRef>uint32</typeRef>
        </component>
        <component componentID="4">
          <name>DurationNS</name>
          <synopsis>Duration in nanoseconds</synopsis>
          <typeRef>uint32</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>InstructionTypes</name>
      <synopsis>Instructions supported</synopsis>
      <atomic>
        <baseType>short</baseType>
        <specialValues>
          <specialValue value="1">
            <name>GotoTable</name>
            <synopsis>Indicates the next table in the processing 
            pipeline. The table-id must be greater than the current
            table-id. The flows of last table of the pipeline can not
            include this instruction</synopsis>
          </specialValue>
          <specialValue value="2">
            <name>WriteMetadata</name>
            <synopsis>Writes the masked metadata value into the 
            metadata field. The mask specifies which bits of the 
            metadata register should be modified (i.e. new metadata = 
            old metadata and ~mask | value and mask)</synopsis>
          </specialValue>
          <specialValue value="3">
            <name>WriteAction</name>
            <synopsis>Merges the specifieed action(s) into the current
             action set. If an action of the given type exists in the
             current set, overwrite it, otherwise add it.</synopsis>
          </specialValue>
          <specialValue value="4">
            <name>ApplyActions</name>
            <synopsis>Applies the specific action(s) immediately, 
            without any change to the Action Set. This instruction may
            be used to modify the packet between two tables or to 
            execute multiple actions of the same type. The actions are
            specified as an action list</synopsis>
          </specialValue>
          <specialValue value="5">
            <name>ClearActions</name>
            <synopsis>Clears all the actions in the action set 
            immediately.</synopsis>
          </specialValue>
        </specialValues>
      </atomic>
    </dataTypeDef>
    <dataTypeDef>
      <name>WriteMetadataTableType</name>
      <synopsis>Metadata and mask for the write metadata instruction 
      per row</synopsis>
      <struct>
        <component componentID="1">
          <name>Metadata</name>
          <synopsis>The metadata</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="2">
          <name>MetadataMask</name>
          <synopsis>The metadata mask</synopsis>
          <typeRef>uint64</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>FlowTableMissConfigType</name>
      <synopsis>Types to configure the default behavior of unmatched 
      packets in a Flow Table</synopsis>
      <atomic>
        <baseType>uint32</baseType>
        <specialValues>
          <specialValue value="0">
            <name>Controller</name>
            <synopsis>Send to the controller</synopsis>
          </specialValue>
          <specialValue value="1">
            <name>Continue</name>
            <synopsis>Continue to the next table in the pipeline or 
            send to the controller if the FlowTable is the last.
            </synopsis>
          </specialValue>
          <specialValue value="2">
            <name>Drop</name>
            <synopsis>Drop the packet</synopsis>
          </specialValue>
        </specialValues>
      </atomic>
    </dataTypeDef>
    <dataTypeDef>
      <name>PacketInTypes</name>
      <synopsis>Packet-in Types</synopsis>
      <atomic>
        <baseType>uchar</baseType>
        <specialValues>
          <specialValue value="0">
            <name>NoMatch</name>
            <synopsis>No Matching flow</synopsis>
          </specialValue>
          <specialValue value="1">
            <name>Action</name>
            <synopsis>Explicit action to send to controller</synopsis>
          </specialValue>
        </specialValues>
      </atomic>
    </dataTypeDef>
    <!-- Data Type Definition for the group -->
    <dataTypeDef>
      <name>GroupCounterType</name>
      <synopsis>Counters per group</synopsis>
      <struct>
        <component componentID="1">
          <name>ReferenceCount</name>
          <synopsis>Flow Entries</synopsis>
          <typeRef>uint32</typeRef>
        </component>
        <component componentID="2">
          <name>PacketCount</name>
          <synopsis>Packet Count</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="3">
          <name>ByteCount</name>
          <synopsis>Byte Count</synopsis>
          <typeRef>uint64</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>GroupBucketExecuteType</name>
      <synopsis>To determine which Action Bucket(s) should be
       executed</synopsis>
      <atomic>
        <baseType>uchar</baseType>
        <specialValues>
          <specialValue value="1">
            <name>all</name>
            <synopsis>Execute all buckets in the group. This group is 
            used for multicast or broadcast forwarding. The packet is
            effectively cloned for each bucket; one packet is processed
            for each bucket of the group. If a bucket directs a packet
            explicitly out the ingress port, this packet clone is
            dropped. If the controller writer wants to forward out the
            ingress port, the group should include an extra bucket
            which includes an output action to the OFPP_IN_PORT virtual
            port.</synopsis>
          </specialValue>
          <specialValue value="2">
            <name>select</name>
            <synopsis>Execute one bucket in the group. Packets are sent
            to a single bucket in the group, based on a switch-computed
            selection algorithm (e.g. hash on some user-configured
            tuple or simple round robin). All configuration and state
            for the selection algorithm is external to OpenFlow. When a
            port speciffied in a bucket in a select group goes down,
            the switch may restrict bucket selection to the remaining
            set (those with forwarding actions to live ports) instead
            of dropping packets destined to that port. This behavior
            may reduce the disruption of a downed link or switch.
            </synopsis>
          </specialValue>
          <specialValue value="3">
            <name>indirect</name>
            <synopsis>Execute the one defined bucket in this group.
            Allows multiple flows or groups to point to a common group
            identifier, supporting faster, more efficient convergence
            (e.g. next hops for IP forwarding). This group type is
            effectively identical to an all group with one bucket.
            </synopsis>
          </specialValue>
          <specialValue value="4">
            <name>fastfailover</name>
            <synopsis>Execute the first live bucket. Each action bucket
            is associated with a specific port and/or group that
            controls its liveness. Enables the switch to change 
            forwarding without requiring a round trip to the 
            controller. If no buckets are live, packets are dropped.
            This group type must implement a liveness 
            mechanism.</synopsis>
          </specialValue>
        </specialValues>
      </atomic>
    </dataTypeDef>
    <dataTypeDef>
      <name>BucketCounterType</name>
      <synopsis>Counters per bucket</synopsis>
      <struct>
        <component componentID="1">
          <name>PacketCount</name>
          <synopsis>Packet Count</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="2">
          <name>ByteCount</name>
          <synopsis>Byte Count</synopsis>
          <typeRef>uint64</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>GroupTableEntry</name>
      <synopsis>A Row of the Group Table</synopsis>
      <struct>
        <component componentID="1">
          <name>GroupID</name>
          <synopsis>Group Identifier uniquely identifying the group
          </synopsis>
          <typeRef>uint32</typeRef>
        </component>
        <component componentID="2">
          <name>GroupType</name>
          <synopsis>The group type to determine which action bucket 
          will be executed.</synopsis>
          <typeRef>GroupBucketExecuteType</typeRef>
        </component>
        <component componentID="3">
          <name>GroupCounters</name>
          <synopsis>Counters per group</synopsis>
          <typeRef>GroupCounterType</typeRef>
        </component>
        <component componentID="4">
          <name>ActionBuckets</name>
          <synopsis>An ordered list of action buckets. Each action 
          bucket is a set of actions similar to a flow table</synopsis>
          <array>
            <typeRef>ActionBucket</typeRef>
          </array>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>ActionBucket</name>
      <synopsis>An Action Bucket</synopsis>
      <struct>
        <component componentID="1">
          <name>Weight</name>
          <synopsis>Relative weight of bucket. Only defined for select
          groups.</synopsis>
          <typeRef>uint16</typeRef>
        </component>
        <component componentID="2">
          <name>WatchPort</name>
          <synopsis>Port whose state affects whether this bucket is 
          live. Required for fast failover group</synopsis>
          <typeRef>uint32</typeRef>
        </component>
        <component componentID="3">
          <name>WatchGroup</name>
          <synopsis>Group whose state affects whether this group is
          live. Only required for fast failover groups</synopsis>
          <typeRef>uint32</typeRef>
        </component>
        <component componentID="4">
          <name>Actions</name>
          <synopsis>Actions for this bucket</synopsis>
          <typeRef>Actions</typeRef>
        </component>
        <component componentID="5">
          <name>BucketCounter</name>
          <synopsis>A counter for this bucket</synopsis>
          <typeRef>BucketCounterType</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <!-- Data Type Definition for ports -->
    <dataTypeDef>
      <name>PortNumberType</name>
      <synopsis>Port Number values</synopsis>
      <atomic>
        <baseType>uint32</baseType>
        <specialValues>
          <specialValue value="0xfffffff8">
            <name>InPort</name>
            <synopsis>Sent the packet out the input port. This virtual 
            port must be explicitly used in order to send back out of
            the input port</synopsis>
          </specialValue>
          <specialValue value="0xfffffff9">
            <name>Table</name>
            <synopsis>Submit the packet to the first flow table. NBL 
            This destination port can only be used in packet-out 
            messages</synopsis>
          </specialValue>
          <specialValue value="0xfffffffa">
            <name>Normal</name>
            <synopsis>Process with normal L2/L3 switching</synopsis>
          </specialValue>
          <specialValue value="0xfffffffb">
            <name>Flood</name>
            <synopsis>Send the packet to all physical ports in VLAN, 
            except input port and those blocked or link down</synopsis>
          </specialValue>
          <specialValue value="0xfffffffc">
            <name>All</name>
            <synopsis>Send the packet to all physical ports, except 
            input port.</synopsis>
          </specialValue>
          <specialValue value="0xfffffffd">
            <name>Controller</name>
            <synopsis>Send the packet to the controller.</synopsis>
          </specialValue>
          <specialValue value="0xfffffffe">
            <name>Local</name>
            <synopsis>Local openflow "port".</synopsis>
          </specialValue>
          <specialValue value="0xffffffff">
            <name>Any</name>
            <synopsis>Wildcard port used only for flow mod (delete) and
            flow stats requests. Selects all flows regardless of output
            port (including flows with no output port).</synopsis>
          </specialValue>
        </specialValues>
      </atomic>
    </dataTypeDef>
    <dataTypeDef>
      <name>PortConfigurationType</name>
      <synopsis>Types of configuration for the OpenFlow port</synopsis>
      <struct>
        <component componentID="1">
          <name>PortDown</name>
          <synopsis>Port is administatively down</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="2">
          <name>NoReceiving</name>
          <synopsis>Drop all packets received by this port</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="3">
          <name>NoForwarding</name>
          <synopsis>Drop packets forwarded to the port</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="4">
          <name>NoPacket_In</name>
          <synopsis>Do not send packet-in messages for port</synopsis>
          <typeRef>boolean</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>PortStateType</name>
      <synopsis>Current State of the port</synopsis>
      <struct>
        <component componentID="1">
          <name>LinkDown</name>
          <synopsis>No physical link present</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="2">
          <name>PortBlocked</name>
          <synopsis>Port is blocked</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="3">
          <name>PortLive</name>
          <synopsis>Live for Fast Failover Group</synopsis>
          <typeRef>boolean</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>PortFeaturesType</name>
      <synopsis>Port Features</synopsis>
      <struct>
        <component componentID="1">
          <name>SpeedTypes</name>
          <synopsis>Types of Speed supported</synopsis>
          <struct>
            <component componentID="1">
              <name>10MB_HD</name>
              <synopsis>10 Mb half-duplex rate support.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="2">
              <name>10MB_FD</name>
              <synopsis>10 Mb full-duplex rate support.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="3">
              <name>100MB_HD</name>
              <synopsis>100 Mb half-duplex rate support.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="4">
              <name>100MB_FD</name>
              <synopsis>100 Mb full-duplex rate support.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="5">
              <name>1GB_HD</name>
              <synopsis>1 Gb half-duplex rate support.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="6">
              <name>1GB_FD</name>
              <synopsis>1 Gb full-duplex rate support.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="7">
              <name>10GB_FD</name>
              <synopsis>10 Gb full-duplex rate support.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="8">
              <name>40GB_FD</name>
              <synopsis>40 Gb full-duplex rate support.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="9">
              <name>100GB_FD</name>
              <synopsis>100 Gb full-duplex rate support.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="10">
              <name>1TB_FD</name>
              <synopsis>1 Tb full-duplex rate support.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="11">
              <name>Other</name>
              <synopsis>Other rate, not listed.</synopsis>
              <typeRef>boolean</typeRef>
            </component>
          </struct>
        </component>
        <component componentID="2">
          <name>MediumConnected</name>
          <synopsis>Medium Connected to the port</synopsis>
          <struct>
            <component componentID="1">
              <name>Copper</name>
              <synopsis>Copper Medium</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="2">
              <name>Fiber</name>
              <synopsis>Fiber Medium</synopsis>
              <typeRef>boolean</typeRef>
            </component>
          </struct>
        </component>
        <component componentID="3">
          <name>Auto</name>
          <synopsis>Auto-negotiation</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="4">
          <name>PauseTypes</name>
          <synopsis>Pause Types supported of the port</synopsis>
          <struct>
            <component componentID="1">
              <name>Pause</name>
              <synopsis>Pause</synopsis>
              <typeRef>boolean</typeRef>
            </component>
            <component componentID="2">
              <name>AsymmetricPause</name>
              <synopsis>Asymmetric pause</synopsis>
              <typeRef>boolean</typeRef>
            </component>
          </struct>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>PortCounterType</name>
      <synopsis>Counter per port</synopsis>
      <struct>
        <component componentID="1">
          <name>ReceivedPackets</name>
          <synopsis>Packets Received</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="2">
          <name>TransmittedPackets</name>
          <synopsis>Packets Transmitted</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="3">
          <name>ReceivedBytes</name>
          <synopsis>Bytes Received</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="4">
          <name>TransmittedBytes</name>
          <synopsis>Bytes Transmitted</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="5">
          <name>ReceivedDrops</name>
          <synopsis>Drops Received</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="6">
          <name>TransmitDrops</name>
          <synopsis>Transmit Drops</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="7">
          <name>RecieveErrors</name>
          <synopsis>Errors in reception</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="8">
          <name>TransmitErrors</name>
          <synopsis>Errors in transmittion</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="9">
          <name>ReceivedFrameAlignmentErrors</name>
          <synopsis>Frame Alignment Errors received</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="10">
          <name>ReceiveOverrunErrors</name>
          <synopsis>Received Overrun Errors</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="11">
          <name>ReceivedCRCErrors</name>
          <synopsis>CRC Errors in received packets</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="12">
          <name>Collisions</name>
          <synopsis>Collisions</synopsis>
          <typeRef>uint64</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <!-- Data Type definitions for Queues -->
    <dataTypeDef>
      <name>QueuePropertyType</name>
      <synopsis>Property type for a queue</synopsis>
      <atomic>
        <baseType>uint16</baseType>
        <specialValues>
          <specialValue value="0">
            <name>None</name>
            <synopsis>No property defined</synopsis>
          </specialValue>
          <specialValue value="1">
            <name>MinimumRate</name>
            <synopsis>Minimum datarate guaranteed</synopsis>
          </specialValue>
        </specialValues>
      </atomic>
    </dataTypeDef>
    <dataTypeDef>
      <name>QueueArrayPropertiesType</name>
      <synopsis>Type Definition for property</synopsis>
      <struct>
        <component componentID="1">
          <name>Property</name>
          <synopsis>One of Queue Priority Types</synopsis>
          <typeRef>QueuePropertyType</typeRef>
        </component>
        <component componentID="2">
          <name>Length</name>
          <synopsis>Length of property</synopsis>
          <typeRef>uint32</typeRef>
        </component>
      </struct>
    </dataTypeDef>
    <dataTypeDef>
      <name>QueueCounterType</name>
      <synopsis>Counters per queue</synopsis>
      <struct>
        <component componentID="1">
          <name>TransmitPackets</name>
          <synopsis>Packets Transmitted</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="2">
          <name>TransmitBytes</name>
          <synopsis>Bytes Transmitted</synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="3">
          <name>TransimtOverrunErrors</name>
          <synopsis>Overrun Errors</synopsis>
          <typeRef>uint64</typeRef>
        </component>
      </struct>
    </dataTypeDef>
  </dataTypeDefs>
  <metadataDefs>
    <metadataDef>
      <name>IngressPort</name>
      <synopsis>The Ingress port the packet has arrived from</synopsis>
      <metadataID>1024</metadataID>
      <typeRef>uint32</typeRef>
    </metadataDef>
    <metadataDef>
      <name>InPhyPort</name>
      <synopsis>The Port Index of the Physical interface the frame 
      entered the switch</synopsis>
      <metadataID>1025</metadataID>
      <typeRef>uint32</typeRef>
    </metadataDef>
    <metadataDef>
      <name>PacketID</name>
      <synopsis>The PacketID metadata is used to uniquelly identify a
      packet within the Flow Table or the Group Table to continue
      processing it after it has been returned from an OFActionLFB.
      </synopsis>
      <metadataID>1026</metadataID>
      <typeRef>uint32</typeRef>
    </metadataDef>
    <metadataDef>
      <name>ActionIndex</name>
      <synopsis>The Action Index metadata is used to point the row in
      the array in an Action LFB </synopsis>
      <metadataID>1027</metadataID>
      <typeRef>uint32</typeRef>
    </metadataDef>
    <metadataDef>
      <name>GroupIndex</name>
      <synopsis>The Group index metadata is used to point to the row of
      the array in an Group LFB</synopsis>
      <metadataID>1028</metadataID>
      <typeRef>uint32</typeRef>
    </metadataDef>
    <metadataDef>
      <name>LFBClassIDMetadata</name>
      <synopsis>The LFBClassID</synopsis>
      <metadataID>1029</metadataID>
      <typeRef>uint32</typeRef>
    </metadataDef>
    <metadataDef>
      <name>QueueIDMetadata</name>
      <synopsis>The Queue ID</synopsis>
      <metadataID>1030</metadataID>
      <typeRef>uint32</typeRef>
    </metadataDef>
    <metadataDef>
      <name>BufferID</name>
      <synopsis>The Buffer ID of a stored packet in the switch requried
      for the PacketOut message</synopsis>
      <metadataID>1031</metadataID>
      <typeRef>uint32</typeRef>
    </metadataDef>
    <metadataDef>
      <name>RedirectReason</name>
      <synopsis>The reason the packet was redirected to the controller
      </synopsis>
      <metadataID>1032</metadataID>
      <atomic>
        <baseType>uchar</baseType>
        <specialValues>
          <specialValue value="0">
            <name>NoMatch</name>
            <synopsis>No match on the Flow Table (table miss)
            </synopsis>
          </specialValue>
          <specialValue value="1">
            <name>Action</name>
            <synopsis>Specific Output to controller action.</synopsis>
          </specialValue>
        </specialValues>
      </atomic>
    </metadataDef>
    <metadataDef>
      <name>FlowTableID</name>
      <synopsis>The FlowTable ID the packet was sent to the controller
      from</synopsis>
      <metadataID>1033</metadataID>
      <typeRef>uchar</typeRef>
    </metadataDef>
    <metadataDef>
      <name>ActionListMetadata</name>
      <synopsis>The Action List that may come along with the packet in
      a PacketOut message</synopsis>
      <metadataID>1034</metadataID>
      <typeRef>octetstring</typeRef>
    </metadataDef>
  </metadataDefs>
  <LFBClassDefs>
    <!-- OpenFlow Switch LFB -->
    <LFBClassDef LFBClassID="1024">
      <name>OFSwitch</name>
      <synopsis>Similar to the FEProtocol and FEObject LFB, the
      OpenFlowSwitch LFB contains information required for the OpenFlow
      protocol.</synopsis>
      <version>1.1</version>
      <components>
        <component componentID="1" access="read-only">
          <name>DatapathID</name>
          <synopsis>Datapath unique ID. The lower 48-bits are for a MAC
           address, while the upper 16-bits are implementer-defined.
           </synopsis>
          <typeRef>uint64</typeRef>
        </component>
        <component componentID="4" access="read-write">
          <name>MissSendLen</name>
          <synopsis>Max bytes of new flow that datapath should send to 
          the controller.</synopsis>
          <typeRef>uint16</typeRef>
        </component>
        <component componentID="5" access="read-write">
          <name>HandleFragments</name>
          <synopsis>if true drop fragments. If false no special 
          handling.</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="6" access="read-write">
          <name>ReassembleFragments</name>
          <synopsis>If true, reassemble fragments</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="7" access="read-write">
          <name>InvalidTTLtoController</name>
          <synopsis>Send packets with invalid TTL ie. 0 or 1 to
          controller</synopsis>
          <typeRef>boolean</typeRef>
        </component>
        <component componentID="8" access="read-only">
          <name>SwitchDescription</name>
          <synopsis>Information about the switch</synopsis>
          <typeRef>SwitchDescriptionType</typeRef>
        </component>
        <component componentID="9" access="read-write">
          <name>Ports</name>
          <synopsis>The Ports that this switch has. It is an array of
          the Port Numbers</synopsis>
          <array>
            <typeRef>uint32</typeRef>
          </array>
        </component>
      </components>
      <capabilities>
        <capability componentID="31">
          <name>FlowStatistics</name>
          <synopsis>Whether the switch keep flow statistics</synopsis>
          <typeRef>boolean</typeRef>
        </capability>
        <capability componentID="32">
          <name>TableStatistics</name>
          <synopsis>Whether the switch keep table statistics</synopsis>
          <typeRef>boolean</typeRef>
        </capability>
        <capability componentID="33">
          <name>PortStatistics</name>
          <synopsis>Whether the switch keep port statistics</synopsis>
          <typeRef>boolean</typeRef>
        </capability>
        <capability componentID="34">
          <name>GroupStatistics</name>
          <synopsis>Whether the switch keep group statistics</synopsis>
          <typeRef>boolean</typeRef>
        </capability>
        <capability componentID="35">
          <name>IPReassembly</name>
          <synopsis>Whether the switch can reassemble IP fragments
          </synopsis>
          <typeRef>boolean</typeRef>
        </capability>
        <capability componentID="36">
          <name>QueueStats</name>
          <synopsis>Whether the switch keeps queue statistics
          </synopsis>
          <typeRef>boolean</typeRef>
        </capability>
        <capability componentID="37">
          <name>ARPMatchIP</name>
          <synopsis>Whether the switch matches IP addresses in APR 
          packets</synopsis>
          <typeRef>boolean</typeRef>
        </capability>
        <capability componentID="38">
          <name>ActionsSupported</name>
          <synopsis>What actions are supported</synopsis>
          <array>
            <atomic>
              <baseType>ActionType</baseType>
              <rangeRestriction>
                <allowedRange max="65534" min="0"/>
              </rangeRestriction>
            </atomic>
            <contentKey contentKeyID="1">
              <contentKeyField>ActionType</contentKeyField>
            </contentKey>
          </array>
        </capability>
        <capability componentID="39">
          <name>MaxBufferedPackets</name>
          <synopsis>Maximum packets buffered at once.</synopsis>
          <typeRef>uint32</typeRef>
        </capability>
        <capability componentID="40">
          <name>TablesSupported</name>
          <synopsis>Number of tables supported by the datapath
          </synopsis>
          <typeRef>uchar</typeRef>
        </capability>
      </capabilities>
      <events baseID="61">
        <event eventID="1">
          <name>PortAdded</name>
          <synopsis>This event is sent when a port is added</synopsis>
          <eventTarget>
            <eventField>Ports</eventField>
          </eventTarget>
          <eventCreated/>
        </event>
        <event eventID="2">
          <name>PortDeleted</name>
          <synopsis>This event is sent when a port is deleted
          </synopsis>
          <eventTarget>
            <eventField>Ports</eventField>
          </eventTarget>
          <eventDeleted/>
        </event>
        <event eventID="3">
          <name>PortModified</name>
          <synopsis>This event is sent when a port is modified
          </synopsis>
          <eventTarget>
            <eventField>Ports</eventField>
          </eventTarget>
          <eventChanged/>
        </event>
      </events>
    </LFBClassDef>
    <!--FlowTable LFB -->
    <LFBClassDef LFBClassID="1025">
      <name>OFFlowTables</name>
      <synopsis>An LFB that houses all OpenFlow Flow Tables residing in
       the switch</synopsis>
      <version>1.1</version>
      <inputPorts>
        <inputPort group="true">
          <name>InputPort</name>
          <synopsis>An Input port that expects packets from an OFPort
          LFB</synopsis>
          <expectation>
            <frameExpected>
              <ref>Arbitrary</ref>
            </frameExpected>
            <metadataExpected>
              <ref>IngressPort</ref>
              <ref>InPhyPort</ref>
            </metadataExpected>
          </expectation>
        </inputPort>
        <inputPort group="true">
          <name>PacketReturn</name>
          <synopsis>A port that expects the packet to be returned from
          an OFActionLFB. If the OFActionLFB is the OFQueueLFB then the
          QueueID metadata is expected as well.</synopsis>
          <expectation>
            <frameExpected>
              <ref>Arbitrary</ref>
            </frameExpected>
            <metadataExpected>
              <ref>PacketID</ref>
              <ref dependency="optional">QueueID</ref>
            </metadataExpected>
          </expectation>
        </inputPort>
        <inputPort group="false">
          <name>RedirectPacketIn</name>
          <synopsis>A port that expects a packet from the controller
          </synopsis>
          <expectation>
            <frameExpected>
              <ref>Arbitrary</ref>
            </frameExpected>
            <metadataExpected>
              <ref>ActionList</ref>
              <ref>IngressPort</ref>
            </metadataExpected>
          </expectation>
        </inputPort>
        <inputPort group="false">
          <name>RedirectBufferIn</name>
          <synopsis>A port that expects a Buffer ID index from the
          controller</synopsis>
          <expectation>
            <metadataExpected>
              <ref>BufferID</ref>
              <ref>ActionList</ref>
              <ref>IngressPort</ref>
            </metadataExpected>
          </expectation>
        </inputPort>
      </inputPorts>
      <outputPorts>
        <outputPort group="true">
          <name>OutputPort</name>
          <synopsis>A port that produces packets leaving the flow table
          to go to the OFOutputAction (to be sent to an output port)
          </synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
            <metadataProduced>
              <one-of>
                <metadataSet>
                  <ref>IngressPort</ref>
                  <ref>InPhyPort</ref>
                </metadataSet>
                <metadataSet>
                  <ref>IngressPort</ref>
                  <ref>InPhyPort</ref>
                  <ref>QueueID</ref>
                </metadataSet>
              </one-of>
            </metadataProduced>
          </product>
        </outputPort>
        <outputPort group="true">
          <name>GroupPort</name>
          <synopsis>A port that produces packets leaving the flow table
          to go to the OFGroupTable.</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
            <metadataProduced>
              <one-of>
                <metadataSet>
                  <ref>IngressPort</ref>
                  <ref>InPhyPort</ref>
                  <ref>GroupIndex</ref>
                </metadataSet>
                <metadataSet>
                  <ref>IngressPort</ref>
                  <ref>InPhyPort</ref>
                  <ref>QueueID</ref>
                  <ref>GroupIndex</ref>
                </metadataSet>
              </one-of>
            </metadataProduced>
          </product>
        </outputPort>
        <outputPort group="true">
          <name>ActionPort</name>
          <synopsis>A port that sends the packet to an OFActionLFB
          </synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
            <metadataProduced>
              <one-of>
                <metadataSet>
                  <ref>LFBClassIDMetadata</ref>
                  <ref>PacketID</ref>
                </metadataSet>
                <metadataSet>
                  <ref>LFBClassIDMetadata</ref>
                  <ref>PacketID</ref>
                  <ref>ActionIndex</ref>
                </metadataSet>
              </one-of>
            </metadataProduced>
          </product>
        </outputPort>
        <outputPort group="false">
          <name>RedirectPacketOut</name>
          <synopsis>A port that sends a packet or part of it to the
          controller</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
            <metadataProduced>
              <one-of>
                <metadataSet>
                  <ref>IngressPort</ref>
                  <ref>InPhyPort</ref>
                  <ref>RedirectReason</ref>
                  <ref>FlowTableID</ref>
                </metadataSet>
                <metadataSet>
                  <ref>IngressPort</ref>
                  <ref>InPhyPort</ref>
                  <ref>RedirectReason</ref>
                  <ref>FlowTableID</ref>
                  <ref>BufferID</ref>
                </metadataSet>
              </one-of>
            </metadataProduced>
          </product>
        </outputPort>
      </outputPorts>
      <components>
        <component componentID="1" access="read-write">
          <name>FlowTables</name>
          <synopsis>Flow entries inside the FlowTable LFB</synopsis>
          <array>
            <struct>
              <component componentID="1">
                <name>FlowEntries</name>
                <synopsis>An array of Flow Entries</synopsis>
                <array>
                  <typeRef>FlowEntry</typeRef>
                </array>
              </component>
              <component componentID="2">
                <name>FlowTableCounter</name>
                <synopsis>A counter for each Flow Table</synopsis>
                <typeRef>TableCounterType</typeRef>
              </component>
              <component componentID="3">
                <name>MissBehaviour</name>
                <synopsis>What should the FlowTable do if a miss occurs
                </synopsis>
                <typeRef>FlowTableMissConfigType</typeRef>
              </component>
            </struct>
          </array>
        </component>
        <component componentID="2" access="read-write">
          <name>ApplyActionList</name>
          <synopsis>Table of actions for each flow</synopsis>
          <array>
            <typeRef>Actions</typeRef>
          </array>
        </component>
        <component componentID="3" access="read-write">
          <name>WriteActions</name>
          <synopsis>Table of Actions to write to the ActionSet
          </synopsis>
          <array>
            <typeRef>Actions</typeRef>
          </array>
        </component>
        <component componentID="4" access="read-write">
          <name>WriteMetadataTable</name>
          <synopsis>The write MetaDataTable</synopsis>
          <array>
            <typeRef>WriteMetadataTableType</typeRef>
          </array>
        </component>
        <component componentID="5" access="read-write">
          <name>GotoFlowTable</name>
          <synopsis>Containing the FlowTable IDs this flow should go
          to.</synopsis>
          <array>
            <typeRef>uint32</typeRef>
          </array>
        </component>
        <component componentID="6" access="read-write">
          <name>GroupTable</name>
          <synopsis>Table of group indeces to point a packet to
          </synopsis>
          <array>
            <typeRef>uint32</typeRef>
          </array>
        </component>
      </components>
      <events baseID="61">
        <event eventID="1">
          <name>FlowRemoved</name>
          <synopsis>If a CE subscribes to this event, it will send an 
          event when a flow is removed.</synopsis>
          <eventTarget>
            <eventField>FlowEntries</eventField>
            <eventSubscript>FlowEntry</eventSubscript>
          </eventTarget>
          <eventDeleted/>
          <eventReports>
            <eventReport>
              <eventField>FlowTableID</eventField>
            </eventReport>
            <eventReport>
              <eventField>FlowEntries</eventField>
              <eventSubscript>FlowEntry</eventSubscript>
              <eventField>Cookie</eventField>
            </eventReport>
            <eventReport>
              <eventField>FlowEntries</eventField>
              <eventSubscript>FlowEntry</eventSubscript>
              <eventField>MatchFields</eventField>
            </eventReport>
            <eventReport>
              <eventField>FlowEntries</eventField>
              <eventSubscript>FlowEntry</eventSubscript>
              <eventField>Timeouts</eventField>
              <eventSubscript>IdleTimeout</eventSubscript>
            </eventReport>
            <eventReport>
              <eventField>FlowEntries</eventField>
              <eventSubscript>FlowEntry</eventSubscript>
              <eventField>Priority</eventField>
            </eventReport>
          </eventReports>
        </event>
      </events>
    </LFBClassDef>
    <!-- GroupTable LFB -->
    <LFBClassDef LFBClassID="1026">
      <name>OFGroupTable</name>
      <synopsis>The OpenFlow Group Tables</synopsis>
      <version>1.1</version>
      <inputPorts>
        <inputPort group="true">
          <name>PacketIn</name>
          <synopsis>A port to expect packets, the GroupIndex metadata,
          the IngressPort and InPhyPort and optionally the QueueID if
          the packet has already been through the OFActionSetQueue LFB.
          </synopsis>
          <expectation>
            <frameExpected>
              <ref>Arbitrary</ref>
            </frameExpected>
            <metadataExpected>
              <ref>GroupIndex</ref>
              <ref>IngressPort</ref>
              <ref>InPhyPort</ref>
              <ref dependency="optional">QueueID</ref>
            </metadataExpected>
          </expectation>
        </inputPort>
        <inputPort group="true">
          <name>PacketReturn</name>
          <synopsis>A port that expects the packet to be returned from
          an OFActionLFB. If the OFActionLFB is the OFQueueLFB then the
          QueueID metadata is expected as well.</synopsis>
          <expectation>
            <frameExpected>
              <ref>Arbitrary</ref>
            </frameExpected>
            <metadataExpected>
              <ref>PacketID</ref>
              <ref dependency="optional">QueueID</ref>
            </metadataExpected>
          </expectation>
        </inputPort>
      </inputPorts>
      <outputPorts>
        <outputPort group="true">
          <name>PacketOut</name>
          <synopsis>The port to return the packet to caller</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
          </product>
        </outputPort>
        <outputPort group="true">
          <name>ActionPort</name>
          <synopsis>A port that sends the packet to an OFActionLFB
          </synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
            <metadataProduced>
              <one-of>
                <metadataSet>
                  <ref>LFBClassIDMetadata</ref>
                  <ref>LFBInstanceIDMetadata</ref>
                </metadataSet>
                <metadataSet>
                  <ref>LFBClassIDMetadata</ref>
                  <ref>LFBInstanceIDMetadata</ref>
                  <ref>ActionIndex</ref>
                </metadataSet>
              </one-of>
            </metadataProduced>
          </product>
        </outputPort>
      </outputPorts>
      <components>
        <component componentID="1">
          <name>GroupTable</name>
          <synopsis>The group table</synopsis>
          <array>
            <typeRef>GroupTableEntry</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <!-- Port LFB -->
    <LFBClassDef LFBClassID="1027">
      <name>OFPort</name>
      <synopsis>Input or Output port of an OpenFlow switch</synopsis>
      <version>1.1</version>
      <inputPorts>
        <inputPort group="false">
          <name>PacketOut</name>
          <synopsis>The input port of the Port LFB from the
          OFActionOutput LFB to output packets.</synopsis>
          <expectation>
            <frameExpected>
              <ref>Arbitrary</ref>
            </frameExpected>
            <metadataExpected>
              <ref dependency="optional">QueueID</ref>
            </metadataExpected>
          </expectation>
        </inputPort>
      </inputPorts>
      <outputPorts>
        <outputPort group="false">
          <name>PacketIn</name>
          <synopsis>Sends a packet to the OFFlowTables that is received
          by the OFPort LFB.</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
            <metadataProduced>
              <ref>IngressPort</ref>
              <ref>InPhyPort</ref>
            </metadataProduced>
          </product>
        </outputPort>
        <outputPort group="true">
          <name>QueueOut</name>
          <synopsis>Sends a packet to the OFQueue LFB to be processed
          and output from the switch</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
          </product>
        </outputPort>
      </outputPorts>
      <components>
        <component componentID="1" access="read-only">
          <name>PortNumber</name>
          <synopsis>The port number uniquely identifies a port within a
          switch.</synopsis>
          <typeRef>PortNumberType</typeRef>
        </component>
        <component componentID="2" access="read-only">
          <name>IEEEMAC</name>
          <synopsis>MAC Address of the port</synopsis>
          <typeRef>IEEEMAC</typeRef>
        </component>
        <component componentID="3" access="read-only">
          <name>Name</name>
          <synopsis>Human readable name of the port</synopsis>
          <typeRef>string[16]</typeRef>
        </component>
        <component componentID="4" access="read-write">
          <name>Configuration</name>
          <synopsis>Configuration of the port</synopsis>
          <typeRef>PortConfigurationType</typeRef>
        </component>
        <component componentID="5" access="read-only">
          <name>State</name>
          <synopsis>State of the OpenFlow Switch</synopsis>
          <typeRef>PortState</typeRef>
        </component>
        <component componentID="6" access="read-only">
          <name>CurrentFeatures</name>
          <synopsis>Current features of the port</synopsis>
          <typeRef>PortFeaturesType</typeRef>
        </component>
        <component componentID="7" access="read-write">
          <name>Advertised</name>
          <synopsis>Features advertised by the port</synopsis>
          <typeRef>PortFeaturesType</typeRef>
        </component>
        <component componentID="8" access="read-only">
          <name>CurrentSpeed</name>
          <synopsis>Current port bitrate in kbps</synopsis>
          <typeRef>uint32</typeRef>
        </component>
        <component componentID="9" access="read-only">
          <name>MaximumSpeed</name>
          <synopsis>Maximum port bitrate in kbps</synopsis>
          <typeRef>uint32</typeRef>
        </component>
        <component componentID="10" access="read-only">
          <name>PortCounter</name>
          <synopsis>Counters for the port</synopsis>
          <typeRef>PortCounterType</typeRef>
        </component>
      </components>
      <capabilities>
        <capability componentID="31">
          <name>Supported</name>
          <synopsis>Features Supported by the port</synopsis>
          <typeRef>PortFeaturesType</typeRef>
        </capability>
        <capability componentID="32">
          <name>Peer</name>
          <synopsis>Features advertised by the peer</synopsis>
          <typeRef>PortFeaturesType</typeRef>
        </capability>
      </capabilities>
    </LFBClassDef>
    <!-- Queue LFB -->
    <LFBClassDef LFBClassID="1028">
      <name>OFQueue</name>
      <synopsis>A queue LFB that can be attached to a port and be used
      to map flows on it. Flows mapped to a queue will be treated
      according to that queue's configuration</synopsis>
      <version>1.1</version>
      <inputPorts>
        <inputPort group="true">
          <name>PacketIn</name>
          <synopsis>An input port that expects any kind of frame.
          </synopsis>
          <expectation>
            <frameExpected>
              <ref>Arbitrary</ref>
            </frameExpected>
          </expectation>
        </inputPort>
      </inputPorts>
      <components>
        <component componentID="1" access="read-only">
          <name>QueueID</name>
          <synopsis>ID for the specific queue</synopsis>
          <typeRef>uint32</typeRef>
        </component>
        <component componentID="2" access="read-write">
          <name>Properties</name>
          <synopsis>List of queue properties</synopsis>
          <array>
            <typeRef>QueueArrayPropertiesType</typeRef>
          </array>
        </component>
        <component componentID="3" access="read-only">
          <name>QueueCounter</name>
          <synopsis>Counters for the queue</synopsis>
          <typeRef>QueueCounterType</typeRef>
        </component>
      </components>
    </LFBClassDef>
    <!-- OFRedirectIn LFB -->
    <LFBClassDef LFBClassID="1029">
      <name>OFRedirectIn</name>
      <synopsis>The OFRedirectIn LFB abstracts the process for the
      controller to inject data packets into the switch to input data
      packets into the data path.</synopsis>
      <version>1.1</version>
      <derivedFrom>RedirectIn</derivedFrom>
      <outputPorts>
        <outputPort group="false">
          <name>PacketIn</name>
          <synopsis>An output port that sends a packet in the data
          path</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
            <metadataProduced>
              <ref>ActionList</ref>
              <ref>IngressPort</ref>
            </metadataProduced>
          </product>
        </outputPort>
        <outputPort group="false">
          <name>BufferIn</name>
          <synopsis>An output port that sends only the buffer id to
          locate a buffered packet</synopsis>
          <product>
            <frameProduced>
              <ref>Null</ref>
            </frameProduced>
            <metadataProduced>
              <ref>BufferID</ref>
              <ref>ActionList</ref>
              <ref>IngressPort</ref>
            </metadataProduced>
          </product>
        </outputPort>
      </outputPorts>
    </LFBClassDef>
    <!-- OFRedirectOut LFB -->
    <LFBClassDef LFBClassID="1030">
      <name>OFRedirectOut</name>
      <synopsis>The OFRedirectOut LFB abstracts the process for the 
      switch to deliver data packets to the controller</synopsis>
      <version>1.1</version>
      <inputPorts>
        <inputPort group="true">
          <name>Outgoing</name>
          <synopsis>The input port expects either the whole packet to
          be sent to the controller or part of it along with the buffer
          ID</synopsis>
          <expectation>
            <frameExpected>
              <ref>Arbitrary</ref>
            </frameExpected>
            <metadataExpected>
              <ref>IngressPort</ref>
              <ref>InPhyPort</ref>
              <ref>RedirectReason</ref>
              <ref dependency="optional">FlowTableID</ref>
              <ref dependency="optional">BufferID</ref>
            </metadataExpected>
          </expectation>
        </inputPort>
      </inputPorts>
    </LFBClassDef>
    <!-- Action LFBs -->
    <LFBClassDef LFBClassID="1031">
      <name>OFAction</name>
      <synopsis>An LFB that performs one specific action on a packet in
      the OpenFlow switch. The OFActionLFB expects any kind of packet 
      and as metadata the FlowTableInstanceID to know from which Flow 
      Table the packet has arrived from and the Action Index to specify
      the row in the Action Table, if there is an Action table.
      </synopsis>
      <version>1.1</version>
      <inputPorts>
        <inputPort group="true">
          <name>PacketIn</name>
          <synopsis>An input port that gets the packet to perform the
          action on. Expects the ClassID of the LFB that calls it to 
          know to which LFB to return it to. Can accept calls from the
          OFFlowTables or the OFGroupLFB.</synopsis>
          <expectation>
            <frameExpected>
              <ref>Arbitrary</ref>
            </frameExpected>
            <metadataExpected>
              <ref>PacketID</ref>
              <ref>LFBClassIDMetadata</ref>
              <ref dependency="optional">ActionIndex</ref>
              <ref dependency="optional">IngressPort</ref>
              <ref dependency="optional">InPhyPort</ref>
              <ref dependency="optional">QueueID</ref>
            </metadataExpected>
          </expectation>
        </inputPort>
      </inputPorts>
      <outputPorts>
        <outputPort group="true">
          <name>PacketOut</name>
          <synopsis>The output port from which the packet will be send
          back to the LFB (OFFlowTables or OFGroupTable) from which it
          came from.</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
            <metadataProduced>
              <ref>PacketID</ref>
            </metadataProduced>
          </product>
        </outputPort>
      </outputPorts>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1032">
      <name>OFActionOutput</name>
      <synopsis>An LFB that performs the Output Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <outputPorts>
        <outputPort group="true">
          <name>PortOutput</name>
          <synopsis>Send a copy of the packet to the specified port
          </synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
          </product>
        </outputPort>
        <outputPort group="true">
          <name>All</name>
          <synopsis>Send the packet out all standard ports, but not to
          the ingress port or ports configured not to forward
          </synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
          </product>
        </outputPort>
        <outputPort group="false">
          <name>Controller</name>
          <synopsis>Send the packet to the controller</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
          </product>
        </outputPort>
        <outputPort group="false">
          <name>Table</name>
          <synopsis>Submit the packet to the first flow table so that
          the packet can be processed through the regular OpenFlow 
          pipeline. Only valid in the action set of a packet-out
          message</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
          </product>
        </outputPort>
        <outputPort group="true">
          <name>InPort</name>
          <synopsis>Send the packet out the ingress port.</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
          </product>
        </outputPort>
        <outputPort group="false">
          <name>Local</name>
          <synopsis>Send the packet to the switch's local networking
          stack</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
          </product>
        </outputPort>
        <outputPort group="false">
          <name>Normal</name>
          <synopsis>Process the packet using the traditional
          non-OpenFlow pipeline of the switch.</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
          </product>
        </outputPort>
        <outputPort group="true">
          <name>Flood</name>
          <synopsis>Flood the packet using the normal pipeline of the
          switch.</synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
          </product>
        </outputPort>
      </outputPorts>
      <components>
        <component componentID="1" access="read-write">
          <name>OutputActionTable</name>
          <synopsis>Output to switch port</synopsis>
          <array>
            <struct>
              <component componentID="1">
                <name>Port</name>
                <synopsis>The port to send the packet out</synopsis>
                <typeRef>PortNumberType</typeRef>
              </component>
              <component componentID="2">
                <name>MaxLength</name>
                <synopsis>If the port is the controller sets the 
                maximum number of bytes to send.</synopsis>
                <typeRef>uint16</typeRef>
              </component>
            </struct>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1033">
      <name>OFActionSetVLANVID</name>
      <synopsis>An LFB that performs the Set VLANID Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetVLANVIDActionTable</name>
          <synopsis>Set the 802.1q VLAN ID</synopsis>
          <array>
            <typeRef>uint16</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1034">
      <name>OFActionSetVLANPriority</name>
      <synopsis>An LFB that performs the Set VLAN Priority Action
      </synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetVLANPriorityActionTable</name>
          <synopsis>Set the 802.1q VLAN Priority</synopsis>
          <array>
            <typeRef>uchar</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1035">
      <name>OFActionSetMACSource</name>
      <synopsis>An LFB that performs the Set MAC Source Action
      </synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetMACSourceActionTable</name>
          <synopsis>Set MAC source address</synopsis>
          <array>
            <typeRef>IEEEMAC</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1036">
      <name>OFActionSetMACDestination</name>
      <synopsis>An LFB that performs the Set MAC Destionation Action
      </synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetMACDestinationActionTable</name>
          <synopsis>Set MAC destination address</synopsis>
          <array>
            <typeRef>IEEEMAC</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1037">
      <name>OFActionSetIPSource</name>
      <synopsis>An LFB that performs the Set IP Source Action
      </synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetIPSourceActionTable</name>
          <synopsis>Set the IP source address</synopsis>
          <array>
            <typeRef>IPv4Addr</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1038">
      <name>OFActionSetIPDestination</name>
      <synopsis>An LFB that performs the Set IP Destination Action
      </synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetIPDestinationActionTable</name>
          <synopsis>Set the IP destination address</synopsis>
          <array>
            <typeRef>IPv4Addr</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1039">
      <name>OFActionSetIPTOS</name>
      <synopsis>An LFB that performs the Set VLANID Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetIPTOSActionTable</name>
          <synopsis>Set IP ToS field</synopsis>
          <array>
            <typeRef>uchar</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1040">
      <name>OFActionSetIPECN</name>
      <synopsis>An LFB that performs the Set IP ECN Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetIPECNActionTable</name>
          <synopsis>Set IP ECN field</synopsis>
          <array>
            <typeRef>uchar</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1041">
      <name>OFActionSetTCPSource</name>
      <synopsis>An LFB that performs the Set TCP/UDP/SCTP Source port 
      Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetTCPSourceActionTable</name>
          <synopsis>Sets TCP/UDP/SCTP source port</synopsis>
          <array>
            <typeRef>uint16</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1042">
      <name>OFActionSetTCPDestination</name>
      <synopsis>An LFB that performs the Set TCP/UDP/SCTP Destination
       port Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetTCPDestinationActionTable</name>
          <synopsis>Sets TCP/UDP/SCTP destination port</synopsis>
          <array>
            <typeRef>uint16</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1043">
      <name>OFActionCopyTTLOut</name>
      <synopsis>An LFB that performs the copy TTL outwards Action
      </synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1044">
      <name>OFActionCopyTTLIn</name>
      <synopsis>An LFB that performs the copy TTL inwards Action
      </synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1045">
      <name>OFActionSetMPLSLabel</name>
      <synopsis>An LFB that performs the Set MPLS Label Action
      </synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetMPLSLabelActionTable</name>
          <synopsis>Sets MPLS Label Table</synopsis>
          <array>
            <typeRef>uint32</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1046">
      <name>OFActionSetMPLSTC</name>
      <synopsis>An LFB that performs the Set MPLS Traffic Class Action
      </synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetMPLSTCActionTable</name>
          <synopsis>Sets MPLS Traffic Class Table</synopsis>
          <array>
            <typeRef>uchar</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1047">
      <name>OFActionSetMPLSTTL</name>
      <synopsis>An LFB that performs the Set MPLS TTL Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetMPLSTTLTable</name>
          <synopsis>Sets MPLS TTL Table</synopsis>
          <array>
            <typeRef>uchar</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1048">
      <name>OFActionDecrementMPLSTTL</name>
      <synopsis>An LFB that performs the decrementation of the MPLS TTL
      Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1049">
      <name>OFActionPushVLan</name>
      <synopsis>An LFB that performs the Push VLAN Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>PushVLANTable</name>
          <synopsis>Push VLAN Table</synopsis>
          <array>
            <typeRef>uint16</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1050">
      <name>OFActionPopVLAN</name>
      <synopsis>An LFB that performs the Pop VLAN Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1051">
      <name>OFActionPushMPLS</name>
      <synopsis>An LFB that performs the Push MPLS Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>PushMPLSTable</name>
          <synopsis>Push MPLS Table</synopsis>
          <array>
            <typeRef>uint16</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1052">
      <name>OFActionPopMPLS</name>
      <synopsis>An LFB that performs the Pop MPLS Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>PopMPLSTable</name>
          <synopsis>Pop MPLS Table</synopsis>
          <array>
            <typeRef>uint16</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1053">
      <name>OFActionSetQueue</name>
      <synopsis>An LFB that performs the Set Queue Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <outputPorts>
        <outputPort group="true">
          <name>QueuePacketOut</name>
          <synopsis>The output port from which the packet will be send 
          back to the Flow Table/GroupTable from which it came from.
          </synopsis>
          <product>
            <frameProduced>
              <ref>Arbitrary</ref>
            </frameProduced>
            <metadataProduced>
              <ref>PacketID</ref>
              <ref>QueueID</ref>
            </metadataProduced>
          </product>
        </outputPort>
      </outputPorts>
      <components>
        <component componentID="1" access="read-write">
          <name>SetQueueTable</name>
          <synopsis>Sets Queue Table</synopsis>
          <array>
            <typeRef>uint32</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1054">
      <name>OFActionSetIPTTL</name>
      <synopsis>An LFB that performs the Set IP TTL Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
      <components>
        <component componentID="1" access="read-write">
          <name>SetIPTTLActionTable</name>
          <synopsis>Sets IP TTL Table</synopsis>
          <array>
            <typeRef>uchar</typeRef>
          </array>
        </component>
      </components>
    </LFBClassDef>
    <LFBClassDef LFBClassID="1055">
      <name>OFActionDecrementIPTTL</name>
      <synopsis>An LFB that performs the decrementation of the IP TTL
      Action</synopsis>
      <version>1.1</version>
      <derivedFrom>OFAction</derivedFrom>
    </LFBClassDef>
  </LFBClassDefs>
</LFBLibrary>
         ]]></artwork>
        </figure>
      </t>
    </section>
    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The authors would like to thank Ahmad N. Quttoum, Zoltan Lajos Kis, Joel Halpern and especially Jamal Hadi Salim, for discussions which helped shape this document.</t>
    </section>
    <section anchor="IANA" title="IANA Considerations">
      <t>(TBD)</t>
    </section>
    <section anchor="Security" title="Security Considerations">
      <t>TBD</t>
    </section>
  </middle>
  <!--  *****BACK MATTER *****-->
  <back>
    <!-- References split into informative and normative-->
    <!-- There are 2 ways to insert reference entries from the citation libraries:
		 1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
		 2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?>here
			(for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")
	
		 Both are cited textually in the same manner: by using xref elements.
		 If you use the PI option, xml2rfc will, by default, try to find included files in the same
		 directory as the including file. You can also define the XML_LIBRARY environment variable
		 with a value containing a set of directories to search.  These can be either in the local
		 filing system or remote ones accessed by http (http://domain/dir/... ).-->
    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
			&RFC3654;
			&RFC3746;  
			&RFC5810;
			&RFC5811;     
			&RFC5812;
			&RFC5813;
			&RFC6053;
			&FORCESLIB;
		  <!-- A reference written by by an organization not a person. -->
      <reference anchor="OpenFlowSpec1.1" target="http://www.OpenFlow.org/documents/OpenFlow-spec-v1.1.0.pdf">
        <front>
          <title>The OpenFlow 1.1 Specification.</title>
          <author>
            <organization>http://www.OpenFlow.org/</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="McKeown" target="http://www.OpenFlow.org/documents/OpenFlow-spec-v1.1.0.pdf">
        <front>
          <title>McKeown, N., Anderson, T., Balakrishnan, H., et al,
             "OpenFlow: enabling innovation in campus networks", ACM
             SIGCOMM Computer Communication Review. 2008, 38(2):69-74.</title>
          <author>
            <organization/>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning.-->
			&RFC2629;
	<!-- A reference written by by an organization not a person.-->
    </references>
  </back>
</rfc>
