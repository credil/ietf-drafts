


NFSv4                                                         W. Adamson
Internet-Draft                                                    NetApp
Intended status: Standards Track                             N. Williams
Expires: April 20, 2014                                     Cryptonector
                                                        October 17, 2013


             Remote Procedure Call (RPC) Security Version 3
                  draft-ietf-nfsv4-rpcsec-gssv3-05.txt

Abstract

   This document specifies version 3 of the Remote Procedure Call (RPC)
   security protocol (RPCSEC_GSS).  This protocol provides for compound
   authentication of client hosts and users to server (constructed by
   generic composition), security label assertions for multi-level and
   type enforcement, structured privilege assertions, and channel
   bindings.

Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on April 20, 2014.

Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal



Adamson & Williams       Expires April 20, 2014                 [Page 1]

Internet-Draft                    NFSv4                     October 2013


   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Applications of RPCSEC_GSSv3 . . . . . . . . . . . . . . .  4
   2.  The RPCSEC_GSSv3 protocol  . . . . . . . . . . . . . . . . . .  5
     2.1.  New auth_stat values . . . . . . . . . . . . . . . . . . .  9
     2.2.  RPC message credential and verifier  . . . . . . . . . . . 10
     2.3.  Control Messages . . . . . . . . . . . . . . . . . . . . . 10
       2.3.1.  Create request . . . . . . . . . . . . . . . . . . . . 11
       2.3.2.  Destruction request  . . . . . . . . . . . . . . . . . 15
       2.3.3.  List request . . . . . . . . . . . . . . . . . . . . . 16
       2.3.4.  Extensibility  . . . . . . . . . . . . . . . . . . . . 16
     2.4.  Data Messages  . . . . . . . . . . . . . . . . . . . . . . 17
   3.  Security Considerations  . . . . . . . . . . . . . . . . . . . 17
   4.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 18
   5.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 19
     5.1.  Normative References . . . . . . . . . . . . . . . . . . . 19
     5.2.  Informative References . . . . . . . . . . . . . . . . . . 19
   Appendix A.  Acknowledgments . . . . . . . . . . . . . . . . . . . 20
   Appendix B.  RFC Editor Notes  . . . . . . . . . . . . . . . . . . 20
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 20




















Adamson & Williams       Expires April 20, 2014                 [Page 2]

Internet-Draft                    NFSv4                     October 2013


1.  Introduction

   The original RPCSEC_GSS protocol [2] provided for authentication of
   RPC clients and servers to each other using the Generic Security
   Services Application Programming Interface (GSS-API) [3].  The second
   version of RPCSEC_GSS [4] added support for channel bindings [5].

   We find that GSS-API mechanisms are insufficient for communicating
   certain aspects of a client's authority to a server.  The GSS-API and
   its mechanisms certainly could be extended to address this
   shortcoming, but it seems be far simpler to address it at the
   application layer, namely, in this case, RPCSEC_GSS.

   The motivation for RPCSEC_GSSv3 is to add support for labeled
   security and server-side copy for NFSv4 (see [6] and [9]).  Both of
   these features require assertions of authority from the client.

   Assertions need to be verified.  One party that can verify an
   assertion is the client host, which can authenticate to the server
   using its own credentials.  We can also require users to verify an
   assertion as well.  This calls for compound authentication.

   Because the design of RPCSEC_GSSv3 relies on either RPCSEC_GSS
   version 1 (though version 2 can be used) to do the actual GSS-API
   security context establishment, we add support for channel binding so
   that implementors who have implemented RPCSEC_GSS version 1 but not
   version 2 can provide a (simplified) channel binding implementation
   using RPCSEC_GSSv3.

   We therefore describe a new version of RPCSEC_GSS that allows for the
   following:

   o  Client-side assertions of authority:

      *  Security labels for multi-level, type enforcement, and other
         labeled security models.  See [10], [11], [12], [6] and [9].

      *  Application-specific structured privileges.  For an example see
         server-side copy [6].

      *  Compound authentication of the client host and user to the
         server done by binding two RPCSEC_GSS handles.

      *  Simplified channel binding.

   Assertions of labels and privileges are evaluated by the server,
   which may then map the asserted values to other values, all according
   to server-side policy.



Adamson & Williams       Expires April 20, 2014                 [Page 3]

Internet-Draft                    NFSv4                     October 2013


   We also add an option for enumerating active server-side privileges
   and supported label format specifiers (LFS).  The LFS and Label
   Format Registry are described in detail in [13].

   RPCSEC_GSSv3 is patterned as follows:

   o  A client uses an existing RPCSEC_GSSv1 (or RPCSEC_GSSv2) context
      handle to protect RPCSEC_GSSv3 exchanges (this will be termed the
      "parent" handle)

   o  The server issues a "child" RPCSEC_GSSv3 handle, but the
      underlying GSS-API security context for the parent handle is used
      in all subsequent exchanges using the child handle.  This works
      because the RPCSEC_GSS handle is included in the integrity
      protected RPCSEC_GSS auth/verifier header for all versions of
      RPCSEC_GSS.  The child context, however, has its own sequence
      number space and window, distinct from that of the parent.

   [[Comment.1: RFC22203 states that when data integrity is used, the
   seq_num in the rpc_gss_data_t must be the same as in the credential.
   This means that using data integrity with GSS3 context's can not
   simply construct it using the parent context as the seq_num must be
   from the GSS3 context. --AA]]

   This means that RPCSEC_GSSv3 depends on RPCSEC_GSS versions 1 and/or
   2 for actual GSS-API security context establishment.  This keeps the
   specification of RPCSEC_GSSv3 simple by avoiding the need to
   duplicate the core functionality of RPCSEC_GSS version 1.

1.1.  Applications of RPCSEC_GSSv3

   The common uses of RPCSEC_GSSv3, particularly for NFSv4 [6], are
   expected to be:

   a.  labeled security: client-side process label assertion [+
       privilege assertion] + compound client host & user
       authentication;

   b.  compound client host & user authentication [+ critical structured
       privilege assertions] used in inter-server server-side copy;

   Labeled NFS (see Section 8 of [6]) uses the subject label provided by
   the client via the RPCSEC_GSSv3 layer to enforce MAC access to
   objects owned by the server to enable server guest mode or full mode
   labeled NFS.

   [[Comment.2: check that this language states what NFSv4.2 labeled NFS
   problem we are really solving. (setting labels on the server) --AA]]



Adamson & Williams       Expires April 20, 2014                 [Page 4]

Internet-Draft                    NFSv4                     October 2013


   A traditional inter-server file copy entails the user gaining access
   to a file on the source, reading it, and writing it to a file on the
   destination.  In secure NFSv4 inter-server server-side copy (see
   Section 3.4.1 of [6]), the user first secures access to both source
   and destination files, and then uses RPCSEC_GSSv3 compound
   authentication and structured privileges to authorize the destination
   to copy the file from the source on behalf of the user.


2.  The RPCSEC_GSSv3 protocol

   This document contains the External Data Representation (XDR) ([7])
   definitions for the RPCSEC_GSSv3 protocol.

   The XDR description is provided in this document in a way that makes
   it simple for the reader to extract into ready to compile form.  The
   reader can feed this document in the following shell script to
   produce the machine readable XDR description of RPCSEC_GSSv3:

   #!/bin/sh
   grep "^  *///" | sed 's?^  */// ??' | sed 's?^  *///$??'

   I.e. if the above script is stored in a file called "extract.sh", and
   this document is in a file called "spec.txt", then the reader can do:

    sh extract.sh < spec.txt > rpcsec_gss_v3.x

   The effect of the script is to remove leading white space from each
   line, plus a sentinel sequence of "///".

   The XDR description, with the sentinel sequence follows:

      ///  /*
      ///   * Copyright (c) 2013 IETF Trust and the persons
      ///   * identified as the document authors. All rights
      ///   * reserved.
      ///   *
      ///   * The document authors are identified in [RFC2203],
      ///   * [RFC5403], and [RFCxxxx].
      ///   *
      ///   * Redistribution and use in source and binary forms,
      ///   * with or without modification, are permitted
      ///   * provided that the following conditions are met:
      ///   *
      ///   * o Redistributions of source code must retain the above
      ///   *   copyright notice, this list of conditions and the
      ///   *   following disclaimer.
      ///   *



Adamson & Williams       Expires April 20, 2014                 [Page 5]

Internet-Draft                    NFSv4                     October 2013


      ///   * o Redistributions in binary form must reproduce the
      ///   *   above copyright notice, this list of
      ///   *   conditions and the following disclaimer in
      ///   *   the documentation and/or other materials
      ///   *   provided with the distribution.
      ///   *
      ///   * o Neither the name of Internet Society, IETF or IETF
      ///   *   Trust, nor the names of specific contributors, may be
      ///   *   used to endorse or promote products derived from this
      ///   *   software without specific prior written permission.
      ///   *
      ///   *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
      ///   *   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
      ///   *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      ///   *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
      ///   *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
      ///   *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
      ///   *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
      ///   *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
      ///   *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
      ///   *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
      ///   *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
      ///   *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
      ///   *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
      ///   *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
      ///   *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      ///   */
      ///
      ///  /*
      ///   * This code was derived from [RFC2203]. Please
      ///   * reproduce this note if possible.
      ///   */
      ///
      ///  /*
      ///   * rpcsec_gss_v3.x
      ///   */
      ///
      ///  enum rpc_gss_service_t {
      ///          /* Note: the enumerated value for 0 is reserved. */
      ///          rpc_gss_svc_none         = 1,
      ///          rpc_gss_svc_integrity    = 2,
      ///          rpc_gss_svc_privacy      = 3,
      ///          rpc_gss_svc_channel_prot = 4
      ///  };
      ///
      ///  enum rpc_gss_proc_t {
      ///           RPCSEC_GSS_DATA          = 0,
      ///           RPCSEC_GSS_INIT          = 1,



Adamson & Williams       Expires April 20, 2014                 [Page 6]

Internet-Draft                    NFSv4                     October 2013


      ///           RPCSEC_GSS_CONTINUE_INIT = 2,
      ///           RPCSEC_GSS_DESTROY       = 3,
      ///           RPCSEC_GSS_BIND_CHANNEL  = 4
      ///  };
      ///
      ///  struct rpc_gss_cred_vers_1_t {
      ///          rpc_gss_proc_t    gss_proc; /* control procedure */
      ///          unsigned int      seq_num;  /* sequence number */
      ///          rpc_gss_service_t service;  /* service used */
      ///          opaque            handle<>; /* context handle */
      ///  };
      ///
      ///  enum rpc_gss3_proc_t {
      ///          RPCSEC_GSS3_DATA = 0,
      ///          RPCSEC_GSS3_LIST = 5,
      ///          RPCSEC_GSS3_CREATE = 6,
      ///          RPCSEC_GSS3_DESTROY = 7
      ///  };
      ///
      ///  struct rpc_gss_cred_vers_3_t {
      ///          rpc_gss3_proc_t         gss_proc;
      ///          unsigned int            seq_num;
      ///          rpc_gss_service_t       service;
      ///          opaque                  handle<>;
      ///  };
      ///
      ///  const RPCSEC_GSS_VERS_1 = 1;
      ///  const RPCSEC_GSS_VERS_2 = 2;
      ///  const RPCSEC_GSS_VERS_3 = 3; /* new */
      ///
      ///  union rpc_gss_cred_t switch (unsigned int rgc_version) {
      ///  case RPCSEC_GSS_VERS_1:
      ///  case RPCSEC_GSS_VERS_2:
      ///          rpc_gss_cred_vers_1_t rgc_cred_v1;
      ///  case RPCSEC_GSS_VERS_3: /* new */
      ///          rpc_gss_cred_vers_3_t rgc_cred_v3;
      ///  };
      ///
      ///  const MAXSEQ = 0x80000000;
      ///
      ///  struct rpc_gss3_extension {
      ///          int     type;
      ///          bool    critical;
      ///          opaque  data<>;
      ///  };
      ///
      ///  struct rpc_gss3_gss_binding {
      ///          unsigned int    vers;



Adamson & Williams       Expires April 20, 2014                 [Page 7]

Internet-Draft                    NFSv4                     October 2013


      ///          opaque          handle<>;
      ///          opaque          nonce<>;
      ///          opaque          mic<>;
      ///  };
      ///
      ///  typedef opaque rpc_gss3_chan_binding<>;
      ///
      ///  struct rpc_gss3_lfs {
      ///          unsigned int lfs_id;
      ///          unsigned int pi_id;
      ///  };
      ///
      ///  struct rpc_gss3_label {
      ///          rpc_gss3_lfs    lfs;
      ///          opaque          label<>;
      ///  };
      ///
      ///  typedef string rpc_gss3_list_name<>;
      ///  struct rpc_gss3_privs {
      ///          rpc_gss3_list_name      listname;
      ///          opaque                  privilege<>;
      ///  };
      ///
      ///  enum rpc_gss3_assertion_type {
      ///          LABEL = 0,
      ///          PRIVS = 1
      ///  };
      ///
      ///  union rpc_gss3_assertion_u
      ///        switch (rpc_gss3_assertion_type atype) {
      ///  case LABEL:
      ///          rpc_gss3_label  label;
      ///  case PRIVILEGES:
      ///          rpc_gss3_privs  privs;
      ///  default:
      ///          opaque          ext<>;
      ///  };
      ///
      ///  struct rpc_gss3_assertion {
      ///          bool                    critical;
      ///          rpc_gss3_assertion_u    assertion;
      ///  };
      ///
      ///  struct rpc_gss3_create_args {
      ///          rpc_gss3_gss_binding    *compound_binding;
      ///          rpc_gss3_chan_binding   *chan_binding_mic;
      ///          rpc_gss3_assertion      assertions<>;
      ///          rpc_gss3_extension      extensions<>;



Adamson & Williams       Expires April 20, 2014                 [Page 8]

Internet-Draft                    NFSv4                     October 2013


      ///  };
      ///
      ///  struct rpc_gss3_create_res {
      ///          opaque                  handle<>;
      ///          rpc_gss3_chan_binding   *chan_binding_mic;
      ///          rpc_gss3_assertion      granted_assertions<>;
      ///          rpc_gss3_extension      granted_extensions<>;
      ///  };
      ///
      ///  enum rpc_gss3_list_item {
      ///          LABEL = 0,
      ///          PRIV = 1,
      ///  };
      ///
      ///  struct rpc_gss3_list_args {
      ///          rpc_gss3_list_item      list_what<>;
      ///  };
      ///
      ///  union rpc_gss3_list_item_u
      ///        switch (rpc_gss3_list_item itype) {
      ///  case LABEL:
      ///          rpc_gss3_lable          labels<>;
      ///  case PRIV:
      ///          rpc_gss3_list_name      privs<>;
      ///  default:
      ///          opaque                  ext<>;
      ///  };
      ///
      ///  typedef rpc_gss3_list_item_u rpc_gss3_list_res<>;

2.1.  New auth_stat values

   RPCSEC_GSSv3 requires the addition of several values to the auth_stat
   enumerated type definition:

              enum auth_stat {
                      ...
                      /*
                       * RPCSEC_GSS errors
                       */
                      RPCSEC_GSS3_COMPOUND_PROBEM = <>,
                      RPCSEC_GSS3_LABEL_PROBLEM = <>,
                      RPCSEC_GSS3_UNKNOWN_ASSERTION = <>
                      RPCSEC_GSS3_UNKNOWN_EXTENSION = <>
                      RPCSEC_GSS3_UNKNOWN_MESSAGE = <>
              };

   [[Comment.3: fix above into YYY.  All the entries are TBD... --NW]]



Adamson & Williams       Expires April 20, 2014                 [Page 9]

Internet-Draft                    NFSv4                     October 2013


2.2.  RPC message credential and verifier

   The rpc_gss_cred_vers_3_t type is used in much the same way that
   rpc_gss_cred_vers_1_t is used in RPCSEC_GSSv1, that is: as the arm of
   the rpc_gss_cred_t discriminated union in the RPC message header
   opaque_auth structure corresponding to version 3 (RPCSEC_GSS_VERS_3).
   It differs from rpc_gss_cred_vers_1_t in that:

   a.  the values for gss_proc corresponding to control messages are
       different.

   b.  the handle field is the RPCSEC_GSSv3 (child) handle, except for
       the RPCSEC_GSS3_CREATE control message where it is set to the
       parent context handle.

   For all RPCSEC_GSSv3 data and control messages, the verifier field in
   the RPC message header is constructed in the RPCSEC_GSSv1 manner
   using the parent GSS-API security context.

2.3.  Control Messages

   There are three RPCSEC_GSSv3 control messages: RPCSEC_GSS3_CREATE,
   RPCSEC_GSS3_DESTROY, and RPCSEC_GSS3_LIST.

   RPCSEC_GSSv3 control messages are similar to the RPCSEC_GSSv1
   RPCSEC_GSS_DESTROY control message (see section 5.4 [2]) in that the
   sequence number in the request must be valid, and the header checksum
   in the verifier must be valid.  In other words, they look a lot like
   an RPCSEC_GSSv3 data message with the header procedure set to
   NULLPROC.

   As in RPCSEC_GSSv1, the RPCSEC_GSSv3 control messages may contain
   information following the verifier in the body of the NULLPROC
   procedure.

   The client MUST use one of the following security services to protect
   any RPCSEC_GSSv3 control message:

   o  rpc_gss_svc_channel_prot (see RPCSEC_GSSv2)

   o  rpc_gss_svc_integrity

   o  rpc_gss_svc_privacy

   Specifically the client MUST NOT use rpc_gss_svc_none.

   For RPCSEC_GSSv3 control messages the rpc_gss_cred_vers_3_t in the
   RPC message opaque_auth structure is encoded as follows:



Adamson & Williams       Expires April 20, 2014                [Page 10]

Internet-Draft                    NFSv4                     October 2013


   1.  the union rpc_gss_cred_t version is set to 3 with the value being
       of type rpc_gss_cred_vers_3_t instead of rpc_gss_cred_vers_1_t.

   2.  the gss_proc is set to one of RPCSEC_GSS3_CREATE,
       RPCSEC_GSS3_DESTROY, or RPCSEC_GSS3_LIST.

   3.  the seq_num is a valid sequence number for the context in the
       handle field.

   4.  the rpc_gss_service_t is one of rpc_gss_svc_integrity,
       rpc_gss_svc_privacy, or rpc_gss_svc_channel_prot.

   5.  the rpc_gss_cred_vers_3_t handle field is either set to the
       parent context handle for RPCSEC_GSS3_CREATE, or to the GSS3
       child handle for RPCSEC_GSS3_LIST and RPCSEC_GSS3_DESTROY.

2.3.1.  Create request

   As noted in the introduction, RPCSEC_GSSv3 relies on the RPCSEC_GSS
   version 1 parent context (though version 2 can be used) secure
   connection to do the actual GSS-API GSS3 security context
   establishment.  As such, the rpc_gss_cred_vers_3_t fields in the RPC
   Call opaque_auth use the parent context handle and seq_num stream.

   The RPCSEC_GSS3_CREATE call message binds one or more items of
   several kinds into a new RPCSEC_GSSv3 context handle:

   o  another RPCSEC_GSS (version 1, 2, or 3) context handle (compound
      authentication)

   o  a channel binding

   o  authorization assertions (labels, privileges)

   o  extensions (see Section 2.3.4 )

   The reply to this message consists of either an error or an
   rpc_gss3_create_res structure which includes a new RPCSEC_GSSv3
   handle, termed the "child" which is used for subsequent control and
   data messages.

   Upon successful RPCSEC_GSS3_CREATE, both the client and the server
   should associate the resultant GSSv3 child context handle with the
   parent context handle in their GSS context caches so as to be able to
   reference the parent context given the child context handle.

   [[Comment.4: Destruction of the parent context => first destroy child
   handle.  IOW fail the RPCSEC_GSS_DESTROY of parent with new



Adamson & Williams       Expires April 20, 2014                [Page 11]

Internet-Draft                    NFSv4                     October 2013


   RPCSEC_GSS3_CONTEXT_EXISTS error code: What about the lifetime of the
   GSS3 context.  Is this meant to be long lived?? --AA]]

   Server policies should take into account the identity of the client
   and/or user as authenticated via the GSS-API.  Server implementation
   and policy MAY result in labels, privileges, and identities being
   mapped to concepts and values that are local to the server.

2.3.1.1.  Compound authentication

   RPCSEC_GSSv3 allows for compound authentication of client hosts and
   users to servers.  As in non-compound authentication, there is a
   parent handle used to protect the RPCSEC_GSS3_CREATE call message,
   and a resultant RPCSEC_GSSv3 child handle.  In addition to the parent
   handle, the compound authentication create control message has a
   handle referenced via the compound_binding field of the
   RPCSEC_GSS3_CREATE arguments structure (rpc_gss3_create_args) termed
   the "inner" handle, as well as a nonce and a MIC of that nounce
   created using the GSS-API security context associated with the
   "inner" handle.

   All uses of a child context handle that is bound to an inner context
   MUST be treated as speaking for the initiator principal (as modified
   by any assertions in the RPCSEC_GSS3_CREATE message) of the inner
   context handle's GSS-API security context.

   This feature is needed, for example, when a client wishes to use
   authority assertions that the server may only grant if a user and a
   client are authenticated together to the server.  Thus a server may
   refuse to grant requested authority to a user acting alone (e.g., via
   an unprivileged user-space program), or to a client acting alone
   (e.g. when a client is acting on behalf of a user) but may grant
   requested authority to a client acting on behalf of a user if the
   server identifies the user and trusts the client.

   It is assumed that an unprivileged user-space program would not have
   access to client host credentials needed to establish a GSS-API
   security context authenticating the client to the server, therefore
   an unprivileged user-space program could not create an RPCSEC_GSSv3
   RPCSEC_GSS3_CREATE message that successfully binds a client and a
   user security context.

   Clients using RPCSEC_GSS context binding MUST use, as the parent
   context handle, an RPCSEC_GSS context handle that corresponds to a
   GSS-API security context that authenticates the client host, and for
   the inner context handle it SHOULD use a context handle to
   authenticate a user.  The reverse (parent handle authenticates user,
   inner authenticates client) MUST NOT be used.  Other compounds might



Adamson & Williams       Expires April 20, 2014                [Page 12]

Internet-Draft                    NFSv4                     October 2013


   eventually make sense.

   An RPCSEC_GSSv3 context handle that is bound to another RPCSEC_GSS
   context MUST be treated by servers as authenticating the GSS-API
   initiator principal authenticated by the inner context handle's GSS-
   API security context.  This principal may be mapped to a server-side
   notion of user or principal as modified by any identity assertions by
   the client in the same RPCSEC_GSS3_CREATE request that the server
   accepts.

2.3.1.2.  Channel binding

   RPCSEC_GSSv3 provides a different way to do channel binding than
   RPCSEC_GSSv2.  Specifically:

   a.  RPCSEC_GSSv3 builds on RPCSEC_GSSv1 by reusing existing,
       established context handles rather than providing a different RPC
       security flavor for establishing context handles,

   b.  channel bindings data are not hashed because the community now
       agrees that it is the secure channel's responsibility to produce
       channel bindings data of manageable size.

   (a) is useful in keeping RPCSEC_GSSv3 simple in general, not just for
   channel binding. (b) is useful in keeping RPCSEC_GSSv3 simple
   specifically for channel binding.

   Channel binding is accomplished as follows.  The client prefixes the
   channel bindings data octet string with the channel type as described
   in [5], then the client calls GSS_GetMIC() to get a MIC of resulting
   octet string, using the parent RPCSEC_GSS context handle's GSS-API
   security context.  The MIC is then placed in the chan_binding_mic
   field of RPCSEC_GSS3_CREATE arguments (rpc_gss3_create_args).

   If the chan_binding_mic field of the arguments of a
   RPCSEC_GSS3_CREATE control message is set, then the server MUST
   verify the client's channel binding MIC if the server supports this
   feature.  If channel binding verification succeeds then the server
   MUST generate a new MIC of the same channel bindings and place it in
   the chan_binding_mic field of the RPCSEC_GSS3_CREATE results.  If
   channel binding verification fails or the server doesn't support
   channel binding then the server MUST indicate this in its reply by
   not including a chan_binding_mic value (chan_binding_mic is an
   optional field).

   The client MUST verify the result's chan_binding_mic value, if the
   server included it, by calling GSS_VerifyMIC() with the given MIC and
   the channel bindings data (including the channel type prefix).  If



Adamson & Williams       Expires April 20, 2014                [Page 13]

Internet-Draft                    NFSv4                     October 2013


   client-side channel binding verification fails then the client MUST
   call RPCSEC_GSS3_DESTROY.  If the client requested channel binding
   but the server did not include a chan_binding_mic field in the
   results, then the client MAY continue to use the resulting context
   handle as though channel binding had never been requested, otherwise
   (if the client really wanted channel binding) it MUST call
   RPCSEC_GSS3_DESTROY.

   As per-RPCSEC_GSSv2 [4]:

      "Once a successful [channel binding] procedure has been performed
      on an [RPCSEC_GSSv3] context handle, the initiator's
      implementation may map application requests for rpc_gss_svc_none
      and rpc_gss_svc_integrity to rpc_gss_svc_channel_prot credentials.
      And if the secure channel has privacy enabled, requests for
      rpc_gss_svc_privacy can also be mapped to
      rpc_gss_svc_channel_prot."

   Any RPCSEC_GSSv3 context handle that has been bound to a secure
   channel in this way SHOULD be used only with the
   rpc_gss_svc_channel_prot, and SHOULD NOT be used with
   rpc_gss_svc_none nor rpc_gss_svc_integrity -- if the secure channel
   does not provide privacy protection then the client MAY use
   rpc_gss_svc_privacy where privacy protection is needed or desired.

2.3.1.3.  Label assertions

   RPCSEC_GSSv3 clients MAY assert a security label in some LSF by
   binding this assertion into an RPCSEC_GSSv3 context handle.  This is
   done by including an assertion of type rpc_gss3_label in the
   'assertions' field (discriminant: 'LABEL') of the RPCSEC_GSS3_CREATE
   arguments to the desired LSF and label.

   Label encoding is specified to mirror the NFSv4 sec_label attribute
   described in Section 12.2.2 of [6].  The label format specifier (LFS)
   is an identifier used by the client to establish the syntactic format
   of the security label and the semantic meaning of its components.
   The policy identifier (PI) is an optional part of the definition of
   an LFS which allows for clients and server to identify specific
   security policies.  The opaque label field of rpc_gss3_label is
   dependent on the MAC model to interpret and enforce.

   [[Comment.5: Check that this Label definition provides all the
   required pieces to enable full mode when combined with NFSv4.2 LNFS.
   Specifically, how does the client find out and respond if a server
   has changed a label. --AA]]

   If a label itself requires privacy protection (i.e., that the user



Adamson & Williams       Expires April 20, 2014                [Page 14]

Internet-Draft                    NFSv4                     October 2013


   can assert that label is a secret) then the client MUST use the
   rpc_gss_svc_privacy protection service for the RPCSEC_GSS3_CREATE
   request or, if the parent handle is bound to a secure channel that
   provides privacy protection, rpc_gss_svc_channel_prot.

   If a client wants to ensure that the server understands the asserted
   label then it MUST set the 'critical' field of the label assertion to
   TRUE, otherwise it MUST set it to FALSE.

   Servers that do not support labeling MUST ignore non-critical label
   assertions.  Servers that do not support the requested LFS MUST
   either ignore non-critical label assertions or map them to a suitable
   label in a supported LFS.  Servers that do not support labeling or do
   not support the requested LFS MUST return an error if the label
   request is critical.  Servers that support labeling in the requested
   LFS MAY map the requested label to different label as a result of
   server-side policy evaluation.

2.3.1.4.  Structured privilege assertions

   A structured privilege is an RPC application defined structure that
   is opaque, and is encoded in the rpc_gss3_privs privilege field.
   Encoding, server verification and any server policies for structured
   privileges are described by the RPC application definition.  The
   listname field of rpc_gss3_privs is a description string used to list
   the privilege.

   A successful structured privilege assertion RPCSEC_GSS3_CREATE call
   must return all accepted privileges in the rpc_gss3_privs
   granted_assertions field.

   Section 3.4.1.2.  "Inter-Server Copy with RPCSEC_GSSv3" of [6] shows
   an example of structured privilege definition and use.

2.3.2.  Destruction request

   The RPCSEC_GSS3_DESTROY control message is the same as the
   RPCSEC_GSSv1 RPCSEC_GSS_DESTROY control message, but with the version
   3 header.  Specifically, the rpc_gss_cred_vers_3_t fields in the RPC
   Call opaque_auth use the GSS3 context handle and seq_num stream.  As
   with all RPCSEC_GSSv3 messages, the header checksum uses the parent
   context, and needs to be valid.

   The server sends a response as it would to a data request.  The
   client and server must then destroy the context for the session.






Adamson & Williams       Expires April 20, 2014                [Page 15]

Internet-Draft                    NFSv4                     October 2013


2.3.3.  List request

   The RPCSEC_GSS3_LIST control message is similar to
   RPCSEC_GSS3_DESTROY message.  Specifically, the rpc_gss_cred_vers_3_t
   fields in the RPC Call opaque_auth use the GSS3 context handle and
   seq_num stream.  As with all RPCSEC_GSSv3 messages, the header
   checksum uses the parent context, and needs to be valid.

   The RPCSEC_GSS3_LIST control message consists of a single integer
   indicating what should be listed, and the reply consists of an error
   or the requested list.  The client may list LFSs or structured
   privilege listnames.

   The result is an opaque octet string containing a list of LFSs
   [encoding TBD] or a list of active structured privileges [encoding
   TBD].

2.3.4.  Extensibility

   New fields may be added through the 'extensions' typed hole.  All
   such extensions have a 'critical' flag.

   [[Comment.6: Should we keep the extensions types hole?  I think
   not... --AA]]

   Assertion types may be added in the future by adding arms to the
   'rpc_gss3_assertion_u' union.  Every assertion has a 'critical' flag
   that can be used to indicate criticality.  Other assertion types are
   described elsewhere and include:

   o  Client-side assertions of identity:

      *  Primary client/user identity

      *  Supplementary group memberships of the client/user, including
         support for specifying deltas to the membership list as seen on
         the server.

   New control message types may be added.

   Servers receiving unknown critical client assertions or unknown
   RPCSEC_GSS_v3 extensions MUST return an error.

   There is no IANA or other registry for RPCSEC_GSSv3 extensions.  All
   extensions MUST be done by IETF Protocol Action.






Adamson & Williams       Expires April 20, 2014                [Page 16]

Internet-Draft                    NFSv4                     October 2013


2.4.  Data Messages

   RPCSEC_GSS3_DATA messages differ from from RPCSEC_GSSv1 data messages
   in that the version number used MUST be '3' instead of '1'.  As noted
   in Section 2.2 the RPCSEC_GSSv3 context handle is used along with
   it's sequence number stream.

   For RPCSEC_GSSv3 data messages the rpc_gss_cred_vers_3_t in the RPC
   message opaque_auth structure is encoded as follows:

   1.  the union rpc_gss_cred_t version is set to 3 with the value being
       of type rpc_gss_cred_vers_3_t instead of rpc_gss_cred_vers_1_t.

   2.  the gss_proc is set to RPCSEC_GSS3_DATA

   3.  the seq_num is a valid GSS3 context (child context) sequence
       number.

   4.  just as in RPCSEC_GSSv1, the rpc_gss_service_t is one of
       rpc_gss_svc_none, rpc_gss_svc_integrity, rpc_gss_svc_privacy, or
       rpc_gss_svc_channel_prot.

   5.  the handle field is set to the (child) RPCSEC_GSSv3 context
       handle


3.  Security Considerations

   This entire document deals with security issues.

   The RPCSEC_GSSv3 protocol allows for client-side assertions of data
   that is relevant to server-side authorization decisions.  These
   assertions must be evaludated by the server in the context of whether
   the client and/or user are authenticated, whether compound
   authentication was used, whether the client is trusted, what ranges
   of assertions are allowed for the client and the user (separately or
   together), and any relevant server-side policy.

   The security semantics of assertions carried by RPCSEC_GSSv3 are
   application protocol-specific.

   RPCSEC_GSSv3 supports a notion of critical assertions (and
   extensions), but there's no need for peers to tell each other what
   assertions were granted, or what they were mapped to.

   Note that RPSEC_GSSv3 is not a complete solution for labeling: it
   conveys the labels of actors, but not the labels of objects.  RPC
   application protocols may require extending in order to carry object



Adamson & Williams       Expires April 20, 2014                [Page 17]

Internet-Draft                    NFSv4                     October 2013


   label information.

   There may be interactions with NFSv4's callback security scheme and
   NFSv4.1's GSS-API "SSV" mechanisms.  Specifically, the NFSv4 callback
   scheme requires that the server initiate GSS-API security contexts,
   which does not work well in practice, and in the context of client-
   side processes running as the same user but with different privileges
   and security labels the NFSv4 callback security scheme seems
   particularly unlikely to work well.  NFSv4.1 has the server use an
   existing, client-initiated RPCSEC_GSS context handle to protect
   server-initiated callback RPCs.  The NFSv4.1 callback security scheme
   lacks all the problems of the NFSv4 scheme, however, it is important
   that the server pick an appropriate RPCSEC_GSS context handle to
   protect any callbacks.  Specifically, it is important that the server
   use RPCSEC_GSS context handles which authenticate the client to
   protect any callbacks relating to server state initiated by RPCs
   protected by RPCSEC_GSSv3 contexts.

   [[Comment.7: [Add text about interaction with GSS-SSV...] --NW]]

   [[Comment.8: I see no reason to use RPCSEC_GSSv3 contexts for NFSv4.x
   back channel. --AA]]

   [[Comment.9: Since GSS3 requires an RPCSEC_GSSv1 or v2 context handle
   to establish a GSS3 context, SSV can not be used as this draft is
   written.]]

   [[Comment.10: AFAICS the reason to use SSV is to avoid using a client
   machine credential which means compound authentication can not be
   used.  Since GSS3 requires an RPCSEC_GSSv1 or v2 context handle to
   establish a GSS3 context, SSV can not be used as the parent context
   for GSSv3. --AA]]


4.  IANA Considerations

   This section uses terms that are defined in [8].

   There are no IANA considerations in this document.  TBDs in this
   document will be assigned by the ONC RPC registrar (which is not
   IANA, XXX: verify).


5.  References







Adamson & Williams       Expires April 20, 2014                [Page 18]

Internet-Draft                    NFSv4                     October 2013


5.1.  Normative References

   [1]   Bradner, S., "Key words for use in RFCs to Indicate Requirement
         Levels", March 1997.

   [2]   Eisler, M., Chiu, A., and L. Ling, "RPCSEC_GSS Protocol
         Specification", RFC 2203, September 1997.

   [3]   Linn, J., "Generic Security Service Application Program
         Interface Version 2, Update 1", RFC 2743, January 2000.

   [4]   Srinivasan, R., "RPC: Remote Procedure Call Protocol
         Specification Version 2", RFC 1831, August 1995.

   [5]   Williams, N., "On the Use of Channel Bindings to Secure
         Channels", RFC 5056, November 2007.

   [6]   Haynes, T., "NFS Version 4 Minor Version 2",
         draft-ietf-nfsv4-minorversion2-19 (Work In Progress),
         March 2013.

   [7]   Eisler, M., "XDR: External Data Representation Standard",
         RFC 4506, May 2006.

   [8]   Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA
         Considerations Section in RFCs", BCP 26, RFC 5226, May 2008.

5.2.  Informative References

   [9]   Haynes, T., "Requirements for Labeled NFS",
         draft-ietf-nfsv4-labreqs-03 (work in progress).

   [10]  "Section 46.6. Multi-Level Security (MLS) of Deployment Guide:
         Deployment, configuration and administration of Red Hat
         Enterprise Linux 5, Edition 6", 2011.

   [11]  Smalley, S., "The Distributed Trusted Operating System (DTOS)
         Home Page",
         <http://www.cs.utah.edu/flux/fluke/html/dtos/HTML/dtos.html>.

   [12]  Carter, J., "Implementing SELinux Support for NFS",
         <http://www.nsa.gov/research/_files/selinux/papers/nfsv3.pdf>.

   [13]  Quigley, D. and J. Lu, "Registry Specification for MAC Security
         Label Formats", draft-quigley-label-format-registry (work in
         progress), 2011.





Adamson & Williams       Expires April 20, 2014                [Page 19]

Internet-Draft                    NFSv4                     October 2013


Appendix A.  Acknowledgments


Appendix B.  RFC Editor Notes

   [RFC Editor: please remove this section prior to publishing this
   document as an RFC]

   [RFC Editor: prior to publishing this document as an RFC, please
   replace all occurrences of RFCTBD10 with RFCxxxx where xxxx is the
   RFC number of this document]


Authors' Addresses

   William A. (Andy) Adamson
   NetApp
   3629 Wagner Ridge Ctt
   Ann Arbor, MI  48103
   USA

   Phone: +1 734 665 1204
   Email: andros@netapp.com


   Nico Williams
   cryptonector.com
   13115 Tamayo Dr
   Austin, TX  78729
   USA

   Email: nico@cryptonector.com



















Adamson & Williams       Expires April 20, 2014                [Page 20]

