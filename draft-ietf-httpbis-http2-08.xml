<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="lib/rfc2629.xslt"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>

<rfc ipr="trust200902" 
     category="std"
     docName="draft-ietf-httpbis-http2-08" 
     x:maturity-level="proposed"
     xmlns:x="http://purl.org/net/xml2rfc/ext">
  <x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
  <front>
    <title abbrev="HTTP/2.0">Hypertext Transfer Protocol version 2.0</title>

    <author initials="M." surname="Belshe" fullname="Mike Belshe">
      <organization>Twist</organization>
      <address>
        <email>mbelshe@chromium.org</email>
      </address>
    </author>

    <author initials="R." surname="Peon" fullname="Roberto Peon">
      <organization>Google, Inc</organization>
      <address>
        <email>fenix@google.com</email>
      </address>
    </author>

    <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
      <organization>Microsoft</organization>
      <address>
        <postal>
          <street>3210 Porter Drive</street>
          <city>Palo Alto</city>
          <code>94304</code>
          <country>US</country>
        </postal>
        <email>martin.thomson@gmail.com</email>
      </address>
    </author>

    <author initials="A." surname="Melnikov" fullname="Alexey Melnikov" role="editor">
      <organization>Isode Ltd</organization>
      <address>
        <postal>
          <street>5 Castle Business Village</street>
          <street>36 Station Road</street>
          <city>Hampton</city>
          <region>Middlesex</region>

          <code>TW12 2BX</code>
          <country>UK</country>
        </postal>
        <email>Alexey.Melnikov@isode.com</email>
      </address>
    </author>

    <date year="2013" />
    <area>Applications</area>
    <workgroup>HTTPbis Working Group</workgroup>
    <keyword>HTTP</keyword>
    <keyword>SPDY</keyword>
    <keyword>Web</keyword>

    <abstract>
      <t>
        This specification describes an optimized expression of the syntax of the Hypertext Transfer
        Protocol (HTTP). HTTP/2.0 enables a more efficient use of network resources and
        a reduced perception of latency by introducing header field compression and allowing multiple
        concurrent messages on the same connection. It also introduces unsolicited push of
        representations from servers to clients.
      </t>
      <t>
        This document is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.
        HTTP's existing semantics remain unchanged.
      </t>
      <t>
        This version of the draft has been marked for implementation.
        Interoperability testing will occur in the HTTP/2.0 interim in
        Zurich, CH, starting 2014-01-22.
      </t>
    </abstract>

    <note title="Editorial Note (To be removed by RFC Editor)">
      <t>
        Discussion of this draft takes place on the HTTPBIS working group mailing list
        (ietf-http-wg@w3.org), which is archived at <eref
        target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
      </t>
      <t>
        Working Group information and related documents can be found at <eref
        target="http://tools.ietf.org/wg/httpbis/"/> (Wiki) and <eref
        target="https://github.com/http2/http2-spec"/> (source code and issues tracker).
      </t>
      <t>
        The changes in this draft are summarized in <xref
        target="change.log"/>.
      </t>
    </note>

  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      
      <t>
        The Hypertext Transfer Protocol (HTTP) is a wildly successful protocol. However, the
        HTTP/1.1 message format (<xref target="HTTP-p1" x:fmt="," x:rel="#http.message"/>) is
        optimized for implementation simplicity and accessibility, not application performance.  As
        such it has several characteristics that have a negative overall effect on application
        performance.
      </t>
      <t>
        In particular, HTTP/1.0 only allows one request to be outstanding at a time on a given
        connection.  HTTP/1.1 pipelining only partially addressed request concurrency and
        suffers from head-of-line blocking.  Therefore, clients that need to make many requests
        typically use multiple connections to a server in order to reduce latency.
      </t>
      <t>
        Furthermore, HTTP/1.1 header fields are often repetitive and verbose, which, in addition to
        generating more or larger network packets, can cause the small initial TCP congestion window
        to quickly fill.  This can result in excessive latency when multiple requests are made on a
        single new TCP connection.
      </t>
      <t>
        This document addresses these issues by defining an optimized mapping of HTTP's semantics to
        an underlying connection.  Specifically, it allows interleaving of request and response
        messages on the same connection and uses an efficient coding for HTTP header fields.  It
        also allows prioritization of requests, letting more important requests complete more
        quickly, further improving performance.
      </t>
      <t>
        The resulting protocol is designed to be more friendly to the network, because fewer TCP
        connections can be used, in comparison to HTTP/1.x. This means less competition with other
        flows, and longer-lived connections, which in turn leads to better utilization of available
        network capacity.
      </t>
      <t>
        Finally, this encapsulation also enables more scalable processing of messages through use of
        binary message framing.
      </t>

      <section title="Document Organization">
        <t>
          The HTTP/2.0 Specification is split into three parts: <xref target="starting">starting
          HTTP/2.0</xref>, which covers how a HTTP/2.0 connection is initiated; <xref
          target="FramingLayer">a framing layer</xref>, which multiplexes a single TCP connection
          into independent frames of various types; and <xref target="HTTPLayer">an HTTP
          layer</xref>, which specifies the mechanism for expressing HTTP interactions using the
          framing layer. While some of the framing layer concepts are isolated from HTTP, building a
          generic framing layer has not been a goal. The framing layer is tailored to the needs of
          the HTTP protocol and server push.
        </t>
      </section>
      <section title="Conventions and Terminology">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119">RFC 2119</xref>.
        </t>
        <t>
          All numeric values are in network byte order.  Values are unsigned unless otherwise
          indicated.  Literal values are provided in decimal or hexadecimal as appropriate.
          Hexadecimal literals are prefixed with <spanx style="verb">0x</spanx> to distinguish them
          from decimal literals.
        </t>
        <t>
          The following terms are used:
          <list style="hanging">
            <t hangText="client:">
              The endpoint initiating the HTTP connection.
            </t>
            <t hangText="connection:">
              A transport-level connection between two endpoints.
            </t>
            <t hangText="connection error:">
              An error on the HTTP/2.0 connection.
            </t>
            <t hangText="endpoint:">
              Either the client or server of the connection.
            </t>
            <t hangText="frame:">
              The smallest unit of communication within an HTTP/2.0 connection, 
              consisting of a header and a variable-length sequence of bytes
              structured according to the frame type.
            </t>
            <t hangText="peer:">
              An endpoint.  When discussing a particular endpoint, "peer" refers to the endpoint
              that is remote to the primary subject of discussion.
            </t>
            <t hangText="receiver:">
              An endpoint that is receiving frames.
            </t>
            <t hangText="sender:">
              An endpoint that is transmitting frames.
            </t>
            <t hangText="server:">
              The endpoint which did not initiate the HTTP connection.
            </t>
            <t hangText="stream:">
              A bi-directional flow of frames across a virtual channel within 
              the HTTP/2.0 connection.
            </t>
            <t hangText="stream error:">
              An error on the individual HTTP/2.0 stream.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="Overview" title="HTTP/2.0 Protocol Overview">
      <t>
        HTTP/2.0 provides an optimized transport for HTTP semantics.
      </t>
      <t>
        An HTTP/2.0 connection is an application level protocol running on top of a TCP connection
        (<xref target="TCP"/>). The client is the TCP connection initiator.
      </t>
      <t>
        This document describes the HTTP/2.0 protocol using a logical structure that is formed of
        three parts: framing, streams, and application mapping.  This structure is provided
        primarily as an aid to specification, implementations are free to diverge from this
        structure as necessary.
      </t>
      
      <section title="HTTP Frames">
        <t>
          HTTP/2.0 provides an efficient serialization of HTTP semantics.  HTTP requests and
          responses are encoded into length-prefixed frames (see <xref target="FrameHeader"/>).
        </t>
        <t>
          HTTP header fields are compressed into a series of frames that contain header block
          fragments (see <xref target="HeaderBlock"/>).
        </t>
      </section>

      <section title="HTTP Multiplexing">
        <t>
           HTTP/2.0 provides the ability to multiplex HTTP requests and responses over a
           single connection.  Multiple requests or responses can be sent concurrently on a
           connection using <xref target="StreamsLayer">streams</xref>.  In order to maintain
           independent streams, flow control and prioritization are necessary.
        </t>
      </section>

      <section title="HTTP Semantics">
        <t>
          HTTP/2.0 defines how HTTP requests and responses are mapped to streams (see <xref
          target="HttpSequence"/>) and introduces a new interaction model, <xref
          target="PushResources">server push</xref>.
        </t>
      </section>

    </section>

    <section anchor="starting" title="Starting HTTP/2.0">
      <t>
        HTTP/2.0 uses the same "http" and "https" URI schemes used by HTTP/1.1. HTTP/2.0 shares the
        same default port numbers: 80 for "http" URIs and 443 for "https" URIs.  As a result,
        implementations processing requests for target resource URIs like <spanx
        style="verb">http://example.org/foo</spanx> or <spanx
        style="verb">https://example.com/bar</spanx> are required to first discover whether the
        upstream server (the immediate peer to which the client wishes to establish a connection)
        supports HTTP/2.0.
      </t>
 
      <t>
        The means by which support for HTTP/2.0 is determined is different for "http" and "https"
        URIs. Discovery for "http" URIs is described in <xref target="discover-http"/>.  Discovery
        for "https" URIs is described in <xref target="discover-https"/>.
      </t>

      <section anchor="versioning" title="HTTP/2.0 Version Identification">
        <t>
          The protocol defined in this document is identified using the string "HTTP/2.0".  This
          identification is used in the HTTP/1.1 Upgrade header field, in the <xref
          target="TLSALPN">TLS application layer protocol negotiation extension</xref> field, and
          other places where protocol identification is required.
        </t>
        <t>
          Negotiating "HTTP/2.0" implies the use of the transport, security, framing and message
          semantics described in this document.
        </t>
        <t>
          <cref>Editor's Note: please remove the remainder of this section prior to the publication
          of a final version of this document.</cref>
        </t>
        <t>
          Only implementations of the final, published RFC can identify themselves as "HTTP/2.0".
          Until such an RFC exists, implementations MUST NOT identify themselves using "HTTP/2.0".
        </t>
        <t>
          Examples and text throughout the rest of this document use "HTTP/2.0" as a matter of
          editorial convenience only.  Implementations of draft versions MUST NOT identify using
          this string.  The exception to this rule is the string included in the connection header
          sent by clients immediately after establishing an HTTP/2.0 connection (see <xref
          target="ConnectionHeader"/>); this fixed length sequence of octets does not change.
        </t>
        <t>
          Implementations of draft versions of the protocol MUST add the string "-draft-" and the
          corresponding draft number to the identifier before the separator ('/').  For example,
          draft-ietf-httpbis-http2-03 is identified using the string "HTTP-draft-03/2.0".
        </t>
        <t>
          Non-compatible experiments that are based on these draft versions MUST instead replace the
          string "draft" with a different identifier.  For example, an experimental implementation
          of packet mood-based encoding based on draft-ietf-httpbis-http2-07 might identify itself
          as "HTTP-emo-07/2.0".  Note that any label MUST conform to the "token" syntax defined in
          <xref target="HTTP-p1" x:fmt="of" x:rel="#field.components"/>.  Experimenters are
          encouraged to coordinate their experiments on the ietf-http-wg@w3.org mailing list.
        </t>
      </section>
      
      <section anchor="discover-http" title="Starting HTTP/2.0 for &quot;http&quot; URIs">
        <t>
          A client that makes a request to an "http" URI without prior knowledge about support for
          HTTP/2.0 uses the HTTP Upgrade mechanism (<xref target="HTTP-p1" x:fmt="of"
          x:rel="#header.upgrade"/>).  The client makes an HTTP/1.1 request that includes an Upgrade
          header field identifying HTTP/2.0.  The HTTP/1.1 request MUST include exactly one <xref
          target="Http2SettingsHeader">HTTP2-Settings</xref> header field.
        </t>
        <figure>
          <preamble>For example:</preamble>
          <artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /default.htm HTTP/1.1
Host: server.example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: HTTP/2.0
HTTP2-Settings: &lt;base64url encoding of HTTP/2.0 SETTINGS payload>
</artwork>
        </figure>
        <t>
          Requests that contain an entity body MUST be sent in their entirety before the
          client can send HTTP/2.0 frames.  This means that a large request entity can block the use
          of the connection until it is completely sent.
        </t>
        <t>
          If concurrency of an initial request with subsequent requests is important, a small
          request can be used to perform the upgrade to HTTP/2.0, at the cost of an additional
          round-trip.
        </t>
        <t>
          A server that does not support HTTP/2.0 can respond to the request as though the Upgrade
          header field were absent:
        </t>
        <figure>
          <artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 200 OK
Content-Length: 243
Content-Type: text/html

...
</artwork>
        </figure>
        <t>
          A server that supports HTTP/2.0 can accept the upgrade with a 101 (Switching Protocols)
          response.  After the empty line that terminates the 101 response, the server can begin
          sending HTTP/2.0 frames.  These frames MUST include a response to the request that
          initiated the Upgrade.
        </t>

        <figure>
          <artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: HTTP/2.0

[ HTTP/2.0 connection ...
</artwork>
        </figure>
        <t>
          The first HTTP/2.0 frame sent by the server is a <x:ref>SETTINGS</x:ref> frame (<xref
          target="SETTINGS"/>). Upon receiving the 101 response, the client sends a <xref
          target="ConnectionHeader">connection header</xref>, which includes a
          <x:ref>SETTINGS</x:ref> frame.
        </t>
        <t>
          The HTTP/1.1 request that is sent prior to upgrade is assigned stream identifier 1 and is
          assigned the highest possible priority.  Stream 1 is implicitly half closed from the
          client toward the server, since the request is completed as an HTTP/1.1 request.  After
          commencing the HTTP/2.0 connection, stream 1 is used for the response.
        </t>

        <section anchor="Http2SettingsHeader" title="HTTP2-Settings Header Field">
          <t>
            A request that upgrades from HTTP/1.1 to HTTP/2.0 MUST include exactly one <spanx
            style="verb">HTTP2-Settings</spanx> header field.  The <spanx
            style="verb">HTTP2-Settings</spanx> header field is a hop-by-hop header field that
            includes settings that govern the HTTP/2.0 connection, provided in anticipation of the
            server accepting the request to upgrade.  A server MUST reject an attempt to upgrade if
            this header field is not present.
          </t>
          <figure>
            <artwork type="abnf" x:indent-with="  "><![CDATA[
HTTP2-Settings    = token68
]]></artwork>
          </figure>

          <t>
            The content of the <spanx style="verb">HTTP2-Settings</spanx> header field is the
            payload of a <x:ref>SETTINGS</x:ref> frame (<xref target="SETTINGS"/>), encoded as a
            base64url string (that is, the URL- and filename-safe Base64 encoding described in <xref
            target="RFC4648" x:fmt="of" x:sec="5"/>, with any trailing '=' characters omitted).  The
            <xref target="RFC5234">ABNF</xref> production for <spanx style="verb">token68</spanx> is
            defined in <xref target="HTTP-p7" x:fmt="of" x:rel="#challenge.and.response"/>.
          </t>
          <t>
            The client MUST include values for the following <xref
            target="SettingFormat">settings</xref>:
            <list style="symbols">
              <t><x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref></t>
              <t><x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref></t>
            </list>
          </t>
          <t>
            As a hop-by-hop header field, the <spanx style="verb">Connection</spanx> header field
            MUST include a value of <spanx style="verb">HTTP2-Settings</spanx> in addition to <spanx
            style="verb">Upgrade</spanx> when upgrading to HTTP/2.0.
          </t>
          <t>
            A server decodes and interprets these values as it would any other
            <x:ref>SETTINGS</x:ref> frame.  Providing these values in the Upgrade request ensures
            that the protocol does not require default values for the above settings, and gives a
            client an opportunity to provide other settings prior to receiving any frames from the
            server.
          </t>
        </section>
      </section>

      <section anchor="discover-https" title="Starting HTTP/2.0 for &quot;https&quot; URIs">
        <t>
          A client that makes a request to an "https" URI without prior knowledge about support for
          HTTP/2.0 uses <xref target="TLS12">TLS</xref> with the <xref target="TLSALPN">application
          layer protocol negotiation extension</xref>.
        </t>
        <t>
          Once TLS negotiation is complete, both the client and the server send a <xref
          target="ConnectionHeader">connection header</xref>.
        </t>
      </section>

      <section anchor="known-http" title="Starting HTTP/2.0 with Prior Knowledge">
        <t>
          A client can learn that a particular server supports HTTP/2.0 by other means.  A client
          MAY immediately send HTTP/2.0 frames to a server that is known to support HTTP/2.0, after
          the <xref target="ConnectionHeader">connection header</xref>.  This only affects the
          resolution of "http" URIs; servers supporting HTTP/2.0 are required to support <xref
          target="TLSALPN">protocol negotiation in TLS</xref> for "https" URIs.
        </t>
        <t>
          Prior support for HTTP/2.0 is not a strong signal that a given server will support
          HTTP/2.0 for future connections.  It is possible for server configurations to change or
          for configurations to differ between instances in clustered server.  Interception proxies
          (a.k.a. "transparent" proxies) are another source of variability.
        </t>
      </section>
      
      <section anchor="ConnectionHeader" title="HTTP/2.0 Connection Header">
        <t>
          Upon establishment of a TCP connection and determination that HTTP/2.0 will be used by
          both peers, each endpoint MUST send a connection header as a final confirmation and to
          establish the initial settings for the HTTP/2.0 connection.
        </t>
        <t>
          The client connection header starts with a sequence of 24 octets, which in hex notation
          are:
        </t>
        <figure>
          <artwork type="inline" x:indent-with="  "><![CDATA[
505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
]]></artwork>
        </figure>
        <t>
          (the string <spanx style="verb">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</spanx>).  This sequence
          is followed by a <x:ref>SETTINGS</x:ref> frame (<xref target="SETTINGS"/>).  The client
          sends the client connection header immediately upon receipt of a 101 Switching Protocols
          response (indicating a successful upgrade), or as the first application data octets of a
          TLS connection. If starting an HTTP/2.0 connection with prior knowledge of server support
          for the protocol, the client connection header is sent upon connection establishment.
        </t>
        <t>
          <list>
            <t>
              The client connection header is selected so that a large proportion of HTTP/1.1 or
              HTTP/1.0 servers and intermediaries do not attempt to process further frames.  Note
              that this does not address the concerns raised in <xref target="TALKING"/>.
            </t>
          </list>
        </t>
        <t>
          The server connection header consists of just
          a <x:ref>SETTINGS</x:ref> frame (<xref target="SETTINGS"/>) that MUST be the
          first frame the server sends in the HTTP/2.0 connection.
        </t>
        <t>
          To avoid unnecessary latency, clients are permitted to send additional frames to the
          server immediately after sending the client connection header, without waiting to receive
          the server connection header.  It is important to note, however, that the server
          connection header <x:ref>SETTINGS</x:ref> frame might include parameters that necessarily
          alter how a client is expected to communicate with the server. Upon receiving the
          <x:ref>SETTINGS</x:ref> frame, the client is expected to honor any parameters established.
        </t>
        <t>
          Clients and servers MUST terminate the TCP connection if either peer does not begin with a
          valid connection header.  A <x:ref>GOAWAY</x:ref> frame (<xref target="GOAWAY"/>) MAY be
          omitted if it is clear that the peer is not using HTTP/2.0.
        </t>
      </section>
    </section>

    <section anchor="FramingLayer" title="HTTP Frames">
      <t>
        Once the HTTP/2.0 connection is established, endpoints can begin exchanging frames.
      </t>

      <section anchor="FrameHeader" title="Frame Format">
        <t>
          All frames begin with an 8-octet header followed by a payload of between 0 and 16,383
          octets.
        </t>
        <figure title="Frame Header">
          <artwork type="inline"><![CDATA[
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | R |     Length (14)           |   Type (8)    |   Flags (8)   |
 +-+-+-----------+---------------+-------------------------------+
 |R|                 Stream Identifier (31)                      |
 +-+-------------------------------------------------------------+
 |                   Frame Payload (0...)                      ...
 +---------------------------------------------------------------+
]]></artwork>
        </figure>
        <t>
          The fields of the frame header are defined as:
          <list style="hanging">
            <x:lt hangText="R:">
              <t>
                A reserved 2-bit field.  The semantics of these bits are undefined and the bit MUST
                remain unset (0) when sending and MUST be ignored when receiving.
              </t>
            </x:lt>
            <x:lt hangText="Length:">
              <t>
                The length of the frame payload expressed as an unsigned 14-bit integer. The 8 octets
                of the frame header are not included in this value.
              </t>
            </x:lt>
            <x:lt hangText="Type:">
              <t>
                The 8-bit type of the frame.  The frame type determines how the remainder of the frame
                header and payload are interpreted.  Implementations MUST ignore frames of unsupported
                or unrecognized types.
              </t>
            </x:lt>
            <x:lt hangText="Flags:">
              <t>
                An 8-bit field reserved for frame-type specific boolean flags.
              </t>
              <t>
                Flags are assigned semantics specific to the indicated frame type.
                Flags that have no defined semantics for a particular frame type
                MUST be ignored, and MUST be left unset (0) when sending.
              </t>
            </x:lt>
            <x:lt hangText="R:">
              <t>
                A reserved 1-bit field.  The semantics of this bit are undefined and the bit MUST
                remain unset (0) when sending and MUST be ignored when receiving.
              </t>
            </x:lt>
            <x:lt hangText="Stream Identifier:">
              <t>
                A 31-bit stream identifier (see <xref target="StreamIdentifiers"/>).  The value 0 is
                reserved for frames that are associated with the connection as a whole as opposed to
                an individual stream.
              </t>
            </x:lt>
          </list>
        </t>
        <t>
          The structure and content of the frame payload is dependent entirely on the frame type.
        </t>
      </section>
      
      <section anchor="FrameSize" title="Frame Size">
        <t>
          The maximum size of a frame payload varies by frame type.  The absolute maximum
          size of a frame is 2<x:sup>14</x:sup>-1 (16,383) octets.  All implementations SHOULD be
          capable of receiving and minimally processing frames up to this maximum size.
        </t>
        <t>
          Certain frame types, such as <x:ref>PING</x:ref> (see <xref target="PING"/>), impose
          additional limits on the amount of payload data allowed.  Likewise, additional size limits
          can be set by specific application uses (see <xref target="HttpExtra" />).
        </t>
        <t>
          If a frame size exceeds any defined limit, or is too small to contain mandatory frame
          data, the endpoint MUST send a <x:ref>FRAME_SIZE_ERROR</x:ref> error. Frame size errors in
          frames that affect connection-level state MUST be treated as a <xref
          target="ConnectionErrorHandler">connection error</xref>.
        </t>
      </section>

      <section anchor="HeaderBlock"  title="Header Compression and Decompression">
        <t>
          A header field in HTTP/2.0 is a name-value pair with one or more associated values. They
          are used within HTTP request and response messages as well as server push operations
          (see <xref target="PushResources" />).
        </t>
        <t>
          Header sets are logical collections of zero or more header fields arranged at the
          application layer.  When transmitted over a connection, the header set is serialized into
          a header block using <xref target="COMPRESSION">HTTP Header Compression</xref>.  The
          serialized header block is then divided into one or more octet sequences, called header
          block fragments, and transmitted within the payload of <xref
          target="HEADERS">HEADERS</xref>, <xref target="PUSH_PROMISE">PUSH_PROMISE</xref> or <xref
          target="CONTINUATION">CONTINUATION</xref> frames.  
        </t>
        <t>
          A receiving endpoint reassembles the header block by concatenating the individual
          fragments, then decompresses the block to reconstruct the header set.
        </t>
        <t>
          A complete header block consists of either:
          <list style="symbols">
            <t>
              a single <x:ref>HEADERS</x:ref> or <x:ref>PUSH_PROMISE</x:ref> frame each respectively
              with the END_HEADERS or END_PUSH_PROMISE flag set, or
            </t>
            <t>
              a <x:ref>HEADERS</x:ref> or <x:ref>PUSH_PROMISE</x:ref> frame with the END_HEADERS or
              END_PUSH_PROMISE flag cleared and one or more <x:ref>CONTINUATION</x:ref> frames,
              where the last <x:ref>CONTINUATION</x:ref> frame has the END_HEADER flag set.
            </t>
          </list>
        </t>
        <t>
          Header blocks MUST be transmitted as a contiguous sequence of frames, with no interleaved
          frames of any other type, or from any other stream.  The last frame in a sequence of
          <x:ref>HEADERS</x:ref> or <x:ref>CONTINUATION</x:ref> frames MUST have the END_HEADERS
          flag set.  The last frame in a sequence of <x:ref>PUSH_PROMISE</x:ref>or
          <x:ref>CONTINUATION</x:ref> frames MUST have the END_PUSH_PROMISE or END_HEADERS flag set
          (respectively).
        </t>
        <t>
          Header block fragments can only be sent as the payload of <x:ref>HEADERS</x:ref>,
          <x:ref>PUSH_PROMISE</x:ref> or <x:ref>CONTINUATION</x:ref> frames.
          <x:ref>HEADERS</x:ref>, <x:ref>PUSH_PROMISE</x:ref> and <x:ref>CONTINUATION</x:ref> frames
          carry data that can modify the compression context maintained by a receiver.  An endpoint
          receiving <x:ref>HEADERS</x:ref>, <x:ref>PUSH_PROMISE</x:ref> or
          <x:ref>CONTINUATION</x:ref> frames MUST reassemble header blocks and perform decompression
          even if the frames are to be discarded.  A receiver MUST terminate the connection with a
          <xref target="ConnectionErrorHandler">connection error</xref> of type
          <x:ref>COMPRESSION_ERROR</x:ref>, if it does not decompress a header block.
        </t>
      </section>
    </section>

    <section anchor="StreamsLayer" title="Streams and Multiplexing">
        <t>
          A "stream" is an independent, bi-directional sequence of <x:ref>HEADERS</x:ref> and
          <x:ref>DATA</x:ref> frames exchanged between the client and server within an HTTP/2.0
          connection.  Streams have several important characteristics:
          <list style="symbols">
            <t>
              A single HTTP/2.0 connection can contain multiple concurrently open streams, with
              either endpoint interleaving frames from multiple streams.
            </t>
            <t>
              Streams can be established and used unilaterally or shared by either the client or
              server.
            </t>
            <t>
              Streams can be closed by either endpoint.
            </t>
            <t>
              The order in which frames are sent within a stream is significant. Recipients process
              frames in the order they are received.
            </t>
            <t>
              Streams are identified by an integer.  Stream identifiers are assigned to streams by
              the initiating endpoint.
            </t>
          </list>
        </t>

     <section anchor="StreamStates" title="Stream States">
        <t>
          The lifecycle of a stream is shown in <xref target="StreamStatesFigure"/>.
        </t>

        <figure anchor="StreamStatesFigure" title="Stream States">
          <artwork type="drawing">
            <![CDATA[
                       +--------+
                 PP    |        |    PP
              ,--------|  idle  |--------.
             /         |        |         \
            v          +--------+          v
     +----------+          |           +----------+
     |          |          | H         |          |
 ,---| reserved |          |           | reserved |---.
 |   | (local)  |          v           | (remote) |   |
 |   +----------+      +--------+      +----------+   |
 |      |          ES  |        |  ES          |      |
 |      | H    ,-------|  open  |-------.      | H    |
 |      |     /        |        |        \     |      |
 |      v    v         +--------+         v    v      |
 |   +----------+          |           +----------+   |
 |   |   half   |          |           |   half   |   |
 |   |  closed  |          | R         |  closed  |   |
 |   | (remote) |          |           | (local)  |   |
 |   +----------+          |           +----------+   |
 |        |                v                 |        |
 |        |  ES / R    +--------+  ES / R    |        |
 |        `----------->|        |<-----------'        |
 |  R                  | closed |                  R  |
 `-------------------->|        |<--------------------'
                       +--------+
]]>
          </artwork>
        </figure>

        <t>
          Both endpoints have a subjective view of the state of a stream that could be different
          when frames are in transit.  Endpoints do not coordinate the creation of streams, they are
          created unilaterally by either endpoint.  The negative consequences of a mismatch in
          states are limited to the "closed" state after sending <x:ref>RST_STREAM</x:ref>, where
          frames might be received for some time after closing.
        </t>
        <t>
          Streams have the following states:
          <list style="hanging">

            <x:lt hangText="idle:">
              <t>
                <vspace blankLines="0"/>
                All streams start in the "idle" state.  In this state, no frames have been
                exchanged.
              </t>
              <t>
                The following transitions are valid from this state:
                <list style="symbols">
                  <t>
                    Sending or receiving a <x:ref>HEADERS</x:ref> frame causes the stream to become
                    "open".  The stream identifier is selected as described in <xref
                    target="StreamIdentifiers"/>.  The same <x:ref>HEADERS</x:ref> frame can also
                    cause a stream to immediately become "half closed".
                  </t>
                  <t>
                    Sending a <x:ref>PUSH_PROMISE</x:ref> frame marks the associated stream for
                    later use.  The stream state for the reserved stream transitions to "reserved
                    (local)".
                  </t>
                  <t>
                    Receiving a <x:ref>PUSH_PROMISE</x:ref> frame marks the associated stream as
                    reserved by the remote peer.  The state of the stream becomes "reserved
                    (remote)".
                  </t>
                </list>
              </t>
            </x:lt>

            <x:lt hangText="reserved (local):">
              <t>
                <vspace blankLines="0"/>
                A stream in the "reserved (local)" state is one that has been promised by sending a
                <x:ref>PUSH_PROMISE</x:ref> frame.  A <x:ref>PUSH_PROMISE</x:ref> frame reserves an
                idle stream by associating the stream with an open stream that was initiated by the
                remote peer (see <xref target="PushResources"/>).
              </t>
              <t>
                In this state, only the following transitions are possible:
                <list style="symbols">
                  <t>
                    The endpoint can send a <x:ref>HEADERS</x:ref> frame.  This causes the stream to
                    open in a "half closed (remote)" state.
                  </t>
                  <t>
                    Either endpoint can send a <x:ref>RST_STREAM</x:ref> frame to cause the stream
                    to become "closed".  This releases the stream reservation.
                  </t>
                </list>
              </t>
              <t>
                An endpoint MUST NOT send frames other than than <x:ref>HEADERS</x:ref> or
                <x:ref>RST_STREAM</x:ref> in this state.
              </t>
              <t>
                A <x:ref>PRIORITY</x:ref> frame MAY be received in this state.  Receiving any frame
                other than <x:ref>HEADERS</x:ref>, <x:ref>RST_STREAM</x:ref>, or
                <x:ref>PRIORITY</x:ref> MUST be treated as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type
                <x:ref>PROTOCOL_ERROR</x:ref>.
              </t>
            </x:lt>

            <x:lt hangText="reserved (remote):">
              <t>
                <vspace blankLines="0"/>
                A stream in the "reserved (remote)" state has been reserved by a remote peer.
              </t>
              <t>
                In this state, only the following transitions are possible:
                <list style="symbols">
                  <t>
                    Receiving a <x:ref>HEADERS</x:ref> frame causes the stream to transition to
                    "half closed (local)".
                  </t>
                  <t>
                    Either endpoint can send a <x:ref>RST_STREAM</x:ref> frame to cause the stream
                    to become "closed".  This releases the stream reservation.
                  </t>
                </list>
              </t>
              <t>
                An endpoint MAY send a <x:ref>PRIORITY</x:ref> frame in this state to reprioritize
                the reserved stream.  An endpoint MUST NOT send any other type of frame other than
                <x:ref>RST_STREAM</x:ref> or <x:ref>PRIORITY</x:ref>.
              </t>
              <t>
                Receiving any other type of frame other than <x:ref>HEADERS</x:ref> or
                <x:ref>RST_STREAM</x:ref> MUST be treated as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type
                <x:ref>PROTOCOL_ERROR</x:ref>.
              </t>
            </x:lt>

            <x:lt hangText="open:">
              <t>
                <vspace blankLines="0"/>
                A stream in the "open" state may be used by both peers to send frames of any type.
                In this state, sending peers observe advertised <xref target="FlowControl">stream
                level flow control limits</xref>.
              </t>
              <t>
                From this state either endpoint can send a frame with an END_STREAM flag set, which
                causes the stream to transition into one of the "half closed" states: an endpoint
                sending an END_STREAM flag causes the stream state to become "half closed (local)"; an
                endpoint receiving an END_STREAM flag causes the stream state to become "half closed
                (remote)".  A <x:ref>HEADERS</x:ref> frame bearing an END_STREAM flag can be followed
                by <x:ref>CONTINUATION</x:ref> frames.
              </t>
              <t>
                Either endpoint can send a <x:ref>RST_STREAM</x:ref> frame from this state, causing it
                to transition immediately to "closed".
              </t>
            </x:lt>

            <x:lt hangText="half closed (local):">
              <t>
                <vspace blankLines="0"/>
                A stream that is in the "half closed (local)" state cannot be used for sending frames.
              </t>
              <t>
                A stream transitions from this state to "closed" when a frame that contains an
                END_STREAM flag is received, or when either peer sends a <x:ref>RST_STREAM</x:ref>
                frame.  A <x:ref>HEADERS</x:ref> frame bearing an END_STREAM flag can be followed by
                <x:ref>CONTINUATION</x:ref> frames.
              </t>
              <t>
                A receiver can ignore <x:ref>WINDOW_UPDATE</x:ref> or <x:ref>PRIORITY</x:ref> frames
                in this state.  These frame types might arrive for a short period after a frame
                bearing the END_STREAM flag is sent.
              </t>
            </x:lt>

            <x:lt hangText="half closed (remote):">
              <t>
                <vspace blankLines="0"/>
                A stream that is "half closed (remote)" is no longer being used by the peer to send
                frames.  In this state, an endpoint is no longer obligated to maintain a receiver
                flow control window if it performs flow control.
              </t>
              <t>
                If an endpoint receives additional frames for a stream that is in this state, other
                than <x:ref>CONTINUATION</x:ref> frames, it MUST respond with a <xref
                target="StreamErrorHandler">stream error</xref> of type
                <x:ref>STREAM_CLOSED</x:ref>.
              </t>
              <t>
                A stream can transition from this state to "closed" by sending a frame that contains
                a END_STREAM flag, or when either peer sends a <x:ref>RST_STREAM</x:ref> frame.
              </t>
            </x:lt>

            <x:lt hangText="closed:">
              <t>
                <vspace blankLines="0"/>
                The "closed" state is the terminal state.
              </t>
              <t>
                An endpoint MUST NOT send frames on a closed stream.  An endpoint that receives any
                frame after receiving a <x:ref>RST_STREAM</x:ref> MUST treat that as a <xref
                target="StreamErrorHandler">stream error</xref> of type
                <x:ref>STREAM_CLOSED</x:ref>.  Similarly, an endpoint that receives any frame after
                receiving a <x:ref>DATA</x:ref> frame with the END_STREAM flag set, or any frame
                except a <x:ref>CONTINUATION</x:ref> frame after receiving a <x:ref>HEADERS</x:ref>
                frame with a END_STREAM flag set MUST treat that as a <xref
                target="StreamErrorHandler">stream error</xref> of type
                <x:ref>STREAM_CLOSED</x:ref>.
              </t>
              <t>
                <x:ref>WINDOW_UPDATE</x:ref>, <x:ref>PRIORITY</x:ref>, or <x:ref>RST_STREAM</x:ref>
                frames can be received in this state for a short period after a <x:ref>DATA</x:ref>
                or <x:ref>HEADERS</x:ref> frame containing an END_STREAM flag is sent.  Until the
                remote peer receives and processes the frame bearing the END_STREAM flag, it might
                send frame of any of these types.  Endpoints MUST ignore
                <x:ref>WINDOW_UPDATE</x:ref>, <x:ref>PRIORITY</x:ref>, or <x:ref>RST_STREAM</x:ref>
                frames received in this state, though endpoints MAY choose to treat frames that
                arrive a significant time after sending END_STREAM as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type
                <x:ref>PROTOCOL_ERROR</x:ref>.
              </t>
              <t>
                If this state is reached as a result of sending a <x:ref>RST_STREAM</x:ref> frame,
                the peer that receives the <x:ref>RST_STREAM</x:ref> might have already sent - or
                enqueued for sending - frames on the stream that cannot be withdrawn.  An endpoint
                MUST ignore frames that it receives on closed streams after it has sent a
                <x:ref>RST_STREAM</x:ref> frame.  An endpoint MAY choose to limit the period over
                which it ignores frames and treat frames that arrive after this time as being in
                error.
              </t>
              <t>
                Flow controlled frames (i.e., <x:ref>DATA</x:ref>) received after sending
                <x:ref>RST_STREAM</x:ref> are counted toward the connection flow control window.
                Even though these frames might be ignored, because they are sent before the sender
                receives the <x:ref>RST_STREAM</x:ref>, the sender will consider the frames to count
                against the flow control window.
              </t>
              <t>
                An endpoint might receive a <x:ref>PUSH_PROMISE</x:ref> frame after it sends
                <x:ref>RST_STREAM</x:ref>.  <x:ref>PUSH_PROMISE</x:ref> causes a stream to become
                "reserved".  The <x:ref>RST_STREAM</x:ref> does not cancel any promised stream.
                Therefore, if promised streams are not desired, a <x:ref>RST_STREAM</x:ref> can be
                used to close any of those streams.
              </t>
            </x:lt>
          </list>
        </t>
        <t>
          In the absence of more specific guidance elsewhere in this document, implementations
          SHOULD treat the receipt of a message that is not expressly permitted in the description
          of a state as a <xref target="ConnectionErrorHandler">connection error</xref> of type
          <x:ref>PROTOCOL_ERROR</x:ref>.
        </t>

        <section anchor="StreamIdentifiers" title="Stream Identifiers">
          <t>
            Streams are identified with an unsigned 31-bit integer.  Streams initiated by a client
            MUST use odd-numbered stream identifiers; those initiated by the server MUST use
            even-numbered stream identifiers.  A stream identifier of zero (0x0) is used for
            connection control message; the stream identifier zero MUST NOT be used to establish a
            new stream.
          </t>
          <t>
            A stream identifier of one (0x1) is used to respond to the HTTP/1.1 request which was
            specified during Upgrade (see <xref target="discover-http"/>).  After the upgrade
            completes, stream 0x1 is "half closed (local)" to the client.  Therefore, stream 0x1
            cannot be selected as a new stream identifier by a client that upgrades from HTTP/1.1.
          </t>
          <t>
            The identifier of a newly established stream MUST be numerically greater than all
            streams that the initiating endpoint has opened or reserved.  This governs streams that
            are opened using a <x:ref>HEADERS</x:ref> frame and streams that are reserved using
            <x:ref>PUSH_PROMISE</x:ref>.  An endpoint that receives an unexpected stream identifier
            MUST respond with a <xref target="ConnectionErrorHandler">connection error</xref> of
            type <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>
          <t>
            The first use of a new stream identifier implicitly closes all streams in the "idle"
            state that might have been initiated by that peer with a lower-valued stream identifier.
            For example, if a client sends a <x:ref>HEADERS</x:ref> frame on stream 7 without ever
            sending a frame on stream 5, then stream 5 transitions to the "closed" state when the
            first frame for stream 7 is sent or received.
          </t>
          <t>
            Stream identifiers cannot be reused.  Long-lived connections can result in endpoint
            exhausting the available range of stream identifiers.  A client that is unable to
            establish a new stream identifier can establish a new connection for new streams.
          </t>
        </section>
        
        <section title="Stream Concurrency">
          <t>
            A peer can limit the number of concurrently active streams using the
            <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref> parameters within a
            <x:ref>SETTINGS</x:ref> frame. The maximum concurrent streams setting is specific to
            each endpoint and applies only to the peer that receives the setting. That is, clients
            specify the maximum number of concurrent streams the server can initiate, and servers
            specify the maximum number of concurrent streams the client can initiate.  Endpoints
            MUST NOT exceed the limit set by their peer.
          </t>
          <t>
            Streams that are in the "open" state, or either of the "half closed" states count toward
            the maximum number of streams that an endpoint is permitted to open.  Streams in any of
            these three states count toward the limit advertised in the
            <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref> setting (see <xref
            target="SettingValues"/>).
          </t>
          <t>
            Streams in either of the "reserved" states do not count as open, even if a small amount
            of application state is retained to ensure that the promised stream can be successfully
            used.
          </t>
        </section>
      </section>

     <section anchor="FlowControl" title="Flow Control">
        <t>
          Using streams for multiplexing introduces contention over use of the TCP connection,
          resulting in blocked streams.  A flow control scheme ensures that streams on the same
          connection do not destructively interfere with each other.  Flow control is used for both
          individual streams and for the connection as a whole.
        </t>
        <t>
          HTTP/2.0 provides for flow control through use of the <x:ref>WINDOW_UPDATE</x:ref> frame
          type.
        </t>

        <section anchor="fc-principles" title="Flow Control Principles">
          <t>
            HTTP/2.0 stream flow control aims to allow for future improvements to flow control
            algorithms without requiring protocol changes.  Flow control in HTTP/2.0 has the
            following characteristics:
            <list style="numbers">
              <t>
                Flow control is hop-by-hop, not end-to-end.
              </t>
              <t>
                Flow control is based on window update frames.  Receivers advertise how many bytes
                they are prepared to receive on a stream and for the entire connection.  This is a
                credit-based scheme.
              </t>
              <t>
                Flow control is directional with overall control provided by the receiver.  A
                receiver MAY choose to set any window size that it desires for each stream and for
                the entire connection.  A sender MUST respect flow control limits imposed by a
                receiver.  Clients, servers and intermediaries all independently advertise their
                flow control preferences as a receiver and abide by the flow control limits set by
                their peer when sending.
              </t>
              <t>
                The initial value for the flow control window is 65,535 bytes for both new streams
                and the overall connection.
              </t>
              <t>
                The frame type determines whether flow control applies to a frame.  Of the frames
                specified in this document, only <x:ref>DATA</x:ref> frames are subject to flow
                control; all other frame types do not consume space in the advertised flow control
                window.  This ensures that important control frames are not blocked by flow control.
              </t>
              <t>
                Flow control can be disabled by a receiver.  A receiver can choose to disable both
                forms of flow control by sending the <x:ref>SETTINGS_FLOW_CONTROL_OPTIONS</x:ref>
                setting.  See <xref target="EndFlowControl">Ending Flow Control</xref> for more
                details.
              </t>
              <t>
                HTTP/2.0 standardizes only the format of the <x:ref>WINDOW_UPDATE</x:ref> frame
                (<xref target="WINDOW_UPDATE"/>).  This does not stipulate how a receiver decides
                when to send this frame or the value that it sends.  Nor does it specify how a
                sender chooses to send packets.  Implementations are able to select any algorithm
                that suits their needs.
              </t>
            </list>
          </t>
          <t>
            Implementations are also responsible for managing how requests and responses are sent
            based on priority; choosing how to avoid head of line blocking for requests; and
            managing the creation of new streams.  Algorithm choices for these could interact with
            any flow control algorithm.
          </t>
        </section>
        
        <section anchor="DisableFlowControl" title="Appropriate Use of Flow Control">
          <t>
            Flow control is defined to protect endpoints that are operating under resource
            constraints.  For example, a proxy needs to share memory between many connections, and
            also might have a slow upstream connection and a fast downstream one.  Flow control
            addresses cases where the receiver is unable process data on one stream, yet wants to
            continue to process other streams in the same connection.
          </t>
          <t>
            Deployments that do not require this capability SHOULD disable flow control for data
            that is being received.  Note that flow control cannot be disabled for sending.  Sending
            data is always subject to the flow control window advertised by the receiver.
          </t>
          <t>
            Deployments with constrained resources (for example, memory) MAY employ flow control to
            limit the amount of memory a peer can consume.  Note, however, that this can lead to
            suboptimal use of available network resources if flow control is enabled without
            knowledge of the bandwidth-delay product (see <xref target="RFC1323"/>).
          </t>
          <t>
            Even with full awareness of the current bandwidth-delay product, implementation of flow
            control can be difficult.  When using flow control, the receive MUST read from the TCP
            receive buffer in a timely fashion.  Failure to do so could lead to a deadlock when
            critical frames, such as <x:ref>WINDOW_UPDATE</x:ref>, are not available to HTTP/2.0.
            However, flow control can ensure that constrained resources are protected without any
            reduction in connection utilization.
          </t>
        </section>
      </section>
      
      <section anchor="StreamPriority" title="Stream priority">
        <t>
          The endpoint establishing a new stream can assign a priority for the stream.  Priority is
          represented as an unsigned 31-bit integer.  0 represents the highest priority and
          2<x:sup>31</x:sup>-1 represents the lowest priority.
        </t>
        <t>
          The purpose of this value is to allow an endpoint to express the relative priority of a
          stream.  An endpoint can use this information to preferentially allocate resources to a
          stream.  Within HTTP/2.0, priority can be used to select streams for transmitting frames
          when there is limited capacity for sending.  For instance, an endpoint might enqueue
          frames for all concurrently active streams.  As transmission capacity becomes available,
          frames from higher priority streams might be sent before lower priority streams.
        </t>
        <t>
          Explicitly setting the priority for a stream does not guarantee any particular processing
          or transmission order for the stream relative to any other stream. Nor is there any
          mechanism provided by which the initiator of a stream can force or require a receiving
          endpoint to process concurrent streams in a particular order.
        </t>
        <t>
          Unless explicitly specified in the <x:ref>HEADERS</x:ref> frame (<xref target="HEADERS"/>)
          during stream creation, the default stream priority is 2<x:sup>30</x:sup>.
        </t>
        <t>
          <xref target="PushResources">Pushed streams</xref> have a lower priority than their
          associated stream.  The promised stream inherits the priority value of the associated
          stream plus one, up to a maximum of 2<x:sup>31</x:sup>-1.
        </t>

      </section>

      <section title="Error Handling">
        <t>
          HTTP/2.0 framing permits two classes of error:
          <list style="symbols">
            <t>
              An error condition that renders the entire connection unusable is a connection error.
            </t>
            <t>
              An error in an individual stream is a stream error.
            </t>
          </list>
        </t>
        <t>
          A list of error codes is included in <xref target="ErrorCodes"/>.
        </t>

        <section anchor="ConnectionErrorHandler" title="Connection Error Handling">
          <t>
            A connection error is any error which prevents further processing of the framing layer
            or which corrupts any connection state.
          </t>
          <t>
            An endpoint that encounters a connection error SHOULD first send a <x:ref>GOAWAY</x:ref>
            frame (<xref target="GOAWAY"/>) with the stream identifier of the last stream that it
            successfully received from its peer.  The <x:ref>GOAWAY</x:ref> frame includes an error
            code that indicates why the connection is terminating.  After sending the
            <x:ref>GOAWAY</x:ref> frame, the endpoint MUST close the TCP connection.
          </t>
          <t>
            It is possible that the <x:ref>GOAWAY</x:ref> will not be reliably received by the
            receiving endpoint.  In the event of a connection error, <x:ref>GOAWAY</x:ref> only
            provides a best-effort attempt to communicate with the peer about why the connection is
            being terminated.
          </t>
          <t>
            An endpoint can end a connection at any time.  In particular, an endpoint MAY choose to
            treat a stream error as a connection error.  Endpoints SHOULD send a
            <x:ref>GOAWAY</x:ref> frame when ending a connection, as long as circumstances permit
            it.
          </t>
        </section>

        <section anchor="StreamErrorHandler" title="Stream Error Handling">
          <t>
            A stream error is an error related to a specific stream identifier that does not affect
            processing of other streams.
          </t>
          <t>
            An endpoint that detects a stream error sends a <x:ref>RST_STREAM</x:ref> frame (<xref
            target="RST_STREAM"/>) that contains the stream identifier of the stream where the error
            occurred.  The <x:ref>RST_STREAM</x:ref> frame includes an error code that indicates the
            type of error.
          </t>
          <t>
            A <x:ref>RST_STREAM</x:ref> is the last frame that an endpoint can send on a stream.
            The peer that sends the <x:ref>RST_STREAM</x:ref> frame MUST be prepared to receive any
            frames that were sent or enqueued for sending by the remote peer.  These frames can be
            ignored, except where they modify connection state (such as the state maintained for
            <xref target="HeaderBlock">header compression</xref>).
          </t>
          <t>
            Normally, an endpoint SHOULD NOT send more than one <x:ref>RST_STREAM</x:ref> frame for
            any stream. However, an endpoint MAY send additional <x:ref>RST_STREAM</x:ref> frames if
            it receives frames on a closed stream after more than a round-trip time.  This behavior
            is permitted to deal with misbehaving implementations.
          </t>
          <t>
            An endpoint MUST NOT send a <x:ref>RST_STREAM</x:ref> in response to an
            <x:ref>RST_STREAM</x:ref> frame, to avoid looping.
          </t>
        </section>

        <section title="Connection Termination">
          <t>
            If the TCP connection is torn down while streams remain in open or half closed states,
            then the endpoint MUST assume that the stream was abnormally interrupted and could be
            incomplete.
          </t>
        </section>
      </section>
    </section>

    <section  anchor="frame-types" title="Frame Definitions">
        <t>
          This specification defines a number of frame types, each identified by a unique 8-bit type
          code. Each frame type serves a distinct purpose either in the establishment and management
          of the connection as a whole, or of individual streams.
        </t>
        <t>
          The transmission of specific frame types can alter the state of a connection. If endpoints
          fail to maintain a synchronized view of the connection state, successful communication
          within the connection will no longer be possible. Therefore, it is important that
          endpoints have a shared comprehension of how the state is affected by the use any given
          frame. Accordingly, while it is expected that new frame types will be introduced by
          extensions to this protocol, only frames defined by this document are permitted to alter
          the connection state.
        </t>

        <section anchor="DATA" title="DATA">
          <t>
            DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated
            with a stream. One or more DATA frames are used, for instance, to carry HTTP request or
            response payloads.
          </t>
          <t>
            The DATA frame defines the following flags:
            <list style="hanging">
              <t hangText="END_STREAM (0x1):">
                Bit 1 being set indicates that this frame is the last that the endpoint will send
                for the identified stream.  Setting this flag causes the stream to enter one of
                <xref target="StreamStates">"half closed" states or "closed" state</xref>.
              </t>
              <t hangText="RESERVED (0x2):">
                Bit 2 is reserved for future use.
              </t>
            </list>
          </t>
          <t>
            DATA frames MUST be associated with a stream. If a DATA frame is received whose stream
            identifier field is 0x0, the recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>
          <t>
            DATA frames are subject to flow control and can only be sent when a stream is in the
            "open" or "half closed (remote)" states. If a DATA frame is received whose stream is not
            in "open" or "half closed (local)" state, the recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type <x:ref>PROTOCOL_ERROR
            </x:ref>.
          </t>
        </section>

        <section anchor="HEADERS" title="HEADERS">
          <t>
            The HEADERS frame (type=0x1) carries name-value pairs. It is used to <xref
            target="StreamStates">open a stream</xref>.  HEADERS frames can be sent on a stream in
            the "open" or "half closed (remote)" states.
          </t>
          <figure title="HEADERS Frame Payload">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                        Priority (31)                        |
 +-+-------------------------------------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
]]></artwork>
          </figure>

          <t>
            The HEADERS frame defines the following flags:
            <list style="hanging">
              <x:lt hangText="END_STREAM (0x1):">
                <t>
                  Bit 1 being set indicates that the <xref target="HeaderBlock">header block</xref>
                  is the last that the endpoint will send for the identified stream.  Setting this
                  flag causes the stream to enter one of <xref target="StreamStates">"half closed"
                  states</xref>.
                </t>
                <t>
                  A HEADERS frame that is followed by <x:ref>CONTINUATION</x:ref> frames carries the
                  END_STREAM flag that signals the end of a stream.  A <x:ref>CONTINUATION</x:ref>
                  frame cannot be used to terminate a stream.
                </t>
              </x:lt>
              <x:lt hangText="RESERVED (0x2):">
                <t>
                  Bit 2 is reserved for future use.
                </t>
              </x:lt>
              <x:lt hangText="END_HEADERS (0x4):">
                <t>
                  Bit 3 being set indicates that this frame contains an entire <xref
                  target="HeaderBlock">header block</xref> and is not followed by any
                  <x:ref>CONTINUATION</x:ref> frames.
                </t>
                <t>
                  A HEADERS frame without the END_HEADERS flag set MUST be followed by a
                  <x:ref>CONTINUATION</x:ref> frame for the same stream.  A receiver MUST treat the
                  receipt of any other type of frame or a frame on a different stream as a <xref
                  target="ConnectionErrorHandler">connection error</xref> of type
                  <x:ref>PROTOCOL_ERROR</x:ref>.
                </t>
              </x:lt>
              <x:lt hangText="PRIORITY (0x8):">
                <t>
                  Bit 4 being set indicates that the first four octets of this frame contain a
                  single reserved bit and a 31-bit priority; see <xref target="StreamPriority"/>.
                  If this bit is not set, the four bytes do not appear and the frame only contains a
                  header block fragment.
                </t>
              </x:lt>
            </list>
          </t>

          <t>
            The payload of a HEADERS frame contains a <xref target="HeaderBlock">header block
            fragment</xref>.  A header block that does not fit within a HEADERS frame is continued
            in a <xref target="CONTINUATION">CONTINUATION frame</xref>.
          </t>

          <t>
            HEADERS frames MUST be associated with a stream. If a HEADERS frame is received whose
            stream identifier field is 0x0, the recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>

          <t>
            The HEADERS frame changes the connection state as described in <xref
            target="HeaderBlock" />.
          </t>
        </section>

        <section anchor="PRIORITY" title="PRIORITY">
          <t>
            The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream.  It can
            be sent at any time for an existing stream. This enables reprioritisation of existing
            streams.
          </t>
          <figure title="PRIORITY Frame Payload">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                        Priority (31)                        |
 +-+-------------------------------------------------------------+
]]></artwork>
          </figure>
          <t>
            The payload of a PRIORITY frame contains a single reserved bit and a 31-bit priority.
          </t>
          <t>
            The PRIORITY frame does not define any flags.
          </t>

          <t>
            The PRIORITY frame is associated with an existing stream. If a PRIORITY frame is
            received with a stream identifier of 0x0, the recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>
          <t>
            The PRIORITY frame can be sent on a stream in any of the "reserved (remote)", "open",
            "half-closed (local)", or "half closed (remote)" states, though it cannot be sent
            between consecutive frames that comprise a single <xref target="HeaderBlock">header
            block</xref>.  Note that this frame could arrive after processing or frame sending has
            completed, which would cause it to have no effect.  For a stream that is in the "half
            closed (remote)" state, this frame can only affect processing of the stream and not
            frame transmission.
          </t>
        </section>

        <section anchor="RST_STREAM" title="RST_STREAM">
          <t>
            The RST_STREAM frame (type=0x3) allows for abnormal termination of a stream.  When sent
            by the initiator of a stream, it indicates that they wish to cancel the stream or that
            an error condition has occurred.  When sent by the receiver of a stream, it indicates
            that either the receiver is rejecting the stream, requesting that the stream be
            cancelled or that an error condition has occurred.
          </t>
          <figure title="RST_STREAM Frame Payload">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                        Error Code (32)                        |
 +---------------------------------------------------------------+
]]></artwork>
          </figure>

          <t>
            The RST_STREAM frame contains a single unsigned, 32-bit integer identifying the <xref
            target="ErrorCodes">error code</xref>.  The error code indicates why the stream is being
            terminated.
          </t>

          <t>
            The RST_STREAM frame does not define any flags.
          </t>

          <t>
            The RST_STREAM frame fully terminates the referenced stream and causes it to enter the
            closed state. After receiving a RST_STREAM on a stream, the receiver MUST NOT send
            additional frames for that stream. However, after sending the RST_STREAM, the sending
            endpoint MUST be prepared to receive and process additional frames sent on the stream
            that might have been sent by the peer prior to the arrival of the RST_STREAM.
          </t>

          <t>
            RST_STREAM frames MUST be associated with a stream.  If a RST_STREAM frame is received
            with a stream identifier of 0x0, the recipient MUST treat this as a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>

          <t>
            RST_STREAM frames MUST NOT be sent for a stream in the "idle" state.  If a RST_STREAM
            frame identifying an idle stream is received, the recipient MUST treat this as a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>

        </section>

        <section anchor="SETTINGS" title="SETTINGS">
          <t>
            The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints
            communicate. The parameters are either constraints on peer behavior or preferences.
          </t>
          <t>
            Settings are not negotiated.  Settings describe characteristics of the sending peer,
            which are used by the receiving peer.  Different values for the same setting can be
            advertised by each peer.  For example, a client might set a high initial flow control
            window, whereas a server might set a lower value to conserve resources.
          </t>

          <t>
            SETTINGS frames MUST be sent at the start of a connection, and MAY be sent at any other
            time by either endpoint over the lifetime of the connection.
          </t>

          <t>
            Implementations MUST support all of the settings defined by this specification and MAY
            support additional settings defined by extensions. Unsupported or unrecognized settings
            MUST be ignored.  New settings MUST NOT be defined or implemented in a way that requires
            endpoints to understand them in order to communicate successfully.
          </t>

          <t>
            Each setting in a SETTINGS frame replaces the existing value for that setting.  Settings
            are processed in the order in which they appear, and a receiver of a SETTINGS frame does
            not need to maintain any state other than the current value of settings.  Therefore, the
            value of a setting is the last value that is seen by a receiver.  This permits the
            inclusion of the same settings multiple times in the same SETTINGS frame, though doing
            so does nothing other than waste connection capacity.
          </t>
          <t>
            The SETTINGS frame defines the following flag:
            <list style="hanging">
              <t hangText="ACK (0x1):">
                Bit 1 being set indicates that this frame acknowledges receipt and application of
                the peer's SETTINGS frame.  When this bit is set, the payload of the SETTINGS frame
                MUST be empty.  Receipt of a SETTINGS frame with the ACK flag set and a length field
                value other than 0 MUST be treated as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type
                <x:ref>FRAME_SIZE_ERROR</x:ref>.  For more info, see <xref
                target="SettingsSync">Settings Synchronization</xref>.
              </t>
            </list>
          </t>
          <t>
            SETTINGS frames always apply to a connection, never a single stream.  The stream
            identifier for a settings frame MUST be zero. If an endpoint receives a SETTINGS frame
            whose stream identifier field is anything other than 0x0, the endpoint MUST respond with
            a <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>
          <t>
            The SETTINGS frame affects connection state.  A badly formed or incomplete SETTINGS
            frame MUST be treated as a <xref target="ConnectionErrorHandler">connection error</xref>
            of type <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>

          <section title="Setting Format" anchor="SettingFormat">
            <t>
              The payload of a SETTINGS frame consists of zero or more settings.  Each setting
              consists of an 8-bit reserved field, an unsigned 24-bit setting identifier, and an
              unsigned 32-bit value.
            </t>

            <figure title="Setting Format">
              <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Reserved (8) |            Setting Identifier (24)            |
 +---------------+-----------------------------------------------+
 |                        Value (32)                             |
 +---------------------------------------------------------------+
]]></artwork>
            </figure>
          </section>

          <section anchor="SettingValues" title="Defined Settings">
            <t>
              The following settings are defined:
              <list style="hanging">
                <x:lt hangText="SETTINGS_HEADER_TABLE_SIZE (1):" anchor="SETTINGS_HEADER_TABLE_SIZE">
                  <t>
                    Allows the sender to inform the remote endpoint of the size of the header
                    compression table used to decode header blocks.  The space available for
                    encoding cannot be changed; it is determined by the setting sent by the peer
                    that receives the header blocks.  The initial value is 4096 bytes.
                  </t>
                </x:lt>
                <x:lt hangText="SETTINGS_ENABLE_PUSH (2):" anchor="SETTINGS_ENABLE_PUSH">
                  <t>
                    This setting can be use to disable <xref target="PushResources">server
                    push</xref>.  An endpoint MUST NOT send a <x:ref>PUSH_PROMISE</x:ref> frame if
                    it receives this setting set to a value of 0.  The initial value is 1, which
                    indicates that push is permitted.
                  </t>
                </x:lt>
                <x:lt hangText="SETTINGS_MAX_CONCURRENT_STREAMS (4):" anchor="SETTINGS_MAX_CONCURRENT_STREAMS">
                  <t>
                    Indicates the maximum number of concurrent streams that the sender will allow.
                    This limit is directional: it applies to the number of streams that the sender
                    permits the receiver to create. Initially there is no limit to this value.  It
                    is recommended that this value be no smaller than 100, so as to not
                    unnecessarily limit parallelism.
                  </t>
                </x:lt>
                <x:lt hangText="SETTINGS_INITIAL_WINDOW_SIZE (7):" anchor="SETTINGS_INITIAL_WINDOW_SIZE">
                  <t>
                    Indicates the sender's initial window size (in bytes) for stream level flow
                    control.
                  </t>
                  <t>
                    This settings affects the window size of all streams, including existing
                    streams, see <xref target="InitialWindowSize"/>.
                  </t>
                </x:lt>
                <x:lt hangText="SETTINGS_FLOW_CONTROL_OPTIONS (10):" anchor="SETTINGS_FLOW_CONTROL_OPTIONS">
                  <t>
                    Indicates flow control options.  The least significant bit (0x1) of the value is
                    set to indicate that the sender has disabled all flow control.  This bit cannot
                    be cleared once set, see <xref target="EndFlowControl"/>.
                  </t>
                  <t>
                    All bits other than the least significant are reserved.
                  </t>
                </x:lt>
              </list>
            </t>
          </section>
          <section anchor="SettingsSync" title="Settings Synchronization">
            <t>
              Most values in SETTINGS benefit from or require an understanding of when the peer has
              received and applied the changed setting values.  In order to provide such
              synchronization timepoints, the recipient of a SETTINGS frame in which the ACK flag is
              not set MUST apply the updated settings as soon as possible upon receipt.
            </t>
            <t>
              The values in the SETTINGS frame MUST be applied in the order they appear, with no
              other frame processing between values.  Once all values have been applied, the
              recipient MUST immediately emit a SETTINGS frame with the ACK flag set.  The sender of
              altered settings applies changes upon receiving a SETTINGS frame with the ACK flag
              set.
            </t>
            <t>
              If the sender of a SETTINGS frame does not receive an acknowledgement within a
              reasonable amount of time, it MAY issue a <xref
              target="ConnectionErrorHandler">connection error</xref> of type
              <x:ref>SETTINGS_TIMEOUT</x:ref>.
            </t>
          </section>
        </section>

        <section anchor="PUSH_PROMISE" title="PUSH_PROMISE">
          <t>
            The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint in advance of
            streams the sender intends to initiate.  The PUSH_PROMISE frame includes the unsigned
            31-bit identifier of the stream the endpoint plans to create along with a set of
            headers that provide additional context for the stream.  <xref target="PushResources"/>
            contains a thorough description of the use of PUSH_PROMISE frames.
          </t>
          <t>
            PUSH_PROMISE MUST NOT be sent if the <x:ref>SETTINGS_ENABLE_PUSH</x:ref> setting of the
            peer endpoint is set to 0.
          </t>

          <figure title="PUSH_PROMISE Payload Format">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                Promised-Stream-ID (31)                      |
 +-+-------------------------------------------------------------+
 |                 Header Block Fragment (*)                   ...
 +---------------------------------------------------------------+
]]></artwork>
          </figure>

          <t>
            The payload of a PUSH_PROMISE includes a "Promised-Stream-ID".  This unsigned 31-bit
            integer identifies the stream the endpoint intends to start sending frames for.  The
            promised stream identifier MUST be a valid choice for the next stream sent by the sender
            (see <xref target="StreamIdentifiers">new stream identifier</xref>).
          </t>
          
          <t>
            Following the "Promised-Stream-ID" is a <xref target="HeaderBlock">header block
            fragment</xref>.
          </t>

          <t>
            PUSH_PROMISE frames MUST be associated with an existing, peer-initiated stream. If the
            stream identifier field specifies the value 0x0, a recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>

          <t>
            The PUSH_PROMISE frame defines the following flags:
            <list style="hanging">
              <x:lt hangText="END_PUSH_PROMISE (0x4):">
                <t>
                  Bit 3 being set indicates that this frame contains an entire <xref
                  target="HeaderBlock">header block</xref> and is not followed by any
                  <x:ref>CONTINUATION</x:ref> frames.
                </t>
                <t>
                  A PUSH_PROMISE frame without the END_PUSH_PROMISE flag set MUST be followed by a
                  CONTINUATION frame for the same stream.  A receiver MUST treat the receipt of any
                  other type of frame or a frame on a different stream as a <xref
                  target="ConnectionErrorHandler">connection error</xref> of type
                  <x:ref>PROTOCOL_ERROR</x:ref>.
                </t>
              </x:lt>
            </list>
          </t>

          <t>
            Promised streams are not required to be used in order promised.  The PUSH_PROMISE only
            reserves stream identifiers for later use.
          </t>

          <t>
            Recipients of PUSH_PROMISE frames can choose to reject promised streams by returning a
            <x:ref>RST_STREAM</x:ref> referencing the promised stream identifier back to the sender
            of the PUSH_PROMISE.
          </t>

          <t>
            The PUSH_PROMISE frame modifies the connection state as defined in <xref
            target="HeaderBlock" />.
          </t>
          <t>
            A PUSH_PROMISE frame modifies the connection state in two ways.  The inclusion of a
            <xref target="HeaderBlock">header block</xref> potentially modifies the compression
            state.  PUSH_PROMISE also reserves a stream for later use, causing the promised stream
            to enter the "reserved" state.  A sender MUST NOT send a PUSH_PROMISE on a stream unless
            that stream is either "open" or "half closed (remote)"; the sender MUST ensure that the
            promised stream is a valid choice for a <xref target="StreamIdentifiers">new stream
            identifier</xref> (that is, the promised stream MUST be in the "idle" state).
          </t>
          <t>
            Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame causes the stream
            state to become indeterminate.  A receiver MUST treat the receipt of a PUSH_PROMISE on a
            stream that is neither "open" nor "half-closed (local)" as a <xref
            target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.  Similarly, a receiver MUST treat the receipt of a
            PUSH_PROMISE that promises an <xref target="StreamIdentifiers">illegal stream
            identifier</xref> (that is, an identifier for a stream that is not currently in the
            "idle" state) as a <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>, unless the receiver recently sent a
            <x:ref>RST_STREAM</x:ref> frame to cancel the associated stream (see <xref
            target="StreamStates"/>).
          </t>
        </section>

        <section anchor="PING" title="PING">
          <t>
            The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from
            the sender, as well as determining whether an idle connection is still functional.  PING
            frames can be sent from any endpoint.
          </t>
          <figure title="PING Payload Format">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 |                      Opaque Data (64)                         |
 |                                                               |
 +---------------------------------------------------------------+
]]></artwork>
          </figure>

          <t>
            In addition to the frame header, PING frames MUST contain 8 octets of data in the
            payload.  A sender can include any value it chooses and use those bytes in any fashion.
          </t>
          <t>
            Receivers of a PING frame that does not include a ACK flag MUST send a PING frame with
            the ACK flag set in response, with an identical payload.  PING responses SHOULD given
            higher priority than any other frame.
          </t>

          <t>
            The PING frame defines the following flags:
            <list style="hanging">
              <t hangText="ACK (0x1):">
                Bit 1 being set indicates that this PING frame is a PING response.  An endpoint MUST
                set this flag in PING responses.  An endpoint MUST NOT respond to PING frames
                containing this flag.
              </t>
            </list>
          </t>
          <t>
            PING frames are not associated with any individual stream. If a PING frame is received
            with a stream identifier field value other than 0x0, the recipient MUST respond with a
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>
          <t>
            Receipt of a PING frame with a length field value other than 8 MUST be treated as a
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>FRAME_SIZE_ERROR</x:ref>.
          </t>

        </section>

        <section anchor="GOAWAY" title="GOAWAY">
          <t>
            The GOAWAY frame (type=0x7) informs the remote peer to stop creating streams on this
            connection.  It can be sent from the client or the server. Once sent, the sender will
            ignore frames sent on new streams for the remainder of the connection. Receivers of a
            GOAWAY frame MUST NOT open additional streams on the connection, although a new
            connection can be established for new streams.  The purpose of this frame is to allow an
            endpoint to gracefully stop accepting new streams (perhaps for a reboot or maintenance),
            while still finishing processing of previously established streams.
          </t>
          <t>
            There is an inherent race condition between an endpoint starting new streams and the
            remote sending a GOAWAY frame.  To deal with this case, the GOAWAY contains the stream
            identifier of the last stream which was processed on the sending endpoint in this
            connection.  If the receiver of the GOAWAY used streams that are newer than the
            indicated stream identifier, they were not processed by the sender and the receiver may
            treat the streams as though they had never been created at all (hence the receiver may
            want to re-create the streams later on a new connection).
          </t>
          <t>
            Endpoints SHOULD always send a GOAWAY frame before closing a connection so that the
            remote can know whether a stream has been partially processed or not.  For example, if
            an HTTP client sends a POST at the same time that a server closes a connection, the
            client cannot know if the server started to process that POST request if the server does
            not send a GOAWAY frame to indicate where it stopped working.  An endpoint might choose
            to close a connection without sending GOAWAY for misbehaving peers.
          </t>

          <t>
            After sending a GOAWAY frame, the sender can discard frames for new streams.  However,
            any frames that alter connection state cannot be completely ignored.  For instance,
            <x:ref>HEADERS</x:ref>, <x:ref>PUSH_PROMISE</x:ref> and <x:ref>CONTINUATION</x:ref>
            frames MUST be minimally processed to ensure a consistent compression state (see <xref
            target="HeaderBlock"/>); similarly DATA frames MUST be counted toward the connection
            flow control window.
          </t>

          <figure title="GOAWAY Payload Format">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                  Last-Stream-ID (31)                        |
 +-+-------------------------------------------------------------+
 |                      Error Code (32)                          |
 +---------------------------------------------------------------+
 |                  Additional Debug Data (*)                    |
 +---------------------------------------------------------------+
]]></artwork>
          </figure>
          <t>
            The GOAWAY frame does not define any flags.
          </t>
          <t>
            The GOAWAY frame applies to the connection, not a specific stream.  The stream
            identifier MUST be zero.
          </t>
          <t>
            The last stream identifier in the GOAWAY frame contains the highest numbered stream
            identifier for which the sender of the GOAWAY frame has received frames on and might
            have taken some action on.  All streams up to and including the identified stream might
            have been processed in some way.  The last stream identifier is set to 0 if no streams
            were processed.
            <list>
              <t>
                Note: In this case, "processed" means that some data from the stream was passed to
                some higher layer of software that might have taken some action as a result.
              </t>
            </list>
            If a connection terminates without a GOAWAY frame, this value is effectively the highest
            stream identifier.
          </t>
          <t>
            On streams with lower or equal numbered identifiers that were not closed completely
            prior to the connection being closed, re-attempting requests, transactions, or any
            protocol activity is not possible (with the exception of idempotent actions like HTTP
            GET, PUT, or DELETE).  Any protocol activity that uses higher numbered streams can be
            safely retried using a new connection.
          </t>
          <t>
            Activity on streams numbered lower or equal to the last stream identifier might still
            complete successfully.  The sender of a GOAWAY frame might gracefully shut down a
            connection by sending a GOAWAY frame, maintaining the connection in an open state until
            all in-progress streams complete.
          </t>
          <t>
            The last stream ID MUST be 0 if no streams were acted upon.
          </t>
          <t>
            The GOAWAY frame also contains a 32-bit <xref target="ErrorCodes">error code</xref> that
            contains the reason for closing the connection.
          </t>
          <t>
            Endpoints MAY append opaque data to the payload of any GOAWAY frame.  Additional debug
            data is intended for diagnostic purposes only and carries no semantic value.  Debug data
            MUST NOT be persistently stored, since it could contain sensitive information.
          </t>
        </section>

        <section anchor="WINDOW_UPDATE" title="WINDOW_UPDATE">
          <t>
            The WINDOW_UPDATE frame (type=0x9) is used to implement flow control.
          </t>
          <t>
            Flow control operates at two levels: on each individual stream and on the entire
            connection.
          </t>
          <t>
            Both types of flow control are hop by hop; that is, only between the two endpoints.
            Intermediaries do not forward WINDOW_UPDATE frames between dependent connections.
            However, throttling of data transfer by any receiver can indirectly cause the
            propagation of flow control information toward the original sender.
          </t>
          <t>
            Flow control only applies to frames that are identified as being subject to flow
            control.  Of the frame types defined in this document, this includes only
            <x:ref>DATA</x:ref> frame.  Frames that are exempt from flow control MUST be accepted
            and processed, unless the receiver is unable to assign resources to handling the frame.
            A receiver MAY respond with a <xref target="StreamErrorHandler">stream error</xref> or
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            <x:ref>FLOW_CONTROL_ERROR</x:ref> if it is unable accept a frame.
          </t>
          <figure title="WINDOW_UPDATE Payload Format">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|              Window Size Increment (31)                     |
 +-+-------------------------------------------------------------+
]]></artwork>
          </figure>
          <t>
            The payload of a WINDOW_UPDATE frame is one reserved bit, plus an unsigned 31-bit
            integer indicating the number of bytes that the sender can transmit in addition to the
            existing flow control window.  The legal range for the increment to the flow control
            window is 1 to 2<x:sup>31</x:sup> - 1 (0x7fffffff) bytes.
          </t>
          <t>
            The WINDOW_UPDATE frame does not define any flags.
          </t>
          <t>
            The WINDOW_UPDATE frame can be specific to a stream or to the entire connection.  In the
            former case, the frame's stream identifier indicates the affected stream; in the latter,
            the value "0" indicates that the entire connection is the subject of the frame.
          </t>
          <t>
            WINDOW_UPDATE can be sent by a peer that has sent a frame bearing the END_STREAM flag.
            This means that a receiver could receive a WINDOW_UPDATE frame on a "half closed
            (remote)" or "closed" stream.  A receiver MUST NOT treat this as an error, see <xref
            target="StreamStates"/>.
          </t>
          <t>
            A receiver that receives a flow controlled frame MUST always account for its
            contribution against the connection flow control window, unless the receiver treats this
            as a <xref target="ConnectionErrorHandler">connection error</xref>.  This is necessary
            even if the frame is in error.  Since the sender counts the frame toward the flow
            control window, if the receiver does not, the flow control window at sender and receiver
            can become different.
          </t>

          <section title="The Flow Control Window">
            <t>
              Flow control in HTTP/2.0 is implemented using a window kept by each sender on every
              stream. The flow control window is a simple integer value that indicates how many
              bytes of data the sender is permitted to transmit; as such, its size is a measure of
              the buffering capability of the receiver.
            </t>
            <t>
              Two flow control windows are applicable: the stream flow control window and the
              connection flow control window.  The sender MUST NOT send a flow controlled frame with
              a length that exceeds the space available in either of the flow control windows
              advertised by the receiver.  Frames with zero length with the END_STREAM flag set (for
              example, an empty data frame) MAY be sent if there is no available space in either
              flow control window.
            </t>
            <t>
              For flow control calculations, the 8 byte frame header is not counted.
            </t>
            <t>
              After sending a flow controlled frame, the sender reduces the space available in both
              windows by the length of the transmitted frame.
            </t>
            <t>
              The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up
              space in flow control windows.  Separate WINDOW_UPDATE frames are sent for the stream
              and connection level flow control windows.
            </t>
            <t>
              A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the
              amount specified in the frame.
            </t>
            <t>
              A sender MUST NOT allow a flow control window to exceed 2<x:sup>31</x:sup> - 1 bytes.
              If a sender receives a WINDOW_UPDATE that causes a flow control window to exceed this
              maximum it MUST terminate either the stream or the connection, as appropriate.  For
              streams, the sender sends a <x:ref>RST_STREAM</x:ref> with the error code of
              <x:ref>FLOW_CONTROL_ERROR</x:ref> code; for the connection, a <x:ref>GOAWAY</x:ref>
              frame with a <x:ref>FLOW_CONTROL_ERROR</x:ref> code.
            </t>
            <t>
              Flow controlled frames from the sender and WINDOW_UPDATE frames from the receiver are
              completely asynchronous with respect to each other. This property allows a receiver to
              aggressively update the window size kept by the sender to prevent streams from
              stalling.
            </t>
          </section>

          <section anchor="InitialWindowSize" title="Initial Flow Control Window Size">
            <t>
              When a HTTP/2.0 connection is first established, new streams are created with an
              initial flow control window size of 65,535 bytes. The connection flow control window
              is 65,535 bytes.  Both endpoints can adjust the initial window size for new streams by
              including a value for <x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref> in the
              <x:ref>SETTINGS</x:ref> frame that forms part of the connection header.
            </t>
            <t>
              Prior to receiving a <x:ref>SETTINGS</x:ref> frame that sets a value for
              <x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref>, an endpoint can only use the default
              initial window size when sending flow controlled frames.  Similarly, the connection
              flow control window is set to the default initial window size until a WINDOW_UPDATE
              frame is received.
            </t>
            <t>
              A <x:ref>SETTINGS</x:ref> frame can alter the initial flow control window size for all
              current streams. When the value of <x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref>
              changes, a receiver MUST adjust the size of all stream flow control windows that it
              maintains by the difference between the new value and the old value. A
              <x:ref>SETTINGS</x:ref> frame cannot alter the connection flow control window.
            </t>
            <t>
              A change to <x:ref>SETTINGS_INITIAL_WINDOW_SIZE</x:ref> could cause the available
              space in a flow control window to become negative.  A sender MUST track the negative
              flow control window, and MUST NOT send new flow controlled frames until it receives
              WINDOW_UPDATE frames that cause the flow control window to become positive.
            </t>
            <t>
      	      For example, if the client sends 60KB immediately on connection establishment, and the
      	      server sets the initial window size to be 16KB, the client will recalculate the
      	      available flow control window to be -44KB on receipt of the <x:ref>SETTINGS</x:ref>
      	      frame.  The client retains a negative flow control window until WINDOW_UPDATE frames
      	      restore the window to being positive, after which the client can resume sending.
            </t>
          </section>

          <section title="Reducing the Stream Window Size">
            <t>
              A receiver that wishes to use a smaller flow control window than the current size can
              send a new <x:ref>SETTINGS</x:ref> frame.  However, the receiver MUST be prepared to
              receive data that exceeds this window size, since the sender might send data that
              exceeds the lower limit prior to processing the <x:ref>SETTINGS</x:ref> frame.
            </t>
            <t>
              A receiver has two options for handling streams that exceed flow control limits:
              <list style="numbers">
                <t>
                  The receiver can immediately send <x:ref>RST_STREAM</x:ref> with
                  <x:ref>FLOW_CONTROL_ERROR</x:ref> error code for the affected streams.
                </t>
                <t>
                  The receiver can accept the streams and tolerate the resulting head of line
                  blocking, sending WINDOW_UPDATE frames as it consumes data.
                </t>
              </list>
              If a receiver decides to accept streams, both sides MUST recompute the available flow
              control window based on the initial window size sent in the <x:ref>SETTINGS</x:ref>.
            </t>
          </section>

          <section anchor="EndFlowControl" title="Ending Flow Control">
            <t>
              After a receiver reads in a frame that marks the end of a stream (for example, a data
              stream with a END_STREAM flag set), it MUST cease transmission of WINDOW_UPDATE frames
              for that stream. A sender is not obligated to maintain the available flow control
              window for streams that it is no longer sending on.
            </t>
            <t>
              Flow control can be disabled for the entire connection using the
              <x:ref>SETTINGS_FLOW_CONTROL_OPTIONS</x:ref> setting.  This setting ends all forms of
              flow control.  An implementation that does not wish to perform flow control can use
              this in the initial <x:ref>SETTINGS</x:ref> exchange.
            </t>
            <t>
              Flow control cannot be enabled again once disabled.  Any attempt to re-enable flow
              control - by sending a WINDOW_UPDATE or by clearing the bits on the
              <x:ref>SETTINGS_FLOW_CONTROL_OPTIONS</x:ref> setting - MUST be rejected with a
              <x:ref>FLOW_CONTROL_ERROR</x:ref> error code.
            </t>
          </section>
        </section>

        <section anchor="CONTINUATION" title="CONTINUATION">
          <t>
            The CONTINUATION frame (type=0xA) is used to continue a sequence of <xref
            target="HeaderBlock">header block fragments</xref>.  Any number of CONTINUATION frames
            can be sent on an existing stream, as long as the preceding frame on the same stream is
            one of <x:ref>HEADERS</x:ref>, <x:ref>PUSH_PROMISE</x:ref> or CONTINUATION without the
            END_HEADERS or END_PUSH_PROMISE flag set.
          </t>

          <figure title="CONTINUATION Frame Payload">
            <artwork type="inline"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
]]></artwork>
          </figure>

          <t>
            The CONTINUATION frame defines the following flags:
            <list style="hanging">
              <x:lt hangText="END_HEADERS (0x4):">
                <t>
                  Bit 3 being set indicates that this frame ends a <xref
                  target="HeaderBlock">header block</xref>.
                </t>
                <t>
                  If the END_HEADERS bit is not set, this frame MUST be followed by another
                  CONTINUATION frame.  A receiver MUST treat the receipt of any other type of frame
                  or a frame on a different stream as a <xref
                  target="ConnectionErrorHandler">connection error</xref> of type
                  <x:ref>PROTOCOL_ERROR</x:ref>.
                </t>
              </x:lt>
            </list>
          </t>

          <t>
            The payload of a CONTINUATION frame contains a <xref target="HeaderBlock">header block
            fragment</xref>.
          </t>

          <t>
            The CONTINUATION frame changes the connection state as defined in <xref
            target="HeaderBlock" />.
          </t>

          <t>
            CONTINUATION frames MUST be associated with a stream. If a CONTINUATION frame is
            received whose stream identifier field is 0x0, the recipient MUST respond with a <xref
            target="ConnectionErrorHandler">connection error</xref> of type PROTOCOL_ERROR.
          </t>

          <t>
            A CONTINUATION frame MUST be preceded by a <x:ref>HEADERS</x:ref>,
            <x:ref>PUSH_PROMISE</x:ref> or CONTINUATION frame without the END_HEADERS flag set.
            A recipient that observes violation of this rule MUST respond with a
            <xref target="ConnectionErrorHandler"> connection error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>
        </section>
    </section>

    <section anchor="ErrorCodes" title="Error Codes">
      <t>
        Error codes are 32-bit fields that are used in <x:ref>RST_STREAM</x:ref> and
        <x:ref>GOAWAY</x:ref> frames to convey the reasons for the stream or connection error.
      </t>

      <t>
        Error codes share a common code space.  Some error codes only apply to specific conditions
        and have no defined semantics in certain frame types.
      </t>

      <t>
        The following error codes are defined:
        <list style="hanging">
          <t hangText="NO_ERROR (0):" anchor="NO_ERROR">
            The associated condition is not as a result of an error.  For example, a
            <x:ref>GOAWAY</x:ref> might include this code to indicate graceful shutdown of a
            connection.
          </t>
          <t hangText="PROTOCOL_ERROR (1):" anchor="PROTOCOL_ERROR">
            The endpoint detected an unspecific protocol error.  This error is for use when a more
            specific error code is not available.
          </t>
          <t hangText="INTERNAL_ERROR (2):" anchor="INTERNAL_ERROR">
            The endpoint encountered an unexpected internal error.
          </t>
          <t hangText="FLOW_CONTROL_ERROR (3):" anchor="FLOW_CONTROL_ERROR">
            The endpoint detected that its peer violated the flow control protocol.
          </t>
          <t hangText="SETTINGS_TIMEOUT (4):" anchor="SETTINGS_TIMEOUT">
            The endpoint sent a SETTINGS frame, but did not receive a response in a
            timely manner.  See <xref target="SettingsSync">Settings Synchronization</xref>.
          </t>
          <t hangText="STREAM_CLOSED (5):" anchor="STREAM_CLOSED">
            The endpoint received a frame after a stream was half closed.
          </t>
          <t hangText="FRAME_SIZE_ERROR (6):" anchor="FRAME_SIZE_ERROR">
            The endpoint received a frame that was larger than the maximum size that it
            supports.
          </t>
          <t hangText="REFUSED_STREAM (7):" anchor="REFUSED_STREAM">
            The endpoint refuses the stream prior to performing any application processing, see
            <xref target="Reliability"/> for details.
          </t>
          <t hangText="CANCEL (8):" anchor="CANCEL">
            Used by the endpoint to indicate that the stream is no longer needed.
          </t>
          <t hangText="COMPRESSION_ERROR (9):" anchor="COMPRESSION_ERROR">
            The endpoint is unable to maintain the compression context for the connection.
          </t>
          <t hangText="CONNECT_ERROR (10):" anchor="CONNECT_ERROR">
            The connection established in response to a <xref target="CONNECT">CONNECT
            request</xref> was reset or abnormally closed.
          </t>
          <t hangText="ENHANCE_YOUR_CALM (420):" anchor="ENHANCE_YOUR_CALM">
            The endpoint detected that its peer is exhibiting a behavior over a given amount of time
            that has caused it to refuse to process further frames.
          </t>
        </list>
      </t>
    </section>

    <section anchor="HTTPLayer" title="HTTP Message Exchanges">
      <t>
        HTTP/2.0 is intended to be as compatible as possible with current web-based
        applications. This means that, from the perspective of the server business logic or
        application API, the features of HTTP are unchanged. To achieve this, all of the application
        request and response header semantics are preserved, although the syntax of conveying those
        semantics has changed.  Thus, the rules from HTTP/1.1 (<xref target="HTTP-p1"/>, <xref
        target="HTTP-p2"/>, <xref target="HTTP-p4"/>, <xref target="HTTP-p5"/>, <xref
        target="HTTP-p6"/>, and <xref target="HTTP-p7"/>) apply with the changes in the sections
        below.
      </t>

      <section anchor="HttpSequence" title="HTTP Request/Response Exchange">
        <t>
          A client sends an HTTP request on a new stream, using a previously unused <xref
          target="StreamIdentifiers">stream identifier</xref>.  A server sends an HTTP response on
          the same stream as the request.
        </t>
        <t>
          An HTTP request or response each consist of:
          <list style="numbers">
            <t>
              a <x:ref>HEADERS</x:ref> frame;
            </t>
            <t>
              one contiguous sequence of zero or more <x:ref>CONTINUATION</x:ref> frames;
            </t>
            <t>
              zero or more <x:ref>DATA</x:ref> frames; and
            </t>
            <t>
              optionally, a contiguous sequence that starts with a <x:ref>HEADERS</x:ref> frame,
              followed by zero or more <x:ref>CONTINUATION</x:ref> frames.
            </t>
          </list>
          The last frame in the sequence bears an END_STREAM flag, though a <x:ref>HEADERS</x:ref>
          frame bearing the END_STREAM flag can be followed by <x:ref>CONTINUATION</x:ref> frames
          that carry any remaining portions of the header block.
        </t>
        <t>
          Other frames MAY be interspersed with these frames, but those frames do not carry HTTP
          semantics.  In particular, <x:ref>HEADERS</x:ref> frames (and any
          <x:ref>CONTINUATION</x:ref> frames that follow) other than the first and optional last
          frames in this sequence do not carry HTTP semantics.
        </t>

        <t>
          Trailing header fields are carried in a header block that also terminates the stream.
          That is, a sequence starting with a <x:ref>HEADERS</x:ref> frame, followed by zero or more
          <x:ref>CONTINUATION</x:ref> frames, where the <x:ref>HEADERS</x:ref> frame bears an
          END_STREAM flag.  Header blocks after the first that do not terminate the stream are not
          part of an HTTP request or response.
        </t>

        <t>
          An HTTP request/response exchange fully consumes a single stream.  A request starts with
          the <x:ref>HEADERS</x:ref> frame that puts the stream into an "open" state and ends with a
          frame bearing END_STREAM, which causes the stream to become "half closed" for the client.
          A response starts with a <x:ref>HEADERS</x:ref> frame and ends with a frame bearing
          END_STREAM, which places the stream in the "closed" state.
        </t>
       
        <section anchor="informational-responses" title="Informational Responses">
          <t>
            <cref>This section is likely to change significantly.  This only captures the high
            points.</cref>
          </t>
          <t>
            The 1xx series of HTTP response codes (<xref target="HTTP-p2" x:fmt=","
            x:rel="#status.1xx"/>) are not supported by HTTP/2.0.
          </t>
          <t>
            An intermediary that translates HTTP/1.1 requests to HTTP/2.0 MUST generate any
            mandatory informational responses.  For instance, a translating intermediary generates a
            100 (Continue) response if a request includes an Expect header field with a <spanx
            style="verb">100-continue</spanx> token (<xref target="HTTP-p2" x:fmt=","
            x:rel="#header.expect"/>).
          </t>
          <t>
            An intermediary that translates HTTP/1.1 responses to HTTP/2.0 MUST ignore informational
            responses.
          </t>
        </section>

        <section title="Examples">
          <t>
            This section shows HTTP/1.1 requests and responses, with illustrations of equivalent
            HTTP/2.0 requests and responses.
          </t>
          <t>
            An HTTP GET request includes request header fields and no body and is therefore
            transmitted as a single contiguous sequence of <x:ref>HEADERS</x:ref> frames containing
            the serialized block of request header fields.  The last <x:ref>HEADERS</x:ref> frame in
            the sequence has both the END_HEADERS and END_STREAM flag set:
          </t>
          
          <figure>
            <artwork type="inline"><![CDATA[
  GET /resource HTTP/1.1         HEADERS
  Host: example.org        ==>     + END_STREAM
  Accept: image/jpeg               + END_HEADERS
                                     :method = GET
                                     :scheme = https
                                     :authority = example.org
                                     :path = /resource
                                     accept = image/jpeg
]]></artwork>
          </figure>
          
          <t>
            Similarly, a response that includes only response header fields is transmitted as a
            sequence of <x:ref>HEADERS</x:ref> frames containing the serialized block of response
            header fields. The last <x:ref>HEADERS</x:ref> frame in the sequence has both the
            END_HEADERS and END_STREAM flag set:
          </t>
          
          <figure>
            <artwork type="inline"><![CDATA[
  HTTP/1.1 204 No Content       HEADERS 
  Content-Length: 0        ===>   + END_STREAM
                                  + END_HEADERS
                                    :status = 204
                                    content-length: 0
]]></artwork>
          </figure>

          <t>
            An HTTP POST request that includes request header fields and payload data is
            transmitted as one <x:ref>HEADERS</x:ref> frame, followed by zero or more
            <x:ref>CONTINUATION</x:ref> frames, containing the request header fields followed by
            one or more <x:ref>DATA</x:ref> frames, with the last <x:ref>CONTINUATION</x:ref> (or
            <x:ref>HEADERS</x:ref>) frame having the END_HEADERS flag set and the final
            <x:ref>DATA</x:ref> frame having the END_STREAM flag set:
          </t>
          
          <figure>
            <artwork type="inline"><![CDATA[
  POST /resource HTTP/1.1        HEADERS 
  Host: example.org         ==>    - END_STREAM
  Content-Type: image/jpeg         + END_HEADERS
  Content-Length: 123                :method = POST
                                     :scheme = https
  {binary data}                      :authority = example.org
                                     :path = /resource
                                     content-type = image/jpeg
                                     content-length = 123

                                 DATA 
                                   + END_STREAM
                                     {binary data}
]]></artwork>
          </figure>

          <t>
            A response that includes header fields and payload data is transmitted as a
            <x:ref>HEADERS</x:ref> frame, followed by zero or more <x:ref>CONTINUATION</x:ref> frames,
            followed by one or more <x:ref>DATA</x:ref> frames, with
            the last <x:ref>DATA</x:ref> frame in the sequence having the END_STREAM flag set:
          </t>
          
          <figure>
            <artwork type="inline"><![CDATA[
  HTTP/1.1 200 OK                HEADERS 
  Content-Type: image/jpeg  ==>    - END_STREAM
  Content-Length: 123              + END_HEADERS
                                     :status = 200
  {binary data}                      content-type = image/jpeg
                                     content-length = 123
                                    
                                 DATA 
                                   + END_STREAM
                                     {binary data}
]]></artwork>
          </figure>

          <t>
            Trailing header fields are sent as a header block after both the request or response
            header block and all the <x:ref>DATA</x:ref> frames have been sent.  The sequence of
            <x:ref>HEADERS</x:ref>/<x:ref>CONTINUATION</x:ref> frames that bears the trailers
            includes a terminal frame that has
            both END_HEADERS and END_STREAM flags set.
          </t>
          
          <figure>
            <artwork type="inline"><![CDATA[
  HTTP/1.1 200 OK               HEADERS 
  Content-Type: image/jpeg ===>   - END_STREAM
  Content-Length: 123             + END_HEADERS 
  Transfer-Encoding: chunked        :status        = 200
  TE: trailers                      content-length = 123
  123                               content-type   = image/jpeg
  {binary data}                     
  0                             DATA 
  Foo: bar                        - END_STREAM 
                                    {binary data}
  
                                HEADERS 
                                  + END_STREAM
                                  + END_HEADERS
                                    foo: bar
]]></artwork>
        </figure>
      </section>        

      <section anchor="HttpHeaders" title="HTTP Header Fields">
        <t>
          HTTP/2.0 request and response header fields carry information as a series of key-value
          pairs.  This includes the target URI for the request, the status code for the response, as
          well as HTTP header fields.
        </t>
        <t>
          HTTP header field names are strings of ASCII characters that are compared in a
          case-insensitive fashion.  Header field names MUST be converted to lowercase prior to
          their encoding in HTTP/2.0.  A request or response containing uppercase header field names
          MUST be treated as <xref target="malformed">malformed</xref>.
        </t>
        <t>
          The semantics of HTTP header fields are not altered by this specification, though header
          fields relating to connection management or request framing are no longer necessary.  An
          HTTP/2.0 request or response MUST NOT include any of the following header fields:
          Connection, Keep-Alive, Proxy-Connection, TE, Transfer-Encoding, and Upgrade.  A request
          or response containing these header fields MUST be treated as <xref
          target="malformed">malformed</xref>.
          <list style="hanging">
            <t hangText="Note:">
              HTTP/2.0 purposefully does not support upgrade from HTTP/2.0 to another protocol.  The
              handshake methods described in <xref target="starting"/> are sufficient to negotiate
              the use of alternative protocols.
            </t>
          </list>
        </t>
        
        <section anchor="HttpRequest" title="Request Header Fields">
          <t>
            HTTP/2.0 defines a number of header fields starting with a colon ':' character that
            carry information about the request target:
            <list style="symbols">
              <x:lt>
                <t>
                  The <spanx style="verb">:method</spanx> header field includes the HTTP method
                  (<xref target="HTTP-p2" x:fmt="," x:rel="#methods"/>).
                </t>
              </x:lt>
              <x:lt>
                <t>
                  The <spanx style="verb">:scheme</spanx> header field includes the scheme portion
                  of the target URI (<xref target="RFC3986" x:fmt="," x:sec="3.1"/>).
                </t>
              </x:lt>
              <x:lt>
                <t>
                  The <spanx style="verb">:authority</spanx> header field includes the authority
                  portion of the target URI (<xref target="RFC3986" x:fmt="," x:sec="3.2"/>).
                </t>
                <t>
                  To ensure that the HTTP/1.1 request line can be reproduced accurately, this header
                  field MUST be omitted when translating from an HTTP/1.1 request that has a request
                  target in origin or asterisk form (see <xref target="HTTP-p1" x:fmt=","
                  x:rel="#request-target"/>).  Clients that generate HTTP/2.0 requests directly
                  SHOULD instead omit the <spanx style="verb">Host</spanx> header field.  An
                  intermediary that converts a request to HTTP/1.1 MUST create a <spanx
                      style="verb">Host</spanx> header field if one is not present in a request by
                  copying the value of the <spanx style="verb">:authority</spanx> header field.
                </t>
              </x:lt>
              <x:lt>
                <t>
                  The <spanx style="verb">:path</spanx> header field includes the path and query
                  parts of the target URI (the <spanx style="verb">path-absolute</spanx> production
                  from <xref target="RFC3986"/> and optionally a '?' character followed by the
                  <spanx style="verb">query</spanx> production, see <xref target="RFC3986" x:fmt=","
                  x:sec="3.3"/> and <xref target="RFC3986" x:fmt="," x:sec="3.4"/>).  This field
                  MUST NOT be empty; URIs that do not contain a path component MUST include a value
                  of '/', unless the request is an OPTIONS in asterisk form, in which case the
                  <spanx style="verb">:path</spanx> header field MUST include '*'.
                </t>
              </x:lt>
            </list>
            All HTTP/2.0 requests MUST include exactly one valid value for all of these header
            fields, unless this is a <xref target="CONNECT">CONNECT request</xref>.  An HTTP request
            that omits mandatory header fields is <xref target="malformed">malformed</xref>.
          </t>
          <t>
            Header field names that contain a colon are only valid in the HTTP/2.0 context.  These
            are not HTTP header fields.  Implementations MUST NOT generate header fields that start
            with a colon, but they MUST ignore any header field that starts with a colon.  In
            particular, header fields with names starting with a colon MUST NOT be exposed as HTTP
            header fields.
          </t>
          <t>
            HTTP/2.0 does not define a way to carry the version identifier that is included in the
            HTTP/1.1 request line.
          </t>
        </section>

        <section anchor="HttpResponse" title="Response Header Fields">
          <t>
            A single <spanx style="verb">:status</spanx> header field is defined that carries the
            HTTP status code field (see <xref target="HTTP-p2" x:fmt="," x:rel="#status.codes"/>).
            This header field MUST be included in all responses, otherwise the response is <xref
            target="malformed">malformed</xref>.
          </t>
          <t>
            HTTP/2.0 does not define a way to carry the version or reason phrase that is included in
            an HTTP/1.1 status line.
          </t>
        </section>

        <section anchor="malformed" title="Malformed Requests and Responses">
          <t>
            A malformed request or response is one that uses a valid sequence of HTTP/2.0 frames,
            but is otherwise invalid due to the presence of prohibited header fields, the absence of
            mandatory header fields, or the inclusion of uppercase header field names.
          </t>
          <t>
            A request or response that includes an entity body can include a <spanx
            style="verb">content-length</spanx> header field.  A request or response is also
            malformed if the value of a <spanx style="verb">content-length</spanx> header field does
            not equal the sum of the <x:ref>DATA</x:ref> frame payload lengths that form the body.
          </t>
          <t>
            Intermediaries that process HTTP requests or responses (i.e., all intermediaries other
            than those acting as tunnels) MUST NOT forward a malformed request or response.
          </t>
          <t>
            Implementations that detect malformed requests or responses need to ensure that the
            stream ends.  For malformed requests, a server MAY send an HTTP response to prior to
            closing or resetting the stream.  Clients MUST NOT accept a malformed response.
          </t>
        </section>
      </section>

      <section anchor="Reliability" title="Request Reliability Mechanisms in HTTP/2.0">
          <t>
            In HTTP/1.1, an HTTP client is unable to retry a non-idempotent request when an error
            occurs, because there is no means to determine the nature of the error.  It is possible
            that some server processing occurred prior to the error, which could result in
            undesirable effects if the request were reattempted.
          </t>
          <t>
            HTTP/2.0 provides two mechanisms for providing a guarantee to a client that a request
            has not been processed:
            <list style="symbols">
              <t>
                The <x:ref>GOAWAY</x:ref> frame indicates the highest stream number that might have
                been processed.  Requests on streams with higher numbers are therefore guaranteed to
                be safe to retry.
              </t>
              <t>
                The <x:ref>REFUSED_STREAM</x:ref> error code can be included in a
                <x:ref>RST_STREAM</x:ref> frame to indicate that the stream is being closed prior to
                any processing having occurred.  Any request that was sent on the reset stream can
                be safely retried.
              </t>
            </list>
          </t>
          <t>
            Clients MUST NOT treat requests that have not been processed as having failed.  Clients
            MAY automatically retry these requests, including those with non-idempotent methods.
          </t>
          <t>
            A server MUST NOT indicate that a stream has not been processed unless it can guarantee
            that fact.  If frames that are on a stream are passed to the application layer for any
            stream, then <x:ref>REFUSED_STREAM</x:ref> MUST NOT be used for that stream, and a
            <x:ref>GOAWAY</x:ref> frame MUST include a stream identifier that is greater than or
            equal to the given stream identifier.
          </t>
          <t>
            In addition to these mechanisms, the <x:ref>PING</x:ref> frame provides a way for a
            client to easily test a connection.  Connections that remain idle can become broken as
            some middleboxes (for instance, network address translators, or load balancers) silently
            discard connection bindings.  The <x:ref>PING</x:ref> frame allows a client to safely
            test whether a connection is still active without sending a request.
          </t>
        </section>
      </section>

      <section anchor="PushResources" title="Server Push">
        <t>
          HTTP/2.0 enables a server to pre-emptively send (or "push") multiple associated resources
          to a client in response to a single request.  This feature becomes particularly helpful
          when the server knows the client will need to have those resources available in order to
          fully process the originally requested resource.
        </t>
        
        <t>
          Pushing additional resources is optional, and is negotiated only between individual
          endpoints.  The <x:ref>SETTINGS_ENABLE_PUSH</x:ref> setting can be set to 0 to indicate
          that server push is disabled.  Even if enabled, an intermediary could receive pushed
          resources from the server but could choose not to forward those on to the client.  How to
          make use of the pushed resources is up to that intermediary.  Equally, the intermediary
          might choose to push additional resources to the client, without any action taken by the
          server.
        </t>
        <t>
          A server can only push requests that are safe (see <xref target="HTTP-p2" x:fmt=","
          x:rel="#safe.methods"/>), cacheable (see <xref target="HTTP-p6" x:fmt=","
          x:rel="#response.cacheability"/>) and do not include a request body.
        </t>

        <section title="Push Requests">
          <t>
            Server push is semantically equivalent to a server responding to a request. The
            <x:ref>PUSH_PROMISE</x:ref> frame, or frames, sent by the server includes a header block
            that contains a complete set of request header fields that the server attributes to
            the request.  It is not possible to push a response to a request that includes a
            request body.
          </t>
          
          <t>
            Pushed resources are always associated with an explicit request from a client.  The
            <x:ref>PUSH_PROMISE</x:ref> frames sent by the server are sent on the stream created for
            the original request.  The <x:ref>PUSH_PROMISE</x:ref> frame includes a promised stream
            identifier, chosen from the stream identifiers available to the server (see <xref
            target="StreamIdentifiers"/>).
          </t>

          <t>
            The header fields in <x:ref>PUSH_PROMISE</x:ref> and any subsequent
            <x:ref>CONTINUATION</x:ref> frames MUST be a valid and complete set of <xref
                target="HttpRequest">request header fields</xref>.  The server MUST include a
            method in the <spanx style="verb">:method</spanx> header field that is safe and
            cacheable.  If a client receives a <x:ref>PUSH_PROMISE</x:ref> that does not include a
            complete and valid set of header fields, or the <spanx style="verb">:method</spanx>
            header field identifies a method that is not safe, it MUST respond with a <xref
                target="StreamErrorHandler">stream error</xref> of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
          </t>

          <t>
            The server SHOULD send <x:ref>PUSH_PROMISE</x:ref> (<xref target="PUSH_PROMISE"/>) frames
            prior to sending any frames that reference
            the promised resources.  This avoids a race where clients issue requests for resources
            prior to receiving any <x:ref>PUSH_PROMISE</x:ref> frames.
          </t>
          <t>
            For example, if the server receives a request for a document containing embedded links to
            multiple image files, and the server chooses to push those additional images to the
            client, sending push promises before the <x:ref>DATA</x:ref> frames that contain the image
            links ensure that the client is able to see the promises before discovering the resources.
            Similarly, if the server pushes resources referenced by the header block (for instance, in
            Link header fields), sending the push promises before sending the header block ensures
            that clients do not request those resources.
          </t>
          
          <t>
            <x:ref>PUSH_PROMISE</x:ref> frames MUST NOT be sent by the client.
            <x:ref>PUSH_PROMISE</x:ref> frames can be sent by the server on any stream that was
            opened by the client.  They MUST be sent on a stream that is in either the "open" or
            "half closed (remote)" state to the server.  <x:ref>PUSH_PROMISE</x:ref> frames are
            interspersed with the frames that comprise a response, though they cannot be
            interspersed with <x:ref>HEADERS</x:ref> and <x:ref>CONTINUATION</x:ref> frames that
            comprise a single header block.
          </t>
        </section>
        
        <section title="Push Responses">
          <t>
            After sending the <x:ref>PUSH_PROMISE</x:ref> frame, the server can begin delivering the
            pushed resource as a <xref target="HttpResponse">response</xref> on a server-initiated
            stream that uses the promised stream identifier.  The server uses this stream to transmit
            an HTTP response, using the same sequence of frames as defined in <xref
            target="HttpSequence"/>.  This stream becomes <xref target="StreamStates">"half closed" to
            the client</xref> after the initial <x:ref>HEADERS</x:ref> frame is sent.
          </t>

          <t>
            Once a client receives a <x:ref>PUSH_PROMISE</x:ref> frame and chooses to accept the
            pushed resource, the client SHOULD NOT issue any requests for the promised resource until
            after the promised stream has closed.
          </t>
          
          <t>
            If the client determines, for any reason, that it does not wish to receive the pushed
            resource from the server, or if the server takes too long to begin sending the promised
            resource, the client can send an <x:ref>RST_STREAM</x:ref> frame, using either the
            <x:ref>CANCEL</x:ref> or <x:ref>REFUSED_STREAM</x:ref> codes, and referencing the pushed
            stream's identifier.
          </t>
          <t>
            A client can use the <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref> setting to limit the
            number of resources that can be concurrently pushed by a server.  Advertising a
            <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref> value of zero disables server push by
            preventing the server from creating the necessary streams.  This does not prohibit a
            server from sending PUSH_PROMISE frames; clients need to reset any promised streams that
            are not wanted.
          </t>

          <t>
            Clients receiving a pushed response MUST validate that the server is authorized to push
            the resource using the same-origin policy (<xref target="RFC6454" x:fmt="," x:sec="3"/>).
            For example, a HTTP/2.0 connection to <spanx style="verb">example.com</spanx> is generally
            <cref>Ed: weaselly use of "generally", needs better definition</cref> not permitted to
            push a response for <spanx style="verb">www.example.org</spanx>.
          </t>        
        </section>

      </section>

      <section anchor="CONNECT" title="The CONNECT Method">
        <t>
          The HTTP pseudo-method CONNECT (<xref target="HTTP-p2" x:fmt="," x:rel="#CONNECT"/>) is
          used to convert an HTTP/1.1 connection into a tunnel to a remote host.  CONNECT is
          primarily used with HTTP proxies to established a TLS session with a server for the
          purposes of interacting with <spanx style="verb">https</spanx> resources.
        </t>
        <t>
          In HTTP/2.0, the CONNECT method is used to establish a tunnel over a single HTTP/2.0
          stream to a remote host.  The HTTP header field mapping works as mostly as defined in
          <xref target="HttpRequest">Request Header Fields</xref>, with a few differences.
          Specifically:
          <list style="symbols">
              <t>
                The <spanx style="verb">:method</spanx> header field is set to <spanx
                style="verb">CONNECT</spanx>.
              </t>
              <t>
                The <spanx style="verb">:scheme</spanx> and <spanx style="verb">:path</spanx> header
                fields MUST be omitted.
              </t>
              <t>
                The <spanx style="verb">:authority</spanx> header field contains the host and port
                to connect to (equivalent to the authority-form of the request-target of CONNECT
                requests, see <xref target="HTTP-p1" x:fmt="," x:rel="#request-target"/>).
              </t>
          </list>
        </t>
        <t>
          A proxy that supports CONNECT, establishes a <xref target="TCP">TCP connection</xref> to
          the server identified in the <spanx style="verb">:path</spanx> header field.  Once this
          connection is successfully established, the proxy sends a <x:ref>HEADERS</x:ref> frame
          containing a 2xx series status code, as defined in <xref target="HTTP-p2" x:fmt=","
          x:rel="#CONNECT"/>.
        </t>
        <t>
          After the initial <x:ref>HEADERS</x:ref> frame sent by each peer, all subsequent
          <x:ref>DATA</x:ref> frames correspond to data sent on the TCP connection.  The payload of
          any <x:ref>DATA</x:ref> frames sent by the client are transmitted by the proxy to the TCP
          server; data received from the TCP server is assembled into <x:ref>DATA</x:ref> frames by
          the proxy.  Frame types other than <x:ref>DATA</x:ref> or stream management frames
          (<x:ref>RST_STREAM</x:ref>, <x:ref>WINDOW_UPDATE</x:ref>, and <x:ref>PRIORITY</x:ref>)
          MUST NOT be sent on a connected stream, and MUST be treated as a <xref
          target="StreamErrorHandler">stream error</xref> if received.
        </t>
        <t>
          The TCP connection can be closed by either peer.  The END_STREAM flag on a
          <x:ref>DATA</x:ref> frame is treated as being equivalent to the TCP FIN bit.  A client is
          expected to send a <x:ref>DATA</x:ref> frame with the END_STREAM flag set after receiving
          a frame bearing the END_STREAM flag.  A proxy that receives a <x:ref>DATA</x:ref> frame
          with the END_STREAM flag set sends the attached data with the FIN bit set on the last TCP
          segment.  A proxy that receives a TCP segment with the FIN bit set sends a
          <x:ref>DATA</x:ref> frame with the END_STREAM flag set.  Note that the final TCP segment
          or <x:ref>DATA</x:ref> frame could be empty.
        </t>
        <t>
          A TCP connection error is signaled with <x:ref>RST_STREAM</x:ref>.  A proxy treats any
          error in the TCP connection, which includes receiving a TCP segment with the RST bit set,
          as a <xref target="StreamErrorHandler">stream error</xref> of type
          <x:ref>CONNECT_ERROR</x:ref>.  Correspondingly, a proxy MUST send a TCP segment with the
          RST bit set if it detects an error with the stream or the HTTP/2.0 connection.
        </t>
      </section>
    </section>

    <section anchor="HttpExtra" title="Additional HTTP Requirements/Considerations">
      <t>
        This section outlines attributes of the HTTP protocol that improve interoperability, reduce
        exposure to known security vulnerabilities, or reduce the potential for implementation
        variation.
      </t>

      <section title="Connection Management">
        <t>
          HTTP/2.0 connections are persistent.  For best performance, it is expected clients will
          not close connections until it is determined that no further communication with a server
          is necessary (for example, when a user navigates away from a particular web page), or
          until the server closes the connection.
        </t>
        <t>
          Clients SHOULD NOT open more than one HTTP/2.0 connection to a given origin (<xref
          target="RFC6454"/>) concurrently.  A client can create additional connections as
          replacements, either to replace connections that are near to exhausting the available
          <xref target="StreamIdentifiers">stream identifiers</xref>, or to replace connections that
          have encountered <xref target="ConnectionErrorHandler">errors</xref>.
        </t>
        <t>
          Servers are encouraged to maintain open connections for as long as possible, but are
          permitted to terminate idle connections if necessary.  When either endpoint chooses to
          close the transport-level TCP connection, the terminating endpoint SHOULD first send a
          <x:ref>GOAWAY</x:ref> (<xref target="GOAWAY"/>) frame so that both endpoints can reliably
          determine whether previously sent frames have been processed and gracefully complete or
          terminate any necessary remaining tasks.
        </t>
      </section>

      <section title="Use of TLS Features">
        <t>
          Implementations of HTTP/2.0 MUST support <xref target="TLS11">TLS 1.1</xref>.  <cref>The
          working group intends to require at least the use of <xref target="TLS12">TLS 1.2</xref>
          prior to publication of this document; negotiating TLS 1.1 is permitted to enable the
          creation of interoperable implementations of early drafts.</cref>
        </t>
        <t>
          The TLS implementation MUST support the <xref target="TLS-EXT">Server Name Indication
          (SNI)</xref> extension to TLS. HTTP/2.0 clients MUST indicate the target domain name when
          negotiating TLS.
        </t>
        <t>
          A server that receives a TLS handshake that does not include either TLS 1.1 or SNI, MUST
          NOT negotiate HTTP/2.0.  Removing HTTP/2.0 protocols from consideration could result in
          the removal of all protocols from the set of protocols offered by the client.  This causes
          protocol negotiation failure, as described in <xref target="TLSALPN" x:fmt="of" x:sec="3.2"/>.
        </t>
        <t>
          Implementations are encouraged not to negotiate TLS cipher suites with known
          vulnerabilities, such as <xref target="RC4"/>.
        </t>
      </section>
      
      <section anchor="Compression" title="GZip Content-Encoding">
        <t>
          Clients MUST support gzip compression for HTTP response bodies.  Regardless of the value
          of the accept-encoding header field, a server MAY send responses with gzip or deflate
          encoding.  A compressed response MUST still bear an appropriate content-encoding header
          field.
        </t>
      </section>
    </section>

    <section anchor="security" title="Security Considerations">
      <section title="Server Authority and Same-Origin">
        <t>
          This specification uses the same-origin policy (<xref target="RFC6454" x:fmt=","
          x:sec="3"/>) to determine whether an origin server is permitted to provide content.
        </t>
        <t>
          A server that is contacted using TLS is authenticated based on the certificate that it
          offers in the TLS handshake (see <xref target="RFC2818" x:fmt="," x:sec="3"/>).  A server
          is considered authoritative for an "https" resource if it has been successfully
          authenticated for the domain part of the origin of the resource that it is providing.
        </t>
        <t>
          A server is considered authoritative for an "http" resource if the connection is
          established to a resolved IP address for the domain in the origin of the resource.
        </t>
        <t>
          A client MUST NOT use, in any way, resources provided by a server that is not
          authoritative for those resources.
        </t>
      </section>

      <section title="Cross-Protocol Attacks">
        <t>
          When using TLS, we believe that HTTP/2.0 introduces no new cross-protocol attacks.  TLS
          encrypts the contents of all transmission (except the handshake itself), making it
          difficult for attackers to control the data which could be used in a cross-protocol
          attack.  <cref>Issue: This is no longer true</cref>
        </t>
      </section>

      <section title="Intermediary Encapsulation Attacks">
        <t>
          HTTP/2.0 header field names and values are encoded as sequences of octets with a length
          prefix.  This enables HTTP/2.0 to carry any string of octets as the name or value of a
          header field.  An intermediary that translates HTTP/2.0 requests or responses into
          HTTP/1.1 directly could permit the creation of corrupted HTTP/1.1 messages.  An attacker
          might exploit this behavior to cause the intermediary to create HTTP/1.1 messages with
          illegal header fields, extra header fields, or even new messages that are entirely
          falsified.
        </t>
        <t>
          An intermediary that performs translation into HTTP/1.1 cannot alter the semantics of
          requests or responses.  In particular, header field names or values that contain
          characters not permitted by HTTP/1.1, including carriage return (U+000D) or line feed
          (U+000A) MUST NOT be translated verbatim, as stipulated in <xref target="HTTP-p1"
          x:rel="#field.parsing" x:fmt=","/>.
        </t>
        <t>
          Translation from HTTP/1.x to HTTP/2.0 does not produce the same opportunity to an
          attacker.  Intermediaries that perform translation to HTTP/2.0 MUST remove any instances
          of the <spanx style="verb">obs-fold</spanx> production from header field values.
        </t>
      </section>

      <section title="Cacheability of Pushed Resources">
        <t>
          Pushed resources are responses without an explicit request; the request for a pushed
          resource is synthesized from the request that triggered the push, plus resource
          identification information provided by the server.  Request header fields are necessary
          for HTTP cache control validations (such as the Vary header field) to work.  For this
          reason, caches MUST associate the request header fields from the PUSH_PROMISE frame
          with the response headers and content delivered on the pushed stream.  This includes
          the Cookie header field.
        </t>
        <t>
          Caching resources that are pushed is possible, based on the guidance provided by the
          origin server in the Cache-Control header field.  However, this can cause issues if a
          single server hosts more than one tenant.  For example, a server might offer multiple
          users each a small portion of its URI space.
        </t>
        <t>
          Where multiple tenants share space on the same server, that server MUST ensure that
          tenants are not able to push representations of resources that they do not have authority
          over.  Failure to enforce this would allow a tenant to provide a representation that would
          be served out of cache, overriding the actual representation that the authoritative tenant
          provides.
        </t>
        <t>
          Pushed resources for which an origin server is not authoritative are never cached or used.
        </t>
      </section>

      <section title="Denial of Service Considerations">
        <t>
          An HTTP/2.0 connection can demand a greater commitment of resources to operate than a
          HTTP/1.1 connection.  The use of header compression and flow control require that an
          implementation commit resources for storing a greater amount of state.  Settings for these
          features ensure that memory commitments for these features are strictly bounded.
          Processing capacity cannot be guarded in the same fashion.
        </t>
        <t>
          The <x:ref>SETTINGS</x:ref> frame can be abused to cause a peer to expend additional
          processing time.  This might be done by pointlessly changing settings, setting multiple
          undefined settings, or changing the same setting multiple times in the same frame.
          Similarly, <x:ref>WINDOW_UPDATE</x:ref> or <x:ref>PRIORITY</x:ref> frames can be
          abused to cause an unnecessary waste of resources.
        </t>
        <t>
          Large numbers of small or empty frames can be abused to cause a peer to expend time
          processing frame headers.  Note however that some uses are entirely legitimate, such as
          the sending of an empty <x:ref>DATA</x:ref> frame to end a stream.
        </t>
        <t>
          Header compression also offers some opportunities to waste processing resources, see <xref
          target="COMPRESSION"/> for more details on potential abuses.
        </t>
        <t>
          In all these cases, there are legitimate reasons to use these protocol mechanisms.  These
          features become a burden only when they are used unnecessarily or to excess.
        </t>
        <t>
          An endpoint that doesn't monitor this behavior exposes itself to a risk of denial of
          service attack.  Implementations SHOULD track the use of these types of frames and set
          limits on their use.  An endpoint MAY treat activity that is suspicious as a <xref
          target="ConnectionErrorHandler">connection error</xref> of type
          <x:ref>ENHANCE_YOUR_CALM</x:ref>.
        </t>
      </section>
    </section>

    <section title="Privacy Considerations">
        <t>
          HTTP/2.0 aims to keep connections open longer between clients and servers in order to
          reduce the latency when a user makes a request.  The maintenance of these connections over
          time could be used to expose private information.  For example, a user using a browser
          hours after the previous user stopped using that browser may be able to learn about what
          the previous user was doing.  This is a problem with HTTP in its current form as well,
          however the short lived connections make it less of a risk.
        </t>
    </section>

    <section anchor="iana" title="IANA Considerations">
      <t>
        A string for identifying HTTP/2.0 is entered into the "Application Layer Protocol
        Negotiation (ALPN) Protocol IDs" registry established in <xref target="TLSALPN"/>.
      </t>
      <t>
        This document establishes registries for frame types, error codes and settings.  These new
        registries are entered in a new "Hypertext Transfer Protocol (HTTP) 2.0 Parameters" section.
      </t>
      <t>
        This document registers the <spanx style="verb">HTTP2-Settings</spanx> header field for
        use in HTTP.
      </t>

      <section anchor="iana-alpn" title="Registration of HTTP/2.0 Identification String">
        <t>
          This document creates a registration for the identification of HTTP/2.0 in the
          "Application Layer Protocol Negotiation (ALPN) Protocol IDs" registry established in <xref
          target="TLSALPN"/>.
          <list style="hanging">
            <t hangText="Protocol:">HTTP/2.0</t>
            <t hangText="Identification Sequence:">0x48 0x54 0x54 0x50 0x2f 0x32 0x2e 0x30
            ("HTTP/2.0")</t>
            <t hangText="Specification:">This document (RFCXXXX)</t>
          </list>
        </t>
      </section>

      <section title="Frame Type Registry">
        <t>
          This document establishes a registry for HTTP/2.0 frame types.  The "HTTP/2.0 Frame Type"
          registry operates under the <xref target="RFC5226">"IETF Review" policy</xref>.
        </t>
        <t>
          Frame types are an 8-bit value.  When reviewing new frame type registrations, special
          attention is advised for any frame type-specific flags that are defined.  Frame flags can
          interact with existing flags and could prevent the creation of globally applicable flags.
        </t>
        <t>
          Initial values for the "HTTP/2.0 Frame Type" registry are shown in <xref
          target="IanaInitialFrameType"/>.
        </t>
        <texttable anchor="IanaInitialFrameType">
          <ttcol>Frame Type</ttcol><ttcol>Name</ttcol><ttcol>Flags</ttcol><ttcol>Section</ttcol>

          <c>0</c><c><x:ref>DATA</x:ref></c><c>END_STREAM(1)</c> <c><xref target="DATA"
          fmt="counter"/></c>
          
          <c>1</c><c><x:ref>HEADERS</x:ref></c><c>END_STREAM(1), END_HEADERS(4), PRIORITY(8)</c>
          <c><xref target="HEADERS" fmt="counter"/></c>

          <c>2</c><c><x:ref>PRIORITY</x:ref></c><c>-</c> <c><xref target="PRIORITY"
          fmt="counter"/></c>

          <c>3</c><c><x:ref>RST_STREAM</x:ref></c><c>-</c> <c><xref target="RST_STREAM"
          fmt="counter"/></c>

          <c>4</c><c><x:ref>SETTINGS</x:ref></c><c>ACK(1)</c> <c><xref target="SETTINGS"
          fmt="counter"/></c>

          <c>5</c><c><x:ref>PUSH_PROMISE</x:ref></c><c>END_PUSH_PROMISE(4)</c> <c><xref
          target="PUSH_PROMISE" fmt="counter"/></c>

          <c>6</c><c><x:ref>PING</x:ref></c><c>ACK(1)</c> <c><xref target="PING"
          fmt="counter"/></c>

          <c>7</c><c><x:ref>GOAWAY</x:ref></c><c>-</c> <c><xref target="GOAWAY" fmt="counter"/></c>

          <c>9</c><c><x:ref>WINDOW_UPDATE</x:ref></c><c>-</c> <c><xref target="WINDOW_UPDATE"
          fmt="counter"/></c>

          <c>10</c><c><x:ref>CONTINUATION</x:ref></c><c>END_HEADERS(4)</c>
          <c><xref target="CONTINUATION" fmt="counter"/></c>
        </texttable>
      </section>

      <section title="Error Code Registry">
        <t>
          This document establishes a registry for HTTP/2.0 error codes.  The "HTTP/2.0 Error Code"
          registry manages a 32-bit space.  The "HTTP/2.0 Error Code" registry operates under the
          <xref target="RFC5226">"Expert Review" policy</xref>.
        </t>
        <t>
          Registrations for error codes are required to include a description of the error code.  An
          expert reviewer is advised to examine new registrations for possible duplication with
          existing error codes.  Use of existing registrations is to be encouraged, but not
          mandated.
        </t>
        <t>
          New registrations are advised to provide the following information:
          <list style="hanging">
            <t hangText="Error Code:">
              The 32-bit error code value.
            </t>
            <t hangText="Name:">
              A name for the error code.  Specifying an error code name is optional.
            </t>
            <t hangText="Description:">
              A description of the conditions where the error code is applicable.
            </t>
            <t hangText="Specification:">
              An optional reference for a specification that defines the error code.
            </t>
          </list>
        </t>
        <t>
          An initial set of error code registrations can be found in <xref target="ErrorCodes"/>.
        </t>
      </section>

      <section title="Settings Registry">
        <t>
          This document establishes a registry for HTTP/2.0 settings.  The "HTTP/2.0 Settings"
          registry manages a 24-bit space.  The "HTTP/2.0 Settings" registry operates under the
          <xref target="RFC5226">"Expert Review" policy</xref>.
        </t>
        <t>
          Registrations for settings are required to include a description of the setting.  An
          expert reviewer is advised to examine new registrations for possible duplication with
          existing settings.  Use of existing registrations is to be encouraged, but not mandated.
        </t>
        <t>
          New registrations are advised to provide the following information:
          <list style="hanging">
            <t hangText="Setting:">
              The 24-bit setting value.
            </t>
            <t hangText="Name:">
              A name for the setting.  Specifying a name is optional.
            </t>
            <t hangText="Flags:">
              Any setting-specific flags that apply, including their value and semantics.
            </t>
            <t hangText="Description:">
              A description of the setting.  This might include the range of values, any applicable
              units and how to act upon a value when it is provided.
            </t>
            <t hangText="Specification:">
              An optional reference for a specification that defines the setting.
            </t>
          </list>
        </t>
        <t>
          An initial set of settings registrations can be found in <xref target="SettingValues"/>.
        </t>
      </section>

      <section title="HTTP2-Settings Header Field Registration">
        <t>
          This section registers the <spanx style="verb">HTTP2-Settings</spanx> header field in the
          <xref target="BCP90">Permanent Message Header Field Registry</xref>.
          <list style="hanging">
            <t hangText="Header field name:">
              HTTP2-Settings
            </t>
            <t hangText="Applicable protocol:">
              http
            </t>
            <t hangText="Status:">
              standard
            </t>
            <t hangText="Author/Change controller:">
              IETF
            </t>
            <t hangText="Specification document(s):">
              <xref target="Http2SettingsHeader"/> of this document
            </t>
            <t hangText="Related information:">
              This header field is only used by an HTTP/2.0 client for Upgrade-based negotiation.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Acknowledgements">
      <t>
        This document includes substantial input from the following individuals:
        <list style="symbols">
          <t>
            Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk, Costin
            Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam Barth, Ryan Hamilton, Gavin
            Peters, Kent Alstad, Kevin Lindsay, Paul Amer, Fan Yang, Jonathan Leighton (SPDY
            contributors).
          </t>
          <t>
            Gabriel Montenegro and Willy Tarreau (Upgrade mechanism)
          </t>
          <t>
            William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro, Jitu Padhye, Roberto
            Peon, Rob Trace (Flow control)
          </t>
          <t>
            Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner, Mike Bishop (Substantial
            editorial contributions)
          </t>
        </list>
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="COMPRESSION">
        <front>
          <title>HPACK - Header Compression for HTTP/2.0</title>
          <author initials="H." surname="Ruellan" fullname="Herve Ruellan"/>
          <author initials="R." surname="Peon" fullname="Roberto Peon"/>
          <date month="October" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-header-compression-04" />
      </reference>

      <reference anchor="TCP">
        <front>
          <title abbrev="Transmission Control Protocol">
            Transmission Control Protocol
          </title>
          <author initials="J." surname="Postel" fullname="Jon Postel">
            <organization>University of Southern California (USC)/Information Sciences
            Institute</organization>
          </author>
          <date year="1981" month="September" />
        </front>
        <seriesInfo name="STD" value="7" />
        <seriesInfo name="RFC" value="793" />
      </reference>

      <reference anchor="RFC2119">
        <front>
          <title>
            Key words for use in RFCs to Indicate Requirement Levels
          </title>
          <author initials="S." surname="Bradner" fullname="Scott Bradner">
            <organization>Harvard University</organization>
            <address><email>sob@harvard.edu</email></address>
          </author>
          <date month="March" year="1997"/>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
      </reference>

     <reference anchor="RFC2818">
        <front>
          <title>
            HTTP Over TLS
          </title>
          <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
            <organization/>
          </author>
          <date month="May" year="2000"/>
        </front>
        <seriesInfo name="RFC" value="2818"/>
      </reference>

      <reference anchor="RFC3986">
        <front>
          <title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic
          Syntax</title>
          <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee"></author>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding"></author>
          <author initials="L." surname="Masinter" fullname="Larry Masinter"></author>
          <date year="2005" month="January" />
        </front>
        <seriesInfo name="STD" value="66" />
        <seriesInfo name="RFC" value="3986" />
      </reference>

      <reference anchor="TLS11">
        <front>
          <title>The Transport Layer Security (TLS) Protocol Version 1.1</title>
          <author initials="T." surname="Dierks" fullname="Tim Dierks"/>
          <author initials="E." surname="Rescorla" fullname="Eric Rescorla"/>
          <date year="2006" month="April" />
        </front>
        <seriesInfo name="RFC" value="4346" />
      </reference>

      <reference anchor="RFC4648">
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author fullname="S. Josefsson" initials="S." surname="Josefsson"/>
          <date year="2006" month="October"/>
        </front>
        <seriesInfo value="4648" name="RFC"/>
      </reference>
      
      <reference anchor="RFC5226">
        <front>
          <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
          <author initials="T." surname="Narten" fullname="T. Narten">
          <organization /></author>
          <author initials="H." surname="Alvestrand" fullname="H. Alvestrand">
          <organization /></author>
          <date year="2008" month="May" />
        </front>
        <seriesInfo name="BCP" value="26" />
        <seriesInfo name="RFC" value="5226" />
      </reference>

      <reference anchor="RFC5234">
        <front>
          <title>Augmented BNF for Syntax Specifications: ABNF</title>
          <author initials="D." surname="Crocker" fullname="D. Crocker"/>
          <author initials="P." surname="Overell" fullname="P. Overell"/>
          <date year="2008" month="January" />
        </front>
        <seriesInfo name="STD" value="68" />
        <seriesInfo name="RFC" value="5234" />
      </reference>

      <reference anchor="TLS12">
        <front>
          <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
          <author initials="T." surname="Dierks" fullname="Tim Dierks"/>
          <author initials="E." surname="Rescorla" fullname="Eric Rescorla"/>
          <date year="2008" month="August" />
        </front>
        <seriesInfo name="RFC" value="5246" />
      </reference>

      <reference anchor="TLS-EXT">
        <front>
          <title>
            Transport Layer Security (TLS) Extensions: Extension Definitions
          </title>
          <author initials="D." surname="Eastlake" fullname="D. Eastlake">
            <organization/>
          </author>
          <date year="2011" month="January"/>
        </front>
        <seriesInfo name="RFC" value="6066"/>
      </reference>

      <reference anchor="RFC6454">
        <front>
          <title>The Web Origin Concept</title>
          <author initials="A." surname="Barth" fullname="A. Barth"/>
          <date year="2011" month="December" />
        </front>
        <seriesInfo name="RFC" value="6454" />
      </reference>

      <reference anchor="TLSALPN">
        <front>
          <title>Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension</title>
          <author initials="S.F." surname="Friedl" fullname="Stephan Friedl"></author>
          <author initials="A." surname="Popov" fullname="Andrei Popov"></author>
          <author initials="A." surname="Langley" fullname="Adam Langley"></author>
          <author initials="E." surname="Stephan" fullname="Emile Stephan"></author>
          <date month="September" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-tls-applayerprotoneg-02" />
      </reference>

      <reference anchor="HTTP-p1">
        <front>
          <title>
          Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
          <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="September" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-24" />
        <x:source href="refs/draft-ietf-httpbis-p1-messaging-24.xml"
                  basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p1-messaging"/>
      </reference>
      <reference anchor="HTTP-p2">
        <front>
          <title>
          Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
          <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="September" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-24" />
        <x:source href="refs/draft-ietf-httpbis-p2-semantics-24.xml"
                  basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p2-semantics"/>
      </reference>
      <reference anchor="HTTP-p4">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
          <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="September" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-24" />
      </reference>
      <reference anchor="HTTP-p5">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
            <organization abbrev="W3C">World Wide Web Consortium</organization>
            <address><email>ylafon@w3.org</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="September" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-24"/>
      </reference>
      <reference anchor="HTTP-p6">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author fullname="Mark Nottingham" initials="M." role="editor" surname="Nottingham">
            <organization>Akamai</organization>
            <address><email>mnot@mnot.net</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="September" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-24"/>
        <x:source href="refs/draft-ietf-httpbis-p6-cache-24.xml" 
                  basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p6-cache"/>
      </reference>
      <reference anchor="HTTP-p7">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="September" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p7-auth-24"/>
        <x:source href="refs/draft-ietf-httpbis-p7-auth-24.xml" 
                  basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/24/p7-auth"/>
      </reference>
    </references>

    <references title="Informative References">
      <reference anchor="RFC1323">
        <front>
          <title>
            TCP Extensions for High Performance
          </title>
          <author initials="V." surname="Jacobson" fullname="Van Jacobson"></author>
          <author initials="B." surname="Braden" fullname="Bob Braden"></author>
          <author initials="D." surname="Borman" fullname="Dave Borman"></author>
          <date year="1992" month="May" />
        </front>
        <seriesInfo name="RFC" value="1323" />
      </reference>
      <reference anchor="TALKING" target="http://w2spconf.com/2011/papers/websocket.pdf">
        <front>
          <title>
            Talking to Yourself for Fun and Profit
          </title>
          <author initials="L-S." surname="Huang"/>
          <author initials="E." surname="Chen"/>
          <author initials="A." surname="Barth"/>
          <author initials="E." surname="Rescorla"/>
          <author initials="C." surname="Jackson"/>
          <date year="2011" />
        </front>
      </reference>
      <reference anchor="RC4">
        <front>
          <title>
            The RC4 encryption algorithm
          </title>
          <author initials="R." surname="Rivest" fullname="Ron Rivest"></author>
          <date year="1992" month="March" />
        </front>
        <seriesInfo name="RSA Data Security, Inc." value="" />
      </reference>

      <reference anchor="BCP90">
        <front>
          <title>Registration Procedures for Message Header Fields</title>
          <author initials="G." surname="Klyne" fullname="G. Klyne">
            <organization>Nine by Nine</organization>
            <address><email>GK-IETF@ninebynine.org</email></address>
          </author>
          <author initials="M." surname="Nottingham" fullname="M. Nottingham">
            <organization>BEA Systems</organization>
            <address><email>mnot@pobox.com</email></address>
          </author>
          <author initials="J." surname="Mogul" fullname="J. Mogul">
            <organization>HP Labs</organization>
            <address><email>JeffMogul@acm.org</email></address>
          </author>
          <date year="2004" month="September" />
        </front>
        <seriesInfo name="BCP" value="90" />
        <seriesInfo name="RFC" value="3864" />
      </reference>
    </references>

    <section title="Change Log (to be removed by RFC Editor before publication)" anchor="change.log">

      <section title="Since draft-ietf-httpbis-http2-07" anchor="changes.since.draft-ietf-httpbis-http2-07">
        <t>
          Marked draft for implementation.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-06" anchor="changes.since.draft-ietf-httpbis-http2-06">
        <t>
          Adding definition for CONNECT method.
        </t>
        <t>
          Constraining the use of push to safe, cacheable methods with no request body.
        </t>
        <t>
          Changing from :host to :authority to remove any potential confusion.
        </t>
        <t>
          Adding setting for header compression table size.
        </t>
        <t>
          Adding settings acknowledgement.
        </t>
        <t>
          Removing unnecessary and potentially problematic flags from CONTINUATION.
        </t>
        <t>
          Added denial of service considerations.
        </t>
      </section>
      <section title="Since draft-ietf-httpbis-http2-05" anchor="changes.since.draft-ietf-httpbis-http2-05">
        <t>
          Marking the draft ready for implementation.
        </t>
        <t>
          Renumbering END_PUSH_PROMISE flag.
        </t>
        <t>
          Editorial clarifications and changes.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-04" anchor="changes.since.draft-ietf-httpbis-http2-04">
        <t>
          Added CONTINUATION frame for HEADERS and PUSH_PROMISE.
        </t>
        <t>
          PUSH_PROMISE is no longer implicitly prohibited if SETTINGS_MAX_CONCURRENT_STREAMS is
          zero.
        </t>
        <t>
          Push expanded to allow all safe methods without a request body.
        </t>
        <t>
          Clarified the use of HTTP header fields in requests and responses.  Prohibited HTTP/1.1
          hop-by-hop header fields.
        </t>
        <t>
          Requiring that intermediaries not forward requests with missing or illegal routing
          :-headers.
        </t>
        <t>
          Clarified requirements around handling different frames after stream close, stream reset
          and <x:ref>GOAWAY</x:ref>.
        </t>
        <t>
          Added more specific prohibitions for sending of different frame types in various stream
          states.
        </t>
        <t>
          Making the last received setting value the effective value.
        </t>
        <t>
          Clarified requirements on TLS version, extension and ciphers.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-03" anchor="changes.since.draft-ietf-httpbis-http2-03">
        <t>
          Committed major restructuring atrocities.
        </t>
        <t>
          Added reference to first header compression draft.
        </t>
        <t>
          Added more formal description of frame lifecycle.
        </t>
        <t>
          Moved END_STREAM (renamed from FINAL) back to <x:ref>HEADERS</x:ref>/<x:ref>DATA</x:ref>.
        </t>
        <t>
          Removed HEADERS+PRIORITY, added optional priority to <x:ref>HEADERS</x:ref> frame.
        </t>
        <t>
          Added <x:ref>PRIORITY</x:ref> frame.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-02" anchor="changes.since.draft-ietf-httpbis-http2-02">
        <t>
          Added continuations to frames carrying header blocks.
        </t>
        <t>
          Replaced use of "session" with "connection" to avoid confusion with other HTTP stateful
          concepts, like cookies.
        </t>
        <t>
          Removed "message".
        </t>
        <t>
          Switched to TLS ALPN from NPN.
        </t>
        <t>
          Editorial changes.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-01" anchor="changes.since.draft-ietf-httpbis-http2-01">
        <t>
          Added IANA considerations section for frame types, error codes and settings.
        </t>
        <t>
          Removed data frame compression.
        </t>
        <t>
          Added <x:ref>PUSH_PROMISE</x:ref>.
        </t>
        <t>
          Added globally applicable flags to framing.
        </t>
        <t>
          Removed zlib-based header compression mechanism.
        </t>
        <t>
          Updated references.
        </t>
        <t>
          Clarified stream identifier reuse.
        </t>
        <t>
          Removed CREDENTIALS frame and associated mechanisms.
        </t>
        <t>
          Added advice against naive implementation of flow control.
        </t>
        <t>
          Added session header section.
        </t>
        <t>
          Restructured frame header.  Removed distinction between data and control frames.
        </t>
        <t>
          Altered flow control properties to include session-level limits.
        </t>
        <t>
          Added note on cacheability of pushed resources and multiple tenant servers.
        </t>
        <t>
          Changed protocol label form based on discussions.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-00" anchor="changes.since.draft-ietf-httpbis-http2-00">
        <t>
          Changed title throughout.
        </t>
        <t>
          Removed section on Incompatibilities with SPDY draft#2.
        </t>
        <t>
          Changed <x:ref>INTERNAL_ERROR</x:ref> on <x:ref>GOAWAY</x:ref> to have a value of 2 <eref
          target="https://groups.google.com/forum/?fromgroups#!topic/spdy-dev/cfUef2gL3iU"/>.
        </t>
        <t>
          Replaced abstract and introduction.
        </t>
        <t>
          Added section on starting HTTP/2.0, including upgrade mechanism.
        </t>
        <t>
          Removed unused references.
        </t>
        <t>
          Added <xref target="fc-principles">flow control principles</xref> based on <eref
          target="http://tools.ietf.org/html/draft-montenegro-httpbis-http2-fc-principles-01"/>.
        </t>
      </section>

      <section title="Since draft-mbelshe-httpbis-spdy-00" anchor="changes.since.draft-mbelshe-httpbis-spdy-00">
        <t>
          Adopted as base for draft-ietf-httpbis-http2.
        </t>
        <t>
          Updated authors/editors list.
        </t>
        <t>
          Added status note.
        </t>
      </section>
    </section>

  </back>
</rfc>
<!--
  vim:et:tw=100:sw=2:
  -->
