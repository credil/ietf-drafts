<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY OASIS.saml-core-2.0-os PUBLIC "" "http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml">
<!ENTITY W3C.CR-xml11-20021015 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-xml11-20021015.xml">
<!ENTITY RFC2045 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY RFC3275 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3275.xml">
<!ENTITY RFC3339 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
<!ENTITY RFC3629 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml">
<!ENTITY RFC3986 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4122 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4122.xml">
<!ENTITY RFC4627 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC4648 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC5226 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
]>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-jones-json-web-token-07"
     ipr="trust200902">
  <front>
    <title>JSON Web Token (JWT)</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
      <organization>Google</organization>
      <address>
	<email>balfanz@google.com</email>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>independent</organization>
      <address>
	<email>ve7jtb@ve7jtb.com</email>
      </address>
    </author>

    <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland">
      <organization>Microsoft</organization>
      <address>
	<email>yarong@microsoft.com</email>
      </address>
    </author>

    <author fullname="John Panzer" initials="J." surname="Panzer">
      <organization>Google</organization>
      <address>
	<email>jpanzer@google.com</email>
      </address>
    </author>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>Nomura Research Institute</organization>
      <address>
	<email>n-sakimura@nri.co.jp</email>
      </address>
    </author>

    <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
      <organization>Facebook</organization>
      <address>
	<email>pt@fb.com</email>
      </address>
    </author>

    <date day="13" month="December" year="2011" />

    <area>Security</area>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>Assertion</keyword>
    <keyword>Claim</keyword>
    <keyword>Simple Web Token</keyword>
    <keyword>Security Token</keyword>
    <keyword>SWT</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>JSON Web Signature</keyword>
    <keyword>JWS</keyword>
    <keyword>JSON Web Encryption</keyword>
    <keyword>JWE</keyword>

    <abstract>
      <t>
	JSON Web Token (JWT) is a means of representing claims to be
	transferred between two parties.  The claims in a JWT are
	encoded as a JSON object that is digitally signed using JSON
	Web Signature (JWS) and/or encrypted using JSON Web Encryption
	(JWE).
      </t>
      <t>
        The suggested pronunciation of JWT is the same as the English
        word "jot".
      </t>
    </abstract>

    <note title="Requirements Language">
      <t>
	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
	NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
	"OPTIONAL" in this document are to be interpreted as described
	in <xref target="RFC2119">RFC 2119</xref>.
      </t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	JSON Web Token (JWT) is a compact token format intended for
	space constrained environments such as HTTP Authorization
	headers and URI query parameters. JWTs encode claims to be
	transmitted as a JSON object (as defined in <xref
	target="RFC4627">RFC 4627</xref>) that is base64url encoded
	and digitally signed and/or encrypted.  Signing is
	accomplished using JSON Web Signature (JWS) <xref target="JWS"
	/>.  Encryption is accomplished using JSON Web Encryption
	(JWE) <xref target="JWE" />.
      </t>
      <t>
        The suggested pronunciation of JWT is the same as the English
        word "jot".
      </t>
    </section>

    <section title="Terminology">
      <t>
	<list style="hanging">

          <t hangText="JSON Web Token (JWT)">
	    A string consisting of three parts: the Encoded JWT Header, the
	    JWT Second Part, and the JWT Third Part, in that order,
	    with the parts being separated by period ('.') characters,
	    and each part containing base64url encoded content.
	  </t>

          <t hangText="JWT Header">
	    A string representing a JSON object that
	    describes the cryptographic operations applied to the JWT.
	    When the JWT is signed, the JWT Header is the JWS Header.
	    When the JWT is encrypted, the JWT Header is the JWE Header.
	  </t>

	  <t hangText="Header Parameter Names">
	    The names of the members within the JWT Header.
	  </t>
	  <t hangText="Header Parameter Values">
	    The values of the members within the JWT Header.
	  </t>

          <t hangText="JWT Second Part">
	    When the JWT is signed, the JWT Second Part is the Encoded JWS Payload.
	    When the JWT is encrypted, the JWT Second Part is the Encoded JWE Encrypted Key.
	  </t>
          <t hangText="JWT Third Part">
	    When the JWT is signed, the JWT Third Part is the Encoded JWS Signature.
	    When the JWT is encrypted, the JWT Third Part is the Encoded JWE Ciphertext.
	  </t>

          <t hangText="JWT Claims Set">
	    A string representing a JSON object that
	    contains the claims conveyed by the JWT.
	    When the JWT is signed, the bytes of the UTF-8 representation of the
	    JWT Claims Set are base64url encoded to create the Encoded JWS Payload.
	    When the JWT is encrypted, the bytes of the UTF-8 representation of the
	    JWT Claims Set are used as the JWE Plaintext.
	  </t>

	  <t hangText="Claim Names">
	    The names of the members of the JSON object represented by
	    the JWT Claims Set.
	  </t>
	  <t hangText="Claim Values">
	    The values of the members of the JSON object represented by
	    the JWT Claims Set.
	  </t>

          <t hangText="Encoded JWT Header">
	    Base64url encoding of the bytes of the
	    UTF-8 <xref target="RFC3629">RFC 3629</xref>
	    representation of the JWT Header.
	  </t>

          <t hangText="Base64url Encoding">
	    For the purposes of this specification, this term always
	    refers to the URL- and filename-safe Base64 encoding
	    described in <xref target="RFC4648">RFC 4648</xref>,
	    Section 5, with the (non URL-safe) '=' padding characters
	    omitted, as permitted by Section 3.2.  (See Appendix C of
	    <xref target="JWS" /> for notes on implementing base64url
	    encoding without padding.)
	  </t>
        </list>
      </t>
    </section>

    <section title="JSON Web Token (JWT) Overview">

      <t>
	JWTs represent a set of claims as a JSON object that is
	base64url encoded and digitally signed and/or
	encrypted.  The JWT Claims Set represents this JSON object.
	As per <xref target="RFC4627">RFC 4627</xref>
	Section 2.2, the JSON object consists of zero or more
	name/value pairs (or members), where the names are strings and
	the values are arbitrary JSON values.  These members are the
	claims represented by the JWT.
      </t>
      <t>
	The member names within the JWT Claims Set are
	referred to as Claim Names.  The
	corresponding values are referred to as Claim Values.
      </t>
      <t>
	The bytes of the UTF-8 representation of the JWT Claims Set
	are signed in the manner described in JSON Web Signature (JWS)
	<xref target="JWS" /> and/or encrypted in the manner described
	in JSON Web Encryption (JWE) <xref target="JWE" />.
      </t>
      <t>
	The contents of the JWT Header describe the cryptographic
	operations applied to the JWT Claims Set.
	If the JWT Header is a JWS Header, the claims are signed.
	If the JWT Header is a JWE Header, the claims are encrypted.
      </t>
      <t>
	A JWT is represented as the concatenation of the Encoded JWT Header,
	the JWT Second Part, and the JWT Third Part, in that order,
	with the parts being separated by period ('.') characters.
	When signed, the three parts of the JWT are the three parts of
	a JWS used to represent the JWT.  When encrypted, the three
	parts of the JWT are the three parts of a JWE used to
	represent the JWT.
      </t>

      <section title="Example JWT" anchor="ExampleJWT">

	<t>
	  The following example JWT Header declares that the
	  encoded object is a JSON Web Token (JWT) and the JWT is
	  signed using the HMAC SHA-256 algorithm:
	</t>

	<figure><artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork></figure>

	<t>
	  Base64url encoding the bytes of the UTF-8 representation of
	  the JWT Header yields this Encoded JWS Header value,
	  which is used as the Encoded JWT Header:
	</t>

	<figure><artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork></figure>

	<t>
	  The following is an example of a JWT Claims Set:
	</t>

	<figure><artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork></figure>

	<t>
	  Base64url encoding the bytes of the UTF-8 representation of
	  the JSON Claims Set yields this Encoded JWS Payload,
	  which is used as the JWT Second Part
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly
9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	<t>
	  Signing the Encoded JWS Header and Encoded JWS Payload with
	  the HMAC SHA-256 algorithm and base64url encoding the
	  signature in the manner specified in <xref target="JWS" />,
	  yields this Encoded JWS Signature, which is used as the JWT
	  Third Part:
	</t>

	<figure><artwork><![CDATA[dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork></figure>

	<t>
	  Concatenating these parts in the order
	  Header.Second.Third with period characters between the
	  parts yields this complete JWT (with line breaks for
	  display purposes only):
	</t>

	<figure><artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork></figure>

	<t>
	  This computation is illustrated in more detail in <xref
	  target="JWS" />, Appendix A.1.
	</t>

      </section>

    </section>

    <section title="JWT Claims">

      <t>
	The JWT Claims Set represents a JSON object whose members
	are the claims conveyed by the JWT.
	The Claim Names within this object MUST be unique.
	Note however, that the set of claims that a
	JWT must contain to be considered valid is context-dependent
	and is outside the scope of this specification.  When used in
	a security-related context, implementations MUST understand
	and support all of the claims present; otherwise, the JWT MUST
	be rejected for processing.
      </t>

      <t>
        There are three classes of JWT Claim Names: Reserved Claim
        Names, Public Claim Names, and Private Claim Names.
      </t>

      <section title="Reserved Claim Names" anchor="ReservedClaimName">
	<t>
	  The following claim names are reserved. None of the claims
	  defined in the table below are intended to be mandatory, but
	  rather, provide a starting point for a set of useful,
	  interoperable claims.  All the names are short because a
	  core goal of JWTs is for the tokens to be compact.
	</t>

	<texttable title="Reserved Claim Definitions" anchor="ClaimTable">

	  <ttcol align="left">Claim Name</ttcol>
	  <ttcol align="left">JSON Value Type</ttcol>
	  <ttcol align="left">Claim Syntax</ttcol>
	  <ttcol align="left">Claim Semantics</ttcol>

	  <c>exp</c>
	  <c>number</c>
	  <c>IntDate</c>
	  <c>
	    The <spanx style="verb">exp</spanx> (expiration time)
	    claim identifies the expiration time on or after which the
	    token MUST NOT be accepted for processing.  The processing
	    of the <spanx style="verb">exp</spanx> claim requires that
	    the current date/time MUST be before the expiration
	    date/time listed in the <spanx style="verb">exp</spanx>
	    claim. Implementers MAY provide for some small leeway,
	    usually no more than a few minutes, to account for clock
	    skew.  This claim is OPTIONAL.
	  </c>

	  <c>nbf</c>
	  <c>number</c>
	  <c>IntDate</c>
	  <c>
	    The <spanx style="verb">nbf</spanx> (not before) claim
	    identifies the time before which the token MUST NOT be
	    accepted for processing.  The processing of the <spanx
	    style="verb">nbf</spanx> claim requires that the current
	    date/time MUST be after or equal to the not-before
	    date/time listed in the <spanx style="verb">nbf</spanx>
	    claim. Implementers MAY provide for some small leeway,
	    usually no more than a few minutes, to account for clock
	    skew.  This claim is OPTIONAL.
	  </c>

	  <c>iat</c>
	  <c>number</c>
	  <c>IntDate</c>
	  <c>
	    The <spanx style="verb">iat</spanx> (issued at) claim
	    identifies the time at which the JWT was issued.  This
	    claim can be used to determine the age of the token.
	    This claim is OPTIONAL.
	  </c>

	  <c>iss</c>
	  <c>string</c>
	  <c>StringOrURI</c>
	  <c>
	    The <spanx style="verb">iss</spanx> (issuer) claim
	    identifies the principal that issued the JWT.  The
	    processing of this claim is generally application
	    specific.
	    The <spanx style="verb">iss</spanx> value is case sensitive.
	    This claim is OPTIONAL.
	  </c>

	  <c>aud</c>
	  <c>string</c>
	  <c>StringOrURI</c>
	  <c>
	    The <spanx style="verb">aud</spanx> (audience) claim
	    identifies the audience that the JWT is intended for.  The
	    principal intended to process the JWT MUST be identified
	    with the value of the audience claim. If the principal
	    processing the claim does not identify itself with the
	    identifier in the <spanx style="verb">aud</spanx> claim
	    value then the JWT MUST be rejected.  The interpretation
	    of the audience value is generally
	    application specific.
	    The <spanx style="verb">aud</spanx> value is case sensitive.
	    This claim is OPTIONAL.
	  </c>

	  <c>prn</c>
	  <c>string</c>
	  <c>StringOrURI</c>
	  <c>
	    The <spanx style="verb">prn</spanx> (principal) claim
	    identifies the subject of the JWT.  The processing of this
	    claim is generally application specific.
	    The <spanx style="verb">prn</spanx> value is case sensitive.
	    This claim is OPTIONAL.
	  </c>

	  <c>jti</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">jti</spanx> (JWT ID) claim
	    provides a unique identifier for the JWT.  The identifier
	    value MUST be assigned in a manner that ensures that there
	    is a negligible probability that the same value will be
	    accidentally assigned to a different data object.  The
	    <spanx style="verb">jti</spanx> claim can be used to
	    prevent the JWT from being replayed.
	    The <spanx style="verb">jti</spanx> value is case sensitive.
	    This claim is OPTIONAL.
	  </c>

	  <c>typ</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">typ</spanx> (type) claim is used
	    to declare a type for the contents of this JWT Claims Set.
	    The <spanx style="verb">typ</spanx> value is case sensitive.
	    This claim is OPTIONAL.
	  </c>

	</texttable>

	<t>
	  Additional reserved claim names MAY be defined via the IANA
	  JSON Web Token Claims registry, as per <xref target="IANA"
	  />.  The syntax values used above are defined as follows:
	</t>

	<texttable title="Claim Syntax Definitions" anchor="SyntaxDefinitions">
	  <ttcol align="left">Syntax Name</ttcol>
	  <ttcol align="left">Syntax Definition</ttcol>

	  <c>IntDate</c>
	  <c>
	    The number of seconds from 1970-01-01T0:0:0Z as measured
	    in UTC until the desired date/time. See <xref
	    target="RFC3339">RFC 3339</xref> for details regarding
	    date/times in general and UTC in particular.
	  </c>

	  <c>String</c>
	  <c>
	    Any string value MAY be used.
	  </c>

	  <c>StringOrURI</c>
	  <c>
	    Any string value MAY be used but a value containing a ":"
	    character MUST be a URI as defined in <xref
	    target="RFC3986">RFC 3986</xref>.
	  </c>

	</texttable>

      </section>

      <section title="Public Claim Names" anchor="PublicClaimName">

        <t>
	  Claim names can be defined at will by those using
	  JWTs. However, in order to prevent collisions, any new claim
	  name SHOULD either be defined in the IANA JSON Web Token
	  Claims registry or be defined as a URI that contains a
	  collision resistant namespace. Examples of collision
	  resistant namespaces include:

          <list style="symbols">
            <t>
	      Domain Names,
	    </t>
            <t>
	      Object Identifiers (OIDs) as defined in the ITU-T X.660
	      and X.670 Recommendation series, or
	    </t>
            <t>
	      Universally Unique IDentifier (UUID) as defined in <xref
	      target="RFC4122">RFC 4122</xref>.
	    </t>
          </list>

          In each case, the definer of the name or value needs to take
          reasonable precautions to make sure they are in control of
          the part of the namespace they use to define the claim
          name.</t>
      </section>

      <section title="Private Claim Names" anchor="PrivateClaimName">

         <t>
	   A producer and consumer of a JWT may agree to any claim
	   name that is not a Reserved Name <xref
	   target="ReservedClaimName"></xref> or a Public Name <xref
	   target="PublicClaimName"></xref>. Unlike Public Names,
	   these private names are subject to collision and should be
	   used with caution.
	 </t>

      </section>
    </section>

    <section title="JWT Header">

      <t>
	The members of the JSON object represented by the JWT Header
	describe the cryptographic operations applied to the JWT and
	optionally, additional properties of the JWT.
	The member names within the JWT Header are
	referred to as Header Parameter Names.  These names MUST be
	unique.  The corresponding values are referred to as Header
	Parameter Values.
      </t>
      <t>
	Implementations MUST understand the entire contents of the
	header; otherwise, the JWT MUST be rejected for processing.
      </t>
      <t>
	There are two ways of distinguishing whether the JWT is a JWS
	or JWE.  The first is by examining the <spanx
	style="verb">alg</spanx> (algorithm) header value.  If the
	value represents a signature algorithm, the JWT is a JWS; if
	it represents an encryption algorithm, the JWT is a JWE.  A
	second method is determining whether an <spanx
	style="verb">enc</spanx> (encryption method) member exists.
	If the <spanx style="verb">enc</spanx> member exists, the JWT
	is a JWE; otherwise, the JWT is a JWS.  Both methods will
	yield the same result.
      </t>
      <t>
	JWS Header Parameters are defined by <xref target="JWS" />.
	JWE Header Parameters are defined by <xref target="JWE" />.
	This specification further specifies the use of the following
	header parameters in both the cases where the JWT is a JWS and
	where it is a JWE.
      </t>

      <texttable title="Reserved Header Parameter Usage" anchor="HeaderParameterTable">

	<ttcol align="left">Header Parameter Name</ttcol>
	<ttcol align="left">JSON Value Type</ttcol>
	<ttcol align="left">Header Parameter Syntax</ttcol>
	<ttcol align="left">Header Parameter Semantics</ttcol>

	<c>typ</c>
	<c>string</c>
	<c>String</c>
	<c>
	  The <spanx style="verb">typ</spanx> (type) header parameter
	  is used to declare structural information about the JWT.
	  In the normal case where nested signing or encryption
	  operations are not employed, the use of this header
	  parameter is OPTIONAL, and if present, it is RECOMMENDED that
	  its value be either "JWT" or
	  "http://openid.net/specs/jwt/1.0".
	  In the case that nested signing or encryption steps are
	  employed, the use of this header parameter is REQUIRED; in
	  this case, the value MUST either be "JWS", to indicate that
	  a nested signed JWT is carried in this JWT or "JWE", to
	  indicate that a nested encrypted JWT is carried in this JWT.
	</c>

      </texttable>

    </section>

    <section title="Plaintext JWTs" anchor="Plaintext">

      <t>
	To support use cases where the JWT content is secured by a
	means other than a signature and/or encryption contained
	within the token (such as a signature on a data structure
	containing the token), JWTs MAY also be created without a
	signature or encryption.  Plaintext JWTs MUST use the <spanx
	style="verb">alg</spanx> value <spanx
	style="verb">none</spanx>, and are formatted identically to a
	signed JWT with an empty signature.  This means that the
	base64url encoding of the bytes representing the UTF-8
	encoding of the JWT Claims Set is the JWT Second Part, and
	the empty string is the JWT Third Part.
      </t>

      <section title="Example Plaintext JWT" anchor="ExamplePlaintextJWT">

	<t>
	  The following example JWT Header declares that the
	  encoded object is a Plaintext JWT:
	</t>

	<figure><artwork><![CDATA[{"alg":"none"}]]></artwork></figure>

	<t>
	  Base64url encoding the bytes of the UTF-8 representation of
	  the JWT Header yields this Encoded JWT Header:
	</t>

	<figure><artwork><![CDATA[eyJhbGciOiJub25lIn0]]></artwork></figure>

	<t>
	  The following is an example of a JWT Claims Set:
	</t>

	<figure><artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork></figure>

	<t>
	  Base64url encoding the bytes of the UTF-8 representation of
	  the JSON Claims Set yields this Encoded JWS Payload,
	  which is used as the JWT Second Part
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	<t>
	  The JWT Third Part is the empty string.
	</t>

	<t>
	  Concatenating these parts in the order
	  Header.Second.Third with period characters between the
	  parts yields this complete JWT (with line breaks for
	  display purposes only):
	</t>

	<figure><artwork><![CDATA[eyJhbGciOiJub25lIn0
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
]]></artwork></figure>
      </section>

    </section>

    <section title="Rules for Creating and Validating a JWT">

      <t>
	To create a JWT, one MUST perform these steps:

        <list style="numbers">

	  <t>
	    Create a JWT Claims Set containing the desired claims.
	    Note that white space is explicitly allowed in the
	    representation and no canonicalization is performed before
	    encoding.
	  </t>
	  <t>
	    Let the Message be the bytes of the UTF-8 representation
	    of the JWT Claims Set.
	  </t>
	  <t>
	    Create a JWT Header containing the desired set of header
	    parameters.  If the JWT is to be signed or encrypted, they
	    MUST conform to either the <xref target="JWS" /> or <xref
	    target="JWE" /> specifications, respectively.  Else, if
	    the JWT is to be plaintext, the <spanx
	    style="verb">alg</spanx> value <spanx
	    style="verb">none</spanx> MUST be used.  Note that white
	    space is explicitly allowed in the representation and no
	    canonicalization is performed before encoding.
	  </t>
          <t>
	    Base64url encode the bytes of the UTF-8 representation of
	    the JWT Header.  Let this be the Encoded JWT Header.
	  </t>
	  <t>
	    Depending upon whether the JWT is to be signed, encrypted,
	    or plaintext, there are three cases:
	    <list style='symbols'>
	      <t>
		If the JWT is to be signed, create a JWS using the JWT
		Header as the JWS Header and the Message as the JWS
		Payload; all steps specified in <xref target="JWS" />
		for creating a JWS MUST be followed.
		Let the JWT Second Part be the Encoded JWS Payload and
		let the JWT Third Part be the Encoded JWS Signature.
	      </t>
	      <t>
		If the JWT is to be encrypted, create a JWE using the
		JWT Header as the JWE Header and the Message as the
		JWE Plaintext; all steps specified in <xref
		target="JWE" /> for creating a JWE MUST be followed.
		Let the JWT Second Part be the Encoded JWE Encrypted
		Key and let the JWT Third Part be the Encoded JWS
		Ciphertext.
	      </t>
	      <t>
		Else, if the JWT is to be plaintext, let the JWT
		Second Part be the base64url encoding of the Message
		and let the JWT Third Part be the empty string.
	      </t>
	    </list>
	  </t>
	  <t>
	    Concatenate the Encoded JWT Header, the JWT Second Part,
	    and the JWT Third Part in that order, separating each by
	    period ('.') characters.
	  </t>
	  <t>
	    If a nested signing or encryption operation will be
	    performed, let the Message be this concatenation, and
	    return to Step 3, using a <spanx style="verb">typ</spanx>
	    value of either "JWS" or "JWE" respectively in the
	    new JWT Header created in that step.
	  </t>
	  <t>
	    Otherwise, let the resulting JWT be this concatenation.
	  </t>
        </list>
      </t>
      <t>
	When validating a JWT the following steps MUST be taken. If
	any of the listed steps fails then the token MUST be rejected
	for processing.
      </t>
      <t>
	<list style="numbers">
	  <t>
	    The JWT MUST contain exactly two period characters.
	  </t>
	  <t>
	    The JWT MUST be split on the two period characters
	    resulting in three strings.  The first string is the
	    Encoded JWT Header; the second is the JWT Second Part; the
	    third is the JWT Third Part.
	  </t>
          <t>
	    The Encoded JWT Header MUST be successfully base64url
	    decoded following the restriction given in this
	    specification that no padding characters have been used.
	  </t>
          <t>
	    The JWT Header MUST be completely valid JSON syntax
	    conforming to <xref target="RFC4627">RFC 4627</xref>.
	  </t>
          <t>
	    The JWT Header MUST be validated to only include
	    parameters and values whose syntax and semantics are both
	    understood and supported.
	  </t>
	  <t>
	    Determine whether the JWT is signed, encrypted, or
	    plaintext by examining the <spanx style="verb">alg</spanx>
	    (algorithm) header value and optionally, the <spanx
	    style="verb">enc</spanx> (encryption method) header value,
	    if present.
	  </t>
	  <t>
	    Depending upon whether the JWT signed, encrypted,
	    or plaintext, there are three cases:
	    <list style='symbols'>
	      <t>
		If the JWT is signed, all steps specified in <xref
		target="JWS" /> for validating a JWS MUST be followed.
		Let the Message be the result of base64url decoding
		the JWS Payload.
	      </t>
	      <t>
		If the JWT is encrypted, all steps specified in <xref
		target="JWE" /> for validating a JWE MUST be followed.
		Let the Message be the JWE Plaintext.
	      </t>
	      <t>
		Else, if the JWT is plaintext, let the Message be the
		result of base64url decoding the JWE Second Part.  The
		Third Part MUST be verified to be the empty string.
	      </t>
	    </list>
	  </t>
	  <t>
	    If the JWT Header contains a <spanx
	    style="verb">typ</spanx> value of either "JWS" or "JWE",
	    then the Message contains a JWT that was the subject of
	    nested signing or encryption operations, respectively.  In
	    this case, return to Step 1, using the Message as the JWT.
	  </t>
	  <t>
	    Otherwise, let the JWT Claims Set be the Message.
	  </t>
	  <t>
	    The JWT Claims Set MUST be completely valid
	    JSON syntax conforming to <xref target="RFC4627">RFC
	    4627</xref>.
	  </t>
	  <t>
	    When used in a security-related context, the
	    JWT Claims Set MUST be validated to only include claims
	    whose syntax and semantics are both understood and
	    supported.
	  </t>
        </list>
      </t>

      <t>
	Processing a JWT inevitably requires comparing known strings
	to values in the token. For example, in checking what the
	algorithm is, the Unicode string encoding <spanx style="verb">alg</spanx> will be
	checked against the member names in the JWT Header
	to see if there is a matching header parameter
	name. A similar process occurs when determining if the value
	of the <spanx style="verb">alg</spanx> header parameter represents a supported
	algorithm.
      </t>
      <t>
	Comparisons between JSON strings and other Unicode strings
	MUST be performed as specified below:

	<list style="numbers">

          <t>
	    Remove any JSON applied escaping to produce an array of
	    Unicode code points.
	  </t>
          <t>
	    <xref target="USA15">Unicode Normalization</xref> MUST NOT
	    be applied at any point to either the JSON string or to
	    the string it is to be compared against.
	  </t>
          <t>
	    Comparisons between the two strings MUST be performed as a
	    Unicode code point to code point equality comparison.
	  </t>

        </list>
      </t>

    </section>

    <section title="Cryptographic Algorithms" anchor="Algorithms">

      <t>
	JWTs use JSON Web Signature (JWS) <xref target="JWS" /> and
	JSON Web Encryption (JWE) <xref target="JWE" /> to sign and/or
	encrypt the contents of the JWT.
      </t>
      <t>
	Of the JWS signing algorithms, only HMAC SHA-256 MUST be
	implemented by conforming JWT implementations.  It is
	RECOMMENDED that implementations also support the RSA SHA-256
	and ECDSA P-256 SHA-256 algorithms.  Support for other
	algorithms and key sizes is OPTIONAL.
      </t>
      <t>
	If an implementation provides encryption capabilities,
	of the JWE encryption algorithms, only RSA-PKCS1-1.5 with 2048 bit keys,
	AES-128-CBC, and AES-256-CBC MUST be implemented by conforming
	implementations.  It is RECOMMENDED that implementations also
	support ECDH-ES with 256 bit keys, AES-128-GCM, and
	AES-256-GCM.  Support for other algorithms and key sizes is
	OPTIONAL.
      </t>

    </section>

    <section title="IANA Considerations" anchor="IANA">
      <t>
	This specification calls for:

        <list style="symbols">

          <t>
	    A new IANA registry entitled "JSON Web Token Claims" for
	    reserved claim names is defined in <xref
	    target="ReservedClaimName"></xref>. Inclusion in the
	    registry is RFC Required in the <xref target="RFC5226">RFC
	    5226</xref> sense for reserved JWT claim names that are
	    intended to be interoperable between implementations.  The
	    registry will just record the reserved claim name and a
	    pointer to the RFC that defines it. This specification
	    defines inclusion of the claim names defined in <xref
	    target="ClaimTable"></xref>.
	  </t>
        </list>
      </t>
    </section>

    <section title="Security Considerations" anchor="Security">
      <t>
	TBD: Lots of work to do here. We need to remember to look into
	any issues relating to security and JSON parsing. One wonders
	just how secure most JSON parsing libraries are. Were they
	ever hardened for security scenarios? If not, what kind of
	holes does that open up? Also, we need to walk through the
	JSON standard and see what kind of issues we have especially
	around comparison of names.  For instance, comparisons of
	claim names and other parameters must occur after they are
	unescaped. Need to also put in text about: Importance of
	keeping secrets secret. Rotating keys. Strengths and
	weaknesses of the different algorithms.
      </t>
      <t>
	TBD: Need to put in text about why strict JSON validation is
	necessary.  Basically, that if malformed JSON is received then
	the intent of the sender is impossible to reliably discern.
	One example of malformed JSON that MUST be rejected is
	an object in which the same member name occurs multiple times.
	While in non-security contexts it's o.k. to be
	generous in what one accepts, in security contexts this can
	lead to serious security holes. For example, malformed JSON
	might indicate that someone has managed to find a security
	hole in the issuer's code and is leveraging it to get the
	issuer to issue "bad" tokens whose content the attacker can
	control.
      </t>
      <t>
	TBD: Write about the need to secure the token content if a
	signature is not contained in the JWT itself.
      </t>

      <section title="Unicode Comparison Security Issues">

        <t>
	  Claim names in JWTs are Unicode strings.  For security
	  reasons, the representations of these names must be compared
	  verbatim after performing any escape processing (as per
	  <xref target="RFC4627">RFC 4627</xref>, Section 2.5).
	</t>
        <t>
	  This means, for instance, that these JSON strings must
	  compare as being equal ("JWT", "\u004aWT"), whereas these
	  must all compare as being not equal to the first set or to
	  each other ("jwt", "Jwt", "JW\u0074").
	</t>
	<t>
	  JSON strings MAY contain characters outside the Unicode
	  Basic Multilingual Plane.  For instance, the G clef
	  character (U+1D11E) may be represented in a JSON string as
	  "\uD834\uDD1E".  Ideally, JWT implementations SHOULD ensure
	  that characters outside the Basic Multilingual Plane are
	  preserved and compared correctly; alternatively, if this is
	  not possible due to these characters exercising limitations
	  present in the underlying JSON implementation, then input
	  containing them MUST be rejected.
	</t>

      </section>
    </section>

    <section title="Open Issues and Things To Be Done (TBD)" anchor="TBD">

      <t>
	The following items remain to be done in this draft:

	<list style="symbols">

	  <t>
	    Provide an example of an encrypted JWT.
	  </t>
	  <t>
	    Clarify the optional ability to provide type information
	    for JWTs and/or their parts.  Specifically, clarify 
	    whether we need to specify the <spanx style="verb">typ</spanx>
	    Claim Name in addition to the Header Parameter,
	    whether it conveys syntax or semantics, and indeed,
	    whether this is the right approach.  Also clarify the
	    relationship between these type values and <xref
	    target="RFC2045">MIME</xref> types (if any).
	  </t>
	  <t>
	    Think about how to best describe the concept currently
	    described as "the bytes of the UTF-8 representation of".
	    Possible terms to use instead of "bytes of" include "byte
	    sequence", "octet series", and "octet sequence".  Also
	    consider whether we want to add an overall clarifying
	    statement somewhere in each spec something like "every
	    place we say 'the UTF-8 representation of X', we mean 'the
	    bytes of the UTF-8 representation of X'".  That would
	    potentially allow us to omit the "the bytes of" part
	    everywhere else.
	  </t>
	  <t>
	    Consider whether a media type should be proposed, such as
	    "application/jwt".
	  </t>
	  <t>
	    Finish the Security Considerations section.
	  </t>
	  <t>
	    Possibly write a companion specification that contains the former
	    JWT JSON Serialization.
	  </t>

	</list>
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &RFC2045;
      &RFC2119;
      &RFC3339;
      &RFC3629;
      &RFC3986;
      &RFC4627;
      &RFC4648;
      &RFC5226;

      <reference anchor="USA15">
        <front>
          <title>Unicode Normalization Forms</title>

          <author fullname="Mark Davis" initials="M." surname="Davis">
            <address>
              <email>markdavis@google.com</email>
            </address>
          </author>

          <author fullname="Ken Whistler" initials="K." surname="Whistler">
            <address>
              <email>ken@unicode.org</email>
            </address>
          </author>

          <author fullname="Martin D&uuml;rst" initials="M."
                  surname="D&uuml;rst"></author>

          <date day="03" month="09" year="2009" />
        </front>

        <seriesInfo name="Unicode Standard Annex" value="15" />
      </reference>

      <reference anchor="JWS">
        <front>
          <title>JSON Web Signature (JWS)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
	    <organization>Google</organization>
	    <address>
	      <email>balfanz@google.com</email>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	    </address>
	  </author>

	  <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland">
	    <organization>Microsoft</organization>
	    <address>
	      <email>yarong@microsoft.com</email>
	    </address>
	  </author>

	  <author fullname="John Panzer" initials="J." surname="Panzer">
	    <organization>Google</organization>
	    <address>
	      <email>jpanzer@google.com</email>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization>Nomura Research Institute</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	    </address>
	  </author>

	  <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
	    <organization>Facebook</organization>
	    <address>
	      <email>pt@fb.com</email>
	    </address>
	  </author>

	  <date day="13" month="December" year="2011" />
        </front>
        <format target="http://tools.ietf.org/html/draft-jones-json-web-signature" type="HTML" />
      </reference>
    </references>

    <references title="Informative References">
      &OASIS.saml-core-2.0-os;
      &W3C.CR-xml11-20021015;
      &RFC3275;
      &RFC4122;

      <reference anchor="SWT">
        <front>
          <title>Simple Web Token (SWT)</title>

          <author fullname="Dick Hardt" initials="D." surname="Hardt"></author>

          <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland"></author>

          <date month="November" year="2009" />
        </front>
        <seriesInfo name="Version" value="0.9.5.1" />
        <format target="http://oauth-wrap-wg.googlegroups.com/web/SWT-v0.9.5.1.pdf?gda=Sn4MsEMAAABFB7PFAFiVedPtjcqT8uuIImHXUksNUKMXLyrSumAs_dF2tzlQ33RhT1wW8BFYO1QytiJ-HdGYYcPi_09pl8N7FWLveOaWjzbYnpnkpmxcWg" type="PDF" />
      </reference>

      <reference anchor="MagicSignatures">
        <front>
          <title>Magic Signatures</title>

          <author fullname="John Panzer (editor)" initials="J." surname="Panzer (editor)"></author>

          <author fullname="Ben Laurie" initials="B." surname="Laurie"></author>

          <author fullname="Dirk Balfanz" initials="D." surname="Balfanz"></author>

          <date month="August" year="2010" />
        </front>
        <format target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-experimental-00.html" type="HTML" />
      </reference>

      <reference anchor="JSS">
        <front>
          <title>JSON Simple Sign</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization>Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/jss/1.0/" type="HTML" />
      </reference>

      <reference anchor="CanvasApp">
        <front>
          <title>Canvas Applications</title>

          <author fullname="Facebook" surname="Facebook"></author>

          <date year="2010" />
        </front>
        <format target="http://developers.facebook.com/docs/authentication/canvas" type="HTML" />
      </reference>

      <reference anchor="JWE">
        <front>
          <title>JSON Web Encryption (JWE)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
	    <organization>RTFM, Inc.</organization>
	    <address>
	      <email>ekr@rtfm.com</email>
	    </address>
	  </author>

	  <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
	    <organization>Cisco Systems, Inc.</organization>
	    <address>
	      <email>jhildebr@cisco.com</email>
	    </address>
	  </author>

	  <date day="13" month="December" year="2011" />
        </front>
        <format target="http://tools.ietf.org/html/draft-jones-json-web-encryption" type="HTML" />
      </reference>

    </references>

    <section title="Relationship of JWTs to SAML Tokens">
      <t>
	<xref target="OASIS.saml-core-2.0-os">SAML 2.0</xref> provides
	a standard for creating tokens with much greater expressivity
	and more security options than supported by JWTs. However, the
	cost of this flexibility and expressiveness is both size and
	complexity. In addition, SAML's use of <xref
	target="W3C.CR-xml11-20021015">XML</xref> and <xref
	target="RFC3275">XML DSIG</xref> only contributes to the size
	of SAML tokens.
      </t>
      <t>
	JWTs are intended to provide a simple token format that is
	small enough to fit into HTTP headers and query arguments in
	URIs. It does this by supporting a much simpler token model
	than SAML and using the <xref target="RFC4627">JSON</xref>
	object encoding syntax. It also supports securing tokens using
	Hash-based Message Authentication Codes (HMACs) and digital
	signatures using a smaller (and less flexible) format than XML
	DSIG.
      </t>
      <t>
	Therefore, while JWTs can do some of the things SAML tokens
	do, JWTs are not intended as a full replacement for SAML
	tokens, but rather as a compromise token format to be used
	when space is at a premium.
      </t>
    </section>

    <section title="Relationship of JWTs to Simple Web Tokens (SWTs)">

      <t>
	Both JWTs and Simple Web Tokens <xref target="SWT">SWT</xref>,
	at their core, enable sets of claims to be communicated
	between applications.  For SWTs, both the claim names and
	claim values are strings.  For JWTs, while claim names are
	strings, claim values can be any JSON type.  Both token types
	offer cryptographic protection of their content: SWTs with
	HMAC SHA-256 and JWTs with a choice of algorithms, including
	HMAC SHA-256, RSA SHA-256, and ECDSA P-256 SHA-256.
      </t>

    </section>

    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>
	The authors acknowledge that the design of JWTs was
	intentionally influenced by the design and simplicity of <xref
	target="SWT">Simple Web Tokens</xref> and ideas for JSON
	tokens that Dick Hardt discussed within the OpenID community.
      </t>
      <t>
	Solutions for signing JSON content were previously explored by
	<xref target="MagicSignatures">Magic Signatures</xref>, <xref
	target="JSS">JSON Simple Sign</xref>, and <xref
	target="CanvasApp">Canvas Applications</xref>, all of which
	influenced this draft.
      </t>

    </section>

    <section title='Document History'>
      <t>
        -07
        <list style='symbols'>
          <t>
            Defined the <spanx style="verb">prn</spanx> (principal)
            claim to identify the subject of the JWT.
	  </t>
	  <t>
	    Defined the <spanx style="verb">jti</spanx> (JWT ID)
	    claim to enable replay protection.
          </t>
	  <t>
	    Use the term "JWT Claims Set" rather than "JWT Claims Object"
	    since this is actually a string representing a JSON object
	    and not the JSON object itself.
	  </t>
	  <t>
	    Moved "MUST" requirements from the Overview to later in
	    the spec.
	  </t>
	  <t>
	    Respect line length restrictions in examples.
	  </t>
	  <t>
	    Applied other editorial improvements.
	  </t>
        </list>
      </t>
      <t>
        -06
        <list style='symbols'>
	  <t>
	    Reference and use content from <xref target="JWS" /> and
	    <xref target="JWE" />, rather than repeating it here.
	  </t>
	  <t>
	    Simplified terminology to better match JWE, where the
	    terms "JWT Header" and "Encoded JWT Header" are now used,
	    for instance, rather than the previous terms "Decoded JWT
	    Header Segment" and "JWT Header Segment".  Also changed to
	    "Plaintext JWT" from "Unsigned JWT".
	  </t>
	  <t>
	    Describe how to perform nested encryption and signing
	    operations.
	  </t>
	  <t>
	    Changed "integer" to "number", since that is the correct
	    JSON type.
	  </t>
          <t>
            Changed StringAndURI to StringOrURI.
          </t>
        </list>
      </t>
      <t>
        -05
        <list style='symbols'>
          <t>
            Added the <spanx style="verb">nbf</spanx> (not before)
            claim and clarified the meaning of the <spanx
            style="verb">iat</spanx> (issued at) claim.
          </t>
        </list>
      </t>
      <t>
        -04
        <list style='symbols'>
          <t>
            Correct typo found by John Bradley: "the JWT Claim Segment
            is the empty string" -> "the JWT Crypto Segment is the
            empty string".
          </t>
        </list>
      </t>
      <t>
	-03
	<list style="symbols">
	  <t>
	    Added "http://openid.net/specs/jwt/1.0" as a token type
	    identifier URI for JWTs.
	  </t>
	  <t>
	    Added <spanx style="verb">iat</spanx> (issued at) claim.
	  </t>
	  <t>
	    Changed RSA SHA-256 from MUST be supported to RECOMMENDED
	    that it be supported.  Rationale: Several people have
	    objected to the requirement for implementing RSA SHA-256,
	    some because they will only be using HMACs and symmetric
	    keys, and others because they only want to use ECDSA when
	    using asymmetric keys, either for security or key length
	    reasons, or both.
	  </t>
	  <t>
	    Defined <spanx style="verb">alg</spanx> value <spanx
	    style="verb">none</spanx> to represent unsigned JWTs.
	  </t>
	</list>
      </t>
      <t>
        -02
        <list style='symbols'>
          <t>
            Split signature specification out into separate
            draft-jones-json-web-signature-00.  This split introduced
            no semantic changes.
          </t>
	  <t>
	    The JWT Compact Serialization is now the only token
	    serialization format specified in this draft.  The JWT
	    JSON Serialization can continue to be defined in a
	    companion specification.
	  </t>
        </list>
      </t>
      <t>
        -01
        <list style='symbols'>
          <t>
            Draft incorporating consensus decisions reached at IIW.
          </t>
        </list>
      </t>
      <t>
        -00
        <list style='symbols'>
          <t>
            Public draft published before November 2010 IIW based upon
            the JSON token convergence proposal incorporating input
            from several implementers of related specifications.
          </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
