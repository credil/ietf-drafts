<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3654 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3654.xml">
<!ENTITY RFC3746 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3746.xml">
<!ENTITY RFC5657 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5657.xml">
<!ENTITY I-D.narten-iana-considerations-rfc2434bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.narten-iana-considerations-rfc2434bis.xml">
<!--<!ENTITY FORCES-OPENFLOW-LIB SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-haleplidis-forces-openflow-lib-01.xml"> -->
<!ENTITY RFC5812 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5812.xml">
<!ENTITY RFC5810 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5810.xml">
<!ENTITY RFC5811 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5811.xml">
<!ENTITY RFC6956 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6956.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="no" ?>
<!-- Start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-haleplidis-forces-packet-parallelization-03" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="ForCES Packet Parallelization">ForCES Packet Parallelization</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

		<author fullname="Evangelos Haleplidis" initials="E.H." surname="Haleplidis">
			<organization>University of Patras</organization>
			<address>
				<postal>
					<street>Department of Electrical and Computer Engineering</street>
					<!-- Reorder these if your country does things differently -->
					<city>Patras</city>
					<region/>
					<code>26500</code>
					<country>Greece</country>
				</postal>
				<email>ehalep@ece.upatras.gr</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
    
		<author fullname="Joel Halpern" initials="J.H." surname="Halpern">
			<organization>Ericsson</organization>
			<address>
				<postal>
					<street>P.O. Box 6049</street>
					<!-- Reorder these if your country does things differently -->
					<city>Leesburg</city>
					<region/>
					<code>20178</code>
					<country>VA</country>
				</postal>
				<phone>+1 703 371 3043</phone>
				<email>joel.halpern@ericsson.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->
    <date year="2013" />

    <area>Routing</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>ForCES</keyword>
    <keyword>Model</keyword>
    <keyword>Extension</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t> Forwarding and Control Element Separation (ForCES) defines an
      architectural framework and associated protocols to standardize
      information exchange between the control plane and the forwarding
      plane in a ForCES Network Element (ForCES NE).  RFC5812 has defined
      the ForCES Model provides a formal way to represent the capabilities, 
      state, and configuration of forwarding elements within the context of 
      the ForCES protocol, so that control elements (CEs) can control the FEs 
      accordingly. More specifically, the model describes the logical functions 
      that are present in an FE, what capabilities these functions support, and 
      how these functions are or can be interconnected.</t>
      <t>Many network devices support parallel packet processing. This document
      describes how ForCES can model a network device's parallelization datapath.</t>
    </abstract>
  </front>

  <middle>
    <section title="Terminology and Conventions">
      <t/>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>
      </section>
  <section title="Definitions">
	<t> This document follows the terminology defined by the ForCES
   Model in <xref target="RFC5812"></xref>.
   The required definitions are repeated below for clarity.</t>
  
      <t><list style="hanging">
      
<t>FE Model - The FE model is designed to model the logical processing
functions of an FE. The FE model proposed in this document
includes three components; the LFB modeling of individual Logical
Functional Block (LFB model), the logical interconnection between
LFBs (LFB topology), and the FE-level attributes, including FE
capabilities. The FE model provides the basis to define the
information elements exchanged between the CE and the FE in the
ForCES protocol [RFC5810].</t>
<t>LFB (Logical Functional Block) Class (or type) - A template that
represents a fine-grained, logically separable aspect of FE
processing. Most LFBs relate to packet processing in the data
path. LFB classes are the basic building blocks of the FE model.</t>
<t>LFB Instance - As a packet flows through an FE along a data path, it
flows through one or multiple LFB instances, where each LFB is an
instance of a specific LFB class. Multiple instances of the same
LFB class can be present in an FE's data path. Note that we often
refer to LFBs without distinguishing between an LFB class and LFB
instance when we believe the implied reference is obvious for the
given context.</t>
<t>LFB Model - The LFB model describes the content and structures in an
LFB, plus the associated data definition. XML is used to provide
a formal definition of the necessary structures for the modeling.
Four types of information are defined in the LFB model. The core
part of the LFB model is the LFB class definitions; the other
three types of information define constructs associated with and
used by the class definition. These are reusable data types,
supported frame (packet) formats, and metadata.</t>
<t>Element - Element is generally used in this document in accordance
with the XML usage of the term. It refers to an XML tagged part
of an XML document. For a precise definition, please see the full
set of XML specifications from the W3C. This term is included in
this list for completeness because the ForCES formal model uses
XML.</t>
<t>Attribute - Attribute is used in the ForCES formal modeling in
accordance with standard XML usage of the term, i.e., to provide
attribute information included in an XML tag.</t>
<t>LFB Metadata - Metadata is used to communicate per-packet state from
one LFB to another, but is not sent across the network. The FE
model defines how such metadata is identified, produced, and
consumed by the LFBs, but not how the per-packet state is
implemented within actual hardware. Metadata is sent between the
FE and the CE on redirect packets.</t>
<t>ForCES Component - A ForCES Component is a well-defined, uniquely
identifiable and addressable ForCES model building block. A
component has a 32-bit ID, name, type, and an optional synopsis
description. These are often referred to simply as components.
LFB Component - An LFB component is a ForCES component that defines
the Operational parameters of the LFBs that must be visible to the
CEs.</t>
<t>LFB Class Library - The LFB class library is a set of LFB classes
that has been identified as the most common functions found in
most FEs and hence should be defined first by the ForCES Working
Group.</t>
		</list></t>
    </section>
  </section>
  <section title="Introduction">
    <t>A lot of network devices can process packets in a parallel manner. The <xref target="RFC5812">ForCES Model</xref> presents a formal way to describe the Forwarding Plane's datapath with Logical Function Blocks (LFBs) using XML. This document describes how packet parallelization can be described with the ForCES model.</t>
    <t>The modelling concept has been influenced by <xref target="Cilc">Cilc</xref>. Cilc is a programming language that has been developed since 1994 at the MIT Laboratory to allow programmers to identify elements that can be executed in parallel. The two Cilc concepts used in this document is spawn and sync. Spawn being the place where parallel work can start and sync being the place where the parallel work finishes and must collect all parallel output. </t>
  </section>
  <section title="Packet Parallelization">
    <t>This document addresses the following two types of packet parallelization:</t>
    <t><list style="numbers">
      <t>Flood - where a copy of a packet is sent to multiple LFBs to be processed in parallel.</t>
      <t>Split - where the packet will be split in equal size chunks specified by the CE and sent to multiple LFB instances probably of the same LFB class to be processed in parallel.</t>
    </list></t>
    <t>It must be noted that the process of copying the packet in the Flood parallel type is implementation depended and is loosely defined here. An implementor may either decide to physical copy the packet and send all packets on the parallel paths, or may decide to logically copy the packet by simply sending for example pointers of the same packet provided that the necessary interlocks are taken into account. The implementor has to take into account the device's characteristics to decide which approach fits bets to the hardware.</t>
    <t>Additionally in the split parallel type, while harder, the implementor may also decide to logically split the packet and send for example pointers to parts of the packet, provided that the necessary interlocks are managed.</t>
    <t>This document introduces two LFBs that are used in before and after the parallelization occurs:</t>
    <t><list style="numbers">
      <t>Splitter - similar to Cilc's spawn. An LFB that will split the path of a packet and be sent to multiple LFBs to be processed in parallel.</t>
      <t>Merger - similar to Cilc's sync. An LFB that will receive packets or chunks of the same initial packet and merge them into one.</t>
    </list></t>
      <t>Both parallel packet distribution types can currently be achieved with the ForCES model. The splitter LFB has one group output that produces either chunks or packets to be sent to LFBs for processing and the merger LFB has one group input that expects either packets or chunks to aggregate all the parallel packets or chunks and produce a single packet. <xref target="SplitParallel"></xref> shows an simple example of a split parallel datapath along with the splitter and merger LFB. <xref target="FloodParallel"></xref> shows an example of a flood parallel datapath along with the splitter and merger LFB.</t>
      <t>Edit. NPP: This modelling framework however allows for more complex parallel datapath topologies as can be seen in <xref target="ComplexParallel"></xref> which shows one of the parallel paths to be further splitted into a new parallel section.</t>
        <t>
          <figure title="Simple split parallel processing" anchor="SplitParallel">
            <artwork align="center"><![CDATA[
                         +------------+
                   +---->| Regex LFB  |----+
    +----------+   |     +------------+    |       +----------+
    |          |---+                       +------>|          |
    |          |         +------------+            |          |
--->| Splitter |-------->| Regex LFB  |----------->|  Merger  |--->
    |   LFB    |         +------------+            |   LFB    |
    |          |---+                       +------>|          |
    +----------+   |     +------------+    |       +----------+
                   +---->| Regex LFB  |----+
                         +------------+
		]]></artwork>
          </figure>
        </t>
        <t>
          <figure title="Simple flood parallel processing" anchor="FloodParallel">
            <artwork align="center"><![CDATA[
    +----------+    +------------+    +-------+    +----------+
    |          |    | Classifier |    | Meter |    |          |
    |          |--->|     LFB    |--->|  LFB  |--->|          |
--->| Splitter |    +------------+    +-------+    |  Merger  |--->
    |   LFB    |                                   |   LFB    |
    |          |          +------------+           |          |
    |          |--------->|  IPv4 TTL  |---------->|          |
    +----------+          |  Decrement |           +----------+
                          |    LFB     |
                          +------------+
		]]></artwork>
          </figure>
        </t>
        <t>Edit. NPP:
          <figure title="Complex parallel processing" anchor="ComplexParallel">
            <artwork align="center"><![CDATA[
                              +-------+
                          +-->|  LFB  |--+
            +----------+  |   +-------+  |   +----------+
            |          |--+              +-->|          |
            |          |      +-------+      |          |
       +--->| Splitter |----->|  LFB  |----->|  Merger  |---+
       |    |   LFB    |      +-------+      |   LFB    |   |
       |    |          |--+              +-->|          |   |
       |    +----------+  |   +-------+  |   +----------+   |
       |                  +-->|  LFB  |--+                  |
       |                      +-------+                     |
       |                                                    |
       +------------------------------+                     |
                                      |                     |
                           +-------+  |        +------------+
                   +------>|  LFB  |--+        |
    +----------+   |       +-------+           |   +----------+
    |          |---+                           +-->|          |
    |          |           +-------+               |          |
--->| Splitter |---------->|  LFB  |-------------->|  Merger  |--->
    |   LFB    |           +-------+               |   LFB    |
    |          |---+                       +------>|          |
    +----------+   |       +-------+       |       +----------+
                   +------>|  LFB  |-------+
                           +-------+
		]]></artwork>
          </figure>
        </t>
      <t>One important element to a developer is the ability to define which LFBs can be used in a parallel mode, with which other LFBs can they be parallelized with and the order of the LFBs can be assembled. This information must be accessible in the core LFBs and therefore this document needs to append one more capability in the FEObject LFB. The topology of the parallel datapath can be deferred and manipulated from the FEObject LFB's LFBTopology.</t>
      <t>The FEObject LFB currently specifies the LFBtopology and supported LFBs in an FE. In order to support parallelization the following component is needed in order to specify each LFB that can be used in a parallel mode :</t>
      <t><list style="symbols">
        <t>The Name of the LFB.</t>
        <t>The Class ID of the LFB.</t>
        <t>The Version of the LFB.</t>
        <t>The number of instances that class can support in parallel.</t>
        <t>A list of LFB classes that can follow this LFB class in a pipeline for a parallel path.</t>
        <t>A list of LFB classes that can exist before this LFB class in a pipeline for a parallel path.</t>
        <t>A list of LFB classes that can process packets or chunks in parallel with this LFB class.</t>
      </list></t>
        <t>
          <figure title="XML Definition for FEObjectLFB extension" anchor="FEObjectExtension">
            <artwork align="center"><![CDATA[
    <!-- Datatype -->
    <dataTypeDef>
       <name>ParallelLFBType</name>
       <synopsis>Table entry for parallel LFBs</synopsis>
       <struct>
          <component componentID="1">
             <name>LFBName</name>
             <synopsis>The name of an LFB Class</synopsis>
             <typeRef>string</typeRef>
          </component>
          <component componentID="2">
             <name>LFBClassID</name>
             <synopsis>The id of the LFB Class</synopsis>
             <typeRef>uint32</typeRef>
          </component>
          <component componentID="3">
             <name>LFBVersion</name>
             <synopsis>The version of the LFB Class used by this FE
             </synopsis>
             <typeRef>string</typeRef>
          </component>
          <component componentID="4">
             <name>LFBParallelOccurenceLimit</name>
             <synopsis>The upper limit of instances of the same
                parallel LFBs of this class</synopsis>
             <optional />
             <typeRef>uint32</typeRef>
          </component>
          <component componentID="5">
             <name>AllowedParallelAfters</name>
             <synopsis>List of LFB Classes that can follow this LFB
                in a parallel pipeline</synopsis>
             <optional />
             <array>
                <typeRef>uint32</typeRef>
             </array>
          </component>
          <component componentID="6">
             <name>AllowedParallelBefores</name>
             <synopsis>List of LFB Classes that this LFB class can
                follow in a parallel pipeline</synopsis>
             <optional />
             <array>
                <typeRef>uint32</typeRef>
             </array>
          </component>
          <component componentID="7">
             <name>AllowedParallel</name>
             <synopsis>List of LFB Classes that this LFB class be run
                in parallel with</synopsis>
             <array>
                <typeRef>uint32</typeRef>
             </array>
          </component>
       </struct>
    </dataTypeDef>
    
    <!-- Capability -->
          <capability componentID="32">
             <name>ParallelLFBs</name>
             <synopsis>List of all supported parallel LFBs</synopsis>
             <array type="Variable-size">
                <typeRef>ParallelLFBType</typeRef>
             </array>
          </capability>
		]]></artwork>
          </figure>
        </t>
      <t>While the ForCES model cannot describe how the splitting or the merging is actually done as that is an implementation issue of the actual LFB, however this document defines operational parameters to control the splitting and merging, namely the size of the chunks, what happens if a packet or chunk has been marked as invalid and whether the merge LFB should wait for all packets or chunks to arrive. Additionally this document defines metadata, which contain necessary information to assist the merging procedure. The following metadata are defined:</t>
      <t><list style="numbers">
        <t>ParallelType - Flood or split</t>
        <t>Correlator - Identify packets or chunks that belonged to the initial packet that entered the Splitter LFB</t>
        <t>ParallelNum - Number of packet or chunk for specific Correlator.</t>
        <t>ParralelPartsCount - Total number of packets or chunks for specific Correlator.</t>
      </list></t>
      <t>This metadata is produced from the Splitter LFB and is opaque to LFBs in parallel paths and is passed along to the merger LFB without being consumed.</t>
      <t>Edit. NPP: In case that in a parallel path there is an additional Splitter LFB therefore parallelizing even more that path, a new set of metadata MUST be produced for that specific Splitter and the first set of metadata MUST be tunneled through without being consumed or changed until reaching the corresponding Merger LFB where it will be sent out again in the previous parallel path.</t>
      <t>In case of a packet/chunk being branded invalid by an LFB in a parallel path, it MUST be sent by an output port of said LFB </t>
      <t>An LFB inside a parallel path decides that a packet or a chunk has to be dropped it MAY drop it but the metadata MUST be sent to the Merger LFB's InvalidIn input port for merging purposes.</t>
      <t>Additional metadata produced by LFBs inside a datapath MAY be aggregated within the Merger LFB and sent on after the merging process. In case of receiving the same metadata definition with multiple values the merger LFB MUST keep the first received from a valid packet or chunk.</t>
    </section>
    <section title="Parallel Base Types">
      <section title="Frame Types">
        <t>One frame type has been defined in this library.</t>
        <texttable title="Parallel Frame Types" align="center">
          <ttcol>Frame Type Name</ttcol>
          <ttcol>Synopsis</ttcol>
          <!--Ingress Port -->
          <c>Chunk</c>
          <c>A chunk is a frame that is part of an original larger frame</c>
        </texttable>
      </section>
      <section title="Data Types">
        <t>One data type has been defined in this library.</t>
        <texttable title="Parallel Data Types" align="center">
          <ttcol>DataType Name</ttcol>
          <ttcol>Type</ttcol>
          <ttcol>Synopsis</ttcol>
          <!--Ingress Port -->
          <c>ParallelTypes</c>
          <c>Atomic uchar. Special Values Flood (0), Split (1).</c>
          <c>The type of parallelization this packet will go through</c>
        </texttable>
      </section>
      <section title="MetaData Types">
        <t>The following metadata are defined in the OpenFlow type library:</t>
      <texttable title="Metadata Structure for Merging">
        <ttcol align="center">Metadata Name</ttcol>
        <ttcol align="center">Type</ttcol>
        <ttcol align="center">ID</ttcol>
        <ttcol align="center">Synopsis</ttcol>
          <!-- MergeID -->            
          <c>ParallelType</c>
          <c>uchar</c>
          <c>32</c>
          <c>The type of parallelization this packet will go through. 0 for flood, 1 for split.</c>
          <!-- MergeID -->            
          <c>Correlator</c>
          <c>uint32</c>
          <c>33</c>
          <c>An identification number to specify that packets or chunks belong to the same parallel work.</c>
          <!-- ParallelCount -->            
          <c>ParallelNum</c>
          <c>uint32</c>
          <c>34</c>
          <c>Defines the number of the specific packet or chunk of the specific parallel ID.</c>
          <!-- ParallelCount -->            
          <c>ParallelPartsCount</c>
          <c>uint32</c>
          <c>35</c>
          <c>Defines the total number of packets or chunks for the specific parallel ID.</c>
      </texttable>
     </section>
    </section>
    <section title="Parallel LFBs">
      <section title="Splitter">
        <t>A splitter LFB takes part in parallelizing the processing datapath by sending either the same packet or chunks of the same packet to multiple LFBs.</t>
        <section title="Data Handling">
          <t>The splitter LFB receives any kind of packet via the singleton input, Input. Depending upon the CE's configuration of the ParallelType component, if the parallel type is of type flood (0), the same packet MUST be sent through all of the group output ParallelOut's instances. If the parallel type is of type split (1), the packet will be split into same size chunks except the last which MAY be smaller, with the max size being defined by the ChunkSize component. All chunks will be sent out in a round-robin fashion through the group output ParallelOut's instances. Each packet or chunk will be accompanied by the following metadata:</t>
          <t><list style="symbols">
            <t>ParallelType - The paralleltype split or flood.</t>
            <t>Parallel ID - generated by the splitter LFB to identify that chunks or packets belong to the same parallel work.</t>
            <t>Parallel Num - each chunk or packet of a parallel id will be assigned a number in order for the merger LFB to know when it has gathered them all along with the ParallelPartsCount metadata.</t>
            <t>ParallelPartsCount - the number of chunks or packets for the specific parallel id.</t>
            <t>Valid - with a default value of true. The merger LFB must know if a packet or a chunk must be set invalid by an LFB in one part of the parallel pipeline.</t>
          </list></t>
        </section>
        <section title="Components">
          <t>This LFB has only two components specified. The first is the ParallelType, an uint32 that defines how the packet will be processed by the Splitter LFB. The second is the ChunkSize, an uint32 that specifies the maximum size of a chunk when a packet is split into multiple same size chunks.</t>
        </section>
        <section title="Capabilities">
          <t>This LFB has only one capability specified, the MinMaxChunkSize a struct of a uint32 to specify the minimum chunk size and a uint32 to specify the maximum chunk size.</t>
        </section>
        <section title="Events">
          <t>This LFB has no events specified.</t>
        </section>
      </section>
      <section title="Merger">
        <t>A merger LFB receives multiple packets or multiple chunks of the same packet and merge them into one merged packet.</t>
        <section title="Data Handling">
          <t>The Merger LFB receives either a packet or a chunk via the group input ParallelIn, along with the ParallelType metadata to identify whether what was received was a packet or a chunk, the Correlator, the ParallelNum and the ParallelPartsCount.</t>
          <t>In case that an LFB has dropped a packet or a chunk within a parallel path the merger LFB MAY receive only the metadata or both metadata and packet or chunk through the InvalidIn group input port. It SHOULD receive a metadata specifying the error code. Current defined metadata's in the <xref target="RFC6956">Base LFB Library</xref> are the ExceptionID and the ValidateErrorID. The Merger LFB MAY store the parallel metadata along with the exception metadata as a string in the optional InvalideMetadataSets as a means for the CE to debug errors in the parallel path.</t>
          <t>If the MergeWaitType is set to false the Merger LFB will initiate the merge process upon receiving the first packet. If false it will wait for all packet in the Correlator to arrive.</t>
          <t>If one packet or chunk has been received through the InvalidIn port then the merging procedure will be operate as configured by the InvalidAction component. If the InvalidAction component has been set to 0 then if one packet or chunk is not valid all will dropped, else the process will initiate. Once the merging process has been finished the resulting packet will be sent via the singleton output port PacketOutput.</t>
          <t>If the Merger LFB receives different values for the same metadata from different packets or chunks that has the same correlator then the Merger LFB will use the first metadata from a packet or chunk that entered the LFB through the ParallelIn input port.</t>
        </section>
        <section title="Components">
          <t>This LFB has the following components specified:</t>
          <t><list style="numbers">
            <t>InvalidAction - a uchar defining what the Merge LFB will do if an invalid chunk or packet is received. If set to 0 (DropAll) the merge will be considered invalid and all chunks or packets will be dropped. If set to 1 (Continue) the merge will continue.</t>
            <t>MergeWaitType - a boolean. If true the Merger LFB will wait for all packets or chunks to be received prior to sending out a response. If false, when one packet or a chunk with a response is received by the merge LFB it will start with the merge process.</t>
            <t>InvalidMergesCounter - a uint32 that counts the number of merges where there is at least one packet or chunk that entered the merger LFB through the InvalidIn input port.</t>
            <t>InvalidAllCounter - a uint 32 that counts the number of merges where all packets/chunks entered the merger LFB through the InvalidIn input port.</t>
            <t>InvalidIDCounters - a struct of two arrays. Each array has a uint32 per row. Each array counts number of invalid merges where at least one packet or chunk entered through InvalidID per error ID. The first array is the InvalidExceptionID and the second is the InvalidValidateErrorID.</t>
            <t>InvalideMetadataSets - an array of strings. An optional component that stores metadata sets along with the error id as a string. This could provide a debug information to the CE regarding errors in the parallel paths.</t>
          </list></t>
        </section>
        <section title="Capabilities">
          <t>This LFB has no capabilities specified.</t>
        </section>
        <section title="Events">
          <t>This LFB specifies only two event. The first detects whether the InvalidMergesCounter has exceeded a specific value and the second detects whether the InvalidAllCounter has exceeded a specific value. Both error reports will send the respective counter value.</t>
        </section>
      </section>
    </section>
    <section title="XML for Parallel LFB library">
        <t>
          <figure title="Parallel LFB library" anchor="ParallelLFBLibrary">
            <artwork align="center"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<LFBLibrary xmlns="urn:ietf:params:xml:ns:forces:lfbmodel:1.0"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="urn:ietf:params:xml:ns:forces:lfbmodel:1.0"
   provides="Parallel">
   <load library="BaseTypeLibrary" location="BaseTypeLibrary.LFB" />
   <frameDefs>
      <frameDef>
         <name>Chunk</name>
         <synopsis>A chunk is a frame that is part of an original
            larger frame</synopsis>
      </frameDef>
   </frameDefs>
   <dataTypeDefs>
      <dataTypeDef>
         <name>ParallelTypes</name>
         <synopsis>The type of parallelization this packet will go
            through</synopsis>
         <atomic>
            <baseType>uchar</baseType>
            <specialValues>
               <specialValue value="0">
                  <name>Flood</name>
                  <synopsis>The packet/chunk has been sent as a whole
                     to multiple recipients</synopsis>
               </specialValue>
               <specialValue value="1">
                  <name>Split</name>
                  <synopsis>The packet/chunk has been split into
                    multiple chunks and sent to recipients</synopsis>
               </specialValue>
            </specialValues>
         </atomic>
      </dataTypeDef>
   </dataTypeDefs>
   <metadataDefs>
      <metadataDef>
         <name>ParallelType</name>
         <synopsis>The type of parallelization this packet/chunk has
            gone through</synopsis>
         <metadataID>32</metadataID>
         <typeRef>ParallelTypes</typeRef>
      </metadataDef>
      <metadataDef>
         <name>Correlator</name>
         <synopsis>An identification number to specify that packets 
           or chunks originate from the same packet.</synopsis>
         <metadataID>33</metadataID>
         <typeRef>uint32</typeRef>
      </metadataDef>
      <metadataDef>
         <name>ParallelNum</name>
         <synopsis>Defines the number of the specific packet or chunk
            of the specific parallel ID.</synopsis>
         <metadataID>34</metadataID>
         <typeRef>uint32</typeRef>
      </metadataDef>
      <metadataDef>
         <name>ParallelPartsCount</name>
         <synopsis>Defines the total number of packets or chunks for
            the specific parallel ID.</synopsis>
         <metadataID>35</metadataID>
         <typeRef>uint32</typeRef>
      </metadataDef>
   </metadataDefs>
   <LFBClassDefs>
      <LFBClassDef LFBClassID="30">
         <name>Splitter</name>
         <synopsis>A splitter LFB takes part in parallelizing the
            processing datapath. It will either send the same packet
            or chunks of one packet to multiple LFBs</synopsis>
         <version>1.0</version>
         <inputPorts>
            <inputPort>
               <name>Input</name>
               <synopsis>An input port expecting any kind of frame
               </synopsis>
               <expectation>
                  <frameExpected>
                     <ref>Arbitrary</ref>
                  </frameExpected>
               </expectation>
            </inputPort>
         </inputPorts>
         <outputPorts>
            <outputPort group="true">
               <name>ParallelOut</name>
               <synopsis>An parallel output port that sends the same
                 packet to all output instances or chunks of the same
                 packet different chunk on each instance.</synopsis>
               <product>
                  <frameProduced>
                     <ref>Arbitrary</ref>
                     <ref>Chunk</ref>
                  </frameProduced>
                  <metadataProduced>
                     <ref>ParallelType</ref>
                     <ref>Correlator</ref>
                     <ref>ParallelNum</ref>
                     <ref>ParallelPartsCount</ref>
                  </metadataProduced>
               </product>
            </outputPort>
         </outputPorts>
         <components>
            <component componentID="1" access="read-write">
               <name>ParallelType</name>
               <synopsis>The type of parallelization this packet will
                  go through</synopsis>
               <typeRef>ParallelTypes</typeRef>
            </component>
            <component componentID="2" access="read-write">
               <name>ChunkSize</name>
               <synopsis>The size of a chunk when a packet is split
                  into multiple same size chunks</synopsis>
               <typeRef>uint32</typeRef>
            </component>
         </components>
         <capabilities>
            <capability componentID="31">
               <name>MinMaxChunkSize</name>
               <synopsis>The minimum and maximum size of a chunk
                  capable of splitted by this LFB</synopsis>
               <struct>
                  <component componentID="1">
                     <name>MinChunkSize</name>
                     <synopsis>Minimum chunk size</synopsis>
                     <optional />
                     <typeRef>uint32</typeRef>
                  </component>
                  <component componentID="2">
                     <name>MaxChunkSize</name>
                     <synopsis>Maximum chunk size</synopsis>
                     <typeRef>uint32</typeRef>
                  </component>
               </struct>
            </capability>
         </capabilities>
      </LFBClassDef>
      <LFBClassDef LFBClassID="31">
         <name>Merger</name>
         <synopsis>A merger LFB receives multiple packets or multiple
            chunks of the same packet and merge them into one merged
            packet</synopsis>
         <version>1.0</version>
         <inputPorts>
            <inputPort group="true">
               <name>ParallelIn</name>
               <synopsis>An parallel input port that accepts packets
                  or chunks from all output instances</synopsis>
               <expectation>
                  <frameExpected>
                     <ref>Arbitrary</ref>
                     <ref>Chunk</ref>
                  </frameExpected>
                  <metadataExpected>
                     <ref>ParallelType</ref>
                     <ref>Correlator</ref>
                     <ref>ParallelNum</ref>
                     <ref>ParallelPartsCount</ref>
                  </metadataExpected>
               </expectation>
            </inputPort>
            <inputPort group="true">
               <name>InvalidIn</name>
               <synopsis>When a packet is sent out of an error port
                  of an LFB in a parallel path will be sent to this
                  output port in the Merger LFB</synopsis>
               <expectation>
                  <frameExpected>
                     <ref>Arbitrary</ref>
                     <ref>Chunk</ref>
                  </frameExpected>
                  <metadataExpected>
                     <one-of>
                        <ref>ExceptionID</ref>
                        <ref>ValidateErrorID</ref>
                     </one-of>
                  </metadataExpected>
               </expectation>
            </inputPort>
         </inputPorts>
         <outputPorts>
            <outputPort>
               <name>PacketOutput</name>
               <synopsis>An output port expecting any kind of frame
               </synopsis>
               <product>
                  <frameProduced>
                     <ref>Arbitrary</ref>
                  </frameProduced>
               </product>
            </outputPort>
         </outputPorts>
         <components>
            <component componentID="1" access="read-write">
               <name>InvalidAction</name>
               <synopsis>What the Merge LFB will do if an invalid
                  chunk or packet is received</synopsis>
               <atomic>
                  <baseType>uchar</baseType>
                  <specialValues>
                     <specialValue value="0">
                        <name>DropAll</name>
                        <synopsis>Drop all packets or chunks
                        </synopsis>
                     </specialValue>
                     <specialValue value="1">
                        <name>Continue</name>
                        <synopsis>Continue with the merge</synopsis>
                     </specialValue>
                  </specialValues>
               </atomic>
            </component>
            <component componentID="2" access="read-write">
               <name>MergeWaitType</name>
               <synopsis>Whether the Merge LFB will wait for all
                  packets or chunks to be received prior to sending
                  out a response</synopsis>
               <typeRef>boolean</typeRef>
            </component>
            <component componentID="3" access="read-reset">
               <name>InvalidMergesCounter</name>
               <synopsis>Counts the number of merges where there is 
                  at least one packet/chunk that entered the merger 
                  LFB through the InvalidIn input port</synopsis>
               <typeRef>uint32</typeRef>
            </component>
            <component componentID="4" access="read-reset">
               <name>InvalidAllCounter</name>
               <synopsis>Counts the number of merges where all
                  packets/chunks entered the merger LFB through the
                  InvalidIn input port</synopsis>
               <typeRef>uint32</typeRef>
            </component>
            <component componentID="5" access="read-reset">
               <name>InvalidIDCounters</name>
               <synopsis>Counts number of invalid merges where at
                  least one packet/chunk entered through InvalidID 
                  per error ID</synopsis>
               <struct>
                  <component componentID="1">
                     <name>InvalidExceptionID</name>
                     <synopsis>Per Exception ID</synopsis>
                     <array>
                        <typeRef>uint32</typeRef>
                     </array>
                  </component>
                  <component componentID="2">
                     <name>InvalidValidateErrorID</name>
                     <synopsis>Per Validate Error ID</synopsis>
                     <array>
                        <typeRef>uint32</typeRef>
                     </array>
                  </component>
               </struct>
            </component>
            <component componentID="6" access="read-reset">
               <name>InvalideMetadataSets</name>
               <synopsis>Buffers metadata sets along with the error
                  id as a string.</synopsis>
               <optional />
               <array>
                  <typeRef>string</typeRef>
               </array>
            </component>
         </components>
         <events baseID="30">
            <event eventID="1">
               <name>ManyInvalids</name>
               <synopsis>An event that specifies if there are too 
                  many invalids</synopsis>
               <eventTarget>
                  <eventField>InvalidCounter</eventField>
               </eventTarget>
               <eventGreaterThan>50</eventGreaterThan>
               <eventReports>
                  <eventReport>
                     <eventField>InvalidMergesCounter</eventField>
                  </eventReport>
               </eventReports>
            </event>
            <event eventID="2">
               <name>ManyAllInvalids</name>
               <synopsis>An event that specifies if there are too 
                  many invalids</synopsis>
               <eventTarget>
                  <eventField>InvalidCounter</eventField>
               </eventTarget>
               <eventGreaterThan>50</eventGreaterThan>
               <eventReports>
                  <eventReport>
                     <eventField>InvalidAllCounter</eventField>
                  </eventReport>
               </eventReports>
            </event>
         </events>
      </LFBClassDef>
   </LFBClassDefs>
</LFBLibrary>
		]]></artwork>
          </figure>
        </t>
    </section>
  <section anchor="Acknowledgements" title="Acknowledgements">
    <t>The authors would like to thank Jamal Hadi Salim for discussions that made this document better.</t>
  </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t></t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC5810;
      &RFC5812;
      &RFC6956;

      <reference anchor="OpenFlowSpec1.1" target="http://www.OpenFlow.org/documents/OpenFlow-spec-v1.1.0.pdf">
        <front>
          <title>The OpenFlow 1.1 Specification.</title>
          <author>
            <organization>http://www.OpenFlow.org/</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

    &RFC2119;
    <reference anchor="Cilc" target="http://supertech.csail.mit.edu/cilk/">
        <front>
          <title>Cilk language</title>
          <author>
            <organization>MIT</organization>
          </author>
          <date/>
        </front>
      </reference>

    </references>

    <!-- Change Log

v00 2009-02-17  EH   Initial version
  -->
  </back>
</rfc>
