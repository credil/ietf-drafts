<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!-- Normative References -->
    <!ENTITY rfc0793 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793.xml">
    <!ENTITY rfc2018 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2018.xml">
    <!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
    <!ENTITY rfc3042 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3042.xml">
    <!ENTITY rfc5681 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5681.xml">
    <!ENTITY rfc6675 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6675.xml">

    <!-- Informative References -->
    <!ENTITY rfc0896 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0896.xml">
    <!ENTITY rfc1122 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1122.xml">
    <!ENTITY rfc2883 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2883.xml">
    <!ENTITY rfc2960 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2960.xml">
    <!ENTITY rfc3465 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3465.xml">
    <!ENTITY rfc3522 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3522.xml">
    <!ENTITY rfc3708 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3708.xml">
    <!ENTITY rfc4015 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4015.xml">
    <!ENTITY rfc5682 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5682.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds
     might want to use. (Here they are set differently than their defaults in
     xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->

<rfc ipr="trust200902" category="exp"
docName="draft-zimmermann-tcpm-rfc4653bis-00" obsoletes="4653">
<!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

    <!-- FRONT MATTER -->
    <front>
        <title abbrev="TCP-aNCR">
        Improving the Robustness of TCP to Non-Congestion Events</title>

        <author initials="A." surname="Zimmermann"
        fullname="Alexander Zimmermann">
            <organization>NetApp, Inc.</organization>
            <address>
                <postal>
                    <street>Sonnenallee 1</street>
                    <city>Kirchheim</city>
                    <code>85551</code>
                    <country>Germany</country>
                </postal>
                <phone>+49 89 900594712</phone>
                <email>alexander.zimmermann@netapp.com</email>
            </address>
        </author>

        <author initials="S." surname="Bhandarkar"
        fullname="Sumitha Bhandarkar">
            <organization abbrev="Texas A&amp;M University">Dept. of Elec.
            Engg., Texas A&amp;M University</organization>
            <address>
                <postal>
                    <street>214 ZACH</street>
                    <city>College Station</city>
                    <region>TX</region>
                    <code>77843-3128</code>
                </postal>
                <email>sumitha@tamu.edu</email>
            </address>
        </author>

        <author initials="A.&nbsp;L.&nbsp;N." surname="Reddy"
        fullname="A. L. Narasimha Reddy">
            <organization abbrev="Texas A&amp;M University"> Dept. of Elec.
            Engg., Texas A&amp;M University</organization>
            <address>
                <postal>
                    <street>315C WERC</street>
                    <city>College Station</city>
                    <region>TX</region>
                    <code>77843-3128</code>
                </postal>
                <email>reddy@ee.tamu.edu</email>
            </address>
        </author>

        <author initials="M." surname="Allman" fullname="Mark Allman">
            <organization abbrev="ICIR/ICSI">ICSI Center for Internet
            Research</organization>
            <address>
                <postal>
                    <street>1947 Center Street, Suite 600</street>
                    <city>Berkeley</city>
                    <region>CA</region>
                    <code>94704-1198</code>
                </postal>
                <phone>(440) 235-1792</phone>
                <email>mallman@icir.org</email>
            </address>
        </author>

        <author initials="E." surname="Blanton" fullname="Blanton">
            <organization abbrev='Purdue University'>Purdue University Computer
            Science</organization>
            <address>
                <postal>
                    <street>305 N. University St.</street>
                    <city>West Lafayette</city>
                    <region>IN</region>
                    <code>47907</code>
                </postal>
                <email>mallman@icir.org</email>
            </address>
        </author>

        <date month="August" year="2013" />

        <!-- Meta-data Declarations -->
        <area>Transport</area>

        <workgroup>TCP Maintenance and Minor Extensions (TCPM) WG</workgroup>

        <keyword>Transmission Control Protocol (TCP), Reordering,
        TCP-NCR</keyword>

    <abstract>
        <t>This document specifies Non-Congestion Robustness (NCR) for TCP. In
        the absence of explicit congestion notification from the network, TCP
        uses loss as an indication of congestion. One of the ways TCP detects
        loss is using the arrival of three duplicate acknowledgments. However,
        this heuristic is not always correct, notably in the case when network
        paths reorder segments (for whatever reason), resulting in degraded
        performance. TCP-NCR is designed to mitigate this degraded performance
        by increasing the number of duplicate acknowledgments required to
        trigger loss recovery, based on the current state of the connection, in
        an effort to better disambiguate true segment loss from segment
        reordering. This document specifies the changes to TCP, as well as the
        costs and benefits of these modifications.</t>
        </abstract>

    </front>

    <!-- MAIN MATTER -->
    <middle>

        <!-- ***** Section: Introduction ***** -->
        <section anchor="intro" title="Introduction">
            <t>One strength of TCP <xref target="RFC0793"/> lies in its ability
            to adjust its sending rate according to the perceived congestion in
            the network <xref target="Jac88"/><xref target="RFC5681"/>. In the
            absence of explicit notification of congestion from the network,
            TCP uses segment loss as an indication of congestion (i.e.,
            assuming queue overflow). TCP receivers send cumulative
            acknowledgments (ACKs) indicating the next sequence number expected
            from the sender for arriving segments <xref target="RFC0793"/>.
            When segments arrive out of order, duplicate ACKs are generated. As
            specified in <xref target="RFC5681"/>, a TCP sender uses the
            arrival of three duplicate ACKs as an indication of segment loss.
            The TCP sender retransmits the lost segment and reduces the load
            imposed on the network, assuming the segment loss was caused by
            resource contention within the network path. The TCP sender does
            not assume loss on the first or second duplicate ACK, but waits for
            three duplicate ACKs to account for minor packet reordering.
            However, the use of this constant threshold of duplicate ACKs has
            several problems that can be mitigated with a dynamic
            threshold.</t>

            <t>The following is an example of TCP's behavior:
                <list style="symbols">
                    <t>TCP A is the data sender, and TCP B is the data
                    receiver.</t>

                    <t>TCP A sends 10 segments, each consisting of a single
                    data byte (i.e., transmits bytes 1-10 in segments
                    1-10).</t>

                    <t>Assume segment 3 is dropped in the network.</t>

                    <t>TCP B cumulatively acknowledges segments 1 and 2, making
                    the cumulative ACK transmitted to the sender 3 (the next
                    expected sequence number). (Note: TCP B may generate one
                    or two ACKs, depending on whether delayed ACKs
                    <xref target="RFC1122"/><xref target="RFC5681"/>
                    are employed.)</t>

                    <t>The arrival of segments 4-10 at TCP B will each trigger
                    the transmission of a cumulative ACK for sequence number 3.
                    (Note: <xref target="RFC5681"/> recommends that delayed
                    ACKs not be used when the ACK is triggered by an
                    out-of-order segment.)</t>

                    <t>When TCP A receives the third duplicate ACK (or fourth
                    ACK overall) for sequence number 3, TCP A will retransmit
                    segment 3 and reduce the sending rate by roughly half (see
                    <xref target="RFC5681"/> for specifics on the congestion
                    control state adjustments).</t>
                </list>
            </t>

            <t>Alternatively, suppose segment 3 was not dropped by the network,
            but rather delayed such that segment 3 arrives at TCP B after
            segment 10. The above scenario will play out in precisely the same
            manner insomuch as a retransmission of segment 3 will be triggered.
            In other words, TCP is not capable of disambiguating this
            reordering event from a segment loss, resulting in an unnecessary
            retransmission and rate reduction.</t>

            <t>The following is the specific motivation behind making TCP
            robust to reordered segments:
                <list style="symbols">
                    <t>A number of Internet measurement studies have shown that
                    packet reordering is not a rare phenomenon
                    <xref target="Pax97"/><xref target="BPS99"/>
                    <xref target="JIDKT03"/><xref target="GPL04"/>. Further,
                    the reordering can be well beyond that required for fast
                    retransmit to be falsely triggered.</t>

                    <t><xref target="BA02"/><xref target="ZKFP03"/> show the
                    negative performance implications that packet reordering
                    has on current TCP.</t>

                    <t>The requirement imposed by TCP for almost in-order
                    packet delivery places a constraint on the design of future
                    technology. Novel routing algorithms, network components,
                    link-layer retransmission mechanisms, and applications
                    could all be looked at with a fresh perspective if TCP were
                    to be more robust to segment reordering. For instance,
                    high-speed packet switches could cause resequencing of
                    packets if TCP were more robust. There has been work
                    proposed in the literature explicitly to ensure that packet
                    ordering is maintained in such switches (e.g.,
                    <xref target="KM02"/>). Also, link-layer mechanisms that
                    attempt to recover from packet corruption by retransmitting
                    could be allowed to reorder packets, and thus increase the
                    chances of local loss repair rather than rely on TCP to
                    repair the loss (and, needlessly reduce its sending rate).
                    Additional examples include multi-path routing, high-delay
                    satellite links, and some of the schemes proposed for a
                    differentiated services architecture. By making TCP more
                    robust to non-congestion events, TCP-NCR may open the
                    design space of the future Internet components.</t>
                </list>
            </t>

            <t>In this document, we specify a set of TCP sender
            modifications to provide Non-Congestion Robustness (NCR) to TCP.
            In particular, these changes are built on top of TCP with selective
            acknowledgments (SACKs) <xref target="RFC2018"/> and the SACK-based
            loss recovery scheme given in <xref target="RFC6675"/>, since SACK
            is widely deployed at this point (<xref target="MAF05"/> indicates
            that 68% of web servers and 88% of web clients utilize SACK as of
            spring 2004).</t>

            <t>Note that the TCP-NCR algorithm provided in this document could
            be easily adapted to SCTP <xref target="RFC2960"/> since SCTP uses
            congestion control algorithms similar to TCP's (and thus has the
            same reordering robustness issues).</t>

            <t>As noted in several places in the remainder of this document,
            we consider TCP-NCR experimental in that more experience with the
            techniques is required before TCP-NCR should be used on a large
            scale on the Internet. We encourage implementation and
            experimentation with TCP-NCR in the hopes of gaining an
            understanding of its suitability for wide-scale deployment.</t>

            <t>The remainder of this document is organized as follows.
            <xref target="ncr"/> provides a high-level description of the
            TCP-NCR mechanisms. In <xref target="algo"/>, we specify the
            TCP-NCR algorithm. <xref target="pro"/>  provides a brief overview
            of the benefits of TCP-NCR, while <xref target="cons"/> discusses
            the drawbacks. <xref target="related"/> discusses related work.
            <xref target="security"/> discusses security concerns.</t>

            <!-- Subsection: Terminology -->
            <section anchor="terminology" title="Terminology">
                <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
                "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
                "OPTIONAL" in this document are to be interpreted as described
                in <xref target="RFC2119" />.</t>

                <t>Readers should be familiar with the TCP terminology (e.g.,
                FlightSize, Pipe) given in <xref target="RFC5681"/> and
                <xref target="RFC6675"/>.</t>
            </section>
        </section>

        <!-- Section: NCR Description -->
        <section anchor="ncr" title="NCR Description">
            <t>As discussed above, in the face of packet reordering, three
            duplicate ACKs may not be enough to disambiguate loss from
            reordering. In this section we provide a non-normative sketch of
            TCP-NCR. The detailed algorithms for implementing Non-Congestion
            Robustness for TCP are presented in the next section.</t>

            <t>The general idea behind TCP-NCR is to increase the threshold
            used to trigger a fast retransmission from the current fixed value
            of three duplicate ACKs <xref target="RFC5681"/> to approximately a
            congestion window of data having left the network (but not less
            than the currently standardized value of three duplicate ACKs).
            Since cwnd represents the amount of data a TCP flow can transmit in
            one round-trip time (RTT), waiting to receive notice that cwnd
            bytes have left the network before deciding whether the root cause
            is loss or reordering imposes a delay of roughly one RTT on both
            the retransmission and the congestion control response. The
            appropriate choice for a new value of the threshold is essentially
            a trade-off between making the best decision regarding the cause of
            the duplicate ACKs and responsiveness. The choice to trigger a
            retransmission only after a cwnd's worth of data is known to have
            left the network represents roughly the largest amount of time a
            TCP can wait before the (often costly) retransmission timeout may
            be triggered. Therefore, the algorithm described in this document
            attempts to make the best decision possible at the expense of
            timeliness.</t>

            <t>Simply increasing the threshold before retransmitting a
            segment can make TCP brittle to packet loss or ACK loss since such
            loss reduces the number of duplicate ACKs that will arrive at the
            sender from the receiver. For instance, if the cwnd is 10 segments
            and one segment is lost, a duplicate ACK threshold of 10 will never
            be met because duplicate ACKs corresponding to at most 9 segments
            will arrive at the sender. To offset the issue of loss, we extend
            TCP's Limited Transmit <xref target="RFC3042"/> scheme to allow for
            the sending of new data during the period when the TCP sender is
            disambiguating loss and reordering. This new data serves to
            increase the likelihood that enough duplicate ACKs arrive at the
            sender to trigger loss recovery if it is appropriate.</t>

            <t>Note that TCP tightly couples reliability and congestion
            control: when a segment is declared lost, a retransmission is
            triggered, and a change to the sending rate is also made on the
            assumption that the drop is due to resource contention
            <xref target="RFC5681"/>. Therefore, simply by changing the
            retransmission trigger, the congestion control response is also
            changed. However, we lack experience on the Internet as to whether
            delaying the point that a rate reduction takes place is appropriate
            for wide-scale deployment. Therefore, the Extended Limited Transmit
            mechanism proposed in this document offers two variants for
            experimentation.</t>

            <t>The first Extended Limited Transmit variant, Careful Limited
            Transmit, calls for the transmission of one previously unsent
            segment, in response to duplicate acknowledgments, for every two
            segments that are known to have left the network. This effectively
            halves the sending rate, since normal TCP operation calls for the
            sending of one segment for every segment that has left the network.
            Further, the halving starts immediately and is not delayed until a
            retransmission is triggered. In the case of packet reordering
            (i.e., not segment loss), the congestion control state is restored
            to its previous state when reordering is determined.</t>

            <t>The second variant, Aggressive Limited Transmit, calls for
            transmitting one previously unsent data segment, in response to
            duplicate acknowledgments, for every segment known to have left the
            network. With this variant, while waiting to disambiguate the loss
            from a reordering event, ACK-clocked transmission continues at
            roughly the same rate as before the event started. Retransmission
            and the sending rate reduction happen per <xref target="RFC5681"/>
            <xref target="RFC6675"/>, albeit with the delayed threshold
            described above. Although this approach delays legitimate rate
            reductions (possibly slightly and temporarily aggravating overall
            congestion on the network), the scheme has the advantage of not
            reducing the transmission rate in the face of segment
            reordering.</t>

            <t>Which of the two Extended Limited Transmit variants is best
            for use on the Internet is an open question.</t>
        </section>

        <!-- Section: Algorithm -->
        <section anchor="algo" title="Algorithm">

            <t>The TCP-NCR modifications make two fundamental changes to the
                way <xref target="RFC6675"/> currently operates, as follows.</t>

            <t>First, the trigger for retransmitting a segment is changed from
            three duplicate ACKs <xref target="RFC5681"/>
            <xref target="RFC6675"/> to indications that a congestion window's
            worth of data has left the network. Second, TCP-NCR decouples
            initial congestion control decisions from retransmission decisions,
            in some cases delaying congestion control changes relative to TCP's
            current behavior as defined in <xref target="RFC5681"/>. The
            algorithm provides two alternatives for extending Limited Transmit.
            The two variants of extended Limited Transmit are:

                <list style="hanging">
                    <t hangText="Careful Limited Transmit">
                    <vspace blankLines="1"/>
                    This variant calls for reducing the sending rate at
                    approximately the same time <xref target="RFC5681"/>
                    implementations reduce the congestion window, while at the
                    same time withholding a retransmission (and the final
                    congestion determination) for approximately one RTT.</t>

                    <t hangText="Aggressive Limited Transmit">
                    <vspace blankLines="1"/>
                    This variant calls for maintaining the sending rate in the
                    face of duplicate ACKs until TCP concludes that a segment
                    is lost and needs to be retransmitted (which TCP-NCR delays
                    by one RTT when compared with current loss recovery
                    schemes).</t>
                </list>
            </t>

            <t>A TCP-NCR implementation MUST use either Careful Limited
            Transmit or Aggressive Limited Transmit.</t>

            <t>A constant MUST be set, depending on which variant of extended
            Limited Transmit is used, as follows:

                <list style="hanging">
                    <t hangText="Careful Limited Transmit">
                    <vspace blankLines="1"/>
                    LT_F = 2/3</t>

                    <t hangText="Aggressive Limited Transmit">
                    <vspace blankLines="1"/>
                    LT_F = 1/2</t>
                </list>
            </t>

            <t>This constant reflects the fraction of outstanding data
            (including data sent during Extended Limited Transmit) that must be
            SACKed before a retransmission is triggered. Since Aggressive
            Limited Transmit sends a new segment for every segment known to
            have left the network, a total of roughly cwnd segments will be
            sent during Aggressive Limited Transmit, and therefore ideally a
            total of roughly 2*cwnd segments will be outstanding when a
            retransmission is triggered. The duplicate ACK threshold is then
            set to LT_F = 1/2 of 2*cwnd (or about 1 RTT worth of data). The
            factor is different for Careful Limited Transmit because the sender
            only transmits one new segment for every two segments that are
            SACKed and therefore will ideally have a total of 1.5*cwnd segments
            outstanding when the retransmission is to be triggered. Hence, the
            required threshold is LT_F=2/3 of 1.5*cwnd to delay the
            retransmission by roughly 1 RTT.</t>

            <t>There are situations whereby the sender cannot transmit new data
            during Extended Limited Transmit (e.g., lack of data from the
            application, receiver's advertised window limit). These situations
            can lead to the problems discussed in the last section when a TCP
            does not employ Extended Limited Transmit and is starved for ACKs.
            Therefore, TCP-NCR adapts the duplicate ACK threshold on each SACK
            arrival to be as robust as possible given the actual amount of data
            that has been transmitted, or roughly LT_F times the number of
            outstanding segments.</t>

            <t>The TCP-NCR modifications specified in this document lend
            themselves to incremental deployment. Only the TCP implementation
            on the sender side requires modification (assuming both hosts
            support SACK). The changes themselves are modest. However, as will
            be discussed below, availability of additional buffer space at the
            receiver will help maximize the benefits of using TCP-NCR but is
            not strictly necessary.</t>

            <t>The following algorithms depend on the notions provided by
            <xref target="RFC6675"/>, and we assume the reader is familiar with
            the terminology given in <xref target="RFC6675"/>. The TCP-NCR
            algorithm can be adapted to alternate SACK- based loss recovery
            schemes. <xref target="BR04"/><xref target="BSRV04"/> outline
            non-SACK-based algorithms; however, we do not specify those
            algorithms in this document and do not recommend them due to both
            the complexity and security implications of having only a gross
            understanding of the number of outstanding segments in the
            network.</t>

            <t>A TCP connection using the Nagle algorithm
            <xref target="RFC0896"/><xref target="RFC1122"/> MAY employ the
            TCP-NCR algorithm. If a TCP implementation does implement TCP-NCR,
            the implementation MUST follow the various specifications provided
            in Sections <xref target="algo:init" format="counter"/> to
            <xref target="algo:recovery" format="counter"/>. If the Nagle
            algorithm is not being used, there is no way to accurately
            calculate the number of outstanding segments in the network (and,
            therefore, no good way to derive an appropriate duplicate ACK
            threshold) without adding state to the TCP sender. A TCP connection
            that does not employ the Nagle algorithm SHOULD NOT use TCP-NCR. We
            envision that NCR could be adapted to an implementation that
            carefully tracks the sequence numbers transmitted in each segment.
            However, we leave this as future work.</t>

            <!-- Subsection: Initialization -->
            <section anchor="algo:init" title="Initialization">
                <t>When entering a period of loss/reordering detection and
                Extended Limited Transmit, a TCP-NCR MUST initialize several
                state variables. A TCP MUST enter Extended Limited Transmit
                upon receiving the first ACK with a SACK block after the
                reception of an ACK that (a) did not contain SACK information
                and (b) did increase the connection's cumulative ACK point.
                The initializations are:</t>

                <t>
                    <list style='format (I.%d)' counter="c:init">
                        <t>The TCP MUST save the current FlightSize.
                            <list style='empty'>
                                <t>FlightSizePrev = FlightSize</t>
                            </list>
                        </t>

                        <t>The TCP MUST set a variable for tracking the number
                        of segments for which an ACK does not trigger a
                        transmission during Careful Limited Transmit.
                            <list style='empty'>
                                <t>Skipped = 0</t>
                            </list>
                        (Note: Skipped is not used during Aggressive
                        Limited Transmit.)</t>

                    <t>The TCP MUST set DupThresh (from
                    <xref target="RFC6675"/>) based on the current FlightSize.
                            <list style='empty'>
                                <t>DupThresh = max (LT_F * (FlightSize /
                                SMSS),3)</t>
                            </list>
                        Note: We keep the lower bound of DupThresh = 3 from
                        <xref target="RFC5681"/>, <xref target="RFC6675"/>.</t>
                    </list>
                </t>

                <t>In addition to the above steps, the incoming ACK MUST be
                processed with the E series of steps in
                <xref target="algo:elt"/>.</t>
            </section>

            <!-- Subsection: Termination -->
            <section anchor="algo:term" title="Terminating Extended Limited
            Transmit and Preventing Bursts">
                <t>Extended Limited Transmit MUST be terminated at the start
                of loss recovery as outlined in
                <xref target="algo:recovery"/>.</t>

                <t>The arrival of an ACK that advances the cumulative ACK
                point while in Extended Limited Transmit, but before loss
                recovery is triggered, signals that a series of duplicate ACKs
                was caused by reordering and not congestion. Therefore, the
                receipt of an ACK that extends the cumulative ACK point MUST
                terminate Extended Limited Transmit. As described below (in
                (T.4)), an ACK that extends the cumulative ACK point and *also*
                contains SACK information will also trigger the beginning of a
                new Extended Limited Transmit phase.</t>

                <t>Upon the termination of Extended Limited Transmit, and
                especially when using the Careful variant, TCP-NCR may be in a
                situation where the entire cwnd is not being utilized, and
                therefore TCP-NCR will be prone to transmitting a burst of
                segments into the network. Therefore, to mitigate this
                bursting when a TCP-NCR in the Extended Limited Transmit phase
                receives an ACK that updates the cumulative ACK point
                (regardless of whether the ACK contains SACK information), the
                following steps MUST be taken:</t>

                <t>
                    <list style='format (T.%d)' counter="c:term">
                        <t>A TCP MUST reset cwnd to:
                            <list style='empty'>
                                <t>cwnd = min (FlightSize + SMSS,
                                FlightSizePrev)</t>
                            </list>
                        This step ensures that cwnd is not grossly larger
                        than the amount of data outstanding, a situation that
                        would cause a line rate burst.</t>

                        <t>A TCP MUST set ssthresh to:
                            <list style='empty'>
                                <t>ssthresh = FlightSizePrev</t>
                            </list>
                        This step provides TCP-NCR with a sense of "history".
                        If step (T.1) reduces cwnd below FlightSizePrev, this
                        step ensures that TCP-NCR will slow start back to the
                        operating point in effect before Extended Limited
                        Transmit.</t>

                        <t>A TCP is now permitted to transmit previously unsent
                        data as allowed by cwnd, FlightSize, application data
                        availability, and the receiver's advertised window.</t>

                        <t>When an incoming ACK extends the cumulative ACK point
                        and also contains SACK information, the initializations
                        in steps (I.2) and (I.3) from
                        <xref target="algo:init"/> MUST be taken (but step
                        (I.1) MUST NOT be executed) to re-start Extended
                        Limited Transmit. In addition, the series of steps in
                        <xref target="algo:elt"/> (the "E" steps) MUST be
                        taken.</t>
                    </list>
                </t>
            </section>

            <!-- Subsection: Extended Limited Transmit -->
            <section anchor="algo:elt" title="Extended Limited Transmit">
                <t>On each ACK containing SACK information that arrives after
                TCP-NCR has entered the Extended Limited Transmit phase (as
                outlined in <xref target="algo:elt"/>) and before Extended
                Limited Transmit terminates, the sender MUST use the following
                procedure.</t>

                <t>
                    <list style='format (E.%d)' counter="c:elt">
                        <t>The SetPipe () procedure from
                        <xref target="RFC6675"/> MUST be used to set the "pipe"
                        variable (which represents the number of bytes still
                        considered "in the network"). Note: the current value
                        of DupThresh MUST be used by SetPipe () to produce an
                        accurate assessment of the amount of data still
                        considered in the network.</t>

                        <t>If the comparison in equation (1), below, holds and
                        there are SMSS bytes of previously unsent data
                        available for transmission, then the sender MUST
                        transmit one segment of SMSS bytes.
                            <list style='empty'>
                                <t>(pipe + Skipped) &lt;= (FlightSizePrev -
                                SMSS)</t>
                            </list>
                        If the comparison in equation (1) does not hold or no
                        new data can be transmitted (due to lack of data from
                        the application or the advertised window limit), skip
                        to step (E.6).</t>

                        <t>Pipe MUST be incremented by SMSS bytes.</t>

                        <t>If using Careful Limited Transmit, Skipped MUST be
                        incremented by SMSS bytes to ensure that the next SMSS
                        bytes of SACKed data processed does not trigger a
                        Limited Transmit transmission (since the goal of
                        Careful Limited Transmit is to send upon receipt of
                        every second duplicate ACK).</t>

                        <t>A TCP MUST return to step (E.2) to ensure that as
                        many bytes as are appropriate are transmitted. This
                        provides robustness to ACK loss that can be (largely)
                        compensated for using SACK information.</t>

                        <t>DupThresh MUST be reset via:
                            <list style='empty'>
                                <t>DupThresh = max (LT_F * (FlightSize /
                                SMSS),3)</t>
                            </list>
                        where FlightSize is the total number of bytes that have
                        not been cumulatively acknowledged (which is different
                        from "pipe").</t>
                    </list>
                </t>
            </section>

            <!-- Subsection: Entering Loss Recovery -->
            <section anchor="algo:recovery" title="Entering Loss Recovery">
                <t>When a segment is deemed lost via the algorithms in
                <xref target="RFC6675"/>, Extended Limited Transmit MUST be
                terminated, leaving the algorithms in <xref target="RFC6675"/>
                to govern TCP's behavior. One slight change to
                <xref target="RFC6675"/> MUST be made, however. In Section 5,
                step (2) of <xref target="RFC6675"/> MUST be changed to:
                    <list style='empty'>
                        <t>ssthresh = cwnd = (FlightSizePrev / 2)</t>
                    </list>
                This ensures that the congestion control modifications are made
                with respect to the amount of data in the network before
                FlightSize was increased by Extended Limited Transmit.</t>

                <t>Note: Once the algorithm in <xref target="RFC6675"/> takes
                over from Extended Limited Transmit, the DupThresh value MUST
                be held constant until the loss recovery phase is
                terminated.</t>
            </section>
        </section>

        <!-- Section: Advantages -->
        <section anchor="pro" title="Advantages">
            <t>The major advantages of TCP-NCR are twofold. As discussed in
            Section 1, TCP-NCR will open up the design space for network
            applications and components that are currently constrained by TCP's
            lack of robustness to packet reordering. The second advantage is
            in terms of an increase in TCP performance.</t>

            <t><xref target="BR04"/> presents ns-2 <xref target="NS-2"/>
            simulations of a pre-cursor to the TCP-NCR algorithm specified in
            this document, called TCP-DCR (Delayed Congestion Response). The
            paper shows that TCP-DCR aids performance in comparison to
            unmodified TCP in the presence of packet reordering. In addition,
            the extended version of <xref target="BR04"/> presents results
            based on emulations involving Linux (kernel 2.4.24). These results
            show that the performance of TCP-DCR is similar to Linux's native
            implementation that seeks to "undo" wrong decisions according to
            duplicate-SACK (DSACK) <xref target="RFC2883"/> feedback (similar
            to the schemes outlined in <xref target="ZKFP03"/>), when packets
            are reordered by less than one RTT. The advantage of using TCP-DCR
            over the DSACK-based scheme is that the DSACK-based scheme tries to
            estimate the exact amount of reordering in the network using fairly
            complex algorithms, whereas TCP-DCR achieves similar results with
            less complicated modifications.</t>

            <t>In addition, <xref target="BR04"/><xref target="BSRV04"/>
            illustrate the ability of TCP-DCR to allow for the improvement of
            other parts of the system. For example, these papers show that
            increasing TCP's robustness to packet reordering allows a novel
            wireless ARQ mechanism to be added at the link-layer. The added
            robustness of the link-layer to channel errors, in turn, increases
            TCP performance by not requiring TCP to retransmit packets that
            were dropped due to corruption (and thus also prevents TCP from
            needlessly reducing the sending rate when retransmitting these
            segments).</t>
        </section>

        <!-- Section: Disadvantages -->
        <section anchor="cons" title="Disadvantages">
            <t>Although all the changes outlined above are implemented in the
            sender, the receiver also potentially has a part to play. In
            particular, TCP-NCR increases the receiver's buffering requirement
            by up to an extra cwnd -- in the case of the TCP sender using
            Aggressive Limited Transmit and actual loss occurring in the
            network. Therefore, to maximize the benefits from TCP-NCR,
            receivers should advertise a large window to absorb the extra
            out-of-order traffic. In the case that the additional buffer
            requirements are not met, the use of the above algorithm takes into
            account the reduced advertised window -- with a corresponding loss
            in robustness to packet reordering.</t>

            <t>In addition, using TCP-NCR could delay the delivery of data to
            the application by up to one RTT because the fast retransmission
            point is delayed by roughly one RTT in TCP-NCR. Applications that
            are sensitive to such delays should turn off the TCP-NCR option.
            For instance, a socket option could be introduced to allow
            applications to control whether NCR would be used for a particular
            connection.</t>

            <t>Finally, the use of TCP-NCR makes the recovery from congestion
            events sluggish in comparison to the standard reaction in
            <xref target="RFC5681"/>. <xref target="BR04"/>
            <xref target="BSRV04"/> show (via simulation) that
            the delay in congestion response has minimal impact on the
            connection itself and the traffic sharing a bottleneck.
            <xref target="BBFS01"/> also indicates (again, via simulation) that
            "slowly responsive" congestion control may be safe for deployment
            in the Internet.  These studies suggest that schemes that slightly
            delay congestion control decisions may be reasonable; however,
            further experimentation on the Internet is required to verify these
            results.</t>
       </section>

        <!-- Section: Related Work -->
        <section anchor="related" title="Related Work">
            <t>Over the past few years, several solutions have been proposed to
            improve the performance of TCP in the face of segment reordering.
            These schemes generally fall into one of two categories (with some
            overlap): mechanisms that try to prevent spurious retransmits from
            happening and mechanisms that try to detect spurious retransmits
            and "undo" the needless congestion control state changes that have
            been taken.</t>

            <t><xref target="BA02"/><xref target="ZKFP03"/> attempt to prevent
            segment reordering from triggering spurious retransmits by using
            various algorithms to approximate the duplicate ACK threshold
            required to disambiguate loss and reordering over a given network
            path at a given time. TCP-NCR similarly tries to prevent spurious
            retransmits. However, TCP-NCR takes a simplified approach compared
            to those in <xref target="BA02"/> <xref target="ZKFP03"/>, in that
            TCP-NCR simply delays retransmission by an amount based on the
            current cwnd (in comparison to standard TCP), while the other
            schemes use relatively complex algorithms in an attempt to derive a
            more precise value for DupThresh that depends on the current
            patterns of packet reordering. While TCP-NCR offers simplicity, the
            other schemes may offer more precision such that applications would
            not be forced to wait as long for their retransmissions. Future
            work could be undertaken to achieve robustness without needless
            delay.</t>

            <t>On the other hand, several schemes have been developed to detect
            and mitigate needless retransmissions after the fact.
            <xref target="RFC3522"/><xref target="RFC3708"/>
            <xref target="BA02"/><xref target="RFC4015"/>
            <xref target="RFC5682"/> present algorithms to detect spurious
            retransmits and mitigate the changes these events made to the
            congestion control state. TCP-NCR could be used in conjunction with
            these algorithms, with TCP-NCR attempting to prevent spurious
            retransmits and some other scheme kicking in if the prevention
            failed. In addition, note that TCP-NCR is concentrated on
            preventing spurious fast retransmits; some of the above algorithms
            also attempt to detect and mitigate spurious timeout-based
            retransmits.</t>
        </section>

        <!-- Section: IANA Considerations -->
        <section anchor="iana" title="IANA Considerations">
            <t>This memo includes no request to IANA.</t>
        </section>

        <!-- Section: Security Considerations -->
        <section anchor="security" title="Security Considerations">
            <t>General attacks against the congestion control of TCP are
            described in <xref target="RFC5681"/>. SACK-based loss recovery for
            TCP <xref target="RFC6675"/> mitigates some of the duplicate ACK
            attacks against TCP's congestion control. This document builds upon
            that work, and the Extended Limited Transmit algorithms specified
            in this document have been designed to thwart the ACK division
            problems that are described in <xref target="RFC3465"/>.</t>
       </section>

        <!-- Section: Acknowledgments -->
        <section anchor="acks" title="Acknowledgments">
            <t>Feedback from Lars Eggert, Ted Faber, Wesley Eddy, Gorry
            Fairhurst, Sally Floyd, Sara Landstrom, Nauzad Sadry, Pasi
            Sarolahti, Joe Touch, Nitin Vaidya, and the TCPM working group have
            contributed significantly to this document. Our thanks to all!</t>
        </section>

    </middle>

    <!-- BACK MATTER -->
    <back>

        <!-- Normative References -->
        <references title="Normative References">
            &rfc0793;
            &rfc2018;
            &rfc2119;
            &rfc3042;
            &rfc5681;
            &rfc6675;
        </references>

        <!-- Informative References -->
        <references title="Informative References">
            &rfc0896;
            &rfc1122;
            &rfc2883;
            &rfc2960;
            &rfc3465;
            &rfc3522;
            &rfc3708;
            &rfc4015;
            &rfc5682;

            <reference anchor="BA02" target="">
                <front>
                    <title>On Making TCP More Robust to Packet Reordering</title>
                    <author surname="Blanton" initials="E."
                        fullname="Ethan Blanton"> <organization />
                    </author>
                    <author surname="Allman" initials="M."
                        fullname="Mark Allman"> <organization />
                    </author>
                    <date year="2002" month="January"/>
                </front>
                <seriesInfo name="ACM Computer Communication Review" value="vol.32,
                no. 1, pp. 20-30" />
            </reference>

            <reference anchor="BBFS01" target="">
                <front>
                    <title>Dynamic Behavior of Slowly Responsive Congestion
                    Control Algorithms</title>
                    <author surname="Bansal" initials="D."
                        fullname="Deepak Bansal"> <organization />
                    </author>
                    <author surname="Balakrishnan" initials="H."
                        fullname="Hari Balakrishnan"> <organization />
                    </author>
                    <author surname="Floyd" initials="S."
                        fullname="Sally FLoyd"> <organization />
                    </author>
                    <author surname="Shenker" initials="S."
                        fullname="Scott Shenker"> <organization />
                    </author>
                    <date year="2001" month="September"/>
                </front>
                <seriesInfo name="Proceedings of the Conference on Applications,
                    Technologies, Architectures, and Protocols for Computer
                    Communication (SIGCOMM'01)" value="pp. 263-274" />
            </reference>

            <reference anchor="BPS99" target="">
                <front>
                    <title>Packet reordering is not pathological network
                    behavior</title>
                    <author surname="Bennett" initials="J."
                        fullname="Jon C. R. Bennett"> <organization />
                    </author>
                    <author surname="Partridge" initials="C."
                        fullname="Craig Partridge"> <organization />
                    </author>
                    <author surname="Shectman" initials="N."
                        fullname="Nicholas Shectman"> <organization />
                    </author>
                    <date year="1999" month="December"/>
                </front>
                <seriesInfo name="IEEE/ACM Transactions on Networking"
                    value="vol.7, no. 6, pp. 789-798" />
            </reference>

            <reference anchor="BSRV04" target="">
                <front>
                    <title>TCP-DCR: A Novel Protocol for Tolerating
                    Wireless Channel Errors</title>
                    <author surname="Bhandarkar" initials="S."
                        fullname="Sumitha Bhandarkar"> <organization />
                    </author>
                    <author surname="Sadry" initials="N. E."
                        fullname="Nauzad Erach Sadry"> <organization />
                    </author>
                    <author surname="Reddy" initials="A. L. N."
                        fullname="A. L. Narasimha Reddy"> <organization />
                    </author>
                    <author surname="Vaidya" initials="N. H."
                        fullname="Nitin H. Vaidya"> <organization />
                    </author>
                    <date year="2005" month="September"/>
                </front>
                <seriesInfo name="IEEE Transactions on Mobile Computing"
                    value="vol. 4, no. 5.,  pp. 517-529" />
            </reference>

            <reference anchor="BR04" target="">
                <front>
                    <title>TCP-DCR: Making TCP Robust to Non-Congestion
                    Events</title>
                    <author surname="Bhandarkar" initials="S."
                        fullname="Sumitha Bhandarkar"> <organization />
                    </author>
                    <author surname="Reddy" initials="A. L. N."
                        fullname="A. L. Narasimha Reddy"> <organization />
                    </author>
                    <date year="2004" month="May"/>
                </front>
                <seriesInfo name="NETWORKING 2004. Networking Technologies,
                    Services, and Protocols; Performance of Computer and
                    Communication Networks; Mobile and Wireless
                    Communications" value="pp. 712-724" />
            </reference>

            <reference anchor="GPL04" target="">
                <front>
                    <title>Packet Reordering, High Speed Networks and
                        Transport Protocol Performance </title>
                    <author surname="Gharai" initials="L."
                        fullname="Ladan Gharai"> <organization />
                    </author>
                    <author surname="Perkins" initials="C."
                        fullname="Colin Perkins"> <organization />
                    </author>
                    <author surname="Lehman" initials="T."
                        fullname="Tom Lehman"> <organization />
                    </author>
                    <date year="2004" month="October"/>
                </front>
                <seriesInfo name="Proceedings of the 13th IEEE International
                    Conference on Computer Communications and Networks
                    (ICCCN'04)" value="pp. 73-78" />
            </reference>

            <reference anchor="Jac88" target="">
                <front>
                    <title>Improving Round-Trip Time Estimates in Reliable
                        Transport Protocols
                    </title>
                    <author surname="Jacobson" initials="V."
                        fullname="Van Jacobson"> <organization />
                    </author>
                    <date year="1988" month="August"/>
                </front>
                <seriesInfo name="Proceedings of the ACM Symposium on
                    Communications Architectures and Protocols
                    (SIGCOMM'88)" value="pp. 314-329" />
            </reference>

            <reference anchor="JIDKT03" target="">
                <front>
                    <title>Measurement and Classification of Out-of-Sequence
                    Packets in a Tier-1 IP Backbone</title>
                    <author surname="Jaiswal" initials="S."
                        fullname="Sharad Jaiswal"> <organization />
                    </author>
                    <author surname="Iannaccone" initials="G."
                        fullname="Gianluca Iannaccone"> <organization />
                    </author>
                    <author surname="Diot" initials="C."
                        fullname="Christophe Diot"> <organization />
                    </author>
                    <author surname="Kurose" initials="J."
                        fullname="Jim Kurose"> <organization />
                    </author>
                    <author surname="Towsley" initials="D."
                        fullname="Don Towsley"> <organization />
                    </author>
                    <date year="2007" month="February"/>
                </front>
                <seriesInfo name="IEEE/ACM Transactions on Networking"
                    value="vol. 15, no. 1, pp. 54-66" />
            </reference>

            <reference anchor="KM02" target="">
                <front>
                    <title>Maintaining packet order in twostage switches</title>
                    <author surname="Keslassy" initials="I."
                        fullname="Isaac Keslassy"> <organization />
                    </author>
                    <author surname="McKeown" initials="N."
                        fullname="Nick McKeown"> <organization />
                    </author>
                    <date year="2002" month="June"/>
                </front>
                <seriesInfo name="Proceedings of the 21st Annual Joint Conference
                    of the IEEE Computer and Communications Societies (INFOCOM'02)"
                    value="pp. 1032-1041" />
            </reference>

            <reference anchor="MAF05" target="">
                <front>
                    <title>Measuring the Evolution of Transport Protocols in the
                    Internet</title>
                    <author surname="Medina" initials="A."
                        fullname="Alberto Medina"> <organization />
                    </author>
                    <author surname="Allman" initials="M."
                        fullname="Mark Allman"> <organization />
                    </author>
                    <author surname="Floyd" initials="S."
                        fullname="Sally FLoyd"> <organization />
                    </author>
                    <date year="2005" month="April"/>
                </front>
                <seriesInfo name="SIGCOMM Computer Communication Review"
                    value="vol. 35, no. 2, pp. 37-51" />
            </reference>

            <reference anchor="NS-2" target="http://www.isi.edu/nsnam/">
                <front>
                    <title>ns-2 Network Simulator</title>
                    <author />
                    <date />
                </front>
            </reference>

            <reference anchor="Pax97" target="">
                <front>
                    <title>End-to-End Internet Packet Dynamics</title>
                    <author surname="Paxson" initials="V."
                        fullname="Vern Paxson"> <organization />
                    </author>
                    <date year="1997" month="June"/>
                </front>
                <seriesInfo name="IEEE/ACM Transactions on Networking"
                    value="vol. 7, no.3, pp. 277-292" />
            </reference>

            <reference anchor="ZKFP03" target="">
                <front>
                    <title>RR-TCP: A Reordering-Robust TCP with
                    DSACK</title>
                    <author surname="Zhang" initials="M."
                        fullname="Ming Zhang"> <organization />
                    </author>
                    <author surname="Karp" initials="B."
                        fullname="Brad Karp"> <organization />
                    </author>
                    <author surname="Floyd" initials="S."
                        fullname="Sally Floyd"> <organization />
                    </author>
                    <author surname="Peterson" initials="L."
                        fullname="Larry Peterson"> <organization />
                    </author>
                    <date year="2003" month="November"/>
                </front>
                <seriesInfo name="Proceedings of the 11th IEEE
                    International Conference on Network Protocols
                    (ICNP'03)" value="pp. 95-106" />
            </reference>
        </references>

        <!-- Section: Changes from previous versions of the draft -->
        <section anchor="changes" title="Changes from previous versions of the draft">
            <t>This appendix should be removed by the RFC Editor before
            publishing this document as an RFC.</t>

            <section anchor="changes_01" title="Changes from RFC 4653">
                <t>
                    <list style="symbols">
                        <t>Only small editorial changes are made comparing to
                        RFC4653. Technical changes will be made in upcomming
                        versions of this document.</t>
                    </list>
                </t>
            </section>
        </section>
    </back>
</rfc>
