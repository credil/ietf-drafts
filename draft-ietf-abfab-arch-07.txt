



ABFAB                                                         J. Howlett
Internet-Draft                                                 JANET(UK)
Intended status: Informational                                S. Hartman
Expires: January 31, 2014                              Painless Security
                                                           H. Tschofenig
                                                  Nokia Siemens Networks
                                                                 E. Lear
                                                      Cisco Systems GmbH
                                                               J. Schaad
                                                 Soaring Hawk Consulting
                                                           July 30, 2013


      Application Bridging for Federated Access Beyond Web (ABFAB)
                              Architecture
                      draft-ietf-abfab-arch-07.txt

Abstract

   Over the last decade a substantial amount of work has occurred in the
   space of federated access management.  Most of this effort has
   focused on two use cases: network access and web-based access.
   However, the solutions to these use cases that have been proposed and
   deployed tend to have few common building blocks in common.

   This memo describes an architecture that makes use of extensions to
   the commonly used security mechanisms for both federated and non-
   federated access management, including the Remote Authentication Dial
   In User Service (RADIUS) and the Diameter protocol, the Generic
   Security Service (GSS), the Extensible Authentication Protocol (EAP)
   and the Security Assertion Markup Language (SAML).  The architecture
   addresses the problem of federated access management to primarily
   non-web-based services, in a manner that will scale to large numbers
   of identity providers, relying parties, and federations.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.







Howlett, et al.         Expires January 31, 2014                [Page 1]

Internet-Draft             ABFAB Architecture                  July 2013


   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on January 31, 2014.

Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   5
       1.1.1.  Channel Binding . . . . . . . . . . . . . . . . . . .   6
     1.2.  An Overview of Federation . . . . . . . . . . . . . . . .   7
     1.3.  Challenges for Contemporary Federation  . . . . . . . . .  10
     1.4.  An Overview of ABFAB-based Federation . . . . . . . . . .  11
     1.5.  Design Goals  . . . . . . . . . . . . . . . . . . . . . .  14
   2.  Architecture  . . . . . . . . . . . . . . . . . . . . . . . .  14
     2.1.  Relying Party to Identity Provider  . . . . . . . . . . .  16
       2.1.1.  AAA, RADIUS and Diameter  . . . . . . . . . . . . . .  17
       2.1.2.  Discovery and Rules Determination . . . . . . . . . .  18
       2.1.3.  Routing and Technical Trust . . . . . . . . . . . . .  19
       2.1.4.  AAA Security  . . . . . . . . . . . . . . . . . . . .  20
       2.1.5.  SAML Assertions . . . . . . . . . . . . . . . . . . .  21
     2.2.  Client To Identity Provider . . . . . . . . . . . . . . .  23
       2.2.1.  Extensible Authentication Protocol (EAP)  . . . . . .  23
       2.2.2.  EAP Channel Binding . . . . . . . . . . . . . . . . .  25
     2.3.  Client to Relying Party . . . . . . . . . . . . . . . . .  25
       2.3.1.  GSS-API . . . . . . . . . . . . . . . . . . . . . . .  26
       2.3.2.  Protocol Transport  . . . . . . . . . . . . . . . . .  27
       2.3.3.  Reauthentication  . . . . . . . . . . . . . . . . . .  27
   3.  Application Security Services . . . . . . . . . . . . . . . .  28
     3.1.  Authentication  . . . . . . . . . . . . . . . . . . . . .  28
     3.2.  GSS-API Channel Binding . . . . . . . . . . . . . . . . .  29



Howlett, et al.         Expires January 31, 2014                [Page 2]

Internet-Draft             ABFAB Architecture                  July 2013


     3.3.  Host-Based Service Names  . . . . . . . . . . . . . . . .  30
     3.4.  Additional GSS-API Services . . . . . . . . . . . . . . .  32
   4.  Privacy Considerations  . . . . . . . . . . . . . . . . . . .  32
     4.1.  Entities and their roles  . . . . . . . . . . . . . . . .  33
     4.2.  Privacy Aspects of ABFAB Communication Flows  . . . . . .  34
       4.2.1.  Client to RP  . . . . . . . . . . . . . . . . . . . .  34
       4.2.2.  Client to IdP (via Federation Substrate)  . . . . . .  35
       4.2.3.  IdP to RP (via Federation Substrate)  . . . . . . . .  36
     4.3.  Relationship between User and Entities  . . . . . . . . .  37
     4.4.  Accounting Information  . . . . . . . . . . . . . . . . .  37
     4.5.  Collection and retention of data and identifiers  . . . .  37
     4.6.  User Participation  . . . . . . . . . . . . . . . . . . .  38
   5.  Security Considerations . . . . . . . . . . . . . . . . . . .  38
   6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  39
   7.  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  39
   8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  40
     8.1.  Normative References  . . . . . . . . . . . . . . . . . .  40
     8.2.  Informative References  . . . . . . . . . . . . . . . . .  41
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  43

1.  Introduction

   The Internet uses numerous security mechanisms to manage access to
   various resources.  These mechanisms have been generalized and scaled
   over the last decade through mechanisms such as Simple Authentication
   and Security Layer (SASL) with the Generic Security Server
   Application Program Interface (GSS-API) (known as the GS2 family)
   [RFC5801], Security Assertion Markup Language (SAML)
   [OASIS.saml-core-2.0-os], and the Authentication, Authorization, and
   Accounting (AAA) architecture as embodied in RADIUS [RFC2865] and
   Diameter [RFC3588].

   A Relying Party (RP) is the entity that manages access to some
   resource.  The entity that is requesting access to that resource is
   often described as the Client.  Many security mechanisms are
   manifested as an exchange of information between these entities.  The
   RP is therefore able to decide whether the Client is authorized, or
   not.

   Some security mechanisms allow the RP to delegate aspects of the
   access management decision to an entity called the Identity Provider
   (IdP).  This delegation requires technical signaling, trust and a
   common understanding of semantics between the RP and IdP.  These
   aspects are generally managed within a relationship known as a
   'federation'.  This style of access management is accordingly
   described as 'federated access management'.





Howlett, et al.         Expires January 31, 2014                [Page 3]

Internet-Draft             ABFAB Architecture                  July 2013


   Federated access management has evolved over the last decade through
   specifications like SAML [OASIS.saml-core-2.0-os], OpenID [1], OAuth
   [RFC5849], [I-D.ietf-oauth-v2] and WS-Trust [WS-TRUST].  The benefits
   of federated access management include:

   Single or Simplified sign-on:

      An Internet service can delegate access management, and the
      associated responsibilities such as identity management and
      credentialing, to an organization that already has a long-term
      relationship with the Client.  This is often attractive as Relying
      Parties frequently do not want these responsibilities.  The Client
      also requires fewer credentials, which is also desirable.

      Data Minimization and User Participation:

      Often a Relying Party does not need to know the identity of a
      Client to reach an access management decision.  It is frequently
      only necessary for the Relying Party know specific attributes
      about the client, for example, that the client is affiliated with
      a particular organization or has a certain role or entitlement.
      Sometimes the RP only needs to know a pseudonym of the client.

      Prior to the release of attributes to the RP from the IdP, the IdP
      will check configuration and policy to determine if the attributes
      are to be released.  There is currently no direct client
      participation in this decision.

   Provisioning:

      Sometimes a Relying Party needs, or would like, to know more about
      a client than an affiliation or a pseudonym.  For example, a
      Relying Party may want the Client's email address or name.  Some
      federated access management technologies provide the ability for
      the IdP to supply this information, either on request by the RP or
      unsolicited.

   This memo describes the Application Bridging for Federated Access
   Beyond the Web (ABFAB) architecture.  This architecture makes use of
   extensions to the commonly used security mechanisms for both
   federated and non-federated access management, including the RADIUS
   and the Diameter protocols, the Generic Security Service (GSS), the
   Extensible Authentication Protocol (EAP) and SAML.  The architecture
   addresses the problem of federated access management primarily for
   non-web-based services.  It does so in a manner that will scale to
   large numbers of identity providers, relying parties, and
   federations.




Howlett, et al.         Expires January 31, 2014                [Page 4]

Internet-Draft             ABFAB Architecture                  July 2013


1.1.  Terminology

   This document uses identity management and privacy terminology from
   [I-D.iab-privacy-considerations].  In particular, this document uses
   the terms identity provider, relying party, identifier, pseudonymity,
   unlinkability, and anonymity.

   In this architecture the IdP consists of the following components: an
   EAP server, a RADIUS or a Diameter server, and optionally a SAML
   Assertion service.

   This document uses the term Network Access Identifier (NAI), as
   defined in [I-D.ietf-radext-nai].  An NAI consists of a realm
   identifier, which is associated with an IdP and a username which is
   associated with a specific client of the IdP.

   One of the problems people will find with reading this document is
   that the terminology sometimes appears to be inconsistent.  This is
   due the fact that the terms used by the different standards we are
   referencing are not consistent.  In general the document uses either
   a the ABFAB term or the term associated with the standard under
   discussion as appropriate.  For reference we include this table which
   maps the different terms into a single table.

   +--------------+--------------+-----------------+-------------------+
   | Protocol     | Client       | Relying Party   | Identity Provider |
   +--------------+--------------+-----------------+-------------------+
   | ABFAB        | Client       | Relying Party   | Identity Provider |
   |              |              | (RP)            | (IdP)             |
   |              |              |                 |                   |
   |              | Initiator    | Acceptor        |                   |
   |              |              |                 |                   |
   |              |              | Server          |                   |
   |              |              |                 |                   |
   | SAML         | Subject      | Service         | Issuer            |
   |              |              | Provider        |                   |
   |              |              |                 |                   |
   | GSS-API      | Initiator    | Acceptor        |                   |
   |              |              |                 |                   |
   | EAP          | EAP peer     |                 | EAP server        |
   |              |              |                 |                   |
   | AAA          |              | AAA Client      | AAA server        |
   |              |              |                 |                   |
   | RADIUS       | user         | NAS             | RADIUS server     |
   |              |              |                 |                   |
   |              |              | RADIUS client   |                   |
   +--------------+--------------+-----------------+-------------------+




Howlett, et al.         Expires January 31, 2014                [Page 5]

Internet-Draft             ABFAB Architecture                  July 2013


   Note that in some cases a cell has been left empty; in these cases
   there is no name that represents the entity.

1.1.1.  Channel Binding

   This document uses the term channel binding with two different
   meanings.

   EAP channel binding is used to provide GSS-API naming semantics.
   Channel binding sends a set of attributes from the peer to the EAP
   server either as part of the EAP conversation or as part of a secure
   association protocol.  In addition, attributes are sent in the
   backend protocol from the authenticator to the EAP server.  The EAP
   server confirms the consistency of these attributes and provides the
   confirmation back to the peer.  In this document, channel binding
   without qualification refers to EAP channel binding.

   GSS-API channel binding provides protection against man-in-the-middle
   attacks when GSS-API is used for authentication inside of some
   tunnel; it is similar to a facility called cryptographic binding in
   EAP.  The binding works by each side deriving a cryptographic value
   from the tunnel itself and then using that cryptographic value to
   prove to the other side that it knows the value.

   See [RFC5056] for a discussion of the differences between these two
   facilities.  However, the difference can be summarized as GSS-API
   channel binding says that there is nobody between the client and the
   authenticator while EAP channel binding allows the client to have
   knowledge about attributes of the authenticator (such as it's name).






















Howlett, et al.         Expires January 31, 2014                [Page 6]

Internet-Draft             ABFAB Architecture                  July 2013


   Typically when considering channel binding, people think of channel
   binding in combination with mutual authentication.  This is
   sufficiently common that without additional qualification channel
   binding should be assumed to imply mutual authentication.  Without
   mutual authentication, only one party knows that the endpoints are
   correct.  That's sometimes useful.  Consider for example a user who
   wishes to access a protected resource from a shared whiteboard in a
   conference room.  The whiteboard is the initiator; it does not need
   to actually authenticate that it is talking to the correct resource
   because the user will be able to recognize whether the displayed
   content is correct.  If channel binding is used without mutual
   authentication, it is effectively a request to disclose the resource
   in the context of a particular channel.  Such an authentication would
   be similar in concept to a holder-of-key SAML assertion.  However,
   also note that while it is not happening in the protocol, mutual
   authentication is happening in the overall system: the user is able
   to visually authenticate the content.  This is consistent with all
   uses of channel binding without protocol level mutual authentication
   found so far.

1.2.  An Overview of Federation

   In the previous section we introduced the following entities:

   o  the Client,

   o  the Identity Provider, and

   o  the Relying Party.

   The final entity that needs to be introduced is the Individual.  An
   Individual is a human being that is using the Client.  In any given
   situation, an Individual may or may not exist.  Clients can act
   either as front ends for Individuals or they may be independent
   entities that are setup and allowed to run autonomously.  An example
   of such an entity can be found in the trust routing protocol where
   the routers use ABFAB to authenticate to each other.

   These entities and their relationships are illustrated graphically in
   Figure 1.


    ,----------\                        ,---------\
    | Identity |       Federation       | Relying |
    | Provider +  <-------------------> + Party   |
    `----------'                        '---------'
           <
            \



Howlett, et al.         Expires January 31, 2014                [Page 7]

Internet-Draft             ABFAB Architecture                  July 2013


             \ Authentication
              \
               \
                \
                 \
                  \  +---------+
                   \ |         |  O
                    v| Client  | \|/ Individual
                     |         |  |
                     +---------+ / \

                Figure 1: Entities and their Relationships

   The relationships between the entities in Figure 1 are:

   Federation

      The Identity Provider and the Relying Parties are part of a
      Federation.  The relationship may be direct (they have an explicit
      trust relationship) or transitive (the trust relationship is
      mediated by one or more entities).  The federation relationship is
      governed by a federation agreement.  Within a single federation,
      there may be multiple Identity Providers as well as multiple
      Relying Parties.  A federation is governed by a federation
      agreement.

   Authentication

      There is a direct relationship between the Client and the Identity
      Provider by which the entities trust and can securely authenticate
      each other.

   A federation agreement typically encompasses operational
   specifications and legal rules:

   Operational Specifications:

      These include the technical specifications (e.g. protocols used to
      communicate between the three parties), process standards,
      policies, identity proofing, credential and authentication
      algorithm requirements, performance requirements, assessment and
      audit criteria, etc.  The goal of operational specifications is to
      provide enough definition that the system works and
      interoperability is possible.

   Legal Rules:





Howlett, et al.         Expires January 31, 2014                [Page 8]

Internet-Draft             ABFAB Architecture                  July 2013


      The legal rules take the legal framework into consideration and
      provide contractual obligations for each entity.  The rules define
      the responsibilities of each party and provide further
      clarification of the operational specifications.  These legal
      rules regulate the operational specifications, make operational
      specifications legally binding to the participants, define and
      govern the rights and responsibilities of the participants.  The
      legal rules may, for example, describe liability for losses,
      termination rights, enforcement mechanisms, measures of damage,
      dispute resolution, warranties, etc.

   The Operational Specifications can demand the usage of a
   sophisticated technical infrastructure, including requirements on the
   message routing intermediaries, to offer the required technical
   functionality.  In other environments, the Operational Specifications
   require fewer technical components in order to meet the required
   technical functionality.

   The Legal Rules include many non-technical aspects of federation,
   such as business practices and legal arrangements, which are outside
   the scope of the IETF.  The Legal Rules can still have an impact on
   the architectural setup or on how to ensure the dynamic establishment
   of trust.

   While a federation agreement is often discussed within the context of
   formal relationships, such as between an enterprise and an employee
   or a government and a citizen, a federation agreement does not have
   to require any particular level of formality.  For an IdP and a
   Client, it is sufficient for a relationship to be established by
   something as simple as using a web form and confirmation email.  For
   an IdP and an RP, it is sufficient for the IdP to publish contact
   information along with a public key and for the RP to use that data.
   Within the framework of ABFAB, it will generally be required that a
   mechanism exists for the IdP to be able to trust the identity of the
   RP, if this is not present then the IdP cannot provide the assurances
   to the client that the identity of the RP has been established.

   The nature of federation dictates that there is some form of
   relationship between the identity provider and the relying party.
   This is particularly important when the relying party wants to use
   information obtained from the identity provider for access management
   decisions and when the identity provider does not want to release
   information to every relying party (or only under certain
   conditions).

   While it is possible to have a bilateral agreement between every IdP
   and every RP; on an Internet scale this setup requires the
   introduction of the multi-lateral federation concept, as the



Howlett, et al.         Expires January 31, 2014                [Page 9]

Internet-Draft             ABFAB Architecture                  July 2013


   management of such pair-wise relationships would otherwise prove
   burdensome.

   The IdP will typically have a long-term relationship with the Client.
   This relationship typically involves the IdP positively identifying
   and credentialing the Client (for example, at time of employment
   within an organization).  When dealing with individuals, this process
   is called identity proofing [NIST-SP.800-63].  The relationship will
   often be instantiated within an agreement between the IdP and the
   Client (for example, within an employment contract or terms of use
   that stipulates the appropriate use of credentials and so forth).

   The nature and quality of the relationship between the Client and the
   IdP is an important contributor to the level of trust that an RP may
   attribute to an assertion describing a Client made by an IdP.  This
   is sometimes described as the Level of Assurance [NIST-SP.800-63].

   Federation does not require an a priori relationship or a long-term
   relationship between the RP and the Client; it is this property of
   federation that yields many of its benefits.  However, federation
   does not preclude the possibility of a pre-existing relationship
   between the RP and the Client, nor that they may use the introduction
   to create a new long-term relationship independent of the federation.

   Finally, it is important to reiterate that in some scenarios there
   might indeed be an Individual behind the Client and in other cases
   the Client may be autonomous.

1.3.  Challenges for Contemporary Federation

   As the number of federated services has proliferated, the role of the
   individual can become ambiguous in certain circumstances.  For
   example, a school might provide online access for a student's grades
   to their parents for review, and to the student's teacher for
   modification.  A teacher who is also a parent must clearly
   distinguish her role upon access.

   Similarly, as the number of federations proliferates, it becomes
   increasingly difficult to discover which identity provider(s) a user
   is associated with.  This is true for both the web and non-web case,
   but is particularly acute for the latter as many non-web
   authentication systems are not semantically rich enough on their own
   to allow for such ambiguities.  For instance, in the case of an email
   provider, the use of SMTP and IMAP protocols do not have the ability
   for the server to get additional information, beyond the clients NAI,
   in order to provide additional input to decide between multiple
   federations it may be associated with.  However, the building blocks
   do exist to add this functionality.



Howlett, et al.         Expires January 31, 2014               [Page 10]

Internet-Draft             ABFAB Architecture                  July 2013


1.4.  An Overview of ABFAB-based Federation

   The previous section described the general model of federation, and
   the application of access management within the federation.  This
   section provides a brief overview of ABFAB in the context of this
   model.

   In this example, a client is attempting to connect to a server in
   order to either get access to some data or perform some type of
   transaction.  In order for the client to mutually authenticate with
   the server, the following steps are taken in an ABFAB federated
   architecture:

   1.   Client Configuration: The Client Application is configured with
        an NAI assigned by the IdP.  It is also configured with any
        keys, certificates, passwords or other secret and public
        information needed to run the EAP protocols between it and the
        IdP.

   2.   Authentication mechanism selection: The GSS-EAP GSS-API
        mechanism is selected for authentication/authorization.

   3.   Client provides an NAI to RP: The client application sets up a
        transport to the RP and begins the GSS-EAP authentication.  In
        response, the RP sends an EAP request message (nested in the
        GSS-EAP protocol) asking for the Client's name.  The Client
        sends an EAP response with an NAI name form that, at a minimum,
        contains the realm portion of its full NAI.

   4.   Discovery of federated IdP: The RP uses pre-configured
        information or a federation proxy to determine what IdP to use
        based on policy and the realm portion of the provided Client
        NAI.  This is discussed in detail below (Section 2.1.2).

   5.   Request from Relying Party to IdP: Once the RP knows who the IdP
        is, it (or its agent) will send a RADIUS/Diameter request to the
        IdP.  The RADIUS/Diameter access request encapsulates the EAP
        response.  At this stage, the RP will likely have no idea who
        the client is.  The RP sends its identity to the IdP in AAA
        attributes, and it may send a SAML Attribute Requests in a AAA
        attribute.  The AAA network checks that the identity claimed by
        the RP is valid.

   6.   IdP begins EAP with the client: The IdP sends an EAP message to
        the client with an EAP method to be used.  The IdP SHOULD NOT
        re-request the clients name in this message, but clients need to
        be able to handle it.  In this case the IdP MUST accept a realm
        only in order to protect the client's name from the RP.  The



Howlett, et al.         Expires January 31, 2014               [Page 11]

Internet-Draft             ABFAB Architecture                  July 2013


        available and appropriate methods are discussed below in this
        memo (Section 2.2.1).

   7.   The EAP protocol is run: A bunch of EAP messages are passed
        between the client (EAP peer) and the IdP (EAP server), until
        the result of the authentication protocol is determined.  The
        number and content of those messages depends on the EAP method
        selected.  If the IdP is unable to authenticate the client, the
        IdP sends a EAP failure message to the RP.  As part of the EAP
        protocol, the client sends a channel bindings EAP message to the
        IdP (Section 2.2.2).  In the channel binding message the client
        identifies, among other things, the RP to which it is attempting
        to authenticate.  The IdP checks the channel binding data from
        the client with that provided by the RP via the AAA protocol.
        If the bindings do not match the IdP sends an EAP failure
        message to the RP.

   8.   Successful EAP Authentication: At this point, the IdP (EAP
        server) and client (EAP peer) have mutually authenticated each
        other.  As a result, the client and the IdP hold two
        cryptographic keys: a Master Session Key (MSK), and an Extended
        MSK (EMSK).  At this point the client has a level of assurance
        about the identity of the RP based on the name checking the IdP
        has done using the RP naming information from the AAA framework
        and from the client (by the channel binding data).

   9.   Local IdP Policy Check: At this stage, the IdP checks local
        policy to determine whether the RP and client are authorized for
        a given transaction/service, and if so, what if any, attributes
        will be released to the RP.  If the IdP gets a policy failure,
        it sends an EAP failure message to the RP.[[Should this be an
        EAP failure to the client as well?]] (The RP will have done its
        policy checks during the discovery process.)

   10.  IdP provide the RP with the MSK: The IdP sends a positive result
        EAP to the RP, along with an optional set of AAA attributes
        associated with the client (usually as one or more SAML
        assertions).  In addition, the EAP MSK is returned to the RP.

   11.  RP Processes Results: When the RP receives the result from the
        IdP, it should have enough information to either grant or refuse
        a resource access request.  It may have information that
        associates the client with specific authorization identities.
        If additional attributes are needed from the IdP the RP may make
        a new SAML Request to the IdP.  It will apply these results in
        an application-specific way.





Howlett, et al.         Expires January 31, 2014               [Page 12]

Internet-Draft             ABFAB Architecture                  July 2013


   12.  RP returns results to client: Once the RP has a response it must
        inform the client application of the result.  If all has gone
        well, all are authenticated, and the application proceeds with
        appropriate authorization levels.  The client can now complete
        the authentication of the RP by the use of the EAP MSK value.

   An example communication flow is given below:

       Relying           Client        Identity
       Party            App          Provider

       |              (1)             | Client Configuration
       |               |              |
       |<-----(2)----->|              | Mechanism Selection
       |               |              |
       |<-----(3)-----<|              | NAI transmitted to RP
       |               |              |
       |<=====(4)====================>| Discovery
       |               |              |
       |>=====(5)====================>| Access request from RP to IdP
       |               |              |
       |               |< - - (6) - -<| EAP method to Client
       |               |              |
       |               |< - - (7) - ->| EAP Exchange to authenticate
       |               |              | Client
       |               |              |
       |               |           (8 & 9) Local Policy Check
       |               |              |
       |<====(10)====================<| IdP Assertion to RP
       |               |              |
       (11)              |              | RP processes results
       |               |              |
       |>----(12)----->|              | Results to client app.



       ----- = Between Client App and RP
       ===== = Between RP and IdP
       - - - = Between Client App and IdP












Howlett, et al.         Expires January 31, 2014               [Page 13]

Internet-Draft             ABFAB Architecture                  July 2013


1.5.  Design Goals

   Our key design goals are as follows:

   o  Each party of a transaction will be authenticated, although
      perhaps not identified, and the client will be authorized for
      access to a specific resource.

   o  Means of authentication is decoupled so as to allow for multiple
      authentication methods.

   o  The architecture requires no sharing of long term private keys
      between clients and servers.

   o  The system will scale to large numbers of identity providers,
      relying parties, and users.

   o  The system will be designed primarily for non-Web-based
      authentication.

   o  The system will build upon existing standards, components, and
      operational practices.

   Designing new three party authentication and authorization protocols
   is hard and fraught with risk of cryptographic flaws.  Achieving
   widespread deployment is even more difficult.  A lot of attention on
   federated access has been devoted to the Web.  This document instead
   focuses on a non-Web-based environment and focuses on those protocols
   where HTTP is not used.  Despite the increased excitement for
   layering every protocol on top of HTTP there are still a number of
   protocols available that do not use HTTP-based transports.  Many of
   these protocols are lacking a native authentication and authorization
   framework of the style shown in Figure 1.

2.  Architecture

   We have already introduced the federated access architecture, with
   the illustration of the different actors that need to interact, but
   did not expand on the specifics of providing support for non-Web
   based applications.  This section details this aspect and motivates
   design decisions.  The main theme of the work described in this
   document is focused on re-using existing building blocks that have
   been deployed already and to re-arrange them in a novel way.

   Although this architecture assumes updates to the relying party, the
   client application, and the Identity Provider, those changes are kept
   at a minimum.  A mechanism that can demonstrate deployment benefits
   (based on ease of update of existing software, low implementation



Howlett, et al.         Expires January 31, 2014               [Page 14]

Internet-Draft             ABFAB Architecture                  July 2013


   effort, etc.) is preferred and there may be a need to specify
   multiple mechanisms to support the range of different deployment
   scenarios.

   There are a number of ways for encapsulating EAP into an application
   protocol.  For ease of integration with a wide range of non-Web based
   application protocols the usage of the GSS-API was chosen.  A
   description of the technical specification can be found in
   [I-D.ietf-abfab-gss-eap].

   The architecture consists of several building blocks, which is shown
   graphically in Figure 2.  In the following sections, we discuss the
   data flow between each of the entities, the protocols used for that
   data flow and some of the trade-offs made in choosing the protocols.

                                    +--------------+
                                    |   Identity   |
                                    |   Provider   |
                                    |    (IdP)     |
                                    +-^----------^-+
                                      * EAP      o RADIUS/
                                      *          o Diameter
                                    --v----------v--
                                 ///                \\\
                               //                      \\
                              |        Federation        |
                              |        Substrate         |
                               \\                      //
                                 \\\                ///
                                    --^----------^--
                                      * EAP      o RADIUS/
                                      *          o Diameter
   +-------------+                  +-v----------v--+
   |             |                  |               |
   | Client      |  EAP/EAP Method  | Relying Party |
   | Application |<****************>|     (RP)      |
   |             |  GSS-API         |               |
   |             |<---------------->|               |
   |             |  Application     |               |
   |             |  Protocol        |               |
   |             |<================>|               |
   +-------------+                  +---------------+

   Legend:

    <****>: Client-to-IdP Exchange
    <---->: Client-to-RP Exchange
    <oooo>: RP-to-IdP Exchange



Howlett, et al.         Expires January 31, 2014               [Page 15]

Internet-Draft             ABFAB Architecture                  July 2013


    <====>: Protocol through which GSS-API/GS2 exchanges are tunneled

                  Figure 2: ABFAB Protocol Instantiation

2.1.  Relying Party to Identity Provider

   Communications between the Relying Party and the Identity Provider is
   done by the federation substrate.  This communication channel is
   responsible for:

   o  Establishing the trust relationship between the RP and the IdP.

   o  Determining the rules governing the relationship.

   o  Conveying authentication packets from the client to the IdP and
      back.

   o  Providing the means of establishing a trust relationship between
      the RP and the client.

   o  Providing a means for the RP to obtain attributes about the client
      from the IdP.

   The ABFAB working group has chosen the AAA framework for the messages
   transported between the RP and IdP.  The AAA framework supports the
   requirements stated above as follows:

   o  The AAA backbone supplies the trust relationship between the RP
      and the IdP.

   o  The agreements governing a specific AAA backbone contains the
      rules governing the relationships within the AAA federation.

   o  A method exists for carrying EAP packets within RADIUS [RFC3579]
      and Diameter [RFC4072].

   o  The use of EAP channel binding [RFC6677] along with the core ABFAB
      protocol provide the pieces necessary to establish the identities
      of the RP and the client, while EAP provides the cryptographic
      methods for the RP and the client to validate they are talking to
      each other.

   o  A method exists for carrying SAML packets within RADIUS
      [I-D.ietf-abfab-aaa-saml] and Diameter (work in progress) which
      allows the RP to query attributes about the client from the IdP.






Howlett, et al.         Expires January 31, 2014               [Page 16]

Internet-Draft             ABFAB Architecture                  July 2013


   Future protocols that support the same framework but do different
   routing may be used in the future.  One such effort is to setup a
   framework that creates a trusted point-to-point channel on the fly.

2.1.1.  AAA, RADIUS and Diameter

   Interestingly, for network access authentication the usage of the AAA
   framework with RADIUS [RFC2865] and Diameter [RFC3588] was quite
   successful from a deployment point of view.  To map to the
   terminology used in Figure 1 to the AAA framework the IdP corresponds
   to the AAA server, the RP corresponds to the AAA client, and the
   technical building blocks of a federation are AAA proxies, relays and
   redirect agents (particularly if they are operated by third parties,
   such as AAA brokers and clearing houses).  The front-end, i.e. the
   end host to AAA client communication, is in case of network access
   authentication offered by link layer protocols that forward
   authentication protocol exchanges back-and-forth.  An example of a
   large scale RADIUS-based federation is EDUROAM [2].

   By using the AAA framework, ABFAB gets a lot of mileage as many of
   the federation agreements already exist and merely need to be
   expanded to cover the ABFAB additions.  The AAA framework has already
   addressed some of the problems outlined above.  For example,

   o  It already has a method for routing requests based on a domain.

   o  It already has an extensible architecture allowing for new
      attributes to be defined and transported.

   o  Pre-existing relationships can be re-used.

   The astute reader will notice that RADIUS and Diameter have
   substantially similar characteristics.  Why not pick one?  RADIUS and
   Diameter are deployed in different environments.  RADIUS can often be
   found in enterprise and university networks, and is also in use by
   fixed network operators.  Diameter, on the other hand, is deployed by
   mobile operators.  Another key difference is that today RADIUS is
   largely transported upon UDP.  We leave as a deployment decision,
   which protocol will be appropriate.  The protocol defines all the
   necessary new AAA attributes as RADIUS attributes.  A future document
   would define the same AAA attributes for a Diameter environment.  We
   also note that there exist proxies which convert from RADIUS to
   Diameter and back.  This makes it possible for both to be deployed in
   a single federation substrate.

   Through the integrity protection mechanisms in the AAA framework, the
   identity provider can establish technical trust that messages are
   being sent by the appropriate relying party.  Any given interaction



Howlett, et al.         Expires January 31, 2014               [Page 17]

Internet-Draft             ABFAB Architecture                  July 2013


   will be associated with one federation at the policy level.  The
   legal or business relationship defines what statements the identity
   provider is trusted to make and how these statements are interpreted
   by the relying party.  The AAA framework also permits the relying
   party or elements between the relying party and identity provider to
   make statements about the relying party.

   The AAA framework provides transport for attributes.  Statements made
   about the client by the identity provider, statements made about the
   relying party and other information are transported as attributes.

   One demand that the AAA substrate makes of the upper layers is that
   they must properly identify the end points of the communication.  It
   must be possible for the AAA client at the RP to determine where to
   send each RADIUS or Diameter message.  Without this requirement, it
   would be the RP's responsibility to determine the identity of the
   client on its own, without the assistance of an IdP.  This
   architecture makes use of the Network Access Identifier (NAI), where
   the IdP is indicated by the realm component [I-D.ietf-radext-nai].
   The NAI is represented and consumed by the GSS-API layer as
   GSS_C_NT_USER_NAME as specified in [RFC2743].  The GSS-API EAP
   mechanism includes the NAI in the EAP Response/Identity message.

2.1.2.  Discovery and Rules Determination

   While we are using the AAA protocols to communicate with the IdP, the
   RP may have multiple federation substrates to select from.  The RP
   has a number of criteria that it will use in selecting which of the
   different federations to use:

   o  The federation selected must be able to communicate with the IdP.

   o  The federation selected must match the business rules and
      technical policies required for the RP security requirements.

   The RP needs to discover which federation will be used to contact the
   IdP.  The first selection criteria used during discovery is going to
   be the name of the IdP to be contacted.  The second selection
   criteria used during discovery is going to be the set of business
   rules and technical policies governing the relationship; this is
   called rules determination.  The RP also needs to establish technical
   trust in the communications with the IdP.

   Rules determination covers a broad range of decisions about the
   exchange.  One of these is whether the given RP is permitted to talk
   to the IdP using a given federation at all, so rules determination
   encompasses the basic authorization decision.  Other factors are
   included, such as what policies govern release of information about



Howlett, et al.         Expires January 31, 2014               [Page 18]

Internet-Draft             ABFAB Architecture                  July 2013


   the client to the RP and what policies govern the RP's use of this
   information.  While rules determination is ultimately a business
   function, it has significant impact on the technical exchanges.  The
   protocols need to communicate the result of authorization.  When
   multiple sets of rules are possible, the protocol must disambiguate
   which set of rules are in play.  Some rules have technical
   enforcement mechanisms; for example in some federations
   intermediaries validate information that is being communicated within
   the federation.

   At the time of writing no protocol mechanism has been specified to
   allow a AAA client to determine whether a AAA proxy will indeed be
   able to route AAA requests to a specific IdP.  The AAA routing is
   impacted by business rules and technical policies that may be quite
   complex and at the present time, the route selection is based on
   manual configuration.

2.1.3.  Routing and Technical Trust

   Several approaches to having messages routed through the federation
   substrate are possible.  These routing methods can most easily be
   classified based on the mechanism for technical trust that is used.
   The choice of technical trust mechanism constrains how rules
   determination is implemented.  Regardless of what deployment strategy
   is chosen, it is important that the technical trust mechanism be able
   to validate theg identities of both parties to the exchange.  The
   trust mechanism must to ensure that the entity acting as IdP for a
   given NAI is permitted to be the IdP for that realm, and that any
   service name claimed by the RP is permitted to be claimed by that
   entity.  Here are the categories of technical trust determination:

   AAA Proxy:
      The simplest model is that an RP is an AAA client and can send the
      request directly to an AAA proxy.  The hop-by-hop integrity
      protection of the AAA fabric provides technical trust.  An RP can
      submit a request directly to a federation.  Alternatively, a
      federation disambiguation fabric can be used.  Such a fabric takes
      information about what federations the RP is part of and what
      federations the IdP is part of and routes a message to the
      appropriate federation.  The routing of messages across the fabric
      plus attributes added to requests and responses provides rules
      determination.  For example, when a disambiguation fabric routes a
      message to a given federation, that federation's rules are chosen.
      Name validation is enforced as messages travel across the fabric.
      The entities near the RP confirm its identity and validate names
      it claims.  The fabric routes the message towards the appropriate
      IdP, validating the IdP's name in the process.  The routing can be
      statically configured.  Alternatively a routing protocol could be



Howlett, et al.         Expires January 31, 2014               [Page 19]

Internet-Draft             ABFAB Architecture                  July 2013


      developed to exchange reachability information about given a IdP
      and to apply policy across the AAA fabric.  Such a routing
      protocol could flood naming constraints to the appropriate points
      in the fabric.

   Trust Broker:
      Instead of routing messages through AAA proxies, some trust broker
      could establish keys between entities near the RP and entities
      near the IdP.  The advantage of this approach is efficiency of
      message handling.  Fewer entities are needed to be involved for
      each message.  Security may be improved by sending individual
      messages over fewer hops.  Rules determination involves decisions
      made by trust brokers about what keys to grant.  Also, associated
      with each credential is context about rules and about other
      aspects of technical trust including names that may be claimed.  A
      routing protocol similar to the one for AAA proxies is likely to
      be useful to trust brokers in flooding rules and naming
      constraints.

   Global Credential:
      A global credential such as a public key and certificate in a
      public key infrastructure can be used to establish technical
      trust.  A directory or distributed database such as the Domain
      Name System is used by the RP to discover the endpoint to contact
      for a given NAI.  Either the database or certificates can provide
      a place to store information about rules determination and naming
      constraints.  Provided that no intermediates are required (or
      appear to be required) and that the RP and IdP are sufficient to
      enforce and determine rules, rules determination is reasonably
      simple.  However applying certain rules is likely to be quite
      complex.  For example if multiple sets of rules are possible
      between an IdP and RP, confirming the correct set is used may be
      difficult.  This is particularly true if intermediates are
      involved in making the decision.  Also, to the extent that
      directory information needs to be trusted, rules determination may
      be more complex.

   Real-world deployments are likely to be mixtures of these basic
   approaches.  For example, it will be quite common for an RP to route
   traffic to a AAA proxy within an organization.  That proxy could then
   use any of the three methods to get closer to the IdP.  It is also
   likely that rather than being directly reachable, the IdP may have a
   proxy on the edge of its organization.  Federations will likely
   provide a traditional AAA proxy interface even if they also provide
   another mechanism for increased efficiency or security.

2.1.4.  AAA Security




Howlett, et al.         Expires January 31, 2014               [Page 20]

Internet-Draft             ABFAB Architecture                  July 2013


   For the AAA framework there are two different places where security
   needs to be examined.  The first is the security that is in place for
   the links in the AAA backbone being used.  The second is the nodes
   that the backbone consists of.

   The default link security for RADIUS is showing its age as it uses
   MD5 and a shared secret to both obfuscate passwords and to provide
   integrity on the RADIUS messages.  While some EAP methods have
   designed in the ability to protect the client authentication
   credentials, the MSK returned from the IDP to the RP is protected
   only by the RADIUS security.  In many environments this is considered
   to be insufficient, especially as not all attributes are obfuscated
   and can thus leak information to a passive eavesdropper.  The use of
   RADIUS with TLS [RFC6614] and/or DTLS [I-D.ietf-radext-dtls]
   addresses these attacks.  The same level of security is included in
   the base Diameter specifications.

2.1.5.  SAML Assertions

   For the traditional use of AAA frameworks, network access, the only
   requirement that was necessary to grant access was an affirmative
   response from the IdP.  In the ABFAB world, the RP may need to get
   additional information about the client before granting access.
   ABFAB therefore has a requirement that it can transport an arbitrary
   set of attributes about the client from the IdP to the RP.

   Security Assertions Markup Language (SAML) [OASIS.saml-core-2.0-os]
   was designed in order to carry an extensible set of attributes about
   a subject.  Since SAML is extensible in the attribute space, ABFAB
   has no immediate needs to update the core SAML specifications for our
   work.  It will be necessary to update IdPs that need to return SAML
   assertions to RPs and for both the IdP and the RP to implement a new
   SAML profile designed to carry SAML assertions in AAA.  The new
   profile can be found in RFCXXXX [I-D.ietf-abfab-aaa-saml].  As SAML
   statements will frequently be large, RADIUS servers and clients that
   deal with SAML statements will need to implement RFC XXXX
   [I-D.perez-radext-radius-fragmentation]

   There are several issues that need to be highlighted:

   o  The security of SAML assertions.

   o  Namespaces and mapping of SAML attributes.

   o  Subject naming of entities.

   o  Making multiple queries about the subject(s).




Howlett, et al.         Expires January 31, 2014               [Page 21]

Internet-Draft             ABFAB Architecture                  July 2013


   o  Level of Assurance for authentication.

   SAML assertions have an optional signature that can be used to
   protect and provide origination of the assertion.  These signatures
   are normally based on asymmetric key operations and require that the
   verifier be able to check not only the cryptographic operation, but
   also the binding of the originators name and the public key.  In a
   federated environment it will not always be possible for the RP to
   validate the binding, for this reason the technical trust established
   in the federation is used as an alternate method of validating the
   origination and integrity of the SAML Assertion.

   Attributes placed in SAML assertions can have different namespaces
   assigned to the same name.  In many, but not all, cases the
   federation agreements will determine what attributes can be used in a
   SAML statement.  This means that the RP needs to map from the
   federation names, types and semantics into the ones that the policies
   of the RP are written in.  In other cases the federation substrate
   may modify the SAML assertions in transit to do the necessary
   namespace, naming and semantic mappings as the assertion crosses the
   different boundaries in the federation.  If the proxies are modifying
   the SAML Assertion, then they will obviously remove any signatures as
   they would no longer validate.  In this case the technical trust is
   the required mechanism for validating the integrity of the assertion.
   Finally, the attributes may still be in the namespace of the
   originating IdP.  When this occurs the RP will need to get the
   required mapping operations from the federation agreements and do the
   appropriate mappings itself.

   The RADIUS SAML RFC [I-D.ietf-abfab-aaa-saml] has define a new SAML
   name format that corresponds to the NAI name form defined by RFC XXXX
   [I-D.ietf-radext-nai].  This allows for easy name matching in many
   cases as the name form in the SAML statement and the name form used
   in RADIUS or Diameter will be the same.  In addition to the NAI name
   form, the document also defines a pair of implicit name forms
   corresponding to the Client and the Client's machine.  These implicit
   name forms are based on the Identity-Type enumeration defined in TEAP
   [I-D.ietf-emu-eap-tunnel-method].  If the name form returned in a
   SAML statement is not based on the NAI, then it is a requirement on
   the EAP server that it validate that the subject of the SAML
   assertion, if any, is equivalent to the subject identified by the NAI
   used in the RADIUS or Diameter session.

   RADIUS has the ability to deal with multiple SAML queries for those
   EAP Servers which follow RFC 5080 [RFC5080].  In this case a State
   attribute will always be returned with the Access-Accept.  The EAP
   client can then send a new Access-Request with the State attribute
   and the new SAML Request Multiple SAML queries can then be done by



Howlett, et al.         Expires January 31, 2014               [Page 22]

Internet-Draft             ABFAB Architecture                  July 2013


   making a new Access-Request using the State attribute returned in the
   last Access-Accept to link together the different RADIUS sessions.

   Some RPs need to ensure that specific criteria are met during the
   authentication process.  This need is met by using Levels of
   Assurance.  The way a Level of Assurance is communicated to the RP
   from the EAP server is by the use of a SAML Authentication Request
   using the Authentication Profile from RFC XXX
   [I-D.ietf-abfab-aaa-saml] When crossing boundaries between different
   federations, either the policy specified will need to be shared
   between the two federations, the policy will need to be mapped by the
   proxy server on the boundary or the proxy server on the boundary will
   need to supply information the EAP server so that it can do the
   required mapping.  If this mapping is not done, then the EAP server
   will not be able to enforce the desired Level of Assurance as it will
   not understand the policy requirements.

2.2.  Client To Identity Provider

   Looking at the communications between the client and the IdP, the
   following items need to be dealt with:

   o  The client and the IdP need to mutually authenticate each other.

   o  The client and the IdP need to mutually agree on the identity of
      the RP.

   ABFAB selected EAP for the purposes of mutual authentication and
   assisted in creating some new EAP channel binding documents for
   dealing with determining the identity of the RP.  A framework for the
   channel binding mechanism has been defined in RFC 6677 [RFC6677] that
   allows the IdP to check the identity of the RP provided by the AAA
   framework with that provided by the client.

2.2.1.  Extensible Authentication Protocol (EAP)

   Traditional web federation does not describe how a client interacts
   with an identity provider for authentication.  As a result, this
   communication is not standardized.  There are several disadvantages
   to this approach.  Since the communication is not standardized, it is
   difficult for machines to correctly enter their credentials with
   different authentications, where Individuals can correctly identify
   the entire mechanism on the fly.  The use of browsers for
   authentication restricts the deployment of more secure forms of
   authentication beyond plaintext username and password known by the
   server.  In a number of cases the authentication interface may be
   presented before the client has adequately validated they are talking
   to the intended server.  By giving control of the authentication



Howlett, et al.         Expires January 31, 2014               [Page 23]

Internet-Draft             ABFAB Architecture                  July 2013


   interface to a potential attacker, the security of the system may be
   reduced and phishing opportunities introduced.

   As a result, it is desirable to choose some standardized approach for
   communication between the client's end-host and the identity
   provider.  There are a number of requirements this approach must
   meet.

   Experience has taught us one key security and scalability
   requirement: it is important that the relying party not get
   possession of the long-term secret of the client.  Aside from a
   valuable secret being exposed, a synchronization problem can develop
   when the client changes keys with the IdP.

   Since there is no single authentication mechanism that will be used
   everywhere there is another associated requirement: The
   authentication framework must allow for the flexible integration of
   authentication mechanisms.  For instance, some IdPs require hardware
   tokens while others use passwords.  A service provider wants to
   provide support for both authentication methods, and other methods
   from IdPs not yet seen.

   These requirements can be met by utilizing standardized and
   successfully deployed technology, namely by the Extensible
   Authentication Protocol (EAP) framework [RFC3748].  Figure 2
   illustrates the integration graphically.

   EAP is an end-to-end framework; it provides for two-way communication
   between a peer (i.e. client or individual) through the authenticator
   (i.e., relying party) to the back-end (i.e., identity provider).
   Conveniently, this is precisely the communication path that is needed
   for federated identity.  Although EAP support is already integrated
   in AAA systems (see [RFC3579] and [RFC4072]) several challenges
   remain:

   o  The first is how to carry EAP payloads from the end host to the
      relying party.

   o  Another is to verify statements the relying party has made to the
      client, confirm these statements are consistent with statements
      made to the identity provider and confirm all the above are
      consistent with the federation and any federation-specific policy
      or configuration.

   o  Another challenge is choosing which identity provider to use for
      which service.





Howlett, et al.         Expires January 31, 2014               [Page 24]

Internet-Draft             ABFAB Architecture                  July 2013


   The EAP method used for ABFAB needs to meet the following
   requirements:

   o  It needs to provide mutual authentication of the client and IdP.

   o  It needs to support channel binding.

   As of this writing, the only EAP method that meets these criteria is
   TEAP [I-D.ietf-emu-eap-tunnel-method] either alone (if client
   certificates are used) or with an inner EAP method that does mutual
   authentication.

2.2.2.  EAP Channel Binding

   EAP channel binding is easily confused with a facility in GSS-API
   also called channel binding.  GSS-API channel binding provides
   protection against man-in-the-middle attacks when GSS-API is used as
   authentication inside some tunnel; it is similar to a facility called
   cryptographic binding in EAP.  See [RFC5056] for a discussion of the
   differences between these two facilities and Section 6.1 for how GSS-
   API channel binding is handled in this mechanism.

   The client knows, in theory, the name of the RP that it attempted to
   connect to, however in the event that an attacker has intercepted the
   protocol, the client and the IdP need to be able to detect this
   situation.  A general overview of the problem along with a
   recommended way to deal with the channel binding issues can be found
   in RFC 6677 [RFC6677].

   Since that document was published, a number of possible attacks were
   found and methods to address these attacks have been outlined in
   [I-D.ietf-emu-crypto-bind].

2.3.  Client to Relying Party

   The final set of interactions between parties to consider are those
   between the client and the RP.  In some ways this is the most complex
   set since at least part of it is outside the scope of the ABFAB work.
   The interactions between these parties include:

   o  Running the protocol that implements the service that is provided
      by the RP and desired by the client.

   o  Authenticating the client to the RP and the RP to the client.

   o  Providing the necessary security services to the service protocol
      that it needs beyond authentication.




Howlett, et al.         Expires January 31, 2014               [Page 25]

Internet-Draft             ABFAB Architecture                  July 2013


   o  Deal with client re-authentication where desired.

2.3.1.  GSS-API

   One of the remaining layers is responsible for integration of
   federated authentication into the application.  There are a number of
   approaches that applications have adopted for security.  So, there
   may need to be multiple strategies for integration of federated
   authentication into applications.  However, we have started with a
   strategy that provides integration to a large number of application
   protocols.

   Many applications such as SSH [RFC4462], NFS [RFC2203], DNS [RFC3645]
   and several non-IETF applications support the Generic Security
   Services Application Programming Interface [RFC2743].  Many
   applications such as IMAP, SMTP, XMPP and LDAP support the Simple
   Authentication and Security Layer (SASL) [RFC4422] framework.  These
   two approaches work together nicely: by creating a GSS-API mechanism,
   SASL integration is also addressed.  In effect, using a GSS-API
   mechanism with SASL simply requires placing some headers on the front
   of the mechanism and constraining certain GSS-API options.

   GSS-API is specified in terms of an abstract set of operations which
   can be mapped into a programming language to form an API.  When
   people are first introduced to GSS-API, they focus on it as an API.
   However, from the prospective of authentication for non-web
   applications, GSS-API should be thought of as a protocol as well as
   an API.  When looked at as a protocol, it consists of abstract
   operations such as the initial context exchange, which includes two
   sub-operations (gss_init_sec_context and gss_accept_sec_context).  An
   application defines which abstract operations it is going to use and
   where messages produced by these operations fit into the application
   architecture.  A GSS-API mechanism will define what actual protocol
   messages result from that abstract message for a given abstract
   operation.  So, since this work is focusing on a particular GSS-API
   mechanism, we generally focus on protocol elements rather than the
   API view of GSS-API.

   The API view of GSS-API does have significant value as well, since
   the abstract operations are well defined, the set of information that
   a mechanism gets from the application is well defined.  Also, the set
   of assumptions the application is permitted to make is generally well
   defined.  As a result, an application protocol that supports GSS-API
   or SASL is very likely to be usable with a new approach to
   authentication including this one with no required modifications.  In
   some cases, support for a new authentication mechanism has been added
   using plugin interfaces to applications without the application being
   modified at all.  Even when modifications are required, they can



Howlett, et al.         Expires January 31, 2014               [Page 26]

Internet-Draft             ABFAB Architecture                  July 2013


   often be limited to supporting a new naming and authorization model.
   For example, this work focuses on privacy; an application that
   assumes it will always obtain an identifier for the client will need
   to be modified to support anonymity, unlinkability or pseudonymity.

   So, we use GSS-API and SASL because a number of the application
   protocols we wish to federate support these strategies for security
   integration.  What does this mean from a protocol standpoint and how
   does this relate to other layers?  This means we need to design a
   concrete GSS-API mechanism.  We have chosen to use a GSS-API
   mechanism that encapsulates EAP authentication.  So, GSS-API (and
   SASL) encapsulate EAP between the end-host and the service.  The AAA
   framework encapsulates EAP between the relying party and the identity
   provider.  The GSS-API mechanism includes rules about how initiators
   and services are named as well as per-message security and other
   facilities required by the applications we wish to support.

2.3.2.  Protocol Transport

   The transport of data between the client and the relying party is not
   provided by GSS-API.  GSS-API creates and consumes messages, but it
   does not provide the transport itself, instead the protocol using
   GSS-API needs to provide the transport.  In many cases HTTP or HTTPS
   is used for this transport, but other transports are perfectly
   acceptable.  The core GSS-API document [RFC2743] provides some
   details on what requirements exist.

   In addition we highlight the following:

   o  The transport does not need to provide either privacy or
      integrity.  After GSS-EAP has finished negotiation, GSS-API can be
      used to provide both services.  If the negotiation process itself
      needs protection from eavesdroppers then the transport would need
      to provide the necessary services.

   o  The transport needs to provide reliable transport of the messages.

   o  The transport needs to ensure that tokens are delivered in order
      during the negotiation process.

   o  GSS-API messages need to be delivered atomically.  If the
      transport breaks up a message it must also reassemble the message
      before delivery.

2.3.3.  Reauthentication

   TBD.




Howlett, et al.         Expires January 31, 2014               [Page 27]

Internet-Draft             ABFAB Architecture                  July 2013


3.  Application Security Services

   One of the key goals is to integrate federated authentication into
   existing application protocols and where possible, existing
   implementations of these protocols.  Another goal is to perform this
   integration while meeting the best security practices of the
   technologies used to perform the integration.  This section describes
   security services and properties required by the EAP GSS-API
   mechanism in order to meet these goals.  This information could be
   viewed as specific to that mechanism.  However, other future
   application integration strategies are very likely to need similar
   services.  So, it is likely that these services will be expanded
   across application integration strategies if new application
   integration strategies are adopted.

3.1.  Authentication

   GSS-API provides an optional security service called mutual
   authentication.  This service means that in addition to the initiator
   providing (potentially anonymous or pseudonymous) identity to the
   acceptor, the acceptor confirms its identity to the initiator.
   Especially for the ABFAB context, this service is confusingly named.
   We still say that mutual authentication is provided when the identity
   of an acceptor is strongly authenticated to an anonymous initiator.

   RFC 2743, unfortunately, does not explicitly talk about what mutual
   authentication means.  Within this document we therefore define it
   as:

   o  If a target name is configured for the initiator, then the
      initiator trusts that the supplied target name describes the
      acceptor.  This implies both that appropriate cryptographic
      exchanges took place for the initiator to make such a trust
      decision, and that after evaluating the results of these
      exchanges, the initiator's policy trusts that the target name is
      accurate.

   o  If no target name is configured for the initiator, then the
      initiator trusts that the acceptor name, supplied by the acceptor,
      correctly names the entity it is communicating with.

   o  Both the initiator and acceptor have the same key material for
      per-message keys and both parties have confirmed they actually
      have the key material.  In EAP terms, there is a protected
      indication of success.

   Mutual authentication is an important defense against certain aspects
   of phishing.  Intuitively, clients would like to assume that if some



Howlett, et al.         Expires January 31, 2014               [Page 28]

Internet-Draft             ABFAB Architecture                  July 2013


   party asks for their credentials as part of authentication,
   successfully gaining access to the resource means that they are
   talking to the expected party.  Without mutual authentication, the
   server could "grant access" regardless of what credentials are
   supplied.  Mutual authentication better matches this user intuition.

   It is important, therefore, that the GSS-EAP mechanism implement
   mutual authentication.  That is, an initiator needs to be able to
   request mutual authentication.  When mutual authentication is
   requested, only EAP methods capable of providing the necessary
   service can be used, and appropriate steps need to be taken to
   provide mutual authentication.  While a broader set of EAP methods
   could be supported by not requiring mutual authentication, it was
   decided that the client needs to always have the ability to request
   it.  In some cases the IdP and the RP will not support mutual
   authentication, however the client will always be able to detect this
   and make an appropriate security decision.

   The AAA infrastructure MAY hide the initiator's identity from the
   GSS-API acceptor, providing anonymity between the initiator and the
   acceptor.  At this time, whether the identity is disclosed is
   determined by EAP server policy rather than by an indication from the
   initiator.  Also, initiators are unlikely to be able to determine
   whether anonymous communication will be provided.  For this reason,
   initiators are unlikely to set the anonymous return flag from
   GSS_Init_Sec_context.

3.2.  GSS-API Channel Binding

   [RFC5056] defines a concept of channel binding which is used prevent
   man-in-the-middle attacks.  The channel binding works by taking a
   cryptographic value from the transport security and checks that both
   sides of the GSS-API conversation know this value.  Transport Layer
   Security (TLS) is the most common transport security layer used for
   this purpose.

   It needs to be stressed that RFC 5056 channel binding (also called
   GSS-API channel binding when GSS-API is involved) is not the same
   thing as EAP channel binding.  GSS-API channel binding is used for
   detecting Man-In-The-Middle attacks.  EAP channel binding is used for
   mutual authentication and acceptor naming checks.  Details are
   discussed in the mechanisms specification [I-D.ietf-abfab-gss-eap].
   A fuller description of the differences between the facilities can be
   found in RFC 5056 [RFC5056].

   The use of TLS can provide both encryption and integrity on the
   channel.  It is common to provide SASL and GSS-API with these other
   security services.



Howlett, et al.         Expires January 31, 2014               [Page 29]

Internet-Draft             ABFAB Architecture                  July 2013


   One of the benefits that the use of TLS provides, is that client has
   the ability to validate the name of the server.  However this
   validation is predicated on a couple of things.  The TLS sessions
   needs to be using certificates and not be an anonymous session.  The
   client and the TLS need to share a common trust point for the
   certificate used in validating the server.  TLS provides its own
   server authentication.  However there are a variety of situations
   where this authentication is not checked for policy or usability
   reasons.  Even when it is checked, if the trust infrastructure behind
   the TLS authentication is different from the trust infrastructure
   behind the GSS-API mutual authentication then confirming the end-
   points using both trust infrastructures is likely to enhance
   security.  If the endpoints of the GSS-API authentication are
   different than the endpoints of the lower layer, this is a strong
   indication of a problem such as a man-in-the-middle attack.  Channel
   binding provides a facility to determine whether these endpoints are
   the same.

   The GSS-EAP mechanism needs to support channel binding.  When an
   application provides channel binding data, the mechanism needs to
   confirm this is the same on both sides consistent with the GSS-API
   specification.

3.3.  Host-Based Service Names

   IETF security mechanisms typically take a host name and perhaps a
   service, entered by a user, and make some trust decision about
   whether the remote party in the interaction is the intended party.
   This decision can be made by the use of certificates, pre-configured
   key information or a previous leap of trust.  GSS-API has defined a
   relatively flexible name convention, however most of the IETF
   applications that use GSS-API (including SSH, NFS, IMAP, LDAP and
   XMPP) have chosen to use a more restricted naming convention based on
   the host name.  The GSS-EAP mechanism needs to support host-based
   service names in order to work with existing IETF protocols.

   The use of host-based service names leads to a challenging trust
   delegation problem.  Who is allowed to decide whether a particular
   host name maps to a specific entity.  Possible solutions to this
   problem have been looked at.

   o  The public-key infrastructure (PKI) used by the web has chosen to
      have a number of trust anchors (root certificate authorities) each
      of which can map any host name to a public key.

   o  A number of GSS-API mechanisms, such as Kerberos [RFC1964], have
      split the problem into two parts.  A new concept called a realm is
      introduced, the realm is responsible for host mapping within that



Howlett, et al.         Expires January 31, 2014               [Page 30]

Internet-Draft             ABFAB Architecture                  July 2013


      realm.  The mechanism then decides what realm is responsible for a
      given name.  This is the approach adopted by ABFAB.

   GSS-EAP defines a host naming convention that takes into account the
   host name, the realm, the service and the service parameters.  An
   example of GSS-API service name is "xmpp/foo@example.com".  This
   identifies the XMPP service on the host foo in the realm example.com.
   Any of the components, except for the service name may be omitted
   from a name.  When omitted, then a local default would be used for
   that component of the name.

   While there is no requirement that realm names map to Fully Qualified
   Domain Names (FQDN) within DNS, in practice this is normally true.
   Doing so allows for the realm portion of service names and the
   portion of NAIs to be the same.  It also allows for the use of DNS in
   locating the host of a service while establishing the transport
   channel between the client and the relying party.

   It is the responsibility of the application to determine the server
   that it is going to communicate with, GSS-API has the ability to help
   confirm that the server is the desired server but not to determine
   the name of the server to use.  It is also the responsibility of the
   application to determine how much of the information identifying the
   service needs to be validated by the ABFAB system.  The information
   that needs to be validated is used to build up the service name
   passed into the GSS-EAP mechanism.  What information is to be
   validated will depend on both what information was provided by the
   client, and what information is considered significant.  If the
   client only cares about getting a specific service, then the host and
   realm that provides the service does not need to be validated.

   In many cases applications may retrieve information about providers
   of services from DNS.  When Service Records (SRV) and Naming
   Authority Pointer (NAPTR) records are used to help find a host that
   provides a service, the security requirements on the referrals is
   going to interact with the information used in the service name.  If
   a host name is returned from the DNS referrals, and the host name is
   to be validated by GS-EAP, then it makes sense that the referrals
   themselves should be secure.  On the other hand, if the host name
   returned is not validated, i.e. only the service is passed in, then
   it is less important that the host name be obtained in a secure
   manner.

   Another issue that needs to be addressed for host-based service names
   is that they do not work ideally when different instances of a
   service are running on different ports.  If the services are
   equivalent, then it does not matter.  However if there are
   substantial differences in the quality of the service that



Howlett, et al.         Expires January 31, 2014               [Page 31]

Internet-Draft             ABFAB Architecture                  July 2013


   information needs to be part of the validation process.  If one has
   just a host name and not a port in the information being validated,
   then this is not going to be a successful strategy.

3.4.  Additional GSS-API Services

   GSS-API provides per-message security services that can provide
   confidentiality and/or integrity.  Some IETF protocols such as NFS
   and SSH take advantage of these services.  As a result GSS-EAP needs
   to support these services.  As with mutual authentication, per-
   message services will limit the set of EAP methods that can be used
   to those that generate a Master Session Key (MSK).  Any EAP method
   that produces an MSK is able to support per-message security services
   described in [RFC2743].

   GSS-API provides a pseudo-random function.  This function generates a
   pseudo-random sequence using the shared private key as the seed for
   the bytes generated.  This provides an algorithm that both the
   initiator and acceptor can run in order to arrive at the same key
   value.  The use of this feature allows for an application to generate
   keys or other shared secrets for use in other places in the protocol.
   In this regards, it is similar in concept to the TLS extractor (RFC
   5705 [RFC5705].).  While no current IETF protocols require this, non-
   IETF protocols are expected to take advantage of this in the near
   future.  Additionally, a number of protocols have found the TLS
   extractor to be useful in this regards so it is highly probably that
   IETF protocols may also start using this feature.

4.  Privacy Considerations

   ABFAB, as an architecture designed to enable federated authentication
   and allow for the secure transmission of identity information between
   entities, obviously requires careful consideration around privacy and
   the potential for privacy violations.

   This section examines the privacy related information presented in
   this document, summarising the entities that are involved in ABFAB
   communications and what exposure they have to identity information.
   In discussing these privacy considerations in this section, we use
   terminology and ideas from [I-D.iab-privacy-considerations].

   Note that the ABFAB architecture uses at its core several existing
   technologies and protocols; detailed privacy discussion around these
   is not examined.  This section instead focuses on privacy
   considerations specifically related to overall architecture and usage
   of ABFAB.





Howlett, et al.         Expires January 31, 2014               [Page 32]

Internet-Draft             ABFAB Architecture                  July 2013


   +--------+       +---------------+       +--------------+
   | Client | <---> |      RP       | <---> | AAA Client   |
   +--------+       +---------------+       +--------------+
                                                  ^
                                                  |
                                                  v
                    +---------------+       +--------------+
                    | SAML Server   |       | AAA Proxy(s) |
                    +---------------+       +--------------+
                             ^                       ^
                             |                       |
                             v                       v
   +------------+       +---------------+       +--------------+
   | EAP Server | <---> |   IdP         | <---> | AAA Server   |
   +------------+       +---------------+       +--------------+

                     Figure 3: Entities and Data Flow

4.1.  Entities and their roles

   Categorizing the ABFAB entities shown in the Figure 3 according to
   the taxonomy of terms from [I-D.iab-privacy-considerations] the
   entities shown in Figure 3 is somewhat complicated as during the
   various phases of ABFAB communications the roles of each entity
   changes.  The three main phases of relevance are the Client to RP
   communication phase, the Client to IdP (via the Federation Substrate)
   phase, and the IdP to RP (via the Federation Substrate) phase.

   In the Client to RP communication phase, we have:

   Initiator:  Client.

   Observers:  Client, RP.

   Recipient:  RP.

   In the Client to IdP (via the Federation Substrate) communication
   phase, we have:

   Initiator:  Client.

   Observers:  Client, RP, AAA Client, AAA Proxy(s), AAA Server, IdP.

   Recipient:  IdP

   In the IdP to Relying party (via the Federation Substrate)
   communication phase, we have:




Howlett, et al.         Expires January 31, 2014               [Page 33]

Internet-Draft             ABFAB Architecture                  July 2013


   Initiator:  RP.

   Observers:  IdP, AAA Server, AAA Proxy(s), AAA Client, RP.

   Recipient:  IdP

   Eavesdroppers and Attackers can reside on any communication link
   between entities in Figure 3.

   The Federation Substrate consists of all of the AAA entities.  In
   some cases the AAA Proxies entities may not exist as the AAA Client
   can talk directly to the AAA Server.  Specifications such as the
   Trust Router Protocol and RADIUS dynamic discovery
   [I-D.ietf-radext-dynamic-discovery] can be used to shorten the path
   between the AAA client and the AAA server (and thus stop these AAA
   Proxies from being Observers), however even in these circumstances
   there may be AAA Proxies in the path.

   In Figure 3 the IdP has been divided into multiple logical pieces, in
   actual implementations these pieces will frequently be tightly
   coupled.  The links between these pieces provide the greatest
   opportunity for attackers and eavesdroppers to acquire information,
   however, as they are all under the control of a single entity they
   are also the easiest to have tightly secured.

4.2.  Privacy Aspects of ABFAB Communication Flows

   In the ABFAB architecture, there are a few different types of data
   and identifiers in use.  The best way to understand them, and the
   potential privacy impacts of them, is to look at each phase of
   communication in ABFAB.

4.2.1.  Client to RP

   The flow of data between the client and the RP is divided into two
   parts.  The first part consists of all of the data exchanged as part
   of the ABFAB authentication process.  The second part consists of all
   of the data exchanged after the authentication process has been
   finished.












Howlett, et al.         Expires January 31, 2014               [Page 34]

Internet-Draft             ABFAB Architecture                  July 2013


   During the initial communications phase, the client sends an NAI (see
   [I-D.ietf-radext-nai]) to the RP.  Many EAP methods (but not all)
   allow for the client to disclose an NAI to RP the in a form that
   includes only a realm component during this communications phase.
   This is the minimum amount of identity information necessary for
   ABFAB to work - it indicates an IdP that the principal has a
   relationship with.  EAP methods that do not allow this will
   necessarily also reveal an identifier for the principal in the IdP
   realm (e.g. a username).

   The data shared during the initial communication phase may be
   protected by a channel protocol such as TLS.  This will prevent the
   leak of information to passive eavesdroppers, however an active
   attacker may still be able to setup as a man-in-the-middle.  The
   client may not be able to validate the certificates (if any) provided
   by the service, defering the check of the identity of the RP until
   the completion of the ABFAB authentication protocol (i.e., using EAP
   channel binding).

   The data exchanged after the authentication process can have privacy
   and authentication using the GSS-API services.  If the overall
   application protocol allows for the process of re-authentication,
   then the same privacy impliciations as discussed in previous
   paragraphs apply.

4.2.2.  Client to IdP (via Federation Substrate)

   This phase sees a secure TLS tunnel initiated between the Client and
   the IdP via the RP and federation substrate.  The process is
   initiated by the RP using the realm information given to it by the
   client.  Once set up, the tunnel is used to send credentials to IdP
   to authenticate.

   Various operational information is transported between RP and IdP,
   over the AAA infrastructure, for example using RADIUS headers.  As no
   end-to-end security is provided by AAA, all AAA entities on the path
   between the RP and IdP have the ability to eavesdrop on this
   information unless additional security measures are taken (such as
   the use of TLS for RADIUS [I-D.ietf-radext-dtls]).  Some of this
   information may form identifiers or explicit identity information:

   o  The Relying Party knows the IP address of the Client.  It is
      possible that the Relying Party could choose to expose this IP
      address by including it in a RADIUS header such as Calling Station
      ID.  This is a privacy consideration to take into account of the
      application protocol.





Howlett, et al.         Expires January 31, 2014               [Page 35]

Internet-Draft             ABFAB Architecture                  July 2013


   o  The EAP MSK is transported between the IdP and the RP over the AAA
      infrastructure, for example through RADIUS headers.  This is a
      particularly important privacy consideration, as any AAA Proxy
      that has access to the EAP MSK is able to decrypt and eavesdrop on
      any traffic encrypted using that EAP MSK (i.e. all communications
      between the Client and IdP).

   o  Related to the above, the AAA server has access to the material
      necessary to derive the session key, thus the AAA server can
      observe any traffic encrypted between the Client and RP.  This
      "feature" was" chosen as a simplification and to make performance
      faster; if it was decided that this trade-off was not desireable
      for privacy and security reasons, then extensions to ABFAB that
      make use of techniques such as Diffie-Helman key exchange would
      mitigate against this.

   The choice of EAP method used has other potential privacy
   implications.  For example, if the EAP method in use does not support
   trust anchors to enable mutual authentication, then there are no
   guarantees that the IdP is who it claims to be, and thus the full NAI
   including a username and a realm might be sent to any entity
   masquerading as a particular IdP.

   Note that ABFAB has not specified any AAA accounting requirements.
   Implementations that use the accounting portion of AAA should
   consider privacy appropriately when designing this aspect.

4.2.3.  IdP to RP (via Federation Substrate)

   In this phase, the IdP communicates with the RP informing it as to
   the success or failure of authentication of the user, and optionally,
   the sending of identity information about the principal.

   As in the previous flow (Client to IdP), various operation
   information is transported between IdP and RP over the AAA
   infrastructure, and the same privacy considerations apply.  However,
   in this flow, explicit identity information about the authenticated
   principal can be sent from the IdP to the RP.  This information can
   be sent through RADIUS headers, or using SAML
   [I-D.ietf-abfab-aaa-saml].  This can include protocol specific
   identitifiers, such as SAML NameIDs, as well as arbitrary attribute
   information about the principal.  What information will be released
   is controlled by policy on the Identity Provider.  As before, when
   sending this through RADIUS headers, all AAA entities on the path
   between the RP and IdP have the ability to eavesdrop unless
   additional security measures are taken (such as the use of TLS for
   RADIUS [I-D.ietf-radext-dtls]).  When sending this using SAML, as
   specified in [I-D.ietf-abfab-aaa-saml], confidentiality of the



Howlett, et al.         Expires January 31, 2014               [Page 36]

Internet-Draft             ABFAB Architecture                  July 2013


   information should however be guaranteed as [I-D.ietf-abfab-aaa-saml]
   requires the use of TLS for RADIUS.

4.3.  Relationship between User and Entities

   o  Between User and IdP - the IdP is an entity the user will have a
      direct relationship with, created when the organisation that
      operates the entity provisioned and exchanged the user's
      credentials.  Privacy and data protection guarantees may form a
      part of this relationship.

   o  Between User and RP - the RP is an entity the user may or may not
      have a direct relationship with, depending on the service in
      question.  Some services may only be offered to those users where
      such a direct relationship exists (for particularly sensitive
      services, for example), while some may not require this and would
      instead be satisfied with basic federation trust guarantees
      between themselves and the IdP).  This may well include the option
      that the user stays anonymous with respect to the RP (though
      obviously never to the IdP).  If attempting to preserve privacy
      through the mitigation of data minimisation, then the only
      attribute information about individuals exposed to the RP should
      be that which is strictly necessary for the operation of the
      service.

   o  Between User and Federation substrate - the user is highly likely
      to have no knowledge of, or relationship with, any entities
      involved with the federation substrate (not that the IdP and/or RP
      may, however).  Knowledge of attribute information about
      individuals for these entities is not necessary, and thus such
      information should be protected in such a way as to prevent access
      to this information from being possible.

4.4.  Accounting Information

   Alongside the core authentication and authorization that occurs in
   AAA communications, accounting information about resource consumption
   may be delivered as part of the accounting exchange during the
   lifetime of the granted application session.

4.5.  Collection and retention of data and identifiers

   In cases where Relying Parties do not require to identify a
   particular individual when an individual wishes to make use of their
   service, the ABFAB architecture enable anonymous or pseudonymous
   access.  Thus data and identifiers other than pseudonyms and
   unlinkable attribute information need not be stored and retained.




Howlett, et al.         Expires January 31, 2014               [Page 37]

Internet-Draft             ABFAB Architecture                  July 2013


   However, in cases where Relying Parties require the ability to
   identify a particular individual (e.g. so they can link this identity
   information to a particular account in their service, or where
   identity information is required for audit purposes), the service
   will need to collect and store such information, and to retain it for
   as long as they require.  Deprovisioning of such accounts and
   information is out of scope for ABFAB, but obviously for privacy
   protection any identifiers collected should be deleted when they are
   no longer needed.

4.6.  User Participation

   In the ABFAB architecture, by its very nature users are active
   participants in the sharing of their identifiers as they initiate the
   communications exchange every time they wish to access a server.
   They are, however, not involved in control of the set of information
   related to them that transmitted from the IdP to RP for authorisation
   purposes; rather, this is under the control of policy on the IdP.
   Due to the nature of the AAA communication flows, with the current
   ABFAB architecture there is no place for a process of gaining user
   consent for the information to be released from IdP to RP.

5.  Security Considerations

   This document describes the architecture for Application Bridging for
   Federated Access Beyond Web (ABFAB) and security is therefore the
   main focus.  This section highlights the main communication channels
   and their security properties:

   Client-to-RP Channel:

      The channel binding material is provided by any certificates and
      the final message (i.e., a cryptographic token for the channel).
      Authentication may be provided by the RP to the client but a
      deployment without authentication at the TLS layer is possible as
      well.  In addition, there is a channel between the GSS requestor
      and the GSS acceptor, but the keying material is provided by a
      "third party" to both entities.  The client can derive keying
      material locally, but the RP gets the material from the IdP.  In
      the absence of a transport that provides encryption and/or
      integrity, the channel between the client and the RP has no
      ability to have any cryptographic protection until the EAP
      authentication has been completed and the MSK is transferred from
      the IdP to the RP.

   RP-to-IdP Channel:





Howlett, et al.         Expires January 31, 2014               [Page 38]

Internet-Draft             ABFAB Architecture                  July 2013


      The security of this communication channel is mainly provided by
      the functionality offered via RADIUS and Diameter.  At the time of
      writing there are no end-to-end security mechanisms standardized
      and thereby the architecture has to rely on hop-by-hop security
      with trusted AAA entities or, as an alternative but possible
      deployment variant, direct communication between the AAA client to
      the AAA server.  Note that the authorization result the IdP
      provides to the RP in the form of a SAML assertion may, however,
      be protected such that the SAML related components are secured
      end-to-end.

      The MSK is transported from the IdP to the RP over this channel.
      As no end-to-end security is provided by AAA, all AAA entities on
      the path between the RP and IdP have the ability to eavesdrop if
      no additional security measures are taken.  One such measure is to
      use a transport between the client and the IdP that provides
      confidentiality.

   Client-to-IdP Channel:

      This communication interaction is accomplished with the help of
      EAP and EAP methods.  The offered security protection will depend
      on the EAP method that is chosen but a minimum requirement is to
      offer mutual authentication, and key derivation.  The IdP is
      responsible during this process to determine that the RP that is
      communication to the client over the RP-to-IdP channel is the same
      one talking to the IdP.  This is accomplished via the EAP channel
      binding.

   Partial list of issues to be addressed in this section: Privacy,
   SAML, Trust Anchors, EAP Algorithm Selection, Diameter/RADIUS/AAA
   Issues, Naming of Entities, Protection of passwords, Channel Binding,
   End-point-connections (TLS), Proxy problems

   When a pseudonym is generated as a unique long term identifier for a
   client by an IdP, care MUST be taken in the algorithm that it cannot
   easily be reverse engineered by the service provider.  If it can be
   reversed then the service provider can consult an oracle to determine
   if a given unique long term identifier is associated with a different
   known identifier.

6.  IANA Considerations

   This document does not require actions by IANA.

7.  Acknowledgments





Howlett, et al.         Expires January 31, 2014               [Page 39]

Internet-Draft             ABFAB Architecture                  July 2013


   We would like to thank Mayutan Arumaithurai, Klaas Wierenga and Rhys
   Smith for their feedback.  Additionally, we would like to thank Eve
   Maler, Nicolas Williams, Bob Morgan, Scott Cantor, Jim Fenton, Paul
   Leach, and Luke Howard for their feedback on the federation
   terminology question.

   Furthermore, we would like to thank Klaas Wierenga for his review of
   the pre-00 draft version.

8.  References

8.1.  Normative References

   [RFC2743]  Linn, J., "Generic Security Service Application Program
              Interface Version 2, Update 1", RFC 2743, January 2000.

   [RFC2865]  Rigney, C., Willens, S., Rubens, A., and W. Simpson,
              "Remote Authentication Dial In User Service (RADIUS)", RFC
              2865, June 2000.

   [RFC3588]  Calhoun, P., Loughney, J., Guttman, E., Zorn, G., and J.
              Arkko, "Diameter Base Protocol", RFC 3588, September 2003.

   [RFC3748]  Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.
              Levkowetz, "Extensible Authentication Protocol (EAP)", RFC
              3748, June 2004.

   [RFC3579]  Aboba, B. and P. Calhoun, "RADIUS (Remote Authentication
              Dial In User Service) Support For Extensible
              Authentication Protocol (EAP)", RFC 3579, September 2003.

   [RFC4072]  Eronen, P., Hiller, T., and G. Zorn, "Diameter Extensible
              Authentication Protocol (EAP) Application", RFC 4072,
              August 2005.

   [I-D.ietf-abfab-gss-eap]
              Hartman, S. and J. Howlett, "A GSS-API Mechanism for the
              Extensible Authentication Protocol", draft-ietf-abfab-gss-
              eap-09 (work in progress), August 2012.

   [I-D.ietf-abfab-aaa-saml]
              Howlett, J. and S. Hartman, "A RADIUS Attribute, Binding,
              Profiles, Name Identifier Format, and Confirmation Methods
              for SAML", draft-ietf-abfab-aaa-saml-05 (work in
              progress), February 2013.

   [I-D.ietf-radext-nai]




Howlett, et al.         Expires January 31, 2014               [Page 40]

Internet-Draft             ABFAB Architecture                  July 2013


              DeKok, A., "The Network Access Identifier", draft-ietf-
              radext-nai-02 (work in progress), January 2013.

   [RFC6677]  Hartman, S., Clancy, T., and K. Hoeper, "Channel-Binding
              Support for Extensible Authentication Protocol (EAP)
              Methods", RFC 6677, July 2012.

8.2.  Informative References

   [RFC2903]  de Laat, C., Gross, G., Gommans, L., Vollbrecht, J., and
              D. Spence, "Generic AAA Architecture", RFC 2903, August
              2000.

   [I-D.nir-tls-eap]
              Nir, Y., Sheffer, Y., Tschofenig, H., and P. Gutmann, "A
              Flexible Authentication Framework for the Transport Layer
              Security (TLS) Protocol using the Extensible
              Authentication Protocol (EAP)", draft-nir-tls-eap-13 (work
              in progress), December 2011.

   [I-D.ietf-oauth-v2]
              Hardt, D., "The OAuth 2.0 Authorization Framework", draft-
              ietf-oauth-v2-31 (work in progress), August 2012.

   [I-D.iab-privacy-considerations]
              Cooper, A., Tschofenig, H., Aboba, B., Peterson, J.,
              Morris, J., Hansen, M., and R. Smith, "Privacy
              Considerations for Internet Protocols", draft-iab-privacy-
              considerations-03 (work in progress), July 2012.

   [I-D.perez-radext-radius-fragmentation]
              Perez-Mendez, A., Lopez, R., Pereniguez-Garcia, F., Lopez-
              Millan, G., Lopez, D., and A. DeKok, "Support of
              fragmentation of RADIUS packets", draft-perez-radext-
              radius-fragmentation-05 (work in progress), February 2013.

   [RFC4017]  Stanley, D., Walker, J., and B. Aboba, "Extensible
              Authentication Protocol (EAP) Method Requirements for
              Wireless LANs", RFC 4017, March 2005.

   [RFC5106]  Tschofenig, H., Kroeselberg, D., Pashalidis, A., Ohba, Y.,
              and F. Bersani, "The Extensible Authentication Protocol-
              Internet Key Exchange Protocol version 2 (EAP-IKEv2)
              Method", RFC 5106, February 2008.

   [RFC1964]  Linn, J., "The Kerberos Version 5 GSS-API Mechanism", RFC
              1964, June 1996.




Howlett, et al.         Expires January 31, 2014               [Page 41]

Internet-Draft             ABFAB Architecture                  July 2013


   [RFC2203]  Eisler, M., Chiu, A., and L. Ling, "RPCSEC_GSS Protocol
              Specification", RFC 2203, September 1997.

   [RFC3645]  Kwan, S., Garg, P., Gilroy, J., Esibov, L., Westhead, J.,
              and R. Hall, "Generic Security Service Algorithm for
              Secret Key Transaction Authentication for DNS (GSS-TSIG)",
              RFC 3645, October 2003.

   [RFC2138]  Rigney, C., Rigney, C., Rubens, A., Simpson, W., and S.
              Willens, "Remote Authentication Dial In User Service
              (RADIUS)", RFC 2138, April 1997.

   [RFC4462]  Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch,
              "Generic Security Service Application Program Interface
              (GSS-API) Authentication and Key Exchange for the Secure
              Shell (SSH) Protocol", RFC 4462, May 2006.

   [RFC4422]  Melnikov, A. and K. Zeilenga, "Simple Authentication and
              Security Layer (SASL)", RFC 4422, June 2006.

   [RFC5056]  Williams, N., "On the Use of Channel Bindings to Secure
              Channels", RFC 5056, November 2007.

   [RFC5080]  Nelson, D. and A. DeKok, "Common Remote Authentication
              Dial In User Service (RADIUS) Implementation Issues and
              Suggested Fixes", RFC 5080, December 2007.

   [RFC5705]  Rescorla, E., "Keying Material Exporters for Transport
              Layer Security (TLS)", RFC 5705, March 2010.

   [RFC5801]  Josefsson, S. and N. Williams, "Using Generic Security
              Service Application Program Interface (GSS-API) Mechanisms
              in Simple Authentication and Security Layer (SASL): The
              GS2 Mechanism Family", RFC 5801, July 2010.

   [RFC5849]  Hammer-Lahav, E., "The OAuth 1.0 Protocol", RFC 5849,
              April 2010.

   [RFC6614]  Winter, S., McCauley, M., Venaas, S., and K. Wierenga,
              "Transport Layer Security (TLS) Encryption for RADIUS",
              RFC 6614, May 2012.

   [OASIS.saml-core-2.0-os]
              Cantor, S., Kemp, J., Philpott, R., and E. Maler,
              "Assertions and Protocol for the OASIS Security Assertion
              Markup Language (SAML) V2.0", OASIS Standard saml-
              core-2.0-os, March 2005.




Howlett, et al.         Expires January 31, 2014               [Page 42]

Internet-Draft             ABFAB Architecture                  July 2013


   [RFC2904]  Vollbrecht, J., Calhoun, P., Farrell, S., Gommans, L.,
              Gross, G., de Bruijn, B., de Laat, C., Holdrege, M., and
              D. Spence, "AAA Authorization Framework", RFC 2904, August
              2000.

   [I-D.ietf-emu-crypto-bind]
              Hartman, S., Wasserman, M., and D. Zhang, "EAP Mutual
              Cryptographic Binding", draft-ietf-emu-crypto-bind-03
              (work in progress), March 2013.

   [I-D.ietf-emu-eap-tunnel-method]
              Zhou, H., Cam-Winget, N., Salowey, J., and S. Hanna,
              "Tunnel EAP Method (TEAP) Version 1", draft-ietf-emu-eap-
              tunnel-method-05 (work in progress), February 2013.

   [I-D.ietf-radext-dtls]
              DeKok, A., "DTLS as a Transport Layer for RADIUS", draft-
              ietf-radext-dtls-03 (work in progress), January 2013.

   [I-D.ietf-radext-dynamic-discovery]
              Winter, S. and M. McCauley, "NAI-based Dynamic Peer
              Discovery for RADIUS/TLS and RADIUS/DTLS", draft-ietf-
              radext-dynamic-discovery-06 (work in progress), February
              2013.

   [WS-TRUST]
              Lawrence, K., Kaler, C., Nadalin, A., Goodner, M., Gudgin,
              M., Barbir, A., and H. Granqvist, "WS-Trust 1.4", OASIS
              Standard ws-trust-200902, February 2009, <http://docs
              .oasis-open.org/ws-sx/ws-trust/v1.4/ws-trust.html>.

   [NIST-SP.800-63]
              Burr, W., Dodson, D., and W. Polk, "Electronic
              Authentication Guideline", NIST Special Publication
              800-63, April 2006.

Authors' Addresses

   Josh Howlett
   JANET(UK)
   Lumen House, Library Avenue, Harwell
   Oxford  OX11 0SG
   UK

   Phone: +44 1235 822363
   Email: Josh.Howlett@ja.net





Howlett, et al.         Expires January 31, 2014               [Page 43]

Internet-Draft             ABFAB Architecture                  July 2013


   Sam Hartman
   Painless Security

   Email: hartmans-ietf@mit.edu


   Hannes Tschofenig
   Nokia Siemens Networks
   Linnoitustie 6
   Espoo  02600
   Finland

   Phone: +358 (50) 4871445
   Email: Hannes.Tschofenig@gmx.net
   URI:   http://www.tschofenig.priv.at


   Eliot Lear
   Cisco Systems GmbH
   Richtistrasse 7
   Wallisellen, ZH  CH-8304
   Switzerland

   Phone: +41 44 878 9200
   Email: lear@cisco.com


   Jim Schaad
   Soaring Hawk Consulting

   Email: ietf@augustcellars.com




















Howlett, et al.         Expires January 31, 2014               [Page 44]
