<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc='yes'?>
<?rfc tocdepth='4'?>
<?rfc compact="yes"?>
<rfc category="std" ipr="trust200902" docName='draft-kyzivat-clue-signaling-05'>

<!--56789012345678901234567890123456789012345678901234567890123456789-->

<!-- Notes:

Paul's messages from 12/18/12 4:11PM and 12/19/12 11:21AM
formed a starting point for this draft.

-->

<front>
   <title abbrev="CLUE Signaling">
      CLUE Signaling
   </title>
   <author initials="P." surname="Kyzivat" fullname="Paul Kyzivat">
      <organization>Huawei</organization>
      <address>
         <email>pkyzivat@alum.mit.edu</email>
      </address>
   </author>
   <author initials="L." surname="Xiao" fullname="Lennard Xiao">
      <organization>Huawei</organization>
      <address>
         <email>lennard.xiao@huawei.com</email>
      </address>
   </author>
   <author initials="C." surname="Groves" fullname="Christian Groves">
      <organization>Huawei</organization>
      <address>
         <email>Christian.Groves@nteczone.com</email>
      </address>
   </author>
   <author initials="R." surname="Hansen" fullname="Robert Hansen">
         <organization>Cisco Systems</organization>
         <address>
            <email>rohanse2@cisco.com</email>
         </address>
      </author>
   
   <date year="2013" />
   <abstract>
      <t>

This document specifies how signaling is conducted in the course of CLUE sessions.
This includes how SIP/SDP signaling is applied to CLUE sessions as well as defining 
a CLUE-specific signaling protocol that complements SIP/SDP and supports negotiation
of CLUE application level data.

      </t>
   </abstract>
</front>
<middle>
   <section title="Introduction">
      <t>

This document specifies how signaling is conducted in the course of CLUE sessions.
This includes how SIP/SDP signaling is applied to CLUE sessions as well as defining 
a CLUE-specific signaling protocol that complements SIP/SDP and supports negotiation
of CLUE application level data. 

      </t>
      <t>

[Yes, this is a dup of the abstract for now. Eventually it should say more.]

      </t>

   </section>

   <section title="Terminology">
      <t>

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.

      </t>
      <t>

This document draws liberally from the terminology defined in the
<xref target="I-D.ietf-clue-framework">CLUE Framework</xref>.

      </t>

      <t>

Other terms introduced here:

      </t>
      <t><list style='hanging'>
         <t hangText="CLUE Channel:">

A reliable, bidirectional, transport mechanism used to convey CLUE messages.
A CLUE channel consists of one SCTP stream in each direction over a DTLS/SCTP session.

         </t>

      </list></t>

   </section>

   <section title="CLUE-Specific Signaling Protocol " anchor="sec.protocol">
      <t>
The <xref target="I-D.ietf-clue-framework">CLUE Framework</xref> mentions a CLUE-specific 
protocol for the exchange of ADVERTISEMENT and CONFIGURE messages, but gives little detail.
The <xref target="I-D.presta-clue-data-model-schema">Data Model</xref> specifies a model
and XML representation for CLUE-related data, but doesn't currently specify exactly what
data belongs in each message, or how messages are sequenced. 
This document provides the detail missing from those documents.
      </t>

         <section title="CLUE Messages" anchor="sec.messages">
               <t>
CLUE messages have the following characteristics:
               </t>
               <t><list style='symbols'>
                  <t>
They are encoded in XML, following the schema in section <xref target="sec.syntax"/>].
                  </t>
                  <t>
There are two kinds of messages – requests and responses.
(This is similar to SIP.)
                  </t>
                  <t>
Every request message expects exactly one response message.
                  </t>
                  <t>
Every request message carries a sequence number that identifies it.
                  </t>
                  <t>
Each end of the connection assigns sequential sequence numbers to the requests it sends.
                  </t>
                  <t>
Every response message carries the sequence number of the message to which it responds.
                  </t>
                  <t>
Responses are to be sent promptly upon the receipt of a request. (Needs more detail.)
                  </t>
                  <t>
Responses also carry info describing the error.
                  </t>
               </list></t>

            <section title="Request Messages">
              <t>
A request message specifies an action the sender is requesting the recipient to perform. There are a number of request types, each of which describes a different action. Each carries parameters qualifying the action.
              </t>
            </section>

            <section title="Response Messages">
              <t>
The recipient of a request message must send a response message that acknowledges that the request has been received. The response indicates if the request was processed successfully, and if not, then the reason for failure. A special reason (OK) indicates that the request was processes successfully.
              </t>
            </section>

            <section title="CLUE Requests">
              <t>
              </t>

              <section title="ADVERTISEMENT Message">
               <t>
This message contains XML representations of captures, capture scenes, 
encoding groups, and simultaneous sets
using the types defined for those in the 
<xref target="I-D.presta-clue-data-model-schema">Data Model</xref>.
               </t>
               <t>
               </t>
               <t>
The XML definition for this is element &lt;advertisement&gt; in section
<xref target="sec.syntax"/>.
               </t>
               <t>
[[ Currently this does not contain any representation of encodings. 
It assumes those will be defined in SDP. ]]
               </t>
             </section>

             <section title="CONFIGURE Message">
               <t>
This message optionally contains an XML representations of captureEncodings
using the type defined in the 
<xref target="I-D.presta-clue-data-model-schema">Data Model</xref>.
A configure message with no captureEncodings indicates that no captures are requested.
               </t>
               <t>
[[ It currently also contains a reference to the request number of the advertisement
it is based upon. Whether this should be present, or if it should implicitly reference
the most recently acknowledged advertisement is TBD. ]]
               </t>
               <t>
The XML definition for this is element &lt;configure&gt; in section
<xref target="sec.syntax"/>
               </t>
             </section>

             <section title="SUPPORTED Message">
               <t>
The Supported message describes the CLUE versions, and options, supported by the sender.
The details of how use this message are presented in section <xref target="sec.versionNegotiation"/>.
               </t>
             </section>

             <section title="REQUIRED Message">
               <t>
The Required message describes the CLUE version, and options, 
that have been negotiated by the sender and the receiver.
The details of how use this message are presented in section <xref target="sec.versionNegotiation"/>.
               </t>
             </section>

            </section>

            <section title="CLUE Response Reasons">

               <t>
The following reasons are defined:
               </t>

               <t><list style='hanging'>
                  <t hangText="OK:">
The message was successfully processed.
                  </t>
                  <t hangText="Syntax Error:">
Message has failed due to a syntax error detected at the message level.
The message does not conform to the schema. 
Used when the message cannot be parsed.
                  </t>
                  <t hangText="Sequencing Error:">
Sequence number has already been used, or is greater than the expected number.
(Details of possible errors depend upon the specific sequence numbering mechanism.)
                  </t>
                  <t hangText="Version incompatibility:">
There is no common value between the major version numbers supported
by the two endpoints of the CLUE channel.
                  </t>
                  <t hangText="Option incompatibility:">
<![CDATA[ 
This can occur if options supported by one endpoint are inconsistent with those supported by the other endpoint. E.g., The <mediaProvider> option is not specified by either endpoint. Options SHOULD be specified so as to make it difficult for this problem to occur. ]]>
<vspace blankLines='1'/><![CDATA[ 
This error may also be used to indicate that insufficient options have been required among the two ends for a useful session to result. This can occur with a feature that needs to be present on at least one end, but not on a specific end. E.g., The <mediaProvider> option was Supported by at least one of the endpoints, but it was not Required by either.]]>
<vspace blankLines='1'/>This may also be used to indicate that an option element in the Required message has attributes or body content that is syntactically correct, but in inconsistent with the rules for option negotiation specified for that particular element. The definition of each option must specify the negotiation rules for that option.                  </t>
                  <t hangText="Unsupported option:">
Unsupported option
<vspace blankLines='1'/>An option element type received in a Required message did not appear in the corresponding Supported element.
<vspace blankLines='1'/>(This code is never received in response to a Supported message.)
                  </t>
                  <t hangText="Unknown capture identity:">
The received Configure message contains an unknown capture identity 
not previously declared by an Advertisement. The message is ignored.
                  </t>
                  <t hangText="Invalid identity:">
The received Configure message contains an invalid capture identity. 
For example a duplicated Capture scene identity or some other semantically incorrect usage. 
The message has ignored.
                  </t>
                  <t hangText="Invalid value:">
The received message contains an invalid parameter value. 
The value is not according to the specification for the containing element.
                  </t>
                  <t hangText="Missing element:">
The received message is missing an element. 
Certain parameters require multiple values, 
e.g. Point of capture requires X,Y,Z co-ordinates 
if one or more elements are missing this error code is used.
                  </t>
                  <t hangText="Conflicting parameters or values:">
The received message contains multiple values that may not be used together.
                  </t>
                  <t hangText="Invalid capture area:">
The received message defines a capture area that cannot be rendered in a sensible manner. 
For example the capture area does not define a quadrilateral region.
                  </t>
                  <t hangText="Invalid point of line of capture:">
The indicated co-ordinate for the point on line of capture is invalid. 
For example: does not lie between the point of capture and the area of capture 
or it is the same as the point of capture.
                  </t>
                  <t hangText="Invalid capture scene entry:">
The message contains an invalid capture scene entry. 
For example the capture scene entry contains more than one media type.
                  </t>
                  <t hangText="Invalid Simultaneous Set:">
The simultaneous set contained in the message is invalid. 
For example the simultaneous set refers to an undefined capture set 
or does not match the specified capture scene entries.
                  </t>
                  <t hangText="Invalid Configuration:">
The Configure message requests a configuration that the provider cannot support.
                  </t>
                  <t hangText="Invalid Advertisement reference:">
The Configure message refers to an invalid Advertisement. 
The message refers-to/depends-upon out-of-date ADVERTISEMENT message 
or provides an invalid reference.
                  </t>
               </list></t>

            </section>

         </section>

         <section title="Message Sequencing" anchor="sec.sequencing">
            <t>
[[NOTE: Should have some state machines formalizing this sequencing.]]
            </t>
            <section title="Pairing of Requests and Responses">
              <t>
Each endpoint of a CLUE channel sends both requests and responses.
For each request sent, a prompt response is required.
Each response identifies the request to which it responds.
After sending a request, one or more requests may be received before a response is received.
              </t>
            </section>

            <section title="Version Negotiation Happens First"
                     anchor="sec.versionNegotiation">
              <t>
Upon establishment of the CLUE channel, version and option negotiation, 
using Supported and Required requests, MUST complete before any other requests 
are sent on the channel. Refer to section <xref target="sec.versioning"/>
for details of this process.
              </t>
            </section>

            <section title="Provider and Consumer Roles">
              <t>
Each CLUE endpoint has two roles that it potential performs: provider and consumer.
In common cases an endpoint can perform both roles. 
Which roles are actually performed is determined during option negotiation.
              </t>
              <t>
              </t>
            </section>

            <section title="Independent Sequencing of Provider and Consumer Roles">
              <t>
In the provider role, an endpoint sends Advertisement messages and receives Configure messages.
              </t>
              <t>
In the consumer role, an endpoint receives Advertisement messages and sends Configure messages.
              </t>
              <t>
The messages (requests and responses) used by each role are exchanged over the same
CLUE channel, and may be interleaved in an arbitrary manner, 
constrained only by the sequencing rules for each role.
              </t>
            </section>

         <section title="Signaling Changes in Provider State">
            <t>
Once a CLUE session has been established, ADVERTISEMENTs and CONFIGUREs exchanged,
and media is flowing, a provider may experience a change in state that has an
effect on what it wishes or is able to provide. In this case it may need to
alter what it is sending and/or send a new ADVERTISEMENT. In some cases it 
will be necessary to alter what is being sent without first sending a new
ADVERTISEMENT and waiting for a CONFIGURE conforming to it.
            </t>
            <t>
The following is a non-exhaustive list of situations and recommended actions:
            </t>
            <t><list style='symbols'>
               <t>
An advertised capture, that is not currently configured, is no longer available.
   <vspace blankLines='1'/>
To recover from this: Send a new ADVERTISEMENT that omits this capture. 
               </t>
               <t>
An advertised capture, that has been configured, is no longer available.
   <vspace blankLines='1'/>
To recover from this: (1) stop transmitting the configured encoding of this capture. 
(2) Send a new ADVERTISEMENT that omits this capture.
               </t>
               <t>
The provider loses some resource and must reduce the frame rate, frame size,
or resolution of a capture encoding.
   <vspace blankLines='1'/>
If the reduced values still fall within the advertised values for the capture
then the change may be made without any further signaling.
   <vspace blankLines='1'/>
If the change must be outside the range of what was advertised,
then the provider must cease transmitting the capture encoding. 
It then must send a new ADVERTISEMENT reflecting what it is now capable of delivering.
               </t>
               <t>
New or changed scenes or scene geometry. 
For instance, the addition of a new scene containing presentation captures.
Also, an MCU may make significant changes in what it advertises as new
endpoints join a conference.
               </t>
               <t>
[Add more]
               </t>
            </list></t>
         </section>

         <section title="Signaling Changes in Consumer State">
            <t>
If the Consumer for some reason looses the CLUE state information 
how does it ask for an Advertisement from the provider? 
There could be multiple possibilities. A error code approach? 
However error codes would typically be associated with a NACK so it may not be good for a Config message. 
Maybe send a message which means “send me a complete update”.
An alternative may be to release the connection or just do new signaling to establish a new CLUE session.
            </t>
         </section>

            <section title="Dangling Text [[TODO: FIX]]">

            <t>
There is a very basic introduction to this topic in section 4 (Overview) of the
<xref target="I-D.ietf-clue-framework">CLUE Framework</xref>. 
After removing extraneous material it would look like:
            </t>

            <figure align="center">
               <artwork align="center"><![CDATA[
 +-----------+                     +-----------+
 | Endpoint1 |                     | Endpoint2 |
 +----+------+                     +-----+-----+
      |                                  |
      | ADVERTISEMENT 1                  |
      |*********************************>|
      |                  ADVERTISEMENT 2 |
      |<*********************************|
      |                                  |
      |                      CONFIGURE 1 |
      |<*********************************|
      | CONFIGURE 2                      |
      |*********************************>|
      |                                  |
               ]]></artwork>
            </figure>
            <t>

But we need much more than this, to show multiple CONFIGUREs per ADVERTISEMENT, 
interleaving of ADVERTISEMENTs and CONFIGUREs in both directions, etc.

            </t>

            <t>
Message sequencing needs to be described at two levels:
            </t>

            <t><list style='symbols'>
               <t>

Basic sequencing of the CLUE messages themselves, 
without regard for the SIP/SDP signaling that may be going on at the same time.
This is useful to cover the basic concepts. That should be covered in this section.
It provides context for understanding the more detailed treatment later.
<vspace blankLines='1'/>
This could include some simple state machines.

               </t>
               <t>

In reality there is a complex dependency between CLUE signaling and 
SDP Offer/Answer exchanges carried in SIP signaling.
So there is a need to describe the valid ways in which these
two forms of signaling interact. That is covered in
<xref target="sec.coordination"/>.

               </t>
            </list></t>

            </section>
      </section>

         <section title="Protocol Versioning and Options" anchor="sec.versioning">

            <section title="Versioning Objectives">
               <t>
The CLUE versioning mechanism addresses the following needs:
               </t>
               <t>
                  <list style='symbols'>
                     <t>Coverage:
                        <list style='symbols'>
                        <t>Versioning of basic behavior and options,</t>
                        <t>CLUE message exchange,</t>
                        <t>CLUE message exchange,</t>
                        <t>coordinated use of SIP and SDP,</t>
                        <t>required media behavior.</t>
                        </list>
                     </t>
                     <t>Remain fixed for the duration of the CLUE channel</t>
                     <t>Be extensible for configuration of new options.</t>
                     <t>
Be sufficient (with extensions) for all envisioned future versions.
                     </t>
                  </list>
               </t>
            </section>

            <section title="Versioning Overview">
               <t>
An initial message exchange on the CLUE channel handles the negotiation of version and options.
               </t>
               <t>
                  <list style='symbols'>
                     <t>
Dedicated message types are used for this negotiation.
                     </t>
                     <t>
The negotiation is repeated if the CLUE channel is reestablished.
                     </t>
                  </list>
               </t>
               <t>
The version usage is similar in philosophy to XMPP:
               </t>
               <t>
                  <list style='symbols'>
                     <t>
See <xref target="RFC6120"/> section 4.7.5.
                     </t>
                     <t>
A version has major and minor components. (Each a non-negative integer.)
                     </t>
                     <t>
Major version changes denote non-interoperable changes.
                     </t>
                     <t>
Minor version changes denote schema changes that are backward compatible by ignoring unknown XML elements, or other backward compatible changes.                     </t>
                     <t>
If a common major version cannot be negotiated, then CLUE MUST NOT be used.
                     </t>
                     <t>
The same message exchange also negotiates options.
                     </t>
                     <t>
Each option is denoted by a unique XML element in the negotiation.

                     </t>
                  </list>
               </t>
               <t>
<xref target="fig.simpleOptNeg"/> shows the negotiation in simplified form:
               </t>
               <t>
               </t>
               <figure anchor="fig.simpleOptNeg" 
                       title="Basic Option Negotiation (simplified)"
                       align="center" >
                  <artwork align="center"><![CDATA[
| Supported       Supported ||------------\ /------------||             X             ||<-----------/ \----------->||                           || Required         Required ||------------\ /------------||             X             ||<-----------/ \----------->||                           ||  Advertise/Configure/...  ||<------------------------->|
                  ]]></artwork>
               </figure>
               <t>
Dedicated message types are used for the negotiation because:
               </t>
               <t>
                  <list style='symbols'>
                     <t>
The protocol can then ensure that the negotiation is done first, and once. 
Not changing mid-session means an endpoint can plan ahead, and predict what may be used and what might be received.
                     </t>
                     <t>
This provides extensible framework for negotiating optional features.
                     </t>
                     <t>
A full option negotiation can be completed before other messages are exchanged.
                     </t>
                  </list>
               </t>
               <t>
<xref target="fig.simpleSupportedMsg"/> and  <xref target="fig.simpleRequiredMsg"/>
are simplified examples of the Supported and Required messages: 
               </t>

               <figure anchor="fig.simpleSupportedMsg" 
                       title="Supported Message (simplified)"
                       align="center" >
                  <artwork align="center"><![CDATA[
<supported>	<version major=“1” minor=“0”>	  <!– May repeat version if multiple         major versions supported.      ->   <!- Options follow ->   <mediaProvider/>	...</supported>
                  ]]></artwork>
               </figure>
               <t>
               </t>

               <figure anchor="fig.simpleRequiredMsg" 
                       title="Required Message (simplified)"
                       align="center" >
                  <artwork align="center"><![CDATA[
<required>	<version major=“1” minor=“0”>	  <!– Requested options of peer follow ->   <!- Options follow ->   <mediaProvider/>	...</required>
                  ]]></artwork>
               </figure>
               <t>
               </t>

            </section>

            <section title="Version Negotiation">
               <t>
<![CDATA[ 
The Supported message includes one or more <version> elements, each denoting a major/minor version combination that the sender of the message is capable of supporting. 
]]>
               </t>
               <t>
<![CDATA[ 
The <version> element contains both a major and minor version. Each is a non-negative integer. Each <version> element in the message MUST contain a unique major version number, distinct from the major version number in all the other <version> elements in the message. The minor version in a <version> element denotes the largest minor version the sender supports for the corresponding major version. (Minor versions are always backwards compatible, so support for a minor version implies support for all smaller minor versions.)
]]>
               </t>
               <t>
Each endpoint of the CLUE channel sends a Supported message, and receives the Supported message sent by the other end. Then each end compares the versions sent and the versions received to determine the version to be used for this CLUE session. 
               </t>
               <t>
                  <list style='symbols'>
                     <t>
If there is no major version in common between the two ends, negotiation fails.                     </t>
                     <t>
<![CDATA[ 
The <version> elements from the two ends that have the largest matching major version are selected.
]]>
                     </t>
                     <t>
After exchange each end determines compatible version numbers to be used for encoding and decoding messages, and other behavior in the CLUE session.

                        <list style='symbols'>
                           <t>
<![CDATA[ 
The <version> elements from the two ends that have the largest matching major version are selected.]]>
                           </t>
                           <t>
The side that sent the smaller minor version chooses the one it sent.
                           </t>
                           <t>
The side that sent the larger minor version may choose the minor version it received, or the one it sent, or any value between those two. 
                           </t>
                        </list>
                     </t>
                     <t>
<![CDATA[ 
Each end then sends a Required message with a single <version> element containing the major and minor versions it has chosen.
]]>
<vspace blankLines='1'/>[[Note: “required” is the wrong semantic for this. Might want a better message name.]]                     </t>
                     <t>
Each end then behaves in accord with the specifications denoted by the version it chose. This continues until the end of the CLUE session, or until changed as a result of another version negotiation when the CLUE channel is reestablished.
<vspace blankLines='1'/>[[Note: The version negotiation remains in effect even if the CLUE channel is lost.]]

                     </t>
                  </list>
               </t>
            </section>

            <section title="Option Negotiation">
               <t>
Option negotiation is used to agree upon which options will be available for use within the CLUE session. (It does not say that these options must be used.) This may be used for both standard and proprietary options. (As used here, and option could be either a feature described as part of this specification that is optional to implement, or a feature defined in a separate specification that extends this one.)               </t>
               <t>
Each end includes, within the Supported message it sends, elements describing those options it is willing and able to use with this CLUE session.               </t>
               <t>
Each side, upon receiving a Supported message, selects from that message those option elements that it wishes the peer to use. (If/when occasion for that use arises.) It then includes those selected elements into the Required message that it sends.               </t>
               <t>
Within a received Supported message, unknown option elements MUST be ignored. This includes elements that are of a known type that is not known to denote an option.               </t>
            </section>

            <section title="Option Elements">
               <t>
Each option is denoted, in the Supported and Required messages, by an XML element. There are no special rules for these elements – they can be any XML element. The attributes and body of the element may carry further information about the option. The same element type is used to denote the option in the Supported message and the corresponding Required message, but the attributes and body may differ according to  option-specific rules. This may be used to negotiate aspects of a particular option. The ordering of option elements is irrelevant within the Supported and Required messages, and need not be consistent in the two.                </t>
                <t>
<![CDATA[ 
Only one option element is defined in this document: <mediaProvider>.]]>
               </t>
               <section title="&lt;mediaProvider&gt;">
                  <t>
<![CDATA[ 
The <mediaProvider> element, when placed in a Supported message, indicates that the sender is willing and able to send Advertisement messages and receive Configure messages.When placed in a Required message, the <mediaProvider> element indicates that the sender is willing, able, and desirous of receiving Advertisement messages and sending Configure messages. If an endpoint does not receive <mediaProvider> in a Required message, it MUST NOT send Advertisement messages. For common cases <mediaProvider> should be supported and required by both endpoints, to enable bidirectional exchange of media. If not required by either end, the CLUE session is useless. This is an error condition, and SHOULD result in termination of the CLUE channel.]]>
                  </t>
                  <t>
<![CDATA[ 
The <mediaProvider> element has no defined attributes or body.]]>
                  </t>
               </section>

            </section>

            <section title="Version &amp; option negotiation errors">
               <t>
The following are errors that may be detected and reported during version negotiation:               </t>
               <t>
                  <list style='symbols'>
                     <t>
Version incompatibility<vspace blankLines='1'/>There is no common value between the major version numbers sent in a Supported message and those in the received Supported message.
                 </t>
                     <t>
Option incompatibility
<vspace blankLines='1'/><![CDATA[ 
This can occur if options supported by one endpoint are inconsistent with those supported by the other endpoint. E.g., The <mediaProvider> option is not specified by either endpoint. Options SHOULD be specified so as to make it difficult for this problem to occur. ]]>
<vspace blankLines='1'/><![CDATA[ 
This error may also be used to indicate that insufficient options have been required among the two ends for a useful session to result. This can occur with a feature that needs to be present on at least one end, but not on a specific end. E.g., The <mediaProvider> option was Supported by at least one of the endpoints, but it was not Required by either.]]>
<vspace blankLines='1'/>This may also be used to indicate that an option element in the Required message has attributes or body content that is syntactically correct, but in inconsistent with the rules for option negotiation specified for that particular element. The definition of each option must specify the negotiation rules for that option.                     </t>
                     <t>
Unsupported option
<vspace blankLines='1'/>An option element type received in a Required message did not appear in the corresponding Supported element.
<vspace blankLines='1'/>(Unsupported options received in a Supported message do not trigger this error. They are ignored.)
                     </t>
                  </list>
               </t>
               <t>
These errors are reported using the normal message error reporting mechanism.               </t>
               <t>
Other applicable error codes may also be returned in response to a Supported or Required message.                </t>
               <t>
Errors that occur at this stage result in negotiation failure. When this occurs, CLUE cannot be used until the end of the SIP session, or until a new CLUE channel is negotiated and a subsequent version negotiation succeeds. The SIP session may continue without CLUE features.               </t>
            </section>

            <section title="Definition and Use of Version Numbers">
               <t>
[[NOTE: THIS IS AWKWARD. SUGGESTIONS FOR BETTER WAYS TO DEFINE THIS ARE WELCOME.]]               </t>
               <t>
This document defines CLUE version 1.0 (major=1, minor=0). This denotes the normative behavior defined in this document and other documents upon which it normatively depends, including but is not limited to:
               </t>
               <t>
                  <list style='symbols'>
                     <t>
the schema defined in <xref target="sec.syntax"/> of this document;                     </t>
                     <t>
the schema defined in [clue-data-model];                     </t>
                     <t>
the protocol used to exchange CLUE messages;                     </t>
                     <t>
the protocol defined herein that defines valid sequence of CLUE messages;                     </t>
                     <t>
the specific rules defined herein for employing SIP, SDP, and RTP to realize the CLUE messages.
                     </t>
                  </list>
               </t>
                <t>
Given two CLUE versions Vx and Vy, then Vx is backward compatible with Vy if and only if:
               </t>
               <t>
                  <list style='symbols'>
                     <t>
All messages valid according to the schema of Vx are also valid according to the schemas of Vy                     </t>
                     <t>
All messages valid according to the schema of Vy can be made valid according to the schemas of Vx by deleting elements undefined in the schemas of Vx. 
<vspace blankLines='1'/>[[NOTE: THIS PROBABLY NEEDS WORK!]]                     </t>
                     <t>
All normative behaviors defined for Vx are defined consistently for Vy. 
<vspace blankLines='1'/>[[NOTE: SOME HAND WAVING HERE.]]
                     </t>
                  </list>
               </t>
               <t>
Revisions, updates,  to any of the documents denoted by Version 1.0 MAY result in the definition of a new CLUE version. If they do, then this document MUST be revised to define the new version.               </t>
               <t>
The CLUE version to be defined in a revision to this document MUST be determined as follows:
               </t>
               <t>
                  <list style='symbols'>
                     <t>
If the revision and the document being revised are mutually backward compatible (they are functionally equivalent), then the CLUE version MUST remain unchanged.                     </t>
                     <t>
Else if the revision is backward compatible with the document being revised, then the CLUE major version MUST remain unchanged, and the CLUE minor version MUST be increased by one (1).                     </t>
                     <t>
Else the CLUE major version must be increased by one (1), and the CLUE minor version set to zero (0).                     </t>
                  </list>
               </t>
               <t>
When a CLUE implementation sends a Supported message, it MUST include the CLUE versions it is willing and able to conform with.
               </t>
            </section>

            <section title="Version &amp; Option Negotiation Examples">
               <t>
               </t>

               <section title="Successful Negotiation - Multi-version">
                  <t>
                  </t>
                  <figure align="center">
                     <artwork align="center"><![CDATA[
| Supported       Supported || Version 2.0               || Version 1.2   Version 1.1 || mediaProv       mediaProv ||------------\ /------------||             X             ||<-----------/ \----------->||                           || OK response   OK response ||------------\ /------------||             X             ||<-----------/ \----------->||                           || Required         Required || Version 1.2   Version 1.1 || mediaProv       mediaProv ||------------\ /------------||             X             ||<-----------/ \----------->||                           || OK response   OK response ||------------\ /------------||             X             ||<-----------/ \----------->||                           ||         Advertise         ||<------------------------->||                           ||         Configure         ||<------------------------->|
                     ]]></artwork>
                  </figure>
                  <t>
The endpoint on the left can support versions 1.2 and 2.0, and
because of backward compatibility can support versions 1.0 and 1.1.
The endpoint on the right supports only version 2.0.
Both endpoints with to both provide and consume media. 
They each send a Supported message indicating what they support.
                  </t>
                  <t>
The element on the left, upon receiving the Supported message, 
determines that it is permitted to use version 1.2 or 1.1,
and decides to use 1.2. 
It sends a Required message containing version 1.2 and also includes
the mediaProvider option element, because it wants its peer to
provide media.
                  </t>
                  <t>
The element on the right, upon receiving the Supported message, 
selects version 1.1 because it is the highest version in common 
to the two sides. It sends a Required message containing version 1.1
because that is the highest version in common. It also includes
the mediaProvider option element, because it wants its peer to
provide media.
                  </t>
                  <t>
Upon receiving the Required messages, both endpoints determine
that they should send Advertisements.
                  </t>
                  <t>
Advertisement and Configure messages will flow in both directions.
                  </t>

               </section>

               <section title="Successful Negotiation - Consumer-Only Endpoint">
                  <t>
                  </t>
                  <figure align="center">
                     <artwork align="center"><![CDATA[
| Supported       Supported || Version 1.0   Version 1.0 || mediaProv       (no opts) ||------------\ /------------||             X             ||<-----------/ \----------->||                           || OK response   OK response ||------------\ /------------||             X             ||<-----------/ \----------->||                           || Required         Required || Version 1.0   Version 1.0 || (no opts)       mediaProv ||------------\ /------------||             X             ||<-----------/ \----------->||                           || OK response   OK response ||------------\ /------------||             X             ||<-----------/ \----------->||                           ||  Advertise                ||-------------------------->||                           ||                 Configure ||<--------------------------|
                     ]]></artwork>
                  </figure>
                  <t>
The endpoint on the right consumes media, but doesn't provide any 
so it doesn't include the mediaProvider option element in the Supported message it sends. 
                  </t>
                  <t>
The element on the left would like to include a mediaProvider option element
in the Requirements message it sends, but can't because it did not receive one in
the Supported message it received.
                  </t>
                  <t>
Advertisement messages will only go from left to right, 
and Configure messages will only go from right to left.
                  </t>

               </section>

               <section title="Successful Negotiation - Provider-Only Endpoint">
                  <t>
                  </t>
                  <figure align="center">
                     <artwork align="center"><![CDATA[
| Supported       Supported || Version 1.0   Version 1.0 || mediaProv       mediaProv ||------------\ /------------||             X             ||<-----------/ \----------->||                           || OK response   OK response ||------------\ /------------||             X             ||<-----------/ \----------->||                           || Required         Required || Version 1.0   Version 1.0 || (no opts)       mediaProv ||------------\ /------------||             X             ||<-----------/ \----------->||                           || OK response   OK response ||------------\ /------------||             X             ||<-----------/ \----------->||                           ||  Advertise                ||-------------------------->||                           ||                 Configure ||<--------------------------|
                     ]]></artwork>
                  </figure>
                  <t>
The endpoint on the left provides media but does not consume any
so it includes the mediaProvider option element in the Supported message it sends,
but does't include the mediaProvider option element in the Required message it sends.
                  </t>
                  <t>
Advertisement messages will only go from left to right, 
and Configure messages will only go from right to left.
                  </t>

               </section>

               <section title="Version Incompatibility">
                  <t>
                  </t>
                  <figure align="center">
                     <artwork align="center"><![CDATA[
| Supported       Supported || Version 1.2   Version 2.1 ||------------\ /------------||             X             ||<-----------/ \----------->||                           || Version           Version || Incompat.       Incompat. ||------------\ /------------||             X             ||<-----------/ \----------->||                           ||     close clue channel    ||<------------------------->||                           ||     legacy mode or BYE    ||<------------------------->|
                     ]]></artwork>
                  </figure>
                  <t>
Upon receiving the Supported message, each endpoint discovers there is
no major version in common, so CLUE usage is not possible. 
Each sends an error response indicating this and then ceases CLUE usage.
                  </t>

               </section>

               <section title="Option Incompatibility">
                  <t>
                  </t>
                  <figure align="center">
                     <artwork align="center"><![CDATA[
| Supported       Supported || Version 1.0   Version 1.0 || mediaProv       mediaProv ||------------\ /------------||             X             ||<-----------/ \----------->||                           || Required         Required || (no opts)       (no opts) ||------------\ /------------||             X             ||<-----------/ \----------->||                           || Option             Option || Incompat.       Incompat. ||------------\ /------------||             X             ||<-----------/ \----------->||                           ||     close clue channel    ||<------------------------->||                           ||     legacy mode or BYE    ||<------------------------->|
                     ]]></artwork>
                  </figure>
                  <t>
Neither of the endpoints is willing to provide media. 
It makes no sense to continue CLUE operation in this situation.
Each endpoint realizes this upon receiving the Supported message,
sends an error response indicating this and then ceases CLUE usage.
                  </t>

               </section>

               <section title="Syntax Error">
                  <t>
                  </t>
                  <figure align="center">
                     <artwork align="center"><![CDATA[
| Supported          !@#$%^ ||------------\ /------------||             X             ||<-----------/ \----------->||                           || syntax error  OK response ||------------\ /------------||             X             ||<-----------/ \----------->||                           ||     close clue channel    ||-------------------------->||                           ||     legacy mode or BYE    ||<------------------------->|
                     ]]></artwork>
                  </figure>
                  <t>
                  </t>

               </section>

            </section>

         </section>

         <section title="Message Syntax" anchor="sec.syntax">

               <t>
[[ The following is a first cut at a schema for the actual messages in the clue protocol.
It uses &lt;encodingGroups&gt; from the data model but not &lt;encodings&gt;.
Rather, it assumes that encodings are described in SDP as m-lines with a text identifier, 
and that the identifier has the same value as the encodingIDs embedded in the &lt;encodingGroups&gt;.
If we stick with this the data model should be adjusted to agree, but until then it should "work".
The SDP encoding of the identifier is proposed to be 'a=label:ID', though 'a=mid:ID' is another candidate. ]] 
               </t>
               <t>
For now there only &lt;advertisement&gt; and &lt;configure&gt; are defined.
More messages will be needed for acknowledgment.
               </t>

            <figure><artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8" ?>
<xs:schema
   targetNamespace="urn:ietf:params:xml:ns:clue-message"
   xmlns:tns="urn:ietf:params:xml:ns:clue-message"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:dm="urn:ietf:params:xml:ns:clue-info"
   xmlns="urn:ietf:params:xml:ns:clue-message"
   elementFormDefault="qualified"
   attributeFormDefault="unqualified">

<!-- Import data model schema -->
   <xs:import namespace="urn:ietf:params:xml:ns:clue-info" 
              schemaLocation="clue-data-model-04-wip.xsd"/>

<!-- ELEMENT DEFINITIONS -->
<xs:element name="response"  type="responseMessageType"/>
<xs:element name="advertisement" type="advertisementMessageType"/>
<xs:element name="configure" type="configureMessageType"/>
<xs:element name="supported" type="supportedMessageType"/>
<xs:element name="required"  type="requiredMessageType"/>

<!-- CLUE MESSAGE TYPE -->
<xs:complexType name="clueMessageType" abstract="true">
  <xs:sequence>
    <!-- mandatory fields -->
    <!-- TBS: version info -->
  </xs:sequence>
</xs:complexType>

<!-- CLUE REQUEST MESSAGE TYPE -->
<xs:complexType name="clueRequestMessageType" abstract="true">
 <xs:complexContent>
  <xs:extension base="clueMessageType">
   <xs:sequence>
     <!-- mandatory fields -->
     <xs:element name="requestNumber" type="xs:integer"/>
   </xs:sequence>
  </xs:extension>
 </xs:complexContent>
</xs:complexType>

<!-- CLUE RESPONSE MESSAGE TYPE -->
<xs:complexType name="clueResponseMessageType">
 <xs:complexContent>
  <xs:extension base="clueMessageType">
   <xs:sequence>
     <!-- mandatory fields -->
     <xs:element name="requestNumber" type="xs:integer"/>
     <xs:element name="reason" type="reasonType" minOccurs="1"/>
     <!-- optional fields -->
     <xs:any namespace="##other"
         processContents="lax" minOccurs="0"/>
   </xs:sequence>
  </xs:extension>
 </xs:complexContent>
</xs:complexType>

<!-- CLUE ADVERTISEMENT MESSAGE TYPE -->
<xs:complexType name="advertisementMessageType">
 <xs:complexContent>
  <xs:extension base="clueRequestMessageType">
   <xs:sequence>
     <!-- mandatory fields -->
     <xs:element name="mediaCaptures"
                 type="dm:mediaCapturesType"/>
     <xs:element name="encodingGroups"
                 type="dm:encodingGroupsType"/>
     <!-- The encodings are defined via identifiers in the SDP, 
          referenced in encodingGroups -->
     <xs:element name="captureScenes"
                 type="dm:captureScenesType"/>
     <!-- optional fields -->
     <xs:element name="simultaneousSets"  
                 type="dm:simultaneousSetsType" minOccurs="0"/>
     <xs:any namespace="##other"
             processContents="lax" minOccurs="0"/>
   </xs:sequence>
  </xs:extension>
 </xs:complexContent>
</xs:complexType>

<!-- CLUE CONFIGURE MESSAGE TYPE -->
<xs:complexType name="configureMessageType">
 <xs:complexContent>
  <xs:extension base="clueRequestMessageType">
   <xs:sequence>
     <!-- mandatory fields -->
     <xs:element name="advertisementNumber" type="xs:integer"/>
     <!-- advertisementNumber is requestNumber
          of the advertisement-->
     <!-- optional fields -->
     <xs:element name="captureEncodings" 
                 type="dm:captureEncodingsType" minOccurs="0"/>
     <xs:any namespace="##other" 
             processContents="lax" minOccurs="0"/>
   </xs:sequence>
  </xs:extension>
 </xs:complexContent>
</xs:complexType>

<!-- CLUE SUPPORTED MESSAGE TYPE -->
<xs:complexType name="supportedMessageType">
 <xs:complexContent>
  <xs:extension base="clueRequestMessageType">
   <xs:sequence>
     <!-- mandatory fields -->
     <xs:element name="version"
                 type="versionType"
                 maxOccurs="unbounded"/>
     <!-- optional fields -->
     <xs:element name="Options"  
                 type="OptionsType" minOccurs="0"/>
     <xs:any namespace="##other"
             processContents="lax" minOccurs="0"/>
   </xs:sequence>
  </xs:extension>
 </xs:complexContent>
</xs:complexType>

<!-- CLUE REQUIRED MESSAGE TYPE -->
<xs:complexType name="requiredMessageType">
 <xs:complexContent>
  <xs:extension base="clueRequestMessageType">
   <xs:sequence>
     <!-- mandatory fields -->
     <xs:element name="version"
                 type="versionType"
                 maxOccurs="1"/>
     <!-- optional fields -->
     <xs:element name="Options"  
                 type="OptionsType" minOccurs="0"/>
     <xs:any namespace="##other"
             processContents="lax" minOccurs="0"/>
   </xs:sequence>
  </xs:extension>
 </xs:complexContent>
</xs:complexType>

<!-- OPTIONS TYPE -->
<xs:complexType name="optionsType">
  <!-- each element represents one option -->
  <xs:any processContents="lax" minOccurs="0"/>
</xs:complexType>

<!-- REASON TYPE -->
<xs:complexType name="reasonType">
  <xs:simpleContent>
    <xs:extension base="xs:string">
      <xs:attribute type="xs:short" name="code" use="required"/>
    </xs:extension>
  </xs:simpleContent>
</xs:complexType>

</xs:schema>   
            ]]></artwork></figure>

            <t>
            </t>
         </section>

         <section title="Message Transport" anchor="sec.transport">
            <t>

CLUE messages are transported over a bidirectional CLUE channel.  
In a two-party CLUE session, a CLUE channel connects the two endpoints.
In a CLUE conference, each endpoint has a CLUE channel connecting it to an MCU. 
(In conferences with cascaded mixers <xref target="RFC4353"/>, 
two MCUs will be connected by a CLUE channel.)

            </t>

            <section title="CLUE Channel Lifetime">
               <t>
The transport mechanism used for CLUE messages is DTLS/SCTP as specified in 
<xref target="I-D.tuexen-tsvwg-sctp-dtls-encaps"/> and 
<xref target="I-D.ietf-mmusic-sctp-sdp"/>. 
A CLUE channel consists of one SCTP stream in each direction over a DTLS/SCTP session.
The mechanism for establishing the DTLS/SCTP session is described in
<xref target="sec.sdp_oa"/>.
               </t>
               <t>
The CLUE channel will usually be offered during the initial SIP INVITE,
and remain connected for the duration of the CLUE/SIP session.
However this need not be the case. The CLUE channel may be established
mid-session after desire and capability for CLUE have been determined,
and the CLUE channel may be dropped mid-call if the desire and/or capability
to support it is lost.
               </t>
               <t>
There may be cases when it becomes necessary to "reset" the CLUE channel.
This by be as a result of an error on the underlying SCTP association,
a need to change the endpoint address of the SCTP association, 
loss of CLUE protocol state, or something else TBD.
               </t>
               <t>
The precise mechanisms used to determine when a reset is required,
and how to accomplish it and return to a well defined state are TBS.
               </t>
            </section>

            <section title="Channel Error Handling" anchor="sec.channel-errors">
               <t>
We will need to specify behavior in the face of transport errors that are so
severe that they can't be managed via CLUE messaging within the CLUE channel.
Some errors of this sort are:
               <list style='symbols'>
                  <t>
Unable to establish the SCTP association after signaling it in SDP.
                  </t>
                  <t>
CLUE channel setup rejected by peer.
                  </t>
                  <t>
Error reported by transport while writing message to CLUE channel. 
                  </t>
                  <t>
Error reported by transport while reading message from CLUE channel.
                  </t>
                  <t>
Timeout - overdue acknowledgement of a CLUE message. 
(Requirements for now soon a message must be responded to are TBD.)
                  </t>
                  <t>
Application fault. CLUE protocol state lost.
                  </t>
               </list>
The worst case is to drop the entire CLUE call.
Another possibility is to fall back to legacy compatibility mode.
Or perhaps a "reset" can be done on the protocol. E.g. this might be
accomplished by sending a new O/A and establishing a replacement SCTP association.
Or a new CLUE channel might be established within the existing SCTP association.
               </t>
            </section>

         </section>

         <section title="Message Framing">
            <t>
Message framing is provided by the SCTP transport protocol.
Each CLUE message is carried in one SCTP message.
            </t>
         </section>

   </section>

   <section title="CLUE use of SDP O/A" anchor="sec.sdp_oa">

      <section title="Establishing the CLUE channel" anchor="sec.sdp_clue_channel">
         <t>
The CLUE channel is usually offered in the first SIP O/A exchange between two parties in an intended CLUE session.
The offer of the CLUE channel is the indicator that this SIP session is proposing to establish a CLUE session.
         </t>
         <t>
(However it is also acceptable to start with a non-CLUE SIP session and upgrade it to a CLUE session later.)
         </t>
         <t>
The mechanism for negotiating a DTLS/SCTP connection is specified in <xref target="I-D.ietf-mmusic-sctp-sdp"/>.
We need to specify how to select the specific pair of SCTP streams that comprise the CLUE channel.
         </t>
         <t>
The presence of an active m-line for the CLUE channel in an SDP offer is an indication that the offer that the sender is CLUE-capable and hence can understand CLUE-specific syntax.    
         </t>
      </section>

      <section title="Representing CLUE Encodings in SDP">
         <t>
Many CLUE constructs have no good analog in SDP. Entities such as 'captures', 
which describe spatial and other properties of a capture source such as a camera,
are not tied directly to RTP streams, do not have negotiated properties and would prove a significant challenge to represent in SDP syntax (while also greatly increasing the size of the SDP).
         </t>
         <t>
However, two entities defined in the <xref target="I-D.ietf-clue-framework">CLUE Framework</xref> are a much closer fit for SDP:
Encodings and Encoding Groups. Both describe RTP media properties and limitations,
though unlike most SDP usage they describe the sender's capabilities, not the receiver's.
Representing encodings in CLUE splits media limitations across two protocols,
and risks duplicated and potentially contradictory information being sent in CLUE and SDP.
As such we are exploring representing this information in SDP,
with the decision to convey them in the CLUE messages only to be made if the SDP approach proves impractical.
         </t>
         <t>
This draft presents an attempt to describe CLUE encodings in SDP. 
As a decision has not yet been reached on how multiplexed RTP streams are to be expressed in SDP,
at this stage the draft does so without multiplexing, using existing SDP attributes,
with a seperate "m" line and hence port per unidirectional RTP stream. 
This is done with the understanding that when a decision is reached on new syntax for multiplexing RTP streams in SDP the CLUE SDP signaling will be modified to use it.
Further, the framework document states that the multiplexing of streams by an implementation is optional,
and in the case of a disaggregated system, with media streams going to different addresses, may not be possible.
         </t>
         <t>
With the current scheme of using existing syntax,
an encoding is specified in SDP as a unicast "m" line, which MUST be marked as sendonly with the "a=sendonly" attribute
or as inactive with the "a=inactive" attribute.
The encoder capabilities of the stream are defined here using existing syntax; 
for instance, for H.264 see Table 6 in <xref target="RFC6184" /> for a list of valid parameters for representing encoder sender stream limits.
         </t>
         <t>
Every "m" line representing a CLUE encoding SHOULD contain a "label" attribute as defined in <xref target="RFC4574" />.
This label is used to identify the encoding by the sender in CLUE Advertisement messages and by the receiver in CLUE Configure messages.
         </t>
         <t>
A receiver who wishes to receive a CLUE stream via this encoding requires a matching "a=recvonly" "m" line.
As well as the normal restrictions defined in <xref target="RFC3264" /> media MUST NOT be sent on this stream
until the sender has received a valid CLUE Configure message specifying the capture to be used for this stream.
         </t>
      </section>
    
      <section title="Representing CLUE Encoding Groups in SDP">
         <t>
As per the previous section, there would be advantages to conveying encoding group information in SDP.
However, with current SDP syntax there is no way to express the encoding group limits defined in the  <xref target="I-D.presta-clue-data-model-schema">Data Model</xref>.
As such the current draft keeps encoding groups as part of the Advertisement message for the time being.
         </t>
      </section>

      <section title="Signaling CLUE control of &quot;m&quot; lines">
         <t>
In many cases an implementation may wish to mix media channels that are under CLUE control with those that are not.
It may want to ensure that there are non-CLUE streams for purposes of interoperability,
or that can provide media from the start of the call before CLUE negotiation completes,
or because the implementation wants CLUE-controlled video but traditional audio,
or for any other reasons.
         </t>
         <t>
Which "m" lines in an SDP body are under control of the CLUE channel is signalled via the <xref target="RFC5888">SDP Grouping Framework</xref>.
Devices that wish to negotiate CLUE MUST support the grouping framework.
         </t>
         <t>
A new semantic for the "group" session-level attribute, "CLUE", is used to signal which "m" lines are under the control of a CLUE channel.
As per the framework, all of the "m" lines of a session description that uses "group" MUST be identified with a "mid" attribute whether they are controlled by CLUE or not.
The "mid" id of any "m" lines controlled by a CLUE channel MUST be included in the "CLUE" group attribute alongside the "mid" id of the CLUE channel controlling them.
         </t>
         <t>
The CLUE group MUST NOT include more than one "m" line for a CLUE channel.
If a CLUE channel is part of the CLUE group attribute other media "m" lines  included in the group are under the control of that CLUE channel;
media MUST NOT be sent or received on these "m" lines until the CLUE channel has been negotiated and negotiation has taken place as defined in this document.
If no CLUE channel is part of the CLUE group attribute then media MUST NOT be sent or received on these "m" lines. 
         </t>
         <t>
"m" lines not specified as under CLUE control follow normal rules for media streams negotiated in SDP as defined in documents such as <xref target="RFC3264" />.
         </t>
         <t>
An SDP MAY include more than one group attribute with the "CLUE" semantic. An "mid" id for a given "m" line MUST NOT be included in more than one CLUE group.
         </t>
      </section>
      <section title="Ensuring interoperability with non-CLUE devices">
         <t>
A CLUE-capable device sending an initial SDP offer SHOULD include an "m" line for the CLUE channel,
but SHOULD NOT include any other CLUE-controlled "m" lines. 
Once each side of the call is aware that the other side is CLUE-capable a new 
O/A exchange MAY be used to add CLUE-controlled "m" lines.
        </t>
      </section>
   </section>

   <section title="Interaction of CLUE and SDP negotiations" anchor="sec.coordination">
      <t>
Information about media streams in CLUE is split between two message types:
SDP, which defines media addresses and limits, and the CLUE channel,
which defines properties of capture devices available, scene information and additional constraints.
As a result certain operations, such as advertising support for a new transmissible capture with associated stream,
cannot be performed atomically, as they require changes to both SDP and CLUE messaging.
      </t>
      <t>
This section defines how the negotiation of the two protocols interact,
provides some recommendations on dealing with intermediary stages in non-atomic operations,
and mandates additional constraints on when CLUE-configured media can be sent.   
      </t>      
      <section title="Independence of SDP and CLUE negotiation">         
         <t>
To avoid complicated state machines with the potential to reach invalid states if messages were to be lost,
or be rewritten en-route by middle boxes, the current proposal is that SDP and CLUE messages are independent.
The state of the CLUE channel does not restrict when an implementation may send a new SDP offer or answer,
and likewise the implementation's ability to send a new CLUE Advertisement or Configure message is not restricted
by the results of or the state of the most recent SDP negotiation.
         </t>
         <t>
The primary implication of this is that a device may receive an SDP with a CLUE
encoding it does not yet have capture information for,
or receive a CLUE Configure message specifying a capture encoding for which the
far end has not negotiated a media stream in SDP.
         </t>
         <t>
CLUE messages contain an EncodingID which is used to identify a specific encoding in SDP.
The non-atomic nature of CLUE negotiation means that a sender may wish to send a new Advertisement before the corresponding SDP message.
As such the sender of the CLUE message MAY include an EncodingID which does not currently match an extant id in SDP.
         </t>
      </section>
      <section title="Recommendations for operating with non-atomic operations">
         <t>
Generally, implementations that receive messages for which they have incomplete information
SHOULD wait until they have the corresponding information they lack before sending messages to make changes related to that information.
For instance, an implementation that receives a new SDP offer with three new "a=sendonly" 
CLUE "m" lines that has not received the corresponding CLUE Advertisement providing the
capture information for those streams SHOULD NOT include corresponding "a=recvonly" lines in its answer,
but instead should make a new SDP offer when and if a new Advertisement arrives with captures relevant to those encodings.
         </t>         
         <t>
Because of the constraints of offer/answer and because new SDP negotiations are generally more 'costly' than sending a new CLUE message,
implementations needing to make changes to both channels SHOULD prioritize sending the updated CLUE message over sending the new SDP message.
The aim is for the recipient to receive the CLUE changes before the SDP changes, 
allowing the recipient to send their SDP answers without incomplete information,
reducing the number of new SDP offers required.
         </t>
      </section>
     <section title="Constraints on sending media">
         <t>
While SDP and CLUE message states do not impose constraints on each other, both impose constraints on the sending of media - 
media MUST NOT be sent unless it has been negotiated in both CLUE and SDP:
an implementation MUST NOT send a specific CLUE capture encoding unless its most
recent SDP exchange contains an active media channel for that encoding AND
the far end has sent a CLUE Configure message specifying a valid capture for that encoding.
         </t>
      </section>
   </section>

   <section title="Example: A call between two CLUE-capable endpoints" anchor="sec-clueexample">
      <t>
This example illustrates a call between two CLUE-capable endpoints.
Alice, initiating the call, is a system with three cameras and three screens.
Bob, receiving the call, is a system with two cameras and two screens.
A call-flow diagram is presented, followed by an summary of each message.
      </t>
      <t>
To manage the size of this section only video is considered, and SDP snippets only
illustrate video 'm' lines. ACKs are not discussed.
      </t>
      <figure>
         <artwork>
            <![CDATA[ 
                  	
              +----------+                      +-----------+
              |  Alice   |                      |    Bob    |
              |          |                      |           |
              +----+-----+                      +-----+-----+
                   |                                  |
                   |                                  |
                   | INVITE 1 (BASIC SDP+COMEDIA)     |
                   |--------------------------------->|
                   |                                  |
                   |                                  |
                   |     200 OK 2 (BASIC SDP+COMEDIA) |
                   |<---------------------------------|
                   |                                  |
                   |                                  |
                   | ACK 1                            |
                   |--------------------------------->|
                   |                                  |
                   |                                  |
                   |                                  |
                   |<########### MEDIA 1 ############>|
                   |   1 video A->B, 1 video B->A     |
                   |<################################>|
                   |                                  |
                   |                                  |
                   |                                  |
                   |<================================>|
                   |   CLUE CTRL CHANNEL ESTABLISHED  |
                   |<================================>|
                   |                                  |
                   |                                  |
                   | ADVERTISEMENT 1                  |
                   |*********************************>|
                   |                                  |
                   |                                  |
                   |                  ADVERTISEMENT 2 |
                   |<*********************************|
                   |                                  |
                   |                                  |
                   | INVITE 2 (+3 sendonly)           |
                   |--------------------------------->|
                   |                                  |
                   |                                  |
                   |                      CONFIGURE 1 |
                   |<*********************************|                   
                   |                                  |
                   |                                  |
                   |           200 OK 2 (+2 recvonly) |
                   |<---------------------------------|
                   |                                  |
                   |                                  |
                   | ACK 2                            |
                   |--------------------------------->|
                   |                                  |
                   |                                  |
                   |                                  |
                   |<########### MEDIA 2 ############>|
                   |   2 video A->B, 1 video B->A     |
                   |<################################>|
                   |                                  |
                   |                                  |
                   |           INVITE 3 (+2 sendonly) |
                   |<---------------------------------|
                   |                                  |                   
                   |                                  |
                   | CONFIGURE 3                      |
                   |*********************************>|
                   |                                  |
                   |                                  |
                   | 200 OK 3 (+2 recvonly)           |
                   |--------------------------------->|                   
                   |                                  |
                   |                                  |
                   |                                  |
                   |                            ACK 3 |
                   |<---------------------------------|
                   |                                  |
                   |                                  |
                   |                                  |
                   |<########### MEDIA 3 ############>|
                   |   2 video A->B, 2 video B->A     |
                   |<################################>|                   
                   |                                  |
                   |                                  |
                   |                                  |
                   v                                  v	
            ]]>
         </artwork>
      </figure>    
      <t>
In INVITE 1, Alice sends Bob a SIP INVITE including in the SDP body the basilar audio and video capabilities 
("BASIC SDP") and the information needed for opening a control channel to be used 
for CLUE protocol messages exchange, according to what is envisioned in the COMEDIA approach ("COMEDIA") 
for DTLS/SCTP channel <xref target="I-D.ietf-mmusic-sctp-sdp"/>.
A snippet of the SDP showing the grouping attribute and the video m-line are shown below (mid 3 represents the CLUE channel):  
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 3
   ...
   m=video 6002 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:2                           
               ]]>
            </artwork>
         </figure>         
      </t>
      <t>
Bob responds with a similar SDP (200 OK 1); due to their similiarity no SDP snippet is shown here.
Alice and Bob are each able to send a single audio and video stream (whether they choose to send this initial media
before CLUE has been negotiated is implementation-dependent). This is illustrated as MEDIA 1.
      </t>
      <t>
With the successful initial O/A Alice and Bob are also free to negotiate the CLUE channel.
Once this is successfully established CLUE negotiation can begin.   This is illustrated as CLUE CHANNEL ESTABLISHED.  
      </t>
      <t>
Alice now sends her CLUE Advertisement (ADVERTISEMENT 1). 
She advertises three static captures representing her three cameras. 
She also includes switched captures suitable for two- and one-screen systems.
All of these captures are in a single capture scene,
with suitable capture scene entries to tell Bob that he should either subscribe to the three static captures,
the two switched capture view or the one switched capture view.
Alice has no simultaneity constraints, so includes all six captures in one simultaneous set.
Finally, Alice includes an encoding group with three encoding IDs: "enc1", "enc2" and "enc3".
These encoding ids aren't currently valid, but will match the next SDP offer she sends.
      </t>  
      <t>
Bob received ADVERTISEMENT 1 but does not yet send a Configure message, 
because he has not yet received Alice's encoding information, 
so as yet he does not know if she will have sufficient resources to send him the two streams he ideally wants at a quality he is happy with.
      </t>  
      <t>
Bob also sends his CLUE Advertisement (ADVERTISEMENT 2). 
He advertises two static captures representing his cameras. 
He also includes a single composed capture for single-screen systems,
in which he will composite the two camera views into a single video stream.
All three captures are in a single capture scene,
with suitable capture scene entries to tell Alice that she should either subscribe to the two static captures,
or the single composed capture.
Bob also has no simultaneity constraints, so includes all three captures in one simultaneous set.
Bob also includes a single encoding group with two encoding IDs: "foo" and "bar".
      </t>
      <t>
Similarly, Alices receives ADVERTISEMENT 2 but does not yet send a Configure message,
because she has not yet received Bob's encoding information.
      </t>
      <t>
Alice now sends INVITE 2. She maintains the sendrecv audio, video and CLUE m-lines,
and she adds three new sendonly m-lines to represents the maximum three encodings she can send.
Each of these m-lines has a label corresponding to one of the encoding ids from ADVERTISEMENT 1.
Each also has its mid added to the grouping attribute to show they are controlled by the CLUE channel.
A snippet of the SDP showing the grouping attribute and the video m-lines are shown below (mid 3 represents the CLUE channel):
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 3 4 5 6
   ...
   m=video 6002 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:2
   ...
   m=video 6004 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=mid:4
   a=label:enc1
   m=video 6006 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=mid:5
   a=label:enc2
   m=video 6008 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=mid:6
   a=label:enc3                           
               ]]>
            </artwork>
        </figure>         
      </t>    
      <t>
Bob now has all the information he needs to decide which streams to configure.
As such he now sends CONFIGURE 1. This requests the pair of switched captures that represent Alice's scene,
and he configures them with encoder ids "enc1" and "enc2".
      </t>
      <t>
Alice receives Bob's message CONFIGURE 1 but does not yet send the capture encodings specified,
because at this stage Bob hasn't negotiated the ability to receive these streams in SDP.
      </t>
      <t>
Bob now sends his SDP answer as part of 200 OK 2.
Alongside his original audio, video and CLUE m-lines he includes two active recvonly m-lines and a zeroed m-line for the third.
He adds their mid values to the grouping attribute to show they are controlled by the CLUE channel.
A snippet of the SDP showing the grouping attribute and the video m-lines are shown below (mid 100 represents the CLUE channel):
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 11 12 100
   ...
   m=video 58722 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:10
   ...
   m=video 58724 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600   
   a=recvonly
   a=mid:11
   m=video 58726 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=recvonly
   a=mid:12
   m=video 0 RTP/AVP 96                          
               ]]>
            </artwork>
         </figure>         
      </t>
      <t>
On receiving 200 OK 2 from Bob Alice is now able to send the two streams of video Bob requested -
this is illustrated as MEDIA 2.
      </t>
      <t>
The constraints of offer/answer meant that Bob could not include his encoder information as new m-lines in 200 OK 2.
As such Bob now sends INVITE 3 to generate a new offer. Along with all the streams from 200 OK 2
Bob also includes two new sendonly streams.
Each stream has a label corresponding to the encoding ids  in his ADVERTISEMENT 2 message.
He also adds their mid values to the grouping attribute to show they are controlled by the CLUE channel.
A snippet of the SDP showing the grouping attribute and the video m-lines are shown below (mid 100 represents the CLUE channel):
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 11 12 13 14 100
   ...
   m=video 58722 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:10
   ...
   m=video 58724 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600   
   a=recvonly
   a=mid:11
   m=video 58726 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=recvonly
   a=mid:12
   m=video 0 RTP/AVP 96
   m=video 58728 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=label:foo
   a=mid:13
   m=video 58730 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=label:bar
   a=mid:14
               ]]>
            </artwork>
         </figure>
      </t>
      <t>
Having received this Alice now has all the information she needs to send CONFIGURE 2.
She requests the two static captures from Bob, to be sent on encodings "foo" and "bar".
      </t>
      <t>
Bob receives Alice's message CONFIGURE 2 but does not yet send the capture encodings specified,
because Alice hasn't yet negotiated the ability to receive these streams in SDP.
      </t>      
      <t>
Alice now sends 200 OK 3, matching two recvonly m-lines to Bob's new sendonly lines.
She includes their mid values in the grouping attribute to show they are controlled by the CLUE channel.
A snippet of the SDP showing the grouping attribute and the video m-lines are shown below (mid 3 represents the CLUE channel):
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 3 4 5 7 8
   ...
   m=video 6002 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:2
   ...
   m=video 6004 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=mid:4
   a=label:enc1
   m=video 6006 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=mid:5
   a=label:enc2
   m=video 0 RTP/AVP 96
   m=video 6010 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=recvonly
   a=mid:7
   m=video 6012 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=recvonly
   a=mid:8
               ]]>
         </artwork>
      </figure>
      </t>
      <t>
Finally, on receiving 200 OK 3 Bob is now able to send the two streams of video Alice requested -
this is illustrated as MEDIA 3.
      </t>
      <t>
Both sides of the call are now sending multiple video streams with their sources defined via CLUE negotiation.
As the call progresses either side can send new Advertisement or Configure or new SDP negotiation to add,
remove or change what they have available or want to receive.
      </t>
   </section>     

   <section title="Example: A call between a CLUE and non-CLUE-capable endpoint" anchor="sec-nonclueexample">
      <t>
In this brief example Alice is a CLUE-capable endpoint making a call to Bob,
who is not CLUE-capable, i.e., it is not able to use the CLUE protocol.
      </t>
         <figure>
            <artwork>
               <![CDATA[

      +----------+                      +-----------+
      |   EP1    |                      |    EP2    |
      |          |                      |           |
      +----+-----+                      +-----+-----+
           |                                  |
           |                                  |
           | INVITE 1 (BASIC SDP+COMEDIA)     |
           |--------------------------------->|
           |                                  |
           |                                  |
           | 200 0K 1 (BASIC SDP+*NO*COMEDIA) |
           |<---------------------------------|
           |                                  |
           |                                  |
           | ACK 1                            |
           |--------------------------------->|
           |                                  |
           |                                  |
           |                                  |
           |<########### MEDIA 1 ############>|
           |   1 video A->B, 1 video B->A     |
           |<################################>|
           |                                  |
           |                                  |
           |                                  |
           |                                  |
           v                                  v	
               ]]>
            </artwork>
         </figure>
      <t>
In INVITE 1, Alice sends Bob a SIP INVITE including in the SDP body the basilar audio and video capabilities 
("BASIC SDP") and the information needed for opening a control channel to be used 
for CLUE protocol messages exchange, according to what is envisioned in the COMEDIA approach ("COMEDIA") 
for DTLS/SCTP channel <xref target="I-D.ietf-mmusic-sctp-sdp"/>.
A snippet of the SDP showing the grouping attribute and the video m-line are shown below (mid 3 represents the CLUE channel):  
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 3
   ...
   m=video 6002 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:2                           
               ]]>
            </artwork>
         </figure>         
      </t>
      <t>
Bob is not CLUE capable, and hence does not recognize the "CLUE" semantic for the grouping attribute,
not does he support the CLUE channel. He responds with an answer with audio and video,
but with the CLUE channel zeroed.
      </t>
      <t>
From the lack of the CLUE channel Alice understands that Bob does not support CLUE, or does not wish to use it.
Both sides are now able to send a single audio and video stream to each other.
Alice at this point begins to send her fallback video:
in this case likely a switched view from whichever camera shows the current loudest participant on her side.
      </t>
   </section>

   <section title="CLUE requirements on SDP O/A" anchor="sec.sdp_rqmts">
      <t>
The current proposal calls for a new "CLUE" semantic for the <xref target="RFC5888">SDP Grouping Framework</xref>.
      </t>
      <t>
Any other SDP extensions required to support CLUE signaling should also be specified here.
Then we will need to take action within MMUSIC to make those happen.
This section should be empty and removed before this document becomes an RFC.
      </t>
      <t>
NOTE: The RTP mapping document 
<xref target="I-D.even-clue-rtp-mapping"/>
is also likely to call for SDP extensions.
We will have to reconcile how to coordinate these two documents.
      </t>
   </section>

   <section title="SIP Signaling" anchor="sec.sip_signaling">
      <t>
(Placeholder) This may be unremarkable. If so we can drop it.
      </t>
   </section>

   <section title="Interoperation with Legacy SIP Devices" anchor="sec.interop">
      <t>
This may just describe how the degenerate form of the general mechanisms
work for legacy devices. Or it may describe special case handling that we
mandate as part of CLUE. Or it may just discuss non-normative things for implementors
should consider.
      </t>
   </section>

   <section title="CLUE over RTCWEB">
      <t>
We may want to rule this out of scope for now. 
But we should be thinking about this.
      </t>
   </section>

   <section title="Open Issues">
      <t>

Here are issues pertinent to signaling that need resolution.
Resolution will probably result in changes somewhere in this document,
but may also impact other documents.


        <list style='symbols'>
         <t>
While the preference is to multiplex multiple capture encodings over a single RTP session,
this will not always be desirable or possible. The factors that prevent multiplexing
may come from either the provider or the consumer. So the extent of multiplexing
must be negotiated. The decision about how to multiplex affects the number and
grouping of m-lines in the SDP. The endpoint of a CLUE session that sends an offer
needs to know the mapping of capture encodings to m-lines for both sides. 
<vspace blankLines='1'/>
AFAIK this issue hasn't yet been considered at all.
         </t>
         <t>
The current method for expressing encodings in SDP limits the parameters available
when describing H264 encoder capabilities to those defined in Table 6 in <xref target="RFC6184" />
         </t>
        </list>
      </t>
   </section>

   <section title="What else?">
      <t>
      </t>
   </section>

   <section title="Acknowledgements">
      <t>
The team focusing on this draft consists of:
Roni Even,
Rob Hansen,
Christer Holmberg,
Paul Kyzivat,
Simon Pietro-Romano,
Roberta Presta.
      </t>
      <t>
Christian Groves has contributed detailed comments and suggestions.
      </t>
      <t>
The author list should be updated as people contribute substantial text to this document.
      </t>
   </section>

   <section title="IANA Considerations">
      <t>

TBD

      </t>
   </section>
   <section title="Security Considerations">
      <t>

TBD

      </t>
   </section>

   <section title="Change History">
      <t><list style='hanging'>
         <t hangText="-05:"> Revisions by pkyzivat:
          <list style='symbols'>
            <t>
Specified versioning model and mechanism.
            </t>
            <t>
Added explicit response to all messages.
            </t>
            <t>
Rearranged text to work with the above changes. 
(Which rendered diff almost useless.)
            </t>
          </list>
         </t>
         <t hangText="-04:"> Revisions by Rob Hansen: ???</t>
         <t hangText="-03:"> Revisions by pkyzivat: 
          <list style='symbols'>
            <t>
Added a syntax section with an XML schema for CLUE messages.
This is a strawhorse, and is very incomplete, but it establishes
a template for doing this based on elements defined in the data model.
(Thanks to Roberta for help with this!)
            </t>
            <t>
Did some rewording to fit the syntax section in and reference it.
            </t>
            <t>
Did some relatively minor restructuring of the document to make
it flow better in a logical way.
            </t>
          </list>

         </t>
         <t hangText="-02:"> A bunch of revisions by pkyzivat: 
         <list style='symbols'>
            <t>
Moved roberta's call flows to a more appropriate place in the document.
            </t>
            <t>
New section on versioning.
            </t>
            <t>
New section on NAK.
            </t>
            <t>
A couple of possible alternatives for message acknowledgment.
            </t>
            <t>
Some discussion of when/how to signal changes in provider state.
            </t>
            <t>
Some discussion about the handling of transport errors.
            </t>
            <t>
Added a change history section.
            </t>
         </list>
These were developed by Lennard Xiao, Christian Groves and Paul, 
so added Lennard and Christian as authors.

         </t>
         <t hangText="-01:">

Updated by roberta to include some sample call flows.

         </t>
         <t hangText="-00:">

Initial version by pkyzivat. Established general outline for the document,
and specified a few things thought to represent wg consensus.

         </t>
      </list></t>
   </section>

</middle>

<back>
   <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.I-D.ietf-clue-framework"?>
      <?rfc include="reference.I-D.presta-clue-data-model-schema"?>
      <?rfc include="reference.I-D.ietf-mmusic-sctp-sdp"?>
      <?rfc include="reference.I-D.tuexen-tsvwg-sctp-dtls-encaps"?>
      <?rfc include="reference.RFC.4574"?>
      <?rfc include="reference.RFC.5888"?>
   </references>
   <references title="Informative References">
      <?rfc include="reference.RFC.4353"?>
      <?rfc include="reference.RFC.3264"?>
      <?rfc include="reference.RFC.6120"?>
      <?rfc include="reference.RFC.6184"?>
      <?rfc include="reference.I-D.even-clue-sdp-clue-relation"?>
      <?rfc include="reference.I-D.even-clue-rtp-mapping"?>
      <?rfc include="reference.I-D.hansen-clue-sdp-interaction"?>
   </references>
</back>
</rfc>
