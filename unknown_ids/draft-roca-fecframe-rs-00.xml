<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<!--<rfc category="std" ipr="full3978" docName="draft-roca-fecframe-rs-00.txt">-->
<!-- <rfc category="std" ipr="trust200811" docName="draft-roca-fecframe-rs-00a.txt">-->
<rfc category="std" ipr="pre5378Trust200902">

<?xml-stylesheet type='text/xsl'
                 href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<!--<?rfc symrefs="no" ?>-->
<?rfc symrefs="yes" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<!--<?rfc compact="yes" ?>-->


	<front>
		<title abbrev='Reed-Solomon FEC Schemes'>
			Reed-Solomon Forward Error Correction (FEC) Schemes for FECFRAME
		</title>

		<author initials='V' surname="Roca" fullname='Vincent Roca'>
			<organization>INRIA</organization>
			<address>
				<postal>
					<street>655, av. de l'Europe</street>
					<street>Inovallee; Montbonnot</street>
					<city>ST ISMIER cedex</city>
					<code>38334</code>
					<country>France</country>
				</postal>
				<email>vincent.roca@inria.fr</email>
				<uri>http://planete.inrialpes.fr/people/roca/</uri>
			</address>
		</author>
		<author initials='M' surname="Cunche" fullname='Mathieu Cunche'>
			<organization>INRIA</organization>
			<address>
				<postal>
					<street>655, av. de l'Europe</street>
					<street>Inovallee; Montbonnot</street>
					<city>ST ISMIER cedex</city>
					<code>38334</code>
					<country>France</country>
				</postal>
				<email>mathieu.cunche@inria.fr</email>
				<uri>http://planete.inrialpes.fr/people/cunche/</uri>
			</address>
		</author>
		<author initials="J" surname="Lacan" fullname="Jerome Lacan">
			<organization>ISAE/LAAS-CNRS</organization>
			<address>
				<postal>
					<street>1, place Emile Blouin</street>
					<city>Toulouse</city>
					<code>31056</code>
					<country>France</country>
				</postal>
				<email>jerome.lacan@isae.fr</email>
				<uri>http://dmi.ensica.fr/auteur.php3?id_auteur=5</uri>
				
			</address>
		</author>
		<author initials="A" surname="Bouabdallah" fullname="Amine Bouabdallah">
			<organization>ISAE/LAAS-CNRS</organization>
			<address>
				<postal>
					<street>1, place Emile Blouin</street>
					<city>Toulouse</city>
					<code>31056</code>
					<country>France</country>
				</postal>
				<email>Amine.Bouabdallah@isae.fr</email>
				<uri>http://dmi.ensica.fr/</uri>
				
			</address>
		</author>
	<author initials="K" surname="Matsuzono" fullname="Kazuhisa Matsuzono">
	  <organization>Keio University</organization>
	  <address>
	    <postal>
	      <street>Graduate School of Media and Governance</street>
	      <street>5322 Endo</street>
	      <city>Fujisawa</city> <region>Kanagawa</region>
	      <code>252-8520</code>
	      <country>Japan</country>
	    </postal>
	    <email>kazuhisa@sfc.wide.ad.jp</email>
	  </address>
	</author>

		<date day="4" month="March" year="2009"/>
		<area>Transport</area>
		<workgroup>FecFrame</workgroup>
		<keyword>I-D</keyword>
		<keyword>Internet-Draft</keyword>
		<keyword>Forward Error Correction</keyword>
		<keyword>Reed-Solomon</keyword>

		<abstract>
<t>
This document describes four fully-specified FEC schemes for Reed-Solomon codes
that can be used to protect media streams along the lines defined by the FECFRAME framework.
Reed-Solomon codes belong to the class of Maximum Distance Separable (MDS) codes which
means they offer optimal protection against packet erasures.
They are also systematic codes, which means that the source symbols are part of the encoding
symbols.
The price to pay is a limit on the maximum source block size, on the maximum number of encoding
symbols, and a computational complexity higher than that of sparse parity check based FEC codes.
However, this complexity remains compatible with software codecs.
<!-- Finally, the FEC schemes described here are compatible with the software codec from Luigi Rizzo.-->
</t>

<t>
The first scheme is for Reed-Solomon codes over GF(2^^m), with m in {2..16}, a global FEC encoding and arbitrary packet flows.
The second scheme is for Reed-Solomon codes over GF(2^^m), with m in {2..16}, the general case FEC encoding, and arbitrary packet flows.
The third (resp. fourth) scheme is similar to the first (resp. second) scheme, with the
exception that it is for a single sequenced flow.
</t>
		</abstract>
	</front>

	<middle>

		<section anchor="Introduction" title="Introduction">
		<!-- =========================================== -->

<t>The use of Forward Error Correction (FEC) codes is a classic solution to improve the reliability
of unicast, multicast and broadcast Content Delivery Protocols (CDP) and applications <xref target="RFC3453"/>.
The <xref target="FECFRAME-FRAMEWORK"/> document describes a generic framework to use FEC schemes
with media delivery applications and in particular with real-time or streaming media applications based
on the RTP real-time protocol.
Similarly the <xref target="RFC5052"/> document describes a generic framework to use FEC schemes
with with objects (e.g., files) delivery applications based on the ALC  <xref target="RMT-PI-ALC"/>
and NORM <xref target="RMT-PI-NORM"/> reliable multicast transport protocols.
</t>

<t>For instance, the <xref target="RFC5053"/> and <xref target="RFC5170"/> FEC schemes introduce
erasure codes based on sparse parity check matrices for object delivery protocols like ALC and NORM.
These codes are efficient in terms of processing but not optimal in terms of erasure recovery
capabilities when dealing with "small" objects.
</t>

<t>The Reed-Solomon FEC codes described in this document belong to the class of Maximum Distance
Separable (MDS) codes that are optimal in terms of erasure recovery capability.
It means that a receiver can recover the k source symbols from any set of exactly k encoding symbols.
However they are limited in terms of maximum source block size and number of encoding symbols.
Since the real-time constraints of media delivery applications usually limit the maximum
source block size, this is not considered to be a major issue in the context of the FEC Framework
for many (but not necessarily all) use-cases.
Additionally, if the encoding/decoding complexity is higher with Reed-Solomon codes than it is with
<xref target="RFC5053"/> or <xref target="RFC5170"/> codes, it remains reasonable for most use-cases,
even in case of a software codec.</t>

<t>Many applications dealing with reliable content transmission or content storage already rely on
packet-based Reed-Solomon codes.
In particular, many of them use the Reed-Solomon codec of Luigi Rizzo  <xref target="RS-codec"/>
<xref target="Rizzo97"/>.
The goal of the present document is to specify Reed-Solomon schemes that are compatible with this codec.
</t>

<t>
The <xref target="RMT-BB-FEC-RS"/> document introduced such Reed-Solomon codes, and the FEC schemes
are compatible with the <xref target="RFC5052"/> framework.
The present document inherits from <xref target="RMT-BB-FEC-RS"/> the specification of the core Reed-Solomon codes
based on Vandermonde matrices, and specifies FEC schemes that are compatible with the
<xref target="FECFRAME-FRAMEWORK"/> framework.
Therefore this document specifies only the information specific to the FECFRAME context and
refers to <xref target="RMT-BB-FEC-RS"/> for the core specifications of the codes.
</t>

<t>The present document introduces:
<list style="symbols">
	<t> the Fully-Specified FEC Scheme with FEC Encoding ID XXX
	that specifies the use of Reed-Solomon codes over GF(2^^m), with m in {2..16},
	a global FEC encoding and for arbitrary packet flows;</t>
	<t> the Fully-Specified FEC Scheme with FEC Encoding ID XXX
	that specifies the use of Reed-Solomon codes over GF(2^^m), with m in {2..16},
	the general case FEC encoding and for a single sequenced flow;</t>
	<t> the Fully-Specified FEC Scheme with FEC Encoding ID XXX
	is similar to Scheme XXX except that it is for a single sequenced flow;</t>
	<t> the Fully-Specified FEC Scheme with FEC Encoding ID XXX
	is similar to Scheme XXX except that it is for a single sequenced flow;</t>
</list>
Distinguishing FEC schemes with a global FEC encoding and FEC schemes with
the general case FEC encoding derives from the small block nature of Reed-Solomon
codes over GF(2^^^8), the default value.
With the general case encoding, protecting a single source data payload block can
require to perform several independent FEC encodings, over different sub-blocks.
A dedicated interleaving solution is then used to assign the various symbols of a
given source packet to the sub-blocks in an optimal way, so as to guaranty the
highest possible erasure recovery capabilities.
</t>
		</section>


		<section anchor="Terminology" title="Terminology">
		<!-- =========================================== -->

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>
		</section>


		<section anchor="DefinitionsNotationsandAbbreviations" title="Definitions Notations and Abbreviations">
		<!-- =========================================== -->


			<section anchor="Definitions" title="Definitions">
			<!-- =========================================== -->

<t>This document uses the same terms and definitions as those specified in  <xref target="RFC5052"/>.
Additionally, it uses the following definitions:

<list style="empty">
<t>Source symbol:		unit of data used during the encoding process.</t>

<t>Encoding symbol:		unit of data generated by the encoding process.
				With systematic codes, source symbols are part
				of the encoding symbols.</t>

<!--
<t>Encoding block:		set of encoding symbols generated by an encoding process.</t>
-->

<t>Repair symbol:		encoding symbol that is not a source symbol.</t>

<t>Code rate:			the k/n ratio, i.e., the ratio between the number
				of source symbols and the number of encoding symbols. The code
				rate belongs to a ]0; 1] interval. A code rate close to 1 indicates
				that a small number of repair symbols have been produced during
				the encoding process.</t>

<t>Systematic code:		FEC code in which the source symbols are part
				of the encoding symbols. The Reed-Solomon codes
				introduced in this document are systematic.</t>

<t>Source block:		a block of k source symbols that are considered
				together for the encoding.</t>

<t>Source Packet:		a data packet containing only source symbols.</t>

<t>Repair Packet:		a data packet containing only repair symbols.</t>

<t>Packet Erasure Channel:	a communication path where packets are either
				dropped (e.g., by a congested router, or because the
				number of transmission errors exceeds the correction
				capabilities of the physical layer codes) or
				received. When a packet is received, it is assumed
				that this packet is not corrupted.</t>

<t>Source Data Flow:		a flow of data payloads coming from an application
				(e.g., using an RTP encapsulation), and to which FEC
				protection is applied.</t>

<t>Source Data Payload:		a unit of data that belongs to a source data flow.</t>

<t>Source Data Payload Block:	a set of source data payloads that are considered
				together by the FECFRAME instance. This is the set
				of symbols over which FEC encoding will be performed,
				either in a global way, or separately, over each
				sub-block.</t>

<t>Sub-Block:			a block of k source symbols, in the general case FEC
				encoding scheme. FEC encoding is performed independently
				over each sub-block.</t>

</list>
</t>
			</section>


			<section anchor="Notations" title="Notations">
			<!-- =========================================== -->

<t>This document uses the following notations:
<list style="empty">
<t>k		denotes the number of source symbols in a source block.</t>
<t>max_k	denotes the maximum number of source symbols for any source block.</t>
<t>n_r		denotes the number of repair symbols generated for a source block.</t>
<t>n		denotes the encoding block length, i.e., the number of
		encoding symbols generated for a source block.
		Therefore: n = k + n_r.</t>
<!--
<t>max_n	denotes the maximum number of encoding symbols generated for any
		source block.</t>
-->
<t>B		denotes the number of source data payloads per source block.</t>
<t>max_B	denotes the maximum number of source data payloads for any source block.</t>
<t>E		denotes the encoding symbol length in bytes.</t>
<t>S		denotes the symbol size in units of m-bit elements.
		When m = 8, then S and E are equal.</t>
<t>m		defines the length of the elements in the finite field, in bits.
		In this document, m belongs to {2..16}.</t>
<t>q		defines the number of elements in the finite field.
		We have: q = 2^^m in this specification.</t>
<t>CR		denotes the "code rate", i.e., the k/n ratio.</t>
<t>a^^b		denotes a raised to the power b.</t>
</list></t>
			</section>

			<section anchor="Abbreviations" title="Abbreviations">
			<!-- =========================================== -->

<t>This document uses the following abbreviations:
<list style="empty">
<t>ESI		stands for Encoding Symbol ID.</t>
<t>FFCI		stands for FEC Framework Configuration Information.</t>
<t>RS		stands for Reed-Solomon.</t>
<t>MDS		stands for Maximum Distance Separable code.</t>
<t>GF(q)	denotes a finite field (also known as Galois Field) with q elements.
		We assume that q = 2^^m in this document.</t>
</list>
</t>
			</section>
		</section>

<section anchor="CommonProcedures" title="Common Procedures Related to the Source Block Creation">
<!-- ================ -->
<t>
This section introduces the procedures that are used during the source block
creation, and that are common to all the FEC schemes introduced in this
document.
</t>

	<section anchor="CommonProc_problem" title="Problem Statement">
	<!-- ==================================== -->
<t>
Several aspects must be considered, that impact the source block creation:
<list style="symbols">
<t> the distribution of source data payload sizes;</t>
<t> the maximum source block size (k parameter) and encoding block size
	(n parameter), that are constrained by the finite field size (m parameter);</t>
<t> the potential real-time constraints, that impact the maximum encoding block size,
	since the larger the block size, the larger the decoding delay;</t>
</list>
We now detail each of these aspects.
</t>

<t>
In its most general form the FECFRAME framework and the RS FEC schemes
are meant to protect a set of independent flows.
Since the flows have no relationship to one another, the source data payloads of each
flow will potentially vary significantly.
Even in the special case of a single flow, the source data payload sizes may largely
vary (e.g., the various frames of a "Group of Pictures (GOP) of an H.264 flow can have
different sizes).
This diversity must be addressed by the source block creation procedure since
the RS FEC scheme requires a constant encoding symbol size (E parameter).
</t>

<t>
The finite field size parameter, m, defines the number of non zero elements in
this field which is equal to: q - 1 = 2^^m - 1.
This q - 1 value is also the theoretical maximum number of encoding symbols that can
be produced for a source block.
For instance, when m = 8 (default) there is a maximum of 2^^8 - 1 = 255 encoding symbols.
So: k < = n < = 255.
Given the target FEC code rate (e.g., provided by the developer when starting the
FECFRAME framework, and taking into account the (known or estimated) packet loss rate),
the sender calculates:
      <list style="empty">
	<t>max_k = floor((2^^m - 1) * CR)</t>
      </list>
This max_k value leaves enough room for the sender to produce the
desired number of repair symbols.
</t>

<t>
The source flows can have real-time constraints. 
It means that the maximum number of source transport payloads of a source block,
which directly impacts the decoding delay, must not exceed a certain threshold.
It is the role of the developer, who knows the flow real-time features, to define an
appropriate upper bound to the source data payload block size, max_B.
</t>

<t>
Another aspect is the appropriate way of performing FEC encoding over
the source data payload block.
Depending of the actual situation, two schemes are feasible:
<list style="symbols">
	<t>There can be situations where a sender needs to protect a small number 
	of source data payloads.
	In that case, all source data payloads, along with additional information
	(flow ID, length, and padding), are virtually split into symbols and a
	global FEC encoding is performed.
	</t>
	<t>There can be situations where a sender needs to protect a large number 
	of source data payloads.
	In that case the number of symbols is large and can easily exceed
	the max_k value.
	For this kind of situation, the present document introduces a general case encoding
	scheme, which defines sub-blocks over which independent FEC encoding is performed.
	</t>
</list>
These two encoding schemes are introduced in the following sections.
</t>

	</section>


	<section anchor="CommonProc_src_block_creation_global_encoding"
		title="Source Block Creation with the Global Encoding Scheme">
	<!-- ==================================== -->

<t>
With the global encoding scheme, the source data payload block is encoded as
a single source block.
There are a total of B < = max_B source data payloads.
For the source data payload i, with 0 < = i < = B-1, 3 bytes are prepended
(<xref target="fig_src_block_creation_global_enc"/>):
<list style="symbols">
	<t>The first byte, FID[i] (Flow ID), contains the integer identifier
		associated to the source flow to which this source data payload
		belongs to.
		It is assumed that a single byte is sufficient, or said
		differently, that no more than 256 flows will be protected by
		a single instance of the FECFRAME framework.
	</t>
	<t>The following two bytes, L[i] (Length), contain the length of this
		source data payload, in network byte order (i.e., big endian).
		This length is for the data payload itself, without considering
		FID[i], L[i], or Pad[i].
	</t>
</list>
Zero padding is also added, in field Pad[i], if needed, for alignment purposes
on symbol boundaries. This can happen at most once per source data payload.
Thanks to this padding, a symbol will never straddle several source data payloads,
nor several source packets.
</t>

<figure anchor="fig_src_block_creation_global_enc" title="Source block creation with the
global encoding scheme, for code rate 1/2 (equal number of source and repair symbols,
7 in this example).">
  <artwork>
  Enc Symbol Len (E)    Enc Symbol Len (E)    Enc Symbol Len (E)
< ------------------ >< ------------------ >< ------------------ >
+----+----+-----------------------+--------+
|F[0]|L[0]|          R[0]         | Pad[1] |
+----+----+----------+------------+--------+
|F[1]|L[1]|   R[1]   |
+----+----+----------+--------------------------------------+----+
|F[2]|L[2]|                      R[2]                       |P[2]|
+----+----+----------+--------------------------------------+----+
|F[3]|L[3]| R[3] | P3|
+----+----+------+---+
\_______________________________  _______________________________/
                                \/
                       global FEC encoding

+--------------------+
|      Repair 4      |
+--------------------+
|      Repair 5      |
+--------------------+
|      Repair 6      |
+--------------------+
|      Repair 7      |
+--------------------+
  </artwork>
</figure>

<t>
Note that neither the initial 3 bytes nor the optional padding
is sent over the network.
However, they are considered when performing FEC encoding, which
means that a receiver who lost a certain UDP datagram (if UDP
is used) will be able to recover both the source data payload
and the initial 3 bytes, as long as FEC decoding succeeds.
</t>
	</section>


	<section anchor="CommonProc_src_block_creation_general_case_encoding"
		title="Source Block Creation with the General Case Encoding Scheme">
	<!-- ==================================== -->

<t>
With the general case encoding scheme, the source data payload block is potentially
split into several sub-blocks.
Each sub-block leads to a different FEC encoding and the appropriate number
of repair symbols are generated, for each sub-block, as specified by the target code
rate.
This constraint comes from the fact that the number of source symbols in the
source data payload block exceeds the max_k value (<xref target="CommonProc_problem"/>).
In this section we define an interleaving approach to distribute the source symbols of
the various packets to sub-blocks in order to guaranty the best possible erasure protection.
Note that this solution is preferable to the alternative approach consisting in
considering smaller source data payload blocks, from an erasure recovery
capability point of view.
Note also that the source block creation with the global encoding scheme
(<xref target="CommonProc_src_block_creation_global_encoding"/>) can also be
regarded as a special case, with a single sub-block.
</t>

<t>
For the source data payload i, with 0 < = i < = B-1, 3 bytes are prepended
and an optional zero padding appended, as in
<xref target="CommonProc_src_block_creation_global_encoding"/>.
</t>

<t>
Let:
<list style="empty">
	<t>s[i] be the number of size of the source data payload i, along with the
	F[i], L[i], and Pad[i] fields, in units of symbols.</t>
	<t>k_tot be the total number of symbols in this source data payload block.
	In other words, k_tot is the sum of all s[i], with 0 < = i < = B-1.</t>
	<t>NSB be the number of sub-blocks for this source data payload block.
	NSB = Ceil(k_tot / max_k).</t>
</list>
Here we assume that k_tot > = max_k (the case where it is equal corresponds to
<xref target="CommonProc_src_block_creation_global_encoding"/>).
The key point here is that maximum erasure recover capabilities require that the
source symbols coming from a certain source packet be spread over the largest possible
number of sub-blocks.
Thereby, the loss of a single source packet will trigger a single symbol erasure on
the corresponding sub-blocks, instead of deeply impacting a single sub-block which
might compromise FEC decoding.
This requirement leads to the definition of an appropriate interleaving scheme.
</t>

<t>
Let us consider the example of <xref target="fig_src_block_creation_general_case_encoding"/>.
</t>
<figure anchor="fig_src_block_creation_general_case_encoding" title="Source block creation with the
general case encoding scheme example (the source data payloads are assumed to be already split in symbols and the F[], L[] and Pad[] fields are not represented).">
  <artwork>
           +----------+
src pkt 0: | symb 0.0 |
           +----------+

           +----------+
src pkt 1: | symb 1.0 |
           +----------+

           +----------+----------+
src pkt 2: | symb 2.0 | symb 2.1 |
           +----------+----------+

           +----------+----------+
src pkt 3: | symb 3.0 | symb 3.1 |
           +----------+----------+

           +----------+----------+----------+
src pkt 4: | symb 4.0 | symb 4.1 | symb 4.2 |
           +----------+----------+----------+
  </artwork>
</figure>

<t>
The source data payload block consists of five packets (B = 5), whose size (in unit of symbols)
is respectively 1, 1, 2, 2, and 3 symbols.
Therefore k_tot = 9 symbols.
If max_k = 3 symbols, then NSB = Ceil(9/3) = 3 sub-blocks.
A good interleaving consists in creating the following sub-blocks:
SB0 = {2.0; 3.0; 4.0},
SB1 = {2.1; 3.1; 4.1}, and
SB2 = {0.0; 1.0; 2.0}.
If the source packet 4 is lost during transmission, then it leads
to a single symbol loss in the three sub-blocks, which will easily be
recovered after FEC decoding.
</t>

<t>
<list><t>----- Editor's note: 
	The exact optimal interleaving algorithm is TBD.
        -----</t>
</list>
</t>

<t>
Here also, neither the initial 3 bytes nor the optional padding
is sent over the network.
However, they are considered when performing FEC encoding, which
means that a receiver who lost a certain UDP datagram (if UDP
is used) will be able to recover both the source data payload
and the initial 3 bytes, as long as FEC decoding succeeds.
</t>
	</section>

</section>


<section anchor="RSover2mArbitraryGE" title="Reed-Solomon FEC Global Encoding Scheme over GF(2^^m) for Arbitrary Packet Flows">
<!-- ==================================== -->

	<section anchor="RSover2mArbitraryGE_formatsAndCodes" title="Formats and Codes">
	<!-- ==================================== -->

		<section title="FEC Framework Configuration Information">
		<!-- ================ -->
<t>
The FEC Framework Configuration Information (or FFCI) includes information
that MUST be communicated between the sender and receiver(s) for the FEC
scheme to operate. It includes both mandatory elements and scheme-specific elements,
as detailed below.
</t>
			<section title="Mandatory Information">
			<!-- ================ -->
<t>
<list style="symbols">
	<t> FEC Encoding ID: the value assigned to this fully-specified FEC scheme MUST be XXX,
	as assigned by IANA (<xref target="iana-cons"/>).</t>
</list>
When SDP is used to communicate the FFCI, this FEC Encoding ID is carried in
the 'encoding-id' parameter.
</t>
			</section>

			<section title="FEC Scheme-Specific Information"
				 anchor="RSover2mArbitraryGE_fssi">
			<!-- ================ -->
<t>
The FEC Scheme Specific Information (FSSI) includes elements that are specific
to the present FEC scheme. More precisely:
<list style="symbols">
<t> Encoding symbol length (E): a non-negative integer indicating the length of each encoding
	symbol in bytes.</t>
<t> m parameter: it defines the length of the elements in the finite field, in bits.
	In this scheme, m belongs to {2..16}.</t>
</list>
The encoding format is the following 3 octet field:
</t>

<figure anchor="fig_RSover2mArbitraryGE_fssi" title="FSSI encoding format."> 
  <artwork>
 0                   1                   2       
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  |       m       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
These elements are required both by the sender (RS encoder) and the receiver(s) (RS decoder).
When SDP is used to communicate the FFCI, this FEC Encoding ID is carried in
the 'fssi' parameter as an opaque octet string.
</t>
			</section>

		</section>


		<section title="Explicit Source FEC Payload ID"
			 anchor="RSover2mArbitraryGE_src_fpi">
		<!-- ================ -->

<t>
A source packet MUST contain an Explicit Source FEC Payload ID that is appended to the
end of the packet as illustrated in <xref target="fig_src_pkt_format"/>.
It contains the original source data payload, and therefore it can span several
source symbols.
</t>

<figure anchor="fig_src_pkt_format" title="Structure of a source packet with the
Explicit Source FEC Payload ID."> 
  <artwork>
+--------------------------------+
|           IP Header            |
+--------------------------------+
|        Transport Header        |
+--------------------------------+
|       Source Data Payload      |
+--------------------------------+
| Explicit Source FEC Payload ID |
+--------------------------------+
  </artwork>
</figure>

<t>
More precisely, the Explicit Source FEC Payload ID is composed of the
Source Block Number and the Encoding Symbol ID.
The length of these two fields depends on the m parameter (which is transmitted
separately in the FFCI, see below):
<list style="symbols">
<t>The Source Block Number (SBN) (32-m bit field) identifies the
   source block to which the source packet belongs.
   There are a maximum of 2^^(32-m) blocks before a wrapping of this field occurs.</t>
<t>The Encoding Symbol ID (ESI) (m bit field) identifies the first
   source symbol associated to this source packet in the source block.
   There are a maximum of 2^^m encoding symbols per block.
   The first k values (0 to k - 1) identify source symbols.</t>
</list>
</t>

<figure anchor="fig_src_fpi_for_8" title="Source FEC Payload ID encoding format for m = 8 (default)."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Source Block Number (32-8=24 bits)       | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<figure anchor="fig_src_fpi_for_16" title="Source FEC Payload ID encoding format for m = 16."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Source Block Nb (16 bits)   |   Enc. Symbol ID (16 bits)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
The format of the FEC Payload ID for m = 8 and m = 16 is illustrated in 
<xref target="fig_src_fpi_for_8"/> and <xref target="fig_src_fpi_for_16"/>
respectively.</t>

		</section>

		<section title="Repair FEC Payload ID" anchor="RSover2mArbitraryGE_repair_fpi">
		<!-- ================ -->
<t>
A repair packet MUST contain a Repair FEC Payload ID that is prepended to the
repair symbol(s) as illustrated in <xref target="fig_repair_pkt_format"/>.
There can be several repair symbols per repair packet.
</t>

<figure anchor="fig_repair_pkt_format" title="Structure of a repair packet with the
Repair FEC Payload ID."> 
  <artwork>
+--------------------------------+
|           IP Header            |
+--------------------------------+
|        Transport Header        |
+--------------------------------+
|      Repair FEC Payload ID     |
+--------------------------------+
|         Repair Symbol          |
+--------------------------------+
  </artwork>
</figure>

<t>
More precisely, the Repair FEC Payload ID is composed of the
Source Block Number, the Encoding Symbol ID and the Source Block Length.
The length of these fields depends on the parameter m (which is transmitted
separately in the FFCI, see below):
<list style="symbols">
<t>The Source Block Number (SBN) (32-m bit field) identifies the
   source block to which the repair packet belongs.
   There are a maximum of 2^^(32-m) blocks before a wrapping of this field occurs.</t>
<t>The Encoding Symbol ID (ESI) (m bit field) identifies the first
   repair symbol contained in this repair packet.
   There are a maximum of 2^^m encoding symbols per block.
   The last n-k values (k to n - k - 1) identify repair symbols.</t>
<t>The Source Block Length (SBL) (16 bit field) provides the actual size of the
   source block, in number of symbols. If 16 bits are too much when m < = 8, it is
   needed when 8 < m < = 16.</t>
  
</list>
</t>

<figure anchor="fig_repair_fpi_for_8" title="Source FEC Payload ID encoding format for m = 8 (default)."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Source Block Number (32-8=24 bits)      | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Source Block Length (SBL)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


  </artwork>
</figure>

<figure anchor="fig_repair_fpi_for_16" title="Source FEC Payload ID encoding format for m = 16."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Source Block Nb (16 bits)   |   Enc. Symbol ID (16 bits)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Source Block Length (SBL)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
The format of the FEC Payload ID for m = 8 and m = 16 is illustrated in 
<xref target="fig_repair_fpi_for_8"/> and <xref target="fig_repair_fpi_for_16"/>
respectively.</t>

		</section>


	</section> <!-- RSover2mArbitraryGE_formatsAndCodes -->

	<section anchor="RSover2mArbitraryGE_Procedures" title="Procedures">
	<!-- ================ -->
<t>
The source block creation procedures are specified in
<xref target="CommonProc_src_block_creation_global_encoding"/>.
More precisely:
<list style="symbols">
	<t>the length indication for the source data payload i,
	used to compute the L[i] field, is the actual length of the
	source data payload i.
	It MUST NOT include FID[i], L[i], Pad[i], nor the Explicit Source
	FEC Payload ID.
	</t>
	<t>
	The SBN value is incremented for each new source block, starting at
	0 for the first block. 
	Wrapping to zero will happen for long sessions, after value 2^^(32-m)-1.
	</t>
	<t>
	The ESI of source symbols are managed sequentially, starting at
	0 for the first symbol.
	</t>
</list>
</t>
	</section>

	<section anchor="RSover2mArbitraryGE_FECCodeSpecification" title="FEC Code Specification">
	<!-- ================ -->
<t>
The present document inherits from <xref target="RMT-BB-FEC-RS"/> the specification of the
core Reed-Solomon codes based on Vandermonde matrices.
</t>
	</section>

</section> <!-- RSover2mArbitraryGE -->




<section anchor="RSover2mArbitraryGCE" title="Reed-Solomon FEC General Case Encoding Scheme over GF(2^^m) for Arbitrary Packet Flows">
<!-- ==================================== -->

	<section anchor="RSover2mArbitraryGCE_formatsAndCodes" title="Formats and Codes">
	<!-- ==================================== -->

		<section title="FEC Framework Configuration Information">
		<!-- ================ -->
<t>
The FEC Framework Configuration Information (or FFCI) includes information
that MUST be communicated between the sender and receiver(s) for the FEC
scheme to operate. It include both mandatory elements and scheme-specific elements,
as detailed below.
</t>
			<section title="Mandatory Information">
			<!-- ================ -->
<t>
<list style="symbols">
	<t> FEC Encoding ID: the value assigned to this fully-specified FEC scheme MUST be XXX,
	as assigned by IANA (<xref target="iana-cons"/>).</t>
</list>
When SDP is used to communicate the FFCI, this FEC Encoding ID is carried in
the 'encoding-id' parameter.
</t>
			</section>

			<section title="FEC Scheme-Specific Information"
				 anchor="RSover2mArbitraryGCE_fssi">
			<!-- ================ -->
<t>
TBD
</t>
			</section>

		</section>

		<section title="Explicit Source FEC Payload ID" anchor="RSover2mArbitraryGCE_src_fpi">
		<!-- ================ -->

<t>
A source packet MUST contain an Explicit Source FEC Payload ID that is appended to the
end of the packet as illustrated in <xref target="fig_src_pkt_format"/>.
</t>

<t>
TBD
</t>

		</section>

		<section title="Repair FEC Payload ID" anchor="RSover2mArbitraryGCE_repair_fpi">
		<!-- ================ -->
<t>
A repair packet MUST contain a Repair FEC Payload ID that is prepended to the
repair symbol(s) as illustrated in <xref target="fig_repair_pkt_format"/>.
</t>

<t>
TBD
</t>

		</section>

	</section> <!-- RSover2mArbitraryGCE_formatsAndCodes -->

	<section anchor="RSover2mArbitraryGCE_Procedures" title="Procedures">
	<!-- ================ -->
<t>
The source block creation procedures are specified in
<xref target="CommonProc_src_block_creation_general_case_encoding"/>.
More precisely:
<list style="symbols">
	<t>the length indication for the source data payload i,
	used to compute the L[i] field, is the actual length of the
	source data payload i.
	It MUST NOT include FID[i], L[i], Pad[i], nor the Explicit Source
	FEC Payload ID.
	</t>
	<t>
	The SBN value is incremented for each new source block, starting at
	0 for the first block. 
	Wrapping to zero will happen for long sessions, after value 2^^(32-m).
	</t>
	<t>
	The ESI of source symbols are managed sequentially, starting at
	0 for the first symbol.
	</t>
</list>
</t>
	</section>

	<section anchor="RSover2mArbitraryGCE_FECCodeSpecification" title="FEC Code Specification">
	<!-- ================ -->
<t>
The present document inherits from <xref target="RMT-BB-FEC-RS"/> the specification of the
core Reed-Solomon codes based on Vandermonde matrices.
</t>
	</section>

</section> <!-- RSover2mArbitraryGCE -->


<section anchor="RSover2mSSFlowGE" title="Reed-Solomon FEC Global Encoding Scheme over GF(2^^m) for a Single Sequenced Flow">
<!-- ==================================== -->

<t>
TBD
</t>

</section> <!-- RSover2mSSFlowGE -->


<section anchor="RSover2mSSFlowGCE" title="Reed-Solomon FEC General Case Encoding Scheme over GF(2^^m) for a Single Sequenced Flow">
<!-- ==================================== -->


<t>
TBD
</t>

</section> <!-- RSover2mSSFlowGCE -->


<section anchor="SecurityConsiderations" title="Security Considerations">
<!-- ==================================== -->

<t>
<list><t>----- Editor's note: 
	Section To Be Updated...
        -----</t>
</list>
</t>

  <section title="Problem Statement">
  <!-- ================ -->

<t>
A content delivery system is potentially subject to many attacks:
some of them target the network (e.g., to compromise the routing infrastructure,
by compromising the congestion control component), others target
the Content Delivery Protocol (CDP) (e.g., to compromise its normal behavior),
and finally some attacks target the content itself.
Since this document focuses on a FEC building block independently of any
particular CDP (even if ALC and NORM are two natural candidates), this
section only discusses the additional threats that an arbitrary CDP may be exposed
to when using this building block.
</t>

<t>
More specifically, several kinds of attacks exist:
<list style="symbols">
	<t> those that are meant to give access to a confidential content (e.g., in
	  case of a non-free content),</t>
	<t> those that try to corrupt the object being transmitted (e.g., to
	  inject malicious code within an object, or to prevent a receiver
	  from using an object),</t>
	<t> and those that try to compromise the receiver's behavior (e.g., by
	  making the decoding of an object computationally expensive).</t>
</list>
These attacks can be launched either against the data flow itself (e.g.
by sending forged symbols) or against the FEC parameters that are
sent either in-band (e.g., in an EXT_FTI or FDT Instance) or out-of-band (e.g., in
a session description).
</t>

  </section>

  <section title="Attacks Against the Data Flow">
  <!-- ================ -->

<t>
First of all, let us consider the attacks against the data flow.
</t>


	<section title="Access to Confidential Objects">
	<!-- ================ -->

<t>
Access control to the object being transmitted is typically provided by means
of encryption.
This encryption can be done over the whole object (e.g., by the content provider, before the
FEC encoding process), or be done on a packet per packet basis (e.g., when IPSec/ESP
is used <xref target="RFC4303"/>).
If access control is a concern, it is RECOMMENDED that one of these solutions be used.
Even if we mention these attacks here, they are not related nor facilitated by
the use of FEC.
</t>

	</section>

	<section title="Content Corruption">
	<!-- ================ -->

<t>
Protection against corruptions (e.g., after sending forged packets) is achieved
by means of a content integrity verification/sender authentication scheme.
This service can be provided at the object level, but in that case a receiver
has no way to identify which symbol(s) is(are) corrupted if the object is detected
as corrupted.
This service can also be provided at the packet level. In this case, after 
removing all forged packets, the object may be in some case recovered.
Several techniques can provide this source authentication/content integrity
service:
<list style="symbols">
<t> at the object level, the object MAY be digitally signed (with public key
  cryptography), for instance by using RSASSA-PKCS1-v1_5 <xref target="RFC3447"/>.
  This signature enables a receiver to check the object integrity, once this latter has
  been fully decoded. Even if digital signatures are computationally expensive,
  this calculation occurs only once per object, which is usually acceptable;</t>

<t> at the packet level, each packet can be digitally signed. A major limitation is
  the high computational and transmission overheads that this solution requires (unless
  Elliptic Curve Cryptography (ECC) is used, but ECC is the subject of proprietary
  patents).
  To avoid this problem, the signature may span a set of symbols (instead of a
  single one) in order to amortize the signature calculation.
  But if a single symbol is missing, the integrity of the whole set cannot be checked;</t>

<t> at the packet level, a Group Message Authentication Code (MAC) <xref target="RFC2104"/>
  scheme can be used, for instance by using HMAC-SHA-1 with a secret key shared by all
  the group members, senders and receivers.
  This technique creates a cryptographically secured (thanks to the secret key)
  digest of a packet that is sent along with the packet.
  The Group MAC scheme  does not create prohibitive processing load nor transmission
  overhead, but it has a major limitation: it only provides a group authentication/integrity
  service since all group members share the same secret group key, which means that each
  member can send a forged packet. It is therefore restricted to situations where
  group members are fully trusted (or in association with another technique as a
  pre-check);</t>

<t> at the packet level, TESLA <xref target="RFC4082"/> is a very attractive
  and efficient solution that is robust to losses, provides a true authentication/integrity
  service, and does not create any prohibitive processing load or transmission overhead.
  Yet checking a packet requires a small delay (a second or more) after its reception;</t>
</list>
</t>


<t>
Techniques relying on public key cryptography (digital signatures and TESLA during
the bootstrap process, when used) require that public keys be securely associated
to the entities. This can be achieved by a Public Key Infrastructure (PKI), or by a
PGP Web of Trust, or by pre-distributing the public keys of each group member.
</t>

<t>
Techniques relying on symmetric key cryptography (group MAC) require that a
secret key be shared by all group members. This can be achieved by means of a
group key management protocol, or simply by pre-distributing the secret key
(but this manual solution has many limitations).
</t>

<t>
It is up to the developer and deployer, who know the security requirements and
features of the target application area, to define which solution is the most appropriate.
Nonetheless, in case there is any concern of the threat of object corruption, it is
RECOMMENDED that at least one of these techniques be used.
</t>
	</section>

  </section>

  <section title="Attacks Against the FEC Parameters">
  <!-- ================ -->

<t>
Let us now consider attacks against the FEC parameters (or FEC OTI).
The FEC OTI can either be sent in-band (i.e., in an EXT_FTI or in an FDT Instance
containing FEC OTI for the object) or out-of-band (e.g., in a session description).
Attacks on these FEC parameters can prevent the decoding of the associated object:
for instance modifying the B parameter will lead to a different block partitioning
at a receiver thereby compromising decoding; or setting the m parameter to 16 instead
of 8 with FEC Encoding ID 2 will increase the processing load while compromising decoding.
</t>

<t>
It is therefore RECOMMENDED that security measures be taken to guarantee the
FEC OTI integrity.
To that purpose, the packets carrying the FEC parameters sent in-band
in an EXT_FTI header extension SHOULD be protected by one of the
per-packet techniques described above: digital signature, group MAC, or TESLA.
When FEC OTI is contained in an FDT Instance, this object SHOULD be protected,
for instance by digitally signing it with XML digital signatures <xref target="RFC3275"/>.
Finally, when FEC OTI is sent out-of-band (e.g., in a session description)
this latter SHOULD be protected, for instance by digitally signing it.
</t>

<t>
The same considerations concerning the key management aspects apply here also.
</t>

  </section>
</section>


			<section anchor="iana-cons" title="IANA Considerations">
			<!-- =============================================== -->
<t>
Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA registration.
</t>
<t>
TBD
</t>
			</section>

			<section anchor="Acknowledgments" title="Acknowledgments">
			<!-- =============================================== -->
				<t>
The authors want to thank Hitoshi Asaeda for his valuable comments.
            </t>
			</section>
	</middle>
	<back>

		<references title="Normative References">
		<!-- ==================================== -->
			<reference anchor="RFC2119">
				<front>
					<title>Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials="S." surname="Bradner" fullname="Scott Bradner">
						<organization/>
					</author>
					<date year=""/>
				</front>
				<seriesInfo name="RFC" value="2119"/>
			</reference>

			<reference anchor="RFC5052">
				<front>
					<title>Forward Error Correction (FEC) Building Block</title>
					<author initials="M." surname="Watson"> <organization/> </author>
					<author initials='M.' surname='Luby'> <organization /> </author>
					<author initials='L.' surname='Vicisano'> <organization /> </author>
					<date month="August" year="2007"/>
				</front>
				<seriesInfo name="RFC" value="5052"/>
			</reference>

			<reference anchor="RMT-BB-FEC-RS">
				<front>
				<title>Reed-Solomon Forward Error Correction (FEC) Schemes</title>
					<author initials="J." surname="Lacan" fullname="Jerome Lacan">
						<organization></organization> </author>
					<author initials="V." surname="Roca" fullname="Vincent Roca">
						<organization></organization> </author>
					<author initials="J." surname="Peltotalo" fullname="Jani Peltotalo">
						<organization></organization> </author>
					<author initials="S." surname="Peltotalo" fullname="Sami Peltotalo">
						<organization></organization> </author>
					<date month="November" year="2007" />
				</front>
				<seriesInfo name="Work in" value="Progress" />
			</reference>

			<reference anchor="FECFRAME-FRAMEWORK">
				<front>
				<title>Forward Error Correction (FEC) Framework</title>
					<author initials="M." surname="Watson" fullname="Mark Watson"> <organization/> </author>
					<date month="October" year="2008" />
				</front>
				<seriesInfo name="Work in" value="Progress" />
			</reference>

		</references>

		<references title="Informative References">
		<!-- ==================================== -->

			<reference anchor="RFC3453">
				<front>
					<title>The Use of Forward Error Correction (FEC) in Reliable Multicast</title>
					<author initials="M." surname="Luby" fullname="M. Luby"> <organization/> </author>
					<author initials="L." surname="Vicisano" fullname="L. Vicisano"> <organization/> </author>
						<author initials="J." surname="Gemmell" fullname="J. Gemmell"> <organization/> </author>
						<author initials="L." surname="Rizzo" fullname="L. Rizzo"> <organization/> </author>
						<author initials="M." surname="Handley" fullname="M. Handley"> <organization/> </author>
						<author initials="J." surname="Crowcroft" fullname="J. Crowcroft"> <organization/> </author>
					<date month="December" year="2002"/>
				</front>
				<seriesInfo name="RFC" value="3453"/>
			</reference>

			<reference anchor="RS-codec">
				<front>
					<title>Reed-Solomon FEC codec (revised version of July 2nd, 1998), available at
http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz and mirrored at http://planete-bcast.inrialpes.fr/</title>
					<author initials="L." surname="Rizzo" fullname="Luigi Rizzo">
						<organization/>
					</author>
					<date month="July" year="1998"/>
				</front>
			</reference>

			<reference anchor="Rizzo97">
				<front>
					<title>Effective Erasure Codes for Reliable Computer Communication Protocols</title>
					<author initials="L." surname="Rizzo" fullname="Luigi Rizzo">
						<organization/>
					</author>
					<date month="April" year="1997" />
				</front>
				<seriesInfo name="ACM SIGCOMM Computer Communication Review" value="Vol.27, No.2, pp.24-36" />
			</reference>

			<reference anchor="RFC5170">
				<front>
					<title>Low Density Parity Check (LDPC) Forward Error Correction</title>
					<author initials="V." surname="Roca"> <organization/> </author>
					<author initials="C." surname="Neumann"> <organization /> </author>
					<author initials="D." surname="Furodet"> <organization /> </author>
					<date month="June" year="2008"/>
				</front>
				<seriesInfo name="RFC" value="5170"/>
			</reference>

			<reference anchor="RFC5053">
				<front>
					<title>Raptor Forward Error Correction Scheme</title>
					<author initials="M." surname="Luby" fullname="M. Luby"> <organization/> </author>
					<author initials="A" surname="Shokrollahi" fullname="A. Shokrollahi"> <organization/> </author>
					<author initials="M" surname="Watson" fullname="M.  Watson"> <organization/> </author>
					<author initials="T" surname="Stockhammer" fullname="T. Stockhammer"> <organization/> </author>
					<date month="June" year="2007"/>
				</front>
				<seriesInfo name="RFC" value="5053"/>
			</reference>

			<reference anchor="RMT-PI-ALC">
				<front>
					<title>Asynchronous Layered Coding (ALC) Protocol Instantiation</title>
					<author initials="M." surname="Luby"> <organization></organization> </author>
					<author initials="M." surname="Watson"> <organization></organization> </author>
					<author initials="L." surname="Vicisano"> <organization></organization> </author>
					<date month="November" year="2007" />
				</front>
				<seriesInfo name="Work in" value="Progress" />
			</reference>

			<reference anchor="RMT-PI-NORM">
				<front>
					<title>Negative-acknowledgment (NACK)-Oriented Reliable Multicast
					(NORM) Protocol</title>
					<author initials="B." surname="Adamson"> <organization></organization> </author>
					<author initials="C." surname="Bormann"> <organization></organization> </author>
					<author initials="M." surname="Handley"> <organization></organization> </author>
					<author initials="J." surname="Macker"> <organization></organization> </author>
					<date month="May" year="2008" />
				</front>
				<seriesInfo name="Work in" value="Progress" />
			</reference>

			<reference anchor="RFC3447">
				<front>
					<title>Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</title>
					<author initials="J." surname="Jonsson" fullname="J. Jonsson"> <organization/> </author>
					<author initials="B." surname="Kaliski" fullname="B. Kaliski"> <organization/> </author>
					<date year="2003" month="February"/>
				</front>
				<seriesInfo name="RFC" value="3447"/>
				<format type="TXT" octets="143173" target="ftp://ftp.isi.edu/in-notes/rfc3447.txt"/>
			</reference>

			<reference anchor="RFC4303">
				<front>
					<title>IP Encapsulating Security Payload (ESP)</title>
					<author initials="S." surname="Kent" fullname="S. Kent"> <organization/> </author>
					<date year="2005" month="December"/>
				</front>
				<seriesInfo name="RFC" value="4303"/>
				<format type="TXT" octets="114315" target="ftp://ftp.isi.edu/in-notes/rfc4303.txt"/>
			</reference>

			<reference anchor="RFC2104">
				<front>
					<title>HMAC: Keyed-Hashing for Message Authentication</title>
					<author fullname="H. Krawczyk"> <organization/> </author>
					<author fullname="M. Bellare"> <organization/> </author>
					<author fullname="R. Canetti"> <organization/> </author>
					<date month="February" year="1997"/>
				</front>
				<seriesInfo name="RFC" value="2104"/>
			</reference>

			<reference anchor="RFC4082">
				<front>
					<title>Timed Efficient Stream Loss-Tolerant Authentication (TESLA):
						Multicast Source Authentication Transform Introduction</title>
					<author fullname="A. Perrig"> <organization/> </author>
					<author fullname="D. Song"> <organization/> </author>
					<author fullname="R. Canetti"> <organization/> </author>
					<author fullname="J.D. Tygar"> <organization/> </author>
					<author fullname="B. Briscoe"> <organization/> </author>
					<date month="June" year="2005"/>
				</front>
				<seriesInfo name="RFC" value="4082"/>
			</reference>

			<reference anchor="RFC3275">
				<front>
					<title>(Extensible Markup Language) XML-Signature Syntax and Processing</title>
					<author initials="D." surname="Eastlake" fullname="D. Eastlake"> <organization/>
					</author>
					<author initials="J." surname="Reagle" fullname="J. Reagle"> <organization/>
					</author>
					<author initials="D." surname="Solo" fullname="D. Solo"> <organization/>
					</author>
					<date year="2002" month="March"/>
				</front>
				<seriesInfo name="RFC" value="3275"/>
				<format type="TXT" octets="164198" target="ftp://ftp.isi.edu/in-notes/rfc3275.txt"/>
			</reference>

		</references>
	</back>
</rfc>
