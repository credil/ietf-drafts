<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
 <!ENTITY rfc2026 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2026.xml'>
 <!ENTITY rfc2028 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2028.xml'>
 <!ENTITY rfc2629 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml'>
 <!ENTITY rfc2119 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
 <!ENTITY rfc3029 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3029.xml'>
 <!ENTITY rfc3126 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3126.xml'>
 <!ENTITY rfc3161 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3161.xml'>
 <!ENTITY rfc3820 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3820.xml'>
 <!ENTITY rfc3852 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3852.xml'>
 <!ENTITY rfc3978 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3978.xml'>
 <!ENTITY rfc4366 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4366.xml'>
 <!ENTITY rfc4491 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4491.xml'>
 <!ENTITY rfc4810 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4810.xml'>
 <!ENTITY rfc4998 PUBLIC ''  
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4998.xml'>
 <!ENTITY XML-DSIG PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml2/reference.W3C.xmldsig-core.xml'>
 <!ENTITY XML-ENC PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml2/reference.W3C.xmlenc-core.xml'>
 <!ENTITY LTANS-LTAP PUBLIC ''  
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ltans-ltap.xml'>
 <!ENTITY ISO-18014-1-2002 PUBLIC '' 
      'http://ltans.edelweb.fr/references/reference.ISO-18014-1.2002.xml'>
 <!ENTITY ISO-18014-2-2002 PUBLIC '' 
      'http://ltans.edelweb.fr/references/reference.ISO-18014-2.2002.xml'>
 <!ENTITY ISO-18014-3-2004 PUBLIC '' 
      'http://ltans.edelweb.fr/references/reference.ISO-18014-3.2004.xml'>
 <!ENTITY ANSI-X9-95-2005 PUBLIC '' 
      'http://ltans.edelweb.fr/references/reference.ANSI.X9-95.2005.xml'>
 <!ENTITY ETSI-TS102176-1-2005 PUBLIC '' 
      'http://ltans.edelweb.fr/references/reference.ETSI-TS102176.1.2005.xml'>
 <!ENTITY ETSI-TS102176-2-2005 PUBLIC '' 
      'http://ltans.edelweb.fr/references/reference.ETSI-TS102176.2.2005.xml'>
 <!ENTITY MER1980 PUBLIC '' 
      'http://ltans.edelweb.fr/references/reference.MER1980.xml'>
]>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="2"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<rfc ipr="full3978" docName="draft-ietf-ltans-ltap-07" category="std">
 <front>
  <title abbrev="LTAP">Long-term Archive Protocol (LTAP)</title>
  <author initials="A.J.B." surname="Jerman Blazic" fullname="Aleksej Jerman Blazic">
   <organization>SETCCE</organization>
   <address>
    <postal>
     <street>Jamova 39</street>
     <city>Ljubljana</city>
     <code>SI-1000</code>
     <country>SLOVENIA</country>
    </postal>
    <facsimile>+386 1 4773861</facsimile>
    <email>aljosa@setcce.org</email>
   </address>
  </author>
  <author initials="P.S." surname="Sylvester" fullname="Peter Sylvester">
   <organization>EdelWeb</organization>
   <address>
    <postal>
     <street>15 quai de Dion-Bouton</street>
     <city>Puteaux</city>
     <code>F-92816</code>
     <country>FRANCE</country>
    </postal>
    <facsimile>+33 1 40 99 14 14</facsimile>
    <email>Peter.Sylvester@edelweb.fr</email>
   </address>
  </author>
  <author initials="C.W." surname="Wallace" fullname="Carl Wallace">
   <organization>Cygnacom Solutions</organization>
   <address>
    <postal>
     <street>Suite 5200</street>
     <street>7925 Jones Branch Drive</street>
     <city>McLean</city>
     <region>VA</region>
     <code>22102</code>
    </postal>
    <email>cwallace@cygnacom.com</email>
   </address>
  </author>
  <date month="November" year="2008"/>
  <area>Security</area>
  <workgroup>LTANS</workgroup>
  <keyword>Evidence</keyword>
  <keyword>Archive</keyword>
  <keyword>Notary</keyword>
  <keyword>Trust</keyword>
  <keyword>Interaction</keyword>
  <abstract>
   <t>This document describes a service operated as a trusted third party to securely archive electronic documents called a long-term archive service (LTA). We describe an architecture framework and a protocol allowing clients to interact with such a service. Bindings to concrete transport and security protocol layers are given.</t>
  </abstract>
 </front>
 <middle>
  <section title="Introduction">
   <t>Conservation of documents is important, one can even say that appropriate conservation rules are a prerequisite for data to become a document.  Conservation has several aspects, e.g., duration or accessibility, which vary based on the nature of the document.  For example, a document may be conserved for a certain period and may be destroyed after that, or its lifetime may be extended when the document becomes part of a conflict. Also, documents may become part of historical archives. A document may be accessible on a public or restricted basis to a set of potentially interested or authorized entities.</t>
   <t> The protocol described in this document enables the use of a specialized service for conservation of electronic documents. The service creates and makes available enough information to demonstrate the existence, integrity and authenticity of electronic data over any period of time.  In other words, the service assumes the responsibility to retrieve and, optionally, store data for conservation, create and store evidence to guarantee data integrity and completeness, and to maintain accessibility of data and evidence created.</t>
   <t>This document describes a protocol for interacting with a long-term archive service (LTA). The document contains only description of a general request and response structure, and a detailed protocol description concerning access to an LTA. Other specifications and descriptions, e.g. a framework protocol containing mappings to transport and security services, are addressed elsewhere.  The protocol is intended to be used in client-server architecture, where client is simply an end user (a physical user or another service) and the server as an LTA.</t>
   <t>The process of replacing paper based workflow and document handling which is also known as 'dematerialization' ignores to a certain degree the requirements for long-term stability of documents. Document conservation is generally performed by specialized services. For electronic formats it is proposed to use similar approaches, while maintaining the distance of technical characteristics (paper versus electronic). Conservation might be taken out from other workflow activities, while the same procedures (evidence creation) might be used for any milestone in an electronic document lifecycle (e.g. version marking).</t>
   <t>Since conservation of documents created by one entity is only necessary if there is a potential entity to which the document may be presented at some time, the conservation service (LTA) acts as a trusted third party for those two entities. The main role of an LTA is to generate and provide enough information for archived data existence in time, integrity and authenticity demonstration over long periods of time. Provision of data storage services is optional and may be assured by supportive infrastructure (e.g. database or document storage/management system).</t>
<t>Conservation is more that just storing a document. Not only, but in particular when the life time is very long, appropriate measures to ensure the integrity of the document must be used. This aspect is handled by this specification. Sometimes, complete transfer of the document information to a new physical support has to be done like transformations from marble to paper or paper to microfilm. The need for such transformation makes the definition of what constitutes the actual document somewhat difficult, in particular it should be done independantly of the support, and even independantly of a current format of the document information. Transformation of documents are largely the scope of this specification besides the obvious possibility of storing all formats of a document and assertions about the transformations.</t> 

 
   <t>Defined data structures are presented in XSD and ASN1 forms. The XSD form has been automatically generated from the ASN.1. When the ASN.1 defined data structured are encoded using XER encoding rules, they are compatible with data structures encoded according to the XSD.</t>
      <section title="Requirements notation">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as 
described in <xref target="RFC2119" />.</t>
      </section>
    </section>
    <!-- Introduction -->
  <section title="Background">
   <t>A conservation service or long-term archive (LTA) consists of several functional blocks. Some of these blocks are not considered as they present basic infrastructure, such as the communication network, storage device, data management, etc. Instead, an LTA implements the archive interaction protocol as defined by this specification (LTAP) and manages archive objects (logically interpreted as packages of archive data and conservation attributes) and evidence records <xref target="RFC4998"/>. An LTA is a part of a general archive service that provides evidence used to demonstrate the existence of an archived data object at a given time and the integrity of the archived data object since that time. The LTA is the primary part tasked with creating and delivering conservation attributes for archived data.</t>
   <t><xref target="RFC4810"/> defines the services that must be provided by an LTA. A principal function of the LTA is to generate or obtain evidence information for (archive) data submited. An LTA may accept and store data for which it generates (or acquires from another service) and maintains evidence inforamtion.  Alternatively, it may simply act as an evidence or information service without data storage capabilities (it relies upon other services for storage of the archived data). Evidence generated and maintained by an LTA addresses the problems of long-term integrity and temporal existence.</t>
   <t>Archive objects are the central logical structures defined by the LTA and maintained on a long-term basis. They are atomic elements of an LTA service consisting of three logical parts: </t>
   <t>
    <list style="symbols">
     <t>Archive data (including metadata or other related data) entering the LTA using the interaction protocol,</t>
     <t>Archive process-related meta or binding information, and</t>
     <t>Evidence information</t>
    </list>
   </t>
   <t>The archive data may contain data of any type, e.g., raw data, signed data, encrypted data or time stamped data as defined by <xref target="RFC4810"/>. Archive data may be associated with additional data or attributes, e.g. meta information or digital signatures.</t>
   <t>Data generated or collected by the LTA are archive process-related meta or binding information including demonstration information and evidence information. Archive metadata may be needed to provide enough information for e.g. special (e.g., legal) purposes or validity demonstration purposes. Examples are complementary information to verify digital signatures or to attest their validity. The LTA collects meta or binding information directly from a user or some other entity (e.g. Certificate Authority). Such information may contain the data owner name, organization, location, etc.. Meta or binding information may be submitted using the LTAP.</t>
   <t>Demonstration information is collected to demonstrate facts on the archive data. Such information may be digital signature reference information. The LTA may use external resources to collect such information, usually without user intervention. Evidence data is generated by the LTA or collected from an external resource, e.g. a time stamping authority. Evidence information is provided for all data: archive data submitted by a client and archive process-related data (including binding and demonstration information) collected by the LTA from the client or alternative resource.</t>
   <t>The LTA performs perpetual maintenance of archive objects and associated metadata for the main purpose of demonstrating archive data existence in time and providing integrity information for the complete archiving time. Archive objects are periodically processed to provide long-term stability (e.g. by proof-reading, copying to new material, or performing time stamp renewal). This protocol specification make no assumptions about the details of such verification operations except that an implementation MUST specify how the outcome is reflected in the archive metadata of each object. The protocol provides for a simple means to initiate a verification on an archive object through a protocol action.</t>
   <t>The LTAP protocol interprets the logical data structure to hold all needed information (including references) to build an archive object including archive data itself (or reference to archive data). The logical
structure of the LTAP messages includes archive data, archiving process-related information and references together with request and processing information. Using LTAP, the LTA should have enough information to build and perform operations on an archive object or group of archive objects.</t>
  </section>
  <!-- Background -->
  <section title="Framework">
   <t>This chapter describes a general framework for secure exchange of request and response messages between an archive client and archive server, e.g. an LTA.  It provides a high level outline and identifies common and external aspects from the concrete protocol data units.</t>

   <section title="Functional Overview">
<t>An LTA, as defined by <xref target="RFC4810"/>, is a service that is responsible for preserving evidence data and/or data for long periods of time. The service is accessible using the protocol defined in this document.</t>
<t>The protocol is intended to be used as well as core functionality available to customers of a service provider, as well as
an internal protocol inside the LTA to access core building blocks as a black box. The latter usage is intended to permit the creating of security zones and auditable implementations. As a consequence, some core functionality defined in the protocol may not be available to all external customers of an LTA.</t>  
<t>The protocol consists of two layers, the higher layer defines the available  service functions and their mapping to encodings, the lower layer defines the rules for the exchange of protocol messages common for all all functions.</t>

<t>It is assumed that an LTA ensures the long-term availability of stored data and created evidence information, as necessary, and uses appropriate means to manage data and access rights. The details of these important features of an LTA are outside the scope of this specification.</t>
    <t>The common high-level architecture consists of a protocol used to exchange requests and responses securely, potentially over different types of transport connections, to ensure the long-term validity of responses.</t>
    <t>Clients and servers use one of several object types to build requests and responses.  Data objects include raw (archive) data, request information, meta information, identification information and attestations.</t>
    <t>Requests and responses are exchanged in a secure way responding to different security requirements, which may concern the security of the transport as well as the long-term validity of the data being exchanged.</t>
    <t>The LTA is not a method for implementing something like a secure file system. In general, archived data are rarely accessed, restored or transferred. Thus, the archive operation is the most important one and performance is an important concern. In this case that client applications need frequent access to the data, they generally keep a copy of the data including evidence information, whose integrity can be compared from time to time or when requested.</t>
   </section>
  <section title="Service functions of an LTA">
<t>The primary aim of this protocol is to enable a formal interaction between a client and an LTA. The result of the interaction is a verifiable attestation of procedures performed by an LTA (e.g. archive data plus evidence record). The format for data structures used to demonstrate integrity,  i.e. to demonstrate that data has not undergone any transformations while in the care of the archive, is partially defined in other documents, namely in <xref target="RFC4998"/>. This specification does not place any requirements on the structure of archived data objects. However, it operates on elements that are derived from archive data objects (e.g. message imprints).</t>
<t>The LTA interface enables clients to perform at least the following operations in cooperation with an LTA:</t>
<t>
<list style="hanging">
<t hangText="ARCHIVE:"> Submit data to an LTA and request creation of evidence information for data</t>
<t hangText="EXPORT:"> Retrieve data (including archive data, meta information and evidence information) from an LTA</t>
<t hangText="DELETE:"> Remove data and/or evidence information from an LTA. </t>
<t hangText="VERIFY:"> Determine the integrity and validity of LTA archived data.</t>
<t hangText="STATUS:"> Inform about the status of data.</t>
<t hangText="LISTIDS:"> Return a list of references to archived objects.</t>
</list>
</t>
<t>These operations MUST be implemented by an LTA service. There is a minimal profile for the parameter structures for transactions with a single server that does act as a final repository. </t>
<t>The operations are intended for different types of clients, including archive data owners but also entities that want to audit the service or are authorised to access to data. Since an LTA may restrict the access based on functions, a client MAY implement only the accessible subset of functions.</t>
<t>An LTA MAY propose additional services either by extending the operations by the means of additional parameters or by defining new operations like archive transfer, extension of lifetime, data splitting or relaying.</t>
<t>For example, often an extension of the initial lifetime of an object must be possible. With the core operations it is not possible to perform this in one operation. In order to do so, a client has to read the object and store it under a different service (not necessarily with the same provider). To extend the lifetime of an object, an EXPORT operation followed by an ARCHIVE operation has be used to transfer or copy the object to an LTA service having the required lifetime policy/configuration.</t><t>Finally, after the transfer, the initial object may be deleted or not. The combination of such a sequence of operations into single one is an example of an extended service provided to clients.</t> 
<t>Since it may not be desirable to make the data available to a potentially untrustworthy client, the combined operation could be implement using an extension to the core LTA functionality by allowing a reference to data as a parameter to the ARCHIVE function.</t>


  </section>
<section title="Transactions">
<t>The model for the exchange of LTAP requests and responses is borrowed from other environments and technologies like EDI, X.400 or ebXML. It's main characteristic is that exchanges for LTAP are conceptually asynchronous. As a consequence, it is necessary to provide a mechanism to allow a client to determime that the LTA has received and processed a request. An LTAP exchange consists of sending a request and retrieving at least one of two different types of responses. A client initiates an archive service by submiting a request. This LTAP request consists of data to be archived and information related to the archive process. The process information may include client authorization, archive policy, service parameters, etc. The first type of response is a technical acknowledgement from the LTA that the request has been received and the process information has been accepted (or rejected). The second type of response is a statement from an LTA containing an indication of the outcome of the requested operation. This result (called an attestation) is, in general, a document with long-term validity allowing the client to reference the operation, and, in particular, to reference the data that has been preserved by the LTA.</t>
<t>The asynchronous nature of the LTAP protocol is required by LTA operations, which may require a specific amount of time to perform, e.g. the archive operation needs to safely store the data and to produce evidence information.</t>
<t>The possibility to deliver the result attestation in a asynchronous way permits cost effective implementations of the LTA.</t>  
    <t>An LTA may deliver immediately a second type response. This occurs for example for a STATUS or LISTIDS function or when an operation is retried and the final result is available.</t>
    <t>A client can repeat an operation, since the request or the response might have been lost.</t> <t>For an ARCHIVE operation, the client MAY provide a unique identification for the request that to be used by the LTA to ensure idempotence of the operation. When retrying an ARCHIVE operation, a client MAY replace the raw data to be archived by a MessageDigest representing the data in order to reduce the payload size.</t>
   <t>For the ARCHIVE, DELETE, VERIFY operations, after receipt of the technical acknowledgement (first type response), the client can also use a STATUS operation for the object in order to indirectly determine the outcome of a transaction. Depending on the lower layer bindings, sending a STATUS request or retrying another operation may be the only way to determine the outcome of an archive operation.</t>
   </section>
   <section title="Life cycles of objects">
<t>
Using the defined transactions and the operations on objects, two levels of life cycles are defined. 
One is directly derived from the operation of a single transaction. 
The other is related to the long-term situation of an object. 
</t>

<section title="Transaction Level Life Cycle">
<t>
When a client initiates an archive operation, client and server have some
knowledge of the progress of the operation. The following list explains the
different states of a transaction seen by both the client and the service,
and decribes actions and events changing the state of the transaction.
</t>
<t>
<list style="hanging">
              <t hangText="T0:">The client has not initiated an archive operation. The LTA does not
                know anything about an object.
              </t>
               <t hangText="T1:">The client has initiated an archive operation. The LTA may have received the object or not;
                the client cannot assume that the LTA has received the request. 
                Client may retry the operation after a timeout.  
              </t>
                <t hangText="T2:">The LTA has received the request and has generated a first type
                response. 
                The server ensures idempotence of at least the ARCHIVE operation, i.e. on multiple 
                occurrences of an identical request, the LTA sends the same
                response and transaction identification. The LTA may still lose the state, 
                e.g., in case of a power failure.  
              </t>
              <t hangText="T3:">
               The client has received the initial response. The client can retry
                the initial operation using the transaction identification at the place of the data
                in order to receive a final answer.  
                In case of negative response, i.e. LTA in state T0, client can fall back to T1.
              </t>
              <t hangText="T4:">The LTA has send a definitive answer for an operation and has
                assumed the responsibility of operation. 
              </t>
                <t hangText="T5:">The client has received a definitive answer and can consider the
                operation as terminated.
              </t>
</list>
</t>
              <t>In case of negative reponses to a transaction, the LTA keeps the
              result for a certain time in order to provide a reasonable answer to
              a client that retries an operation.</t>

            </section>
<section title="Long term life cycle.">

<t>We can distinguish the following phases in the lifetimes of an archived object:</t>
<t>
<list style="hanging">
<t hangText="L0:"> The LTA has no knowledge about an object.</t> 
<t hangText="L1:"> An LTA has received an archive object and is proceeding the request. The LTA may accept or reject the request, or may lose knowledge about it.</t>
<t hangText="L2:"> An LTA has archived an object. An LTA can accept other operations, i.e., EXPORT, DELETE or VERIFY operations. When receiving an EXPORT or VERIFY operation, some metadata may be updated, e.g., last time of access, last verification operation etc.</t>
<t hangText="L3:"> After a DELETE operation prior to the initially defined lifetime of the operation, the LTA MAY keep an information about the actual status of the object (e.g. deleted) until the end of the lifetime. If available, the LTA MAY returns other remaining metadata containing for example a new location of the data.</t>
<t hangText="L4:"> After the lifetime of an object, an object or the reference to is being deleted. At the end of this internal operation, the LTA is in state L0.</t>
</list>
</t>
<t>When an LTA has archived an object, it keeps a certain number of metadata, which gives information about the current status of the object. Some metadata MAY remain available even after deleting the object.  Among the remaining metadata there may be the date of deletion or a reference to where the information can actually be received.</t>
<t>A change from state L2 can also occur when an LTA determines loss of integrity or loss of data.</t>
<t>The LTA MUST maintain a chronological order for references to archived data.</t>
            </section>
          </section>
<section title="Roles, Service Types, Policies and Configurations">
 <t>The protocol assumes a number of different actors playing different roles. The basic roles are a client and a server. These roles are simply defined by the types of protocol data units, i.e., requests and responses. Several other roles may exist, which are currently not in the scope of the protocol specification. An example of an additional role is a relay or a proxy using both the basic roles of client and server. In general two entities are distinguished, based on different characteristics: an entity that requests its data to be archived or to be acted upon, and an entity that accepts data and assures responsibility of archived data, or acts on the data. Other entities serving as a lower layer transport services, data storage services or security services are out of the scope of protocol definition.</t>
 <t>Clients may occur in different roles. Besides users that archive data, there may be relying or controlling entities like a judge who must be able to get access to it. Or, there are entities like auditors that may access to some data. The protocol distinguishs such roles by the definition of the following service types and service policy information.</t>
 <t>The LTA interface implementation MUST enable clients to perform all the service operations.</t>
 <t>A client implementation MAY only support a subset of the service types in order to have a small footprint. This is motivated by the fact that different operations are generally invoked by different entities in totally different environments, e.g., a client may only submit data and never verify an evidence record.</t>
<t>The way a particular operation is performed is only defined at the LTA server side implementation and can be influenced by policy information parameters. A client MAY indicate one or more service policy identifiers associated to a service type in order to select different features to be performed by the LTA. The goal of policy identifiers is to keep client configurations simple.</t>
<t>An LTA service may provide additional features, which may be identified by clients, that govern how services are performed. An LTA might offer a series of features based on quality characteristics, e.g. number of timestamps used, refresh period, etc.  The protocol specification builds on the assumption that features are clearly identifiable and are included in the protocol elements. Features enable clients to request specific handling by the LTA, such as requesting a premium service that assures prompt and immediate archiving vs. a standard service that handles queues and generates evidence data periodically based on data collections, i.e., one timestamp per a document bundle. Also, services may differ according to data storage characteristics (e.g. client may request full evidence and storage capacity or only evidence creation service), redundancy characteristics (single timestamp versus multiple time stamping), etc. Service characteristics are defined by archive or operation policies.</t>
<t>An LTA may use external services, like validation and evidence creation services. Another service is provision of physical infrastructure or data storage and management systems. Such entities can also be referenced by service policy identifiers.</t>
<t>In general, for each client, in particular those that are archiving, a default or single possible configuration is defined at the server in order to group features and policies into defined sets. A server may operate different configurations and from the protocol standpoint, general configuration is selected by the policy identificator.</t>
    <t>As a last mechanism to provide parameters to the archive server, LTA clients MAY use specific configuration parameters in their requests. The definition of such parameters is not in the scope of this protocol. Configuration parameters allow clients to transfer arbitary key/value pairs from the client to the server.</t>
    <t>In principle, a single sequence of policy information is sufficient to indicate both the service type and the configuration parameters. A multi-dimensional approach with configuration and service types rounds up the requirements for LTA and scenarios of archiving processes.</t>

<t>This specification defines no particular policy or configuration.</t>
   </section>
   <!-- Service Types, Policies and Configurations -->
<section title="Identification">

<t>This text defines one two ASN.1 modules. One module uses current ASN.1 syntax.
A version number is added as the last component of the module object identifier.
A version of 0 indicates modules of any draft of this memo. 
</t>
<t>
Definitions of data are made as well in XML schema notation XSD as well as in ASN.1. The XSD schema has been generated automatically using the asn1xsd tool from OSS Nokalva. The ASN.1 has been validated using the asn1c compiler from OSS Nokalva.
</t>
<t>The module with current (2005) syntax is defined with the following syntax:</t>
    <figure>
     <preamble>Current ASN.1 Module start</preamble>
<!-- COLLECT BEGIN ASN1 --><artwork><![CDATA[
LTAP {iso(1) identified-organization(3) dod(6) 
      internet(1) security(5) mechanisms(5) 
      ltans(11) id-mod(0) id-mod-ltap(4) 0}
DEFINITIONS IMPLICIT TAGS ::=
BEGIN

]]></artwork><!-- COLLECT END -->
</figure> 


<t>The following XSD schema is generated:</t>
    <figure>
     <preamble>XML Schema Identification</preamble>

<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<schema xmlns="http://www.w3.org/2001/XMLSchema" 
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
  xmlns:enc="http://www.w3.org/2001/04/xmlenc#" 
  targetNamespace="http://www.setcce.org/schemas/ltap" 
  elementFormDefault="qualified" 
  attributeFormDefault="unqualified"> 
<annotation><documentation xml:lang="en">
   XML Schema for LTAP
</documentation></annotation>

]]></artwork><!-- COLLECT END -->

    </figure>
</section>
   <section title="External definitions">
<t>The modules export all their definitions, and import several definitions
from other modules. The modules differ depending of the ASN.1 syntax but
generate identical encodings.</t>

    <figure>
     <preamble>Current ASN.1 Module external definition</preamble>
<!-- COLLECT BEGIN ASN1 --><artwork><![CDATA[
-- EXPORTS ALL
IMPORTS 

   certificateExtensions 
FROM UsefulDefinitions {joint-iso-itu-t ds(5) module(1)
      usefulDefinitions(0) 5}

   PolicyInformation, GeneralNames
FROM CertificateExtensions certificateExtensions

   PKCS7-CONTENT-TYPE, ContentInfo
FROM PKCS7
   {iso(1) member-body(2) us(840) rsadsi(113549)
  pkcs(1) pkcs-7(7) modules(0) pkcs-7(1)}
;
]]></artwork><!-- COLLECT END -->
</figure>


<t>These are corresponding XML definitions for the imported structures.</t>
    <figure>
     <preamble>XML Schema for imported data structures</preamble>

<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="Name">
 <xsd:choice>
   <xsd:element name="rdnSequence" type="RDNSequence"/>
 </xsd:choice>
</xsd:complexType>

<xsd:complexType name="RDNSequence">
 <xsd:sequence minOccurs="0" maxOccurs="unbounded">
  <xsd:element name="RelativeDistinguishedName" 
               type="RelativeDistinguishedName"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="RelativeDistinguishedName">
 <xsd:sequence minOccurs="0" maxOccurs="unbounded">
  <xsd:element name="AttributeTypeAndDistinguishedValue" 
               type="AttributeTypeAndDistinguishedValue"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="AttributeTypeAndDistinguishedValue">
 <xsd:sequence>
  <xsd:element name="type">
   <xsd:simpleType>
    <xsd:restriction base="OBJECT_IDENTIFIER"/>
   </xsd:simpleType>
  </xsd:element>
  <xsd:element name="value">
   <xsd:complexType mixed="true">
    <xsd:choice>
     <xsd:any processContents="lax"/>
    </xsd:choice>
   </xsd:complexType>
  </xsd:element>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="PolicyInformation">
 <xsd:sequence>
  <xsd:element name="policyIdentifier" 
               type="CertPolicyId"/>
  <xsd:element name="policyQualifiers" minOccurs="0">
   <xsd:complexType>
    <xsd:sequence minOccurs="0" maxOccurs="unbounded">
     <xsd:element name="PolicyQualifierInfo" 
                  type="PolicyQualifierInfo"/>
    </xsd:sequence>
   </xsd:complexType>
  </xsd:element>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="PolicyQualifierInfo">
 <xsd:sequence>
  <xsd:element name="policyQualifierId">
   <xsd:simpleType>
    <xsd:restriction base="OBJECT_IDENTIFIER"/>
   </xsd:simpleType>
  </xsd:element>
  <xsd:element name="qualifier" minOccurs="0">
   <xsd:complexType mixed="true">
    <xsd:choice>
     <xsd:any processContents="lax"/>
    </xsd:choice>
   </xsd:complexType>
  </xsd:element>
 </xsd:sequence>
</xsd:complexType>

<xsd:simpleType name="CertPolicyId">
 <xsd:restriction base="OBJECT_IDENTIFIER"/>
</xsd:simpleType>

]]></artwork><!-- COLLECT END -->

    </figure>

</section>
   <section title="Entities">
    <t>Entities that participate in protocol exchanges are represented by identifiers and may possess attributes. It is outside the scope of this definition to define an organisation of identifiers and attributes, in particular the way how entity identifiers are related to identifiers used for authentication, or what attributes are associated to data.</t>
    <t>As the current LTAP specification assumes end-to-end communication only, there is no distinction between technical roles like 'client, 'server', 'relay', 'proxy' or 'authorized agent'. For LTAP, only client and server roles are defined.</t>
    <t>The explicit usage of identifiers and attributes enables decisions to be traceable, i.e., the participating entities can indicate to a certain degree why they want a service or why it has been provided.</t>
    <t>Furthermore, entity identifiers and attributes MAY be provided by the transport or security layer information. These information can be added to protocol elements as trace attributes.</t>
    <section title="Entity Identifiers">
     <t>Entity identifiers are used in the protocol to indicate the participating entities. A client can indicate one or more identifiers indicating who is making the request or participating in its creation and one or more identifiers indicating who should perform the service. A server can indidate who has provided the service and who is the indented client.</t>
     <t>It MUST be ensured in some way that in an actual context of a client/server network names are scalable and global both in terms of actual community space and time to live of the treated data objects.</t>
     <t>Identifiers are labeled in some way, i.e. string representations are typed and can be derived from various external layers. Identifiers SHOULD use an appropriate structure such as ASN.1 definition of GeneralName.</t>
    </section>
    <!-- Entity Identifiers-->
    <section title="Attributes">
     <t>Entities may possess additional attributes like roles, scopes or capabilities. Entities MAY indicate attribute values in protocol exchanges so that they can be used for authentication purposes or billing.</t>
     <t>Attributes may be related to attributes of data, for example, an entity may acts as a judge or arbitrator for a particular jurisdiction. The attribute jurisdiction is associated to the entity and to data treated by the service, and thus, can be used for authorisation control.</t>
    </section>
    <!-- Attributes -->
   </section>
   <!-- Entities -->
   <section title="Data Model">
    <t>The data fields of a LTAP request are as follows:</t>
    <t>
     <list style="symbols">
      <t>request information or status information</t>
      <t>raw data to archive, or references to data or to transactions.</t>
      <t>metadata providing additional information about the data to archive</t>
      <t>authorisation and authentication information of the entities paticipating in the procedure</t>
      <t>other information, required for supporting functions like billing</t>
     </list>
    </t>
    <section title="Data objects">
     <t>The data to be archived are arbitrary binary data and, minimally, an associated type that MUST be either available as part of a server configuration policy or explicitly indicated by the client.</t>
     <t>Data can be referenced by identifiers. Data identifiers are used to uniquely identify data objects. Data identifiers SHOULD have an additional local structure (e.g., contain a checksum), in order to avoid or detect client copying errors. An additional measure to enhance the redundancy of identifiers is the usage of time values which can be used in combination with data identifiers.</t>
     <t>Servers MUST create a server-wide unique identifier for each data object managed by the LTA. The identifier MUST be global during the intended lifetime of an object.</t>
     <t>Clients may provide their own data identifiers in requests. Whether the client provided identifiers are unique is outside the scope of the protocol. LTAs treat these identifiers as opaque information.</t>
     <t>In order to identify data for the short lifespan of a transaction, artifacts can be used to reference data or transactions.</t>
    </section>
    <!-- Data objects -->
    <section title="Collections of objects">
     <t>Data grouping can occur for various reasons, i.e. logical, contextual, semantic, operational, etc. Grouping of objects can be performed by a client using metadata present for each object. This document does not specify how client can create groups of objects, collections, hierarchies etc.</t> 
     <t>Collections of data can be defined explicitly or implicitly. A document amy be implicitelt added to a collection using policy and entity identifiers to request a specific collection strategy (e.g. a collection of data that is processed on a daily basis for a specific user). A collection identifier may be explicitely present as metadata. Grouping can also be implicitely defined by service policies, e.g. per user or on a daily or volume basis. Details are out of scope of this specification.</t>
      
<t>An LTA MAY understand metadata concerning collections in order to optimize  for example evidence creation by building hash trees as defined in <xref target="RFC4998"/> or operational reasons, e.g. for reducing storage costs or to improve performance or scalability.</t>

    </section>
    <section title="MetaData">
     <t>Meta information is associated with archive data and can be included implicitly, i.e. be a part of a document, or explicitly, i.e. as a document attachment. An LTA does not interprete metadata that may express logical relations among documents in the archive that is submitted selectively using several requests. For LTAs, the client is only in control of selecting and enclosing meta information, which is logically, contextually or for any other reason related to a document.</t>
     <t>Meta information may occur in various forms and may be an integral part of archive data, e.g. security attributes in form of digital signatures. To process such information, the LTA MUST retrieve enough information on the type and purpose of information enclosed, which may simply be defined with the use of an apropriate archive service policy, e.g. archive service for digitally signed documents.</t>
     <t>An LTA may perform specific actions related to meta information processing (and preservation, such as complementary data collection in form of digital certificates). This can also be done by an external service, e.g. <xref target="RFC3029"/> or SVCP.</t>
     <t>In some scenarios, a specific set of meta information must be preserved together with archive data, e.g. information identifying the document owner/author, location or time. The LTAP protocol does not define constraints on information type and structure. The LTAP request structure is defined to accept any type of data.</t>
    </section>
    <!-- MetaData -->
    <section title="Binding Information">
     <t>Clients and servers MAY include additional information in their requests and responses concerning the lower layer binding to a transport like SOAP, HTTP or S/MIME, e.g. end-point addresses. This category may also include things like billing/accounting information, i.e. whatever a business transaction needs but which is not part of metadata, i.e. outside the scope of the archived data.</t>

   </section>
    <!-- Binding Information -->
    <section title="Evidence Data">
     <t>Evidence information demonstrates the integrity and existence of archived data. The LTA accepts data for the single purpose of generating or obtaining evidence information for data submitted by a client. The evidence information structure is defined in <xref target="RFC4998"/>.</t>
     <t>In the case where LTA accepts data only for the purpose of generating evidence information (without storage capabilites to avoid, e.g. confidentiality issues), the archivation process is limited in time. When an LTA performs a renewal of evidence, archived data may be required to be available, e.g. when renewing a hash tree. In such scenarios, the LTA requires availability of archived data for hash re-computation. The LTAP protocol does not support function for data re-submission.</t>
    </section>
    <!-- Evidence Data -->
   </section>
   <!-- Data Model -->
  </section>
  <!-- Framework -->
  <section title="Data Types">
   <t>A number of data types are common to both requests and responses. 
</t>

   <section title="Artifacts">
    <t>Artifacts are identifiers used to reference a transaction, or a result of a transaction. They can be returned as a protocol answer in an initial response, to allow retrieval of a response or progress of a transaction later by the initial client or another authorised entity.</t>
    <figure>
     <preamble>ASN.1 definition</preamble>

<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
Artifact ::= PrintableString 
]]></artwork><!-- COLLECT END -->

    </figure>
<t>The corresponding XML type is:</t>
    <figure>
     <preamble>XML Schema element</preamble>

<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
   <xsd:simpleType name="Artifact">
 <xsd:restriction base="PrintableString"/>
    </xsd:simpleType>
]]></artwork><!-- COLLECT END -->

    </figure>

   </section>
   <!-- Artifacts -->
   <section title="MessageDigest">
    <t>A MessageDigest is a short representation of data which can be used in evidences to link to some data. This is just another way of saying that they are the result of a one way hash function applied to some data.</t>
    <t>It is not assumed that a MessageDigest will always identify some data in a unique way (which is not the case by definition of a hash function), neither it is assumed that collisions may not exist now or in the future. It is only assumed that within a bounded collection of data objects (in time and number), which are stored phyically safe, a MessageDigest uniquely designate other data.</t>
    <t>Nevertheless, it is assumed that for the lifetime of protocol exchanges, a hash function used to create a MessageDigest is crytographically safe.</t>
    <t>The structure of a MessageDigest is a sequence of an globally defined identification of a hash function and an representation of an octet string encoding a value of the hash function.</t>

    <figure>
     <preamble>XML Schema element</preamble>
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="MessageDigest">
 <xsd:sequence>
  <xsd:element name="digestAlgorithm" 
               type="DigestMethodType"/>
  <xsd:element name="digestValue" 
               type="DigestValueType"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:simpleType name="DigestValueType">
 <xsd:restriction base="OCTET_STRING"/>
</xsd:simpleType>

<xsd:simpleType name="DigestMethodType">
 <xsd:restriction base="OBJECT_IDENTIFIER"/>
</xsd:simpleType>
]]></artwork><!-- COLLECT END -->
    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>

<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
MessageDigest ::= SEQUENCE {
    digestAlgorithm DigestMethodType,
    digestValue     DigestValueType
}

DigestMethodType ::= OBJECT IDENTIFIER
DigestValueType ::= OCTET STRING

]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <!-- Message Imprints -->
   <section title="MetaData">
    <t>Metadata are a list of open types which can be regarded as key/value pairs giving addtional information about entities or data or which are related to the preservation process.</t>
 

    <t>The following ASN.1 definition allows to have hierarchical metadata structures that can be decoded and encoded without
     the need to modify the ASN.1 definition. It is left to the application layers or other metadata defnitions to define
     restrictions and semantics.</t>
    <t>The 'type' identifies in a globally unique way the semantics of the value. The 'oid' choice can be used in a similar way as with the MIBs in SNMP. The 'uri' choce allows to reference metadata defined by URIs. The semantics 'attribute' choice normally depends on the semantics of a surrounding definition. Global values for 'attribute' may exist, i.e. the choice can be used in the outermost MetaData sequence.</t>
<t>This specification defines one global 'attribute' "datatype". The  'values' item MUST contain one occurence of either a 'stringValue' which indicates a mime-type, or an 'oidValue' or 'uriValue' indicating an FTAM document type.</t>
<t>Some global metadata are essential for the LTA service and require a standardised interpretation. An LTA MUST provide a complete description of all metadata it associates to an archived data object. A client is not required to implement any particular treatment of such metadata.</t> 
<t> 
 Although it is possible to recur to some other existing metedata specification, e.g., the Dublin Core, we do not want to depend on external semantics here. An LTA is free to map metadata. 
</t>
    <figure>
    <preamble>ASN.1 Definition</preamble>
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
MetaData ::= SEQUENCE OF MetaItem

MetaItem ::= SEQUENCE {
  type CHOICE {oid OBJECT IDENTIFIER,
               attribute UTF8String, 
               uri  IA5String } ,
  values SEQUENCE OF 
     value CHOICE {
        oidValue  OBJECT IDENTIFIER,
        stringValue UTF8String,
        uriValue IA5String,
        integerValue INTEGER,
        opaqueValue OCTET STRING,
        composedValue MetaItem 
     }
}
]]></artwork><!-- COLLECT END -->
    </figure>
    <figure>
     <preamble>XML Schema element</preamble>
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="MetaData">
 <xsd:sequence minOccurs="0"
               maxOccurs="unbounded">
  <xsd:element name="MetaItem" 
               type="MetaItem"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="MetaItem">
 <xsd:sequence>
  <xsd:element name="type">
   <xsd:complexType>
    <xsd:choice>
     <xsd:element name="oid" 
                  type="OBJECT_IDENTIFIER"/>
     <xsd:element name="attribute" 
                  type="UTF8String"/>
     <xsd:element name="uri" 
                  type="IA5String"/>
    </xsd:choice>
   </xsd:complexType>
  </xsd:element>
  <xsd:element name="values">
   <xsd:complexType>
    <xsd:sequence minOccurs="0" 
                  maxOccurs="unbounded">
     <xsd:choice>
      <xsd:element name="oidValue" 
                   type="OBJECT_IDENTIFIER"/>
      <xsd:element name="stringValue" 
                   type="UTF8String"/>
      <xsd:element name="uriValue" 
                   type="IA5String"/>
      <xsd:element name="integerValue" 
                   type="INTEGER"/>
      <xsd:element name="opaqueValue" 
                   type="OCTET_STRING"/>
      <xsd:element name="composedValue" 
                   type="MetaItem"/>
     </xsd:choice>
    </xsd:sequence>
   </xsd:complexType>
  </xsd:element>
 </xsd:sequence>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->
    </figure>
   </section>
   <!-- Metadata-->
   <section title="Nonce">
    <t>A Nonce is an octetstring usable to prevent replays of responses for the STATUS operation. If present in a request, a server MUST respond with a response containing the Nonce value. It does not indicate that the server must determine in a back-end operation the actual status. </t>
    <figure>
     <preamble>XML Schema element</preamble>

<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:simpleType name="Nonce">
 <xsd:restriction base="OCTET_STRING"/>
</xsd:simpleType>
]]></artwork><!-- COLLECT END -->
    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
Nonce ::= OCTET STRING 
]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <!-- Nonce-->

   <section title="RawData">
    <t>This type carries data to be verified, archived or returned. A client MUST select a metadata type to indicate the type of the data or the type of the data MUST be defined as part of the service policy.</t>
    <t>For preservation purposes, an LTA must have information on archive data type (e.g., signed or unsigned). If type is not included, it is assumed that data retrieved must be processed as binary string (e.g signatures are not verifed.).</t>
 
    <figure>
     <preamble>XML Schema element</preamble>

<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="RawData">
 <xsd:choice>
  <xsd:element name="opaque" type="OCTET_STRING"/>
  <xsd:element name="string" type="UTF8String"/>
  <xsd:element name="structured" type="MetaData"/>
  </xsd:choice>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->

    </figure>

    <figure>
     <preamble>ASN.1 Definition</preamble>

<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
RawData ::= CHOICE {
opaque     OCTET STRING,
string     UTF8String,
structured MetaData
}
]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <!-- RawData-->
   <section title="DataOrTransaction">
    <t>This choice type is used to identify data by:</t>
 <t>
          <list style="symbols">
            <t>themselves</t>
            <t>an artifact identifying a transaction</t>
            <t>a data identifier</t>
          </list>
 </t>
    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="DataOrTransaction">
 <xsd:choice>
  <xsd:element name="data" type="RawData"/>
  <xsd:element name="artifact" type="Artifact"/>
  <xsd:element name="reference" type="IA5String"/>
 </xsd:choice>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->

    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
DataOrTransaction ::= CHOICE {
data      RawData,
artifact  Artifact,
reference IA5String
    }
]]></artwork><!-- COLLECT END -->
<!-- COLLECT END -->
    </figure>
   </section>
   <section title="ArchiveData">
    <t>This type is used to describe data together with metadata. At least one of the optional elements MUST be provided in order to either provide or identify the data.</t>
<t>The number of element fields allowed in requests or responses depends on the service.</t>
<t>The optional messageImprint field contains the hash value of a corresponding rawData element (provided for example in a initial ARCHIVE request.)The messageImprint is calculated on the content octets of the choices
of the RawData elements: For the opaque and string choices, the content of the
octet string is used, i.e. giving the same digest independantly of the
actual encoding of the data. For the structured choice the result differs
depending on the encoding, either thye XER encoding or the DER encoding
is used. (need to verify if XER is a canonic form).</t>
    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="ArchiveData">
 <xsd:sequence minOccurs="0" maxOccurs="unbounded">
  <xsd:element name="element">
   <xsd:complexType>
    <xsd:sequence>
     <xsd:element name="dataReference" 
                  type="DataOrTransaction"/>
     <xsd:element name="metaData" 
                  type="MetaData" minOccurs="0"/>
     <xsd:element name="messageImprint" 
                  type="MessageDigest" minOccurs="0"/>
    </xsd:sequence>
   </xsd:complexType>
  </xsd:element>
 </xsd:sequence>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->

    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
ArchiveData ::= SEQUENCE OF element SEQUENCE{
    dataReference  DataOrTransaction ,
    metaData       MetaData OPTIONAL ,
    messageImprint [0] MessageDigest OPTIONAL
} 

]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <section title="SerialNumber">
    <t>A SerialNumber is an integer value used to identify a request and its response. Servers MAY add an additional verifyable structure to such a number, e.g. checksum digits, in order to avoid copying errors in long-term applications with potential media break.</t>
    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:simpleType name="SerialNumber">
 <xsd:restriction base="INTEGER"/>
</xsd:simpleType>
]]></artwork><!-- COLLECT END -->

    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>

<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
SerialNumber ::= INTEGER
]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <!-- SerialNumber -->
   <section title="LtapTime">
    <t>Clients and servers can add an indication of (its idea of) the time when a request or response was created, search intervals etc. The LtapTime type is used. The encoding of the string content MUST be according to the distinguished encoding rules (DER).</t>
    <figure>
     <preamble>XML Schema element</preamble>

<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:simpleType name="LtapTime">
 <xsd:restriction base="GeneralizedTime"/>
</xsd:simpleType>
]]></artwork><!-- COLLECT END -->

    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
LtapTime ::= GeneralizedTime 
]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <!-- Time -->
   <section title="Version">
    <t>Version is used in requests and responses to indicate the protocol version used. This specification is provided for two values:</t>
    <t>
     <list style="symbols">
      <t>v0 - This version should be used by implementation that want to experiment with draft version of this specification.</t>
      <t>v1 - this version is used to indicate that the request and response corresponds to this specification.</t>
     </list>
    </t>
    <t>This memo does not define an extension mechanism.</t>
    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="Version">
 <xsd:choice>
  <xsd:element name="v0" type="NULL"/>
  <xsd:element name="v1" type="NULL"/>
 </xsd:choice>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->

    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
Version ::= ENUMERATED {
    v0,
    v1
}
]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <!-- Version -->
   <section title="EntityIdentifier">
    <t>Entity identifiers are used in the protocol to indicate the participating entities. A client can indicate one or more identifiers indicating who is making the request or participating in its creation and one or more identifiers indicating who should perform the service. A server can indidate who has provided the service and who is the indented client.</t>
    <t>A client MAY also indicate an address to who a response is to be return in case of an asynchronous reponse, e.g. an e-mail address.</t> 
    <t>It MUST be ensured in some way that in an actual context of a client/server network names are scalable and global both in terms of actual community space and time to live of the treated data objects.</t>
    <t>Identifiers are defined as GeneralNames imported from InformationFramework.</t>
    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="EntityIdentifier">
 <xsd:sequence minOccurs="0" maxOccurs="unbounded">
  <xsd:choice>
   <xsd:element name="rfc822Name" type="IA5String"/>
   <xsd:element name="dNSName" type="IA5String"/>
   <xsd:element name="directoryName" type="Name"/>
   <xsd:element name="uniformResourceIdentifier" 
                type="IA5String"/>
   <xsd:element name="iPAddress" type="OCTET_STRING"/>
   <xsd:element name="registeredID" 
                type="OBJECT_IDENTIFIER"/>
   </xsd:choice>
 </xsd:sequence>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->

    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
EntityIdentifier ::= GeneralNames
]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <!-- EntityIdentifier -->
   <section title="ServiceType">
    <t>This type is either enumeration of core services defined in this memo of an object identifier defined by a service provider. It indicates operations accessible by the protocol.</t>
    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="ServiceType">
 <xsd:choice>
  <xsd:element name="core">
   <xsd:complexType>
    <xsd:choice>
     <xsd:element name="archive" type="NULL"/>
     <xsd:element name="delete" type="NULL"/>
     <xsd:element name="export" type="NULL"/>
     <xsd:element name="status" type="NULL"/>
     <xsd:element name="verify" type="NULL"/>
     <xsd:element name="listids" type="NULL"/>
    </xsd:choice>
   </xsd:complexType>
  </xsd:element>
  <xsd:element name="ltapextendedservice" 
               type="OBJECT_IDENTIFIER"/>
 </xsd:choice>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->

    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
ServiceType ::= CHOICE {
   core ENUMERATED {
      archive,
      delete,
      export,
      status,
      verify,
      listids
   },
   ltapextendedservice OBJECT IDENTIFIER
}
]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <!-- ServiceType -->
   <section title="StatusInformation">
    <t>The LTA indicates the global status of a transaction using this enumeration type. The semantics of the values is as follows:</t>
<t>
<list type="hanging">
<t hangText="waiting">
The response is an initial first type reponse. The request has been technically accepted by the LTA.
</t>
<t hangText="granted">
The response is a second type final response from the LTA.  
</t>
<t hangText="grantedWithMods">
The response is a second type final response from the LTA. The operation performed by the LTA but only with some modifications. 
</t>
<t hangText="error">
The operation has not been accepted.
</t></list>
</t>
<t>In case of modifications or error, the LTA MUST also return details using the following GeneralErrorNotice</t>


    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="StatusInformation">
 <xsd:choice>
  <xsd:element name="granted" type="NULL"/>
  <xsd:element name="grantedWithMods" type="NULL"/>
  <xsd:element name="rejection" type="NULL"/>
  <xsd:element name="waiting" type="NULL"/>
  <xsd:element name="more" type="NULL"/>
 </xsd:choice>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->

    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
StatusInformation ::= ENUMERATED {
    granted,
    grantedWithMods,
    rejection,
    waiting,
    more
}
]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <!-- StatusInformation -->
 

<section title="RequestInformation">
    <t>This data structure comprises information about the request others that the raw data and metadata. The structure is filled in partially by a requestor and augmented or modified by the responder. It resumes
the operation that has been performed.</t>
 

    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[

RequestInformation ::= SEQUENCE {
    version           Version DEFAULT v1,
    servicePolicyInfo PolicyInformation,
    serviceType       ServiceType,
 
    requestorID       EntityIdentifier,
    serviceID         EntityIdentifier,
    returnID          EntityIdentifier OPTIONAL, 
    serial            SerialNumber OPTIONAL,
    nonce             Nonce OPTIONAL,  
    requestTime       LtapTime OPTIONAL,
    startTime         [0] LtapTime OPTIONAL, 
    nextTime          [1] LtapTime OPTIONAL,
    bindingInfo       [2] MetaData OPTIONAL
}
]]></artwork><!-- COLLECT END -->

    </figure>
    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="RequestInformation">
 <xsd:sequence>
  <xsd:element name="version" 
               type="Version" minOccurs="0"/>
  <xsd:element name="servicePolicyInfo" 
               type="PolicyInformation"/>
  <xsd:element name="serviceType" 
               type="ServiceType"/>
  <xsd:element name="requestorID" 
               type="EntityIdentifier"/>
  <xsd:element name="serviceID" 
               type="EntityIdentifier"/>
  <xsd:element name="returnID" 
               type="EntityIdentifier" minOccurs="0"/>
  <xsd:element name="serial" 
               type="SerialNumber" minOccurs="0"/>
  <xsd:element name="nonce" 
               type="Nonce" minOccurs="0"/>
  <xsd:element name="requestTime" 
               type="LtapTime" minOccurs="0"/>
  <xsd:element name="startTime" 
               type="LtapTime" minOccurs="0"/>
  <xsd:element name="nextTime" 
               type="LtapTime" minOccurs="0"/>
  <xsd:element name="bindingInfo" 
               type="MetaData" minOccurs="0"/>
 </xsd:sequence>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->

    </figure>
    
   <t>The version item indicates the version of the protocol to be used.</t>
   <t>The item serviceType indicate the operation to be performed. The value can be one of the enumeration values defined in this memo or an object identifier defining another operation. Additional operation MUST NOT modify the ASN.1 but use
metadata for additional parameters.</t>
   <t>The serviceID item identifies the LTA service provider(s)</t>
   <t>The servicePolicyInfo item defines the service policy.</t>
   <t>If a client specifies a nonce item, the server MUST return either the same value, or a value that has the client value as a prefix.</t>
   <t>The meaning of the startTime and nextTime items depend on the value of the serviceType item and is described later.</t>

   <t>The serial item indicates a serial number of a request has been received, the field MUST NOT be set by the requestor and MUST be set by the responder in order to uniquely identify the request.</t>
  <t>The requestTime item indicates the time when the request has been received, the field MAY be set by the requestor in case of a proxy and it SHOULD be set in any response.</t>
  <t>The bindingInfo item contains additional information required by the LTA or returned to the client. These metadata are associated with the request and not with the archived data.</t>
  <t>The semantics of the items startTime and nextTime depend on the serviceType.</t>

   </section>
</section>
<section title="Top level protocol elements">
<t>On the top level, there are three protocol elements, one is used in requests, and the two other are either describing the successful outcome of an operation or an error notice.</t>
   <section title="Request">
    <t>This data structure describes a request made by a client. It contains a RequestInformation data structure, as well as data or data references. At least one of the Data and MessageDigest elements must be provided.</t>
    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="Request">
 <xsd:sequence>
  <xsd:element name="information" 
               type="RequestInformation"/>
  <xsd:element name="data" 
               type="ArchiveData" minOccurs="0"/>
  <xsd:element name="transactionIdentifier" 
               type="IA5String" minOccurs="0"/>
 </xsd:sequence>
</xsd:complexType>

]]></artwork><!-- COLLECT END -->

    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
Request ::= SEQUENCE {
   information           RequestInformation,
   data                  ArchiveData OPTIONAL,
   transactionIdentifier IA5String OPTIONAL
}

]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <section title="StatusNotice">
    <t>A server may return a general error notice indicating an important failure with referencing the request. The element can be created either by the service, e.g., when a request cannot be decoded, but also by a client lower layer, e.g. when a connection cannot be established.</t>

    <figure>
     <preamble>XML Schema element</preamble>

<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="StatusNotice">
 <xsd:sequence>
  <xsd:element name="status" 
               type="StatusInformation"/>
  <xsd:element name="errorInformation">
   <xsd:complexType mixed="true">
    <xsd:complexContent mixed="true">
     <xsd:extension base="UTF8String"/>
    </xsd:complexContent>
   </xsd:complexType>
  </xsd:element>
  <xsd:element name="lastValid" 
               type="LtapTime" minOccurs="0"/>
  <xsd:element name="transactionIdentifier" 
               type="IA5String" minOccurs="0"/>
 </xsd:sequence>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->
    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
StatusNotice ::= SEQUENCE {
    status           StatusInformation,
    errorInformation UTF8String (SIZE(0..8192)),
    lastValid        LtapTime OPTIONAL,
    transactionIdentifier IA5String OPTIONAL
}
]]></artwork><!-- COLLECT END -->

    </figure>
   </section>
   <section title="OperationResponse">
    <t>This structure is returned on a successful or unsuccessful operation of the service. It references the initial request as well as the data that had been submitted.</t>
    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="OperationResponse">
 <xsd:sequence>
  <xsd:element name="information" 
               type="RequestInformation"/>
  <xsd:element name="status" type="StatusNotice"/>
  <xsd:element name="data" type="ArchiveData"/>
 </xsd:sequence>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->
    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
OperationResponse ::= SEQUENCE {
    information RequestInformation,
    status             StatusNotice,
    data               ArchiveData
}
]]></artwork><!-- COLLECT END -->
    </figure>
   </section>
   <section title="Response">
    <t>This structure is returned on a successful or unsuccessful operation of the service.</t>
    <figure>
     <preamble>XML Schema element</preamble>
     
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:complexType name="Response">
 <xsd:choice>
  <xsd:element name="operationResponse" 
               type="OperationResponse"/>
  <xsd:element name="errorNotice" 
               type="StatusNotice"/>
 </xsd:choice>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->
    </figure>
    <figure>
     <preamble>ASN.1 Definition</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
Response ::= CHOICE {
    operationResponse OperationResponse,
    errorNotice   [0] StatusNotice
}
]]></artwork><!-- COLLECT END -->
    </figure>
   </section>

  </section>
  <!-- Data Types -->
    <section title="Service Operations">
      <t>This section describes in detail the different operations that a client can initiate with a request and their outcomes. All operations share the same data types for the input and output but the choices are filled in differently.</t>
<t>For all operations, the archive service may react in the following ways:</t>
        <t>
<list type="hanging">
<t hangText="Error">The request is not understood or cannot be transmitted, an ErrorNotice is returned.</t>
<t hangText="Acceptance"> The request is accepted, an OperationResponse indicating that the transaction is 'waiting'. The item nextTime in the requestInformation SHOULD be set by the responder in case when the client needs to poll for the final response to indicate to the client not poll before that date.</t>
<t hangText="Rejection">The request is rejected. an OperationResponse describing the error is returned. </t>
<t hangText="Result">This a final response, an OperationResponse containing the result of the transaction is returned.</t>
          </list>
        </t>
      <t>When the transport layer is asynchronous, the protocol is the following: The client MUST fill the item  'returnID' in the requestInformation. A server MAY respond either with the final result or with two messages indicating acceptance and result.  The client MAY retry the operation (slightly modified) after that date. Since any operation can be lost, a client has to set an appropriate value for initial retry timeout.</t>
      <t>When the transport layer is synchronous, e.g. if HTTP is used, the server immediately returns either an error or acceptance, and the client MUST retry the operation (slightly modified) in order to get the final result.</t>
      <t>A server may offer a mixed environment where the initial response is obtained in a synchronous way, and the final response can be transferred in an asynchronous way. In this case, the client MAY be required to set a returnID.</t>  

      <section title="ARCHIVE operation">
        <t>The major operation of the archive service is the ARCHIVE operation. A client prepares the data and associated metadata, and transfers the request to the archive service.
         The client builds a Request with an information item including service policy interpreting service characteristics and service configuration parameters. Data to be archived and metadata are enclosed.</t>
<t>
          <list style="symbols">
            <t>the service type is set to "archive"</t>
            <t>If this is an initial request, the data are filled in with one element and rawData.</t>
<t>The messageImprint field MAY be set in order to perform an integrity check on the rawData. The LTA calculated a messageImprint and returns the calcumated value in the corresponding field of the response.
 If a messageImprint is present in the request, the server compares it to the
 calculated value, and rejects the request in case the two value differ.</t>
    <t>If this is a retry of a previous operation, the client has several option depending on the outcome of the previous operation and available information. If no response has been received by the client, the client MAY either repeat the operation as is, or send remove the content octets of the selected choice (replacing it by a zero length choice) and send a messageImprint.</t>
<t>If available from an initial response, the client MUST provide an artifact, if available from an response.</t> 

          </list>
</t>
          <t>The server SHOULD use an artifact when the StatusInformation is 'waiting', in order to simplify its processing when the client retries the operation.  When an operation is retried, the client SHOULD use the returned artifact instead of the data.</t>
          <t>The final response contains a data reference to be usable in other operations concerning the same data object.</t>
          <t>When a client archives may objects in parallel operations, it may be unreasonable to poll for each outstanding result individually. An LTA MAY support a LISTIDS function returning artifacts for finished archive operations.</t>

      </section>
      <!-- ARCHIVE Operation -->


      <section title="EXPORT operation">
        <t>This operation allows a client to retrieve data.</t>
          <t>
          <list style="symbols">
          <t>Data identification must be a data reference and/or a message imprint.</t>
         <t>The service type is set to "export".</t>
</list>
</t>

          <t>In the final result, the LTA returns data and metadata of the object.</t>

      </section>
      <!-- EXPORT Operation -->

     <section title="DELETE operation">
        <t>This operation allows a client to delete data or request data shredding. After a successful operation, the the server does not maintain any status information about the object.</t>
         <t>
          <list style="symbols">
        <t>Data identification must include data itself or data reference or message imprint.</t>
      <t>The metadata MAY be set to replace the existing metadata of the object.</t>
         <t>The service type is set to "delete".</t>
</list>
</t>

          <t>The LTA MAY either return a result with updated metadata or nothing.</t>
          <t>If the client retries a delete operation, it may happen that the LTA has already deleted all traces of the operation. In this case, the server always pretends having deleted the referenced data. The client cannot distinguish whether the data have ever existed.</t>
</section>
          <!-- DELETE Operation -->


      <section title="VERIFY operation">
        <t>This operation allows a client to verify the authenticity of information stored in the archive. Depending on the actual status of the object and on the policy of the LTA, the LTA initiates an internal procedure to determine the validity of the data. An LTA may perform the similar steps as for the initial archiving operation. The LTA MAY choose not to perform the operation if the actual status is sufficiently recent. In this case, the operation is identical to STATUS operation.</t>
          <t>
          <list style="symbols">
          <t>Data identification must be a data reference and/or a message imprint.</t>
         <t>The service type is set to "verify".</t>
</list>
</t>
          <t>The LTA returns updated metadata of the object.</t>
      </section>
      <!-- VERIFY Operation -->

 
     <section title="STATUS operation">
        <t>A client can request the status of a data object.</t>
          <t>Client builds a Request with request information including service policy interpreting service characteristics and service configuration parameters.</t> 
         <t>
          <list style="symbols">
<t>The service type is set to "status".</t>
           <t>Data identification must be a data reference and/or a message imprint.</t>
 
          </list>
        </t>
          <t>In the final response, the LTA returns the current status and the metadata for the object.</t>
 
      </section>
      <!-- STATUS Operation -->

     <section title="LISTIDS operation">
        <t>A client can request a list of reference of objects archived. The client builds a Request with request information including service policy interpreting service characteristics and service configuration parameters.</t> 
         <t>
          <list style="symbols">
<t>The service type is set to "LISTIDS".</t>
           <t>Data identification MUST be a data reference, an artifact and/or a message imprint. If present, the LTA returns references to objects starting with this reference in the chronological order defined by the LTA. The reference or artifact MUST be known to the LTA.</t>
           <t>The startDate and endDate MAY be set to indidate a range. The exact definition of when an object belongs to that range is defined by the LTA.</t>
          </list>
        </t>
          <t>The LTA returns a list of references as a sequence of DataOrTransaction items. The artifact and dataReference choices are allowed. If the request contains an artifact, the LTA MUST return the artifacts that correspond to terminated transactions.</t>
<t> 
The number of references returned is defined by the LTA and may not be the complete set. If the LTA has more data to provide, it sets the StatusInformation to 'more'. The client has to repeat the operation using the last returned reference as data identification. A client can distinguish this case from the initial acknowledge which has the same value for StatusInformation. For the Acceptance response no references are returned. There may be a final response with no references incase when no data exist for the specified criteria.</t>
 
      </section>
      <!-- STATUS Operation -->


    </section>    
  <!-- Archive Operations -->

  <section title="Presentation and Bindings">
   <t>In the previous chapters we have presented all basic data types as well as XSD schema as in with ASN.1. This is done in order to allow implentations work on both data syntaxes and to be able to present and transform messages in a defined way.</t>
     <t>There is no mandatory transport mechanism in this document. All mechanisms are optional. Two examples of transport protocols are given that allow online exchange of request and a response, and asynchronous communication between a client and an LTA. An LTA MAY use a combination of protocols, for example in order to return additional responses.</t>


     <t>This memo defines bindings for the transfer of requests and/or responses, one using HTTP and another using e-mail.</t>
   <section title="Common parameters and encoding requirements">
<t>This memo defines two principalways how requests and responses are encoded, either using a restricted BER encoding or XML. An LTA MUST provide at least one of them. Furthermore, we define optional enveloping protection mechanisms which depend on the encoding. CMS protection of signedData and envelopedData can be used independantly of the encoding of the request or response. XML-DSIG and XML-ENC can only be used for XML encoded requests and responses.</t>
 
<t>For requests encoded in XML either based on XER (or the equivalent XSD), the associated MIME type is application/ltap-request+xml. For request not encoded in XML, the associated MIME type is application/ltap-request.</t> 

 <t>Similarly, for responses have an associated MIME types application/ltap-response and application/ltap-response+xml.</t>
<t>When request and responses are exchanged using an XML encoding, the XSD top level elements LTAPRequest or LTAPResponse are used, and not an XER version of ContentInfo.</t>
<t>When a XML Signature is used, an enveloping signature for a Request or Response or enc:EncryptedData MUST be used</t>
<t>EncryptedData MUST decrypt to a Request or Response or ds:Signature</t>  
 
<t>When the request is presented with the application/ltap-request type, the client MAY encode it using BER with strings nested at most one level. Similarily, a response presented with the application/ltap-response type may have BER with strings nested at most one level.</t> 

<t>The Request and Response items can be encapsulated inside CMS signedData and/or CMS envelopedData, or, 
If not protected, the Request is encapsulated in a ContentInfo using id-ct-LTAPRequest as identification, and the Response is encapsulated in a ContentInfo structure using id-ct-LTAPResponse for identification.</t>
<t>If the Request and Response which are not encoded in XML are encapsulated inside SignedData and/or EnvelopedData, the contenttype of the innermost encapsulatedContent is set to using id-ct-LTAPRequest or id-ct-LTAPResponse respectively.</t>  

<t>Any of the four MIME parts can be encapsulated inside CMS using an id-data content-type.</t>
<t>LTANS has its own object identifier tree, the content-types are defined there. The owner of the S/MIME arc doesn't like to register them in the S/MIME arc.</t> 

<t>
    <figure>
     <preamble>CMS ContentTypes identifiers</preamble>
     
<!-- COLLECT BEGIN ASN1_ASN188 --><artwork><![CDATA[
id-ltans-ct OBJECT IDENTIFIER ::= { 
      iso(1) identified-organization(3) 
      dod(6) internet(1) security(5) mechanisms(5) 
      ltans(11) 1 }

id-ct-LTAPRequest  OBJECT IDENTIFIER ::= 
         { id-ltans-ct 4 }
id-ct-LTAPResponse  OBJECT IDENTIFIER ::= 
         { id-ltans-ct 5 }

]]></artwork><!-- COLLECT END -->
    </figure>
In current ASN.1 we have the following ContentType definitions.
    <figure>
     <preamble>CMS ContentTypes</preamble>
     

<!-- COLLECT BEGIN ASN1 --><artwork><![CDATA[
ltap-Request  PKCS7-CONTENT-TYPE ::= {Request
     IDENTIFIED BY  id-ct-LTAPRequest }
ltap-Response PKCS7-CONTENT-TYPE ::= {Response
     IDENTIFIED BY  id-ct-LTAPResponse }

LTAPRequest ::= ContentInfo
LTAPResponse ::= ContentInfo
]]></artwork><!-- COLLECT END -->
    </figure>
 </t> 

   <figure>
     <preamble>XML top level definitions</preamble>
<!-- COLLECT BEGIN XSD --><artwork><![CDATA[
<xsd:element name="Request" type="Request"/>
<xsd:element name="Response" type="Response"/>
<xsd:element name="LTAPRequest" type="LTAPRequest"/>
<xsd:element name="LTAPResponse" type="LTAPResponse"/>

<xsd:complexType name="LTAPResponse">
 <xsd:choice>
  <xsd:element name="response" type="Response"/>
  <xsd:element name="signedResponse" type="ds:Signature"/>
  <xsd:element name="encryptedResponse" type="enc:EncryptedData"/>
 </xsd:choice>
</xsd:complexType>

<xsd:complexType name="LTAPRequest">
 <xsd:choice>
  <xsd:element name="request" type="Request"/>
   <xsd:element name="signedRequest" type="xd:Signature"/>
   <xsd:element name="encryptedRequest" type="enc:EncryptedData"/>
 </xsd:choice>
</xsd:complexType>
]]></artwork><!-- COLLECT END -->
    </figure>

   </section>
   <section title="e-mail bindings">

    <t>In a request, the last element of item requestorID corresponds to the From header, the last element of the item serviceID to the To header and the last element of the returnID to reply-to header. The e-mail header is not used by the LTA, but rather the items in the requestInformation. When a server acts as a relay, it MAY add appropriate values to these items.</t>
    <t>For the response, an LTA normally sets the From and To header fields to either the last items of  serviceID and returnID (or requestorID). In case of a relaying LTA, when the LTA receives a response from another LTA, it first determines its own identity
in requestInformation, sets the From: header to its own identity and the To: header to the identity of its client.</t>
    </section>
   <section title="HTTP Bindings" anchor="http">
<t>Servers MUST understand HTTP 1.1 requests at least for the ARCHIVE, EXPORT and LISTIDS functions allowing chunked input of a POST request and 'Continue' responses. A server SHOULD understand a Content-Encoding value of gzip. In case of a HTTP 1.0 request and response, a positive value Content-Length indicating the total size of the data MUST be used. A client MUST send a Host header in the request.</t>

<t>The Request URI may be used to indicate a particular service endpoint.
When using HTTPS, TLS MUST be supported by clients and servers. Clients SHOULD send a TLS servername extension in the ClientHello.</t>
<t>
The Content-Type header MUST be set to "application/ltap-request" or "application/ltap-request+xml".
The LTAPrequest message MUST be sent in the body of the HTTP Request.</t>

<t>The Content-Type header MUST be set to "application/ltap-response" or "application/ltap-response+xml".
The LTAP response message MUST be sent in the body of the HTTP Response.</t>
<t>The HTTP status code MUST be set to 200 if a LTAP response message is returned.  Otherwise, the status code can be set to 3xx to indicate a redirection, 4xx to indicate a low-level client error (such as a malformed request), or 5xx to indicate a low-level server error. Clients SHOULD react automatically to redirections.</t>  
<t>When using HTTPS, TLS 1.0 MUST be supported.  SSL 3.0 MAY be supported by servers. Future versions of TLS MAY be supported. Clients SHOULD send a TLS servername extension in the ClientHello.</t>


<t>RSA ciphersuites MUST be supported.  Diffie-Hellman and DSS ciphersuites MAY be supported.
TripleDES ciphersuites MUST be supported.  AES ciphersuites SHOULD be supported.</t>  
    </section>


  <section title="Security">
<t>
A request and a response MAY be encapsulated in an <xref target="RFC3852"/> signedData or envelopedData where the content type indicated in the eContentType of the encapContentInfo is one of the LTAP content types and the eContent of the encapContentInfo, carried as an octet string containing an encoded request or response structure.</t>
  <t>When using a SignedData structure for authentication, LTAP requests and responses MAY contain one or more SignerInfo structures, each of which may contain countersignature attributes depending on operational environments. Relaying LTAs MAY add additional signatures or a countersignature attributes or remove the encapsulation and create a new one depending on the requirements of the next LTA.</t>


<t>For the XML encoded structures, alternatively, security mechanisme from <xref target="W3C.xmldsig-core"/> and <xref target="W3C.xmlenc-core"/>
may be used. An LTA MAY impose restrictions on the usage of these features. </t>

   <t>Clients and relays MUST ensure authenticity of a server when submitting data. In order to do so, they MAY add another encapsulation from <xref target="RFC3852"/> that provides for confidentiality, and/or MAY use a secure transport layer, e.g., TLS to perform server authentication and to ensure confidentiality of the transport.</t>
   <t>Responses are generally protected in similar way by using a SignedData encapsulation with one or more SignerInfos, and CounterSignatures, depending on the number of participating servers.  The number of signatures is not related to the number of participating servers but rather to the number of entities that may be used to authenticate a response or part of it.</t>
   <t>In some circumstances, a client/server communication may be secured only by lower layer transport mechanism, e.g. SSL/TLS.</t>
   <t>A client MUST NOT trust a response that cannot be authenticated.</t>
   <t>Archive clients and servers MUST always create requests and responses that can be authenticated with the explicit exception of a global error status, which may be returned as a non-signed response.</t>
 <t>In order to be able to associate a possible error response with a request, the requester SHOULD use the field 'transactionIdentifier'.  The requester SHOULD not make any assumption about the usage of  message header fields by the responding service, in particular the usage of fields like Subject, Message-ID or References.</t>
  </section>

  <!-- Security -->
  </section>
  <section title="Credits">
<t>This document has been created using XML2RFC (<xref target="RFC2629" />).</t>
<t>The XSD schema has been generated automatically using the asn1xsd tool from OSS Nokalva.</t>
<t>The ASN.1 has been validated using the asn1c compiler from OSS Nokalva.</t>
<t>All participants of the IETF LTANS working group for their great patience and careful reading of the drafts.</t>
</section>
  <section title="Security Considerations">

   <t>This section discusses addition security considerations of the framework.</t>
   <t>When designing an LTA service, the following considerations have been identified that have an impact upon the validity or "trust" in the ltans server responses.</t>
<t>An LTA is assumed to operate with best effort. Nevertheless, an operation can fail or get totally lost. A client SHOULD be able to recover from lost requests, i.e., avoid deleting data until an attestation has been received.</t>
<t>It is possible for an LTA to report loss of integrity for archived data, or simply non-existence of data which is equivalent to loss of data. Depending on the value of the data, appropriate measures to address these catastrophic scenarios need to be provided outside the core service, e.g., by using redundant copies managed either by a client of internally of a broker type service.</t>
   <t>The validity of data should be checked by periodic execution of VERIFY operations intended to ensure data with demonstratable integrity is available throughout the lifetime of an archived data object. The rate of refresh will be driven by a number of factors, some of which have a direct impact of demonstration of integrity. For example, the confidence in the strength of cryptographic algorithms or the quality of storage devices are factors determining the verification intervals.</t>
   <t>Depending on the lifetime and the quality of data, relying on cryptographic protection of data object may not be a sufficient means to determine authenticity in time, other means may be required, e.g. physical protection of data storage material.</t>
   <t>It is imperative that keys used to sign responses are guarded with proper security and controls in order to minimize the possibility of compromise.  Nevertheless, in case the private key does become compromised, an audit trail of all the response generated by the service SHOULD be kept as a means to help discriminate between genuine and false responses. An LTA MAY provide for a service to validate responses created by this service or another one solely based on the audit trail.</t>
   <t>As already indicated, when confidentiality and server authentication is required, requests and responses MAY be protected using appropriate mechanisms (e.g., CMS encapsulation <xref target="RFC3852" /> or TLS <xref target="RFC4366" />).</t>
   <t>Server authentication is highly recommended for all service which transfer data to a server.</t>
   <t>Client identification and authentication MAY use services defined by TLS (<xref target="RFC4366" />) instead of, or in addition to, using a document or message protection format, e.g. CMS.</t>
   <t>It is possible for an LTA to report loss of integrity for archived data, or simply non-existence of data which is equivalent to loss of data. Depending on the value of the data, appropriate measures to address these catastrophic scenarios need to be provided outside the core service, e.g., by using redundant copies managed either by a client of internally of a broker type service.</t>
  </section>
  <!-- Security Considerations -->
  <section title="IPR Patent Information">
   <t>The material presented in this document was initially drafted in 2005.</t>
   <t>The following United States Patents related to data validation and certification services, listed in chronological order, are known by the authors to exist at this time.  This may not be an exhaustive list.  Other patents may exist or be issued at any time.  Implementers of this protocol and applications using the protocol SHOULD perform their own patent search and determine whether or not any encumberences exist on their implementation. The list is intitially taken from <xref target="RFC3029"/>.</t>
<t>
# 4,309,569 Method of Providing Digital Signatures<vspace blankLines="0" />
(issued) January 5, 1982<vspace blankLines="0" />
(inventor) Ralph C. Merkle<vspace blankLines="0" />
(assignee) The Board of Trustees of the Leland Stanford Junior University<vspace blankLines="1" />

# 5,001,752 Public/Key Date-Time Notary Facility<vspace blankLines="0" />
(issued) March 19, 1991<vspace blankLines="0" />
(inventor) Addison M. Fischer<vspace blankLines="1" />

# 5,022,080 Electronic Notary<vspace blankLines="0" />
(issued) June 4, 1991<vspace blankLines="0" />
(inventors) Robert T. Durst, Kevin D. Hunter<vspace blankLines="1" />

# 5,136,643 Public/Key Date-Time Notary Facility<vspace blankLines="0" />
(issued) August 4, 1992<vspace blankLines="0" />
(inventor) Addison M. Fischer<vspace blankLines="1" />
(Note: This is a continuation of patent # 5,001,752.)<vspace blankLines="0" />

# 5,136,646 Digital Document Time-Stamping with Catenate Certificate<vspace blankLines="0" />
(issued) August 4, 1992<vspace blankLines="0" /><vspace blankLines="0" />
(inventors) Stuart A. Haber, Wakefield S. Stornetta Jr.<vspace blankLines="0" />
(assignee) Bell Communications Research, Inc.<vspace blankLines="1" />

# 5,136,647 Method for Secure Time-Stamping of Digital Documents<vspace blankLines="0" />
(issued) August 4, 1992<vspace blankLines="0" />
(inventors) Stuart A. Haber, Wakefield S. Stornetta Jr.<vspace blankLines="0" />
(assignee) Bell Communications Research, Inc.<vspace blankLines="1" />

# 5,373,561 Method of Extending the Validity of a Cryptographic Certificate<vspace blankLines="0" />
(issued) December 13, 1994<vspace blankLines="0" />
(inventors) Stuart A. Haber, Wakefield S. Stornetta Jr.<vspace blankLines="0" />
(assignee) Bell Communications Research, Inc.,<vspace blankLines="1" />

# 5,422,95 Personal Date/Time Notary Device<vspace blankLines="0" />
(issued) June 6, 1995<vspace blankLines="0" />
(inventor) Addison M. Fischer<vspace blankLines="1" />

# 5,781,629 Digital Document Authentication System<vspace blankLines="0" />
(issued) July 14, 1998<vspace blankLines="0" />
(inventor) Stuart A. Haber, Wakefield S. Stornetta Jr.<vspace blankLines="0" />
(assignee) Surety Technologies, Inc.<vspace blankLines="1" />
</t>
  </section>
 <section title="IANA considerations">
<t>
  LTAP request and response messages are identified using
  Object Identifiers (OIDs), which are defined in an arc
  delegated by IANA to the LTANS Working Group.  This document also
  includes four MIME type registrations in <xref target="http" />.  
  No further action by IANA is necessary for this document.
</t>
  </section>
  <!-- Patent Information -->
        </middle>
 <back>
  <references title="Normative references">&rfc2119;&rfc3852;&rfc4366;&rfc4998;</references>
  <references title="Informative references">&rfc2629;&rfc3029;&rfc4810;&XML-DSIG;&XML-ENC;</references>

  <section title="ASN.1 module in current syntax">
   <t>The following ASN.1 module has been checked using the asn1c tool.</t>
   <figure>
<!-- COLLECT INCLUDE ASN1 --><artwork><![CDATA[
LTAP {iso(1) identified-organization(3) dod(6) 
      internet(1) security(5) mechanisms(5) 
      ltans(11) id-mod(0) id-mod-ltap(4) 0}
DEFINITIONS IMPLICIT TAGS ::=
BEGIN


-- EXPORTS ALL
IMPORTS 

   certificateExtensions 
FROM UsefulDefinitions {joint-iso-itu-t ds(5) module(1)
      usefulDefinitions(0) 5}

   PolicyInformation, GeneralNames
FROM CertificateExtensions certificateExtensions

   PKCS7-CONTENT-TYPE, ContentInfo
FROM PKCS7
   {iso(1) member-body(2) us(840) rsadsi(113549)
  pkcs(1) pkcs-7(7) modules(0) pkcs-7(1)}
;

Artifact ::= PrintableString 

MessageDigest ::= SEQUENCE {
    digestAlgorithm DigestMethodType,
    digestValue     DigestValueType
}

DigestMethodType ::= OBJECT IDENTIFIER
DigestValueType ::= OCTET STRING


MetaData ::= SEQUENCE OF MetaItem

MetaItem ::= SEQUENCE {
  type CHOICE {oid OBJECT IDENTIFIER,
               attribute UTF8String, 
               uri  IA5String } ,
  values SEQUENCE OF 
     value CHOICE {
        oidValue  OBJECT IDENTIFIER,
        stringValue UTF8String,
        uriValue IA5String,
        integerValue INTEGER,
        opaqueValue OCTET STRING,
        composedValue MetaItem 
     }
}

Nonce ::= OCTET STRING 

RawData ::= CHOICE {
opaque     OCTET STRING,
string     UTF8String,
structured MetaData
}

DataOrTransaction ::= CHOICE {
data      RawData,
artifact  Artifact,
reference IA5String
    }

ArchiveData ::= SEQUENCE OF element SEQUENCE{
    dataReference  DataOrTransaction ,
    metaData       MetaData OPTIONAL ,
    messageImprint [0] MessageDigest OPTIONAL
} 


SerialNumber ::= INTEGER

LtapTime ::= GeneralizedTime 

Version ::= ENUMERATED {
    v0,
    v1
}

EntityIdentifier ::= GeneralNames

ServiceType ::= CHOICE {
   core ENUMERATED {
      archive,
      delete,
      export,
      status,
      verify,
      listids
   },
   ltapextendedservice OBJECT IDENTIFIER
}

StatusInformation ::= ENUMERATED {
    granted,
    grantedWithMods,
    rejection,
    waiting,
    more
}


RequestInformation ::= SEQUENCE {
    version           Version DEFAULT v1,
    servicePolicyInfo PolicyInformation,
    serviceType       ServiceType,
 
    requestorID       EntityIdentifier,
    serviceID         EntityIdentifier,
    returnID          EntityIdentifier OPTIONAL, 
    serial            SerialNumber OPTIONAL,
    nonce             Nonce OPTIONAL,  
    requestTime       LtapTime OPTIONAL,
    startTime         [0] LtapTime OPTIONAL, 
    nextTime          [1] LtapTime OPTIONAL,
    bindingInfo       [2] MetaData OPTIONAL
}

Request ::= SEQUENCE {
   information           RequestInformation,
   data                  ArchiveData OPTIONAL,
   transactionIdentifier IA5String OPTIONAL
}


StatusNotice ::= SEQUENCE {
    status           StatusInformation,
    errorInformation UTF8String (SIZE(0..8192)),
    lastValid        LtapTime OPTIONAL,
    transactionIdentifier IA5String OPTIONAL
}

OperationResponse ::= SEQUENCE {
    information RequestInformation,
    status             StatusNotice,
    data               ArchiveData
}

Response ::= CHOICE {
    operationResponse OperationResponse,
    errorNotice   [0] StatusNotice
}

id-ltans-ct OBJECT IDENTIFIER ::= { 
      iso(1) identified-organization(3) 
      dod(6) internet(1) security(5) mechanisms(5) 
      ltans(11) 1 }

id-ct-LTAPRequest  OBJECT IDENTIFIER ::= 
         { id-ltans-ct 4 }
id-ct-LTAPResponse  OBJECT IDENTIFIER ::= 
         { id-ltans-ct 5 }


ltap-Request  PKCS7-CONTENT-TYPE ::= {Request
     IDENTIFIED BY  id-ct-LTAPRequest }
ltap-Response PKCS7-CONTENT-TYPE ::= {Response
     IDENTIFIED BY  id-ct-LTAPResponse }

LTAPRequest ::= ContentInfo
LTAPResponse ::= ContentInfo

END
]]></artwork><!-- COLLECT END END-->
   </figure>
  </section>
  <section title="XML schema for LTAP">

   <figure>
<!-- COLLECT INCLUDE XSD --><artwork><![CDATA[
<schema xmlns="http://www.w3.org/2001/XMLSchema" 
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
  xmlns:enc="http://www.w3.org/2001/04/xmlenc#" 
  targetNamespace="http://www.setcce.org/schemas/ltap" 
  elementFormDefault="qualified" 
  attributeFormDefault="unqualified"> 
<annotation><documentation xml:lang="en">
   XML Schema for LTAP
</documentation></annotation>


<xsd:complexType name="Name">
 <xsd:choice>
   <xsd:element name="rdnSequence" type="RDNSequence"/>
 </xsd:choice>
</xsd:complexType>

<xsd:complexType name="RDNSequence">
 <xsd:sequence minOccurs="0" maxOccurs="unbounded">
  <xsd:element name="RelativeDistinguishedName" 
               type="RelativeDistinguishedName"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="RelativeDistinguishedName">
 <xsd:sequence minOccurs="0" maxOccurs="unbounded">
  <xsd:element name="AttributeTypeAndDistinguishedValue" 
               type="AttributeTypeAndDistinguishedValue"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="AttributeTypeAndDistinguishedValue">
 <xsd:sequence>
  <xsd:element name="type">
   <xsd:simpleType>
    <xsd:restriction base="OBJECT_IDENTIFIER"/>
   </xsd:simpleType>
  </xsd:element>
  <xsd:element name="value">
   <xsd:complexType mixed="true">
    <xsd:choice>
     <xsd:any processContents="lax"/>
    </xsd:choice>
   </xsd:complexType>
  </xsd:element>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="PolicyInformation">
 <xsd:sequence>
  <xsd:element name="policyIdentifier" 
               type="CertPolicyId"/>
  <xsd:element name="policyQualifiers" minOccurs="0">
   <xsd:complexType>
    <xsd:sequence minOccurs="0" maxOccurs="unbounded">
     <xsd:element name="PolicyQualifierInfo" 
                  type="PolicyQualifierInfo"/>
    </xsd:sequence>
   </xsd:complexType>
  </xsd:element>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="PolicyQualifierInfo">
 <xsd:sequence>
  <xsd:element name="policyQualifierId">
   <xsd:simpleType>
    <xsd:restriction base="OBJECT_IDENTIFIER"/>
   </xsd:simpleType>
  </xsd:element>
  <xsd:element name="qualifier" minOccurs="0">
   <xsd:complexType mixed="true">
    <xsd:choice>
     <xsd:any processContents="lax"/>
    </xsd:choice>
   </xsd:complexType>
  </xsd:element>
 </xsd:sequence>
</xsd:complexType>

<xsd:simpleType name="CertPolicyId">
 <xsd:restriction base="OBJECT_IDENTIFIER"/>
</xsd:simpleType>


   <xsd:simpleType name="Artifact">
 <xsd:restriction base="PrintableString"/>
    </xsd:simpleType>

<xsd:complexType name="MessageDigest">
 <xsd:sequence>
  <xsd:element name="digestAlgorithm" 
               type="DigestMethodType"/>
  <xsd:element name="digestValue" 
               type="DigestValueType"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:simpleType name="DigestValueType">
 <xsd:restriction base="OCTET_STRING"/>
</xsd:simpleType>

<xsd:simpleType name="DigestMethodType">
 <xsd:restriction base="OBJECT_IDENTIFIER"/>
</xsd:simpleType>

<xsd:complexType name="MetaData">
 <xsd:sequence minOccurs="0"
               maxOccurs="unbounded">
  <xsd:element name="MetaItem" 
               type="MetaItem"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="MetaItem">
 <xsd:sequence>
  <xsd:element name="type">
   <xsd:complexType>
    <xsd:choice>
     <xsd:element name="oid" 
                  type="OBJECT_IDENTIFIER"/>
     <xsd:element name="attribute" 
                  type="UTF8String"/>
     <xsd:element name="uri" 
                  type="IA5String"/>
    </xsd:choice>
   </xsd:complexType>
  </xsd:element>
  <xsd:element name="values">
   <xsd:complexType>
    <xsd:sequence minOccurs="0" 
                  maxOccurs="unbounded">
     <xsd:choice>
      <xsd:element name="oidValue" 
                   type="OBJECT_IDENTIFIER"/>
      <xsd:element name="stringValue" 
                   type="UTF8String"/>
      <xsd:element name="uriValue" 
                   type="IA5String"/>
      <xsd:element name="integerValue" 
                   type="INTEGER"/>
      <xsd:element name="opaqueValue" 
                   type="OCTET_STRING"/>
      <xsd:element name="composedValue" 
                   type="MetaItem"/>
     </xsd:choice>
    </xsd:sequence>
   </xsd:complexType>
  </xsd:element>
 </xsd:sequence>
</xsd:complexType>

<xsd:simpleType name="Nonce">
 <xsd:restriction base="OCTET_STRING"/>
</xsd:simpleType>

<xsd:complexType name="RawData">
 <xsd:choice>
  <xsd:element name="opaque" type="OCTET_STRING"/>
  <xsd:element name="string" type="UTF8String"/>
  <xsd:element name="structured" type="MetaData"/>
  </xsd:choice>
</xsd:complexType>

<xsd:complexType name="DataOrTransaction">
 <xsd:choice>
  <xsd:element name="data" type="RawData"/>
  <xsd:element name="artifact" type="Artifact"/>
  <xsd:element name="reference" type="IA5String"/>
 </xsd:choice>
</xsd:complexType>

<xsd:complexType name="ArchiveData">
 <xsd:sequence minOccurs="0" maxOccurs="unbounded">
  <xsd:element name="element">
   <xsd:complexType>
    <xsd:sequence>
     <xsd:element name="dataReference" 
                  type="DataOrTransaction"/>
     <xsd:element name="metaData" 
                  type="MetaData" minOccurs="0"/>
     <xsd:element name="messageImprint" 
                  type="MessageDigest" minOccurs="0"/>
    </xsd:sequence>
   </xsd:complexType>
  </xsd:element>
 </xsd:sequence>
</xsd:complexType>

<xsd:simpleType name="SerialNumber">
 <xsd:restriction base="INTEGER"/>
</xsd:simpleType>

<xsd:simpleType name="LtapTime">
 <xsd:restriction base="GeneralizedTime"/>
</xsd:simpleType>

<xsd:complexType name="Version">
 <xsd:choice>
  <xsd:element name="v0" type="NULL"/>
  <xsd:element name="v1" type="NULL"/>
 </xsd:choice>
</xsd:complexType>

<xsd:complexType name="EntityIdentifier">
 <xsd:sequence minOccurs="0" maxOccurs="unbounded">
  <xsd:choice>
   <xsd:element name="rfc822Name" type="IA5String"/>
   <xsd:element name="dNSName" type="IA5String"/>
   <xsd:element name="directoryName" type="Name"/>
   <xsd:element name="uniformResourceIdentifier" 
                type="IA5String"/>
   <xsd:element name="iPAddress" type="OCTET_STRING"/>
   <xsd:element name="registeredID" 
                type="OBJECT_IDENTIFIER"/>
   </xsd:choice>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="ServiceType">
 <xsd:choice>
  <xsd:element name="core">
   <xsd:complexType>
    <xsd:choice>
     <xsd:element name="archive" type="NULL"/>
     <xsd:element name="delete" type="NULL"/>
     <xsd:element name="export" type="NULL"/>
     <xsd:element name="status" type="NULL"/>
     <xsd:element name="verify" type="NULL"/>
     <xsd:element name="listids" type="NULL"/>
    </xsd:choice>
   </xsd:complexType>
  </xsd:element>
  <xsd:element name="ltapextendedservice" 
               type="OBJECT_IDENTIFIER"/>
 </xsd:choice>
</xsd:complexType>

<xsd:complexType name="StatusInformation">
 <xsd:choice>
  <xsd:element name="granted" type="NULL"/>
  <xsd:element name="grantedWithMods" type="NULL"/>
  <xsd:element name="rejection" type="NULL"/>
  <xsd:element name="waiting" type="NULL"/>
  <xsd:element name="more" type="NULL"/>
 </xsd:choice>
</xsd:complexType>

<xsd:complexType name="RequestInformation">
 <xsd:sequence>
  <xsd:element name="version" 
               type="Version" minOccurs="0"/>
  <xsd:element name="servicePolicyInfo" 
               type="PolicyInformation"/>
  <xsd:element name="serviceType" 
               type="ServiceType"/>
  <xsd:element name="requestorID" 
               type="EntityIdentifier"/>
  <xsd:element name="serviceID" 
               type="EntityIdentifier"/>
  <xsd:element name="returnID" 
               type="EntityIdentifier" minOccurs="0"/>
  <xsd:element name="serial" 
               type="SerialNumber" minOccurs="0"/>
  <xsd:element name="nonce" 
               type="Nonce" minOccurs="0"/>
  <xsd:element name="requestTime" 
               type="LtapTime" minOccurs="0"/>
  <xsd:element name="startTime" 
               type="LtapTime" minOccurs="0"/>
  <xsd:element name="nextTime" 
               type="LtapTime" minOccurs="0"/>
  <xsd:element name="bindingInfo" 
               type="MetaData" minOccurs="0"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="Request">
 <xsd:sequence>
  <xsd:element name="information" 
               type="RequestInformation"/>
  <xsd:element name="data" 
               type="ArchiveData" minOccurs="0"/>
  <xsd:element name="transactionIdentifier" 
               type="IA5String" minOccurs="0"/>
 </xsd:sequence>
</xsd:complexType>


<xsd:complexType name="StatusNotice">
 <xsd:sequence>
  <xsd:element name="status" 
               type="StatusInformation"/>
  <xsd:element name="errorInformation">
   <xsd:complexType mixed="true">
    <xsd:complexContent mixed="true">
     <xsd:extension base="UTF8String"/>
    </xsd:complexContent>
   </xsd:complexType>
  </xsd:element>
  <xsd:element name="lastValid" 
               type="LtapTime" minOccurs="0"/>
  <xsd:element name="transactionIdentifier" 
               type="IA5String" minOccurs="0"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="OperationResponse">
 <xsd:sequence>
  <xsd:element name="information" 
               type="RequestInformation"/>
  <xsd:element name="status" type="StatusNotice"/>
  <xsd:element name="data" type="ArchiveData"/>
 </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="Response">
 <xsd:choice>
  <xsd:element name="operationResponse" 
               type="OperationResponse"/>
  <xsd:element name="errorNotice" 
               type="StatusNotice"/>
 </xsd:choice>
</xsd:complexType>

<xsd:element name="Request" type="Request"/>
<xsd:element name="Response" type="Response"/>
<xsd:element name="LTAPRequest" type="LTAPRequest"/>
<xsd:element name="LTAPResponse" type="LTAPResponse"/>

<xsd:complexType name="LTAPResponse">
 <xsd:choice>
  <xsd:element name="response" type="Response"/>
  <xsd:element name="signedResponse" type="ds:Signature"/>
  <xsd:element name="encryptedResponse" type="enc:EncryptedData"/>
 </xsd:choice>
</xsd:complexType>

<xsd:complexType name="LTAPRequest">
 <xsd:choice>
  <xsd:element name="request" type="Request"/>
   <xsd:element name="signedRequest" type="xd:Signature"/>
   <xsd:element name="encryptedRequest" type="enc:EncryptedData"/>
 </xsd:choice>
</xsd:complexType>

</schema>
]]></artwork><!-- COLLECT END </schema>-->
   </figure>
  </section>


  <section title="Additional XML definitions">
<t>A number of additional XML definitions are necessary. They correspond to universal  ASN.1 types.</t>
  </section>
   <figure>
<artwork><![CDATA[
   <xsd:simpleType name="INTEGER">
 <xsd:restriction base="xsd:integer"/>
    </xsd:simpleType>

    <xsd:complexType name="BOOLEAN">
 <xsd:choice>
     <xsd:element name="true" type="NULL"/>
     <xsd:element name="false" type="NULL"/>
 </xsd:choice>
    </xsd:complexType>

    <xsd:simpleType name="NULL">
 <xsd:restriction base="xsd:string">
     <xsd:length value="0"/>
 </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="IA5String" mixed="true">
 <xsd:sequence minOccurs="0" maxOccurs="unbounded">
     <xsd:choice>
  <xsd:element name="nul" type="NULL"/>
  <xsd:element name="soh" type="NULL"/>
  <xsd:element name="stx" type="NULL"/>
  <xsd:element name="etx" type="NULL"/>
  <xsd:element name="eot" type="NULL"/>
  <xsd:element name="enq" type="NULL"/>
  <xsd:element name="ack" type="NULL"/>
  <xsd:element name="bel" type="NULL"/>
  <xsd:element name="bs" type="NULL"/>
  <xsd:element name="vt" type="NULL"/>
  <xsd:element name="ff" type="NULL"/>
  <xsd:element name="so" type="NULL"/>
  <xsd:element name="si" type="NULL"/>
  <xsd:element name="dle" type="NULL"/>
  <xsd:element name="dc1" type="NULL"/>
  <xsd:element name="dc2" type="NULL"/>
  <xsd:element name="dc3" type="NULL"/>
  <xsd:element name="dc4" type="NULL"/>
  <xsd:element name="nak" type="NULL"/>
  <xsd:element name="syn" type="NULL"/>
  <xsd:element name="etb" type="NULL"/>
  <xsd:element name="can" type="NULL"/>
  <xsd:element name="em" type="NULL"/>
  <xsd:element name="sub" type="NULL"/>
  <xsd:element name="esc" type="NULL"/>
  <xsd:element name="is4" type="NULL"/>
  <xsd:element name="is3" type="NULL"/>
  <xsd:element name="is2" type="NULL"/>
  <xsd:element name="is1" type="NULL"/>
     </xsd:choice>
 </xsd:sequence>
    </xsd:complexType>

    <xsd:simpleType name="OCTET_STRING">
 <xsd:restriction base="xsd:string">
     <xsd:whiteSpace value="collapse"/>
     <xsd:pattern value="( *([0-9]|[A-F]|[a-f]) *)*"/>
 </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="OBJECT_IDENTIFIER">
 <xsd:restriction base="xsd:string">
     <xsd:pattern value="( *([a-z]|[0-9]|\{|\}|\.)* *)"/>
 </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="UTF8String" mixed="true">
 <xsd:sequence minOccurs="0" maxOccurs="unbounded">
     <xsd:choice>
  <xsd:element name="nul" type="NULL"/>
  <xsd:element name="soh" type="NULL"/>
  <xsd:element name="stx" type="NULL"/>
  <xsd:element name="etx" type="NULL"/>
  <xsd:element name="eot" type="NULL"/>
  <xsd:element name="enq" type="NULL"/>
  <xsd:element name="ack" type="NULL"/>
  <xsd:element name="bel" type="NULL"/>
  <xsd:element name="bs" type="NULL"/>
  <xsd:element name="vt" type="NULL"/>
  <xsd:element name="ff" type="NULL"/>
  <xsd:element name="so" type="NULL"/>
  <xsd:element name="si" type="NULL"/>
  <xsd:element name="dle" type="NULL"/>
  <xsd:element name="dc1" type="NULL"/>
  <xsd:element name="dc2" type="NULL"/>
  <xsd:element name="dc3" type="NULL"/>
  <xsd:element name="dc4" type="NULL"/>
  <xsd:element name="nak" type="NULL"/>
  <xsd:element name="syn" type="NULL"/>
  <xsd:element name="etb" type="NULL"/>
  <xsd:element name="can" type="NULL"/>
  <xsd:element name="em" type="NULL"/>
  <xsd:element name="sub" type="NULL"/>
  <xsd:element name="esc" type="NULL"/>
  <xsd:element name="is4" type="NULL"/>
  <xsd:element name="is3" type="NULL"/>
  <xsd:element name="is2" type="NULL"/>
  <xsd:element name="is1" type="NULL"/>
     </xsd:choice>
 </xsd:sequence>
    </xsd:complexType>

    <xsd:simpleType name="PrintableString">
 <xsd:restriction base="xsd:string">
     <xsd:pattern value="[ &apos;\(\)\+-:=\?A-Za-z]*"/>
 </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="GeneralizedTime">
 <xsd:restriction base="xsd:string">
     <xsd:whiteSpace value="collapse"/>
     <xsd:pattern 
 value="( *([0-9]{8}([0-9]{2})?([0-9]{2})?([0-9]{2})?
       (\.[0-9]+)?((Z)|([\+\-][0-9]{4}))?) *)"/>
 </xsd:restriction>
    </xsd:simpleType>
]]></artwork>
</figure>

 </back>
</rfc>
