


ABFAB                                                         J. Howlett
Internet-Draft                                                 JANET(UK)
Intended status: Informational                               S. Hartmann
Expires: June 24, 2011                                 Painless Security
                                                           H. Tschofenig
                                                  Nokia Siemens Networks
                                                                 E. Lear
                                                      Cisco Systems GmbH
                                                       December 21, 2010


      Application Bridging for Federated Access Beyond Web (ABFAB)
                              Architecture
                      draft-lear-abfab-arch-01.txt

Abstract

   Over the last decade a substantial amount of work has occurred in the
   space of federated authentication and authorization.  Most of this
   effort has focused on two common use cases: network and web-based
   access, with few common building blocks within the architecture.
   This memo describes an architecture that makes use of extensions to
   the commonly used mechanisms for both federated and non-federated
   authentication and authorization, including Radius/Diameter, GSS/GS2,
   and SAML, to primarily address non-web based authentication, in a
   that will scale to large numbers of federations.

Status of this Memo

   This Internet-Draft is submitted to IETF in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.




Howlett, et al.           Expires June 24, 2011                 [Page 1]

Internet-Draft             ABFAB Architecture              December 2010


   This Internet-Draft will expire on June 24, 2011.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the BSD License.



































Howlett, et al.           Expires June 24, 2011                 [Page 2]

Internet-Draft             ABFAB Architecture              December 2010


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Federation Description . . . . . . . . . . . . . . . . . .  3
     1.2.  Design Goals . . . . . . . . . . . . . . . . . . . . . . .  7
     1.3.  Use of Radius  . . . . . . . . . . . . . . . . . . . . . .  8
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  9
   3.  Architecture . . . . . . . . . . . . . . . . . . . . . . . . . 10
     3.1.  Federation Substrate . . . . . . . . . . . . . . . . . . . 10
     3.2.  Subject To Identity Provider . . . . . . . . . . . . . . . 12
     3.3.  Application to Service . . . . . . . . . . . . . . . . . . 13
     3.4.  Personalization Layer  . . . . . . . . . . . . . . . . . . 14
     3.5.  Tieing Layers Together . . . . . . . . . . . . . . . . . . 14
   4.  Application Security Services  . . . . . . . . . . . . . . . . 16
     4.1.  Server (Mutual) Authentication . . . . . . . . . . . . . . 16
     4.2.  GSS-API Channel Binding  . . . . . . . . . . . . . . . . . 17
     4.3.  Host-Based Service Names . . . . . . . . . . . . . . . . . 18
     4.4.  Per-Message Tokens . . . . . . . . . . . . . . . . . . . . 19
   5.  Privacy Considerations . . . . . . . . . . . . . . . . . . . . 20
   6.  Deployment Considerations  . . . . . . . . . . . . . . . . . . 21
     6.1.  EAP Channel Binding  . . . . . . . . . . . . . . . . . . . 21
     6.2.  AAA Proxy Behavior . . . . . . . . . . . . . . . . . . . . 21
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 22
   8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 23
   9.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 24
   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 25
     10.1. Normative References . . . . . . . . . . . . . . . . . . . 25
     10.2. Informative References . . . . . . . . . . . . . . . . . . 25
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 28






















Howlett, et al.           Expires June 24, 2011                 [Page 3]

Internet-Draft             ABFAB Architecture              December 2010


1.  Introduction

   XXX This document is a first draft.  Comments and contributions are
   requested.

   The Internet makes uses of numerous authentication methods to grant
   access to various resources.  These mechanisms have been generalized
   and scaled over the last decade through mechanisms such as GS2,
   Security Assertion Markup Language (SAML) [OASIS.saml-core-2.0-os],
   Radius, and Diameter.  So-called "federated" access has evolved over
   the last decade between web servers through such standards as SAML,
   OpenID, and OAUTH, allowing entire domains of individuals to be
   authorized for resources.  The key scaling points that have been
   addressed are the following:

   o  An Internet service need not copy manually authentication
      information from a domain to allow for authentication and
      authorization.

   o  Individual users are able to make use of a single credential to
      authenticate to such services.

   As the number of such federated services has proliferated, however,
   the role of the individual has become ambiguous in certain
   circumstances.  For example, a school might provide online access to
   grades to a parent who is also a teacher.  She must clearly
   distinguish her role upon access.  After all, she is probably not
   allowed to edit her own child's grades.

   Similarly, as the number of federations proliferates, it becomes
   increasingly difficult to discover which identity provider a user is
   associated with.  This is true for both the web and non-web case, but
   particularly acute for the latter ans many non-web authentication
   systems are not semantically rich enough on their own to allow for
   such ambiguities.  For instance, in the case of an email provider,
   the use of SMTP and IMAP protocols does not on its own provide for a
   way to select a federation.  However, the building blocks do exist to
   add this functionality.

1.1.  Federation Description

   The typical setup for a three party protocol involves the following
   entities:

   o  the End Host,

   o  the Identity Provider, and




Howlett, et al.           Expires June 24, 2011                 [Page 4]

Internet-Draft             ABFAB Architecture              December 2010


   o  the Relying Party.

   These entities are illustrated graphically in Figure 1.


                          -----
                        /-     -\
                      //         \\
                      /           \
                     |             |
    ,----------\    |               |   ,---------\
    | Identity |    |               |   | Relying |
    | Provider +----+   Federation  +---+ Party   |
    `----------'    |               |   '---------'
             <      |               |        >
              \      |             |        /
               \      \           /        /
                \     \\         //       /
                \       \-     -/        /
                 \        -----         /
                  \                    /
                   \  +------------+  /
                    \ |            | /
                     v|  End Host  |v
                      |            |
                      +------------+

              Figure 1: Three Party Authentication Framework

   Figure 1 also shows the logical entity 'Federation'.  In a
   federation, policy is agreed upon by some form of administrative
   management, and then instantiated through an operational framework
   that the members use, and where compliance is measured in some
   fashion.  Some deployments may be required to deploy message routing
   intermediaries, such as application layer relays or proxies, to offer
   the required technical functionality while in other deployments those
   are missing.

   Often a real world entity is associated with the end host and
   responsible for interacting with the identity provider, even if it is
   only as weak as completing a web form and confirming the verification
   email.  The outcome of this initial registration step is that
   credentials are made available to the identity provider and to the
   end host.  It is important to highlight that in some scenarios there
   might indeed be a human behind the device denoted as end host and in
   other cases there is no human involved in the actual protocol
   execution.




Howlett, et al.           Expires June 24, 2011                 [Page 5]

Internet-Draft             ABFAB Architecture              December 2010


   To support the more generic deployment case, we assume that the
   identity provider and the relying party belong to different
   administrative domains.  The nature of federation dictates that there
   is some form of relationship between the identity provider and the
   relying party.  This is particularly important when the relying party
   wants to use information obtained from the identity provider for
   authorization decisions and when the identity provider does not want
   to release information to every relying party (or only under certain
   conditions).  While it is possible to have a bilateral agreement
   between every identity provider and every relying party; on an
   Internet scale this setup requires the introduction of a federation
   concept, as the management of such pair-wise relationships would
   otherwise prove burdensome.  While many of the non-technical aspects
   of such a federation, such as business practices and operational
   arrangements, are outside the scope of the IETF they still impact the
   architecture setup on how to ensure the dynamic establishment of
   trust.

   The steps taken generally in an ABFAB federated authentication/
   authorization exchange are as follows (XXX not complete):

   1.   Principal provides NAI to Application: Somehow the client is
        configured with at least the realm portion of an NAI, which
        represents the IdP to be discovered.

   2.   Authentication mechanism selection: this is the step necessary
        to indicate that the GSS-EAP SASL/GS2 mechanism will be used for
        authentication/authorization.

   3.   Client Application provides NAI to RP: At the conclusion of
        mechanism selection the NAI must be provided to the RP for
        discovery.

   4.   Discovery of federated IdP: This is discussed in detail below.
        Either the RP is configured with authorized IdPs, or it makes
        use of a federation proxy.

   5.   Request from Relying Party to IdP: Once the RP knows who the IdP
        is, it or its agent will forward RADIUS request that
        encapsulates a GSS/EAP access request to an IdP.  This may or
        may not contain a SAML request as a series of attributes..  At
        this stage, the RP will likely have no idea who the principal
        is.  The RP claims its identity to the IdP in AAA attributes.

   6.   IdP informs the principal of which EAP method to use: The
        available and appropriate methods are discussed below in this
        memo.




Howlett, et al.           Expires June 24, 2011                 [Page 6]

Internet-Draft             ABFAB Architecture              December 2010


   7.   A bunch of EAP messages happen between the endpoints: Messages
        are exchanged between the principal and the IdP until a result
        is determined.  The number and content of those messages will
        depend on the EAP method.  If the IdP is unable to authenticate
        the principal, the process concludes here.  As part of this
        process, the principal will, under protection of EAP, assert the
        identity of the RP to which it intends to authenticate.

   8.   Successful Authentication: At the very least the EAP server /
        IdP has authenticated the principal, and the principal has
        authenticated the IdP.  As a result of this step, the principal
        and the EAP server hold two cryptographic keys- a Master Session
        Key (MSK), and an Extended MSK (EMSK).  If the asserted identity
        of the RP by the principal matches the identity the RP itself
        asserted, there is some confidence that the RP is now
        authenticated to the IdP.

   9.   Local IdP Policy Check: At this stage, the IdP checks local
        policy to determine whether the RP and principal are authorized
        for the assertion to be made.  Additional policy checks will
        likely have been made earlier just through the process of
        discovery (see later discussion).

   10.  Response from the IdP to the Relying Party: Once the IdP has
        made a determination of whether and how to authenticate or
        authorize the principal to the RP, it returns either a negative
        answer to the RP, or it returns the identity of the principal to
        the RP, as well as an optional set of attributes associated with
        the principal.  XXX XXX XXX this needs work!!!

   11.  Return results to principal: Once the RP has a response it must
        inform the client application of the result.  If all has gone
        well, all are authenticated, and the application proceeds with
        appropriate authorization levels.

   An example communication flow is given below:















Howlett, et al.           Expires June 24, 2011                 [Page 7]

Internet-Draft             ABFAB Architecture              December 2010


       Relying Party    Client App       IdP

          |              (1)             | Client App gets NAI (somehow)
          |               |              |
          |<-----(2)----->|              | Mechanism Selection
          |               |              |
          |<-----(3)-----<|              | NAI transmitted to RP
          |               |              |
          |<=====(4)====================>| Discovery
          |               |              |
          |>=====(5)====================>| Access request from RP to IdP
          |               |              |
          |               |< - - (6) - -<| EAP method to Principal
          |               |              |
          |               |< - - (7) - ->| EAP Exchange to authenticate
          |               |              | Principal
          |               |              |
          |               |           (8 & 9) Local Policy Check
          |               |              |
          |<====(10)====================<| IdP Assertion to RP
          |               |              |
          |>----(11)----->|              | Results to client app.



        ----- = Between Client App and RP
        ===== = Between RP and IdP
        - - - = Between Client App and IdP




1.2.  Design Goals

   Our key design goals are as follows:

   o  Each party of a transaction will be authenticated, and the
      principal will be authorized for access to a specific resource .

   o  Means of authentication is decoupled so as to allow for multiple
      authentication methods.

   o  Hence, the architecture requires no sharing of long term private
      keys.

   o  The system will scale to large numbers of identity providers,
      relying parties, and users.




Howlett, et al.           Expires June 24, 2011                 [Page 8]

Internet-Draft             ABFAB Architecture              December 2010


   o  The system will be designed primarily for non-Web-based
      authentication.

   o  The system will build upon existing standards, components, and
      operational practices.

   Designing new three party authentication and authorization protocols
   is hard and frought with risk of cryptographic flaws.  Achieving
   widespead deployment is even more difficult.  A lot of attention on
   federated access has been devoted to the Web. This document instead
   focuses on a non-Web-based environment and focuses on those protocols
   where HTTP is not used.  Despite the increased excitement for
   layering every protocol on top of HTTP there are still a number of
   protocols available that do not use HTTP-based transports.  Many of
   these protocols are lacking a native authentication and authorization
   framework of the style shown in Figure 1.

1.3.  Use of Radius

   Interestingly, for network access authentication the usage of the AAA
   framework with RADIUS [RFC2865] and Diameter [RFC3588] was quite
   successful from a deployment point of view.  To map the terminology
   used in Figure 1 to the AAA framework the identity provider
   corresponds to the AAA server, the relying party corresponds to the
   AAA client, and the technical building blocks of a federation are AAA
   proxies, relays and redirect agents (particularly if they are
   operated by third parties, such as AAA brokers and clearing houses).
   The front-end, i.e. the end host to AAA client communication, is in
   case of network access authentication offered by link layer protocols
   that forward authentication protocol exchanges back-and-forth.  An
   example of a large scale Radius-based federation is EDUROAM [1].

   Is it possible to design a system that builds on top of successful
   protocols to offer non-Web-based protocols with a solid starting
   point for authentication and authorization in a distributed system?
















Howlett, et al.           Expires June 24, 2011                 [Page 9]

Internet-Draft             ABFAB Architecture              December 2010


2.  Terminology

   This document uses identity management and privacy terminology from
   [I-D.hansen-privacy-terminology].















































Howlett, et al.           Expires June 24, 2011                [Page 10]

Internet-Draft             ABFAB Architecture              December 2010


3.  Architecture

   Section 1 already introduced the federated access architecture, with
   the illustration of the different actors that need to interact, but
   it did not expand on the specifics of providing support for non-Web
   based applications.  This section details this aspect and motivates
   design decisions.  The main theme of the work described in this
   document is focused on re-using existing building blocks that have
   been deployed already and to re-arrange them in a novel way.

   Although this architecture assumes updates to both the relying party
   as well as to the end host for application integration, those changes
   are kept at a minimum.  A mechanism that can demonstrate deployment
   benefits (based on ease of update of existing software, low
   implementation effort, etc.)is preferred and there may be a need to
   specify multiple mechanisms to support the range of different
   deployment scenarios.

   There are a number of ways for encapsulating EAP into an application
   protocol.  For ease of integration with a wide range of non-Web based
   application protocols the usage of the GSS-API was chosen.
   Encapsulating EAP into the GSS-API also allows EAP to be used in
   SASL.  A description of the technical specification can be found in
   [I-D.ietf-abfab-gss-eap].  Other alternatives exist as well and may
   be considered later, such as "TLS using EAP Authentication"
   [I-D.nir-tls-eap].

   There are several architectural layers in the system; this section
   discusses the individual layers.

3.1.  Federation Substrate

   The federation substrate is responsible for the connunication between
   the relying party and the identity provider.  This layer is
   responsible for the inter-domain communication and for the technical
   mechanisms necessary to establish inter-domain trust.

   A key design goal is the re-use of an existing infrastructure, we
   build upon the AAA framework as utilized by RADIUS [RFC2138] and
   Diameter [RFC3588].  Since this document does not aim to re-describe
   the AAA framework the interested reader is referred to [RFC2904].
   Building on the AAA infrastructure, and RADIUS and Diameter as
   protocols, modifications to that infrastructure is to be avoided.
   Also, modifications to AAA servers should be kept at a minimum.

   One demand that the AAA substrate must make of the upper layers is
   that they must properly identify the end points of the communication.
   That is- it must be possible for the AAA server at the RP to



Howlett, et al.           Expires June 24, 2011                [Page 11]

Internet-Draft             ABFAB Architecture              December 2010


   determine where to send each radius or diameter message.  Otherwise,
   it is the RP's responsibility to determine the identity of the
   principal on its own, without the assistance of an IdP.  This
   architecture makes use of the Network Access Identifier (NAI), where
   the IdP is indicated in the realm component [RFC4282].  The NAI is
   represented and consumed by the GSS-API layer as GSS_C_NT_USER_NAME
   as specified in [RFC2743].  XXX Where is EAP here?

   Once an IdP has been determined by the RP, it or its proxy agent must
   determine whether or not the IdP itself is authorized to make
   assertions, as it will likely not blindly accept any old provider.
   Federations serve this purpose.  This architecture provides for three
   approaches to resolve whether an IdP is authorized:

   Static Configuration:   In this case, the federation provides the RP
      or its proxy agent with a static list of IdPs that it may trust.

   Federation Dynamic Referral  In this case, the federation provides a
      proxy of its own that will in some way authorize the IdP to the
      RP, and visa versa, as not all RPs may be authorized to use all
      IdPs for all purposes within a federation.  N.B., because the
      identity of the principal is likely unknown at this point, it will
      not be possible for a federation to authorize an IdP to an RP
      based on the identity of the principal.

   Federation Proxy:   In this case, the authentication request is
      forwarded to a federation proxy, who then further forwards the
      request to the IdP.

   In the first two cases, it is expected that RPs will be configured to
   consult multiple federations, as a matter of practice.  The first
   successful query is sufficient for the RP to then contact the IdP's
   AAA server.

   The astute reader will notice that RADIUS and Diameter have
   substantially similar characteristics.  Why not pick one?  A key
   difference is that today RADIUS is largely transported upon UDP, and
   its use is largely, though not exclusively, intra-domain.  Diameter
   itself was designed to scale to broader uses.  We leave as a
   deployment decision, which protocol will be appropriate.

   Through the integrity protection mechanisms in the AAA framework, the
   relying party can establish technical trust that messages are being
   sent by the appropriate relying party.  Any given interaction will be
   associated with one federation at the policy level.  The legal or
   business relationship defines what statements the identity provider
   is trusted to make and how these statements are interpreted by the
   relying party.  The AAA framework also permits the relying party or



Howlett, et al.           Expires June 24, 2011                [Page 12]

Internet-Draft             ABFAB Architecture              December 2010


   elements between the relying party and identity provider to make
   statements about the relying party.

   The AAA framework provides transport for attributes.  Statements made
   about the subject by the identity provider, statements made about the
   relying party and other information is transported as attributes.

3.2.  Subject To Identity Provider

   Traditional web federation does not describe how a subject
   communicates with an identity provider.  As a result, this
   communication is not standardized.  There are several disadvantages
   to this approach.  It is difficult to have subjects that are machines
   rather than humans that use some sort of programatic credential.  In
   addition, use of browsers for authentication restricts the deployment
   of more secure forms of authentication beyond plaintext username and
   password known by the server.  In a number of cases the
   authentication interface may be presented before the subject has
   adequately validated they are talking to the intended server.  By
   giving control of the authentication interface to a potential
   attacker, then the security of the system may be reduced and phishing
   opportunities introduced.

   As a result, it is desirable to choose some standardized approach for
   communication between the subject's end-host and the identity
   provider.  There are a number of requirements this approach must
   meet.

   Experience has taught us one key security and scalability
   requirement: it is important that the relying party not get in
   possession of the long-term secret of the entity being authenticated
   by the AAA server.  Aside from a valuable secret being exposed, a
   synchronization problem can also often develop.  Since there is no
   single authentication mechanism that will be used everywhere there is
   another associated requirement: The authentication framework must
   allow for the flexible integration of authentication mechanisms.  For
   instance, some identity providers may require hardware tokens while
   others may use passwords.  A service provider would want to support
   both sorts of federations, and others.

   Fortunately, these requirements can be met by utilizing standardized
   and successfully deployed technology, namely by the Extensible
   Authentication Protocol (EAP) framework [RFC3748].  Figure 2
   illustrates the integration graphically.

   EAP is an end-to-end framework; it provides for two-way communication
   between a peer (i.e,service client or principal) through the
   authenticator (i.e., service provider) to the back-end (i.e.,



Howlett, et al.           Expires June 24, 2011                [Page 13]

Internet-Draft             ABFAB Architecture              December 2010


   identity provider).  Conveniently, this is precisely the
   communication path that is needed for federated identity.  Although
   EAP support is already integrated in AAA systems (see [RFC3579] and
   [RFC4072]) several challenges remain: one is to carry EAP payloads
   from the end host to the relying party.  Another is to verify
   statements the relying party has made to the subject, confirm these
   statements are consistent with statements made to the identity
   provider and confirm all the above are consistent with the federation
   and any federation-specific policy or configuration.  Another
   challenge is choosing which identity provider to use for which
   service.

3.3.  Application to Service

   One of the remaining layers is responsible for integration of
   federated authentication into the application.  There are a number of
   approaches that applications have adopted for security.  So, there
   may need to be multiple strategies for integration of federated
   authentication into applications.  However, we have started with a
   strategy that provides integration to a large number of application
   protocols.

   Many applications such as SSH [RFC4462], NFS [RFC2203], DNS [RFC3645]
   and several non-IETF applications support the Generic Security
   Services Application Programming Interface [RFC2743].  Many
   applications such as IMAP, SMTP, XMPP and LDAP support e Simple
   Authentication and Security Layer (SASL) [RFC4422] framework.  These
   two approaches work together nicely: by creating a GSS-API mechanism,
   SASL integration is also addressed [RFC5801].  In effect, using a
   GSS-API mechanism with SASL simply requires placing some headers on
   the front of the mechanism and constraining certain GSS-API options.

   GSS-API is specified in terms of an abstract set of operations which
   can be mapped into a programming language to form an API.  When
   people are first introduced to GSS-API, they focus on it as an API.
   However, from the prospective of authentication for non-web
   applications, GSS-API should be thought of as a protocol not an API.
   It consists of some abstract operations such as the initial context
   exchange, which includes two sub-operations (gss_init_sec_context and
   gss_accept_sec_context).  An application defines which abstract
   operations it is going to use and where messages produced by these
   operations fit into the application architecture.  A GSS-API
   mechanism will define what actual protocol messages result from that
   abstract message for a given abstract operation.  So, since this work
   is focusing on a particular GSS-API mechanism, we generally focus on
   protocol elements rather than the API view of GSS-API.

   The API view has significant value.  Since the abstract operations



Howlett, et al.           Expires June 24, 2011                [Page 14]

Internet-Draft             ABFAB Architecture              December 2010


   are well defined, the set of information that a mechanism gets from
   the application is well defined.  Also, the set of assumptions the
   application is permitted to make is generally well defined.  As a
   result, an application protocol that supports GSS-API or SASL is very
   likely to be usable with a new approach to authentication including
   this one with no required modifications.  In some cases, support for
   a new authentication mechanism has been added using plugin interfaces
   to applications without the application being modified at all.  Even
   when modifications are required, they can often be limited to
   supporting a new naming and authorization model.  For example, this
   work focuses on privacy; an application that assumes it will always
   obtain an identifier for the principal will need to be modified to
   support anonymity, unlinkability or pseudonymity.

   So, we use GSS-API and SASL because a number of the application
   protocols we wish to federate support these strategies for security
   integration.  What does this mean from a protocol standpoint and how
   does this relate to other layers?  This means we need to design a
   concrete GSS-API mechanism.  We have chosen to use a GSS-API
   mechanism that encapsulates EAP authentication.  So, GSS-API (and
   SASL) encapsulate EAP between the end-host and the service.  The AAA
   framework encapsulates EAP between the relying party and the identity
   provider.  The GSS-API mechanism includes rules about how principals
   and services are named as well as per-message security and other
   facilities required by the applications we wish to support.

3.4.  Personalization Layer

   The AAA framework provides a way to transport statements from the
   identity provider to the relying party.  However, we also need to say
   more about the content of these statements.  In simple cases,
   attributes particular to the AAA protocol can be defined.  However in
   more complicated situations it is strongly desirable to re-use an
   existing protocol for asking questions and receiving information
   about subjects.  SAML is used for this.

   SAML usage may be as simple as the identity provider including a SAML
   Response message in the AAA response.  Alternatively the relying
   party may generate a SAML request.

3.5.  Tieing Layers Together










Howlett, et al.           Expires June 24, 2011                [Page 15]

Internet-Draft             ABFAB Architecture              December 2010


                                    +--------------+
                                    |  AAA Server  |
                                    |  (Identity   |
                                    |  Provider)   |
                                    +-^----------^-+
                                      * EAP      | RADIUS/
                                      *          | Diameter
                                    --v----------v--
                                 ///                \\\
                               //                      \\   ***
                              |        Federation        |  back-
                              |                          |  end
                               \\                      //   ***
                                 \\\                ///
                                    --^----------^--
                                      * EAP      | RADIUS/
                    Application       *          | Diameter
   +-------------+  Data            +-v----------v--+
   |             |<---------------->|               |
   | Client      |  EAP/EAP Method  | Server Side   |
   | Application |<****************>| Application   |
   | @ End Host  |  GSS-API         |(Relying Party)|
   |             |<---------------->|               |
   |             |  Application     |               |
   |             |  Protocol        |               |
   |             |<================>|               |
   +-------------+                  +---------------+
                  *** front-end ***

   Legend:

    <****>: End-to-end exchange
    <---->: Hop-by-hop exchange
    <====>: Protocol through which GSS-API/GS2 exchanges are tunnelled

       Figure 2: Architecture for Federated Access of non-Web based
                               Applications














Howlett, et al.           Expires June 24, 2011                [Page 16]

Internet-Draft             ABFAB Architecture              December 2010


4.  Application Security Services

   One of the key goals is to integrate federated authentication into
   existing application protocols and where possible, existing
   implementations of these protocols.  Another goal is to perform this
   integration while meeting the best security practices of the
   technologies used to perform the integration.  This section describes
   security services and properties required by the EAP GSS-API
   mechanism in order to meet these goals.  This information could be
   viewed as specific to that mechanism.  However, other future
   application integration strategies are very likely to need similar
   services.  So, it is likely that these services will be expanded
   across application integration strategies if new application
   integration strategies are adopted.

4.1.  Server (Mutual) Authentication

   GSS-API provides an optional security service called mutual
   authentication.  This service means that in addition to the initiator
   providing (potentially anonymous or pseudonymous) identity to the
   acceptor, the acceptor confirms its identity to the initiator.
   Especially for the ABFAB context, this service is confusingly named.
   We still say that mutual authentication is provided when the identity
   of an acceptor is strongly authenticated to an anonymous initiator.

   RFC 2743 does not explicitly talk about what mutual authentication
   means.  Within the GSS-API community successful mutual authentication
   has come to mean:

   o  If a target name is supplied by the initiator, then the initiator
      trusts that the supplied target name describes the acceptor.  This
      implies both that appropriate cryptographic exchanges took place
      for the initiator to make such a trust decision, and that after
      evaluating the results of these exchanges, the initiator's policy
      trusts that the target name is accurate.

   o  The initiator trusts that its idea of the acceptor name correctly
      names the entity it is communicating with.

   o  Both the initiator and acceptor have the same key material for
      per-message keys and both parties have confirmed they actually
      have the key material.  In EAP terms, there is a protected
      indication of success.

   Mutual authentication is an important defense against certain aspects
   of phishing.  Intuitively, users would like to assume that if some
   party asks for their credentials as part of authentication,
   successfully gaining access to the resource means that they are



Howlett, et al.           Expires June 24, 2011                [Page 17]

Internet-Draft             ABFAB Architecture              December 2010


   talking to the expected party.  Without mutual authentication, the
   acceptor could "grant access" regardless of what credentials are
   supplied.  Mutual authentication better matches this user intuition.

   The GSS-EAP mechanism MUST implement mutual authentication.  That is,
   an initiator needs to be able to request mutual authentication.  When
   mutual authentication is requested, only EAP methods capabale of
   providing the necessary service can be used, and appropriate steps
   need to be taken to provide mutual authentication.  A broader set of
   EAP methods could be supported when a particular application does not
   request mutual authentication.  It is an open question whether the
   mechanism will permit this.

4.2.  GSS-API Channel Binding

   [RFC5056] defines a concept of channel binding to prevent man-in-the-
   middle attacks.  It is common to provide SASL and GSS-API with
   another layer to provide transport security; Transport Layer Security
   (TLS) is the most common such layer.  TLS provides its own server
   authentication.  However there are a variety of situations where this
   authentication is not checked for policy or usability reasons.  Even
   when it is checked, if the trust infrastructure behind the TLS
   authentication is different from the trust infrastructure behind the
   GSS-API mutual authentication.  If the endpoints of the GSS-API
   authentication are different than the endpoints of the lower layer,
   this is a strong indication of a problem such as a man-in-the-middle
   attack.  Channel binding provides a facility to determine whether
   these endpoints are the same.

   The GSS-EAP mechanism needs to support channel binding.  When an
   application provides channel binding data, the mechanism needs to
   confirm this is the same on both sides consistent with the GSS-API
   specification.  XXXThere is an open question here as to the details;
   today RFC 5554 governs.  We could use that and the current draft
   assumes we will.  However in Beijing we became aware of some changes
   to these details that would make life much better for GSS
   authentication of HTTP.  We should resolve this with kitten and
   replace this note with a reference to the spec we're actually
   following.

   Typically when considering channel binding, people think of channel
   binding in combination with mutual authentication.  This is
   sufficiently common that without additional qualification channel
   binding should be assumed to imply mutual authentication.  Without
   mutual authentication, only one party knows that the endpoints are
   correct.  That's sometimes useful.  Consider for example a user who
   wishes to access a protected resource from a shared whiteboard in a
   conference room.  The whiteboard is the initiator; it does not need



Howlett, et al.           Expires June 24, 2011                [Page 18]

Internet-Draft             ABFAB Architecture              December 2010


   to actually authenticate that it is talking to the correct resource
   because the user will be able to recognize whether the displayed
   content is correct.  If channel binding were used without mutual
   authentication, it would in effect be a request to only disclose the
   resource in the context of a particular channel.  Such an
   authentication would be similar in concept to a holder-of-key SAML
   assertion.  However, also note that while it is not happening in the
   protocol, mutual authentication is happening in the overall system:
   the user is able to visually authenticate the content.  This is
   consistent with all uses of channel binding without protocol level
   mutual authentication found so far.

   RFC 5056 channel binding (also called GSS-API channel binding when
   GSS-API is involved) is not the same thing as EAP channel binding.
   EAP channel binding is also used in the ABFAB context in order to
   implement acceptor naming and mutual authentication.  Details are
   discussed in the mechanisms specification [I-D.ietf-abfab-gss-eap].

4.3.  Host-Based Service Names

   IETF security mechanisms typically take the name of a service entered
   by a user and make some trust decision about whether the remote party
   in an interaction is the intended party.  GSS-API has a relatively
   flexible naming architecture.  However most of the IETF applications
   that use GSS-API, including SSH, NFS, IMAP, LDAP and XMPP, have
   chosen to use host-based service names when they use GSS-API.  In
   this model, the initiator names an acceptor based on a service such
   as "imap" or "host" (for login services such as SSH) and a host name.

   Using host-based service names leads to a challenging trust
   delegation problem.  Who is allowed to decide whether a particular
   hostname maps to an entity.  The public-key infrastructure (PKI) used
   by the web has chosen to have a number of trust anchors (root
   certificate authorities) each of wich can map any name to a public
   key.  A number of GSS-API mechanisms suchs as Kerberos [RFC1964]
   split the problem into two parts.  A new concept called a realm is
   introduced.  Then the mechanism decides what realm is responsible for
   a given name.  That realm is responsible for deciding if the acceptor
   entity is allowed to claim the name.  ABFAB needs to adopt this
   approach.

   Host-based service names do not work ideally when different instances
   of a service are running on different ports.  Also, these do not work
   ideally when SRV record or other insecure referrals are used.

   The GSS-EAP mechanism needs to support host-based service names in
   order to work with existing IETF protocols.




Howlett, et al.           Expires June 24, 2011                [Page 19]

Internet-Draft             ABFAB Architecture              December 2010


4.4.  Per-Message Tokens

   GSs-API provides per-message security services that can provide
   confidentiality and integrity.  Some IETF protocols such as NFS and
   SSH take advantage of these services.  As a result GSS-EAP needs to
   support these services.  As with mutual authentication, per-message
   services will limit the set of EAP methods that are available.  Any
   method that produces a Master Session Key (MSK) should be able to
   support per-message security services.

   GSS-API provides a pseudo-random function.  While the pseudo-random
   function does not involve sending data over the wire, it provides an
   algorithm that both the initiator and acceptor can run in order to
   arrive at the same key value.  This is useful for designs where a
   successful authentication is used to key some other function.  This
   is similar in concept to the TLS extractor.  No current IETF
   protocols require this.  However GSS-EAP supports this service
   because it is valuable for the future and easy to do given per-
   message services.  Non-IETF protocols are expected to take advantage
   of this in the near future.































Howlett, et al.           Expires June 24, 2011                [Page 20]

Internet-Draft             ABFAB Architecture              December 2010


5.  Privacy Considerations

   Sharing identity information may lead to privacy violations.  A
   future verison of this document will provide a discussion of privacy
   considerations in a federated access environment.














































Howlett, et al.           Expires June 24, 2011                [Page 21]

Internet-Draft             ABFAB Architecture              December 2010


6.  Deployment Considerations

6.1.  EAP Channel Binding

   Discuss the implications of needing EAP channel binding.

6.2.  AAA Proxy Behavior

   Discuss deployment implications of our proxy requirements.










































Howlett, et al.           Expires June 24, 2011                [Page 22]

Internet-Draft             ABFAB Architecture              December 2010


7.  Security Considerations

   This entire document is about security.  A future version of the
   document will highlight some important security concepts.















































Howlett, et al.           Expires June 24, 2011                [Page 23]

Internet-Draft             ABFAB Architecture              December 2010


8.  IANA Considerations

   This document does not require actions by IANA.
















































Howlett, et al.           Expires June 24, 2011                [Page 24]

Internet-Draft             ABFAB Architecture              December 2010


9.  Acknowledgments

   We would like to thank Mayutan Arumaithurai and Klaas Wierenga for
   their feedback.  Additionally, we would like to thank Eve Maler,
   Nicolas Williams, Bob Morgan, Scott Cantor, Jim Fenton, and Luke
   Howard for their feedback on the federation terminology question.

   Furthermore, we would like to thank Klaas Wierenga for his review of
   the pre-00 draft version.










































Howlett, et al.           Expires June 24, 2011                [Page 25]

Internet-Draft             ABFAB Architecture              December 2010


10.  References

10.1.  Normative References

   [RFC2743]  Linn, J., "Generic Security Service Application Program
              Interface Version 2, Update 1", RFC 2743, January 2000.

   [RFC2865]  Rigney, C., Willens, S., Rubens, A., and W. Simpson,
              "Remote Authentication Dial In User Service (RADIUS)",
              RFC 2865, June 2000.

   [RFC3588]  Calhoun, P., Loughney, J., Guttman, E., Zorn, G., and J.
              Arkko, "Diameter Base Protocol", RFC 3588, September 2003.

   [RFC3748]  Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.
              Levkowetz, "Extensible Authentication Protocol (EAP)",
              RFC 3748, June 2004.

   [RFC3579]  Aboba, B. and P. Calhoun, "RADIUS (Remote Authentication
              Dial In User Service) Support For Extensible
              Authentication Protocol (EAP)", RFC 3579, September 2003.

   [RFC4072]  Eronen, P., Hiller, T., and G. Zorn, "Diameter Extensible
              Authentication Protocol (EAP) Application", RFC 4072,
              August 2005.

   [RFC4282]  Aboba, B., Beadles, M., Arkko, J., and P. Eronen, "The
              Network Access Identifier", RFC 4282, December 2005.

   [I-D.hansen-privacy-terminology]
              Pfitzmann, A., Hansen, M., and H. Tschofenig, "Terminology
              for Talking about Privacy by Data Minimization: Anonymity,
              Unlinkability, Undetectability, Unobservability,
              Pseudonymity, and Identity Management",
              draft-hansen-privacy-terminology-01 (work in progress),
              August 2010.

   [I-D.ietf-abfab-gss-eap]
              Hartman, S. and J. Howlett, "A GSS-API Mechanism for the
              Extensible Authentication Protocol",
              draft-ietf-abfab-gss-eap-00 (work in progress),
              October 2010.

10.2.  Informative References

   [I-D.nir-tls-eap]
              Nir, Y., Sheffer, Y., Tschofenig, H., and P. Gutmann, "TLS
              using EAP Authentication", draft-nir-tls-eap-08 (work in



Howlett, et al.           Expires June 24, 2011                [Page 26]

Internet-Draft             ABFAB Architecture              December 2010


              progress), July 2010.

   [RFC1964]  Linn, J., "The Kerberos Version 5 GSS-API Mechanism",
              RFC 1964, June 1996.

   [RFC2203]  Eisler, M., Chiu, A., and L. Ling, "RPCSEC_GSS Protocol
              Specification", RFC 2203, September 1997.

   [RFC3645]  Kwan, S., Garg, P., Gilroy, J., Esibov, L., Westhead, J.,
              and R. Hall, "Generic Security Service Algorithm for
              Secret Key Transaction Authentication for DNS (GSS-TSIG)",
              RFC 3645, October 2003.

   [RFC2138]  Rigney, C., Rigney, C., Rubens, A., Simpson, W., and S.
              Willens, "Remote Authentication Dial In User Service
              (RADIUS)", RFC 2138, April 1997.

   [RFC4462]  Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch,
              "Generic Security Service Application Program Interface
              (GSS-API) Authentication and Key Exchange for the Secure
              Shell (SSH) Protocol", RFC 4462, May 2006.

   [RFC4422]  Melnikov, A. and K. Zeilenga, "Simple Authentication and
              Security Layer (SASL)", RFC 4422, June 2006.

   [RFC5056]  Williams, N., "On the Use of Channel Bindings to Secure
              Channels", RFC 5056, November 2007.

   [RFC5801]  Josefsson, S. and N. Williams, "Using Generic Security
              Service Application Program Interface (GSS-API) Mechanisms
              in Simple Authentication and Security Layer (SASL): The
              GS2 Mechanism Family", RFC 5801, July 2010.

   [OASIS.saml-core-2.0-os]
              Cantor, S., Kemp, J., Philpott, R., and E. Maler,
              "Assertions and Protocol for the OASIS Security Assertion
              Markup Language (SAML) V2.0", OASIS Standard saml-core-
              2.0-os, March 2005.

   [RFC2904]  Vollbrecht, J., Calhoun, P., Farrell, S., Gommans, L.,
              Gross, G., de Bruijn, B., de Laat, C., Holdrege, M., and
              D. Spence, "AAA Authorization Framework", RFC 2904,
              August 2000.








Howlett, et al.           Expires June 24, 2011                [Page 27]

Internet-Draft             ABFAB Architecture              December 2010


URIs

   [1]  <http://www.eduroam.org>
















































Howlett, et al.           Expires June 24, 2011                [Page 28]

Internet-Draft             ABFAB Architecture              December 2010


Authors' Addresses

   Josh Howlett
   JANET(UK)


   Phone:
   Email: Josh.Howlett@ja.net


   Sam Hartman
   Painless Security


   Phone:
   Email: hartmans-ietf@mit.edu


   Hannes Tschofenig
   Nokia Siemens Networks
   Linnoitustie 6
   Espoo  02600
   Finland

   Phone: +358 (50) 4871445
   Email: Hannes.Tschofenig@gmx.net
   URI:   http://www.tschofenig.priv.at


   Eliot Lear
   Cisco Systems GmbH
   Richtistrasse 7
   Wallisellen, ZH  CH-8304
   Switzerland

   Phone: +41 44 878 9200
   Email: lear@cisco.com














Howlett, et al.           Expires June 24, 2011                [Page 29]

