<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2104 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml'>
    <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY rfc2246 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2246.xml'>
    <!ENTITY rfc3766 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3766.xml'>
    <!ENTITY rfc4346 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4346.xml'>
    <!ENTITY rfc4366 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4366.xml'>
    <!ENTITY rfc4492 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4492.xml'>
    <!ENTITY rfc5246 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml'>
]>
<rfc category="info" ipr="trust200902" docName="draft-campagna-tls-ecmqv-ecqv-00">

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>

    <front>

        <title abbrev="ECMQV_ECQV in TLS">ECMQV_ECQV Cipher Suites for Transport Layer Security (TLS)</title>

        <author initials="M." surname="Campagna" fullname="Matthew Campagna">
            <organization>Certicom Corp.</organization>
			<address>
				<postal>
					<street>5520 Explorer Drive #400</street>
					<city>Mississauga</city> <region>Ontario</region>
					<code>L4W 5L1</code>
					<country>Canada</country>
				</postal>
				<email>mcampagna@certicom.com</email>
			</address>
        </author>
        <author initials="D." surname="Stebila" fullname="Douglas Stebila">
            <organization>Queensland University of Technology</organization>
			<address>
				<postal>
					<street>Information Security Institute</street>
					<street>Level 7, 126 Margaret St</street>
					<city>Brisbane</city> <region>Queensland</region>
					<code>4000</code>
					<country>Australia</country>
				</postal>
				<email>douglas@stebila.ca</email>
			</address>
        </author>

        <date month="September" day="24" year="2009" />

		<area>Security</area>
		<workgroup>Network Working Group</workgroup>
		<keyword>I-D</keyword>
		<keyword>Internet-Draft</keyword>
		<keyword>Elliptic Curve Cryptography (ECC)</keyword>
		<keyword>Transport Layer Security (TLS)</keyword>

        <abstract><t>This document specifies a set of cipher suites for the Transport Layer Security (TLS) protocol that use Elliptic Curve Qu-Vanstone (ECQV) certificates to authenticate an Elliptic Curve Menezes-Qu-Vanstone (ECMQV) exchange.  These cipher suites provide forward secrecy.</t></abstract>

    </front>

    <middle>

		<section anchor="intro" title="Introduction">

			<t>Elliptic curve implicit certificates, combined with the Elliptic Curve Menezes-Qu-Vanstone (ECMQV) key agreement schemes, provide significant computation and bandwidth savings over traditional certificate schemes and the Diffie-Hellman key agreement schemes, while still affording equivalent security properties.</t>

			<t>Elliptic Curve Qu-Vanstone (ECQV) is an implicit certificate scheme that removes the need for explicitly signing a public key and associated data in the certificate.  Details of the security properties provided by ECQV can be found in <xref target="SEC4" />. Compared to currently prevalent certificate schemes, ECQV provides smaller certificate sizes for equivalent security levels. This is illustrated in the following table, which compares the minimial number of bit required to convey the public key and, if required, the explicit signature in the certificate, at various symmetric key security levels.  In the table columns with (p/2^m) shows sizes for elliptic curve groups over prime fields of size p or 2^m, respectively.</t>

			<texttable>
				<ttcol align="center">Symmetric</ttcol>
				<ttcol align="center">ECQV (p/2^m)</ttcol>
				<ttcol align="center">ECDSA (p/2^m)</ttcol>
				<ttcol align="center">DH/DSA/RSA</ttcol>
				<c> 80 </c><c> 160/163 </c><c> 480/489 </c><c> 2064</c>
				<c> 112 </c><c> 224/233 </c><c> 672/699 </c><c> 4112</c>
				<c> 128 </c><c> 256/283 </c><c> 768/849 </c><c> 6160</c>
				<c> 192 </c><c> 384/409 </c><c> 1152/1227 </c><c> 15376</c>
				<c> 256 </c><c> 521/571 </c><c> 1563/1713 </c><c> 30736</c>
			</texttable>

			<t><xref target="RFC4492" /> defines a set of elliptic curve cryptography (ECC)-based cipher suites for the Transport Layer Security (TLS) protocol and describes the use of ECC certificates for client authentication.  In particular, it specifies the use of Elliptic Curve Diffie-Hellman (ECDH) key agreement in a TLS handshake and the use of Elliptic Curve Digital Signature Algorithm (ECDSA) for authentication.</t>

			<t>ECMQV key agreement with ECQV implicit certifcates, denoted ECMQV_ECQV, provides the same security properties as provided by ephemeral ECDH (ECDHE) with ECDSA certificates, but requires less computation.  The following table compares the number of operations required by each party in the two schemes.</t>

			<texttable>
				<ttcol align="center">ECMQV_ECQV with client ECQV_ECMQV</ttcol>
				<ttcol align="center">ECDHE_ECDSA with client ECDSA_sign</ttcol>
				<c> 1 hash operation </c><c> 3 hash operations</c>
				<c> 1 key generation </c><c> 2 key generations</c>
				<c> 2 point additions </c><c> 2 point additions</c>
				<c> 2.5 point multiplications </c><c> 3 point multiplications</c>
			</texttable>

			<t>The computational and bandwidth savings make ECMQV_ECQV particularly attractive for bandwidth-constrained environments and devices with constrained computational power.</t>

			<t>ECMQV and ECQV are used in the Certificate Based Key Exchange (CBKE) defined in the ZigBee Smart Energy Specification <xref target="ZigBeeSE" />. ZigBee is developing an Internet Protocol (IP) capability to support a unified Smart Energy profile to run over HomePlug. This document is meant to help support the general ZigBee and HomePlug efforts to use IETF protocols and achieve application-layer security, bandwidth, and computational goals.</t>

			<t>This document describes additions to TLS to support ECMQV_ECQV, applicable to TLS version 1.0 <xref target="RFC2246" />, TLS version 1.1 <xref target="RFC4346" />, and TLS version 1.2 <xref target="RFC5246" />.  In particular, it defines:</t>

			<list style="symbols">
			<t>the use of the Elliptic Curve Menezes-Qu-Vanstone (ECMQV) key agreement scheme with long-term and ephemeral keys to establish the TLS premaster secret, and</t>
			<t>the use of Elliptic Curve Qu-Vanstone (ECQV) implicit certificates for authentication of TLS peers.</t>
			</list>

			<t>The remainder of this document is organized as follows.  <xref target="ecmqv_ecqv" /> provides an overview of ECMQV_ECQV-based key exchange algorithms for TLS.  <xref target="datastructs" /> describes the data structures and actions required to implement the new authenticated key agreement scheme.  <xref target="ciphersuites" /> defines new ECMQV_ECQV-based cipher suites and identifies a small subset of these as recommended for all implementations of this specification.  <xref target="security" /> discusses security considerations.  <xref target="iana" /> describes IANA considerations for the name spaces created by this document.</t>

			<t>Implementation of this document requires familiarity with the following technologies and standards: elliptic curve cryptography <xref target="SEC1" /> (additional information available in <xref target="HMV04" />, <xref target="IEEE1363" />); ECMQV <xref target="SEC1" />, Section 6.2 (additional information available in <xref target="LMQSV98" />); ECQV <xref target="SEC4" />; the use of elliptic curve cryptography in TLS <xref target="RFC4492" />; and the relevant version of TLS <xref target="RFC2246" />, <xref target="RFC4346" />, <xref target="RFC5246" />.</t>

		</section>

		<section anchor="notation" title="Notation">

			<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

		</section>

		<section anchor="ecmqv_ecqv" title="ECMQV_ECQV Key Exchange Algorithm">

			<t>This document describes a new ECC-based key exchange algorithm for TLS.  It uses ECMQV to compute a TLS premaster secret.  The derivation of the TLS master secret from the premaster secret and the subsequent generation of bulk encryption/MAC keys and initialization vectors is independent of the key exchange algorithm and not impacted by the techniques in this document.</t>

			<t>ECMQV_ECQV key exchange provides forward secrecy and mutual authentication.  It provides a new server authentication mechanism and a new client authentication mechanism, both using ECQV certificates.  This document treats the ECQV certificates as an opaque data structure that is defined outside this specification; for example, this structure could be an X.509 format.</t>

			<section anchor="ecmqv_ecqv-overview" title="ECMQV_ECQV Handshake Protocol Overview">

				<t>The handshake defined for ECMQV_ECQV requires that a server has an ECQV certificate.  In the case that the client also has a certificate no CertificateVerify message is required: proof of possession of the private key is demonstrated by the verify_data in the Finished method.  This is a property afforded by ECMQV that also applies to ECQV certificates and can reduce the bandwidth and computational complexity of a mutually authenticated key establishment.</t>

				<figure anchor="fig-ecmqv_ecqv-prot">
				<artwork>
    Client                                               Server
    
    ClientHello                  --------&gt;
                                                    ServerHello
                                                    Certificate
                                              ServerKeyExchange
                                            CertificateRequest*
                                 &lt;--------      ServerHelloDone
    Certificate*
    ClientKeyExchange
    [ChangeCipherSpec]
    Finished                     --------&gt;
                                             [ChangeCipherSpec]
                                 &lt;--------             Finished
    Application Data             &lt;-------&gt;     Application Data

	* message is not sent in some conditions
</artwork>
				<postamble>Message flow for an ECMQV_ECQV handshake.</postamble>
				</figure>

			</section>

			<section anchor="ecmqv_ecqv-serverauth" title="Server Authentication">

				<t>The ECMQV_ECQV scheme provides server authentication by the exchange of an ECQV certificate issued by a certificate authority recognized by the client.</t>

			</section>

			<section anchor="ecmqv_ecqv-clientauth" title="Client Authentication">

				<t>The ECMQV_ECQV scheme provides client authentication by the exchange of an ECQV certificate issued by a certificate authority recognized by the clientserver.</t>

				<t>The server MUST request ECQV-based client authentication by including this certificate type in its CertificateRequest message.  The client MUST check if it possesses a certificate appropriate for this method suggested by the server and is willing to use it for authentication.</t>

				<t>If these conditions are not met, the client SHOULD send a client Certificate message containing no certificates.  In this case, the ClientKeyExchange message is as described in <a href="#sec-3.5">Section 3.5</a>.  If the server requires client authentication, it MAY respond with a fatal handshake failure alert.</t>

				<t>If the client has an appropriate certificate and is willing to use it for authentication, it MUST send that certificate in the client's Certificate message (as per <xref target="datastructs-clientcert" />) and prove possession of the private key corresponding to the certified key.  The process of proving possession is described below.</t>

				<t>The cipher suites described in this document make use of the elliptic curve parameter negotiation mechanism defined in <xref target="RFC4492" />, which makes use of TLS extensions <xref target="RFC4366" />.  When the cipher suites defined in this document are used, the 'ecmqv_ecqv' case inside the ServerKeyExchange and ClientKeyExchange structure MUST be used (i.e., the ServerKeyExchange and ClientKeyExchange messages MUST include the ECQV parameters).</t>

			</section>

		</section>

		<section anchor="datastructs" title="Data Structures and Computations">

			<t>This section specifies the data structures and computations used by ECMQV key mechanisms specified in <xref target="ciphersuites" />.  The presentation language used here is the same as that used in TLS <xref target="RFC4346" />.  Since this specification extends TLS, these descriptions should be merged with those in the TLS specification and any others that extend TLS.  This means that enum types may not specify all possible values, and structures with multiple formats chosen with a select() clause may not indicate all possible cases.</t>

			<t>The ClientHello message and the ServerHello messages are unchanged and utilize those used in <xref target="RFC4492" />.</t>

			<section anchor="datastructs-servercert" title="Server Certificate">

				<t>When this message is sent:</t>

				<t>This message is sent in all ECMQV_ECQV-based cipher suites.</t>

				<t>Meaning of this message:</t>
			 
				<t>This message is used to authentically convey the server's static public key to the client.  ECC public keys MUST be encoded in a Certificate message.</t>

				<t>Structure of this message:</t>

				<figure>
				<artwork>
    opaque ECQVCert&lt;1..2^8-1&gt;

    struct {
        ECQVCert certificate_list&lt;0..2^16-1&gt;
    } Certificate;
</artwork>
				</figure>

				<t>The ECQVCert value is defined by the underlying application specification.  For general details on the necessary components see SEC 4 <xref target="SEC4" />.</t>

				<t>The server constructs an appropriate Certificate structure and conveys it to the client in the Certificate message.  If the client has used a Supported Elliptic Curves Extension, the public key in the server's certificate MUST respect the client's choice of elliptic curves; in particular, the public key MUST employ a named curve (not the same curve as an explicit curve) unless the client has indicated support for explicit curves of the appropriate type.  If the client has used a Supported Point Formats Extension, both the server's public key point and (in the case of an explicit curve) the curve's base point MUST respect the client's choice of point formats.  (A server that cannot satisfy these requirements MUST NOT choose an ECMQV_ECQV cipher suite in its ServerHello message.)</t>

				<t>Actions of the receiver:</t>

				<t>The client validates the information in the ECQVCert and extracts the server's public key using the operations specified in SEC 4 <xref target="SEC4" /> section 2.3, under the curve specified in the Server Key Exchange message defined in <xref target="datastructs-serverkeyex" />.  (A possible reason for a fatal handshake failure is that the client's capabilities for handling elliptic curves and point formats are exceeded; cf. <xref target="RFC4492" />, Section 5.1.)</t>

			</section>

			<section anchor="datastructs-serverkeyex" title="Server Key Exchange">

				<t>When this message is sent:</t>
			 
				<t>This message is sent in all ECMQV_ECQV-based cipher suites.</t>

				<t>Meaning of this message:</t>

				<t>This message is used to convey the server's ephemeral ECMQV public key (and the corresponding elliptic curve domain parameters) to the client.</t>

				<t>Structure of this message:</t>

				<figure>
				<artwork>
    struct {
        ECParameters curve_params;
        ECPoint      public;
    } ServerECMQVParams;
</artwork>
				</figure>

				<t>curve_params:   Specifies the elliptic curve domain parameters associated with the ECMQV public key and is as specified in <xref target="RFC4492" />, Section 5.4.</t>

				<t>public:   The ephemeral ECMQV public key.</t>

				<t>The ServerKeyExchange message is extended as follows.</t>

				<figure>
				<artwork>
    enum { 
        ec_mqv (xx)
    } KeyExchangeAlgorithm;
</artwork>
				</figure>

				<t>ec_mqv:   Indicates the ServerKeyExchange message contains an ECMQV public key.</t>

				<t>The ServerKeyExchange structure is extended as follows:</t>

				<figure>
				<artwork>
    select (KeyExchangeAlgorithm) {
        case ec_mqv:
            ServerECMQVParams params;
    } ServerKeyExchange;
</artwork>
				</figure>

				<t>params:   Specifies the ECMQV public key and associated domain parameters.</t>

				<t>Actions of the sender:</t>

				<t>The server selects elliptic curve domain parameters and an ephemeral ECMQV public key corresponding to these parameters according to the ECKAS-MQV scheme as specified in <xref target="SEC1" />, Section 6.2.  It conveys this information to the client in the ServerKeyExchange message using the format defined above.</t>

				<t>NOTE: curve_params MUST specify the same curve that is used by the CA, and the curve on which the point in the Certificate from the server's Certificate message lies.</t>

				<t>Actions of the receiver:</t>

				<t>The client retrieves the server's elliptic curve domain parameters and ephemeral ECMQV public key from the ServerKeyExchange message and MUST validate the parameters in accordance with <xref target="SEC1" />, Section 6.2.1, and MUST validate the ephemeral public keys in accordance with <xref target="SEC1" />, Section 6.2.2.  (A possible reason for a fatal handshake failure is that the client's capabilities for handling elliptic curves and point formats are exceeded;  cf. <xref target="RFC4492" />, Section 5.1.)</t>
	
			</section>

			<section anchor="datastructs-certreq" title="Certificate Request">

				<t>When this message is sent:</t> 

				<t>This message is sent by the server when requesting client authentication.</t>

				<t>Meaning of this message:</t>

				<t>The server uses this message to suggest acceptable client authentication methods.</t>

				<t>Structure of this message:</t>

				<t>The TLS CertificateRequest message is extended as follows.</t>

				<figure>
				<artwork>
    enum {
        ecqv_ecmqv (xx),
    } ClientCertificateType;
</artwork>
				</figure>

				<t>ecqv_ecmqv: Indicates that the server would like to use the corresponding client authentication method specified in <xref target="datastructs-clientcert" />.</t>

				<t>The TLS SignatureAndHashAlgorithms are extended by the addition of a hashing algorithm which uses the Advanced Encryption Standard (AES) functions AES-128 and AES-256 in Matyas-Meyer-Oseas (MMO) hash function mode (<xref target="ZigBee" />, Section B.6; see also <xref target="MOV96" />, Section 9.4.1) and an implicit certificate type signature for ECQV.</t>

				<figure>
				<artwork>
    enum {
        aes_128_mmo (xx), aes_256_mmo (xx)
    } HashAlgorithm;
    
    enum {
        ecqv (xx)
    } SignatureAlgorithm;
    
    struct {
        ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
        SignatureAndHashAlgorithm
            supported_signature_algorithms&lt;1..2^16-1&gt;;
        DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
    } CertificateRequest;
</artwork>
				</figure>

				<t>The benefit of ECQV certificate exchanges is the reduction in packet sizes.  It is expected that most of the parties communicating via ECQV certificates belong to the same or a small list of acceptable certificate authorities, and that these certificate authorities are identified within the certificates.  As such, it is expected that the certificate_authorities list will often be empty.</t>

				<t>The interaction of the certificate_types and supported_signature_algorithms fields is further complicated when using TLS version 1.2 <xref target="RFC5246" />.  The following rules augment the existing rules in <xref target="RFC5246" />:</t>

				<list style="symbols">
				<t>If the ecqv SignatureAlgorithm type is specified, it only applies to the public key contained in the end-entity certificate.  It cannot be used to sign certificates.</t>
				</list>

				<t>Actions of the sender:</t>

				<t>The server decides which client authentication methods it would like to use, and conveys this information to the client using the format defined above.</t>

				<t>Actions of the receiver:</t>

				<t>The client determines whether it has a suitable certificate for use with any of the requested methods and whether to proceed with client authentication.</t>

			</section>

			<section anchor="datastructs-clientcert" title="Client Certificate">

				<t>When this message is sent:</t>

				<t>This message is sent by the client in response to a CertificateRequest when a client has a suitable certificate and has decided to proceed with client authentication.  (Note that if the server has used a Supported Point Formats Extension, a certificate can only be considered suitable for use with the ECQV_ECMQV authentication methods if the public key point specified in it respects the server's choice of point formats.  If no Supported Point Formats Extension has been used, a certificate can only be considered suitable for use with these authentication methods if the point is represented in uncompressed point format.)</t>

				<t>Meaning of this message:</t>

				<t>This message is used to authentically convey the client's static public key to the server in an ECQV certificate.</t>

				<t>Structure of this message:</t>

				<t>Identical to the ECQV Certificate format specified in Server Certificate <xref target="datastructs-servercert" />.</t>

				<t>Actions of the sender:</t>

				<t>The client constructs an appropriate Certificate message.</t>

				<t>NOTE: The ECQV certificate MUST be issued by a CA on the same curve specified in the ECParameters sent in the Server Key Exchange message.  The point in the ECQV certificate MUST also be on the same curve.</t>

				<t>Actions of the receiver:</t>

				<t>The TLS server validates the information in the ECQVCert, and extracts the client's public key using the operations specified in <xref target="SEC4" /> section 2.3, under the curve specified in the Server Key Exchange message defined in <xref target="datastructs-serverkeyex" />.</t>

			</section>

			<section anchor="datastructs-clientkeyex" title="Client Key Exchange">

				<t>When this message is sent:</t>

				<t>This message is sent in all ECMQV_ECQV-based cipher suites.</t>

				<t>Meaning of the message:</t>

				<t>This message is used to convey the client's ephemeral ECMQV public key.</t>

				<t>Structure of this message:</t>

				<t>The TLS ClientKeyExchange message mimics <xref target="RFC4492" /> as follows.</t>

				<figure>
				<artwork>
    enum { implicit, explicit } PublicValueEncoding;
</artwork>
				</figure>

				<t>implicit, explicit: For ECMQV_ECQV cipher suites, this indicates whether the client's has one ECMQV public key in the client's certificate ("implicit") and is providing one ephemeral ECMQV public key or if it is providing two ephemeral ECMQV public keys, in the ClientKeyExchange message ("explicit").</t>

				<figure>
				<artwork>
    struct {
        select (PublicValueEncoding) {
            case implicit: 
                ECPoint ecmqv_q2;
            case explicit: struct {
                ECPoint ecmqv_q1;
                ECPoint ecmqv_q2;
            };
        } ecmqv_public;
    } ClientECMQVPublic;
</artwork>
				</figure>

				<t>ecmqv_q1: Contains the client's ephemeral ECMQV public key as a byte string ECPoint.point, which may represent an elliptic curve point in uncompressed or compressed format.  Here, the format MUST conform to what the server has requested through a Supported Point Formats Extension if this extension was used, and MUST be uncompressed if this extension was not used.</t>

				<t>ecmqv_q2: Is the same as above.</t>

				<t>The ClientKeyExchange message is extended as follows.</t>

				<figure>
				<artwork>
    struct {
        select (KeyExchangeAlgorithm) {
            case ecmqv:
                ClientECMQVPublic;
        } exchange_keys;
    } ClientKeyExchange;
</artwork>
				</figure>

				<t>Actions of the sender:</t>

				<t>The client selects an ephemeral ECMQV public key corresponding to the parameters it received from the server according to the ECKAS-MQV scheme as specified in <xref target="SEC1" />, Section 6.2.  It conveys this information to the client in the ClientKeyExchange message using the format defined above.</t>

				<t>Actions of the receiver:</t>

				<t>The server retrieves the client's ephemeral ECMQV public key(s) from the ClientKeyExchange message, checks that the public key(s) is(are) on the same elliptic curve as the server's ECMQV key, and validates the ephemeral public keys in accordance with <xref target="SEC1" />, Section 6.2.2.</t>

				<t>The premaster secret is formed as follows.  First, recover the static public key in the ECQV certificate as described in <xref target="SEC4" />, Section 2.5, and then perform the ECMQV computation as described in <xref target="SEC1" />, Section 6.2.  Let premaster secret be the octet string produced by this computation.</t>

			</section>

		</section>

		<section anchor="ciphersuites" title="ECMQV_ECQV-Based Cipher Suites">

			<section anchor="ciphersuites-sha1" title="ECMQV_ECQV Cipher Suites Using the SHA-1 Hash Function">

				<t>The document specifies four cipher suites using ECMQV key exchange and ECQV certificates with RC-4, Triple-DES (3DES), or Advanced Encryption Standard (AES) encryption and the SHA-1 hash function:</t>

				<figure>
				<artwork>
    CipherSuite TLS_ECMQV_ECQV_WITH_RC4_128_SHA          = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_3DES_EDE_CBC_SHA     = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_AES_128_CBC_SHA      = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_AES_256_CBC_SHA      = {0xXX,0xXX};
</artwork>
				</figure>

			</section>

			<section anchor="ciphersuites-sha2" title="ECMQV_ECQV Cipher Suites Using the SHA2 Hash Function Family">

				<t>The document specifies two cipher suites using ECMQV key exchange and ECQV certificates with AES encryption and the SHA2 hash function family:</t>

				<figure>
				<artwork>
    CipherSuite TLS_ECMQV_ECQV_WITH_AES_128_CBC_SHA256   = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_AES_256_CBC_SHA384   = {0xXX,0xXX};
</artwork>
				</figure>

				<t>The above two cipher suites are the same as the corresponding AES cipher suites in <xref target="ciphersuites-sha1" /> above, except for the hash and PRF algorithms, which are as follows.</t>

				<t>For TLS_ECMQV_ECQV_WITH_AES_128_CBC_SHA256:</t>

				<list style="symbols">

					<t>The MAC is HMAC <xref target="RFC2104" /> with SHA-256 as the hash function.</t>

					<t>When negotiated in a version of TLS prior to 1.2, the PRF from that version is used; otherwise the PRF is the TLS version 1.2 PRF <xref target="RFC5246" /> with SHA-256 as the hash function.</t>

				</list>

				<t>For TLS_ECMQV_ECQV_WITH_AES_256_CBC_SHA384:</t>

				<list style="symbols">

					<t>The MAC is HMAC <xref target="RFC2104" /> with SHA-384 as the hash function.</t>

					<t>When negotiated in a version of TLS prior to 1.2, the PRF from that version is used; otherwise the PRF is the TLS version 1.2 PRF <xref target="RFC5246" /> with SHA-384 as the hash function.</t>

				</list>

			</section>

			<section anchor="ciphersuites-aesmmo" title="ECMQV_ECQV Cipher Suites Using AES-MMO Hash Functions">

				<t>The document specifies two cipher suites using ECMQV key exchange and ECQV certificates with AES encryption and AES-MMO hash functions:</t>

				<figure>
				<artwork>
    CipherSuite TLS_ECMQV_ECQV_WITH_AES_128_CCM_AES_128_MMO = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_AES_128_CCM_AES_256_MMO = {0xXX,0xXX};
</artwork>
				</figure>

				<t>The AES-MMO hash functions are specified in <xref target="ZigBee" />, Section B.6.</t>

				<t>These two cipher suites are similar to the above and are included to accommodate the Certificate-Based Key Establishment (CBKE) scheme in <xref target="ZigBeeSE" />.</t>

				<list style="symbols">

					<t>The MAC is HMAC <xref target="RFC2104" /> with AES-128-MMO or AES-256-MMO, respectively, as the hash function.</t>

					<t>When negotiated in a version of TLS prior to 1.2, the PRF from that version is used; otherwise the PRF is the TLS version 1.2 PRF <xref target="RFC5246" /> with AES-128-MMO or AES-256-MMO, respectively, as the hash function.</t>

				</list>

			</section>

		</section>

		<section anchor="ciphersuitesnull" title="ECMQV_ECQV-Based Cipher Suites With NULL Encryption">

			<t>This section specifies cipher suites using the NULL encryption algorithm.  As a result, these cipher suites provide only authentication, not confidentiality.</t>

			<section anchor="ciphersuitesnull-sha1" title="ECMQV_ECQV Cipher Suite Using the SHA-1 Hash Function with NULL Encryption">

				<t>The following cipher suite matches the cipher suites defined in <xref target="ciphersuites-sha1" />, except that we define a suite with NULL encryption.</t>

				<figure>
				<artwork>
    CipherSuite TLS_ECMQV_ECQV_WITH_NULL_SHA             = {0xXX,0xXX};
</artwork>
				</figure>

			</section>

			<section anchor="ciphersuitesnull-sha2" title="ECMQV_ECQV Cipher Suites Using the SHA2 Hash Function Family with NULL Encryption">

				<t>The following two cipher suites are the same as the corresponding cipher suites in <xref target="ciphersuites-sha2" />, but with NULL encryption.</t>

				<figure>
				<artwork>
    CipherSuite TLS_ECMQV_ECQV_WITH_NULL_SHA256          = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_NULL_SHA384          = {0xXX,0xXX};
</artwork>
				</figure>

			</section>

			<section anchor="ciphersuitesnull-aesmmo" title="ECMQV_ECQV Cipher Suites Using AES-MMO Hash Functions with NULL Encryption">

				<t>The following two cipher suites are the same as the corresponding cipher suites in <xref target="ciphersuites-aesmmo" />, but with NULL encryption.</t>

				<figure>
				<artwork>
    CipherSuite TLS_ECMQV_ECQV_WITH_NULL_AES_128_MMO     = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_NULL_AES_256_MMO     = {0xXX,0xXX};
</artwork>
				</figure>

			</section>

		</section>

		<section anchor="security" title="Security Considerations">

			<t>This document provides new cipher suites for the Transport Layer Security protocol.  For the most part, the security considerations involved in using the Transport Layer Security protocol apply.  Additionally, implementers should be aware of security considerations specific to elliptic curve cryptography.</t>

			<t>For ECMQV authenticated key exchange, the current best known technique for breaking the cryptosystems is by solving the elliptic curve discrete logarithm problem (ECDLP).</t>

			<t>The difficulty of breaking the ECDLP depends on the size and quality of the elliptic curve parameters.  Certain types of curves can be more susceptible to known attacks than others.  For example, curves over finite fields GF(2^m), where m is composite, may be susceptible to an attack based on the Weil descent.  All of the named curves specified in <xref target="RFC4492" />, Section 5.1.1, do not have this problem.  System administrators should be cautious when enabling named curves other than the ones specified in <xref target="RFC4492" /> or in supporting explicit curves, and should make a more detailed investigation into the security of the curve in question.</t>
			
			<t>It is believed (see for example Section B.2.1 of <xref target="SEC1" />) that when curve parameters are generated at random the curves will be resistant to special attacks, and must rely on the most general attacks.  The named curves in <xref target="RFC4492" />, Section 5.1.1, were all generated verifiably pseudorandomly.  The runtime of general attacks depends on the algorithm used.  At present, the best known algorithm is the Pollard-rho method.  (Shor's algorithm for quantum computers can solve the ECDLP in polynomial time, but at present large-scale quantum computers have not been constructed and significant experimental physics and engineering work needs to be done before large-scale quantum computers can be constructed.  There is no solid estimate as to when this may occur, but it is widely believed to be at least 20 years from the present.)</t>
			
			<t>Based on projections of computation power, it is possible to estimate the running time of the best known attacks based on the size of the finite field.  Table 1 in <xref target="RFC4492" /> gives an estimate of the equivalence between elliptic curve field size and symmetric key size.  Roughly speaking, an N-bit elliptic curve offers the same security as an N/2-bit symmetric cipher, so a 256-bit elliptic curve (such as the secp256r1 curve) is suitable for use with 128-bit AES, for example.</t>

			<t>Many estimates consider that 2^80-2^90 operations are beyond feasible, so that would suggest using elliptic curves of at least 160-180 bits.  The REQUIRED curves in this documents are 256-, 384-, and 521-bit curves; implementations SHOULD NOT use curves smaller than 160 bits.</t>

			<t>A detailed discussion on the security considerations of elliptic curve domain parameters and the ECMQV algorithm can be found in Appendix B of <xref target="SEC1" />.</t>

			<t>Additionally, the cipher suites defined in this document rely on the SHA-1 hash function, the SHA2 family of hash functions, and the AES-MMO hash function, as well as the DES, Triple-DES, and AES block ciphers.  The appropriate security considerations of the documents defining those functions apply.  Although some weaknesses have been discovered in SHA-1, it still provides a reasonable level of security for lower security lebels.  No weaknesses in the SHA2 family are known at present.  The SHA2 family consists of four variants -- SHA-224, SHA-256, SHA-384, and SHA-521 -- named after their digest lengths.  In the absence of special purpose attacks exploiting the specific structure of the hash function, the difficulty of finding collisions, preimages, and second preimages for the hash function is related to the digest length.</t>

			<t>Since ECMQV allow for elliptic curves of arbitrary sizes and thus arbitrary security strength, it is important that the size of elliptic curve be chosen to match the security strength of other elements of the cipher suite.  In particular, key sizes, hashing algorithms and bulk encryption algorithms must be chosen appropriately.  Information regarding estimated equivalence of key sizes is available in <xref target="NIST-800-57" />; the discussion in <xref target="RFC3766" /> is also relevant.</t>

			<t>System administrators and implementers should take careful consideration of the security issues when enabling curves other than the named curves defined in <xref target="RFC4492" />.  Not all elliptic curves are secure, even if they are over a large field.</t>

			<t>Implementers SHOULD ensure that any ephemeral private keys or random values -- including the ephemeral private key values in ECMQV -- are generated from a random number generator or a properly-seed pseudorandom number generator, are protected from leakage, are not reused outside of the context of the protocol in this document, and are erased from memory when no longer needed.  Additionally, implementers SHOULD ensure that any public keys received are validated as per the specification to avoid known attacks.</t>

		</section>

		<section anchor="iana" title="IANA Considerations">

			<t>This document defines the following new cipher suites, whose values are to be assigned from the TLS Cipher Suite registry defined in <xref target="RFC5246" />.</t>

			<figure>
			<artwork>	
    CipherSuite TLS_ECMQV_ECQV_WITH_RC4_128_SHA          = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_3DES_EDE_CBC_SHA     = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_AES_128_CBC_SHA      = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_AES_256_CBC_SHA      = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_AES_128_CBC_SHA256   = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_AES_256_CBC_SHA384   = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_NULL_SHA             = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_NULL_SHA256          = {0xXX,0xXX};
    CipherSuite TLS_ECMQV_ECQV_WITH_NULL_SHA384          = {0xXX,0xXX};
</artwork>
			</figure>

			<t>This document defines the following new client certificate types, whose values are to be assigned from the TLS ClientCertificateType Identifiers registry defined in <xref target="RFC5246" />.</t>

			<figure>
			<artwork>
    ecqv_ecmqv (xx)
</artwork>
			</figure>

			<t>This document defines the following new signature algorithms, whose values are to be assigned from the TLS SignatureAlgorithm registry defined in <xref target="RFC5246" />.</t>

			<figure>
			<artwork>
    ecqv (xx)
</artwork>
			</figure>

			<t>This document defines the following new hash algorithms, whose values are to be assigned from the TLS HashAlgorithm registry defined in <xref target="RFC5246" />.</t>

			<figure>
			<artwork>
    aes_128_mmo (xx),
    aes_256_mmo (xx)
</artwork>
			</figure>

			<t>This document creates no new registries.</t>

		</section>

    </middle>

    <back>

        <references title="Normative References">

			<reference anchor="FIPS-180-3" target="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf">
				<front>
					<title>Secure Hash Standard</title>
					<author>
						<organization>National Institute of Standards and Technology</organization>
					</author>
					<date month="October" year="2008" />
				</front>
				<seriesInfo name="FIPS" value="180-3" />
				<format type="PDF" target="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf" />
			</reference>

			<reference anchor="FIPS-197" target="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">
				<front>
					<title>Advanced Encryption Standard</title>
					<author>
						<organization>National Institute of Standards and Technology</organization>
					</author>
					<date month="November" year="2001" />
				</front>
				<seriesInfo name="FIPS" value="197" />
				<format type="PDF" target="hhttp://csrc.nist.gov/publications/fips/fips197/fips-197.pdf" />
			</reference>

			<reference anchor="NIST-800-57" target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf">
				<front>
					<title>Recommendation for Key Management - Part 1: General (Revised)</title>
					<author>
						<organization>National Institute of Standards and Technology</organization>
					</author>
					<date month="March" year="2007" />
				</front>
				<seriesInfo name="NIST Special Publication" value="800-57" />
				<format type="PDF" target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf" />
			</reference>

			&rfc2104;
			&rfc2119;
			&rfc2246;
			&rfc3766;
			&rfc4346;
			&rfc4366;
			&rfc4492;
			&rfc5246;

			<reference anchor="SEC1" target="http://www.secg.org/download/aid-780/sec1-v2.pdf">
				<front>
					<title>Elliptic Curve Cryptography</title>
					<author>
						<organization>Standards for Efficient Cryptography Group</organization>
					</author>
					<date month="September" day="20" year="2000" />
				</front>
				<seriesInfo name="SEC" value="1" />
				<format type="PDF" target="http://www.secg.org/download/aid-780/sec1-v2.pdf" />
			</reference>

			<reference anchor="SEC4" target="http://www.secg.org/download/aid-775/sec4-ECQV-v091.pdf">
				<front>
					<title>Elliptic Curve Qu-Vanstone Implicit Certificate Scheme (ECQV), v0.91</title>
					<author>
						<organization>Standards for Efficient Cryptography Group</organization>
					</author>
					<date month="November" day="18" year="2008" />
				</front>
				<seriesInfo name="SEC" value="4" />
				<format type="PDF" target="http://www.secg.org/download/aid-775/sec4-ECQV-v091.pdf" />
			</reference>

			<reference anchor="ZigBee" target="http://www.zigbee.org/ZigBeeSpecificationDownloadRequest/tabid/311/Default.aspx">
				<front>
					<title>ZigBee Specification, revision 17</title>
					<author>
						<organization>ZigBee Standards Organization</organization>
					</author>
					<date month="October" day="19" year="2007" />
				</front>
   				<format type="PDF" target="http://www.zigbee.org/ZigBeeSpecificationDownloadRequest/tabid/311/Default.aspx" />
				<annotation>Registration required.</annotation>
			</reference>

		</references>

        <references title="Informative References">

			<reference anchor="HMV04">
				<front>
					<title>Guide to Elliptic Curve Cryptography</title>
					<author initials="D." surname="Hankerson" fullname="Darrel Hankerson"><organization /></author>
					<author initials="A. J." surname="Menezes" fullname="Alfred J. Menezes"><organization /></author>
					<author initials="S." surname="Vanstone" fullname="Scott Vanstone"><organization /></author>
					<date month="" year="2004" />
				</front>
				<annotation>Springer, ISBN 038795273X.</annotation>
			</reference>
			
			<reference anchor="IEEE1363">
				<front>
					<title>Standard Specifications for Public Key Cryptography</title>
					<author><organization>Institute of Electrical and Electronics Engineers</organization></author>
					<date month="" year="2000" />
				</front>
				<seriesInfo name="IEEE" value="1363" />
			</reference>

			<reference anchor="LMQSV98" target="http://www.cacr.math.uwaterloo.ca/techreports/1998/corr98-05.pdf">
				<front>
					<title>An Efficient Protocol for Authenticated Key Agreement</title>
					<author initials="L." surname="Law" fullname="Laurie Law"><organization /></author>
					<author initials="A. J." surname="Menezes" fullname="Alfred J. Menezes"><organization /></author>
					<author initials="M." surname="Qu" fullname="Minghua Qu"><organization /></author>
					<author initials="J." surname="Solinas" fullname="Jerry Solinas"><organization /></author>
					<author initials="S." surname="Vanstone" fullname="Scott Vanstone"><organization /></author>
					<date month="August" year="1998" />
				</front>
				<seriesInfo name="University of Waterloo Technical Report CORR" value="98-05" />
				<format type="PDF" target="http://www.cacr.math.uwaterloo.ca/techreports/1998/corr98-05.pdf" />
			</reference>

			<reference anchor="MOV96" target="http://www.cacr.math.uwaterloo.ca/hac">
				<front>
					<title>Handbook of Applied Cryptography</title>
					<author initials="A. J." surname="Menezes" fullname="Alfred J. Menezes"><organization /></author>
					<author initials="P. C." surname="van Oorschot" fullname="Paul C. van Oorschot"><organization /></author>
					<author initials="S." surname="Vanstone" fullname="Scott Vanstone"><organization /></author>
					<date month="" year="1996" />
				</front>
				<annotation>CRC Press, ISBN 0-8493-8523-7. Available online.</annotation>
				<format type="HTML" target="http://www.cacr.math.uwaterloo.ca/hac/" />
			</reference>

			<reference anchor="ZigBeeSE" target="http://www.zigbee.org/ZigBeeSmartEnergyPublicApplicationProfile/tabid/312/Default.aspx">
				<front>
					<title>ZigBee Smart Energy Profile Specification, revision 15</title>
					<author>
						<organization>ZigBee Standards Organization</organization>
					</author>
					<date month="December" day="1" year="2008" />
				</front>
   				<format type="PDF" target="http://www.zigbee.org/ZigBeeSmartEnergyPublicApplicationProfile/tabid/312/Default.aspx" />
				<annotation>Registration required.</annotation>
			</reference>

		</references>

		<section anchor="ack" title="Acknowledgements">

			<t></t>

		</section>

    </back>

</rfc>
