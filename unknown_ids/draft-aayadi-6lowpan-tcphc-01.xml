<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc compact='yes'?>

<rfc category="exp" docName="draft-aayadi-6lowpan-tcphc-01" ipr="trust200902" xml:lang="en">
<front>
<title>TCP header compression for 6LoWPAN</title>

<author initials="A." surname="Ayadi" fullname="Ahmed Ayadi">
<organization>Telecom Bretagne</organization>
<address>
<postal>
	<street>Rue de la Chataigneraie, CS 17607</street>
	<city>35576 Cesson Sevigne cedex</city>
<country>France</country>
</postal>
<phone>+33 2 99 12 70 52</phone>
<email>ahmed.ayadi@telecom-bretagne.eu</email>
</address>
</author>

<author fullname="David Ros" initials="D." surname="Ros">
<organization>Telecom Bretagne</organization>
<address>
<postal>
	<street>Rue de la Chataigneraie, CS 17607</street>
	<city>35576 Cesson Sevigne cedex</city>
<country>France</country>
</postal>
<phone>+33 2 99 12 70 46</phone>
<email>david.ros@telecom-bretagne.eu</email>
</address>
</author>

<author fullname="Laurent Toutain" initials="L." surname="Toutain">
<organization>Telecom Bretagne</organization>
<address>
<postal>
	<street>Rue de la Chataigneraie, CS 17607</street>
	<city>35576 Cesson Sevigne cedex</city>
<country>France</country>
</postal>
<phone>+33 2 99 12 70 26</phone>
<email>laurent.toutain@telecom-bretagne.eu</email>
</address>
</author>

<date month="October" year="2010" />
<area>General</area>


<keyword>6LoWPAN</keyword>
<keyword>TCP</keyword>
<keyword>Header Compression</keyword>

<abstract>
<t>
   This document describes LOWPAN_TCPHC, a scheme for compressing the header of Transmission
   Control Protocol (TCP) 
   segments, in order to reduce the overhead on low-power and lossy  networks. It also
   specifies the LOWPAN_TCPHC header fields for the transmission of TCP
   segments over IPv6 for Low-power Wireless Personal Area Networks (6LoWPAN).
   In many cases, the 20 bytes of the mandatory TCP header can be compressed into as little as 6 bytes.
</t>
</abstract>
    
</front>

<middle>
<section anchor="intro" title="Introduction">

<t>
The 6LoWPAN Working Group <xref target="RFC4919"></xref> has proposed
LOWPAN_IPHC <xref target="I-D.ietf-6lowpan-hc"></xref>, a new version of
the LOWPAN_HC1 header compression mechanism <xref target="RFC4944"></xref>
which reduces the IPv6 header to about 3-5 bytes.
In <xref target="I-D.ietf-6lowpan-hc"></xref>, a header-compression
method for the transport layer (LOWPAN_NHC) has also been introduced,
however, only a UDP <xref target="RFC0768"></xref> datagram compression
mechanism is specified.
</t>

<t>
   UDP header compression is useful for 6LoWPAN because many Low-power
   and Lossy Network (LLN) applications are fault-tolerant and do not
   require 100% reliability. However, other applications and services
   such as SSH and HTTP require a reliable service from the transport
   layer that cannot be offered by UDP. Moreover, some usage scenarios
   of LLNs, such as health, military and security applications, impose
   strong reliability constraints. Also, in some usage cases (e.g.,
   sending a software update to a wireless node, or sending a query
   requesting a specific information from the wireless node) there is
   a need for a reliable data transport.
</t>

<!--<t>
   The reliability is not the main purpose of LLNs in general (e.g., 6LoWPANs) because most of LLN
   applications are loss-tolerant.
   However, new applications such as health, military and security applications require
   new needs : sending an image software to a wireless node to update the applications, sending a query
   requesting a specific information from the wireless node.
</t>-->

<t>
   In this document, we focus on the Transmission Control Protocol (TCP)
   <xref target="RFC0793"></xref>, which carries most of the traffic
   in IP networks.
   TCP is a connection-oriented, end-to-end reliable transport protocol.
   To ensure end-to-end reliability, TCP must recover from
   packet corruption, loss or  out-of-order delivery.
   This is achieved by assigning a sequence number to each transmitted
   byte (done by the TCP source), by requiring a positive acknowledgment
   (ACK) from the TCP destination, and by retransmitting lost or
   corrupted packets.
</t>

<t>
   In the context of 6LoWPAN networks, the size of TCP headers may
   induce a large overhead, especially for link-layer technologies that
   use small frames. For instance, a pure TCP acknowledgment (i.e., a
   TCP ACK carrying no data) without any TCP options represents 25% of
   the payload of an IEEE 802.15.4 typically <xref target="IEEE 802.15.4"></xref>
   MAC frame.
   In addition, TCP pure ACKs represent roughly 33% of the total number
   of segments exchanged in a TCP session (this figure may go up to
   roughly 50% if the Delayed ACK mechanism <xref target="RFC1122"></xref>
   is not used).
   This suggests that the use of header-compression mechanisms for TCP
   may result in important performance gains, in terms of used bandwidth
   and/or energy spent for frame transmission.
</t>

<t>
   A TCP header compression algorithm for 6LoWPAN should respect some requirements: (a)
   Efficiency (the scheme must provide low overhead in all cases), (b)
   Transparency (the resulting header after a compression and decompression
   should be identical to the original header), (c)
   Reordering tolerance (the scheme should be able to decompress
   compressed segments correctly even when segments arrive with a
   moderate reordering).
</t>

<!--<t>
  The importance of the size of the TCP header relative to the total size of a full
  frame (e.g., the size of a TCP acknowledgment represents 25% of the maximum size
  of the IEEE 802.15.4 frame). In addition, TCP acknowledgments represent 33% to 50% of
  the total of all segments exchanged in a TCP session (without using
  Delayed-ACK <xref target="RFC1122"></xref>).
</t>-->


<!--<t>
   6LoWAPAN devices are characterized by short range, low bit-rate,
   low power, low cost, and short data frame. For example, in IEEE 802.15.4 networks 
   <xref target="IEEE 802.15.4"></xref>, the maximum physical
   layer packet size is 127 bytes.
   In addition, medium access layer and link layer security
   requirements leave only 81 bytes for upper layers data.
</t>-->

<!--<t>
   In this document, we focus on TCP, since it is the most used reliable transport
   protocol in IP-based networks and it is recommended to be used with 6LoWPAN
   to reduce the complexity at the bridge router.
   Nevertheless, TCP suffers from its header length which should be compressed and
   adapted for 6LoWPAN. Moreover, in this kind of networks, losses are not only
   due to congestions but also to the high bit error ratio and collisions in
    the wireless networks.
</t>-->

<t>
   The goal of this document is thus to define a TCP header compression
   scheme for 6LoWPAN, called LOWPAN_TCPHC, which
   allows to significantly reduce the TCP overhead.
   The TCP header compression and decompression is performed in the edge router
   between the 6LoWPAN and the external IP network.
   The compression scheme can also be used between two 6LoWPAN nodes for 
   machine-to-machine communications.
   This document defines also an encoding format for LOWPAN_TCPHC header
   compression.
   Such mechanism and packet format aims at making TCP a more viable
   proposition for 6LoWPAN networks.
   Moreover, the LOWPAN_TCPHC mechanism can be used with LOWPAN_IPHC
   <xref target="I-D.ietf-6lowpan-hc"></xref> and thus reduce all header
   overheads to about seven to ten bytes instead of 60 bytes.
</t>

<t>
   The proposed scheme does not compress TCP control messages at
   the connection establishment phase.
   Those TCP segments are used to exchange a context identifier.
   Such context identifier replaces the port numbers in subsequent TCP
   segments, as a means of identifying a given TCP session.
<!--   Moreover, TCP flags are omitted from the TCP header in LOWPAN_TCPHC
   because they are specified in TCP segments that are sent uncompressed.
   The urgent pointer is omitted if the flag is not set and the window
   field is also omitted if it does not change. -->
   Some TCP options, such as Timestamp <xref target="RFC2018"></xref>
   and SACK <xref target="RFC1323"></xref> <xref target="RFC2883"></xref>,
   are supported (i.e., compressed) by the mechanism, while other options,
   unlikely to be required/used in 6LoWPANs, are omitted.
</t>

<section anchor="Related Work" title="Related Work">
  
<t>
   This section presents prior work on TCP/IP header compression.
   In particular, we will briefly describe three existing TCP header
   compression algorithms. A more detailed discussion of these algorithms
   can be found in <xref target="RFC4996"></xref>.

<!--A detailed
   description of background works on TCP header compression algorithms can be found in
   <xref target="RFC4995"></xref>. In the following paragraphs, three TCP header
   compression algorithm are shortly described and criticized.-->
</t>

<t>
   One of the first TCP/IP header compression methods was Compressed TCP
   (CTCP), proposed by Jacobson <xref target="RFC1144"></xref>.
   Jacobson's header compression algorithm distinguishes between dynamic
   fields and static fields. The static fields (e.g., source address,
   source port, ...) are sent in two situations: when initiating
   a connection, and when refreshing the context after a loss of
   synchronization.
   CTCP proposes to send the difference between the current and the previous value
   of dynamic fields (e.g., sequence number, acknowledgment number).
   When the synchronization is lost between the compressor and
   the decompressor, the TCP sender sends a segment with a regular
   header to refresh the context.
   Experimental studies <xref target="Perkins et al."></xref>
   <xref target="Srivastava et al."></xref> <xref target="Wang04"></xref>
   have shown that the performance of Jacobson's algorithm may degrade
   significantly in noisy/lossy network environments.
   An important disadvantage of CTCP is that it does not support
   TCP options, some of which are ubiquitous nowadays <xref target="Medina05"></xref>.
</t>

<t>
   IPHC <xref target="RFC2507"></xref> enhances Jacobson's TCP header
   compression by introducing a mechanism, called TWICE, to repair
   incorrectly-decompressed headers. TWICE is most efficient when
   applied to data-carrying TCP segments. <xref target="RFC2507"></xref>
   also describes a mechanism for explicitly requesting the transmission
   of less-compressed or uncompressed headers. such mechanism is
   especially suited for pure TCP acknowledgments.
   Note however that IPHC does not actually provide a compression method
   for TCP options; changing option fields are carried in compressed
   headers, but without any compression.
   Also, the header request mechanism may be unsuited for lossy
   6LoWPAN networks, which low bit rates and strong energy constraints
   are at odds with any additional signaling overhead.
   LoWPAN_TCPHC enhances IPHC by defining an adapted header compression
   of TCP for LLNs by sending lest significant bytes instead of sending
   a delta value.
   Moreover, LoWPAN_TCPHC completes IPHC by defining
   header compression schemes for the mostly used TCP options.
<!--
   Note that neither CTCP nor IPHC support the compression of SYN
   (i.e., connection-opening) and FIN (i.e., connection-closing) segments.
-->
<!--   IPHC <xref target="RFC2507"></xref> improves Van Jacobson by sending
   full header segment with a slow-start mode. However, the compressor
   should send a refresh segment after F_MAX_PERIOD which the maximum
   number of connective uncompressed sent segments. IPHC presents a repair mechanism
   called TWICE to repair incorrectly decompression header.
   However, this algorithm does not provide a compression method for
   TCP options; and the refresh mechanism is not needed in lossy 6LoWPAN networks
   because of the low bit rate and the size of the TCP windows.-->
</t>

<t>
  ROHC-TCP <xref target="RFC4996"></xref> improves on <xref target="RFC2507"></xref>
  by providing a new method for compressing all TCP header fields,
  including the TCP options. ROHC-TCP proposes also to start compressing
  packets starting from the SYN segments, using parameters from previous
  or simultaneous connections. This may offer noticeable improvements in
  performance when most TCP flows are short-lived, i.e., composed of a
  small number of data segments. Nevertheless, the ROHC-TCP algorithm
  is fairly complex and its memory requirements may not be met by small,
  constrained devices.
</t>

<t>
    The algorithm described in this document, LOWPAN_TCPHC, supports
    features like the compression of TCP options and FIN segments,
    and at the same time it is relatively simple and easy to implement
    in memory- and CPU-constrained devices.
<!-- This document presents LOWPAN_TCPHC, a new algorithm for TCP header compression. It does
   not modify to TCP behavior. It is simple and easy to
   implement in memory-constraint mobile devices.-->
</t> 
   
</section>

<section anchor="Terminology" title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"></xref>.
</t>

<t>
   This section defines general terms related to 
   TCP/IPv6 header compression <xref target="RFC2507"></xref> <xref target="RFC4995"></xref> and to the
   6LoWPAN architecture <xref target="RFC4919"></xref> used in this specification.
</t>

<t> <list style='symbols'>

      <t> Subheader: An IPv6 header, a UDP header, or a TCP header.</t>

      <t> Header: A chain of subheaders.</t>

      <t> Compression: The act of reducing the size of a header
      by either removing or reducing the size of  header
      fields.
      This is done in a way such that a decompressor can reconstruct
      the header if its context state is identical to the
      context state used when compressing the header.</t>

      <t> Decompression: The act of reconstructing a compressed header.</t>

      <t> Static fields: These fields are expected to be constant
      throughout the lifetime of the TCP connection. Static information must
      be communicated once in some way.</t>
      
      <t> Dynamic fields: These fields are expected to vary between
      different TCP segments, either randomly within a limited range or
      in some other manner.</t>
      
      <t> Context identifier (CID): A small unique number identifying
      the context that should be used to decompress a compressed header.
      Carried in full headers and compressed headers.</t>

      <t> Context: The state used by the compressor to compress a header, and by the
      decompressor  to decompress a header.
	  The context is given by the uncompressed version of
      the last header sent (compressor) or received (decompressor) over the link, except
      for fields in the header that are included "as-is" in compressed headers, or that
	  can be inferred from e.g. the size of the link-layer frame.</t>

      <t> Full header: An uncompressed header that updates or refreshes the context for a
      packet stream. It carries a CID that will be used to identify the context.</t>
      
      <t> Regular header: A normal, uncompressed header. It does not carry any CID.
<!--      or generation association. -->
      </t>

      <t> Compressed header: A header in which all the static fields are elided, and
	  all the dynamic fields are sent compressed.</t>
<!--
      <t> Mostly compressed header: A header in which all the static fields are elided,
	  and all the dynamic fields are sent without compression.</t>
-->
      <t> Incorrect decompression: When a decompressed header does not match
	  the corresponding original, uncompressed header.
	  Usually due to mismatching contexts between the compressor and
      decompressor, caused by e.g. bit errors during the transmission of
	  the compressed header, or by packet loss.</t>

      <t> IEEE 802.15.4: A low-power, low-bandwidth link layer protocol.
<!--      , over which ZigBee was originally intended to run.-->
      </t>

      <t> LoWPAN host: A node that only sources or sinks IPv6 datagrams.
      Referred to as a host in this document.</t>

      <t> LoWPAN router: A node that forwards datagrams between arbitrary
      source-destination pairs using a single 6LoWPAN interface,
      performing IP routing on that interface.</t>

      <t> LoWPAN edge router (ER): An IPv6 router that interconnects the 6LoWPAN to
      another IP network. Referred to as an Edge Router in this document.</t>

      <t> LoWPAN node: A node that composes a 6LoWPAN, referring to both hosts and
      routers. Simply called a Node in this document.</t>

</list> </t>

</section>

</section>

<section anchor="Protocol Overview" title="Protocol Overview">

   <t>      
   This section gives an overview of the TCP header compression mechanism for
   6LoWPAN (LOWPAN_TCPHC). The  main purpose of LOWPAN_TCPHC is to reduce
   the protocol header overhead, with the intent of reducing both
   bandwidth usage and energy consumption due to packet transmissions.
   </t> 
   <t> 
   Indeed, the LOWPAN_TCPHC allows establishing TCP connections between
   an external IP host and a LoWPAN host, and also between two LoWPAN hosts.
   This former type of connection is performed by an Edge Router (ER)
   which links the 6LoWPAN to an external IPv6-based network.
   <xref target="A 6LoWPAN network"></xref> shows a typical 6LoWPAN topology
   with which two edge router create a bridge between the LoWPAN network and
   the external IP network. The path between a LoWPAN node to the external 
   network may change following the movement of the node or the update of 
   routing tables.
   </t>

<figure anchor='A 6LoWPAN network' title="A 6LoWPAN network"><artwork>
                        |                  *  *
                        |                 *  *  *
                        |    +--------+  *  *  *  *  
                        |____|  Edge  | *  *  *  *  *
                        |    | Router | *  *  *  *  *
                        |    +--------+  *  *  *  *
                        |                 *  *  *
 External IP Network -- |                  *  *  *  
                        |                 *  *  *  
                        |    +--------+  *  *  *  *
                        |____|  Edge  | *  *  *  *  *
                        |    | Router | *  *  *  *  *
                        |    +--------+  *  *  *  *  
                        |                 *  *  *  
                        |                  *  *  
 *: LoWPAN Node
</artwork></figure>

   <t>
   The compression and decompression mechanisms are implemented on
   the edge routers and on the LoWPAN hosts.
   The ERs create and maintain the contexts of all TCP connections.
   <xref target="Connection initiation by outside host"></xref> and
   <xref target="Connection initiation by inside host"></xref> show
   sequence diagrams of a connection establishment between a LoWPAN
   host and an external IP host.
   The external IP host sends and receives regular TCP segments,
   whereas the LoWPAN host sends and receives segments with compressed
   headers or full headers.
   </t>

   <t>
   The LOWPAN_TCPHC algorithm does not compress TCP control messages at
   the connection establishment phase.
   These segments are used to exchange the context identifier (CID) and allow the
   ER to create a context using the TCP header fields.
   The LOWPAN_TCPHC algorithm supports usefull TCP option for LLNs.
   Supported TCP options that are negotiated in the two first messages are sent
   in a full header format. Whereas, the remaining supported options are sent
   compressed with in the TCP segments.
   The LOWPAN_TCPHC algorithm defines a compression mechanism for TCP SACK and
   Timestamp options.
   </t>
   
   <t>
   The TCP connection may also be established between two LoWPAN hosts for
   Machine-to-Machine communications. In this case, the context should
   be shared between the two LoWPAN hosts.
<!--   If a lost or corrupted packet is detected -->
   If a packet is dropped due to loss, then the mechanism refreshes the
   context by retransmitting lost segments using the mostly compressed header format.
   </t>

   <t>
   The compression protocol uses two different header formats.
   For the TCP opening phase and for error management, the TCP segments must
   be sent with a full header.
   These segments contain the Context Identifier (CID) which will be used to identify
   the connection during the transfer phase. The CID replaces
   the two port numbers, hence avoiding to send the port numbers
   in every packet.
   The CID value and its size are set by the LoWPAN host if the TCP connection
   is between a LoWPAN host and an external IP host.
   Otherwise (i.e., a TCP connection between two LoWPAN hosts), the CID
   value and its size are set by the LoWPAN host that has opened the connection.
   For the TCP connection between a LoWPAN host and an external IP host,
   the couple (CID, Ipv6 address) must be unique.
   </t>
   
   <!--
   The CID value and its size are set by the ER if the TCP connection
   is between a LoWPAN host and an external IP host, otherwise they are
   set by a LoWPAN host.
   For the TCP connection between a LoWPAN host and external IP host, The CID pairs SHOULD be unique for a destination inside the 6LoWPAN network.
   </t>

   <t>
   The CID SHOULD be set by the ER to ensure uniqueness. This field is
   added by the edge router in the ACK segment when an external IP host
   initiates the TCP connection.
   The CID MUST be sent in the ACK segment to make sure that the
   LoWPAN node is aware of the CID of the new connection.
   For in-6LoWPAN TCP communications, the CID that is finally used should be the one set in the
   third ACK segment of the three-way handshake.
   </t>
   -->
   
   <t>
  <!-- The second kind of header is the compressed header in which all static
   fields are elided. The compressed header may contains some bytes of
   dynamic fields that has not been changed since the last sent segment. -->

   The second kind of header is the compressed header in which all static
   fields are elided, and all dynamic fields are compressed.
   Depending on how they change with respect to the last sent segment,
   dynamic fields may be compressed fully (i.e., elided) or partially
   (i.e., only a portion of a field is sent, containing the bytes that
   have changed).
   </t>
   
   <t>
   The last kind of packet is sent when a packet is lost, corruption or
   reordering is detected by the TCP receiver.
   This segment is called mostly compressed header and contains dynamic
   fields with all bytes uncompressed, while its static fields are elided.
   This kind of segment should be sent after a loss of synchronization 
   between the compressor and the decompressor.
   </t>
   
<section anchor="TCP Connection Initiation" title="Connection Initiation">

   <t>
   This section gives an overview of TCP connection initiation with
   LOWPAN_TCPHC.
   </t>
    
<figure anchor="Connection initiation by outside host"
title="TCP Connection initiated by an external IP-host">
<artwork>
 External IP host          Edge Router                LoWPAN host
 |                              |                               |
 | --- SYN --&gt;                  |         --- SYN with CID=0--&gt; |
 | The LOWPAN host creates a context for the new TCP connection |
 |                                                              |
 |                              |       &lt;-- SYN/ACK with CID--- |
 | The ER creates a context using the received (CID, LoWPAN IPv6)  |
 |                              |                               |
 | &lt;-- SYN/ACK ---              |                               |
 | --- ACK --&gt;                  |          ---  ACK with CID --&gt;|
 |                              |                               |
</artwork>
</figure>
    
   <t>
   <xref target="Connection initiation by outside host"></xref> shows an
   example of a connection initiation scenario started by an external IP
   host.
   In this scenario, an external host sends a SYN segment trying to
   establish a connection with a LoWPAN host.
   The SYN message can include options, some of which may be eliminated
   by the Edge Router (i.e., those options not supported by the
   LOWPAN_TCPHC mechanism).
   The ER sends the SYN segment in a full header message with a CID
   equal to zero.
   Upon the reception of the SYN segment, the LoWPAN node sends
   a SYN/ACK segment including a new CID, set to the smallest available
   CID value. The ER creates a new context with the received information
   from the SYN/ACK segment.
   </t>
   
<figure anchor="Connection initiation by inside host"
title="TCP Connection initiated by a LoWPAN host">
<artwork>
 External IP host          Edge Router                LoWPAN host
 |                              |                               |
 |                              |           &lt;-- SYN with CID--- |
 |  The LOWPAN host creates a context and sends the SYN message |
 |                                                              |
 | &lt;-- SYN ---                  |                               |
 | The ER creates a context for the new TCP connection          |
 |                                                              |
 | --- SYN/ACK --&gt;              |      --- SYN/ACK with CID --&gt; |
 | &lt;-- ACK ---                  |          &lt;-- ACK with CID --- |
</artwork>
</figure>
   <t>
   <xref target="Connection initiation by inside host"></xref> gives an
   example of a TCP connection initiated by a LoWPAN host.
   The first SYN segment is sent with the full header with a
   CID value equal to smallest available value of CIDs.
<!--
   The LoWPAN host replays by sending a TCP SYN+ACK in full header with
   a CID equals to the maximum of its current used CIDs.
-->
   Contrary to the first case, the ER creates a context upon the
   reception of the SYN message from the LoWPAN host.
   </t>
   
<figure anchor="TCP/IPv6 connection between two LoWPAN hosts"
title="TCP/IPv6 Connection between two LoWPAN hosts">
<artwork>
   LoWPAN host                                      LoWPAN host
   |                                                           |
   |                &lt;-- SYN with CID---                        |
   | The initiator LOWPAN Host creates a context for the new   |
   | TCP connection and then sends SYN segment                 |
   |                                                           |
   |                   --- SYN/ACK with CID---&gt;                |
   | The receiver creates a context using the initiator IID    |
   |                                                           |
   |                &lt;--  ACK with CID ---                      |
</artwork >
</figure>

   <t>
   <xref target="TCP/IPv6 connection between two LoWPAN hosts"></xref> presents
   a TCP connection initiated by a LoWPAN node to another LoWPAN node.
   The LoWPAN host sends in the TCP SYN segment with a CID
   equals to the smallest available CID value.
   </t>
   
   
   <t>
   The CID value is chosen by the first LoWPAN host that is involved in
   establishing the TCP connection.
   This way, it is easy to ensure the unicity of the CID.
   At the same time, this simplifies the context management at the ERs.
   Moreover, if all CID values are used, the initiator should increase the CID
   field length from 8 bits to 16 bits.
   </t>

</section>

<section anchor="The LoWPAN_TCPHC context" title="The LoWPAN_TCPHC context">
 
<section anchor="The LoWPAN_TCPHC context structure" title="LoWPAN_TCPHC context structure">

   <t>
   The context includes some TCP header fields that are needed by the compressor
   and the decompressor algorithm.
   <xref target="struct_context"></xref> lists the contents of 
   a LOWPAN_TCPHC context.
   </t>
   
<figure anchor="struct_context" title="Structure of a LOWPAN_TCPHC context">
<artwork>
   +---------+------------------------------------+----------+
  | Field   | Description                        | Length   |
  +---------+------------------------------------+----------+
  | CID     | Context Identifier                 | 16 bits  |
  +---------+------------------------------------+----------+
  | Address | LoWPAN IPv6 address                | 128 bits |
  ---------+------------------------------------+----------+
  | SrcPort | TCP Source Port Number             | 16 bits  |
  +---------+------------------------------------+----------+
  | DstPort | TCP Destination Port Number        | 16 bits  |
  +---------+------------------------------------+----------+
  | seq_rcv | Sequence number in incoming segments | 32 bits  |
  +---------+------------------------------------+----------+
  | ack_rcv | Acknowledgment number in reception | 32 bits  |
  ---------+------------------------------------+----------+
  | wnd_rcv | Window size in reception           | 16 bits  |
  ---------+------------------------------------+----------+
  | seq_snd | Sequence number in reception       | 32 bits  |
  +---------+------------------------------------+----------+
  | ack_snd | Acknowledgment number in reception | 32 bits  |
  ---------+------------------------------------+----------+
  | wnd_snd | Window size in reception           | 16 bits  |
  ---------+------------------------------------+----------+
  | State   | Context state                      | 4 bits   |
  +---------+------------------------------------+----------+
</artwork>
</figure>

    <t>
    The address field saves the Ipv6 address of the 6LoWPAN node. If the TCP 
    connection is established between two 6LoWPAN nodes, the Ipv6 address of 
    the initiator is saved in the context.
    </t>
    
    <t>
    State field indicates in which state a TCP connection is.
    This field is especially needed by the ERs.
    The possible states of a context are: closed, using, closing, fin_1, fin_2,
    fin_3, and shutting.
    </t>
    <t>
    The CID and Ipv6 address are utilized to identify the connection for
    compressed headers. The SrcPort and DstPort, toghether with the Ipv6 adsress,
    are used to identify the connection for full headers.
    </t>
    <t>
    The seq_rcv, ack_rcv, and wnd_rcv are used to store the dynamic fields of
    the last incoming segment (except retransmitted segment).
    While the seq_snd, ack_snd, and wnd_snd are the dynamic
    fields of the last outgoing segment (except retransmitted segment).
    </t>
</section>

<section anchor="The_CID_Management" title="Context management">

   <t>
   This section describes the context management in 6LoWPAN when
   LOWPAN_TCPHC is used.
   The edge router to which a LoWPAN node host is attached may change over time,
   due to route instability or to host mobility 
   However, this change should
   not break the TCP communication. To ensure the TCP communication
   despite the change of ER, the ERs should share the contexts of
   current connections.
   So, even if a 6LoWPAN node changes its attached ER, the new ER should
   continue to compress the segments using the same context.
   Context exchange and management between ERs is out of the scope of
   this document.
   </t>

   <t>
   The edge router should free a context when a TCP connection is
   finished (e.g., reception of FIN control messages).
   The Edge Router can also free a connection after a silent period
   (i.e., when no messages are exchanged after a certain period of time).
   </t>

   <t>
    The ER may remove the context of a TCP connection that is not yet closed.
    In this case, after receiving a new data segment, the ER SHOULD
    reply by sending a RST segment to the sender.
   </t>
   
</section>

</section>

<section anchor="Loss_Detection_Retransmissions" title="Loss detection and retransmissions">

   <t>
   In this section, we present how the LOWPAN_TCPHC
   mechanism should react when a segment is lost or is assumed to be lost.
   The loss is handled when the TCP ACK segment is not received within
   the RTO.
   The ER handles a retransmission by scanning the sequence numbers.
   The ER should send a mostly compressed header segment when it
   receives an already sent segment.
   This mechanism allows updating the context on both sides after a
   packet loss.
   We assume that the 6LoWPAN has a low bit rate, and
   also that nodes are memory-constrained and thus the TCP window size 
   is probably limited to a few segments.
   In this case, the loss of synchronization will likely not lead to a burst of
   losses.
   For this reason, this document does not present a refresh algorithm
   to update the context between the compressor and the decompressor.
   </t>

<figure anchor="Loss detection in 6LoWPAN"
title="Loss detection in 6LoWPAN">
<artwork>

External IP Host           Edge Router                  LoWPAN Host
|                              |                                   |
| --- Regular DATA(124) --&gt;    |--- Compressed header DATA(124) --&gt;|
| &lt;-- Regular ACK(188)  ---    | &lt;-- Compressed header ACK(188) ---|
| --- Regular DATA(188) --&gt;    | --- Compressed header DATA(188) -X|
| Data packet (188) is lost in the LoWPAN                          |
|                              |                                   |
| The External node handles the segment loss after an RTO          |
| and retransmits the lost segment                                 |
|                              |                                   |
| --- Regular DATA(188) --&gt;    |       --- Most Comp. DATA(188) --&gt;|
| The ER compresses the retranmitted segment with a mostly         |
| compressed header                                                |
|                              |                                   |
| &lt;-- Regular ACK(252)  ---    | &lt;-- Compressed header ACK(252) ---|
| The receiver decompresses the request data segment,              |
| and finally sends an ACK to request the next segment             |
|                              |                                   |
</artwork></figure>

   <t>
   <xref target="Loss detection in 6LoWPAN"></xref> shows a scenario
   where a TCP segment is lost in the 6LoWPAN. After an RTO the enternal 
   IP host retransmits the lost segment.
   Upon the reception of the retransmitted segment, the ER
   produces a mostly compressed header allowing the LoWPAN node to
   decompress the segment.
   </t>
</section>

</section>

<section anchor="TCP" title="Transmission Control Protocol">

<t>
   This section presents more details on TCP and its header fields.
   As it has been defined in <xref target="RFC0793"></xref>, The TCP is a
   connection-oriented, end-to-end reliable transport protocol
   mostly used in IP-based networks.
   The TCP is able to transfer a continuous stream of bytes in each
   direction between two end-points by packing some number of bytes
   into segments for transmission through IP-based network.
<!--
   In general, the TCPs decide when to block and forward data at their
   own convenience.
   -->
</t>

<t>
   To ensure the end-to-end reliability, the TCP must recover data that
   is damaged, lost or delivered out-of-order. This is achieved by
   assigning a sequence number to each transmitted byte (done by the
   TCP source), and by requiring a positive acknowledgment (ACK) from
   the TCP destination.
   If the ACK is not received within the timeout interval, the data
   segment is assumed to be lost. Then, the source TCP should retransmit it.
   At the receiver, the sequence numbers are used to correctly order
   segments that may be received out of order and eliminate duplicates.
   Damaged segments are handled by adding a checksum to each segment
   transmitted, checking it at the receiver and rejecting damaged segments.
</t>

<section anchor="TCP header fields" title="TCP headers fields">

<t>
   In this section, we present a short description of TCP header fields and
   how they are handled by the compression mechanism.
   <xref target="RFC4413"></xref> provides a detailed description of TCP
   header and TCP header options.
</t>

<!--
       <texttable anchor="tcp_header_fileds"  title="TCP header fields">
           <ttcol align='left'>Field</ttcol>
           <ttcol align='left'>Size (bits)</ttcol>
           <c>Source port     </c> <c>16</c> 
           <c>Destination port</c> <c>16</c> 
           <c>Sequence Number </c> <c>32</c> 
           <c>Acknowledgment Number </c> <c>32</c> 
           <c>Data Offset </c> <c>4</c> 
           <c>Reserved </c> <c>4</c> 
           <c>CWR flag </c> <c>1</c> 
           <c>ECE flag </c> <c>1</c> 
           <c>URG flag </c> <c>1</c> 
           <c>ACK flag </c> <c>1</c> 
           <c>PSH flag </c> <c>1</c> 
           <c>RST flag </c> <c>1</c> 
           <c>SYN flag </c> <c>1</c> 
           <c>FIN flag </c> <c>1</c> 
           <c>CWR flag </c> <c>1</c> 
           <c>Window   </c> <c>16</c> 
           <c>Checksum </c> <c>16</c> 
           <c>Urgent pointer</c> <c>16</c> 
           <c>Options  </c> <c>0-352</c> 
       </texttable>
-->

<t> <list style='symbols'>

    <t> Source port (16 bits):
    This field identifies the sending port. This field will be replaced by 
    the CID in compressed headers.
    </t>

    <t> Destination port (16 bits):
    This field identifies the receiving port. This field will be replaced by
    the CID in compressed headers.
    </t>

    <t> Sequence Number (32 bits):
    The sequence number of the first data byte in this segment (except when SYN flag is set).
    If SYN is present the sequence number is the initial sequence number (ISN) and the first
    data byte is ISN+1.
<!--    Only changed bytes of this field will be sent.-->
    Only the bytes that change (respect to the previous segment) will be sent.
    If this field does not change, nothing should be sent.
    </t>

    <t> Acknowledgment number (32 bits):
    If the ACK flag is set this field contains the value of the next sequence number
    the sender of the segment is expecting to receive.
    Once a connection is established this is always sent.
    Only changed bytes of this field according to the last sent segment will be sent.
    If this field does not change, nothing should be sent.
    </t>

    <t> Reserved (4 bits):
    Reserved for future use. Must be zero. This field should not be sent in compressed segments.
    </t>

    <t>Flags (8 bits):

    <list style='hanging'>
    <t hangText="URG (1 bit):"> Urgent Pointer field contains a valid value.</t>
    <t hangText="ACK (1 bit):"> Acknowledgment field contains a valid value.</t>
    <t hangText="PSH (1 bit):"> Push.</t>
    <t hangText="RST (1 bit):"> Reset the connection.</t>
    <t hangText="SYN (1 bit):"> Synchronize sequence numbers.</t>
    <t hangText="FIN (1 bit):"> No more data from sender.</t>
    <t hangText="CWR (1 bit):"> Congestion window reduced.</t>
    <t hangText="ECE (1 bit):"> Echo the 'congestion experienced' signal in the IP header.</t>
    </list>
    <!--
    <t>
     The some flags are include in the LOWPAN_TCPHC header, the other are sent in full header segments
    </t>
    -->
    </t>

    <t>Window (16 bits):
    The number of data bytes, beginning with the one indicated in the acknowledgment field,
    the sender of this segment is willing to accept. This field is compressed
    and only the bytes that have changed are sent.
    <!-- In LOWPAN_TCPHC, two bits are used to indicates the bytes that are uncompressed. -->
    </t>

    <t> Checksum (16 bits)
    The 16-bit checksum field is used for error-checking of the header and data.
    This field is not compressed by LOWPAN_TCPHC.
    </t>

    <t> Urgent Pointer (16 bits):
    This field communicates the current value of the urgent pointer as a
    positive offset from the sequence number in this segment. The
    urgent pointer points to the sequence number of the byte following
    the urgent data. This field is only interpreted in segments with
    the URG flag set to 1.
    This field is rarely used in TCP communications.
    For this reason, the URG flag and Urgent Pointer are sent if and only if
    they are set. In this case, the segment is sent with a full header.
    </t>

</list> </t>
</section>

<section anchor="Options" title="TCP Header Options">
    <t>
    Options may occupy space at the end of the TCP header and are a multiple of
    8 bits in length.
    Options are considered for the checksum calculation.
    The most used TCP options are indicated below:

<list style='symbols'>

   <t> End of Option List (8 bits): indicates the end of the option list.</t>
   <t> No-Operation (8 bits): may be used between options.</t>
   <t> Maximum Segment Size (32 bits): the maximum segment size at the TCP which sends this segment.</t>
   <t> Window Scale Option (24 bits): indicates that the sending TCP end-host
   is prepared to perform both send and receive window scaling.</t>
   <t> SACK-Permitted (16 bits): ask for using SACK option.</t>
   <t> SACK (80-320 bits): selective acknowledgment.</t>
<!--
   <t> Echo (48 bits): this option is obsoleted by timestamp option</t>
   <t> Echo Reply (48 bits): this option is obsoleted by timestamp option</t>
-->
   <t> Timestamp (80 bits): used to compute RTT.</t>

<!--
   <t hangText="- Partial Order Connection (POC) permitted:"> </t>
   <t hangText="- POC service profile:"> </t>
   <t hangText="- CC.New:"> </t>
   <t hangText="- CC.ECHO:"> </t>
   <t hangText="- Alternate Checksum Request:"> </t>
   <t hangText="- Alternate Checksum data:"> </t>
   <t> MD5 Digest (144 bits): uses again spoofing. The option contains 16-bytes generated by MD5 algorithm</t>
-->
   
</list>
</t>

<t>
   The TCP header padding is used to ensure that the TCP header ends and
   data begins on the 32-bit boundary.
   <!-- The padding is composed of zeros.-->
</t>

</section>

</section>



<section anchor="tcp_header_compression" title="TCP header fields compression">

<t>In this section, we define the LOWPAN_TCPHC specifications for TCP header
   compression for LLNs.
   LOWPAN_TCPHC initiates the compression algorithm by exchanging a context
   identifier at the beginning of the connection.
   The compressor and decompressor store most fields of the first
   full headers as a context.
</t>

<t>
   As described in <xref target="RFC2507"></xref>,
   the context consists of the header fields whose values are constant
   or regularly increasing.
   The dynamic fields should be elided because they are the same 
   with respect to the previous header. In fact,
   it is more efficient to send fewer bits, which are the difference from
   previous value comparing to the sending of the absolute value.
   The LoWPAN_TCPHC mechanism is based on sending
   only those fields or parts of fields that do change
   with respect to the previously sent packet.
   That is why, the TCP receiver should save the last received
   segment fields to decompress the next one.
   For example, the two first bytes of the sequence number field can be
   elided if they are equal to the value of the previous segment.
</t>

<t>
   If a TCP segment is lost and must be retransmitted,
   the retransmitted segment should be sent with a mostly compressed header.
   Then, the TCPHC receiver updates the context.
</t>

<t>The TCP compression format is shown in <xref target="TCP Header Encoding" />.
   The three first bits are used to dispatch between different types of segments.
   LOWPAN_TCPHC uses two bytes which contain the uncompressed flags of TCP.
</t>

    <t>
    Source and destination port numbers are omitted and replaced by a context 
    identifier. The latter should be sent in connection initiation messages
    and replaces the source and destination port numbers.
    </t>

    <t>
    The checksum is not compressed and is used by the receiver to check if the 
    decompressed TCP segment is received correctly.
    To reduce the TCP header length, only these fields which have been changed between
    two successive segments need to be sent to the receiver. Thus,
    based on the previously received segment,  the
    receiver reconstructs the original TCP header.
    </t>

    <t>
    The urgent pointer field is transmitted only when the urgent bit is set.
    When a receiver sends a duplicated acknowledgment, LOWPAN_TCPHC can 
    compress the TCP header down to six bytes (2 bytes LOWPAN_TCPHC,
    1 byte CID, 1 byte acknowledgment number,
    2 bytes Checksum).
</t>


<section title="TCP ports" anchor="tcp_port_compression" >

<t>These fields are part of the definition of a stream and they must
   be constant for all packets in the stream.
   TCP port numbers can be elided in TCP compressed segments and replaced by a
   context identifier (CID).
   The context identifier should be generated by the
   the first involved LoWPAN node.
<!--
    and it should be sent with the last
   uncompressed TCP segment.

   The context identifier can be sent in the SYN+ACK control message
   as a TCP option.
-->
</t>

</section>

<section title="Flags" anchor="tcp_flags_compression" >

    <t>
    Some of the TCP flags are omitted because TCP control messages that set such 
    flags (SYN, PUSH) are sent uncompressed.
    The uncompressed flags are : PUSH, FIN, Congestion Window Reduced (CWR) and
    ECN-Echo indication (ECE). These flags are present in the two bytes of the
    LOWPAN_TCPHC header.
</t>
</section>

<section title="Sequence and Acknowledgment numbers" anchor="seq_ack_compression">

<t>
   The sequence number specifies the first data byte in the segment
   (except the first segment). The length of the sequence number field is
   four bytes.
</t>

<!--
<t>
   Jacobson in <xref target="RFC1144"></xref> assumes that packets are
   arriving in order.
   He proposes sending the difference between fields of segments rather than
   sending the fields themselves.
   In LoWPAN_TCPHC, the numbers sent for TCP sequence number and acknowledgment are the difference
   between the current value and the value in the previous packet.
   The lost of a packet and/or the reception of an out-of-order packets lead to
   a loss of synchronization between the compressor and the decompressor.
   In this case, the TCP engine after waiting a RTO, restarts
   the retransmission by sending a full header segment.
   The Van Jacobson's scheme is very loss- and disorder-sensitive <xref target="Wang04"></xref>.
</t>
-->

    <t>
    In a TCP connection, the sequence number is incremented for each packet
    by a value between 0 and the MSS (Maximum Segment Size).
    Thus, the less significant bytes (LSB) are expected to change mush
    frequently than the most significant bytes (MSB).
    Thus, it is often enough to send the N less-significant bytes if the 4-N
    bytes most significant bytes do not change.  
    The decompressor module can deduce the elided bytes from the previously
    received segments.
    </t>
    
    <t>
    For example: The MSS value is
    512 bytes and the current sequence number is 0x00f24512. Then, the sequence
    number of the next segment should be less or equal to 0x00f24712.
    The compressed segment can sent with only two bytes instead of sending all 4 bytes.
    The TCP sender can send two bytes 0x4712 and the TCP receives should add the
    remaining static bytes 0x00f2.
    Using this method, we reduce to about 50% the length of sequence number or
    acknowledgment number fields if the MSS value does not exceed 65535 bytes.
    </t>
   
<t>
   The sequence number can be elided if a receiver is just acknowledging data
   segments and does not send data to the source (i.e., the receiver sends a 
   pure TCP ACK).
   The same algorithm is used for the compression of the acknowledgment number
   and only bytes which are changed should be carried in-line.
   If the TCP sink does not generate data, the four bytes of the sequence number
   are omitted in all acknowledgment segments and only compressed
   acknowledgment fields should be sent.
<!--
   One of the suitable solutions for out-of-orders packets can be
   "Twice" algorithm <xref target="RFC2507"></xref>. A new sophisticated
   algorithm can be proposed to improve "Twice" algorithm. 
-->
</t>

</section>

<section anchor="tcp_win_compression" title="Window">
<t>The window field can be omitted if it does not change in time. Moreover,
   only the window field bits that have been changed should be sent. The decompression
   deduces the value of this field from the last received full segment.
</t>
</section>

<section anchor="tcp_urgent_compression" title="Urgent Pointer">

<t>
   The urgent pointer field is sent in full header format only
   if the urgent flag is set. Otherwise, this field is elided.
</t>

</section>

</section>

<section anchor="tcp_new_format" title="LOWPAN_TCPHC Packet Format">

<section anchor="TCP segment types" title="TCP segments types">
   
   <t>
   Three types of packets are used in a TCP session with header
   compression:
   
   <list style="hanging">

        <t hangText="Regular header TCP segment:">
        A normal, uncompressed header. Does not carry any CID.
        <xref target="Regular Segment stack"></xref>
        shows the packet format of a regular TCP segment.
        <figure anchor="Regular Segment stack"
                title="Regular header TCP segment">
        <artwork>
               +------------+----------+-------+
               |IPHC (NHC=0)|TCP header|Payload|
               +------------+----------+-------+
        </artwork>
        </figure>
        </t>

        <t hangText="Full header TCP segment:">
        An uncompressed header that updates or refreshes the context for a
        packet stream. It carries a CID that will be used to identify the
        context.
        <xref target="full header TCP segment"></xref>
        shows the packet format of a full header TCP segment.
        <figure anchor="full header TCP segment"
                title="Full header TCP segment">
        <artwork>
        +------------+--------+---+----------+-------+
        |IPHC (NHC=1)|00000001|CID|TCP header|Payload|
        +------------+--------+---+----------+-------+
        </artwork>
        </figure>
        </t>
<!--
        <t hangText="Mostly compressed header TCP segment:">
        A TCP segment sent to refresh only dynamic field. Especially
        requested after a packet loss or after the reception of
        an out-of-order segment.
        <xref target="Mostly compressed header TCP segment"></xref>
        shows the header stack of a mostly compressed TCP segment.
        <figure anchor="Mostly compressed header TCP segment"
                title="Mostly compressed header TCP segment">
<artwork>
      +--------------+--------------+-----+----------------+---------+
      | IPHC (NHC=1) | LOWPAN_TCPHC | CID | Dyn. TCP field | Payload |
      +--------------+--------------+-----+----------------+---------+
</artwork>
        </figure>
        </t>
-->
        <t hangText="Compressed header TCP segment:">
        <xref target="Compressed header TCP segment"></xref>
        shows the header stack of a compressed TCP segment.
        <figure anchor="Compressed header TCP segment"
                title="Compressed header TCP segment">
<artwork>
   +------------+------------+---+-----------------------+-------+
   |IPHC (NHC=1)|LOWPAN_TCPHC|CID|uncompressed TCP fields|Payload|
   +------------+------------+---+-----------------------+-------+
</artwork>
        </figure>
        </t>

      
      </list>
   </t>

</section>

<section anchor="LOWPAN_TCPHC Format" title="LOWPAN_TCPHC Format">

<figure anchor="TCP Header Encoding" title="TCP Header Encoding">
    <artwork>
  0   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 0 |Id |  Seq  |  Ack  |   W   |CWR|ECE| F | P | T | S |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    </artwork>
</figure>

<t>
<list style="hanging">

<!--
   <t hangText="DISPATCH:"> Three bits, which allow specifying up to
   seven kinds header of TCP header compression
   
        <list style="hanging">

        <t hangText="000:">
        Reserved
        </t>
        
        <t hangText="001:">
        Full header TCP segment.
        </t>

        <t hangText="010:">
        Compressed TCP header segment.
        </t>
        
        <t hangText="011:">
        Reserved
        </t>
        
        <t hangText="1xx:">
        Reserved
        </t>

      </list>

    </t>
-->
   <t hangText="Id:">Context Identifier Size

      <list style="hanging">

         <t hangText="0:">
         CID is coded in 8 bits.
         </t>

         <t hangText="1:">
         CID is coded in 16 bits.
         </t>

      </list>
   </t>

   <t hangText="Seq:">Sequence Number:

     <list style="hanging">

      <t hangText="00:">
      All 32 bits of Sequence Number are elided.
      </t>

      <t hangText="01:">
      First 8 less-significant bits of Sequence Number are carried in-line.  The
      remaining 24 bits are elided.
      </t>

      <t hangText="10:">
      First 16 less-significant bits of Sequence Number are carried in-line.  Last 
      16 bits of Sequence Number are elided.
      </t>

      <t hangText="11:">
      All 32 bits of Sequence Number are carried in-line.
      </t>

      </list>
   </t>

   <t hangText="Ack:">Acknowledgment Number:
      <list style="hanging">

         <t hangText="00:">
         All 32 bits of Acknowledgment Number are elided.
         </t>

         <t hangText="01:">
         First 8 less-significant bits of Acknowledgment Number are carried in-line.  The
         remaining 24 bits are elided.
         </t>

         <t hangText="10:">
         First 16 less-significant bits of Acknowledgment Number are carried in-line.  Last 
         16 bits of Acknowledgment Number are elided.
         </t>

         <t hangText="11:">
         All 32 bits of Acknowledgment Number are carried in-line.
         </t>

      </list>
   </t>

    <t hangText="W:">Window:

        <list style="hanging">

            <t hangText="00:">
            The Window field is elided.
            </t>

            <t hangText="01:">
            The less-significant byte of Window field is carried in-line.
            The most-significant byte is elided.
            </t>

            <t hangText="10:">
            The most-significant byte of Window field is carried in-line.
            The less-significant byte is elided.
            </t>

            <t hangText="11:">
            Full 16 bits for Window field are carried in-line.
            </t>

        </list>
    </t>

    <t hangText="F:">FIN flag.</t>
   
    <t hangText="P:">PUSH flag.</t>

    <t hangText="CWR:">Congestion Window Reduced flag.</t>

    <t hangText="ECE:">ECN-Echo flag.</t>
   
    <t hangText="T:">Set if the TCP header contains Timestamp option.</t>

    <t hangText="S:">Set if the TCP header contains SACK option.</t>

</list>
</t>

   <t>
   Fields carried in-line (in part or in whole) appear in the same order
   as they do in the TCP header format <xref target="RFC0793"></xref>.
   The TCP Length field must always be elided and it is inferred from
   lower layers using the
   6LoWPAN fragmentation header or the MAC layer header.
   </t>
</section>

<section anchor="TCP header " title="Examples of compressed TCP headers">
 
   <t>   
    In this section, we present some examples of a compressed TCP header
    using LOWPAN_TCPHC. </t>
<!--    
    <section anchor="Mostly compressed header" title="Mostly compressed header">
    <t> <xref target="Mostly compressed header TCP Header Encoding"></xref>
    represents a header of a mostly compressed segment. The sequence
    number, acknowledgment number and window size fields are carried
    in-line. The size of this header is 15 bytes.
    <figure anchor="Mostly compressed header TCP Header Encoding"
        title="Mostly compressed header TCP Header Encoding">
    <artwork>
  3  1  2  2  2 1 1  2 1 1   8      32       32        16       16
+---+-+--+--+--+-+-+-+-+-+-+---+---------+---------+-------+--------+
|010|0|11|11|11|0|0|0|1|0|0|CID|Seq.Numb.|Ack.Numb.|Windows|Checksum|
+---+-+--+--+--+-+-+-+-+-+-+---+---------+---------+-------+--------+
    </artwork>
    </figure>
    </t>
    </section>
-->    
    <section anchor="Compressed header" title="Compressed header">
    
    <t> <xref target="Compressed header TCP Header Encoding"></xref>
    represents a header of a TCP data segment whose window field has not
    changed from with respect its antecedent, the two
    bytes of the lowest bytes of the sequence number that have been changed.
    The size of this header is seven bytes.
    <figure anchor="Compressed header TCP Header Encoding"
            title="Compressed header TCP Header Encoding">
    <artwork>
   3  1  2  2  2 1 1 1 1 1 1 1 8       16         16
+---+-+--+--+--+-+-+-+-+-+-+-+---+----------+----------+
|010|0|01|00|00|0|0|0|0|0|0|0|CID|Seq.Number| Checksum |
+---+-+--+--+--+-+-+-+-+-+-+-+---+----------+----------+
    </artwork>
    </figure>
    </t>    
    </section>
    
</section>

</section>

<section title="TCP Option Compression">

<t>
   This section defines a compression method for the TCP options most likely
   to be used in 6LoWPAN. The "end of option" byte and the "no operatioon" byte
   are elided. Taking into account the caracterisctics of the LLNs, the "window 
   scale" option are not supported because it is especially needed in broadband
   network and the window size in LLNs are limited to few segments.
   The "maximum segment size" option is negociated in the first 
   control segments, thus they are not compressed. SACK option are not 
   negociated and are allowed by default.
   However, the ER can decide to allow or to deny an option sent
   in the SYN segment.
   LOWPAN_TCPHC compresses the mostly used TCP options : SACK and Timestamp.
   We assume that the SACK and Timestamp are not negotiated and used by default.
   LOWPAN_TCPHC specifies two bits for SACK and Timestamp TCP options.
   <xref target="tcp_header_option_conf" /> shows the structure of a TCP
   segment including options compressed using LOWPAN_TCPHC.
   MSS and SACK-Permitted options are sent in a SYN and they are compressed.
   The Window Scale Option (WSO) is useless in 6LoWPAN because it is more
   performance to use small windows than large windows.
   The size of the SACK option is 4 bytes and the size of Timestamp option is
   variable from 2 to 8 bytes.
</t>

<figure anchor="tcp_header_option_conf" title="TCP Header Option Configuration">
    <artwork>
+--------------+-----+----------+-------+-----------+---------+
| LOWPAN_TCPHC | CID | Com. TCP | SACK  | Timestamp | Payload |
|   Encoding   |     |  fields  | option|  option   |         |
+--------------+-----+----------+-------+-----------+---------+
    </artwork>
</figure>

<section title="Selective Acknowledgment option">

<t>
   The TCP Selective Acknowledgment option (SACK) <xref target="RFC2018"></xref>   <xref target="RFC2883"></xref>
   should be negotiated in set-up phase, then the option may
   be used when dropped segments are detected by the receiver.
   This option is to be used to convey extended acknowledgment
   information over an established connection.
   The left edge of the block can be replaced by the offset between
   the first byte of the segment and the right edge by the length of
   the block.
   The Left edge and the right edge will be coded in 16 bits.



<figure anchor="Compressed SACK option" title="Compressed SACK option">
    <artwork>
          +---------------------+----------------------+
          | Left Edge (16 bits) | Right Edge (16 bits) |
          +---------------------+----------------------+
    </artwork>
</figure>
</t>

</section >

<section title="Timestamp option">

<t>
   This option carries eight-byte timestamp fields. 
   If timestamp options <xref target="RFC1323"></xref> are
   exchanged in the connection set-up phase, they are
   expected to appear on all subsequent segments.
   This overhead added by this option can be reduced: a TCP that does not
   sent data is not interested to compute the RTTM. And thus, it can replay
   by sending only Timestamp Echo Reply field (TSecr).
   However, the Timestamp Value field (TSval) is more important for TCP
   that send data.
<!--
   Then, if the T flag and ACK flag are set, it mean that the next 4 bytes
   contain the TSecr. Otherwise, (i.e., if the ACK flag is not set)
   the 4 bytes contain the TSval.
   This optimization is only valid when a single TCP sends data.
   Otherwise, the two four-bytes should be sent.
-->
</t>

<t>
   LOWPAN_TCPHC sends only bytes that have changed since the last segment
   to reduce the size of the Timestamp field. 
   LOWPAN_TCPHC defines a bitmap field which specifies the bytes that are
   elided and the bytes that are carried in-line.
   <xref target="Compressed Timestamp option"></xref> shows the structure of the
   compressed TCP timestamp option fields.
   
<figure anchor="Compressed Timestamp option" title="Compressed Timestamp option">
    <artwork>
    +------------------+------------------+------------------+
    | Timestamp bitmap | Compressed TSval | Compressed TSecr |
    +------------------+------------------+------------------+
    </artwork>
</figure>
</t>




</section >

</section >

<section title="Acknowledgments">
<t>
This work has been funded by the Pole de Recherche Avancée en Communications (PRACom).
The authors would like to thank Patrick Maillé and Tiancong Zheng for their useful
comments on an early version of this document.
</t>
</section>

</middle>
<back>

<references>

<reference anchor="Perkins et al.">
   <front>
       <title>Dependency removal for transport protocol header compression over noisy channels</title>
       <author initials="S. J." surname="Perkins" fullname="Stephan J. Perkins">
           <organization >
           Michigan State University
           </organization>
       </author>
       <author initials="M. W." surname="Multa" fullname="Matt W. Multa">
           <organization>
           Michigan State University
        </organization>
       </author>
       <date month="June" year="1997" />
   </front>
   <seriesInfo name='International Conference on Communications' value='1997' />
</reference>

<reference anchor="Srivastava et al.">
   <front>
       <title>A study of TCP performance over wireless data networks</title>
       <author initials="A." surname="Srivastava" fullname="Arty Srivastava">
           <organization >
           Metricom
           </organization>
       </author>
       <author initials="R.J." surname="Friday" fullname="Robert J. Friday">
           <organization >
           Metricom
           </organization>
       </author>
       <author initials="M.W." surname="Ritter" fullname="Michael W. Ritter">
           <organization >
           Metricom
           </organization>
       </author>
       <author initials="W." surname="San Filippo" fullname="Will San Filippo">
           <organization >
           Metricom
           </organization>
       </author>
       <date month="May" year="2001" />
   </front>
   <seriesInfo name='Vehicular Technology Conference,' value='IEEE VTS 53rd' />

</reference>

<reference anchor="Wang04">
   <front>
       <title>An experimental study of TCP/IP's Van Jacobson header compression
	   behavior in lossy space environment</title>
       <author initials="R." surname="Wang" fullname="R. Wang">
           <organization >
           Lamar university
           </organization>
       </author>
       <date month="September" year="2004" />
   </front>
   <seriesInfo name='Vehicular Technology Conference,' value='IEEE VTC 60th' />
</reference>

<reference anchor="Medina05" target="">
	<front>
		<title>Measuring the Evolution of Transport Protocols in the Internet</title>
		
		<author initials="A." surname="Medina" fullname="A. Medina">
			<organization></organization>
		</author>
		<author initials="M." surname="Allman" fullname="M. Allman">
			<organization></organization>
		</author>
		<author initials="S." surname="Floyd" fullname="S. Floyd">
			<organization></organization>
		</author>
		
		<date year="2005" month="April" />
	</front>
	<seriesInfo name="ACM SIGCOMM Computer Communications Review" value=" 35(2):37-51" />
</reference>


<reference anchor="I-D.ietf-6lowpan-hc">
   <front>
       <title>Compression Format for IPv6 Datagrams in 6LoWPAN Networks</title>
       <author initials="J." surname="Hui" fullname="Jonathan W. Hui">
           <organization >
           Arch Rock Corp
           </organization>
       </author>
       <author initials="P." surname="Thubert" fullname="Pascal Thubert">
           <organization>
           Cisco
        </organization>
       </author>
       <date month="October" year="2009" />
   </front>
</reference>

<reference anchor="IEEE 802.15.4">
   <front>
       <title>IEEE Std. 802.15.4-2006</title>
       <author>
           <organization abbrev="ISI">
           IEEE Computer Society
           </organization>
       </author>
       <date month="October" year="2006" />
   </front>
   <seriesInfo name='IEEE Standard for Information technology-Telecommunications and information exchange between systems-Local and metropolitan area networks-' value='Specific requirements Part 15.4:
   Wireless Medium Access Control (MAC) and Physical Layer (PHY) Specifications for Low-Rate Wireless Personal Area Networks (WPANs)' />
</reference>

<reference anchor='RFC0768'>

    <front>
    <title>User Datagram Protocol</title>
    <author initials='J.' surname='Postel' fullname='J. Postel'>
    <organization>University of Southern California (USC)/Information Sciences Institute</organization>
    <address>
    <postal>
    <street>4676 Admiralty Way</street>
    <city>Marina del Rey</city>
    <region>CA</region>
    <code>90291</code>
    <country>US</country></postal>
    <phone>+1 213 822 1511</phone></address></author>
    <date year='1980' day='28' month='August' /></front>
    
    <seriesInfo name='STD' value='6' />
    <seriesInfo name='RFC' value='768' />
<format type='TXT' octets='5896' target='ftp://ftp.isi.edu/in-notes/rfc768.txt' />
</reference>

<reference anchor='RFC0793'>

        <front>
    <title abbrev='Transmission Control Protocol'>Transmission Control Protocol</title>
    <author initials='J.' surname='Postel' fullname='Jon Postel'>
    <organization>University of Southern California (USC)/Information Sciences Institute</organization>
    <address>
    <postal>
    <street>4676 Admiralty Way</street>
    <city>Marina del Rey</city>
    <region>CA</region>
    <code>90291</code>
    <country>US</country></postal></address></author>
    <date year='1981' day='1' month='September' /></front>
    
    <seriesInfo name='STD' value='7' />
    <seriesInfo name='RFC' value='793' />
    <format type='TXT' octets='172710' target='ftp://ftp.isi.edu/in-notes/rfc793.txt' />
</reference>

<reference anchor='RFC1122'>
    
    <front>
    <title>Requirements for Internet Hosts - Communication Layers</title>
    <author initials='R.' surname='Braden' fullname='Robert Braden'>
    <organization>University of Southern California (USC)/ Information Sciences Institute (ISI)</organization>
    <address>
    <postal>
    <street>4676 Admiralty Way</street>
    <city>Marina del Rey</city>
    <region>CA</region>
    <code>90292-6695</code>
    <country>US</country></postal>
    <phone>+1 213 822 1511</phone>
    <email>Braden@ISI.EDU</email></address></author>
    <date year='1989' month='October' /></front>
    
    <seriesInfo name='STD' value='3' />
    <seriesInfo name='RFC' value='1122' />
    <format type='TXT' octets='295992' target='ftp://ftp.isi.edu/in-notes/rfc1122.txt' />
</reference>

<reference anchor='RFC1144'>

    <front>
    <title abbrev='Compressing TCP/IP Headers'>Compressing TCP/IP headers for low-speed serial links</title>
    <author initials='V.' surname='Jacobson' fullname='Van Jacobson'>
    <organization>Lawrence Berkeley Laboratory, Real Time Systems Group</organization>
    <address>
    <postal>
    <street>Mail Stop 46A</street>
    <city>Berkeley</city>
    <region>CA</region>
    <code>94720</code>
    <country>US</country></postal>
    <email>van@helios.ee.lbl.gov</email></address></author>
    <date year='1990' day='1' month='February' /></front>
    
    <seriesInfo name='RFC' value='1144' />
    <format type='TXT' octets='120959' target='ftp://ftp.isi.edu/in-notes/rfc1144.txt' />
    <format type='PS' octets='534729' target='ftp://ftp.isi.edu/in-notes/rfc1144.ps' />
    <format type='PDF' octets='255616' target='ftp://ftp.isi.edu/in-notes/rfc1144.pdf' />
</reference>


<reference anchor='RFC1323'>

    <front>
    <title>TCP Extensions for High Performance</title>
    <author initials='V.' surname='Jacobson' fullname='Van Jacobson'>
    <organization>University of California Berkeley, Lawrence Berkeley Laboratory</organization>
    <address>
    <postal>
    <street>Mail Stop 46A</street>
    <city>Berkeley</city>
    <region>CA</region>
    <code>94720</code>
    <country>US</country></postal>
    <phone>+1 415 486 6411</phone>
    <email>van@CSAM.LBL.GOV</email></address></author>
    <author initials='B.' surname='Braden' fullname='Bob Braden'>
    <organization>University of Southern California (USC), Information Sciences Institute</organization>
    <address>
    <postal>
    <street>4676 Admiralty Way</street>
    <city>Marina del Rey</city>
    <region>CA</region>
    <code>90292</code>
    <country>US</country></postal>
    <phone>+1 310 822 1511</phone>
    <email>Braden@ISI.EDU</email></address></author>
    <author initials='D.' surname='Borman' fullname='Dave Borman'>
    <organization>Cray Research</organization>
    <address>
    <postal>
    <street>655-E Lone Oak Drive</street>
    <city>Eagan</city>
    <region>MN</region>
    <code>55121</code>
    <country>US</country></postal>
    <phone>+1 612 683 5571</phone>
    <email>dab@cray.com</email></address></author>
    <date year='1992' month='May' />
    <abstract>
    <t>This memo presents a set of TCP extensions to improve performance over large bandwidth*delay product paths and to provide reliable operation over very high-speed paths.  It defines new TCP options for scaled windows and timestamps, which are designed to provide compatible interworking with TCP's that do not implement the extensions.  The timestamps are used for two distinct mechanisms: RTTM (Round Trip Time Measurement) and PAWS (Protect Against Wrapped Sequences).  Selective acknowledgments are not included in this memo.</t>
    <t>This memo combines and supersedes RFC-1072 and RFC-1185, adding additional clarification and more detailed specification.  Appendix C summarizes the changes from the earlier RFCs.</t></abstract></front>
    
    <seriesInfo name='RFC' value='1323' />
    <format type='TXT' octets='84558' target='ftp://ftp.isi.edu/in-notes/rfc1323.txt' />
</reference>

<reference anchor='RFC2018'>
    <front>
    <title abbrev='TCP Selective Acknowledgment Options'>TCP Selective Acknowledgment Options</title>
    <author initials='M.' surname='Mathis' fullname='Matt Mathis'>
    <organization>Pittsburgh Supercomputing Center</organization>
    <address>
    <postal>
    <street>4400 Fifth Ave</street>
    <street>Pittsburgh</street>
    <street>PA 15213</street></postal>
    <email>mathis@psc.edu</email></address></author>
    <author initials='J.' surname='Mahdavi' fullname='Jamshid Mahdavi'>
    <organization>Pittsburgh Supercomputing Center</organization>
    <address>
    <postal>
    <street>4400 Fifth Ave</street>
    <street>Pittsburgh</street>
    <street>PA 15213</street></postal>
    <email>mahdavi@psc.edu</email></address></author>
    <author initials='S.' surname='Floyd' fullname='Sally Floyd'>
    <organization>Lawrence Berkeley National Laboratory</organization>
    <address>
    <postal>
    <street>One Cyclotron Road</street>
    <street>Berkeley</street>
    <street>CA 94720</street></postal>
    <email>floyd@ee.lbl.gov</email></address></author>
    <author initials='A.' surname='Romanow' fullname='Allyn Romanow'>
    <organization>Sun Microsystems, Inc.</organization>
    <address>
    <postal>
    <street>2550 Garcia Ave.</street>
    <street>MPK17-202</street>
    <street>Mountain View</street>
    <street>CA 94043</street></postal>
    <email>allyn@eng.sun.com</email></address></author>
    <date year='1996' month='October' />
    <area>Transport</area>
    <keyword>TCP</keyword>
    <keyword>acknowledgment</keyword>
    <keyword>transmission control protocol</keyword>
    <abstract>
    <t>
       TCP may experience poor performance when multiple packets are lost
       from one window of data.   With the limited information available
       from cumulative acknowledgments, a TCP sender can only learn about a
       single lost packet per round trip time.  An aggressive sender could
       choose to retransmit packets early, but such retransmitted segments
       may have already been successfully received.
    </t>
    <t>
       A Selective Acknowledgment (SACK) mechanism, combined with a
       selective repeat retransmission policy, can help to overcome these
       limitations.  The receiving TCP sends back SACK packets to the sender
       informing the sender of data that has been received. The sender can
       then retransmit only the missing data segments.
    </t>
    <t>
        This memo proposes an implementation of SACK and discusses its
       performance and related issues.
    </t></abstract></front>
    
    <seriesInfo name='RFC' value='2018' />
    <format type='TXT' octets='25671' target='ftp://ftp.isi.edu/in-notes/rfc2018.txt' />
    <format type='HTML' octets='43791' target='http://xml.resource.org/public/rfc/html/rfc2018.html' />
    <format type='XML' octets='30268' target='http://xml.resource.org/public/rfc/xml/rfc2018.xml' />
</reference>

<reference anchor='RFC2119'>

    <front>
    <title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials='S.' surname='Bradner' fullname='Scott Bradner'>
    <organization>Harvard University</organization>
    <address>
    <postal>
    <street>1350 Mass. Ave.</street>
    <street>Cambridge</street>
    <street>MA 02138</street></postal>
    <phone>- +1 617 495 3864</phone>
    <email>sob@harvard.edu</email></address></author>
    <date year='1997' month='March' />
    <area>General</area>
    <keyword>keyword</keyword>
    <abstract>
    <t>
       In many standards track documents several words are used to signify
       the requirements in the specification.  These words are often
       capitalized.  This document defines these words as they should be
       interpreted in IETF documents.  Authors who follow these guidelines
       should incorporate this phrase near the beginning of their document:
    
    <list>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
          "OPTIONAL" in this document are to be interpreted as described in
          RFC 2119.
    </t></list></t>
    <t>
       Note that the force of these words is modified by the requirement
       level of the document in which they are used.
    </t></abstract></front>
    
    <seriesInfo name='BCP' value='14' />
    <seriesInfo name='RFC' value='2119' />
    <format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
    <format type='HTML' octets='17491' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
    <format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>

<!--
<reference anchor='RFC2460'>

    <front>
    <title abbrev='IPv6 Specification'>Internet Protocol, Version 6 (IPv6) Specification</title>
    <author initials='S.E.' surname='Deering' fullname='Stephen E. Deering'>
    <organization>Cisco Systems, Inc.</organization>
    <address>
    <postal>
    <street>170 West Tasman Drive</street>
    <street>San Jose</street>
    <region>CA</region>
    <code>95134-1706</code>
    <country>USA</country></postal>
    <phone>+1 408 527 8213</phone>
    <facsimile>+1 408 527 8254</facsimile>
    <email>deering@cisco.com</email></address></author>
    <author initials='R.M.' surname='Hinden' fullname='Robert M. Hinden'>
    <organization>Nokia</organization>
    <address>
    <postal>
    <street>232 Java Drive</street>
    <street>Sunnyvale</street>
    <region>CA</region>
    <code>94089</code>
    <country>USA</country></postal>
    <phone>+1 408 990 2004</phone>
    <facsimile>+1 408 743 5677</facsimile>
    <email>hinden@iprg.nokia.com</email></address></author>
    <date year='1998' month='December' />
    <area>Internet</area>
    <keyword>internet protocol version 6</keyword>
    <keyword>IPv6</keyword>
    <abstract>
    <t>
       This document specifies version 6 of the Internet Protocol (IPv6),
       also sometimes referred to as IP Next Generation or IPng.
    </t></abstract></front>
    
    <seriesInfo name='RFC' value='2460' />
    <format type='TXT' octets='85490' target='ftp://ftp.isi.edu/in-notes/rfc2460.txt' />
    <format type='HTML' octets='99496' target='http://xml.resource.org/public/rfc/html/rfc2460.html' />
    <format type='XML' octets='93343' target='http://xml.resource.org/public/rfc/xml/rfc2460.xml' />
</reference>
-->

<reference anchor='RFC2507'>
    <front>
    <title>IP Header Compression</title>
    <author initials='M.' surname='Degermark' fullname='Mikael Degermark'>
    <organization>Department of Computer Science and Electrical Engineering</organization>
    <address>
    <postal>
    <street>Lulea University of Technology</street>
    <city>Lulea</city>
    <code>SE-971 87</code>
    <country>SE</country></postal>
    <phone>+46 92 091188</phone>
    <email>micke@sm.luth.se</email></address></author>
    <author initials='B.' surname='Nordgren' fullname='Bjorn Nordgren'>
    <organization>CDT/Telia Research AB</organization>
    <address>
    <postal>
    <street>Aurorum 6</street>
    <city>Lulea</city>
    <code>S-977 75</code>
    <country>SE</country></postal>
    <phone>+46 92 075400</phone>
    <!-- <email>bcn@lulea.trab.se</email> -->
    <email>bcn@cdt.luth.se</email></address></author>
    <author initials='S.' surname='Pink' fullname='Stephen Pink'>
    <organization>Department of Computer Science and Electrical Engineering</organization>
    <address>
    <postal>
    <street>Lulea University of Technology</street>
    <city>Lulea</city>
    <code>SE-971 87</code>
    <country>SE</country></postal>
    <phone>+46 92 075229</phone>
    <email>steve@sm.luth.se</email></address></author>
    <date year='1999' month='February' />
    <abstract>
    <t>This document describes how to compress multiple IP
    headers and TCP
    and UDP headers per hop over point to point links.
    The methods can be
    applied to of IPv6 base and extension headers, IPv4 headers, TCP and
    UDP headers, and encapsulated IPv6 and IPv4 headers.</t>
    <t>Headers of typical UDP or TCP packets can be compressed down to 4-7
    octets including the 2 octet UDP or TCP checksum.
    This largely
    removes the negative impact of large IP headers and allows efficient
    use of bandwidth on low and medium speed links.</t>
    <t>The compression algorithms are specifically designed to work well
    over links with nontrivial packet-loss rates.
    Several wireless and
    modem technologies result in such links.</t></abstract></front>
    
    <seriesInfo name='RFC' value='2507' />
    <format type='TXT' octets='106292' target='ftp://ftp.isi.edu/in-notes/rfc2507.txt' />
</reference>

<reference anchor='RFC2883'>

<front>
<title>An Extension to the Selective Acknowledgment (SACK) Option for TCP</title>
<author initials='S.' surname='Floyd' fullname='S. Floyd'>
<organization /></author>
<author initials='J.' surname='Mahdavi' fullname='J. Mahdavi'>
<organization /></author>
<author initials='M.' surname='Mathis' fullname='M. Mathis'>
<organization /></author>
<author initials='M.' surname='Podolsky' fullname='M. Podolsky'>
<organization /></author>
<date year='2000' month='July' />
<abstract>
<t>This note defines an extension of the Selective Acknowledgment (SACK) Option for TCP. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='2883' />
<format type='TXT' octets='35794' target='ftp://ftp.rfc-editor.org/in-notes/rfc2883.txt' />
</reference>

<reference anchor='RFC4413'>
    <front>
    <title>TCP/IP Field Behavior</title>
    <author initials='M.' surname='West' fullname='M. West'>
    <organization /></author>
    <author initials='S.' surname='McCann' fullname='S. McCann'>
    <organization /></author>
    <date year='2006' month='March' />
    <abstract>
    <t>This memo describes TCP/IP field behavior in the context of header compression.  Header compression is possible because most header fields do not vary randomly from packet to packet.  Many of the fields exhibit static behavior or change in a more or less predictable way.  When a header compression scheme is designed, it is of fundamental importance to understand the behavior of the fields in detail.  An example of this analysis can be seen in RFC 3095.  This memo performs a similar role for the compression of TCP/IP headers.  This memo provides information for the Internet community.</t></abstract></front>
    
    <seriesInfo name='RFC' value='4413' />
    <format type='TXT' octets='28435' target='ftp://ftp.rfc-editor.org/in-notes/rfc4413.txt' />
</reference>


<reference anchor='RFC4919'>
    <front>
    <title>IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals</title>
    <author initials='N.' surname='Kushalnagar' fullname='N. Kushalnagar'>
    <organization /></author>
    <author initials='G.' surname='Montenegro' fullname='G. Montenegro'>
    <organization /></author>
    <author initials='C.' surname='Schumacher' fullname='C. Schumacher'>
    <organization /></author>
    <date year='2007' month='August' />
    <abstract>
    <t>This document describes the assumptions, problem statement, and goals for transmitting IP over IEEE 802.15.4 networks.  The set of goals enumerated in this document form an initial set only.  This memo provides information for the Internet community.</t></abstract></front>

    <seriesInfo name='RFC' value='4919' />
    <format type='TXT' octets='27650' target='ftp://ftp.rfc-editor.org/in-notes/rfc4919.txt' />
</reference>

<reference anchor='RFC4944'>
    <front>
    <title>Transmission of IPv6 Packets over IEEE 802.15.4 Networks</title>
    <author initials='G.' surname='Montenegro' fullname='G. Montenegro'>
    <organization /></author>
    <author initials='N.' surname='Kushalnagar' fullname='N. Kushalnagar'>
    <organization /></author>
    <author initials='J.' surname='Hui' fullname='J. Hui'>
    <organization /></author>
    <author initials='D.' surname='Culler' fullname='D. Culler'>
    <organization /></author>
    <date year='2007' month='September' />
    <abstract>
    <t>This document describes the frame format for transmission of IPv6 packets and the method of forming IPv6 link-local addresses and statelessly autoconfigured addresses on IEEE 802.15.4 networks.  Additional specifications include a simple header compression scheme using shared context and provisions for packet delivery in IEEE 802.15.4 meshes. [STANDARDS TRACK]</t></abstract></front>

    <seriesInfo name='RFC' value='4944' />
    <format type='TXT' octets='67232' target='ftp://ftp.rfc-editor.org/in-notes/rfc4944.txt' />
</reference>

<reference anchor='RFC4995'>
   <front>
   <title>The RObust Header Compression (ROHC) Framework</title>
   <author initials='L-E.' surname='Jonsson' fullname='L-E. Jonsson'>
   <organization /></author>
   <author initials='G.' surname='Pelletier' fullname='G. Pelletier'>
   <organization /></author>
   <author initials='K.' surname='Sandlund' fullname='K. Sandlund'>
   <organization /></author>
   <date year='2007' month='July' />
   <abstract>
   <t>The Robust Header Compression (ROHC) protocol provides an efficient, flexible, and future-proof header compression concept. It is designed to operate efficiently and robustly over various link technologies with different characteristics.&lt;/t>&lt;t> The ROHC framework, along with a set of compression profiles, was initially defined in RFC 3095. To improve and simplify the ROHC specifications, this document explicitly defines the ROHC framework and the profile for uncompressed separately. More specifically, the definition of the framework does not modify or update the definition of the framework specified by RFC 3095. [STANDARDS TRACK]</t></abstract></front>
   
   <seriesInfo name='RFC' value='4995' />
   <format type='TXT' octets='87198' target='ftp://ftp.rfc-editor.org/in-notes/rfc4995.txt' />
</reference>

<reference anchor='RFC4996'>
   <front>
   <title>RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)</title>
   <author initials='G.' surname='Pelletier' fullname='G. Pelletier'>
   <organization /></author>
   <author initials='K.' surname='Sandlund' fullname='K. Sandlund'>
   <organization /></author>
   <author initials='L-E.' surname='Jonsson' fullname='L-E. Jonsson'>
   <organization /></author>
   <author initials='M.' surname='West' fullname='M. West'>
   <organization /></author>
   <date year='2007' month='July' />
   <abstract>
   <t>This document specifies a ROHC (Robust Header Compression) profile for compression of TCP/IP packets. The profile, called ROHC-TCP, provides efficient and robust compression of TCP headers, including frequently used TCP options such as Selective Acknowledgments (SACK) and Timestamps.&lt;/t>&lt;t> ROHC-TCP works well when used over links with significant error rates and long round-trip times. For many bandwidth-limited links where header compression is essential, such characteristics are common. [STANDARDS TRACK]</t></abstract></front>
   
   <seriesInfo name='RFC' value='4996' />
   <format type='TXT' octets='183113' target='ftp://ftp.rfc-editor.org/in-notes/rfc4996.txt' />
</reference>


<!--<reference anchor='ESVJHC'>
   <front>
   <title>An experimental study of TCP/IP's van jacobson header compression behavior in lossy space environment</title>
   <author initials='R.' surname='WANG' fullname='R. Wang'>
   </author>
   <date year='2004' />
   </front>
</reference>
-->



</references>

</back>
</rfc>
