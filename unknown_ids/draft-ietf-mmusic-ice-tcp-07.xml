<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc='yes'?>
<?rfc tocdepth='5'?>

<?rfc symrefs="yes"?>
<?rfc compact='yes'?>
<?rfc subcompact='no'?>

<rfc ipr="full3978" category="std">


    <front>
        <title abbrev="ICE-TCP">
TCP Candidates with Interactive Connectivity Establishment (ICE)
</title>
    
        <author initials="J.R." surname="Rosenberg"
                fullname="Jonathan Rosenberg">
            <organization>Cisco</organization>
    
            <address>
                <postal>
                    <city>Edison</city> <region>NJ</region>
                    <country>US</country>
                </postal>
    
                <email>jdrosen@cisco.com</email>
                <uri>http://www.jdrosen.net</uri>
            </address>
        </author>
    
        <date month="July" year="2008" />
    
        <area>RAI</area>
        <workgroup>MMUSIC</workgroup>
        <keyword>SIP</keyword>
        <keyword>NAT</keyword>
        <abstract>
            <t>Interactive Connectivity Establishment (ICE) defines a
mechanism for NAT traversal for multimedia communication protocols
based on the offer/answer model of session negotiation. ICE works by
providing a set of candidate transport addresses for each media
stream, which are then validated with peer-to-peer connectivity checks
based on Session Traversal Utilities for NAT (STUN). ICE provides a
general framework for describing candidates, but only defines
UDP-based transport protocols. This specification extends ICE
to TCP-based media, including the ability to offer a mix of
TCP and UDP-based candidates for a single stream.</t>
        </abstract>
    </front>

<middle>

<!-- microsoft guys comment #1: the current tcp mechanism doesn't work
when one side is behind symmetric, other is behind not-symmetric. The
guy behind the not-symmetric nat will never get a IP address that
shows up in a candidate that it can use for the suicide attempt from
the other turn server. Proposed solution is to extend TURN to include
the mapped address in the response for tcp also. -->

<!-- stun over tcp - allow RTP/TCP mux. Use contrans to frame STUN
within TCP. This allows TCP processing to be the same as UDP as far as
ICE is concerned. This allows the hack discussed in ICE - of sending
to the validated candidate right away - to work for tcp -->

<!-- main change: allow sending media to validated candidate that you
would otherwise promote to m/c-line right away, promote it at the next
opportunity -->

<!-- for relayed addresses, make sure its ok to use UDP to the TCP
allocated address -->

<!-- make sure wording is not specific to turn/stun, only uses those
as examples on how to meet specific functoinal requirements -->

<!-- there is still some vague wording in here about whether there can
be an initial active candidate for tcp; clarify when you would do this
and be less vague -->

<!-- need to add example -->

<!-- january 2007 -->

<!-- per gonzalo's note mid-december, clarify connection
management. Namely, you can close a connection at any time but SHOULD
keep it open. Clarify more differences with 4145. -->


<section title="Introduction">

<t>
Interactive Connectivity Establishment (ICE) <xref
target="I-D.ietf-mmusic-ice"/> defines a mechanism for NAT traversal
for multimedia communication protocols based on the offer/answer model
<xref target="RFC3264"/> of session negotiation. ICE works by
providing a set of candidate transport addresses for each media
stream, which are then validated with peer-to-peer connectivity checks
based on Session Traversal Utilities for NAT (STUN) <xref
target="I-D.ietf-behave-rfc3489bis"/>. However, ICE only defines
procedures for UDP-based transport protocols.</t>

<t> There are many reasons why ICE support for TCP is
important. Firstly, there are media protocols that only run over
TCP. Examples of such protocols are web and application sharing and
instant messaging <xref target="RFC4975"/>. For these protocols to
work in the presence of NAT, unless they define their own NAT
traversal mechanisms, ICE support for TCP is needed. In addition, RTP
itself can run over TCP <xref target="RFC4571"/>. Typically, it is
preferable to run RTP over UDP, and not TCP. However, in a variety of
network environments, overly restrictive NAT and firewall devices
prevent UDP-based communications altogether, but general TCP-based
communications are permitted. In such environments, sending RTP over
TCP, and thus establishing the media session, may be preferable to
having it fail altogether. With this specification, agents can gather
UDP and TCP candidates for an RTP-based stream, list the UDP ones with
higher priority, and then only use the TCP-based ones if the UDP ones
fail. This provides a fallback mechanism that allows
multimedia communications to be highly reliable.
</t>

<t>
The usage of RTP over TCP is particularly useful when combined
with Traversal Using Relay NAT
<xref target="I-D.ietf-behave-turn"/>. In this case, one of 
the agents would connect to its TURN server using TCP, and obtain a
TCP-based relayed candidate. It would offer 
this to its peer agent as a candidate. The answerer would initiate a
TCP connection towards the TURN server. When that connection is
established, media can flow over the connections, through the
TURN server. The benefit of this usage is that it only requires the agents
to make outbound TCP connections to a server on the public
network. This kind of operation is broadly interoperable through NAT
and firewall devices. Since it is a goal of ICE and this extension to
provide highly reliable communications that "just works" in as a broad
a set of network deployments as possible, this use case is particularly
important.  </t>

<t>
This specification extends ICE by defining its usage with TCP
candidates. It also defines how ICE can be used with RTP and SRTP to
provide both TCP and UDP candidates. This specification does so by
following the outline of ICE itself, and calling out the additions and
changes necessary in each section of ICE to support TCP candidates.
</t>

</section>

<section title="Overview of Operation">

<t>
The usage of ICE with TCP is relatively
straightforward. The main area 
of specification is around how and when connections are opened, and
how those connections relate to candidate pairs.
</t>

<t>
When the agents perform address allocations to gather TCP-based
candidates, three types of candidates can be obtained. These are
active candidates, passive candidates, and simultaneous-open
candidates. An active candidate is one for
which the agent will attempt to open an outbound connection, but will
not receive incoming connection requests. A passive candidate is one
for which the agent will receive incoming connection attempts, but not
attempt a connection. A simultaneous-open candidate is one for which
the agent will attempt to open a connection simultaneously with its
peer. 
</t>

<t>
Unlike UDP, there are no lite implementation defined for TCP. Instead,
an implementation that meets the criteria for a lite implementation as
discussed in Appendix A of <xref target="I-D.ietf-mmusic-ice"/> can
just uses the mechanisms defined in <xref target="RFC4145"/>, with
constraints defined here on selection of attribute values.
</t>

<t>
When gathering candidates from a host interface, the agent typically
obtains an active, passive and simultaneous-open
candidates. Similarly, communications with a STUN server will provide
server reflexive and relayed versions of all three types. Connections
to the STUN server are kept open during ICE processing.
</t>

<t>
When encoding these candidates into offers and answers, the type of
the candidate is signaled. In the case of active candidates, an IP
address and port is present, but it is meaningless, as it is ignored
by the peer. As a consequence, active candidates do not need to be
physically allocated at the time of address gathering. Rather, the
physical allocations, which occur as a consequence of a connection
attempt, occur at the time of the connectivity checks.
</t>

<t> When the candidates are paired together, active candidates are
always paired with passive, and simultaneous-open candidates with each
other. When a connectivity check is to be made on a candidate pair,
each agent determines whether it is to make a connection attempt for
this pair.
</t>

<t><list style="empty"><t> Why have both active and simultaneous-open
candidates? Why not just simultaneous-open? The reason is that NAT
treatment of simultaneous opens is currently not well defined, though
specifications are being developed to address this <xref
target="I-D.ietf-behave-tcp"/>. Some NATs block the second
TCP SYN packet or improperly process the subsequent SYNACK, which will
cause the connection attempt to fail. Therefore, if only simultaneous
opens are used, connections may often fail. Alternatively, using
unidirectional opens (where one side is active and the other is
passive) is more reliable, but will always require a relay if both
sides are behind NAT. Therefore, in the spirit of the ICE philosophy,
both are tried. Simultaneous-opens are preferred since, if it does
work, it will not require a relay even when both sides are behind a
different NAT.  </t>
</list></t>

<t>
The actual process of generating connectivity checks, managing the
state of the check list, and updating the Valid list, work identically
for TCP as they do for UDP.
</t>

<t>
ICE requires an agent to demultiplex STUN and application layer
traffic, since they appear on the same port. This demultiplexing is
described by ICE, and is done using the magic cookie and other fields
of the message.  Stream-oriented transports introduce another wrinkle,
since they require a way to frame the connection so that the
application and STUN packets can be extracted in order to determine
which is which. For this reason, TCP media streams
utilizing ICE use the basic framing provided in RFC 4571 <xref
target="RFC4571"/>, even if the application layer protocol is not
RTP. 
</t>

<t>When TLS is in use (for non-RTP traffic) or DTLS (for RTP traffic),
it runs over the RFC 4571 framing shim, so that STUN runs outside of
the D/TLS connection (D/TLS is shorthand for TLS or
DTLS). Pictorially:
</t>

<figure anchor="fig-icetcp" title="ICE TCP Stack"><artwork>
<![CDATA[
                               +----------+                               
                               |          |                               
                               |    App   |                               
                    +----------+----------+                               
                    |          |          |                               
                    |   STUN   |  D/TLS   |                               
                    +----------+----------+                               
                    |                     |                               
                    |      RFC 4571       |                               
                    +---------------------+                               
                    |                     |                               
                    |         TCP         |                               
                    +---------------------+                               
                    |                     |                               
                    |         IP          |                               
                    +---------------------+                               
]]></artwork></figure>

<t>The
implication of this is that, for any media stream protected by D/TLS,
the agent will first run ICE procedures, exchanging STUN
messages. Then, once ICE completes, D/TLS procedures begin. ICE and D/TLS
are thus "peers" in the protocol stack. The STUN messages are not sent
over the D/TLS connection, even ones sent for the purposes of keepalive
in the middle of the media session.
</t>

<t>
When an updated offer is generated by the controlling endpoint, the SDP
extensions for connection oriented media <xref target="RFC4145"/> are
used to signal that an existing connection should be used, rather than
opening a new one. 
</t>

</section>

<section title="Sending the Initial Offer">

<t>
If an offerer meets the criteria for lite as defined in Appendix A of
<xref target="I-D.ietf-mmusic-ice"/>, it omits any ICE attributes for
its TCP-based media streams. Instead, the offerer follows the
procedures defined in <xref target="RFC4145"/> for constructing the
offer. However, the offerer MUST use a setup attribute of "actpass"
for those streams. 
</t>

<t>
For offerers making use of ICE for TCP streams, the procedures below
are used.
</t>

<section anchor="sec-gather" title="Gathering Candidates">

<t>For each TCP capable media stream the agent wishes to use
(including ones, like RTP, which can either be UDP or TCP), the agent
SHOULD obtain two host candidates (each on a different port) for each
component of the media stream on each interface that the host has -
one for the simultaneous open, and one for the passive candidate. If
an agent is not capable of acting in one of these modes it would omit
those candidates. 
</t>

<t>
Providers of real-time communications services may decide that it is
preferable to have no media at all than it is to have media over
TCP. To allow for choice, it is RECOMMENDED that agents be
configurable with whether they obtain TCP candidates for real time
media. 
</t>

<t><list style="empty"> <t> Having it be configurable, and then
configuring it to be off, is far better than not having the capability
at all. An important goal of this specification is to provide a single
mechanism that can be used across all types of endpoints. As such, it
is preferable to account for provider and network variation through
configuration, instead of hard-coded limitations in an
implementation. Furthermore, network characteristics and connectivity
assumptions can, and will change over time. Just because a agent is
communicating with a server on the public network today, doesn't mean
that it won't need to communicate with one behind a NAT tomorrow. Just
because a agent is behind a NAT with endpoint indpendent mapping
today, doesn't mean that 
tomorrow they won't pick up their agent and take it to a public
network access point where there is a NAT with address and port
dependent mapping properties, or one that only
allows outbound TCP. The way to handle these cases and build a
reliable system is for agents to implement a diverse set of techniques
for allocating addresses, so that at least one of them is almost
certainly going to work in any situation. Implementors should consider
very carefully any assumptions that they make about deployments before
electing not to implement one of the mechanisms for address
allocation. In particular, implementors should consider whether the
elements in the system may be mobile, and connect through different
networks with different connectivity. They should also consider
whether endpoints which are under their control, in terms of location
and network connectivity, would always be under their control. In
environments where mobility and user control are possible, a
multiplicity of techniques is essential for reliability.   </t></list>
</t>


<t>Each agent SHOULD "obtain" an active host candidate for each
component of each TCP capable media stream on each interface that the
host has. The agent does not have to actually allocate a port for
these candidates. These candidates serve as a placeholder for the
creation of the check lists.
</t>

<t>
Next, the agent SHOULD take all host TCP candidates for a component
that have the same foundation (there will typically be two - a passive
and a simultaneous-open), and amongst them, pick two
arbitrarily. These two host candidates will be used to obtain relayed
and server reflexive candidates. To do that, the agent initiates a TCP
connection from each candidate to the TURN server (resulting in two
TCP connections). On each connection, it issues an Allocate
request. One of the resulting relayed candidate is used as a passive
relayed candidate, and the other, as a simultaneous-open relayed
candidate. In addition, the Allocate responses will provide the agent
with a server reflexive candidate for their corresponding host
candidate. 
</t>

<t>
For all of the remaining host candidates, if any, the agent only needs
to obtain server reflexive candidates. To do that, it initiates a TCP
connection from each host candidate to a STUN server, and uses a
Binding request over that connection to learn the server reflexive
candidate corresponding to that host candidate.
</t>

<t>Once the
Allocate or Binding request has completed, the agent MUST keep the TCP
connection open until ICE processing has completed. See
<xref target="sec-impl"/> for important implementation
guidelines.
</t>

<t>If a media stream is UDP-based (such as RTP), an agent MAY use an
additional host TCP candidate to request a UDP-based candidate from
a TURN server. Usage of the UDP candidate from the TURN server follows the
procedures defined in ICE for UDP candidates.
</t>

<t>Each agent SHOULD "obtain" an active relayed candidate for each
component of each TCP capable media stream on each
interface that the host has. The agent does not have to actually
allocate a port for these candidates from the relay at this
time. These candidates serve as a placeholder for the creation of the
check lists.
</t>

<t> Like its UDP counterparts, TCP-based STUN transactions are paced
out at one every Ta seconds. This pacing refers strictly to STUN
transactions (both Binding and Allocate requests). If performance of
the transaction requires establishment of a TCP connection, then the
connection gets opened when the transaction is performed. 
</t>

</section>

<section title="Prioritization">

<t>
The transport protocol itself is a criteria for choosing one
candidate over another. If a particular media stream can run over UDP
or TCP, the UDP candidates might be preferred over the TCP
candidates. This allows ICE to use the lower latency UDP connectivity
if it exists, but fallback to TCP if UDP doesn't work.
</t>

<t>
To accomplish this, the local preference SHOULD be defined as:
</t>

<figure><artwork>
<![CDATA[
local-preference = (2^12)*(transport-pref) +
                   (2^9)*(direction-pref) +
                   (2^0)*(other-pref)
]]></artwork></figure>

<t>
Transport-pref is the relative preference for candidates with this
particular transport protocol (UDP or TCP), and direction-pref is the
preference for candidates with this particular establishment
directionality (active, passive, or simultaneous-open). Other-pref is
used as a differentiator when two candidates would otherwise have
identical local preferences. 
</t>

<t>
Transport-pref MUST be between 0
and 15, with 15 being the most preferred. Direction-pref MUST be
between 0 and 7, with 7 being the most preferred. Other-pref MUST be
between 0 and 511, with 511 being the most preferred. For RTP-based
media streams, it is RECOMMENDED that UDP have a transport-pref of 15
and TCP of 6. It is RECOMMENDED that, for all
connection-oriented media, simultaneous-open candidates have a
direction-pref of 7, active of 5 and passive of 2. If any two
candidates have the same type-preference, transport-pref, and
direction-pref, they MUST have a unique other-pref. With this
specification, the only way that can happen is with multi-homed hosts,
in which case other-pref is a preference amongst interfaces.
</t>

</section>

<section title="Choosing Default Candidates">

<t>
The default candidate is chosen primarily based on the likelihood of it
working with a non-ICE peer. When media streams supporting mixed modes
(both TCP and UDP) are used with ICE, it is RECOMMENDED that, for
real-time streams (such as RTP), the default candidates be
UDP-based. However, the default SHOULD NOT be the simultaneous-open
candidate. 
</t>

<t>
If a media stream is inherently TCP-based, the agent MUST select
the active candidate as default. This ensures proper directionality of
connection establishment for NAT traversal with non-ICE implementations.
</t>

</section>

<section title="Encoding the SDP">

<t> TCP-based candidates are encoded into a=candidate lines
identically to the UDP encoding described in
<xref target="I-D.ietf-mmusic-ice"/>. However, the transport protocol
is set to "tcp-so" for TCP simultaneous-open candidates, "tcp-act" for
TCP active candidates, and "tcp-pass" for TCP passive candidates. The
addr and port encoded into the candidate attribute for active
candidates MUST be set to IP address that will be used for the
attempt, but the port MUST be set to 9 (i.e., Discard). For active
relayed candidates, the value for addr must be identical to the IP
address of a passive or simultaneous-open candidate from the same TURN
server.
</t>

<t> If the default candidate is TCP, the agent MUST include the
a=setup and a=connection attributes from RFC 4145
<xref target="RFC4145"/>, following the procedures defined there as if
ICE was not in use. In particular, if an agent is the answerer, the
a=setup attribute MUST meet the constraints in RFC 4145 based on the
value in the offer. Since an ICE-tcp offerer always uses the active candidate
as default, an ICE-tcp answerer will always use the passive attribute as
default and include the a=setup:passive attribute in the answer. 
</t>

<t>
If an agent is utilizing SRTP
<xref target="RFC3711"/>, it MAY include a mix of UDP
and TCP candidates. If ICE selects a TCP candidate pair, the agent
MUST still utilize SRTP, but run over the connection establised
by ICE. The alternative, RTP over TLS, MUST NOT be used. This allows
for the higher layer protocols (the security handshakes and media
transport) to be independent of the underlying transport protocol. In
the case of DTLS-SRTP <xref target="I-D.ietf-avt-dtls-srtp"/>, the
directionality attributes (a=setup) are utilized strictly to determine
the direction of the DTLS handshake. Directionality of the TCP
connection establishment are determined by the ICE attributes and
procedures defined here. 
</t>

<t>If an agent is securing non-RTP media over TCP/TLS, he SDP MUST be
constructed as described in RFC 4572 <xref target="RFC4572"/>. The
directionality attributes (a=setup) are utilized strictly to determine
the direction of the TLS handshake. Directionality of the TCP
connection establishment are determined by the ICE attributes and
procedures defined here.
</t>

</section>

</section>

<section title="Receiving the Initial Offer">

<section title="Verifying ICE Support">

<t>
Since this specification does not define a lite mode for ICE-tcp, a
lite implementation will include candidate attributes for its UDP
streams, but no such attributes for its TCP streams. An agent
receiving such an offer MUST proceed with ICE in this case. ICE will
be used for the UDP streams, and <xref target="RFC4145"/> procedures
will be used for the TCP streams. However, if the offer indicates a
setup direction of actpass, the answerer MUST utilize a=setup:active
in the answer. This is required to ensure proper directionality of
connection establishment to work through NAT.
</t>

<t>
Similarly, if an agent is lite, and receives an offer that includes
streams with TCP candidates, it will omit candidates from the answer
for those streams. This will cause <xref target="RFC4145"/> procedures
to be used for those streams. In this case, the offer will indicate a
direction of active, and the agent will use passive in its answer. 
</t>

</section>


<section title="Forming the Check Lists">

<t>
When forming candidate pairs, the following types of candidates can be
paired with each other:
</t>

<figure><artwork>
<![CDATA[

Local             Remote
Candidate         Candidate
----------------------------
tcp-so           tcp-so
tcp-act          tcp-pass
tcp-pass         tcp-act
]]></artwork></figure>

<t>
When the agent prunes the check list, it MUST also remove any pair for
which the local candidate is tcp-pass.
</t>

<t>
The remainder of check list processing works like the UDP case.
</t>

</section>

</section>

<section title="Connectivity Checks">

<section title="STUN Client Procedures">

<section title="Sending the Request">

<t>
When an agent wants to send a TCP-based connectivity check, it first
opens a TCP connection if none yet exists for the 5-tuple defined by
the candidate pair for which the check is to be sent. This connection
is opened from the local candidate of the pair to the remote candidate
of the pair. If the local candidate is tcp-act, the agent MUST open a
connection from the interface associated with that local
candidate. This connection MUST be opened from an unallocated
port. For host candidates, this is readily done by connecting from the
candidates interface. For relayed candidates, the agent uses the
procedures in <xref target="I-D.ietf-behave-turn"/> to initiate a new
connection from the specified interface on the TURN server.
</t>

<t>
Once the connection is established, the agent MUST utilize the shim
defined in RFC 4571 <xref target="RFC4571"/> for the duration this
connection remains open. The STUN Binding requests and responses are
sent ontop of this shim, so that the length field defined in RFC 4571
precedes each STUN message. If TLS or DTLS-SRTP is to be utilized for the media
session, the TLS or DTLS-SRTP handshakes will take place ontop of this shim as
well. However, they only start once ICE processing has completed. In
essence, the TLS or DTLS-SRTP handshakes are considered a part of the media
protocol. STUN is never run within the TLS or DTLS-SRTP session.
</t>

<t>
If the TCP connection cannot be established, the check is considered
to have failed, and a full-mode agent MUST update the pair state to
Failed in the check list.
</t>

<t>
Once the connection is established, client procedures are identical to
those for UDP candidates. Note that STUN responses received on an
active TCP candidate will typically produce a remote peer
reflexive candidate.
</t>


</section>

</section>

<section title="STUN Server Procedures">

<t>
An agent MUST be prepared to receive incoming TCP connection requests
on any host or relayed TCP candidate that is simultaneous-open or
passive. When the connection request is received, the agent MUST
accept it. The agent MUST utilize the framing defined in RFC 4571
<xref target="RFC4571"/> for the lifetime of this connection. Due to
this framing, the agent will receive data in discrete frames. Each
frame could be media (such as RTP or SRTP), TLS, DLTS, or STUN
packets. The STUN packets are extracted as described in
<xref target="sec-recvmedia"/>.
</t>

<t>
Once the connection is established, STUN server procedures are identical to
those for UDP candidates. Note that STUN requests received on a
passive TCP candidate will typically produce a remote peer
reflexive candidate.
</t>

</section>

</section>

<section title="Concluding ICE Processing">

<t>
If there are TCP candidates for a media stream, a controlling agent
MUST use a regular selection algorithm. 
</t>

<t>
When ICE processing for a media stream completes, each agent SHOULD
close all TCP connections except the one between the candidate pairs
selected by ICE.
</t>

<t><list style="empty"><t>
These two rules are related; the closure of connection on completion
of ICE implies that a regular selection algorithm has to be used. This
is because aggressive selection might cause transient pairs to be
selected. Once such a pair was selected, the agents would close the
other connections, one of which may be about to be selected as a
better choice. This race condition may result in TCP connections being
accidentally closed for the pair that ICE selects. 
</t></list></t>

</section>

<section title="Subsequent Offer/Answer Exchanges">


<section title="ICE Restarts">

<t>
If an ICE restart occurs for a media stream with TCP candidate pairs
that have been selected by ICE, the agents MUST NOT close the
connections after the restart. In the offer or answer that causes the
restart, an agent MAY include a simultaneous-open candidate whose
transport address matches the previously selected candidate. If both
agents do this, the result will be a simultaneous-open candidate pair
matching an existing TCP connection. In this case, the agents MUST NOT
attempt to open a new connection (or start new TLS or DTLS-SRTP
procedures). Instead, that existing connection is reused and STUN
checks are performed.
</t>

<t>
Once the restart completes, if the selected pair does not match the
previously selected pair, the TCP connection for the previously
selected pair SHOULD be closed by the agent. 
</t>

</section>

</section>

<section title="Media Handling">

<section title="Sending Media">

<t>
When sending media, if the selected candidate pair matches an existing TCP
connection, that connection MUST be used for sending media.
</t>

<t>
The framing defined in RFC 4571 MUST be used when sending media. For
media streams that are not RTP-based and do not normally use RFC 4571,
the agent treats the media stream as a byte stream, and assumes that
it has its own framing of some sort. It then takes an
arbitrary number of bytes from the bytestream, and places that as a
payload in the RFC 4571 frames, including the length. Next, the sender
checks to see if the resulting set of bytes would be viewed as a STUN
packet based on the rules in sections 6 and 8 of
<xref target="I-D.ietf-behave-rfc3489bis"/>. This includes a check on
the most significant two bits, the magic cookie, the length, and the
fingerprint. If, based on those rules, the bytes would be viewed as a
STUN message, the sender SHOULD utilize a different number of bytes so
that the length checks will fail. Though it is normally highly
unlikely that an arbitrary number of bytes from a bytestream would
resemble a STUN packet based on all of the checks, it can happen if
the content of the application stream happens to contain a STUN
message (for example, a file transfer of logs from a client which
includes STUN messages). 
</t>

<t>
If TLS or DTLS-SRTP procedures are being utilized to protect the media
stream, those procedures start at the point that media is permitted to
flow, as defined in the ICE specification
<xref target="I-D.ietf-mmusic-ice"/>. The TLS or DTLS-SRTP handshakes
occur ontop of the RFC 4571 shim, and are considered part of the media
stream for purposes of this specification.
</t>

</section>

<section anchor="sec-recvmedia" title="Receiving Media">

<t>
The framing defined in RFC 4571 MUST be used when receiving media. For
media streams that are not RTP-based and do not normally use RFC 4571,
the agent extracts the payload of each RFC 4571 frame, and determines
if it is a STUN or an application layer data based on the procedures
in ICE <xref target="I-D.ietf-mmusic-ice"/>. If media is being
protected with DTLS-SRTP, the DTLS, RTP and STUN packets are
demultiplexed as described in Section 3.6.2 of 
<xref target="I-D.ietf-avt-dtls-srtp"/>. 
</t>

<t>
For non-STUN data, the agent appends this to the ongoing bytestream
collected from the frames. It then parses the bytestream as if it had
been directly received over the TCP connection. This allows for
ICE-tcp to work without regard to the framing mechanism used by the
application layer protocol.
</t>

</section>

</section>

<section title="Connection Management">

<section title="Connections Formed During Connectivity Checks">

<t>
Once a TCP or TCP/TLS connection is opened by ICE for the purpose of
connectivity checks, its lifecycle depends on how it is used. If that
candidate pair is selected by ICE for usage for media, an agent SHOULD
keep the connection open until:
<list style="symbols">
<t>The session terminates</t>
<t>The media stream is removed</t>
<t>An ICE restart
takes place, resulting in the selection of a different candidate
pair. </t>
</list>
In these cases, the agent SHOULD close the connection when that event
occurs. This applies to both agents in a session, in which case
usually one of the agents will end up closing the connection first.
</t>

<t>
If a connection has been selected by ICE, an agent MAY close it
anyway. As described in the next paragraph, this will cause it to be
reopened almost immediately, and in the interim media cannot be
sent. Consequently, such closures have a negative effect and are NOT
RECOMMENDED. However, there may be cases where an agent needs to close
a connection for some reason.
</t>

<t>
If an agent needs to send media on the selected candidate pair, and
its TCP connection has closed, either on purpose or due to some error,
then:
<list style="symbols">
<t>If the agent's local candidate is tcp-act or tcp-so, it MUST reopen a
connection to the remote candidate of the selected pair.
</t>
<t>If the agent's local candidate is tcp-pass, the agent MUST await an
incoming connection request, and consequently, will not be able to
send media until it has been opened.
</t>
</list>
If the TCP connection is established, the framing of RFC 4571 is
utilized. If the agent opened the connection, it MUST send a STUN
connectivity check. An agent MUST be prepared to receive a
connectivity check over a connection it opened or accepted (note that
this is true in general; ICE requires that an agent be prepared to
receive a connectivity check at any time, even after ICE processing
completes). If an agent receives a connectivity check after
re-establishment of the connection, it MUST generate a triggered check
over that connection in response if it has not already sent a
check. Once an agent has sent a check and received a successful
response, the connection is considered Valid and media can be sent
(which includes a TLS or DTLS-SRTP session resumption or restart).
</t>

<t>
If the TCP connection cannot be established, the controlling agent
SHOULD restart ICE for this media stream. This will happen in cases
where one of the agents is behind a NAT with connection dependent
mapping properties <xref target="I-D.ietf-behave-tcp"/>. 
</t>

</section>

<section title="Connections formed for Gathering Candidates">

<t>
If the agent opened a connection to a STUN server for the purposes of
gathering a server reflexive candidate, that connection SHOULD be
closed by the client once ICE processing has completed. This happens
irregardless of whether the candidate learned from the STUN server was
selected by ICE.
</t>

<t>
If the agent opened a connection to a TURN server for the purposes of
gathering a relayed candidate, that connection MUST be kept open by
the client for the duration of the media session if:
<list style="symbols">
<t>A relayed candidate learned by the TURN server was selected by ICE, 
</t>
<t>or an active candidate established as a consequence of a Connect
  request sent through that TCP connection was selected by ICE.
</t>
</list>
Otherwise, the connection to the TURN server SHOULD be closed once ICE
processing completes.
</t>

<t>
If, despite efforts of the client, a TCP connection to a TURN server
fails during the lifetime of the media session utilizing a transport
address allocated by that server, the client SHOULD
reconnect to the TURN server, obtain a new allocation, and restart ICE
for that media stream.  
</t>

</section>

</section>

<section title="Security Considerations">

<t>
The main threat in ICE is hijacking of connections for the purposes of
directing media streams to DoS targets or to malicious users. ICE-tcp
prevents that by only using TCP connections that have been
validated. Validation requires a STUN transaction to take place over
the connection. This transaction cannot complete without both
participants knowing a shared secret exchanged in the rendezvous
protocol used with ICE, such as SIP. This shared secret, in turn, is
protected by that protocol exchange. In the case of SIP, the usage of
the sips mechanism is RECOMMENDED. When this is done, an attacker,
even if it knows or can guess the port on which an agent is listening
for incoming TCP connections, will not be able to open a connection
and send media to the agent.
</t>

<t>
A more detailed analysis of this attack and the various ways ICE
prevents it are described in <xref
target="I-D.ietf-mmusic-ice"/>. Those considerations apply to this
specification.
</t>

</section>

<section title="IANA Considerations">

<t>
There are no IANA considerations associated with this specification.
</t>

</section>

<section title="Acknowledgements">

<t>
The authors would like to thank Tim Moore, Saikat Guha, Francois Audet and Roni
Even for the reviews and input on this document.
</t>

</section>

</middle>

<back>
<references title="Normative References">
<?rfc include="reference.I-D.ietf-behave-rfc3489bis"?>
<?rfc include="reference.RFC.3264"?>
<?rfc include="reference.RFC.4145"?>
<?rfc include="reference.RFC.4571"?>
<?rfc include="reference.RFC.4572"?>
<?rfc include="reference.I-D.ietf-mmusic-ice"?>
<?rfc include="reference.I-D.ietf-avt-dtls-srtp"?>
<?rfc include="reference.I-D.ietf-behave-turn"?>
<?rfc include="reference.RFC.3711"?>
</references>

<references title="Informative References">
<?rfc include="reference.I-D.ietf-behave-tcp"?>
<?rfc include="reference.RFC.4975"?>

</references>

</back>

<section anchor="sec-impl" title="Implementation Considerations for
				  BSD Sockets">

<t>
This specification requires unusual handling of TCP connections, the
implementation of which in traditional BSD socket APIs is
non-trivial. 
</t>

<t>
In particular, ICE requirs an agent to obtain a local TCP candidate,
bound to a local IP and port, and then from that local port, initiate
a TCP connection (to the STUN server, in order to obtain server
reflexive candidates, to the TURN server, to obtain a relayed
candidate, or to the peer as part of a connectivity check),
and be prepared to receive incoming TCP connections (for passive and
simultaneous-open candidates). A "typical" BSD socket is used either
for initiating or receiving connections, and not for
both. The code required to allow incoming and outgoing connections on
the same local IP and port is non-obvious. The following pseudocode,
contributed by Saikat Guha, has been found to work on many platforms: 
</t>

<figure><artwork>
<![CDATA[
for i in 0 to MAX
   sock_i = socket()
   set(sock_i, SO_REUSEADDR)
   bind(sock_i, local)

listen(sock_0)
connect(sock_1, stun)
connect(sock_2, remote_a)
connect(sock_3, remote_b)
]]></artwork></figure>

<t>
The key here is that, prior to the listen() call, the full set of
sockets that need to be utilized for outgoing connections must be
allocated and bound to the local IP address and port. This number,
MAX, represents the maximum number of TCP connections to different
destinations that might need to be established from the same local
candidate. This number can be potentially large for simultaneous-open
candidates. If a request forks, ICE procedures may take place with
multiple peers. Furthermore, for each peer, connections would need to
be established to each passive or simultaneous-open candidate for the
same component. If we assume a worst case of 5 forked branches, and
for each peer, five simultaneous-open candidates, that results in
MAX=25. For a passive candidate, MAX is equal to the number of STUN
servers, since the agent only initiates TCP connections on a passive
candidate to its STUN server. 
</t>

</section>
</rfc>

