<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc3411 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3411.xml">
<!ENTITY rfc3412 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3412.xml">
<!ENTITY __reference.RFC.3414__evo974gq SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3414.xml">
<!ENTITY rfc3417 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3417.xml">
<!ENTITY __reference.RFC.2865__evn5qyl1 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2865.xml">
<!ENTITY rfc3410 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3410.xml">
<!ENTITY rfc3584 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3584.xml">
<!ENTITY __reference.RFC.4346__evn5pqv9 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4346.xml">
<!ENTITY rfc4422 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4422.xml">
<!ENTITY __reference.RFC.4251__evn67u9c SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4251.xml">
<!ENTITY rfc4741 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4741.xml">
<!ENTITY I-D.ietf-isms-transport-security-model SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-isms-transport-security-model.xml">
<!ENTITY I-D.ietf-isms-secshell SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-isms-secshell.xml">
]>
<?rfc toc="yes"?>
<?rfc compact="yes"?>
<?rfc symrefs="yes" ?>
<?rfc strict="yes" ?>
<?rfc rfcedstyle="yes" ?>
<rfc category="std" docName="draft-ietf-isms-tmsm-11" ipr="full3978"
     updates="3411,3412,3414,3417">
  <!--
  $Id: draft-ietf-isms-tmsm.xml,v 1.20 2007/09/15 16:15:04 H73653 Exp $
  -->

  <front>
    <title abbrev="SNMP Transport Subsystem">Transport Subsystem for the
    Simple Network Management Protocol (SNMP)</title>

    <author fullname="David Harrington" initials="D." surname="Harrington">
      <organization>Huawei Technologies (USA)</organization>

      <address>
        <postal>
          <street>1700 Alma Dr. Suite 100</street>

          <city>Plano, TX 75075</city>

          <country>USA</country>
        </postal>

        <phone>+1 603 436 8634</phone>

        <email>dharrington@huawei.com</email>
      </address>
    </author>

    <author fullname="Juergen Schoenwaelder" initials="J."
            surname="Schoenwaelder">
      <organization>Jacobs University Bremen</organization>

      <address>
        <postal>
          <street>Campus Ring 1</street>

          <city>28725 Bremen</city>

          <country>Germany</country>
        </postal>

        <phone>+49 421 200-3587</phone>

        <email>j.schoenwaelder@iu-bremen.de</email>
      </address>
    </author>

    <date year="2007" />

    <area>Operations and Management</area>

    <!-- <workgroup>ISMS WG</workgroup> -->

    <keyword>Network Management</keyword>

    <keyword>Simple Network Management Protocol</keyword>

    <keyword>SNMP</keyword>

    <keyword>SNMP-TRANSPORT-MIB</keyword>

    <abstract>
      <t>This document defines a Transport Subsystem, extending the Simple
      Network Management Protocol (SNMP) architecture defined in RFC 3411.
      This document defines a subsystem to contain Transport Models,
      comparable to other subsystems in the RFC3411 architecture. As work is
      being done to expand the transport to include secure transport such as
      SSH and TLS, using a subsystem will enable consistent design and
      modularity of such Transport Models. This document identifies and
      describes some key aspects that need to be considered for any Transport
      Model for SNMP.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>This document defines a Transport Subsystem, extending the Simple
      Network Management Protocol (SNMP) architecture defined in <xref
      target="RFC3411"></xref>. This document identifies and describes some
      key aspects that need to be considered for any Transport Model for
      SNMP.</t>

      <section title="The Internet-Standard Management Framework">
        <t>For a detailed overview of the documents that describe the current
        Internet-Standard Management Framework, please refer to section 7 of
        RFC 3410 <xref target="RFC3410"></xref>.</t>
      </section>

      <section title="Where this Extension Fits">
        <t>It is expected that readers of this document will have read RFC3410
        and RFC3411, and have a general understanding of the functionality
        defined in RFCs 3412-3418.</t>

        <t>The "Transport Subsystem" is an additional component for the SNMP
        Engine depicted in RFC3411, section 3.1.</t>

        <figure>
          <preamble>The following diagram depicts its place in the RFC3411
          architecture.:</preamble>

          <artwork><![CDATA[
   +-------------------------------------------------------------------+
   |  SNMP entity                                                      |
   |                                                                   |
   |  +-------------------------------------------------------------+  |
   |  |  SNMP engine (identified by snmpEngineID)                   |  |
   |  |                                                             |  |
   |  |  +------------+                                             |  |
   |  |  | Transport  |                                             |  |
   |  |  | Subsystem  |                                             |  |
   |  |  +------------+                                             |  |
   |  |                                                             |  |
   |  |  +------------+ +------------+ +-----------+ +-----------+  |  |
   |  |  | Dispatcher | | Message    | | Security  | | Access    |  |  |
   |  |  |            | | Processing | | Subsystem | | Control   |  |  |
   |  |  |            | | Subsystem  | |           | | Subsystem |  |  |
   |  |  +------------+ +------------+ +-----------+ +-----------+  |  |
   |  +-------------------------------------------------------------+  |
   |                                                                   |
   |  +-------------------------------------------------------------+  |
   |  |  Application(s)                                             |  |
   |  |                                                             |  |
   |  |  +-------------+  +--------------+  +--------------+        |  |
   |  |  | Command     |  | Notification |  | Proxy        |        |  |
   |  |  | Generator   |  | Receiver     |  | Forwarder    |        |  |
   |  |  +-------------+  +--------------+  +--------------+        |  |
   |  |                                                             |  |
   |  |  +-------------+  +--------------+  +--------------+        |  |
   |  |  | Command     |  | Notification |  | Other        |        |  |
   |  |  | Responder   |  | Originator   |  |              |        |  |
   |  |  +-------------+  +--------------+  +--------------+        |  |
   |  +-------------------------------------------------------------+  |
   |                                                                   |
   +-------------------------------------------------------------------+

]]></artwork>
        </figure>

        <t></t>

        <t>The transport mappings defined in RFC3417 do not provide
        lower-layer security functionality, and thus do not provide
        transport-specific security parameters. This document updates RFC3411
        and RFC3417 by defining an architectural extension and ASIs that
        transport mappings (models) can use to pass transport-specific
        security parameters to other subsystems, including transport-specific
        security parameters translated into transport-independent securityName
        and securityLevel parameters</t>

        <t>The Transport Security Model <xref
        target="I-D.ietf-isms-transport-security-model"></xref> and the Secure
        Shell Transport Model <xref target="I-D.ietf-isms-secshell"></xref>
        utilize the Transport Subsystem. The Transport Security Model is an
        alternative to the existing SNMPv1 Security Model <xref
        target="RFC3584"></xref>, the SNMPv2c Security Model <xref
        target="RFC3584"></xref>, and the User-based Secutiry Model <xref
        target="RFC3414"></xref>. The Secure Shell Transport Model is an
        alternative to existing transport mappings (or models) as described in
        <xref target="RFC3417"></xref>.</t>
      </section>

      <section title="Conventions">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in RFC 2119 <xref
        target="RFC2119"></xref>.</t>

        <t>Non uppercased versions of the keywords should be read as in normal
        English. They will usually, but not always, be used in a context
        relating to compatibility with the RFC3411 architecture or the
        subsystem defined here, but which might have no impact on on-the-wire
        compatibility. These terms are used as guidance for designers of
        proposed IETF models to make the designs compatible with RFC3411
        subsystems and Abstract Service Interfaces (see section 3.2).
        Implementers are free to implement differently. Some usages of these
        lowercase terms are simply normal English usage.</t>

        <t>For consistency with SNMP-related specifications, this document
        favors terminology as defined in STD62 rather than favoring
        terminology that is consistent with non-SNMP specifications that use
        different variations of the same terminology. This is consistent with
        the IESG decision to not require the SNMPv3 terminology be modified to
        match the usage of other non-SNMP specifications when SNMPv3 was
        advanced to Full Standard.</t>
      </section>
    </section>

    <section title="Motivation">
      <t>Just as there are multiple ways to secure one's home or business, in
      a continuum of alternatives, there are multiple ways to secure a network
      management protocol. Let's consider three general approaches.</t>

      <t>In the first approach, an individual could sit on his front porch
      waiting for intruders. In the second approach, he could hire an employee
      , schedule the employee, position the employee to guard what he wants
      protected, hire a second guard to cover if the first gets sick, and so
      on. In the third approach, he could hire a security company, tell them
      what he wants protected, and they could hire employees, train them,
      position the guards, schedule the guards, send a replacement when a
      guard cannot make it, etc., thus providing the desired security, with no
      significant effort on his part other than identifying requirements and
      verifying the quality of the service being provided.</t>

      <t>The User-based Security Model (USM) as defined in <xref
      target="RFC3414"></xref> largely uses the first approach - it provides
      its own security. It utilizes existing mechanisms (e.g., SHA), but
      provides all the coordination. USM provides for the authentication of a
      principal, message encryption, data integrity checking, timeliness
      checking, etc.</t>

      <t>USM was designed to be independent of other existing security
      infrastructures. USM therefore requires a separate principal and key
      management infrastructure. Operators have reported that deploying
      another principal and key management infrastructure in order to use
      SNMPv3 is a deterrent to deploying SNMPv3. It is possible to use
      external mechanisms to handle the distribution of keys for use by USM.
      The more important issue is that operators wanted to leverage a single
      user base that wasn't specific to SNMP.</t>

      <t>A solution based on the second approach might use a USM-compliant
      architecture, but combine the authentication mechanism with an external
      mechanism, such as RADIUS <xref target="RFC2865"></xref>, to provide the
      authentication service. It might be possible to utilize an external
      protocol to encrypt a message, to check timeliness, to check data
      integrity, etc. It is difficult to cobble together a number of
      subcontracted services and coordinate them however, because it is
      difficult to build solid security bindings between the various services,
      and potential for gaps in the security is significant.</t>

      <t>A solution based on the third approach might utilize one or more
      lower-layer security mechanisms to provide the message-oriented security
      services required. These would include authentication of the sender,
      encryption, timeliness checking, and data integrity checking. There are
      a number of IETF standards available or in development to address these
      problems through security layers at the transport layer or application
      layer, among them TLS <xref target="RFC4346"></xref>, SASL <xref
      target="RFC4422"></xref>, and SSH <xref target="RFC4251"></xref>.</t>

      <t>From an operational perspective, it is highly desirable to use
      security mechanisms that can unify the administrative security
      management for SNMPv3, command line interfaces (CLIs) and other
      management interfaces. The use of security services provided by lower
      layers is the approach commonly used for the CLI, and is also the
      approach being proposed for NETCONF <xref target="RFC4741"></xref>.</t>

      <t>This document defines a Transport Subsystem extension to the RFC3411
      architecture based on the third approach. This extension specifies how
      other lower layer protocols with common security infrastructures can be
      used underneath the SNMP protocol and the desired goal of unified
      administrative security can be met.</t>

      <t>This extension allows security to be provided by an external protocol
      connected to the SNMP engine through an SNMP Transport Model <xref
      target="RFC3417"></xref>. Such a Transport Model would then enable the
      use of existing security mechanisms such as (TLS) <xref
      target="RFC4346"></xref> or SSH <xref target="RFC4251"></xref> within
      the RFC3411 architecture.</t>

      <t>There are a number of Internet security protocols and mechanisms that
      are in wide spread use. Many of them try to provide a generic
      infrastructure to be used by many different application layer protocols.
      The motivation behind the Transport Subsystem is to leverage these
      protocols where it seems useful.</t>

      <t>There are a number of challenges to be addressed to map the security
      provided by a secure transport into the SNMP architecture so that SNMP
      continues to provide interoperability with existing implementations.
      These challenges are described in detail in this document. For some key
      issues, design choices are described that might be made to provide a
      workable solution that meets operational requirements and fits into the
      SNMP architecture defined in <xref target="RFC3411"></xref>.</t>
    </section>

    <!-- ********************************************* -->

    <section title="Requirements of a Transport Model">
      <!-- **************************************************** -->

      <section title="Message Security Requirements">
        <t>Transport security protocols SHOULD provide protection against the
        following message-oriented threats <xref target="RFC3411"></xref>:</t>

        <t><list style="numbers">
            <t>modification of information</t>

            <t>masquerade</t>

            <t>message stream modification</t>

            <t>disclosure</t>
          </list></t>

        <t>These threats are described in section 1.4 of <xref
        target="RFC3411"></xref>. It is not required to protect against denial
        of service or traffic analysis, but it should not make those threats
        significantly worse.</t>

        <section title="Security Protocol Requirements">
          <t>There are a number of standard protocols that could be proposed
          as possible solutions within the Transport Subsystem. Some factors
          SHOULD be considered when selecting a protocol.</t>

          <t>Using a protocol in a manner for which it was not designed has
          numerous problems. The advertised security characteristics of a
          protocol might depend on it being used as designed; when used in
          other ways, it might not deliver the expected security
          characteristics. It is recommended that any proposed model include a
          description of the applicability of the Transport Model.</t>

          <t>A Transport Model SHOULD require no modifications to the
          underlying protocol. Modifying the protocol might change its
          security characteristics in ways that would impact other existing
          usages. If a change is necessary, the change SHOULD be an extension
          that has no impact on the existing usages. Any Transport Model
          SHOULD include a description of potential impact on other usages of
          the protocol.</t>

          <t>Transport Models MUST be able to coexist with each other.</t>
        </section>
      </section>

      <section title="SNMP Requirements">
        <t></t>

        <section title="Architectural Modularity Requirements">
          <t>SNMP version 3 (SNMPv3) is based on a modular architecture
          (defined in <xref target="RFC3411"></xref> section 3) to allow the
          evolution of the SNMP protocol standards over time, and to minimize
          side effects between subsystems when changes are made.</t>

          <t>The RFC3411 architecture includes a Security Subsystem for
          enabling different methods of providing security services, a Message
          Processing Subsystem permitting different message versions to be
          handled by a single engine, Applications(s) to support different
          types of application processors, and an Access Control Subsystem for
          allowing multiple approaches to access control. The RFC3411
          architecture does not include a subsystem for Transport Models,
          despite the fact there are multiple transport mappings already
          defined for SNMP. This document addresses the need for a Transport
          Subsystem compatible with the RFC3411 architecture. As work is being
          done to expand the transport to include secure transport such as SSH
          and TLS, using a subsystem will enable consistent design and
          modularity of such Transport Models.</t>

          <t>The design of this Transport Subsystem accepts the goals of the
          RFC3411 architecture defined in section 1.5 of <xref
          target="RFC3411"></xref>. This Transport Subsystem uses a modular
          design that will permit Transport Models to be advanced through the
          standards process independently of other Transport Models, and
          independent of other modular SNMP components as much as
          possible.</t>

          <t>Parameters have been added to the ASIs to pass model-independent
          transport address information.</t>

          <t>IETF standards typically require one mandatory to implement
          solution, with the capability of adding new mechanisms in the
          future. Part of the motivation of developing Transport Models is to
          develop support for secure transport protocols, such as a Transport
          Model that utilizes the Secure Shell protocol. Any Transport Model
          SHOULD define one minimum-compliance security mechanism, such as
          certificates, to ensure a basic level of interoperability, but
          should also be able to support additional existing and new
          mechanisms.</t>

          <t>The Transport Subsystem permits multiple transport protocols to
          be "plugged into" the RFC3411 architecture, supported by
          corresponding Transport Models, including models that are
          security-aware.</t>

          <t>The RFC3411 architecture and the Security Subsystem assume that a
          Security Model is called by a Message Processing Model and will
          perform multiple security functions within the Security Subsystem. A
          Transport Model that supports a secure transport protocol might
          perform similar security functions within the Transport Subsystem. A
          Transport Model might perform the translation of transport security
          parameters to/from security-model-independent parameters.</t>

          <t>To accommodate this, an implementation-specific cache of
          transport-specific information will be described (not shown), and
          the data flows between the Transport Subsystem and the Transport
          Dispatch, between the Message Dispatch and the Message Processing
          Subsystem, and between the Message Processing Subsystem and the
          Security Subsystem will be extended to pass
          security-model-independent values. New Security Models may also be
          defined that understand how to work with the modified ASIs and the
          cache. One such Security Model, the Transport Security Model, is
          defined in <xref
          target="I-D.ietf-isms-transport-security-model"></xref></t>

          <figure>
            <preamble>The following diagram depicts the SNMPv3 architecture
            including the new Transport Subsystem defined in this document,
            and a new Transport Security Model defined in <xref
            target="I-D.ietf-isms-transport-security-model"></xref>.</preamble>

            <artwork><![CDATA[
+------------------------------+
|    Network                   |
+------------------------------+
   ^       ^              ^
   |       |              |
   v       v              v                 
+-------------------------------------------------------------------+
| +--------------------------------------------------+              |
| |  Transport Subsystem                             |              |
| | +-----+ +-----+ +-----+ +-----+       +-------+  |              |
| | | UDP | | TCP | | SSH | | TLS | . . . | other |  |              |
| | +-----+ +-----+ +-----+ +-----+       +-------+  |              |
| +--------------------------------------------------+              |
|              ^                                                    |
|              |                                                    |
| Dispatcher   v                                                    |
| +-------------------+ +---------------------+  +----------------+ |
| | Transport         | | Message Processing  |  | Security       | |
| | Dispatch          | | Subsystem           |  | Subsystem      | |
| |                   | |     +------------+  |  | +------------+ | |
| |                   | |  +->| v1MP       |<--->| | USM        | | |
| |                   | |  |  +------------+  |  | +------------+ | |
| |                   | |  |  +------------+  |  | +------------+ | |
| |                   | |  +->| v2cMP      |<--->| | Transport  | | |
| | Message           | |  |  +------------+  |  | | Security   | | |
| | Dispatch    <--------->|  +------------+  |  | | Model      | | |
| |                   | |  +->| v3MP       |<--->| +------------+ | |
| |                   | |  |  +------------+  |  | +------------+ | |
| | PDU Dispatch      | |  |  +------------+  |  | | Other      | | |
| +-------------------+ |  +->| otherMP    |<--->| | Model(s)   | | |
|              ^        |     +------------+  |  | +------------+ | |
|              |        +---------------------+  +----------------+ |
|              v                                                    |
|      +-------+-------------------------+---------------+          |
|      ^                                 ^               ^          |
|      |                                 |               |          |
|      v                                 v               v          |
| +-------------+   +---------+   +--------------+  +-------------+ |
| |   COMMAND   |   | ACCESS  |   | NOTIFICATION |  |    PROXY    | |
| |  RESPONDER  |<->| CONTROL |<->|  ORIGINATOR  |  |  FORWARDER  | |
| | application |   |         |   | applications |  | application | |
| +-------------+   +---------+   +--------------+  +-------------+ |
|      ^                                 ^                          |
|      |                                 |                          |
|      v                                 v                          |
| +----------------------------------------------+                  |
| |             MIB instrumentation              |      SNMP entity |
+-------------------------------------------------------------------+
              ]]></artwork>

            <postamble></postamble>
          </figure>

          <section title="Processing Differences between USM and Secure Transport">
            <t>USM and secure transports differ in the processing order and
            responsibilities within the RFC3411 architecture. While the steps
            are the same, they occur in a different order, and may be done by
            different subsystems. With USM and some other Security Models,
            security processing starts when the Message Processing Model
            decodes portions of the encoded message to extract security
            parameters and header parameters that identify which Security
            Model should process the message to perform authentication,
            decryption, timeliness checking, integrity checking, and
            translation of parameters to model-independent parameters. A
            secure transport performs those security functions on the message,
            before the message is decoded.</t>
          </section>

          <section title="Passing Information between Engines">
            <t>A secure Transport Model will establish an authenticated and/or
            encrypted tunnel between the Transport Models of two SNMP engines.
            After a transport layer tunnel is established, then SNMP messages
            can be sent through the tunnel from one SNMP engine to the other
            SNMP engine. Transport Models MAY support sending multiple SNMP
            messages through the same tunnel.</t>
          </section>
        </section>

        <section title="Access Control Requirements">
          <t>RFC3411 made some design decisions related to the support of an
          Access Control Subsystem. These include establishing and passing in
          a model-independent manner the securityModel, securityName and
          securityLevel parameters, and separating message authentication from
          data access authorization.</t>

          <section title="securityName and securityLevel Mapping">
            <t>SNMP data access controls are expected to work on the basis of
            who can perform what operations on which subsets of data, and
            based on the security services that will be provided to secure the
            data in transit. The securityModel and securityLevel parameters
            establish the protections for transit - whether authentication and
            privacy services will be or have been applied to the message. The
            securityName is a model-independent identifier of the security
            "principal",</t>

            <t>The Message Processing Subsystem relies on a Security Model,
            such as USM, to play a role in security that goes beyond
            protecting the message - it provides a mapping between the
            security-model-specific principal for an incoming message to a
            security-model independent securityName which can be used for
            subsequent processing, such as for access control. The
            securityName is mapped from a mechanism-specific identity, and
            this mapping must be done for incoming messages by the Security
            Model before it passes securityName to the Message Processing
            Model via the processIncoming ASI.</t>

            <t>A Security Model is also responsible to specify, via the
            securityLevel parameter, whether incoming messages have been
            authenticated and/or encrypted, and to ensure that outgoing
            messages are authenticated and/or encrypted based on the value of
            securityLevel.</t>

            <t>A translation from a mechanism-specific identity to a
            securityName might be done by a Transport Model, and the proposed
            securityName and a proposed securityLevel might then be made
            available to a Security Model via the tmStateReference. A Security
            Model may have multiple sources for determining the principal and
            desired security services, and a particular Security Model may or
            may not utilize the securityName mapping and securityLevel made
            available by the Transport Model when deciding the value of the
            securityName and securityLevel to be passed to the Message
            Processing Model.</t>
          </section>

          <!-- **************************************************** -->
        </section>

        <section title="Security Parameter Passing Requirements">
          <t>RFC3411 section 4 describes abstract data flows between the
          subsystems, models and applications within the architecture.
          Abstract Service Interfaces describe the flow of data, passing
          model-independent information between subsystems within an engine.
          The RFC3411 architecture has no ASI parameters for passing security
          information between the Transport Subsystem and the dispatcher, or
          between the dispatcher and the Message Processing Model. This
          document defines or modifies ASIs for this purpose.</t>

          <t>A Message Processing Model might unpack SNMP-specific security
          parameters from an incoming message before calling a specific
          Security Model to authenticate and decrypt an incoming message,
          perform integrity checking, and translate security-model-specific
          parameters into model-independent parameters. When using a secure
          Transport Model, some security parameters might be provided through
          means other than carrying them in the SNMP message; some of the
          parameters for incoming messages might be extracted from the
          transport layer by the Transport Model before the message is passed
          to the Message Processing Subsystem.</t>

          <t>This document describes a cache mechanism (see Section 5), into
          which the Transport Model puts information about the transport and
          security parameters applied to a transport connection or an incoming
          message, and a Security Model may extract that information from the
          cache. A tmStateReference is passed as an extra parameter in the
          ASIs of the Transport Subsystem and the Message Processing and
          Security Subsystems, to identify the relevant cache. This approach
          of passing a model-independent reference is consistent with the
          securityStateReference cache already being passed around in the
          RFC3411 ASIs.</t>

          <t>For outgoing messages, even when a secure Transport Model will
          provide the security services, a Message Processing Model might have
          a Security Model actually create the message from its component
          parts. Whether there are any security services provided by the
          Security Model for an outgoing message is security-model-dependent.
          For incoming messages, even when a secure Transport Model provides
          security services, a Security Model might provide some security
          functionality that can only be provided after the message version or
          other parameters are extracted from the message.</t>
        </section>

        <section title="Separation of Authentication and Authorization">
          <t>The RFC3411 architecture defines a separation of authentication
          and the authorization to access and/or modify MIB data. A set of
          model-independent parameters (securityModel, securityName, and
          securityLevel) are passed between the Security Subsystem, the
          applications, and the Access Control Subsystem.</t>

          <t>This separation was a deliberate decision of the SNMPv3 WG, to
          allow support for authentication protocols which did not provide
          data access authorization capabilities, and to support data access
          authorization schemes, such as VACM, that do not perform their own
          authentication. This decision also permits different types of data
          access policies, such as one built on UNIX groups or Windows
          domains. The VACM approach is based on administrator-defined groups
          of users.</t>

          <t>A Message Processing Model determines which Security Model is
          used, either based on the message version, e.g., SNMPv1 and SNMPv2c,
          and possibly by a value specified in the message, e.g., SNMPv3.</t>

          <t>The Security Model makes the decision which securityName and
          securityLevel values are passed as model-independent parameters to
          an application, which then passes them via the isAccessAllowed ASI
          to the Access Control Subsystem.</t>

          <t>An Access Control Model performs the mapping from the
          model-independent security parameters to a policy within the Access
          Control Model that is access-control-model-dependent.</t>

          <t>A Transport Model does not know which securityModel will be used
          for an incoming message, so a Transport Model cannot know how the
          securityName and securityLevel parameters are determined. A
          Transport Model can provide a mapping from a transport-specific
          identity and provide candidate values for the securityName and
          securityLevel, but there is no guarantee the transport-provided
          values will be used by the Security Model.</t>

          <t>For example, the SNMPv1 Message Processing Model described in
          RFC3584 always selects the SNMPv1 Security Model. This is true even
          if the SNMPv1 message was protected in transit using a secure
          Transport Model, such as one based on SSH or TLS. The SNMPv1
          Security Model does not know the tmStateReference exists.</t>
        </section>
      </section>

      <section title="Session Requirements">
        <t>Some secure transports might have a notion of sessions, while other
        secure transports might provide channels or other session-like
        mechanism. Throughout this document, the term session is used in a
        broad sense to cover sessions, channels, and session-like mechanisms.
        Session refers to an association between two SNMP engines that permits
        the transmission of one or more SNMP messages within the lifetime of
        the session. How the session is actually established, opened, closed,
        or maintained is specific to a particular Transport Model.</t>

        <t>Sessions are not part of the SNMP architecture defined in <xref
        target="RFC3411"></xref>, but are considered desirable because the
        cost of authentication can be amortized over potentially many
        transactions.</t>

        <t>The architecture defined in <xref target="RFC3411"></xref> does not
        include a session selector in the Abstract Service Interfaces, and
        neither is that done for the Transport Subsystem, so an SNMP
        application has no mechanism to select a session using the ASIs except
        by passing a unique combination of transportDomain, transportAddress,
        securityName, and securityLevel. Implementers, of course, might
        provide non-standard mechanisms to select sessions. The
        transportDomain and transportAddress identify the transport connection
        to a remote network node; the securityName identifies which security
        principal to communicate with at that address (e.g., different NMS
        applications), and the securityLevel might permit selection of
        different sets of security properties for different purposes (e.g.,
        encrypted SETs vs. non-encrypted GETs).</t>

        <t>To reduce redundancy, this document describes aspects that are
        expected to be common to all Transport Model sessions.</t>

        <section title="Session Establishment Requirements">
          <t>SNMP has no mechanism to specify a transport session using the
          ASIs except by passing a unique combination transportDomain,
          transportAddress, securityName, and securityLevel to be used to
          identify a session in a transport-independent manner. SNMP
          applications provide the transportDomain, transportAddress,
          securityName, and securityLevel to be used to create a session.</t>

          <t>For an outgoing message, securityLevel is the requested security
          for the message, passed in the ASIs. If the Transport Model cannot
          provide at least the requested level of security, the Transport
          Model SHOULD discard the message and notify the dispatcher that
          establishing a session and sending the message failed.</t>

          <t>A Transport Model determines whether an appropriate session
          exists (transportDomain, transportAddress, securityName, and
          securityLevel) for an outgoing message. If an appropriate session
          does not yet exist, the Transport Model attempts to establish a
          session for delivery . If a session cannot be established then the
          message is discarded and the dispatcher should be notified that
          sending the message failed.</t>

          <t>Transport session establishment might require provisioning
          authentication credentials at an engine, either statically or
          dynamically. How this is done is dependent on the transport model
          and the implementation.</t>

          <t>The Transport Subsystem has no knowledge of pduType, so cannot
          distinguish between a session created to carry different pduTypes.
          To differentiate a session established for different purposes, such
          as a notification session versus a request-response session, an
          application can use different securityNames or transport addresses.
          For example, in SNMPv1, UDP ports 161 and 162 were used to
          differentiate types of traffic. New transport models may define a
          single well-known port for all traffic types. Administrators might
          choose to define one port for SNMP request-response traffic, but
          configure notifications to be sent to a different port.</t>
        </section>

        <section title="Session Maintenance Requirements">
          <t>A Transport Model can tear down sessions as needed. It might be
          necessary for some implementations to tear down sessions as the
          result of resource constraints, for example.</t>

          <t>The decision to tear down a session is implementation-dependent.
          While it is possible for an implementation to automatically tear
          down each session once an operation has completed, this is not
          recommended for anticipated performance reasons. How an
          implementation determines that an operation has completed, including
          all potential error paths, is implementation-dependent.</t>

          <t>The elements of procedure describe when cached information can be
          discarded, in some circumstances, and the timing of cache cleanup
          might have security implications, but cache memory management is an
          implementation issue.</t>

          <t>If a Transport Model defines MIB module objects to maintain
          session state information, then the Transport Model MUST define what
          SHOULD happen to the objects when a related session is torn down,
          since this will impact interoperability of the MIB module.</t>
        </section>

        <section title="Message security versus session security">
          <t>A Transport Model session is associated with state information
          that is maintained for its lifetime. This state information allows
          for the application of various security services to multiple
          messages. Cryptographic keys associated with the transport session
          SHOULD be used to provide authentication, integrity checking, and
          encryption services, as needed, for data that is communicated during
          the session. The cryptographic protocols used to establish keys for
          a Transport Model session SHOULD ensure that fresh new session keys
          are generated for each session. In addition sequence information
          might be maintained in the session which can be used to prevent the
          replay and reordering of messages within a session. If each session
          uses new keys, then a cross-session replay attack will be
          unsuccessful; that is, an attacker cannot successfully replay on one
          session a message he observed from another session. A good security
          protocol will also protect against replay attacks _within_ a
          session; that is, an attacker cannot successfully replay a message
          observed earlier in the same session.</t>

          <t>A Transport Model session will have a single transportDomain,
          transportAddress, securityName and securityLevel associated with it.
          If an exchange between communicating engines requires a different
          securityLevel or is on behalf of a different securityName, then
          another session would be needed. An immediate consequence of this is
          that implementations SHOULD be able to maintain some reasonable
          number of concurrent sessions.</t>

          <t>For Transport Models, securityName should be specified during
          session setup, and associated with the session identifier.</t>

          <t>SNMPv3 was designed to support multiple levels of security,
          selectable on a per-message basis by an SNMP application, because,
          for example, there is not much value in using encryption for a
          Commander Generator to poll for potentially non-sensitive
          performance data on thousands of interfaces every ten minutes; the
          encryption might add significant overhead to processing of the
          messages.</t>

          <t>Some Transport Models might support only specific authentication
          and encryption services, such as requiring all messages to be
          carried using both authentication and encryption, regardless of the
          security level requested by an SNMP application. A Transport Model
          may upgrade the requested security level, i.e. noAuthNoPriv and
          authNoPriv MAY be sent over an authenticated and encrypted
          session.</t>
        </section>
      </section>
    </section>

    <section title="Scenario Diagrams and the Transport Subsystem">
      <t>RFC3411 section 4.6.1 and 4.6.2 provide scenario diagrams to
      illustrate how an outgoing message is created, and how an incoming
      message is processed. RFC3411 does not define ASIs for "Send SNMP
      Request Message to Network" or "Receive SNMP Response Message from
      Network", and does not define ASIs for "Receive SNMP Message from
      Network" or "Send SNMP message to Network".</t>

      <t>This document defines a sendMessage ASI to send SNMP messages to the
      network, regardless of pduType, and a receiveMessage ASI to receive SNMP
      messages from the network, regardless of pduType.</t>
    </section>

    <section title="Cached Information and References">
      <t>The RFC3411 architecture uses caches to store dynamic model-specific
      information, and uses references in the ASIs to indicate in a
      model-independent manner which cached information flows between
      subsystems.</t>

      <t>There are two levels of state that might need to be maintained: the
      security state in a request-response pair, and potentially long-term
      state relating to transport and security.</t>

      <t>This state is maintained in caches. To simplify the elements of
      procedure, the release of state information is not always explicitly
      specified. As a general rule, if state information is available when a
      message being processed gets discarded, the state related to that
      message should also be discarded, and if state information is available
      when a relationship between engines is severed, such as the closing of a
      transport session, the state information for that relationship might
      also be discarded.</t>

      <t>This document differentiates the tmStateReference from the
      securityStateReference. This document does not specify an implementation
      strategy, only an abstract description of the data that flows between
      subsystems. An implementation might use one cache and one reference to
      serve both functions, but an implementer must be aware of the
      cache-release issues to prevent the cache from being released before a
      security or Transport Model has had an opportunity to extract the
      information it needs.</t>

      <section title="securityStateReference">
        <t>The securityStateReference parameter is defined in RFC3411.
        securityStateReference is not accessible to models of the Transport
        Subsystem.</t>
      </section>

      <section title="tmStateReference">
        <t>For each transport session, information about the message security
        is stored in a cache to pass model- and mechanism-specific parameters.
        The state referenced by tmStateReference may be saved across multiple
        messages, in a Local Configuration Datastore (LCD), as compared to
        securityStateReference which is usually only saved for the life of a
        request-response pair of messages.</t>

        <t>For security reasons, if a secure transport session is closed
        between the time a request message is received and the corresponding
        response message is sent, then the response message SHOULD be
        discarded, even if a new session has been established. The SNMPv3 WG
        decided that this should be a SHOULD architecturally, and it is a
        security-model-specific decision whether to REQUIRE this.</t>

        <t>Since a transport model does not know whether a message contains a
        response, and transport session information is
        transport-model-specific, the tmStateReference contains two pieces of
        information for performing the request-response transport session
        pairing.</t>

        <t>Each transport model that supports sessions and supports the
        tmStateReference cache SHOULD include a transport-specific session
        identifier in the cache for an incoming message, so that if a security
        model requests the same session, the transport model can determine
        whether the current existing session is the same as the session used
        for the incoming request.</t>

        <t>Each Security Model that supports the tmStateReference cache SHOULD
        pass a tmSameSession parameter in the tmStateReference cache for
        outgoing messages to indicate whether the same session MUST be used
        for the outgoing message as was used for the corresponding incoming
        message.</t>

        <t>If the same session requirement is indicated by the security model,
        but the session identified in the tmStateReference does not match the
        current established transport session, i.e., it is not the same
        session, then the message MUST be discarded, and the dispatcher should
        be notified the sending of the message failed.</t>

        <t>Since the contents of a cache are meaningful only within an
        implementation, and not on-the-wire, the format of the cache and the
        LCD are implementation-specific.</t>
      </section>
    </section>

    <section title="Abstract Service Interfaces">
      <t>Abstract service interfaces have been defined by RFC 3411 to describe
      the conceptual data flows between the various subsystems within an SNMP
      entity, and to help keep the subsystems independent of each other except
      for the common parameters.</t>

      <t>This document follows the example of RFC3411 regarding the release of
      state information, and regarding error indications.</t>

      <t>1) The release of state information is not always explicitly
      specified in a transport model. As a general rule, if state information
      is available when a message gets discarded, the message-state
      information should also be released, and if state information is
      available when a session is closed, the session state information should
      also be released. Note that keeping sensitive security information
      longer than necessary might introduce potential vulnerabilities to an
      implementation.</t>

      <t>2) An error indication in statusInformation may include an OID and
      value for an incremented counter and a value for securityLevel, and
      values for contextEngineID and contextName for the counter, and the
      securityStateReference if the information is available at the point
      where the error is detected.</t>

      <section title="sendMessage ASI">
        <t>The sendMessage ASI is used to pass a message from the Dispatcher
        to the appropriate Transport Model for sending.</t>

        <t>In the diagram in section 4.6.1 of RFC 3411, the sendMessage ASI
        replaces the text "Send SNMP Request Message to Network". In section
        4.6.2, the sendMessage ASI replaces the text "Send SNMP Message to
        Network"</t>

        <t>If present and valid, the tmStateReference refers to a cache
        containing transport-model-specific parameters for the transport and
        transport security. How the information in the cache is used is
        transport-model-dependent and implementation-dependent. How a
        tmStateReference is determined to be present and valid is
        implementation-dependent.</t>

        <t>This may sound underspecified, but a transport model might be
        something like SNMP over UDP over IPv6, where no security is provided,
        so it might have no mechanisms for utilizing a securityName and
        securityLevel.</t>

        <figure>
          <artwork><![CDATA[
statusInformation =
sendMessage(
IN   destTransportDomain           -- transport domain to be used
IN   destTransportAddress          -- transport address to be used
IN   outgoingMessage               -- the message to send
IN   outgoingMessageLength         -- its length       
IN   tmStateReference              -- reference to transport state                
 )
 ]]></artwork>
        </figure>
      </section>

      <section title="Other Outgoing ASIs">
        <t>A tmStateReference parameter has been added to the
        prepareOutgoingMessage, prepareResponseMessage, generateRequestMsg,
        and generateResponseMsg ASIs as an OUT parameter. The transportDomain
        and transportAddress parameters have been added to the
        generateRequestMsg, and generateResponseMsg ASIs as IN parameters (not
        shown).</t>

        <figure>
          <artwork><![CDATA[
statusInformation =          -- success or errorIndication
prepareOutgoingMessage(
IN  transportDomain          -- transport domain to be used
IN  transportAddress         -- transport address to be used
IN  messageProcessingModel   -- typically, SNMP version
IN  securityModel            -- Security Model to use
IN  securityName             -- on behalf of this principal
IN  securityLevel            -- Level of Security requested
IN  contextEngineID          -- data from/at this entity
IN  contextName              -- data from/in this context
IN  pduVersion               -- the version of the PDU
IN  PDU                      -- SNMP Protocol Data Unit
IN  expectResponse           -- TRUE or FALSE
IN  sendPduHandle            -- the handle for matching 
                                incoming responses
OUT  destTransportDomain     -- destination transport domain
OUT  destTransportAddress    -- destination transport address
OUT  outgoingMessage         -- the message to send
OUT  outgoingMessageLength   -- its length
OUT  tmStateReference        -- (NEW) reference to transport state
            )]]></artwork>
        </figure>

        <figure>
          <artwork><![CDATA[
statusInformation =          -- success or errorIndication
prepareResponseMessage(
IN  messageProcessingModel   -- typically, SNMP version
IN  securityModel            -- Security Model to use
IN  securityName             -- on behalf of this principal
IN  securityLevel            -- Level of Security requested
IN  contextEngineID          -- data from/at this entity
IN  contextName              -- data from/in this context
IN  pduVersion               -- the version of the PDU
IN  PDU                      -- SNMP Protocol Data Unit
IN  maxSizeResponseScopedPDU -- maximum size able to accept
IN  stateReference           -- reference to state information
                             -- as presented with the request
IN  statusInformation        -- success or errorIndication
                             -- error counter OID/value if error
OUT destTransportDomain      -- destination transport domain
OUT destTransportAddress     -- destination transport address
OUT outgoingMessage          -- the message to send
OUT outgoingMessageLength    -- its length
OUT tmStateReference         -- (NEW) reference to transport state
            )]]></artwork>
        </figure>

        <t>The tmStateReference parameter of generateRequestMsg or
        generateResponseMsg is passed in the OUT parameters of the Security
        Subsystem to the Message Processing Subsystem. If a cache exists for a
        session identifiable from transportDomain, transportAddress,
        securityModel, securityName, and securityLevel, then an appropriate
        Security Model might create a tmStateReference to the cache and pass
        that as an OUT parameter.</t>

        <t>If one does not exist, the Security Model might create a cache
        referenced by tmStateReference. This information might include
        transportDomain, transportAddress, the securityLevel, and the
        securityName, plus any model or mechanism-specific details. The
        contents of the cache may be incomplete until the Transport Model has
        established a session. What information is passed, and how this
        information is determined, is implementation and
        security-model-specific.</t>

        <t>The prepareOutgoingMessage ASI passes tmStateReference from the
        Message Processing Subsystem to the dispatcher. How or if the Message
        Processing Subsystem modifies or utilizes the contents of the cache is
        message-processing-model-specific.</t>

        <t>This may sound underspecified, but a message processing model might
        have access to all the information from the cache and from the
        message, and an application might specify a Security Model such as USM
        to authenticate and secure the SNMP message, but also specify a secure
        transport such as that provided by the SSH Transport Model to send the
        message to its destination.</t>
      </section>

      <!-- **************************************************** -->

      <section title="The receiveMessage ASI">
        <t>If one does not exist, the Transport Model might create a cache
        referenced by tmStateReference. If present, this information might
        include transportDomain, transportAddress, securityLevel, and
        securityName, plus model or mechanism-specific details. How this
        information is determined is implementation and
        transport-model-specific.</t>

        <t>In the diagram in section 4.6.1 of RFC 3411, the receiveMessage ASI
        replaces the text "Receive SNMP Response Message from Network". In
        section 4.6.2, the receiveMessage ASI replaces the text "Receive SNMP
        Message from Network"</t>

        <t>This may sound underspecified, but a transport model might be
        something like SNMP over UDP over IPv6, where no security is provided,
        so it might have no mechanisms for determining a securityName and
        securityLevel.</t>

        <t>The Transport Model does not know the securityModel for an incoming
        message; this will be determined by the Message Processing Model in a
        message-processing-model-dependent manner.</t>

        <t>The receiveMessage ASI is used to pass a message from the Transport
        Subsystem to the Dispatcher.</t>

        <figure>
          <artwork><![CDATA[
statusInformation =
receiveMessage(
IN   transportDomain               -- origin transport domain 
IN   transportAddress              -- origin transport address 
IN   incomingMessage               -- the message received
IN   incomingMessageLength         -- its length       
IN   tmStateReference              -- reference to transport state  
 )
 ]]></artwork>
        </figure>
      </section>

      <section title="Other Incoming ASIs">
        <t>To support the Transport Subsystem, the tmStateReference is added
        to the prepareDataElements ASI (from the Dispatcher to the Message
        Processing Subsystem), and to the processIncomingMsg ASI (from the
        Message Processing Subsystem to the Security Model Subsystem). How or
        if a Message Processing Model or Security Model uses tmStateReference
        is message-processing-model-dependent and
        security-model-dependent.</t>

        <figure>
          <artwork><![CDATA[
result =                       -- SUCCESS or errorIndication
prepareDataElements(
IN   transportDomain           -- origin transport domain
IN   transportAddress          -- origin transport address
IN   wholeMsg                  -- as received from the network
IN   wholeMsgLength            -- as received from the network
IN   tmStateReference          -- (NEW) from the Transport Model
OUT  messageProcessingModel    -- typically, SNMP version
OUT  securityModel             -- Security Model to use
OUT  securityName              -- on behalf of this principal
OUT  securityLevel             -- Level of Security requested
OUT  contextEngineID           -- data from/at this entity
OUT  contextName               -- data from/in this context
OUT  pduVersion                -- the version of the PDU
OUT  PDU                       -- SNMP Protocol Data Unit
OUT  pduType                   -- SNMP PDU type
OUT  sendPduHandle             -- handle for matched request
OUT  maxSizeResponseScopedPDU  -- maximum size sender can accept
OUT  statusInformation         -- success or errorIndication
                               -- error counter OID/value if error
OUT  stateReference            -- reference to state information
                               -- to be used for possible Response
)

]]></artwork>
        </figure>

        <figure>
          <artwork><![CDATA[
statusInformation =  -- errorIndication or success
                         -- error counter OID/value if error
processIncomingMsg(
IN   messageProcessingModel    -- typically, SNMP version
IN   maxMessageSize            -- of the sending SNMP entity
IN   securityParameters        -- for the received message
IN   securityModel             -- for the received message
IN   securityLevel             -- Level of Security
IN   wholeMsg                  -- as received on the wire
IN   wholeMsgLength            -- length as received on the wire
IN   tmStateReference          -- (NEW) from the Transport Model
OUT  securityEngineID          -- authoritative SNMP entity
OUT  securityName              -- identification of the principal
OUT  scopedPDU,                -- message (plaintext) payload
OUT  maxSizeResponseScopedPDU  -- maximum size sender can handle
OUT  securityStateReference    -- reference to security state
 )                         -- information, needed for response
        ]]></artwork>
        </figure>

        <t>The tmStateReference parameter of prepareDataElements is passed
        from the dispatcher to the Message Processing Subsystem. How or if the
        Message Processing Subsystem modifies or utilizes the contents of the
        cache is message-processing-model-specific.</t>

        <t>The processIncomingMessage ASI passes tmStateReference from the
        Message Processing Subsystem to the Security Subsystem.</t>

        <t>If tmStateReference is present and valid, an appropriate Security
        Model might utilize the information in the cache. How or if the
        Security Subsystem utilizes the information in the cache is
        security-model-specific.</t>

        <t>This may sound underspecified, but a message processing model might
        have access to all the information from the cache and from the
        message. The Message Processing Model might determine that the USM
        Security Model is specified in an SNMPv3 message header; the USM
        Security Model has no need of values in the tmStateReference cache to
        authenticate and secure the SNMP message, but an application might
        have specified to use a secure transport such as that provided by the
        SSH Transport Model to send the message to its destination.</t>
      </section>
    </section>

    <!-- 	***************************************************** 	-->

    <section title="Security Considerations">
      <t>This document defines an architectural approach that permits SNMP to
      utilize transport layer security services. Each proposed Transport Model
      should discuss the security considerations of the Transport Model.</t>

      <t>It is considered desirable by some industry segments that SNMP
      Transport Models should utilize transport layer security that addresses
      perfect forward secrecy at least for encryption keys. Perfect forward
      secrecy guarantees that compromise of long term secret keys does not
      result in disclosure of past session keys. Each proposed Transport Model
      should include a discussion in its security considerations of whether
      perfect forward security is appropriate for the Transport Model.</t>

      <t>Since the cache and LCD will contain security-related parameters,
      implementers should store this information (in memory or in persistent
      storage) in a manner to protect it from unauthorized disclosure and/or
      modification.</t>

      <t>Care must be taken to ensure that a SNMP engine is sending packets
      out over a transport using credentials that are legal for that engine to
      use on behalf of that user. Otherwise an engine that has multiple
      transports open might be "tricked" into sending a message through the
      wrong transport.</t>

      <t>A Security Model may have multiple sources from which to define the
      securityName and securityLevel. The use of a secure Transport Model does
      not imply that the securityName and securityLevel chosen by the Security
      Model represent the transport-authenticated identity or the
      transport-provided security services. The securityModel, securityName,
      and securityLevel parameters are a related set, and an administrator
      should understand how the specified securityModel selects the
      corresponding securityName and securityLevel.</t>

      <section title="Coexistence, Security Parameters, and Access Control">
        <t>In the RFC3411 architecture, the Message Processing Model makes the
        decision about which Security Model to use. The architectural change
        described by this document does not alter that.</t>

        <t>The architecture change described by this document does however,
        allow SNMP to support two different approaches to security -
        message-driven security and transport-driven security. With
        message-driven security, SNMP provides its own security, and passes
        security parameters within the SNMP message; with transport-driven
        security, SNMP depends on an external entity to provide security
        during transport by "wrapping" the SNMP message.</t>

        <t>Security models defined before the Transport Security Model (i.e.,
        SNMPv1, SNMPv2c, and USM) do not support transport-based security, and
        only have access to the security parameters contained within the SNMP
        message. They do not know about the security parameters associated
        with a secure transport. As a result, the Access Control Subsystem
        bases its decisions on the security parameters extracted from the SNMP
        message, not on transport-based security parameters.</t>

        <t>Implications of coexistence of older security models with secure
        transport models are known. The securityName used for access control
        decisions represents an SNMP-authenticated identity, not the
        transport-authenticated identity. (I can transport-authenticate as
        guest and then simply use a community name for root, or a USM
        non-authenticated identity.)<list hangIndent="" style="symbols">
            <t>An SNMPv1 message will always be paired with an SNMPv1 Security
            Model (per RFC3584), regardless of the transport mapping or
            transport model used, and access controls will be based on the
            community name.</t>

            <t>An SNMPv2c message will always be paired with an SNMPv2c
            Security Model (per RFC3584), regardless of the transport mapping
            or transport model used, and access controls will be based on the
            community name.</t>

            <t>An SNMPv3 message will always be paired with the securityModel
            specified in the msgSecurityParameters field of the message (per
            RFC3412), regardless of the transport mappng or transport model
            used. If the SNMPv3 message specifies the User-based Security
            Model (USM), access controls will be based on the USM user.If the
            SNMPv3 message specifies the Transport Security Model (TSM),
            access controls will be based on the principal authenticated by
            the transport.</t>
          </list></t>
      </section>
    </section>

    <!-- 	***************************************************** 	-->

    <section title="IANA Considerations">
      <t>This document requires no action by IANA.</t>
    </section>

    <section title="Acknowledgments">
      <t>The Integrated Security for SNMP WG would like to thank the following
      people for their contributions to the process:</t>

      <t>The authors of submitted Security Model proposals: Chris Elliot, Wes
      Hardaker, David Harrington, Keith McCloghrie, Kaushik Narayan, David
      Perkins, Joseph Salowey, and Juergen Schoenwaelder.</t>

      <t>The members of the Protocol Evaluation Team: Uri Blumenthal,
      Lakshminath Dondeti, Randy Presuhn, and Eric Rescorla.</t>

      <t>WG members who performed detailed reviews: Jeffrey Hutzelman, Bert
      Wijnen, Tom Petch.</t>
    </section>

    <!-- Acknowledgements -->
  </middle>

  <back>
    <references title="Normative References">
      &rfc2119;

      &rfc3411;

      &rfc3412;

      &__reference.RFC.3414__evo974gq;

      &rfc3417;
    </references>

    <references title="Informative References">
      &__reference.RFC.2865__evn5qyl1;

      &rfc3410;
      
      &rfc3584;

      &__reference.RFC.4346__evn5pqv9;

      &rfc4422;

      &__reference.RFC.4251__evn67u9c;

      &rfc4741;

      &I-D.ietf-isms-transport-security-model;

      &I-D.ietf-isms-secshell;
    </references>

    <section title="Why tmStateReference?">
      <t>This appendix considers why a cache-based approach was selected for
      passing parameters.</t>

      <t>There are four approaches that could be used for passing information
      between the Transport Model and a Security Model.</t>

      <t><list style="numbers">
          <t>one could define an ASI to supplement the existing ASIs, or</t>

          <t>one could add a header to encapsulate the SNMP message,</t>

          <t>one could utilize fields already defined in the existing SNMPv3
          message, or</t>

          <t>one could pass the information in an implementation-specific
          cache or via a MIB module.</t>
        </list></t>

      <section title="Define an Abstract Service Interface">
        <t>Abstract Service Interfaces (ASIs) are defined by a set of
        primitives that specify the services provided and the abstract data
        elements that are to be passed when the services are invoked. Defining
        additional ASIs to pass the security and transport information from
        the Transport Subsystem to Security Subsystem has the advantage of
        being consistent with existing RFC3411/3412 practice, and helps to
        ensure that any Transport Model proposals pass the necessary data, and
        do not cause side effects by creating model-specific dependencies
        between itself and other models or other subsystems other than those
        that are clearly defined by an ASI.</t>
      </section>

      <section title="Using an Encapsulating Header">
        <t>A header could encapsulate the SNMP message to pass necessary
        information from the Transport Model to the dispatcher and then to a
        Message Processing Model. The message header would be included in the
        wholeMessage ASI parameter, and would be removed by a corresponding
        Message Processing Model. This would imply the (one and only)
        messaging dispatcher would need to be modified to determine which SNMP
        message version was involved, and a new Message Processing Model would
        need to be developed that knew how to extract the header from the
        message and pass it to the Security Model.</t>
      </section>

      <section title="Modifying Existing Fields in an SNMP Message">
        <t><xref target="RFC3412"></xref> defines the SNMPv3 message, which
        contains fields to pass security related parameters. The Transport
        Subsystem could use these fields in an SNMPv3 message, or comparable
        fields in other message formats to pass information between Transport
        Models in different SNMP engines, and to pass information between a
        Transport Model and a corresponding Message Processing Model.</t>

        <t>If the fields in an incoming SNMPv3 message are changed by the
        Transport Model before passing it to the Security Model, then the
        Transport Model will need to decode the ASN.1 message, modify the
        fields, and re-encode the message in ASN.1 before passing the message
        on to the message dispatcher or to the transport layer. This would
        require an intimate knowledge of the message format and message
        versions so the Transport Model knew which fields could be modified.
        This would seriously violate the modularity of the architecture.</t>
      </section>

      <section title="Using a Cache">
        <t>This document describes a cache, into which the Transport Model
        puts information about the security applied to an incoming message,
        and a Security Model can extract that information from the cache.
        Given that there might be multiple TM-security caches, a
        tmStateReference is passed as an extra parameter in the ASIs between
        the Transport Subsystem and the Security Subsystem, so the Security
        Model knows which cache of information to consult.</t>

        <t>This approach does create dependencies between a specific Transport
        Model and a corresponding specific Security Model. However, the
        approach of passing a model-independent reference to a model-dependent
        cache is consistent with the securityStateReference already being
        passed around in the RFC3411 ASIs.</t>
      </section>
    </section>

    <section title="Open Issues">
      <t>NOTE to RFC editor: If this section is empty, then please remove this
      open issues section before publishing this document as an RFC. (If it is
      not empty, please send it back to the editor to resolve.<list
          style="symbols">
          <t></t>
        </list></t>
    </section>

    <section title="Change Log">
      <t>NOTE to RFC editor: Please remove this change log before publishing
      this document as an RFC.</t>

      <t>Changes from -09- to -10-</t>

      <t><list style="symbols">
          <t>Pointed to companion documents</t>

          <t>Wordsmithed extensively</t>

          <t>Modified the note about SNMPv3-consistent terminology</t>

          <t>Modified the note about RFC2119 terminology.</t>

          <t>Modified discussion of cryptographic key generation.</t>

          <t>Added security considerations about coexistence with older
          security models</t>

          <t>Expanded discussion of same session functionality</t>

          <t>Described how sendMessage and receiveMessage fit into RFC3411
          diagrams</t>

          <t>Modified prepareResponseMessage ASI</t>

          <t></t>
        </list></t>

      <t>Changes from -08- to -09-</t>

      <t><list style="symbols">
          <t>A question was raised that notifications would not work properly,
          but we could never find the circumstances where this was true.</t>

          <t>removed appendix with parameter matrix</t>

          <t>Added a note about terminology, for consistency with SNMPv3
          rather than with RFC2828.</t>
        </list></t>

      <t>Changes from -07- to -08-</t>

      <t><list style="symbols">
          <t>Identified new parameters in ASIs.</t>

          <t>Added discussion about well-known ports.</t>
        </list></t>

      <t>Changes from -06- to -07-</t>

      <t><list style="symbols">
          <t>Removed discussion of double authentication</t>

          <t>Removed all direct and indirect references to pduType by
          Transport Subsystem</t>

          <t>Added warning regarding keeping sensitive security information
          available longer than needed.</t>

          <t>Removed knowledge of securityStateReference from Transport
          Subsystem.</t>

          <t>Changed transport session identifier to not include
          securityModel, since this is not known for incoming messages until
          the message processing model.</t>
        </list></t>

      <t>Changes from revision -05- to -06-</t>

      <t><list>
          <t>mostly editorial changes</t>

          <t>removed some paragraphs considered unnecessary</t>

          <t>added Updates to header</t>

          <t>modified some text to get the security details right</t>

          <t>modified text re: ASIs so they are not API-like</t>

          <t>cleaned up some diagrams</t>

          <t>cleaned up RFC2119 language</t>

          <t>added section numbers to citations to RFC3411</t>

          <t>removed gun for political correctness</t>
        </list></t>

      <t>Changes from revision -04- to -05-</t>

      <t><list>
          <t>removed all objects from the MIB module.</t>

          <t>changed document status to "Standard" rather than the xml2rfc
          default of informational.</t>

          <t></t>

          <t>changed mention of MD5 to SHA</t>

          <t>moved addressing style to TDomain and TAddress</t>

          <t>modified the diagrams as requested</t>

          <t>removed the "layered stack" diagrams that compared USM and a
          Transport Model processing</t>

          <t>removed discussion of speculative features that might exist in
          future Transport Models</t>

          <t>removed openSession and closeSession ASIs, since those are
          model-dependent</t>

          <t>removed the MIB module</t>

          <t>removed the MIB boilerplate intro (this memo defines a SMIv2 MIB
          ...)</t>

          <t>removed IANA considerations related to the now-gone MIB
          module</t>

          <t>removed security considerations related to the MIB module</t>

          <t>removed references needed for the MIB module</t>

          <t>changed receiveMessage ASI to use origin transport
          domain/address</t>

          <t>updated Parameter CSV appendix</t>
        </list>Changes from revision -03- to -04-</t>

      <t><list>
          <t>changed title from Transport Mapping Security Model Architectural
          Extension to Transport Subsystem</t>

          <t>modified the abstract and introduction</t>

          <t>changed TMSM to TMS</t>

          <t>changed MPSP to simply Security Model</t>

          <t>changed SMSP to simply Security Model</t>

          <t>changed TMSP to Transport Model</t>

          <t>removed MPSP and TMSP and SMSP from Acronyms section</t>

          <t>modified diagrams</t>

          <t>removed most references to dispatcher functionality</t>

          <t>worked to remove dependencies between transport and security
          models.</t>

          <t>defined snmpTransportModel enumeration similar to
          snmpSecurityModel, etc.</t>

          <t>eliminated all reference to SNMPv3 msgXXXX fields</t>

          <t>changed tmSessionReference back to tmStateReference</t>
        </list></t>

      <t>Changes from revision -02- to -03-</t>

      <t><list style="symbols">
          <t>removed session table from MIB module</t>

          <t>removed sessionID from ASIs</t>

          <t>reorganized to put ASI discussions in EOP section, as was done in
          SSHSM</t>

          <t>changed user auth to client auth</t>

          <t>changed tmStateReference to tmSessionReference</t>

          <t>modified document to meet consensus positions published by JS
          <list style="symbols">
              <t>authoritative is model-specific</t>

              <t>msgSecurityParameters usage is model-specific</t>

              <t>msgFlags vs. securityLevel is
              model/implementation-specific</t>

              <t>notifications must be able to cause creation of a session</t>

              <t>security considerations must be model-specific</t>

              <t>TDomain and TAddress are model-specific</t>

              <t>MPSP changed to SMSP (Security Model security processing)</t>
            </list></t>
        </list></t>

      <t>Changes from revision -01- to -02-</t>

      <t><list style="symbols">
          <t>wrote text for session establishment requirements section.</t>

          <t>wrote text for session maintenance requirements section.</t>

          <t>removed section on relation to SNMPv2-MIB</t>

          <t>updated MIB module to pass smilint</t>

          <t>Added Structure of the MIB module, and other expected MIB-related
          sections.</t>

          <t>updated author address</t>

          <t>corrected spelling</t>

          <t>removed msgFlags appendix</t>

          <t>Removed section on implementation considerations.</t>

          <t>started modifying the security boilerplate to address TMS and MIB
          security issues</t>

          <t>reorganized slightly to better separate requirements from
          proposed solution. This probably needs additional work.</t>

          <t>removed section with sample protocols and sample
          tmSessionReference.</t>

          <t>Added section for acronyms</t>

          <t>moved section comparing parameter passing techniques to
          appendix.</t>

          <t>Removed section on notification requirements.</t>
        </list></t>

      <t>Changes from revision -00- <list style="symbols">
          <t>changed SSH references from I-Ds to RFCs</t>

          <t>removed parameters from tmSessionReference for DTLS that revealed
          lower layer info.</t>

          <t>Added TMS-MIB module</t>

          <t>Added Internet-Standard Management Framework boilerplate</t>

          <t>Added Structure of the MIB Module</t>

          <t>Added MIB security considerations boilerplate (to be
          completed)</t>

          <t>Added IANA Considerations</t>

          <t>Added ASI Parameter table</t>

          <t>Added discussion of Sessions</t>

          <t>Added Open issues and Change Log</t>

          <t>Rearranged sections</t>
        </list></t>
    </section>
  </back>
</rfc>
<!-- Local Variables:                                           -->
<!-- compile-command: "xml2rfc draft-schoenw-snmp-tlsm-03.xml"  -->
<!-- ispell-local-dictionary: "american"                        -->
<!-- sgml-declaration: "/usr/lib/sgml/declaration/xml.decl"     -->
<!-- sgml-omittag:nil                                           -->
<!-- sgml-shorttag:t                                            -->
<!-- sgml-namecase-general:t                                    -->
<!-- sgml-minimize-attributes:nil                               -->
<!-- sgml-always-quote-attributes:t                             -->
<!-- sgml-indent-step:2                                         -->
<!-- sgml-indent-data:t                                         -->
<!-- sgml-parent-document:nil                                   -->
<!-- sgml-exposed-tags:nil                                      -->
<!-- sgml-local-catalogs:nil                                    -->
<!-- sgml-local-ecat-files:nil                                  -->
<!-- End:                                                       -->