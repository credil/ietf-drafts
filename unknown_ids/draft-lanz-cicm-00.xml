<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!-- General -->
<?rfc strict="yes" ?>
<!-- Enforce Internet-Drafts nits & DTD validity? -->
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<!-- References -->
<?rfc symrefs="yes"?>
<!-- Show symbolic links (yes) or numbers (no). -->
<?rfc sortrefs="yes" ?>
<!-- Sort references? -->
<!-- Comments -->
<?rfc comments="yes" ?>
<!-- Display <cref> elements? -->
<?rfc inline="yes" ?>
<!-- Place comments inline (yes) or in comments section (no). -->
<?rfc editing="no" ?>
<!-- Insert editing marks? -->
<!-- Table of Contents -->
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocompact="yes"?>
<!-- End of directives; start of RFC. -->
<rfc category="info" ipr="trust200902" docName="draft-lanz-cicm-00">
  <front>
    <title abbrev="CICM">Common Interface to Cryptographic
    Modules</title>
    <author fullname="Daniel J. Lanz" initials="D." surname="Lanz">
      <organization abbrev="MITRE">The MITRE
      Corporation</organization>
      <address>
        <email>dlanz@mitre.org</email>
      </address>
    </author>
    <author fullname="Lev Novikov" initials="L." surname="Novikov">
      <organization abbrev="MITRE">The MITRE
      Corporation</organization>
      <address>
        <email>lnovikov@mitre.org</email>
      </address>
    </author>
    <date year="2010" month="January" />
    <area>Security</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <abstract>
      <t>This memo presents a programming interface to standardize
      the way software programs manage cryptographic modules and
      utilize cryptographic services offered by modules. Although a
      number of interfaces for commercial environments have been
      standardized and are in use, this is the first generic
      cryptographic interface to be developed that supports
      cryptographic modules separating two security domains and is
      thus ideal for the high assurance marketplace. The interface
      has been designed to also allow less demanding environments
      to take advantage of its features.</t>
    </abstract>
    <note title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
      "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
      and "OPTIONAL" in this document are to be interpreted as
      described in
      <xref target="RFC2119">RFC 2119</xref>.</t>
    </note>
  </front>
  <middle>
    <!-- Content. -->

	<section title="Introduction">
		<section title="Background">
			<t>Sensitive data is increasingly under attack,
			whether in transit or at rest. The computer security community has
			responded to these threats by using cryptography to secure
			sensitive data. To counter the growing number and types of threats
			against systems processing sensitive data, module vendors have
			engineered a diverse set of cryptographic modules.</t>
			<t>Systems that require cryptographic protection may utilize
			various cryptographic services including data encryption, signature
			generation, hashing, and keystream generation. Cryptographic
			modules providing these services and the key material they hold
			must be managed. All of these services have proprietary interfaces
			that differ significantly among module types, leading to the
			following problems:</t>
			<t><list style="symbols">
				<t>Replacement of one module type for another and reuse of
				module-dependent software are inhibited as applications require
				extensive modifications to adapt to new module types and their
				proprietary interfaces.</t>
				<t>Developers of systems that host cryptographic modules must
				accommodate different cryptographic module interfaces for
				different types of cryptographic modules.</t>
				<t>Test tools and procedures developed for one module usually
				will not work with other modules.</t>
				<t>Security evaluators must learn multiple module developers'
				interfaces, increasing evaluation time and expense.</t>
			  </list></t>
			<t>To address these problems, the Common Interface to Cryptographic
			Modules (CICM) specification offers module developers a set of
			standard interfaces for the set of operations supported by high
			assurance cryptographic modules. Although many Application
			Programming Interfaces (APIs) intended for commercial cryptography
			are available, the CICM specification was designed for high
			assurance environments, but may be used in other environments as
			well.</t>
			<t>Modules do not require changes to support the use of CICM. A
			module-specific abstraction layer between the library implementing
			CICM interfaces and the module performs the needed translations
			between the CICM model of a module and the model presented by a
			specific module. This abstraction component may be provided by the
			module developer, a module embedder/integrator, or another
			interested party. This arrangement is analogous to manufacturers of
			computer peripheral devices providing platform or operating
			system-specific drivers for their peripheral devices.</t>
			<t>CICM is defined using Interface Definition Language (IDL), a
			specification language that describes a software interface in a
			language-neutral way. IDL compilers can generate a functionally
			equivalent CICM interface binding for common programming languages.
			The use of IDL in CICM is not intended to either prescribe or
			preclude a particular communications protocol such as General
			Inter-ORB Protocol (GIOP) between programs in different address
			spaces or on different devices.</t>
			<t>Software developers who require the services of cryptographic
			modules to perform cryptographic operations use a CICM library in
			their desired language binding for the specific module from which
			they intend to access cryptographic services. The specification
			currently does not specify normative bindings for specific
			programming languages, although bindings for common languages can
			be generated from the IDL provided with the specification. However,
			normative bindings for one or more popular programming languages
			will be made available in a future release of the
			specification.</t>
			<t>The benefits of using the CICM standard interfaces to access
			cryptographic services include:</t>
			<t><list style="symbols">
			  <t>Provide a common, logical model of cryptographic modules that
			  is straightforward to learn and easy to use.</t>
			  <t>Enable the replacement of one cryptographic module for
			  another without significant modifications to the client programs
			  that interact and use the cryptographic module, assuming certain
			  compatibility characteristics between the modules exist.</t>
			  <t>Accommodate binding to multiple programming languages.</t>
			  <t>Enforce the correct use of the API; in particular, interfaces
			  must be used in the intended order, imposable at compile time or
			  recognizable via static analysis.</t>
			  <t>Support high assurance evaluation by enabling evaluators to
			  quickly validate that a particular implementation uses only the
			  required functions in the manner they were intended.</t>
			</list></t>
		</section>
		<section title="Audience">
			<t>The CICM specification is written for computer
			programmers, software engineers, and technical architects with a
			background in data security and cryptography. Knowledge of
			object-oriented programming concepts is useful when reading IDL
			definitions. Software engineers may use the specification when
			developing software that integrates with cryptographic modules.
			Technical architects may use the specification when designing
			systems that incorporate cryptographic modules to secure data
			within the system or between systems.</t>
			<t>Although the specification is targeted to software developers
			who will access module services using a compliant implementation,
			it also addresses module developers and others who implement
			library and other support software.</t>
		</section>
		<section title="Scope of the Specification">
			<t>CICM interfaces provide a common
			way to access the following services offered by cryptographic
			modules:
			<list style="symbols">
			  <t>Cryptographic module management: Includes retrieving
			  information about a specific module, managing access control,
			  managing module events, and loading and managing software
			  packages on modules.</t>
			  <t>Key management: Includes the generation, storage, protection,
			  and removal of key material, and support for message exchanges
			  used in key agreement and key transfer protocols.</t>
			  <t>Channel management: A channel defines a specific
			  cryptographic transform and encapsulates all attributes
			  associated with that transform. Channel management includes
			  channel instantiation, channel control throughout its lifetime,
			  providing data to a channel for transformation, and extracting
			  transformed data from a channel.</t>
			</list></t>
			<t>Each of the above services is discussed in detail in Section 2
			of the specification and is introduced normatively in Section
			3.</t>
			<t>The following elements are not addressed by the specification:
			<list style="symbols">
			  <t>Hardware interfaces, protocols, or design</t>
			  <t>Details of specific protocols in the specification (The
			  specification provides a means to move protocol messages into and
			  out of a module, but does not dictate low level protocol.)</t>
			  <t>Internal structure of certain types of data elements (e.g.,
			  software packages imported into a module, test results extracted
			  from a module) that move through CICM interfaces</t>
			  <t>Policy enforcement (The specification provides a means to
			  convey policy elements to the module, but policy enforcement is
			  considered a module responsibility.)</t>
			  <t>Organization of the information stored and processed within a
			  module</t>
			  <t>Separation of commands/data for multiple security domains
			  that access a single CICM library instance (e.g., Multiple Levels
			  of Security).</t>
			</list></t>
		</section>
		<section title="Use Cases">
			<t>A significant characteristic that differentiates
			CICM from other cryptographic interfaces is its ability to support
			cryptographic modules that separate two security domains. The use
			cases that follow capture this fundamental element of CICM
			interface design. These use cases can be divided into two basic
			types:
			<list style="symbols">
			  <t>Cryptographic transformation of data initiated in one
			  security domain with the result made available in another
			  security domain</t>
			  <t>Cryptographic transformation of data within a single security
			  domain: Cryptographic hash or digital signature operations may be
			  initiated in the same security domain where the result is
			  received. Other single domain use cases include data
			  encryption/decryption for storage and keystream/random data
			  generation.</t>
			</list></t>
			<t>The data-in-transit and data-at-rest use cases illustrated below
			incorporate multiple security domains, while the final use case
			depicts a transformation within a single domain.</t>
			<section title="Data-in-Transit">
				<t>The figure below shows a hardware device
				with an embedded cryptographic module providing encryption and
				decryption services between a secure and non-secure network. The
				secure side protocol logic subsystems access cryptographic services
				using CICM. In this use case, the High Assurance IP Encryptor
				(HAIPE) device utilizes CICM to enable the internal protocol logic
				of the device to access cryptographic services; the network to
				which the HAIPE device is connected does not interface to the
				protocol encryptor using CICM.</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 1. First Data-in-Transit Use Case, HAIPE</t>
				<t>The following figure depicts the same use case in its end-to-end
				configuration.</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 2. HAIPE Use Case in End-to-End Configuration</t>
				<t>A second data-in-transit use case shows a tactical secure radio
				with an embedded cryptographic module providing encryption and
				decryption services between a local host and a radio frequency
				environment. The functional blocks that make up the tactical secure
				radio are logically identical to those in the first example.</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 3. Second Data-in-Transit Use Case, Tactical Secure Radio</t>
			</section>
			<section title="Data-at-Rest">
				<t>The figure below shows a cryptographic module
				providing encryption services for data stored on a disk and
				decryption services for data read from a disk. A file system driver
				accesses cryptographic services using CICM standard interfaces.
				This use case could apply to a laptop computer that contains
				encrypted data; it would prevent access to sensitive data from a
				lost or stolen laptop.</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 4. Data-at-Rest Use Case</t>
			</section>
			<section title="Single Security Domain">
				<t>The following figure shows a cryptographic transform within a single security domain (it assumes
				that the transform does not change the classification of the data).
				The plaintext is conveyed to the module, transformed by an
				encryption algorithm, and results in ciphertext. This information
				is then returned to the same domain from which the plaintext
				originated. Other natural examples of a single domain use case
				include signing, which results in a digital signature; hashing,
				which results in a hash value; and keystream generation, which
				results in keystream data.</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 5. Single Security Domain Use Case</t>
			</section>
		</section>
		<section title="Assumptions">
			<t>The following assumptions were made in the
			development of CICM:
			<list style="symbols">
			  <t>Library implementers may implement part of the specification
			  (refer to Section 4, Conformance and Extensions, for the
			  normative rules).</t>
			  <t>A client program initiates cryptographic transformations
			  with a cryptographic module via the CICM API. Multiple client
			  programs may concurrently access a single module from a single
			  security domain, but CICM provides no support for controlling
			  access to a module by two or more client programs.</t>
			  <t>A module may be implemented as hardware, firmware, or
			  software component, or any combination thereof.</t>
			  <t>Although CICM is intended for use in high assurance
			  environments, its use is not precluded in less demanding
			  environments.</t>
			  <t>One or more entities between the API library and the module
			  translates CICM commands or interfaces to module-specific
			  commands or interfaces.</t>
			  <t>CICM makes no provision in the design of the API to guarantee
			  the confidentiality, integrity, or authenticity of commands and
			  data between a client program calling the API and a module.
			  However, such protections can be applied in the library or
			  runtime system software.</t>
			  <t>Specialized hardware (e.g., hardware access tokens, key fill
			  devices, trusted displays) independent of a module may require
			  host (and thus API) interaction or may require no host
			  interaction.</t>
			</list></t>
		</section>
		<section title="Specification Organization">
			<t> This specification contains
			normative and informative (non-normative) material. The normative
			material is prescriptive and provides information that is necessary
			to claim conformance to the specification. The informative material
			is for informational purposes; it assists the reader in the
			understanding and use of the specification but does not contain
			provisions required for conformance.</t>
			<t>Section 1 and Section 2 provide introductory material and are
			non-normative. Section 3 presents the namespaces, interfaces,
			methods, and attributes that comprise the specification, and is
			normative. Section 4, Conformance and Extensions, provides the
			specification conformance statement and is normative. Appendix A
			lists the status codes referred to within the document and is
			normative. Appendix B lists the terms used within the document and
			is non-normative.</t>
		</section>
		<section title="Acknowledgements">
			<t>Many individuals participated in the development and review of
			the CICM specification. The CICM development team consists of
			Ronald Albuquerque, Samuel Cardman, Greg Carrier, James Cottrell,
			Shirley Kawamoto, Daniel Lanz, Brent Midwood, Lev Novikov, Brian
			O'Hanlon, Rick Page, Adam Pennington, and Nguyen Thai. The document
			production team consists of Mark Dwyer, Amanda Lind, and Brian
			Parrish.</t>
			<t>The CICM team wishes to thank the following individuals for
			participating in a review of the specification:</t>
			<t><list>
				<t>Bill Beckwith, Objective Interface Systems</t>
				<t>Dennis Bourget, Viasat</t>
				<t>Thom Brooke, Linquest Corp.</t>
				<t>Randy Culver, RT Logic</t>
				<t>John Davis, ITT Corporation</t>
				<t>Eric Dube, The MITRE Corporation</t>
				<t>Jan Duffy, Rockwell Collins</t>
				<t>H.J. Eckles, General Dynamics</t>
				<t>Mark Flinchbaugh, Harris Corp.</t>
				<t>Carolyn Francisco, The MITRE Corporation</t>
				<t>James Howard, L-3 Communications</t>
				<t>Kent Kofstad, The MITRE Corporation</t>
				<t>Hema Krishnamurthy, ITT Corporation</t>
				<t>Prithvi Kumar, The MITRE Corporation</t>
				<t>Chip McGrogan, L-3 Communications</t>
				<t>Hank Morris, Concurrent Technologies Corp.</t>
				<t>Jeff Picciotto, The MITRE Corporation</t>
				<t>Tom Plachecki, General Dynamics</t>
				<t>Ray Purvis, The MITRE Corporation</t>
				<t>Mike Ridge, The MITRE Corporation</t>
				<t>Harry Shaffer, The MITRE Corporation</t>
				<t>Patrick Smith, Linquest Corp.</t>
				<t>Wayne Staats, Rockwell Collins</t>
				<t>James Steinwachs, Harris Corp.</t>
				<t>Porter Taylor, The MITRE Corporation</t>
				<t>Otaway Thomas, Arkham Technology</t>
				<t>Bob Walcott, The MITRE Corporation</t>
				<t>Blane Yamamoto, SafeNet Mykotronx</t>
			</list></t>
		</section>
	</section>
	<section title="Using the Specification">
		<section title="Specification Categories">
			<t>CICM interfaces are divided into
			three major categories:
			<list style="symbols">
			  <t>Module management</t>
			  <t>Key management</t>
			  <t>Channel management</t>
			</list></t>
			<t>This section describes CICM support for capabilities made
			available by cryptographic modules to systems that depend upon high
			assurance cryptography.</t>
		</section>
		<section title="Module Management">
			<t>CICM's most fundamental element and its
			technique for abstracting modules is the CryptoModule interface.
			This interface provides the means to manage individual modules, and
			to access channel and key interfaces. Individual CryptoModule
			instances are accessible from the CICMRoot interface, enabling a
			single CICM library instance to provide access to multiple
			cryptographic modules available from a particular host.</t>
			<t>The CryptoModule interface defines attributes that enable a
			caller to retrieve information about a module, including the module
			manufacturer, serial number, and version numbers. This interface
			also defines specialized attributes called managers that provide
			access to the services made available by the module. CryptoModule
			supports the managers described in the sections below.</t>

			<section title="Managing Module Authentication">
				<t>Modules may require a host
				or user to authenticate to the module before the module will enter
				an operational state, allowing it to accept commands and perform
				cryptographic transformations. In some cases, a specialized,
				removable hardware component will perform or participate in the
				authentication. This hardware component is termed a
				 hardware access token in CICM nomenclature, although other
				communities may use different terminology. Most implementations
				utilizing hardware access tokens will transfer key material between
				the token and module, independent of the API. In cases where access
				tokens are not supported, a user may provide authentication
				credentials to the module via the API. In still other cases,
				support for multi-factor authentication will require a token and a
				user login. Note that the user and token holder may be different
				entities.</t>
				<t>CICM provides interfaces that can be used separately or in
				combination with one another as appropriate for the system using
				them and for the authentication mechanisms offered by the module
				that is utilized by the system. Methods to manage module/token
				associations are available for systems where hardware access tokens
				are supported. Login methods and related user management methods
				are supported for systems that require user login.</t>
				<t>The managers below support the functionality described above.</t>

				<section title="Managing Hardware Access Tokens">
					<t>The token manager defines
					methods that support associating a token with a module,
					disassociating a token from a module, and disassociating a module
					from a token. The manager also supports retrieving a list of token
					associations on a module and module associations on a token.</t>
				</section>
				<section title="Managing Users">
					<t>The user manager defines methods that
					support adding users to and removing users from a module user
					database, and associating a user with a module-defined role. The
					manager also supports listing the user database, and the roles
					defined and supported by the module.</t>
				</section>
				<section title="Logging in to a Module from a Host">
					<t>The login manager
					defines methods that enable a user configured on a module to login
					to and logout from a module.</t>
				</section>
			</section>
			<section title="Managing Software Packages">
				<t>The package manager defines
				methods that support importing and managing the executable images
				that reside on a cryptographic module. These methods enable module
				software/firmware packages to be imported and other software
				package management operations to be performed, including retrieving
				a list of packages, and activating or deleting a specific
				package.</t>
				<t>The package manager enables packages to be imported into a
				module in segments rather as an atomic unit. This supports modules
				that must make special provisions to import executable images due
				to internal storage space limitations.</t>
			</section>
			<section title="Managing Logs">
				<t>Modules generate log entries as they operate.
				The log manager defines methods that support retrieving individual
				log entries or extracting an entire log from a module.
				Additionally, clients may clear individual log entries or the
				entire module log.</t>
			</section>
			<section title="Managing Tests">
				<t>Modules may incorporate built-in tests to
				validate that module functionality is operating as designed. Some
				tests may be externally initiated. The test manager defines methods
				that support host-initiated module tests.</t>
			</section>
			<section title="Managing Module Events">
				<t>The event manager defines methods
				that support registering/unregistering module-generated event
				notifications received by a client program. Clients can register
				custom-developed callback procedures, called
				 listeners , for specific module events. When the condition
				associated with a specific listener presents itself, the registered
				listener is called.</t>
				<t>Examples of events for which listeners may be registered
				include:
				<list style="symbols">
				  <t>Hardware access token has been inserted or removed.</t>
				  <t>Module is ready to receive traffic.</t>
				  <t>Alarm condition is raised.</t>
				  <t>Hardware zeroization condition raised.</t>
				  <t>Continuous module/engine health test failed.</t>
				  <t>Usable lifespan of key expired.</t>
				  <t>Change in module power state.</t>
				</list></t>
			</section>
			<section title="Managing Keys and Channels">
				<t>Channel and key management
				interfaces are made available via managers in the CryptoModule
				interface. The asymmetric and symmetric key manager attributes
				allow for access to asymmetric keysets and symmetric keys,
				respectively, and the key database manager offers the ability to
				zeroize a module and reencrypt the module key database. The channel
				manager attribute allows channels to be created and used.</t>
			</section>
		</section>
		<section title="Key Management">
			<t>Cryptographic modules utilize key material
			under their protection as one input to perform a cryptographic
			transformation. Keys
			<list style="symbols">
			  <t>can originate at a Key Infrastructure Component that has a trust
			  relationship with the module</t>
			  <t>may be agreed upon between the module and another entity</t>
			  <t>may be generated on the module itself</t>
			  <t>may be derived from information presented to the module by a
			  client program. Once established on a module, they may be subject
			  to client-initiated management operations or may be used as part
			  of a cryptographic channel to effect cryptographic
			  transformations.</t>
			</list></t>
			<t>CICM supports separate IDL interfaces for symmetric keys and
			asymmetric keysets. An asymmetric keyset may comprise an asymmetric
			key pair, the public and private key components of a keypair, the
			digital certificate corresponding to the keyset public key, one or
			more verification certificates in the certificate chain of trust,
			and related public domain parameters.</t>
			<t>The asymmetric and symmetric key manager attributes allow for
			access to asymmetric keysets and symmetric keys, respectively.</t>

			<section title="Creating and Establishing Keys">
				<t>Keys may be moved into a
				module in one of several scenarios. Each scenario is described in
				detail below.</t>

				<section title="No Host Interaction Key Fill">
					<t>Specialized hardware devices
					designed to transfer key from a key infrastructure component to a
					specific cryptographic module may fill key into a module without
					host involvement and thus no API interaction. In some cases, this
					process does not support transferring key metadata with a key. This
					requires host and API interaction to apply metadata to the key
					inside the module upon completion of the fill.</t>
				</section>
				<section title="Client Program-Initiated">
					<t>In some cases, key fill devices
					require host interaction to initiate a key fill. The API enables a
					key storage location to be specified or key tagging information to
					be associated with the filled key prior to the initiation of the
					fill.</t>
					<t>Keys may be imported via the key import method or derived using
					a text-based secret provided by the user of the client program.
					Keys also may be generated directly on the module. Each case
					results in a persistent key.</t>
					<t>A key also is implicitly established each time a channel is
					created using an asymmetric keyset and upon renegotiation. Keys
					resulting from channel-based key agreement are ephemeral; they are
					not generally managed outside of a channel. Ephemeral keys also may
					be destroyed when a channel is destroyed.</t>
				</section>
				<section title="Module/Key Infrastructure Initiated">
					<t>A facility to operate a
					key agreement protocol with an infrastructure component is
					supported. This facility also enables key material or key
					revocation information to be authenticated by one of the module's
					trust anchors, and then loaded into the module.</t>
				</section>
			</section>
			<section title="Exporting Keys">
				<t>Methods to export key material out of a
				module are supported. A module may require wrapping the key
				material prior to export or may disallow this operation.</t>

				<section title="Locating and Retrieving Information about a Key">
					<t>A method to
					locate a specific key on a module based upon identification
					information associated with the key is supported. In addition, the
					entire key database may be listed.</t>
				</section>
				<section title="Applying Metadata to Keys">
					<t>Key metadata may be retrieved and
					set for individual keys. Metadata elements include the key
					identifier, alias, and classification. Keys, imported via a fill
					device, that are untagged may require certain metadata to be
					applied after the conclusion of the load.</t>
				</section>
				<section title="Performing Operations on Keys">
					<t>A number of management
					operations on keys are supported. Keys may be wrapped
					(cryptographically protected) in preparation for export, or may be
					unwrapped after import. Keys may be zeroized, either individually
					or as the set of all key material on the module. Specialized
					operations to perform key conversions and updates also are
					available.</t>
				</section>
				<section title="Enabling Remote Management">
					<t>The specification enables
					support for various key management-related protocol messages
					including remote key functions (e.g., remote zeroize or rekey),
					infrastructure-initiated key revocation, and trust anchor
					management.</t>
				</section>
			</section>
			<section title="Channel Management">
				<t>The CICM channel is the fundamental
				construct under which one or more related cryptographic transforms
				are performed, and within which all details and attributes
				associated with the transform are encapsulated, including the path
				through the module. Most channels accept data from a port in the
				local security domain, transform the data, and output the result on
				a port in another security domain. A channel also may perform
				transformations within a single security domain, or may accept data
				for transformation in one domain and output the result in another.
				The channel type determines which ports must be specified when a
				channel is created.</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 6. Local and Remote Port
				  Nomenclature for Channels that Operate in Two Security
				  Domains</t>
				<t>Three classes of objects are fundamental to the creation and use
				of CICM channels. A
				 controller is used to configure and control a channel. A
				 stream enables data to be sent to a module to be
				transformed, and transformed data to be received using a controller
				as a foundation. A
				 conduit is the sum of a controller and a stream. Thus, the
				term
				 channel is only an abstraction representing the logical
				path through the module on which cryptographic transformations are
				performed.</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 7. Relationship Between Channel,
				  Conduit, Controller, and Stream</t>
				<t>This division of responsibility makes channels very flexible.
				One client program can be responsible for creating and managing
				channels with a controller, and another can send data over this
				preconfigured channel for transformation using a stream. In some
				environments, data to be transformed never enters the host to pass
				through the API. Instead, it is clocked directly through the
				module. In this situation, a controller is configured, but no
				stream is configured since it would never be used. In other cases,
				a client program is required to configure the channel and pass data
				through the channel it configured. In this case, the client program
				configures a conduit, which incorporates a controller and a
				stream.</t>
				<t>Both controllers and conduits accept symmetric keys, requiring
				that the client program configuring the channel and its remote peer
				share the same secret key. Alternatively, all peers may hold their
				own respective asymmetric keysets, requiring a key negotiation
				which, upon successful completion, results in each peer holding an
				ephemeral symmetric key. CICM supports a negotiator IDL interface
				for this purpose. A successful negotiation results in a negotiated
				controller or conduit.</t>
				<t>CICM supports the following channel types:
				<list style="symbols">
				  <t>Encryption/decryption, including selective bypass</t>
				  <t>Signature generation/verification</t>
				  <t>Message Authentication Code (MAC)
				  generation/verification</t>
				  <t>Cryptographic hashing</t>
				  <t>Keystream generation</t>
				  <t>Random/pseudo-random data generation</t>
				  <t>Key wrap</t>
				  <t>Full bypass.</t>
				</list></t>
				<t>CICM also supports hybrid channel types. A channel that
				simultaneously supports encryption and signature, resulting in both
				ciphertext and a final signature value, is a hybrid channel.</t>
				<t>Each of the types above differs in the way it is configured, its
				configuration options, and how it handles the cryptographic
				transformation of data. Consider the following examples portraying
				the diversity of the channel types:
				<list style="symbols">
				  <t>The encryption channel accepts plaintext to be transformed,
				  and can return the resulting ciphertext directly to the caller or
				  route it a different security domain</t>
				  <t>The random data generation channel requires no data for
				  transformation, but emits a random stream</t>
				  <t>The signature channel accepts an indeterminate amount of
				  data, and returns an algorithm-specific fixed-sized value</t>
				  <t>The hashing channel does not accept a cryptographic key as a
				  parameter, as most of the other channel types do (keyed hashes
				  are supported by MAC channels)</t>
				  <t>The decryption channel accepts a state vector input
				  parameter, but does not allow a state vector to be
				  generated.</t>
				</list></t>
				<t>This diversity results from the fundamental characteristics of
				the cryptographic primitives that are being abstracted. The channel
				manager defines the methods that support creating conduits,
				controllers, streams, and negotiators for each of the channel
				services listed above.</t>
				<t>Interfaces for channel services are organized into 10 namespaces
				for modularity and as a mechanism to group similar channel types
				together. A namespace is an abstract container that holds related
				interfaces.</t>
				<t>The CICM channel manager provides the ability to perform the
				functions described in the following sections.</t>

				<section title="Creating Channels">
					<t>Creating a channel requires an awareness
					of the options available:
					<list style="symbols">
					  <t>The type of cryptographic operation desired (encryption,
					  hashing, keystream generation, etc.)</t>
					  <t>How the channel will be used (control-only, send/receive data
					  only, or both control and send/receive data)</t>
					  <t>The type of key that will be used for channels that require a
					  symmetric key or an asymmetric keyset (hybrid channels accept two
					  keys).</t>
					</list></t>
					<t>Selecting among these options enables the client program
					developer to determine what channel interface to use.</t>
					<t>Consider the following example of a client program configuring a
					channel to perform encryption using an asymmetric keyset:
					<list style="symbols">
					  <t>The desired cryptographic operation is "encryption."</t>
					  <t>The program only needs to control the channel, not send data
					  over the channel to be encrypted.</t>
					  <t>An asymmetric keyset is available, requiring a key agreement
					  protocol negotiation before the channel will be usable.</t>
					</list></t>
					<t>Given the above information, creating the appropriate type of
					negotiator from the ChannelManager is straightforward: </t>
					<figure>
<artwork><![CDATA[// Assume references to cryptoModule, localPort, remotePort, protocol,
// and key.

CICM::Status sCode;

// Retrieve a reference to the ChannelManager:
CICM::ChannelManager channelManager =
cryptoModule._get_channel_manager();

// Create the appropriate Negotiator:
CICM::Encrypt::ControllerNegotiator negotiator;
sCode = channelManager.negotiate_encrypt_controller(localPort,
	remotePort, protocol, key, &negotiator);
]]></artwork>
					</figure>
					<t>The above call results in the initiation of a key agreement
					protocol negotiation with its remote peer. To ensure that it is the
					expected peer, a human user at the client may validate information
					extracted from the peer's certificate. If the module uses a trusted
					display, it directly communicates the peer information to the
					display. Based upon user input at the display, host-independent
					negotiation is continued or aborted. If no trusted display is
					available, the client program requests information about the remote
					peer, displays it at the host for user confirmation, and provides
					positive confirmation via the API that the peer is valid, allowing
					the negotiation to continue.</t>
					<t>The following example shows the display interactions required to
					retrieve a negotiated controller:</t>
					<figure>
<artwork><![CDATA[// Retrieve peer information:
CICM::PeerInfo peerInfo;
negotiator.get_remote_info(&peerInfo);

// Assume the user positively confirms that the peer is valid.

// Complete the negotiation.
CICM::Encrypt::NegotiatedController negotiatedController;
sCode = negotiator.complete(&negotiatedController);
]]></artwork>
					</figure>
					<t>The resulting negotiated controller can be used to control and
					manage the channel.</t>
					<t>The sections below describe the channel types that are
					supported.</t>

					<section title="Encryption and Decryption">
						<t>CICM defines interfaces to
						support encryption and decryption between two security domains or
						within a single security domain. Additional variants are defined
						including hybrid channels that can concurrently compute integrity
						values. Another set of variants provides methods to perform
						encryption/decryption with selective bypass.</t>
						<t>If an asymmetric keyset is used to create a channel, a
						negotiation process is initiated, which results in a negotiated
						channel. Negotiated versions of hybrid channels also are available.
						For those negotiator versions that combine encryption with
						integrity value generation, negotiation applies only to the
						encryption key specified when the channel is negotiated, not the
						signature or MAC key.</t>
						<t>Channel-based multiple key wrap/unwrap support is provided via a
						special channels for that purpose.</t>
						<t>CICM also supports encryption/decryption channels that operate
						in coprocessor mode . These channels accept their input and return their
						output as part of the same method call. Where relevant, the
						integrity value or verification status (verified/not verified) is
						returned when the final block of the input has been presented for
						transformation.</t>
						<t>Duplex channel configurations that use the same key to perform
						encrypt and decrypt transformations also are supported. Negotiated
						versions of the duplex channel also are available.</t>
					</section>
					<section title="Bypass">
						<t>Bypass channels capable of defining a path through a
						module and then bypassing data from one security domain to a
						different domain are supported. Selective bypass also is supported
						on encryption and decryption channels.</t>
					</section>
					<section title="Integrity">
						<t>Interfaces to compute and validate integrity
						values using asymmetric key-derived digital signatures or symmetric
						key-derived MACs are available. A variant on the sign and verify
						interfaces accepts a previously generated hash value in place of a
						message.</t>
					</section>
					<section title="Hashing">
						<t>A channel to calculate a fixed-length cryptographic
						hash from an input message is available. Keyed hashes are supported
						by MAC channels.</t>
					</section>
					<section title="Keystream Generation">
						<t>Channels are supported to read keystream from a module.</t>
					</section>
					<section title="Random Data">
						<t>Separate interfaces are defined to retrieve
						random or pseudorandom data from a module.</t>
					</section>
				</section>
				<section title="Managing Channels">
					<t>Only conduits and controllers (not
					streams) can manage channels. Negotiators also can manage the
					negotiation aspects of a channel.</t>
					<t>The management operations that can be performed on a channel are
					specific to each channel type, but the following general operations
					are supported:
					<list style="symbols">
					  <t>Generating, extracting, and setting state vectors</t>
					  <t>Resynchronization</t>
					  <t>Initiating a key rollover</t>
					  <t>Initiating a key update.</t>
					</list></t>
					<t>Negotiators support the following general operations:
					<list style="symbols">
					  <t>Renegotiation</t>
					  <t>Changing classification level/acknowledging change of
					  classification level.</t>
					</list></t>
					<t>Managing state vectors is an important channel management
					capability. CICM provides a method to explicitly generate a state
					vector for those algorithms/modes that require a random
					 initialization vector (IV), although modules may
					alternatively generate an IV as a byproduct of channel creation.
					CICM also provides a method to set the state vector on a channel.
					This may be used to:
					<list style="symbols">
					  <t>Set the decrypt channel to the IV generated/used on the
					  encrypt side of a channel.</t>
					  <t>Provide a vector on a block-by-block basis for appropriate
					  algorithms/modes or at each time epoch (e.g., time-of-day
					  encryption). In addition, a method is available to take a special
					  state vector called a
					   synchronization vector to assist in resynchronizing a
					  channel.</t>
					</list></t>
				</section>
				<section title="Using Channels">
					<t>Only conduits and streams (not controllers)
					can send data for transformation and receive cryptographically
					transformed data on a channel.</t>
					<t>The data operations that can be performed on a channel or stream
					are specific to each channel type, but the following general
					operations are supported:
					<list style="symbols">
					  <t>Sending data on a channel to initiate a cryptographic
					  transformation:
					  <list style="symbols">
						<t>Blocking send: Call does not return until data has been
						sent or the operation times out.</t>
						<t>Non-blocking send: Call queues data for sending and returns
						immediately to the caller.</t>
						<t>Poll: Determines status of non-blocking send
						operation.</t>
					  </list></t>
					  <t>Receiving transformed data from a channel:
					  <list style="symbols">
						<t>Blocking read: Blocks until data becomes available or the
						operation times out.</t>
						<t>Non-blocking read: Call queues a buffer to receive data and
						returns immediately.</t>
						<t>Poll: Determines status of non-blocking read
						operation.</t>
						<t>Notification via callback that data has become available
						using a ChannelEventListener.</t>
					  </list></t>
					</list></t>
					<t>Although it is possible for multiple client programs to use
					the same stream, the specification provides no facilities to
					coordinate the parties participating in the communication.</t>
					<t>Certain channel services support receiving an "answer" from a
					channel. For example, signature and hashing channels accept
					variable amounts of data for transformation before returning a
					final, constant-sized "answer" (a signature or a hash) to the
					caller. Composite channels require sending/receiving data and
					receiving a final "answer" after a discrete unit of data has been
					transformed.</t>
					<t>The figure below depicts the use of a hybrid channel. Plaintext
					is sent through the CICM API for transformation. The module
					performs encrypt and sign transformations on the plaintext data.
					Ciphertext resulting from the encrypt transform emits from the
					module in a different security domain than the one in which it
					originated. When it is finished presenting data for transformation,
					the client program requests the signature that results from the
					transaction via the API.</t>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 8. Hybrid SignEncrypt Channel Operations</t>
					<t>Consider the following hybrid channel example where a client
					program configures a channel to simultaneously encrypt and sign
					data. The encryption operation utilizes a symmetric key, and the
					signature operation utilizes an asymmetric keyset. Cleartext is
					sent into the channel for transformation, and the resulting
					ciphertext emits in another security domain. When all data for
					transformation has been presented to the channel, the caller calls
					the associated "end" method to generate and retrieve the signature
					calculated over the plaintext.</t>
					<figure>
<artwork><![CDATA[// Assume references to cryptoModule, remotePort,
// signKey, encryptKey, signAlgorithm, encryptAlgorithm, data_first,
// and data_second.

CICM::Status sCode;

// Get the ChannelManager:
CICM::ChannelManager channelManager =
cryptoModule._get_channel_manager();

// Create the appropriate conduit.
CICM::Encrypt::WithSignConduit conduit;
sCode = channelManager.create_encrypt_with_sign_conduit(remotePort,
signKey, encryptKey, signAlgorithm, encryptAlgorithm,
&conduit);

// Encrypt and sign some data.
sCode = conduit.encrypt(data_first);
sCode = conduit.encrypt(data_second);

// Retrieve the signature.
CICM::SigBuffer signature;
sCode = conduit.end_get_signature(&signature);
]]></artwork>
					</figure>
					<t>Each type of channel supports a specific set of channel data
					operations. Channel types and the data operations they support are
					listed below:
					<list style="symbols">
					  <t>Encrypt, selective bypass with encryption, and full bypass
					  write channels: Write data in the local security domain for
					  transformation and output in another security domain.</t>
					  <t>Decrypt, selective bypass with decryption, and full bypass
					  read channels: Read transformed data from one security domain
					  into the local security domain.</t>
					  <t>Coprocessor channels: Data is presented for transformation
					  and the result received within the same security domain.</t>
					  <t>Duplex channels: Read/write exchange between two security
					  domains.</t>
					  <t>Keystream and random data generation: Transformation within
					  module results in data stream that emits in the local
					  domain.</t>
					</list></t>
					<t>For example, channels for encryption and bypass can send data.
					Channels for decryption, bypass, keystream generation, and random
					data generation can receive data. Duplex and coprocessor channels
					can send and receive data.</t>
				</section>
				<section title="Grouping Channels">
					<t>Controllers and conduits can be grouped
					to enable certain characteristics to be shared. One characteristic
					may be the state vector associated with the channels. This supports
					environments where two or more channels with related security rules
					supporting a single operation are used within a system. Whenever a
					shared characteristic is changed on a controller or conduit in a
					group, the effect of this change is applied to all
					controllers/conduits in the group.</t>
				</section>
				<section title="Receiving Notification of Channel Events">
					<t>The specification
					defines methods that support managing module event notifications.
					Similar support is available at the granularity of an individual
					conduit/controller. Conduits and controllers define methods that
					support registering/unregistering channel-specific module-generated
					event notifications captured by a client program. Clients can
					register custom-developed callback procedures called
					 listeners for specific channel events. When the condition
					associated with a specific listener presents itself, the registered
					listener is called.</t>
					<t>Examples of channel events for which listeners may be registered
					include:
					<list style="symbols">
					  <t>Data is available.</t>
					  <t>Synchronization with peer has been lost.</t>
					  <t>Remote peer no longer available.</t>
					  <t>General channel error encountered.</t>
					</list></t>
				</section>
				<section title="Destroying Channels">
					<t>Conduits and controllers may be
					destroyed when their services are no longer needed. A channel is
					destroyed without regard for users who may have pending operations
					on the channel. Any ephemeral keys associated with the channel also
					may be destroyed. A stream ceases to function when its associated
					controller is destroyed. A destroyed channel is removed from any
					channel groups to which it belongs without effect upon other
					controllers/conduits in the group.</t>
				</section>
			</section>
		</section>
	</section>

	<section title="Normative Specification">
		<t>The namespaces, interfaces, datatypes,
		methods, and attributes that comprise the specification are
		presented in a prescriptive manner. The conventions used within the
		section are presented first. The subsections that follow introduce
		the API partitioned into its three major categories:
		<list style="symbols">
		  <t>Module management</t>
		  <t>Key management</t>
		  <t>Channel management.</t>
		</list></t>
		<t>For each category, each namespace is described followed by the
		interfaces contained within it. The datatype, method, and attribute
		definitions then follow each interface definition.</t>

		<section title="Introduction">
			<section title="Conventions">
				<t>Understanding the design of the API and the
				IDL interfaces that compose CICM requires an understanding of the
				conventions used in this normative specification. The conventions
				used are introduced below.</t>

				<section title="Diagrams">
					<t>{SECTION REMOVED}</t>
				</section>
				<section title="IDL Definitions">
					<t>Throughout this specification, normative
					definitions are presented using the following format:</t>
					<figure>
						<preamble>Method Cat::eat()</preamble>
						<artwork><![CDATA[void eat( in CatFood food );]]></artwork>
						<postamble>Provides the cat with food.</postamble>
					</figure>
					<t>Parameters:
						<list>
							<t>[in] food Food for the cat.</t>
						</list>
					</t>
					<t>This same format is used to provide definitions for types,
					constants, attributes, interfaces, and namespaces.</t>
				</section>
			</section>
			<section title="Normative Statements">
				<t>A number of concerns fundamental to the
				remainder of the normative specification are listed below.</t>

				<section title="Endianness">
					<t>Endianness is the byte ordering used to
					represent data stored in a computer or transmitted between
					computers. CICM requires a big-endian ordering of bytes.</t>
				</section>
				<section title="Blocking and Non-blocking Calls">
					<t>All CICM methods block
					(wait for the operation defined by the method) to complete before
					returning, unless they are explicitly defined as non-blocking. For
					example, the CICM::Encrypt::Stream::encrypt method blocks when
					sending data on a stream to be encrypted, while its sibling
					CICM::Encrypt::Stream::encrypt_non_blocking is identified not only
					in its name as non-blocking, but also clearly within the
					documentation for the method.</t>
				</section>
				<section title="IDL Language Mapping Conventions">
					<t>Memory responsibilities
					and calling conventions shall follow the appropriate IDL language
					mapping conventions.</t>
				</section>
			</section>
		</section>
		<section title="Fundamental Definitions">
			<section title="Namespace CICM">
				<figure>
					<preamble>Namespace CICM</preamble>
					<artwork><![CDATA[module CICM]]></artwork>
					<postamble>CICM is the top-level namespace for all CICM interfaces and
					sub-namespaces.</postamble>
				</figure>
			</section>
			<section title="Fundamental Types">
				<section title="General Types">
					<figure>
					  <preamble>Type CICM::UInt32</preamble>
					  <artwork><![CDATA[typedef unsigned long UInt32;]]></artwork>
					  <postamble>Unsigned 32-bit integer.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::Bool</preamble>
					  <artwork><![CDATA[typedef boolean Bool;]]></artwork>
					  <postamble>Boolean value.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::CharString</preamble>
					  <artwork><![CDATA[typedef string CharString;]]></artwork>
					  <postamble>Sequence of characters.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::Buffer</preamble>
					  <artwork><![CDATA[typedef sequence<octet> Buffer;]]></artwork>
					  <postamble>Byte sequence, encapsulating the sequence of bytes, the
					  length of the sequence, and the amount of allocated space.</postamble>
					</figure>
				</section>
				<section title="Identifiers">
					<figure>
					  <preamble>Type CICM::ModuleId</preamble>
					  <artwork><![CDATA[typedef CICM::CharString ModuleId;]]></artwork>
					  <postamble>Unique cryptographic module identifier.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::ModuleRecord</preamble>
					  <artwork><![CDATA[typedef CICM::CharString ModuleRecord;]]></artwork>
					<postamble>Unique module association record.</postamble></figure>
					<figure>
					  <preamble>Type CICM::TokenRecord</preamble>
					  <artwork><![CDATA[typedef CICM::CharString TokenRecord;]]></artwork>
					  <postamble>Unique token association record.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::PackageId</preamble>
					  <artwork><![CDATA[typedef CICM::CharString PackageId;]]></artwork>
					  <postamble>Unique package identifier.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::UserId</preamble>
					  <artwork><![CDATA[typedef CICM::CharString UserId;]]></artwork>
					  <postamble>Unique user identifier.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::RoleId</preamble>
					  <artwork><![CDATA[typedef CICM::CharString RoleId;]]></artwork>
					  <postamble>Unique role identifier.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::KeyId</preamble>
					  <artwork><![CDATA[typedef CICM::CharString KeyId;]]></artwork>
					  <postamble>Unique key identifier.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::TransId</preamble>
					  <artwork><![CDATA[typedef CICM::UInt32 TransId;]]></artwork>
					  <postamble>Unique transaction identifier for read/write operations.</postamble>
					</figure>
				</section>
				<section title="Status Codes">
					<figure>
					  <preamble>Type CICM::Status</preamble>
					  <artwork><![CDATA[typedef CICM::UInt32 Status;]]></artwork>
					  <postamble>Status of an executed method.</postamble>
					</figure>
					<t>See also:
						<list>
							<t><xref target="status-codes" /> for a full list of status codes.</t>
						</list>
					</t>
				</section>
				<section title="Classifications">
					<figure>
					  <preamble>Type CICM::Classification</preamble>
					  <artwork><![CDATA[typedef CICM::UInt32 Classification;]]></artwork>
					  <postamble>Classification levels.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::C_LEVEL_UNCLASSIFIED</preamble>
<artwork><![CDATA[const CICM::Classification
	C_LEVEL_UNCLASSIFIED = 0x0000602F;]]></artwork>
					  <postamble>Value indicating unclassified classification level.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::C_LEVEL_CONFIDENTIAL</preamble>
<artwork><![CDATA[const CICM::Classification
	C_LEVEL_CONFIDENTIAL = 0x00006029;]]></artwork>
					  <postamble>Value indicating confidential classification level.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::C_LEVEL_SECRET</preamble>
<artwork><![CDATA[const CICM::Classification
	C_LEVEL_SECRET = 0x0000602A;]]></artwork>
					  <postamble>Value indicating secret classification level.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::C_LEVEL_TOP_SECRET</preamble>
<artwork><![CDATA[const CICM::Classification
	C_LEVEL_TOP_SECRET = 0x0000602C;]]></artwork>
					  <postamble>Value indicating top secret classification level.</postamble>
					</figure>
				</section>
				<section title="Algorithms">
					<figure>
					  <preamble>Type CICM::HashAlgorithmId</preamble>
					  <artwork><![CDATA[typedef CICM::CharString HashAlgorithmId;]]></artwork>
					  <postamble>Unique hash algorithm identifier.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::AsymEncrAlgorithmId</preamble>
					  <artwork><![CDATA[typedef CICM::CharString AsymEncrAlgorithmId;]]></artwork>
					  <postamble>Unique asymmetric encryption algorithm identifier.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::IMPLICIT_ASYM_ENCR_ALGO</preamble>
<artwork><![CDATA[const CICM::AsymEncrAlgorithmId
	IMPLICIT_ASYM_ENCR_ALGO = "IMPLICIT";]]></artwork>
					  <postamble>Value that indicates that the encryption algorithm is
					  implicit in the key being provided to the module.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::AsymSigAlgorithmId</preamble>
<artwork><![CDATA[typedef CICM::CharString
	AsymSigAlgorithmId;]]></artwork>
					  <postamble>Unique asymmetric signature algorithm identifier.</postamble>
					</figure>
					<figure>
						<preamble>Constant CICM::IMPLICIT_ASYM_SIG_ALGO</preamble>
<artwork><![CDATA[const CICM::AsymSigAlgorithmId
	IMPLICIT_ASYM_SIG_ALGO = "IMPLICIT";]]></artwork>
					  <postamble>Value that indicates that the signature algorithm is
					  implicit in the key being provided to the module.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::KeyWrapAlgorithmId</preamble>
<artwork><![CDATA[typedef CICM::CharString
	KeyWrapAlgorithmId;]]></artwork>
					  <postamble>Unique key wrap algorithm identifier, incorporating both the
					algorithm and the mode.</postamble>
					</figure>
					<figure>
						<preamble>Constant CICM::IMPLICIT_KEY_WRAP_ALGO</preamble>
<artwork><![CDATA[const CICM::KeyWrapAlgorithmId
	IMPLICIT_KEY_WRAP_ALGO = "IMPLICIT";]]></artwork>
					  <postamble>Value that indicates that the key wrap algorithm is
					  implicit in the key being provided to the module.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::SymEncrAlgorithmId</preamble>
					  <artwork><![CDATA[typedef CICM::CharString SymEncrAlgorithmId;]]></artwork>
					  <postamble>Unique symmetric encryption algorithm identifier,
					  incorporating both the algorithm and the mode.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::IMPLICIT_SYM_ENCR_ALGO</preamble>
<artwork><![CDATA[const CICM::SymEncrAlgorithmId
	IMPLICIT_SYM_ENCR_ALGO = "IMPLICIT";]]></artwork>
					  <postamble>Value that indicates that the encryption algorithm is
					  implicit in the key being provided to the module.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::SymMacAlgorithmId</preamble>
					  <artwork><![CDATA[typedef CICM::CharString SymMacAlgorithmId;]]></artwork>
					  <postamble>Unique symmetric MAC algorithm identifier.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::IMPLICIT_SYM_MAC_ALGO</preamble>
<artwork><![CDATA[const CICM::SymMacAlgorithmId
	IMPLICIT_SYM_MAC_ALGO = "IMPLICIT";]]></artwork>
					  <postamble>Value that indicates that the MAC algorithm is implicit in
					  the key being provided to the module.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::ProtocolId</preamble>
					  <artwork><![CDATA[typedef CICM::CharString ProtocolId;]]></artwork>
					  <postamble>Unique key agreement protocol identifier.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::IMPLICIT_PROTOCOL_ID</preamble>
<artwork><![CDATA[const CICM::ProtocolId
	IMPLICIT_PROTOCOL_ID = "IMPLICIT";]]></artwork>
					  <postamble>Value that indicates that the key agreement protocol is
					  implicit in the message being provided to the module.</postamble>
					</figure>
				</section>
				<section title="Ports">
					<figure>
					  <preamble>Type CICM::RemotePort</preamble>
					  <artwork><![CDATA[typedef CICM::UInt32 RemotePort;]]></artwork>
					  <postamble>Remote module port.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::IMPLICIT_REMOTE_PORT</preamble>
<artwork><![CDATA[const CICM::RemotePort
	IMPLICIT_REMOTE_PORT = 0xFFFFFF99;]]></artwork>
					  <postamble>Value that indicates that the remote port value is
					  implicit.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::LocalPort</preamble>
					  <artwork><![CDATA[typedef CICM::UInt32 LocalPort;]]></artwork>
					  <postamble>Local module port.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::IMPLICIT_LOCAL_PORT</preamble>
<artwork><![CDATA[const CICM::LocalPort
	IMPLICIT_LOCAL_PORT = 0xFFFFFFBB;]]></artwork>
					  <postamble>Value that indicates that the local port value is
					  implicit.</postamble>
					</figure>
					<figure>
					  <preamble>Constant CICM::FILL_INTERFACE_PORT</preamble>
<artwork><![CDATA[const CICM::LocalPort
	FILL_INTERFACE_PORT = 0xFFFFFFEE;]]></artwork>
					  <postamble>Value that represents the port on which keys are filled or
					  exported.</postamble>
					</figure>
				</section>
				<section title="State Vector">
					<figure>
					  <preamble>Type CICM::Vector</preamble>
					  <artwork><![CDATA[typedef CICM::Buffer Vector;]]></artwork>
					  <postamble>State vector, used to represent initialization vectors,
					  synchronization vectors, counter values, and time-of-day values.</postamble>
					</figure>
				</section>
				<section title="Integrity Buffers">
					<figure>
					  <preamble>Type CICM::HashBuffer</preamble>
					  <artwork><![CDATA[typedef CICM::Buffer HashBuffer;]]></artwork>
					  <postamble>Cryptographic hash.</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::MACBuffer</preamble>
					  <artwork><![CDATA[typedef CICM::Buffer MACBuffer;]]></artwork>
					  <postamble>Message authentication code (MAC).</postamble>
					</figure>
					<figure>
					  <preamble>Type CICM::SigBuffer</preamble>
					  <artwork><![CDATA[typedef CICM::Buffer SigBuffer;]]></artwork>
					  <postamble>Cryptographic signature.</postamble>
					</figure>
				</section>
			</section>
			<section title="Fundamental Interfaces">
				<section title="Interface CICM::CICMRoot">
					<figure>
					  <preamble>Interface CICM::CICMRoot</preamble>
					  <artwork><![CDATA[interface CICMRoot]]></artwork>
					  <postamble>CICMRoot serves as the entry point to the CICM API and
					  enables a specific cryptographic module of potentially many modules
					  available to a host to be selected.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 10. Interface Relationship Diagram for CICMRoot</t>

					<section title="CICM::CICMRoot Methods">
						<figure>
							<preamble>Method CICM::CICMRoot::get_module_by_id()</preamble>
<artwork><![CDATA[CICM::Status get_module_by_id(
  in  CICM::ModuleId id,
  out CICM::CryptoModule crypto_module_ref
);]]></artwork>
							<postamble>Returns a reference to the module with the given module
							unique identifier.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] id Unique identifier for the module.</t>
								<t>[out] crypto_module_ref Module associated with the given identifier.</t>
							</list>
						</t>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_HOST_RESOURCES,
								  S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE,
								  S_TIMEOUT, S_MODULE_DOES_NOT_EXIST</t></list>
						</t>
						<figure>
							<preamble>Example (C++):</preamble>
<artwork><![CDATA[CICM::Status sCode;
CICM::CryptoModule device;

// Instantiate the root object. CICM::CICMRoot cicm =
new CICM::CICMRoot();

// Retrieve a reference to the module
// corresponding to the specified module identifier.
const string MODULE_ID = "CM10293495867";

// If found, [device] refers to the specified
crypto module. sCode = cicm.get_module_by_id(MODULE_ID, &device);]]></artwork>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::CryptoModule">
					<figure>
					  <preamble>Interface CICM::CryptoModule</preamble>
					  <artwork><![CDATA[interface CryptoModule]]></artwork>
					  <postamble>CICM::CryptoModule contains attributes that provide access to
					  module-specific information and attributes that enable access to
					  module managers, through which nearly all interface functionality
					  is accessed.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 11. Interface Relationship Diagram
					  for CryptoModule</t>

					<section title="CICM::CryptoModule Attributes">
						<figure>
						  <preamble>Attribute CICM::CryptoModule::module_id</preamble>
						  <artwork><![CDATA[readonly attribute CICM::ModuleId module_id;]]></artwork>
						  <postamble>Unique identifier for this module.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::manufacturer</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString manufacturer;]]></artwork>
						  <postamble>Name of cryptographic module manufacturer.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::model</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString model;]]></artwork>
						<postamble>Model of cryptographic module.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::serial_number</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString serial_number;]]></artwork>
						  <postamble>Serial number of cryptographic module.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::module_version</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString module_version;]]></artwork>
						  <postamble>Hardware version of cryptographic module.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::software_version</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString software_version;]]></artwork>
						  <postamble>Currently executing software/firmware version number.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::driver_version</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString driver_version;]]></artwork>
						  <postamble>CICM module-specific abstraction layer version number.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::library_version</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString library_version;]]></artwork>
						  <postamble>CICM library version number.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::role</preamble>
						  <artwork><![CDATA[readonly attribute CICM::RoleId role;]]></artwork>
						  <postamble>Current security role in which module is operating.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::date_time</preamble>
						  <artwork><![CDATA[attribute CICM::CharString date_time;]]></artwork>
						  <postamble>Current date/time. Intended for use only with module services
						  that require coarse-grained time (e.g., timestamp on a log), not
						  for time-of-day encryption.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::sym_key_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymKeyManager sym_key_manager;]]></artwork>
						  <postamble>Reference to CICM::SymKeyManager.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::asym_key_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymKeyManager asym_key_manager;]]></artwork>
						  <postamble>Reference to CICM::AsymKeyManager.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::key_database</preamble>
						  <artwork><![CDATA[readonly attribute CICM::KeyDatabase key_database;]]></artwork>
						  <postamble>Reference to CICM::KeyDatabase.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::channel_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::ChannelManager channel_manager;]]></artwork>
						  <postamble>Reference to CICM::ChannelManager.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::event_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::ModuleEventManager event_manager;]]></artwork>
						  <postamble>Reference to CICM::ModuleEventManager.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::package_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::PackageManager package_manager;]]></artwork>
						  <postamble>Reference to CICM::PackageManager.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::token_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::TokenManager token_manager;]]></artwork>
						  <postamble>Reference to CICM::TokenManager.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::user_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::UserManager user_manager;]]></artwork>
						  <postamble>Reference to CICM::UserManager.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::login_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::LoginManager login_manager;]]></artwork>
						  <postamble>Reference to CICM::LoginManager.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::test_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::TestManager test_manager;]]></artwork>
						  <postamble>Reference to CICM::TestManager.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::CryptoModule::log_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::LogManager log_manager;]]></artwork>
						  <postamble>Reference to CICM::LogManager.</postamble>
						</figure>
					</section>
					<section title="CICM::CryptoModule Methods">
						<figure>
						  <preamble>Method CICM::CryptoModule::configure_fill_interface()</preamble>
<artwork><![CDATA[CICM::Status configure_fill_interface(
	in  CICM::Buffer interface_parameters,
	in  CICM::LocalPort fill_port
);]]></artwork>
							<postamble>Configure a module key fill interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This method accepts an opaque buffer containing a
								module-specific data structure specifying fill port
								configuration parameters.</t>
								<t>The format of the interface parameters value is not defined
								by CICM. The Implementation Conformance Statement (see Section
								4, Conformance and Extensions) must reference a standard format
								or define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] interface_parameters Opaque buffer containing
								the fill interface configuration parameters.</t>
								<t>[in] fill_port Fill port to configure.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
						  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
						  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
						  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
						  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_DATA_BUFFER,
						  S_KEY_FILL_DEVICE_NOT_CONNECTED, S_LOCAL_PORT_INVALID,
						  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
						  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>

						<figure>
						  <preamble>Method CICM::CryptoModule::reset()</preamble>
						  <artwork><![CDATA[CICM::Status reset();]]></artwork>
						  <postamble>Perform a software-initiated reset on the module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This method attempts to restart a module in the event of a
								module failure or in the event a module has entered an alarm
								state. A CICM::S_OK status denotes that the command was
								accepted by the module or runtime system, not that any specific
								action has been initiated as a result of the reset
								request.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
								<section title="Interface CICM::Iterator">
					<figure>
					  <preamble>Interface CICM::Iterator</preamble>
					  <artwork><![CDATA[interface Iterator]]></artwork>
					  <postamble>Interface from which other iterators are inherited.</postamble>
					</figure>
					<t>Remarks:
					  <list>
						  <t>The specification does not define any specific order in which
						  iterated elements are returned.</t>
						</list>
					</t>

					<section title="CICM::Iterator Types and Constants">
						<figure>
						  <preamble>Type CICM::Iterator::Status</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Status;]]></artwork>
						  <postamble>Indicates whether or not there are more items over which to
						  iterate.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Iterator::C_ITERATOR_HAS_NEXT</preamble>
<artwork><![CDATA[const CICM::Iterator::Status
	C_ITERATOR_HAS_NEXT = 0x00006031;]]></artwork>
							<postamble>There are more items in the list.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Iterator::C_ITERATOR_NO_MORE</preamble>
<artwork><![CDATA[const CICM::Iterator::Status
	C_ITERATOR_NO_MORE = 0x00006032;]]></artwork>
							<postamble>There are no more items in the list.</postamble>
						</figure>
					</section>
					<section title="CICM::Iterator Methods">
						<figure>
						  <preamble>Method CICM::Iterator::has_next()</preamble>
<artwork><![CDATA[CICM::Status has_next(
	out CICM::Iterator::Status has_next
);]]></artwork>
						  <postamble>Used with get_next() to determine if one or more additional
						  elements are available to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>For elements that have not already been processed, changes
								in the state of the list/database over which the iterator is
								being run during the lifetime of the iterator will be reflected
								in the results from calls to retrieve iterator elements.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] has_next Indicates whether more elements are available to be retrieved.</t>
							</list>
						</t><t>Returns:
							<list>
							  <t>S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
		</section>
		<section title="Module Management">
			<section title="Managing Hardware Access Tokens">
				<t>Cryptographic modules may rely upon hardware
				access tokens for two primary functions: to allow subjects (e.g.,
				administrators or users in possession of a token) to be identified
				and authenticated so that privileges can be enforced and audit log
				entries can identify the subject; and to unlock all or some subset
				of cryptographic services. A hardware access token may be
				associated with a number of specific modules, and a module may
				likewise be associated with a number of specific tokens. The token
				management functions below enable tokens and modules to be
				associated with and disassociated from one another, and allow
				existing associations to be listed.</t>
				<t>The removal of an association between a token and a module is
				straightforward if both the token and the module are available.
				However, if either the token or module are unavailable, or if a
				different module than the one originally associated with the token
				is used to remove an association from a token, the disassociation
				is less straightforward.</t>
				<t>If a module requires that an administrative token be inserted
				prior to the token to which the association/disassociation will
				apply, the methods below may return an CICM::S_TOKEN_NOT_PRESENT or
				CICM::S_TOKEN_ADMIN_NOT_PRESENT status.</t>
				<t>Modules that do not support hardware tokens may instead provide
				similar support via CICM::LoginManager. Modules may use
				CICM::LoginManager in tandem with tokens to support multi-factor
				authentication. See the Managing Module Authentication subsection
				in Section 2 for additional information.</t>

				<section title="Interface CICM::TokenManager">
					<figure>
					  <preamble>Interface CICM::TokenManager</preamble>
					  <artwork><![CDATA[interface TokenManager {]]></artwork>
					  <postamble>CICM::TokenManager supports associating and disassociating
					  modules and tokens. It is accessed from CICM::CryptoModule via the
					  CICM::CryptoModule::token_manager attribute. CICM::TokenManager
					  constructs the CICM::ModuleAssnIterator and CICM::TokenAssnIterator
					  interfaces.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 12. Interface Relationship Diagram for TokenManager</t>
					<figure>
						<preamble>Example (C++):</preamble>
<artwork><![CDATA[// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;

CICM::Status sCode;
CICM::tokenManager tokenManager;

// Retrieve reference to the token manager.
tokenManager = device._get_token_manager();

// Associate the current token with the module.
sCode = tokenManager.associate();

// Assume that some time later the token is lost or destroyed.

// Disassociate the token from the module.
CICM::TokenUniqueId tokenId = new CICM::TokenUniqueId("TOKEN1426864");
sCode = tokenManager.disassociate_missing_token(tokenId);
]]></artwork>
					</figure>
					<section title="CICM::TokenManager Attributes">
						<figure>
						  <preamble>Attribute CICM::TokenManager::module_association_iterator</preamble>
<artwork><![CDATA[readonly attribute CICM::ModuleAssnIterator
	module_association_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable each module identifier
						  associated with the current token to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The returned iterator is set to the beginning of the iterated sequence.</t>
							</list>
						</t>
						<figure>
						  <preamble>Attribute CICM::TokenManager::token_association_iterator</preamble>
<artwork><![CDATA[readonly attribute CICM::TokenAssnIterator
	token_association_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable each token identifier
						  associated with the current module to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							  <t>The returned iterator is set to the beginning of the iterated
							  sequence.</t>
							</list>
						</t>
					</section>
					<section title="CICM::TokenManager Methods">
						<figure>
						  <preamble>Method CICM::TokenManager::associate()</preamble>
<artwork><![CDATA[CICM::Status associate(
	out CICM::ModuleRecord module_rec,
	out CICM::TokenRecord token_rec
);]]></artwork>
						   <postamble>Associate the module and currently-inserted hardware access
						   token.</postamble>
						 </figure>
						<t>Remarks:
							<list>
								<t>The module and token record identifiers should be recorded
								for use in the disassociation process in the event that either
								the module or the token are no longer available or usable.</t>
								<t>The formats of the module and token records are not defined
								by CICM. The Implementation Conformance Statement (see Section
								4, Conformance and Extensions) must reference a standard format
								or define a module developer-specific format implemented by the
								module for these datatypes.</t>
							</list>
						</t><t>Parameters:
							<list>
							  <t>[in] module_rec Module record identifier of the newly associated module.</t>
							  <t>[in] token_rec Token record identifier of the newly associated token.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS, S_TOKEN_RESOURCES,
								  S_TOKEN_ASSOC_EXISTS, S_TOKEN_ASSOC_AT_MODULE,
								  S_TOKEN_ASSOC_AT_TOKEN, S_TOKEN_ASSOC_GENERAL,
								  S_TOKEN_TIMEOUT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::TokenManager::disassociate()</preamble>
						  <artwork><![CDATA[CICM::Status disassociate();]]></artwork>
						  <postamble>Disassociate the module and currently-inserted hardware
							access token when the associated module and token are both present
							and both recognize the association.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS,
								  S_TOKEN_ASSOC_NOT_EXIST, S_TOKEN_DISASSOC_GENERAL,
								  S_TOKEN_TIMEOUT, S_TOKEN_LAST_ASSOCIATED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::TokenManager::disassociate_missing_module()</preamble>
<artwork><![CDATA[CICM::Status disassociate_missing_module(
	in  CICM::ModuleRecord module_rec
);]]></artwork>
						  <postamble>Remove association information from the currently-inserted
							hardware access token when the associated module is not
							present.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The module on which this method is being executed is used
								as a surrogate to perform the disassociation (it is not the
								module that performed the initial association). The specific
								module to disassociate from the token is identified by a unique
								module identifier (e.g., a module serial number). Use
								CICM::ModuleAssnIterator to retrieve module record identifiers
								corresponding to modules associated with the inserted token.</t>
								<t>The format of the module record is not defined by CICM. The
								Implementation Conformance Statement (see Section 4,
								Conformance and Extensions) must reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] module_rec Identifies the module for which module identification
								  information should be removed from the currently-inserted
								  hardware access token.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ACCESS,
								  S_TOKEN_DISASSOC_GENERAL, S_TOKEN_REC_NOT_FOUND,
								  S_TOKEN_TIMEOUT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::TokenManager::disassociate_missing_token()</preamble>
<artwork><![CDATA[CICM::Status disassociate_missing_token(
	in  CICM::TokenRecord token_rec
);]]></artwork>
						  <postamble>Remove association information from the module on which this
							method is being executed when the associated token is not
							present.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The specific token to disassociate from the module is
								identified by a unique token identifier (e.g., a token serial
								number). Use CICM::TokenAssnIterator to retrieve token record
								identifiers corresponding to associated tokens from the module.</t>

								<t>The format of the token record is not defined by CICM. The
								Implementation Conformance Statement (see Section 4,
								Conformance and Extensions) must reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] token_rec Identifies the hardware access token for which token
								  identification information should be removed from the
								  module.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_TOKEN_ASSOC_NOT_EXIST,
								  S_TOKEN_DISASSOC_GENERAL, S_TOKEN_REC_NOT_FOUND,
								  S_TOKEN_TIMEOUT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::TokenAssnIterator">
					<figure>
					  <preamble>Interface CICM::TokenAssnIterator</preamble>
					  <artwork><![CDATA[interface TokenAssnIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::TokenAssnIterator supports retrieving each token record
						from the token association list in the module.</postamble>
					</figure>

					<section title="CICM::TokenAssnIterator Inheritance">
					<t>CICM::TokenAssnIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::TokenAssnIterator Methods">
						<figure>
						  <preamble>Method CICM::TokenAssnIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::TokenRecord token_rec_ref
);]]></artwork>
						  <postamble>Returns a reference to the next token.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional
								elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] token_rec_ref Reference to next token.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
								<section title="Interface CICM::ModuleAssnIterator">
					<figure>
					  <preamble>Interface CICM::ModuleAssnIterator</preamble>
					  <artwork><![CDATA[interface ModuleAssnIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::ModuleAssnIterator supports retrieving each module
						record from the module association list in the token.</postamble>
					</figure>

					<section title="CICM::ModuleAssnIterator Inheritance">
					<t>CICM::ModuleAssnIterator inherits from: CICM::Iterator.</t>
					</section>

					<section title="CICM::ModuleAssnIterator Methods">
						<figure>
						  <preamble>Method CICM::ModuleAssnIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::ModuleRecord module_rec_ref
);]]></artwork>
						  <postamble>Returns a reference to the next module record from the module
							association list in the token.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional
								elements exist.</t>
							</list>
						</t><t>Parameters:
						  <list>
							  <t>[out] module_rec_ref  Reference to next module record.</t>
						  </list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Managing Users">
				<t>These interfaces enable the management of
				users in support of password-based login. See the Managing Module
				Authentication subsection in Section 2 for additional
				information.</t>

				<section title="Interface CICM::UserManager">
					<figure>
					  <preamble>Interface CICM::UserManager</preamble>
					  <artwork><![CDATA[interface UserManager {]]></artwork>
					  <postamble>CICM::UserManager supports adding a user/password, modifying
						a user's password, and removing users; and associating and
						disassociating users from a role. It is accessed from
						CICM::CryptoModule via the CICM::CryptoModule::user_manager
						attribute. CICM::UserManager constructs the CICM::UserIdIterator
						and CICM::RoleIdIterator interfaces.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 13. Interface Relationship Diagram for UserManager</t>
					<figure>
					  <preamble>Example (C++):</preamble>
<artwork><![CDATA[// See CICMRoot::get_module_by_id()
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;

CICM::Status sCode;
CICM::UserManager userManager;

// Retrieve reference to the user manager.
userManager = device._get_user_manager();

// Create the user.
CICM::UserUniqueId userId = "bob_smith";
CICM::CharString password = "p@$$w0rd";
sCode = userManager.add(userId, password);

// Associate the user with a pre-defined module role.
CICM::RoleUniqueId roleId = "administrator";
sCode = userManager.associate(userId, roleId);

// Destroy the user.
sCode = userManager.remove(userId);]]></artwork>
					</figure>

					<section title="CICM::UserManager Attributes">
						<figure>
						  <preamble>Attribute CICM::UserManager::user_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::UserIdIterator user_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable an identifier for each user in
							the module user database to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The returned iterator is set to the beginning of the
								iterated sequence.</t>
						  </list>
						</t>
						<figure>
						  <preamble>Attribute CICM::UserManager::role_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::RoleIdIterator role_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable an identifier for each role
							supported by the module to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							  <t>The returned iterator is set to the beginning of the iterated
							  sequence.</t>
							</list>
						</t>
					</section>
					<section title="CICM::UserManager Methods">
						<figure>
						  <preamble>Method CICM::UserManager::add()</preamble>
<artwork><![CDATA[CICM::Status add(
	in  CICM::UserId user,
	in  CICM::CharString password
);]]></artwork>
						  <postamble>Add a user to the module user database.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user New user to add.</t>
								<t>[in] password New user's password.</t>

							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USERNAME_INVALID, S_USER_EXISTS,
								  S_PASSWORD_INVALID, S_PASSWORD_INVALID_CHAR,
								  S_PASSWORD_INVALID_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::UserManager::modify()</preamble>
<artwork><![CDATA[CICM::Status modify(
	in  CICM::UserId user,
	in  CICM::CharString password
);]]></artwork>
						  <postamble>Change the password of a user in the module user
							database.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user User to modify.</t>
								<t>[in] password User's new password.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID,
								  S_PASSWORD_INVALID, S_PASSWORD_INVALID_CHAR,
								  S_PASSWORD_INVALID_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::UserManager::remove()</preamble>
<artwork><![CDATA[CICM::Status remove(
	in  CICM::UserId user
);]]></artwork>
						  <postamble>Remove a user from the module user database.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user User to remove.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::UserManager::associate()</preamble>
<artwork><![CDATA[CICM::Status associate(
	in  CICM::UserId user,
	in  CICM::RoleId role
);]]></artwork>
						  <postamble>Associate a role with the specified user.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user User to associate.</t>
								<t>[in] role Role to associate with the user.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID, S_ROLE_INVALID,
								  S_ROLE_ASSOCIATED, S_ROLE_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::UserManager::disassociate()</preamble>
<artwork><![CDATA[CICM::Status disassociate(
	in  CICM::UserId user,
	in  CICM::RoleId role
);]]></artwork>
						  <postamble>Disassociate a role from the specified user.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user User to disassociate.</t>
								<t>[in] role Role to disassociate from the user.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_USER_INVALID, S_ROLE_INVALID,
								  S_ROLE_NOT_ASSOCIATED</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::UserIdIterator">
					<figure>
					  <preamble>Interface CICM::UserIdIterator</preamble>
					  <artwork><![CDATA[interface UserIdIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::UserIdIterator supports retrieving each user configured on a module.</postamble>
					</figure>

					<section title="CICM::UserIdIterator Inheritance">
						<t>CICM::UserIdIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::UserIdIterator Methods">
						<figure>
						  <preamble>Method CICM::UserIdIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::UserId user_id
);]]></artwork>
						  <postamble>Returns the next user identifier.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional
								elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] user_id Next user identifier.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::RoleIdIterator">
					<figure>
					  <preamble>Interface CICM::RoleIdIterator</preamble>
					  <artwork><![CDATA[interface RoleIdIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::RoleIdIterator supports retrieving each role available on a module.</postamble>
					</figure>

					<section title="CICM::RoleIdIterator Inheritance">
						<t>CICM::RoleIdIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::RoleIdIterator Methods">
						<figure>
						  <preamble>Method CICM::RoleIdIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::RoleId role_id
);]]></artwork>
						  <postamble>Returns the next role identifier.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional
								elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] role_id Reference to next role identifier.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Managing Login">
				<t>These interfaces support a user configured on
				a module to login to a module using a password and, optionally,
				additional authentication data. See the Managing Module
				Authentication subsection in Section 2 for additional information.</t>
				<t>Modules that support hardware tokens may use the login manager
				in tandem with the CICM::TokenManager to support multi-factor
				authentication.</t>

				<section title="Interface CICM::LoginManager">
					<figure>
					  <preamble>Interface CICM::LoginManager</preamble>
					  <artwork><![CDATA[interface LoginManager {]]></artwork>
					  <postamble>CICM::LoginManager supports user login to a module. It is
						accessed from CICM::CryptoModule via the
						CICM::CryptoModule::login_manager attribute. CICM::LoginManager
						constructs the CICM::Login interface. The LoginManager relies upon
						the CICM::UserManager to manage the users that are specified to the
						login methods.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 14. Interface Relationship Diagram for LoginManager</t>
					<figure>
						<preamble>Example (C++):</preamble>
<artwork><![CDATA[// See CICMRoot::get_module_by_id() 
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::LoginManager loginManager;
CICM::Login loginRef;
// Retrieve reference to the login manager.
loginManager = device._get_login_manager();
// Login to the module.
CICM::UserUniqueId userId = "bob_smith";
CICM::CharString password = "p@$$w0rd";
sCode = loginManager.add(userId, password, &loginRef);
// Logout from the module.
sCode = loginRef.logout();]]></artwork>
					</figure>

					<section title="CICM::LoginManager Methods">
						<figure>
						  <preamble>Method CICM::LoginManager::login()</preamble>
<artwork><![CDATA[ CICM::Status login(
	in  CICM::UserId user,
	in  CICM::CharString password,
	out CICM::Login login_ref
);]]></artwork>
						  <postamble>Login to the module with username/password.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] user User attempting to login.</t>
								<t>[in] password User's password.</t>
								<t>[out] login_ref Reference to state resulting from successful
									user login enabling the user to later logout.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_AUTHENTICATION_FAILED,
								  S_USER_AUTHENTICATED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::LoginManager::login_auth_data()</preamble>
<artwork><![CDATA[CICM::Status login_auth_data(
	in  CICM::UserId user,
	in  CICM::CharString password,
	in  CICM::Buffer auth_data,
	out CICM::Login login_ref
);]]></artwork>
						  <postamble>Login to the module with username/password, but provide
							additional (potentially host-stored) authentication data to the
							module for use in the authentication process.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This may be used in cases where the host supports a virtual token.</t>
								<t>The format of the authentication data is not defined by
								CICM. The Implementation Conformance Statement (see Section 4,
								Conformance and Extensions) must reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] user User attempting to login.</t>
								<t>[in] password User's password.</t>
								<t>[in] auth_data Additional host-stored authentication data.</t>
								<t>[out] login_ref Reference to state resulting from successful user
									  login enabling the user to later logout.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_DATA_BUFFER,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
								  S_AUTHENTICATION_FAILED, S_USER_AUTHENTICATED</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Login">
					<figure>
					  <preamble>Interface CICM::Login</preamble>
					  <artwork><![CDATA[interface Login {]]></artwork>
					  <postamble>CICM::Login results from a successful user login to a
						module and enables the user to log out from the module.</postamble>
					</figure>

					<section title="CICM::Login Methods">
						<figure>
						  <preamble>Method CICM::Login::logout()</preamble>
						  <artwork><![CDATA[CICM::Status logout();]]></artwork>
						  <postamble>Logout of the module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This may be equivalent to disconnecting a hardware access
								token from a module in certain systems.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Managing Software Packages">
				<t>These interfaces support software, FPGA
				images, policy databases, configuration parameters, or other types
				of executable or interpretable code to be imported into and removed
				from a module.</t>

				<section title="Interface CICM::PackageManager">
					<figure>
					  <preamble>Interface CICM::PackageManager</preamble>
					  <artwork><![CDATA[interface PackageManager {]]></artwork>
					  <postamble>CICM::PackageManager supports the management of module
						software packages. It is accessed from CICM::CryptoModule via the
						CICM::CryptoModule::package_manager attribute. CICM::PackageManager
						constructs the CICM::PackageImporter, CICM::PackageIterator, and
						CICM::Package interfaces.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 15. Interface Relationship Diagram for PackageManager</t>
					<figure>
					  <preamble>Example (C++):</preamble>
<artwork><![CDATA[// See CICMRoot::get_module_by_id() 
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::PackageManager packageManager;
CICM::PackageImporter packageImporter;
// Retrieve reference to the package manager.
packageManager = device._get_package_manager();

// Initialize the import process.
sCode = packageManager.import_package(
	CICM::Package::C_PACKAGE_FPGA_IMAGE, &packageImporter);

// Assume FPGA image data in [fpgaData].
CICM::Buffer fpgaData;
sCode = packageImporter.import_segment(fpgaData);

// Assume all segments are imported.
// Complete the import process.

CICM::Package fpgaPackage;
sCode = packageImporter.complete(&fpgaPackage);
// If successful, [fpgaPackage] is a reference to the imported package.
// Activate the package.
sCode = fpgaPackage.activate();]]></artwork>
					</figure>

					<section title="CICM::PackageManager Attributes">
						<figure>
						  <preamble>Attribute CICM::PackageManager::package_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::PackageIterator package_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable a reference to each
							package loaded on the module to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							  <t>The returned iterator is set to the beginning of the iterated
							  sequence.</t>
							</list>
						</t>
					</section>
					<section title="CICM::PackageManager Methods">
						<figure>
						  <preamble>Method CICM::PackageManager::import_package()</preamble>
<artwork><![CDATA[CICM::Status import_package(
	in  CICM::Package::PackageType package_type,
	out CICM::PackageImporter importer_ref
);]]></artwork>
						  <postamble>Initiate the process of importing a package into the module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The CICM::PackageImporter that results from this call is
								used to import package segments into the module. It is the
								responsibility of the caller to break a package into segments,
								import each individual segment, and then call
								CICM::PackageImporter::complete to receive a reference to the
								resulting package. Note that the key required to decrypt any
								encrypted package segments must be referenced within the
								package and must be available to the module; the key may be
								explicitly specified by using the
								CICM::PackageManager::import_package_with_key version of the
								call.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] package_type Type of the package being imported.</t>
							<t>[out] importer_ref Reference to package importer interface which enables
								  a package to be imported segment by segment.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_TYPE_INVALID,
								  S_PACKAGE_KEY_NOT_AVAILABLE,
								  S_PACKAGE_KEY_NOT_SPECIFIED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::PackageManager::import_package_with_key()</preamble>
<artwork><![CDATA[CICM::Status import_package_with_key(
	in  CICM::Package::PackageType package_type,
	in  CICM::SymKey key_ref,
	out CICM::PackageImporter importer_ref
);]]></artwork>
						  <postamble>Initiate the process of importing a package into the module,
							specifying a reference to the key that will be used by
							CICM::PackageImporter to decrypt each package segment.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The CICM::PackageImporter that results from this call is
								used to import package segments into the module. It is the
								responsibility of the caller to break a package into segments,
								import each individual segment, and then call
								CICM::PackageImporter::complete to receive a reference to the
								resulting package.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] package_type Type of the package being imported.</t>
							<t>[in] key_ref Reference to key to decrypt package segments.</t>
							<t>[out] importer_ref Reference to package importer interface which enables
								  a package to be imported segment by segment.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_TYPE_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::PackageManager::get_package_by_id()</preamble>
<artwork><![CDATA[CICM::Status get_package_by_id(
	in  CICM::PackageId package_id,
	out CICM::Package package_ref
);]]></artwork>
						  <postamble>Retrieve a reference to a package based upon a unique
							identifier associated with that package.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] package_id Package identifier.</t>
								<t>[out] package_ref Reference to package corresponding to the specified identifier.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::PackageManager::reencrypt_software()</preamble>
						  <artwork><![CDATA[CICM::Status reencrypt_software();]]></artwork>
						  <postamble>Re-encrypt module software with a key managed by the module.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::PackageImporter">
					<figure>
					  <preamble>Interface CICM::PackageImporter</preamble>
					  <artwork><![CDATA[interface PackageImporter {]]></artwork>
					  <postamble>CICM::PackageImporter supports importing software packages,
						segment by segment. CICM::PackageImporter is constructed by the
						CICM::PackageManager::import_package and
						CICM::PackageManager::import_package_with_key methods and may not
						be instantiated independently. CICM::PackageImporter constructs the
						CICM::Package interface.</postamble>
					</figure>
					<section title="CICM::PackageImporter Methods">
						<figure>
						  <preamble>Method CICM::PackageImporter::import_segment()</preamble>
<artwork><![CDATA[CICM::Status import_segment(
	in  CICM::Buffer package_data
);]]></artwork>
						  <postamble>Import one segment of a package.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>It is the responsibility of the caller to break a package
								into segments, import each individual segment, and then call
								CICM::PackageImporter::complete to receive a reference to the
								resulting package.</t>
								<t>CICM does not specify the structure of the binary data that
								constitutes the package being imported. The Implementation
								Conformance Statement (see Section 4, Conformance and
								Extensions) must reference a standard format or define a module
								developer-specific format implemented by the module for this
								datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] package_data Contents of the package.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::PackageImporter::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Package package_ref
);]]></artwork>
						  <postamble>Declare the package import complete and retrieve
							a reference to the resulting package object.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>If this method is called before the package is fully
								loaded, the CICM::S_PACKAGE_INVALID status results.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] package_ref Reference to resulting imported package.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES,
								  S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE,
								  S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED,
								  S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::PackageImporter::abort()</preamble>
						  <artwork><![CDATA[CICM::Status abort();]]></artwork>
						  <postamble>Abort a package import, resetting this CICM::PackageImporter
							instance, allowing a new package import session to begin.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Segments already imported are discarded.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Package">
					<figure>
					  <preamble>Interface CICM::Package</preamble>
					  <artwork><![CDATA[interface Package {]]></artwork>
					  <postamble>CICM::Package serves as a reference to a package previously
						loaded into a module, and supports activating, deactivating, and
						deleting the package. CICM::Package is constructed by the
						CICM::PackageManager::get_package_by_id and
						CICM::PackageImporter::complete methods and may not be instantiated
						independently.</postamble>
					</figure>

					<section title="CICM::Package Types and Constants">
						<figure>
						  <preamble>Type CICM::Package::PackageType</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 PackageType;]]></artwork>
						  <postamble>Supported package types.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Package::C_PACKAGE_ALGORITHM</preamble>
<artwork><![CDATA[const CICM::Package::PackageType
	C_PACKAGE_ALGORITHM = 0x00006054;]]></artwork>
							<postamble>Algorithm package type.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Package::C_PACKAGE_CONFIG_PARAMS</preamble>
<artwork><![CDATA[const CICM::Package::PackageType
	C_PACKAGE_CONFIG_PARAMS = 0x00006057;]]></artwork>
							<postamble>Configuration parameter package type.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Package::C_PACKAGE_FPGA_IMAGE</preamble>
<artwork><![CDATA[const CICM::Package::PackageType
	C_PACKAGE_FPGA_IMAGE = 0x00006058;]]></artwork>
							<postamble>FPGA image package type.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Package::C_PACKAGE_POLICY_DB</preamble>
<artwork><![CDATA[const CICM::Package::PackageType
	C_PACKAGE_POLICY_DB = 0x0000605B;]]></artwork>
							<postamble>Policy database package type.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Package::C_PACKAGE_SOFTWARE</preamble>
<artwork><![CDATA[const CICM::Package::PackageType
	C_PACKAGE_SOFTWARE = 0x0000605D;]]></artwork>
							<postamble>Software package type.</postamble>
						</figure>
					</section>
					<section title="CICM::Package Attributes">
						<figure>
						  <preamble>Attribute CICM::Package::id</preamble>
						  <artwork><![CDATA[readonly attribute CICM::PackageId id;]]></artwork>
						  <postamble>Unique package identifier of this package.</postamble>
						</figure>
					</section>
					<section title="CICM::Package Methods">
						<figure>
						  <preamble>Method CICM::Package::activate()</preamble>
						  <artwork><![CDATA[CICM::Status activate();]]></artwork>
						  <postamble>Activate a specific package on the module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>It may be necessary to reset the module before the
								specified package is activated in place of the currently
								activated package.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_NOT_ACTIVATABLE,
								  S_PACKAGE_ACTIVATED, S_PACKAGE_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Package::deactivate()</preamble>
						  <artwork><![CDATA[CICM::Status deactivate();]]></artwork>
						  <postamble>Deactivate a specific package on the module.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_NOT_ACTIVE,
								  S_PACKAGE_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Package::delete()</preamble>
						  <artwork><![CDATA[CICM::Status delete();]]></artwork>
						  <postamble>Delete a package from the module.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_PACKAGE_ACTIVATED,
								  S_PACKAGE_INVALID</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::PackageIterator">
					<figure>
					  <preamble>Interface CICM::PackageIterator</preamble>
					  <artwork><![CDATA[interface PackageIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::PackageIterator supports retrieving a reference to each
						software package available on a module. CICM::PackageIterator
						constructs the CICM::Package interface.</postamble>
					</figure>

					<section title="CICM::PackageIterator Inheritance">
						<t>CICM::PackageIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::PackageIterator Methods">
						<figure>
						  <preamble>Method CICM::PackageIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::Package package_ref
);]]></artwork>
						  <postamble>Returns a reference to the next software package.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional
								elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] package_ref Reference to next software package.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Managing Logs">
				<t>These interfaces support the retrieval and removal of log entries.</t>
				<section title="Interface CICM::LogManager">
					<figure>
					  <preamble>Interface CICM::LogManager</preamble>
					  <artwork><![CDATA[interface LogManager {]]></artwork>
					  <postamble>CICM::LogManager supports retrieving or destroying an entire
						module log, or retrieving or deleting individual log entries. It is
						accessed from CICM::CryptoModule via the
						CICM::CryptoModule::log_manager attribute. CICM::LogManager
						constructs the CICM::LogEntryIterator interface.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 16. Interface Relationship Diagram for LogManager</t>
					<figure>
					  <preamble>Example (C++):</preamble>
<artwork><![CDATA[// See CICMRoot::get_module_by_id() 
// to retrieve reference to CryptoModule.
CICM::CryptoModule device;
CICM::Status sCode;
CICM::LogManager logManager;

// Retrieve reference to the log manager.
logManager = device._get_log_manager();

// Retrieve reference to a log entry iterator.
CICM::LogEntryIterator iter;
iter = logManager._get_log_entry_iterator();
CICM::Iterator::Status status;
CICM::LogEntry entry;

// Confirm that there are log entries.
sCode = iter.hasNext(&status);

// Iterate over the log entries.
while( CICM::Iterator::C_ITERATOR_HAS_NEXT == status ) {
        sCode = iter.get_next(&entry);
		// Perform an operation on [entry].
        sCode = iter.hasNext(&status);
}
// Delete all of the log entries.
sCode = logManager.destroy();]]></artwork>
					</figure>

					<section title="CICM::LogManager Attributes">
						<figure>
						  <preamble>Attribute CICM::LogManager::log_entry_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::LogEntryIterator log_entry_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable a reference to each module
							CICM::LogEntry to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							  <t>The returned iterator is set to the beginning of the iterated
							  sequence.</t>
							</list>
						</t>
					</section>
					<section title="CICM::LogManager Methods">
						<figure>
							<preamble>Method CICM::LogManager::retrieve()</preamble>
<artwork><![CDATA[ CICM::Status retrieve(
	out CICM::Buffer log_ref
);]]></artwork>
							<postamble>Retrieve a reference to the entire module log.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[out] log_ref Reference to entire module log.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::LogManager::destroy()</preamble>
						  <artwork><![CDATA[CICM::Status destroy();]]></artwork>
						  <postamble>Destroy all entries in the module log.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::LogEntry">
					<figure>
					  <preamble>Interface CICM::LogEntry</preamble>
					  <artwork><![CDATA[interface LogEntry {]]></artwork>
					  <postamble>CICM::LogEntry serves as a reference to an individual log
						entry in the module log, and supports retrieving information about
						an individual log entry and deleting an individual log entry.</postamble>
					</figure>

					<section title="CICM::LogEntry Attributes">
						<figure>
						  <preamble>Attribute CICM::LogEntry::user_id</preamble>
						  <artwork><![CDATA[readonly attribute CICM::UserId user_id;]]></artwork>
						  <postamble>User initiating the module action resulting in this log entry.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::LogEntry::role_id</preamble>
						  <artwork><![CDATA[readonly attribute CICM::RoleId role_id;]]></artwork>
						  <postamble>Role under which the module action resulting in this log
							entry was initiated.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::LogEntry::message</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString message;]]></artwork>
						  <postamble>Log message associated with this log entry.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::LogEntry::date_time</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString date_time;]]></artwork>
						  <postamble>Date/time of creation of this log entry.</postamble>
						</figure>
					</section>
					<section title="CICM::LogEntry Methods">
						<figure>
						  <preamble>Method CICM::LogEntry::delete()</preamble>
						  <artwork><![CDATA[CICM::Status delete();]]></artwork>
						  <postamble>Remove the current entry from the module log.</postamble>
						</figure>
						<t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_LOG_ENTRY_INVALID</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::LogEntryIterator">
					<figure>
					  <preamble>Interface CICM::LogEntryIterator</preamble>
					  <artwork><![CDATA[interface LogEntryIterator : CICM::Iterator {]]></artwork>
					  <postamble>CICM::LogEntryIterator supports retrieving a reference to
						each log entry in the module log. CICM::LogEntryIterator constructs
						the CICM::LogEntry interface.</postamble>
					</figure>

					<section title="CICM::LogEntryIterator Inheritance">
						<t>CICM::LogEntryIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::LogEntryIterator Methods">
						<figure>
						  <preamble>Method CICM::LogEntryIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::LogEntry log_entry_ref
);]]></artwork>
						  <postamble>Returns a reference to the next log entry.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Use CICM::Iterator::has_next to determine if additional elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] log_entry_ref Reference to next log entry.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Managing Tests">
				<t>These interfaces support the initiation of module internal tests by client programs.</t>

				<section title="Interface CICM::TestManager">
					<figure>
					  <preamble>Interface CICM::TestManager</preamble>
					  <artwork><![CDATA[interface TestManager {]]></artwork>
					  <postamble>CICM::TestManager supports initiating client program-invoked
						module built-in tests. It is accessed from CICM::CryptoModule via
						the CICM::CryptoModule::test_manager attribute.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 17. Interface Relationship Diagram for TestManager</t>

					<section title="CICM::TestManager Types and Constants">
						<figure>
						  <preamble>Type CICM::TestManager::Status</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Status;]]></artwork>
						  <postamble>Test state at completion.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::TestManager::C_TEST_SUCCESS</preamble>
<artwork><![CDATA[const CICM::TestManager::Status
	C_TEST_SUCCESS = 0x00006062;]]></artwork>
							<postamble>The test completed successfully.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::TestManager::C_TEST_FAILURE</preamble>
<artwork><![CDATA[const CICM::TestManager::Status
	C_TEST_FAILURE = 0x00006064;]]></artwork>
							<postamble>The test failed.</postamble>
						</figure>
					 </section>
					 <section title="CICM::TestManager Methods">
						<figure>
							<preamble>Method CICM::TestManager::run_test()</preamble>
<artwork><![CDATA[CICM::Status run_test(
	in  CICM::Buffer test_parameters,
	out CICM::TestManager::Status status
);]]></artwork>
							<postamble>Run module built-in tests specifying module-specific test parameters.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This method can only initiate tests that a client program
								can explicitly request (e.g., this method does not apply to a
								series of tests automatically initiated during a module's
								start-up sequence). Running built-in tests on some modules may
								result in an alarm if an error is encountered during the test
								run.</t>
								<t>The format of the test parameters value is not defined by
								CICM. The Implementation Conformance Statement (see Section 4,
								Conformance and Extensions) must reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] test_parameters Module-specific test parameters.</t>
								<t>[out] status Status of test at completion.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_MODULE_IN_USE,
								  S_INVALID_DATA_BUFFER, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
								<t>CICM::TestManager::run_test_get_results for the version of
								this method that returns test results.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::TestManager::run_test_get_results()</preamble>
<artwork><![CDATA[CICM::Status run_test_get_results(
	in  CICM::Buffer test_parameters,
	out CICM::Buffer test_results
);]]></artwork>
						  <postamble>Run module built-in tests specifying module-specific test
							parameters and receiving module-specific results or data for later
							evaluation from the test run.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This method can only initiate tests that a client program
								can explicitly request (e.g., this method does not apply to a
								series of tests automatically initiated during a module's
								start-up sequence). Running built-in tests on some modules may
								result in an alarm if an error is encountered during the test
								run.</t>
								<t>The formats of the test parameters and test results values
								are not defined by CICM. The Implementation Conformance
								Statement (see Section 4, Conformance and Extensions) must
								reference a standard format or define a module
								developer-specific format implemented by the module for these
								datatypes.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] test_parameters Module-specific test parameters.</t>
								<t>[out] test_results Results of the test.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_MODULE_IN_USE,
								  S_INVALID_DATA_BUFFER, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
								<t>CICM::TestManager::run_test for the version of this Method
								that returns a simple test status value.</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Managing Module Events">
				<t>In certain cases it may be necessary for a
				module to asynchronously notify a client program of an event.
				Client programs can register to receive module notifications using
				CICM::ModuleEventManager. This manager enables a client program to
				register a listener (callback) method designed to handle a specific
				condition. The event method prototype provided by the client
				program is defined in CICM::ModuleEventListener.
				CICM::ModuleEventListener also defines the conditions that may
				result in a notification, including: hardware requires attention,
				alarm, key expired, and health test failure.</t>
				<t>In certain cases, a single event on a module may result in the
				generation of multiple notification messages. For example,
				CICM::ModuleEventListener::C_MODULE_ALARM may be followed by a
				CICM::ModuleEventListener::C_MODULE_NOT_READY_FOR_TRAFFIC.</t>

				<section title="Interface CICM::ModuleEventManager">
					<figure>
					  <preamble>Interface CICM::ModuleEventManager</preamble>
					  <artwork><![CDATA[interface ModuleEventManager {]]></artwork>
					  <postamble>CICM::ModuleEventManager supports registering and
						unregistering user-defined module event listeners
						(CICM::ModuleEventListener) for specific module events. It is
						accessed from CICM::CryptoModule via the
						CICM::CryptoModule::event_manager attribute.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 18. Interface Relationship Diagram for ModuleEventManagers</t>

					<section title="CICM::ModuleEventManager Methods">
						<figure>
						  <preamble>Method CICM::ModuleEventManager::register()</preamble>
<artwork><![CDATA[CICM::Status register(
	in  CICM::ModuleEventListener::ModuleEvent event,
	in  CICM::ModuleEventListener listener
);]]></artwork>
						  <postamble>Registers the listener for a specific module event.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The provided listener applies only to the client program
								from which the registration is initiated.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] event Event for which this listener is being registered.</t>
								<t>[in] listener Listener that will receive a notification about the
									  specified event.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES,
								  S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE,
								  S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED,
								  S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_EVENT_REGISTERED,
								  S_EVENT_NOT_SUPPORTED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::ModuleEventManager::unregister()</preamble>
<artwork><![CDATA[CICM::Status unregister(
	in  CICM::ModuleEventListener::ModuleEvent event
);]]></artwork>
						  <postamble>Unregisters the listener associated with the specified event.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The listener associated with the specified event is only
								unregistered from the client program from which this method is
								called.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] event Event that will no longer have a listener associated with it.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_MODULE_RESOURCES,
								  S_HOST_RESOURCES, S_INVALID_STATE, S_ALARM_STATE,
								  S_MODULE_NOT_AVAILABLE, S_TIMEOUT, S_NOT_AUTHENTICATED,
								  S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_EVENT_NOT_REGISTERED</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::ModuleEventListener">
					<figure>
					  <preamble>Interface CICM::ModuleEventListener</preamble>
					  <artwork><![CDATA[interface ModuleEventListener {]]></artwork>
					  <postamble>CICM::ModuleEventListener is unlike other CICM interfaces in
						that the interface is implemented by the developer of the client
						program to service a specific module event and is then registered
						via the CICM::ModuleEventManager.</postamble>
					</figure>

					<section title="CICM::ModuleEventListener Types and Constants">
						<figure>
						  <preamble>Type CICM::ModuleEventListener::ModuleEvent</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 ModuleEvent;]]></artwork>
						  <postamble>Events for which a ModuleEventListener can be notified.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_ACCESS_TOKEN_INSERTED</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ACCESS_TOKEN_INSERTED = 0x00002001;]]></artwork>
							<postamble>Access token has been inserted.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_ACCESS_TOKEN_REMOVED</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ACCESS_TOKEN_REMOVED = 0x00002002;]]></artwork>
							<postamble>Access token has been removed.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_ALARM</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ALARM = 0x00002004;]]></artwork>
							<postamble>Module has entered an alarm state.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_FAILURE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_FAILURE = 0x00002007;]]></artwork>
							<postamble>Non-critical module failure detected.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_INSUFFICIENT_ENTROPY</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_INSUFFICIENT_ENTROPY = 0x00002008;]]></artwork>
						    <postamble>Insufficient entropy available to a cryptographic operation
								that requires it.</postamble>
						 </figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_EXPIRED_HARD</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_EXPIRED_HARD =	0x0000200B;]]></artwork>
							<postamble>Specific key has expired; the module can optionally include
							  identifying information about the specific key that expired in
							  the event_data buffer that is provided with the event
							  itself.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_EXPIRED_SOFT</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_EXPIRED_SOFT = 0x0000200D;]]></artwork>
							<postamble>Specific key is within some system-defined delta of hard
							  expiration; the module can optionally include identifying
							  information about the specific key that is about to expire in the
							  event_data buffer that is provided with the event itself.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_COMPLETE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_COMPLETE = 0x0000200E;]]></artwork>
							<postamble>Key fill is complete.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_CONNECTED</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_CONNECTED = 0x00002010;]]></artwork>
							<postamble>Key fill device has been connected.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_FILL_INITIATED</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_FILL_INITIATED = 0x00002013;]]></artwork>
							<postamble>Key fill has been initiated.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_MEMORY</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_MEMORY = 0x00002015;]]></artwork>
							<postamble>Out of internal key memory condition.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_KEY_PROTO_MESSAGE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_KEY_PROTO_MESSAGE = 0x00002016;]]></artwork>
							<postamble>Key protocol message is available; see the Key Protocol
								Management documentation for additional information.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_LOG_FULL</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOG_FULL = 0x00002019;]]></artwork>
							<postamble>Module log is full.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_LOG_NEAR_FULL</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOG_NEAR_FULL = 0x0000201A;]]></artwork>
							<postamble>Module log is nearly full.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_LOGIN_FAILURE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_LOGIN_FAILURE = 0x0000201C;]]></artwork>
							<postamble>Attempted login failed.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_NOT_READY_FOR_TRAFFIC</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_NOT_READY_FOR_TRAFFIC = 0x0000201F;]]></artwork>
							<postamble>Module is not able to process traffic.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_POWER_MGMT_ENTER</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
C_MODULE_POWER_MGMT_ENTER = 0x00002020;]]></artwork>
							<postamble>Module has entered power management state.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_POWER_MGMT_EXIT</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_MGMT_EXIT = 0x00002023;]]></artwork>
							<postamble>Module has exited power management state.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_POWER_OFF</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_OFF = 0x00002025;]]></artwork>
							<postamble>Change in module power state to OFF detected.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_POWER_OFF_FAILURE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_OFF_FAILURE = 0x00002026;]]></artwork>
							<postamble>Disorderly change in module power state to OFF detected.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_POWER_ON</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_POWER_ON = 0x00002029;]]></artwork>
							<postamble>Change in module power state to ON detected.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_READY_FOR_TRAFFIC</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_READY_FOR_TRAFFIC = 0x0000202A;]]></artwork>
							<postamble>Module is ready to process traffic.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_REKEY_REQUEST</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_REKEY_REQUEST = 0x0000202C;]]></artwork>
							<postamble>Rekey of a specific key is required; the module can
							  optionally include identifying information about the specific key
							  to be rekeyed in the event_data buffer that is provided with the
							  event itself.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_TEST_FAILURE</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_TEST_FAILURE = 0x0000202F;]]></artwork>
							<postamble>Module internal test has failed; the module can optionally
							  include identifying information about the specific test that
							  failed in the event_data buffer that is provided with the event
							  itself.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ModuleEventListener::C_MODULE_ZEROIZED</preamble>
<artwork><![CDATA[const CICM::ModuleEventListener::ModuleEvent
	C_MODULE_ZEROIZED = 0x00002031;]]></artwork>
							<postamble>Module has been zeroized.</postamble>
						</figure>
					</section>
					<section title="CICM::ModuleEventListener Methods">
						<figure>
							<preamble>Method CICM::ModuleEventListener::event_occurred()</preamble>
<artwork><![CDATA[void event_occurred(
	in  CICM::ModuleEventListener::ModuleEvent event,
	in  CICM::Buffer event_data
);]]></artwork>
							<postamble>Method implemented by client program that is called by the
								host runtime system to notify that a specific module event has
								occurred.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>An opaque data field with additional information about the
								event in a module-specific format may optionally be provided
								with the event itself. This field may be of length zero.</t>
								<t>The format of the event data value is not defined in this
								specification. The Implementation Conformance Statement (see
								Section 4, Conformance and Extensions) must reference a
								standard format or define a module-specific format for this
								datatype.</t>
							</list>
						</t><t>Note:
							<list>
							    <t>Because this method is called by the runtime system and not
								a client program, it does not return a status value.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] event Event that occurred.</t>
								<t>[in] event_data Opaque data associated with the event (e.g., specific
									  test that failed, key that will expire).</t>
							</list>
						</t>
					</section>
				</section>
			</section>
		</section>
		<section title="Key Management">
			<section title="General Key Concepts">
				<section title="Interface CICM::Key">
					<figure>
					  <preamble>Interface CICM::Key</preamble>
					  <artwork><![CDATA[interface Key {]]></artwork>
					  <postamble>Interface from which symmetric and asymmetric key interfaces inherit.</postamble>
					</figure>

					<section title="Creating and Establishing Keys">
						<t>This specification provides
						facilities to convey key material into a cryptographic module via
						one of several methods, including importing key into the module
						through the API or a key fill interface, or generating or deriving
						key on the module.</t>
						<t>Key material may also be created through the use of a key
						establishment protocol between the module and a key infrastructure
						component or another module. Such a protocol is initiated between
						two or more parties to establish a secret key over a communications
						channel. The specification supports conveying generic protocol
						messages to and from a cryptographic module to effect the
						establishment of this secret key. See the CICM::KeyProtocolSender
						and CICM::KeyProtocolReceiver interfaces for additional
						information.</t>
						<t>Key metadata may be retrieved and set for individual keys.
						Metadata elements include the key identifier, alias, and
						classification. Keys imported via a fill device that are untagged
						may require certain metadata to be applied after the conclusion of
						the load, for example.</t>
						<t>{FIGURE REMOVED}</t>
						<t>Figure 19. Interface Inheritance Diagram
						  for AsymKey and SymKey, Depicting Key Creation Methods</t>
					</section>
					<section title="Exporting Keys">
						<t>Key material may also be exported out of a
						cryptographic module through the use of the key export
						functionality to enable transfer to another entity or for storage
						within the host system.</t>
					</section>
					<section title="Destroying Keys">
						<t>This specification provides the ability to
						permanently and irretrievably destroy key material. These
						capabilities apply to keys managed by the module, whether stored
						internal to the module or stored externally.</t>
						<t>{FIGURE REMOVED}</t>
						<t>Figure 20. Interface Relationship and
						  Inheritance Diagram Depicting Key Zeroization</t>
					</section>
					<section title="Locating Keys">
						<t>A key is typically designated by a global
						identifier defined by the external key management system from which
						the key originated. Alternatively, a key may be designated by a
						numeric value representing the physical storage location of the key
						within the module. Key location methods enable a key object
						representing the key specified by a supplied identifier to be
						retrieved by the caller.</t>
						<t>Note that the format of the key identifier is not defined by
						CICM. The Implementation Conformance Statement (see Section 4,
						Conformance and Extensions) must reference a standard format or
						define a module developer-specific format implemented by the module
						for this datatype.</t>
						<t>{FIGURE REMOVED}</t>
						<t>Figure 21. Interface Relationship Diagram
						  for Key Managers</t>
					</section>
					<section title="Protecting Keys">
						<t>These methods enable the encryption and
						decryption of key material to support transferring keys between
						modules or other entities (including storage of key material
						external to the module).</t>
						<t>{FIGURE REMOVED}</t>
						<t>Figure 22. Interface Inheritance Diagram
						  for AsymKey and SymKey, Depicting Key Protection Methods</t>
					</section>
					<section title="CICM::Key Types and Constants">
						<figure>
						  <preamble>Type CICM::Key::State</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 State;]]></artwork>
						  <postamble>Indicates whether or not the key is valid.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Key::C_KEY_INVALID</preamble>
<artwork><![CDATA[const CICM::Key::State
	C_KEY_INVALID = 0x00006010;]]></artwork>
							<postamble>Key is invalid.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Key::C_KEY_VALID_WRAPPED</preamble>
<artwork><![CDATA[const CICM::Key::State
	C_KEY_VALID_WRAPPED = 0x00006013;]]></artwork>
							<postamble>Key is valid and in wrapped form.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Key::C_KEY_VALID_UNWRAPPED</preamble>
<artwork><![CDATA[const CICM::Key::State
	C_KEY_VALID_UNWRAPPED = 0x00006015;]]></artwork>
							<postamble>Key is valid and in unwrapped form.</postamble>
						</figure>
						<figure>
						  <preamble>Type CICM::Key::UsageStatus</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 UsageStatus;]]></artwork>
						  <postamble>Indicates whether a key usage is allowed or forbidden.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Key::C_KEY_USAGE_ALLOWED</preamble>
<artwork><![CDATA[const CICM::Key::UsageStatus
	C_KEY_USAGE_ALLOWED = 0x00006016;]]></artwork>
							<postamble>Key is valid for this usage.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Key::C_KEY_USAGE_FORBIDDEN</preamble>
<artwork><![CDATA[const CICM::Key::UsageStatus
	C_KEY_USAGE_FORBIDDEN = 0x00006019;]]></artwork>
							<postamble>Key is not valid for this usage.</postamble>
						</figure>
					</section>
					<section title="CICM::Key Attributes">
						<figure>
						  <preamble>Attribute CICM::Key::identifier</preamble>
						  <artwork><![CDATA[attribute CICM::CharString identifier;]]></artwork>
						  <postamble>Unique global identifier for this key.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This identifier is the string representation of a key
								management authority-specific global key identifier. The
								identifier may be composed of multiple components; the
								representation of these components within the CICM identifier
								string is not defined in this specification. The Implementation
								Conformance Statement (see Section 4, Conformance and
								Extensions) must reference a standard format or define a module
								developer-specific format implemented by the module for this
								identifier.</t>
							</list>
						</t><t>Warning:
							<list>
								<t>This attribute SHALL be unimplemented if
								CICM::Key::location is implemented.</t>
							</list>
						</t>
						<figure>
						  <preamble>Attribute CICM::Key::location</preamble>
						  <artwork><![CDATA[attribute CICM::UInt32 location;]]></artwork>
						  <postamble>Module-specific physical storage location for this key.</postamble>
						</figure>
						<t>Warning:
							<list>
								<t>This attribute should only be used when a module utilizes a
								key storage model that requires keys of particular types to be
								stored in specific locations or in situations where keys are
								tied to module capabilities based upon physical location of the
								key. Because of the architectural knowledge of a module
								required, its use is highly discouraged because it virtually
								guarantees that code using it will be incompatible with other
								dissimilar modules. This attribute SHALL be unimplemented if
								CICM::Key::identifier is implemented.</t>
							</list>
						</t>
						<figure>
						  <preamble>Attribute CICM::Key::alias</preamble>
						  <artwork><![CDATA[attribute CICM::CharString alias;]]></artwork>
						  <postamble>Key alias, to assist in distinguishing one key from another.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::Key::classification</preamble>
						  <artwork><![CDATA[attribute CICM::Classification classification;]]></artwork>
						  <postamble>Key classification level.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::Key::caveat</preamble>
						  <artwork><![CDATA[attribute CICM::CharString caveat;]]></artwork>
						  <postamble>Key caveat, a protective marking or distribution/handling
							instruction that may augment classification level.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::Key::authority</preamble>
						  <artwork><![CDATA[attribute CICM::CharString authority;]]></artwork>
						  <postamble>Key management authority governing generation and use of
							key.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::Key::state</preamble>
						  <artwork><![CDATA[readonly attribute CICM::Key::State state;]]></artwork>
						  <postamble>State of key. A key may become invalid if zeroized, for
							example. Note that if an attempt is made to use an invalid key, the
							method accepting the key reference will return with an appropriate
							error status.</postamble>
						</figure>
					</section>
					<section title="CICM::Key Methods">
						<figure>
						  <preamble>Method CICM::Key::wrap()</preamble>
<artwork><![CDATA[CICM::Status wrap(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm
);]]></artwork>
						  <postamble>Instruct module to wrap key, destroying the original
							unwrapped key and replacing it with the newly wrapped key.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] kek Reference to key encryption key.</t>
								<t>[in] algorithm Key wrap algorithm/mode used to wrap key.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
								  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
								  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
								  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
								  S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_WRAPPED,
								  S_KEY_NOT_WRAPPABLE, S_KEY_WRAPPED_EXISTS, S_ALGO_INVALID,
								  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Key::unwrap()</preamble>
<artwork><![CDATA[CICM::Status unwrap(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm
);]]></artwork>
						  <postamble>Instruct module to unwrap key, destroying the original
							wrapped key and replacing it with the newly unwrapped key.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] kek Reference to key decryption key.</t>
							<t>[in] algorithm Key wrap algorithm/mode used to unwrap key.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
								  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
								  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
								  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
								  S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION,
								  S_KEY_UNWRAPPED_EXISTS, S_KEY_MALFORMED,
								  S_KEY_METADATA_MALFORMED, S_ALGO_INVALID,
								  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Key::export()</preamble>
<artwork><![CDATA[CICM::Status export(
	out CICM::Buffer key_material
);]]></artwork>
						  <postamble>Export key material from a cryptographic module as an opaque
							binary object.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The key must have been previously wrapped, if required. See CICM::Key::wrap.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] key_material Binary version of the key.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
								  S_KEY_EXPIRED, S_KEY_WRAPPED, S_KEY_NOT_WRAPPED,
								  S_KEY_NOT_EXPORTABLE, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Key::export_via_fill_interface()</preamble>
<artwork><![CDATA[CICM::Status export_via_fill_interface(
	in  CICM::LocalPort fill_port
);]]></artwork>
						  <postamble>Export key material from a cryptographic module via a port
							representing a key fill interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The key must have been previously wrapped, if required. See
								CICM::Key::wrap.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] fill_port The local port from which the key will emanate.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
								  S_KEY_EXPIRED, S_KEY_WRAPPED, S_KEY_NOT_WRAPPED,
								  S_KEY_NOT_EXPORTABLE, S_KEY_FILL_DEVICE_NOT_CONNECTED,
								  S_KEY_FILL_NOT_INITIATED, S_LOCAL_PORT_INVALID,
								  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Key::zeroize()</preamble>
						  <artwork><![CDATA[CICM::Status zeroize();]]></artwork>
						  <postamble>Zeroize the selected key.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Future cryptographic operations depending upon this key
								SHALL fail with a CICM::S_KEY_INVALID status.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::KeyDatabase">
					<figure>
					  <preamble>Interface CICM::KeyDatabase</preamble>
					  <artwork><![CDATA[interface KeyDatabase {]]></artwork>
					  <postamble>CICM::KeyDatabase supports zeroizing keys and reencrypting a
						module key database. It is accessed from CICM::CryptoModule via the
						CICM::CryptoModule::key_database attribute.</postamble>
					</figure>

					<section title="CICM::KeyDatabase Methods">
						<figure>
						  <preamble>Method CICM::KeyDatabase::zeroize()</preamble>
						  <artwork><![CDATA[CICM::Status zeroize();]]></artwork>
						<postamble>Zeroize all key material on the module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This method renders all instantiated key objects invalid.
								Future cryptographic operations depending upon zeroized keys
								may fail with a CICM::S_KEY_INVALID status.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::KeyDatabase::reencrypt()</preamble>
						  <artwork><![CDATA[CICM::Status reencrypt();]]></artwork>
						  <postamble>Re-encrypt the module key database.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This method uses a module-managed key to protect the key
								database and only applies to keys managed by the module,
								whether stored internal to the module or stored externally.
								Keys stored external to the module and not directly managed by
								the module must utilize the key wrap methods to protect key
								material.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Asymmetric Keys">
				<section title="Interface CICM::AsymKeyManager">
					<figure>
					  <preamble>Interface CICM::AsymKeyManager</preamble>
					  <artwork><![CDATA[interface AsymKeyManager {]]></artwork>
					  <postamble>CICM::AsymKeyManager supports retrieving, importing, and
						generating asymmetric keysets. It is accessed from
						CICM::CryptoModule via the CICM::CryptoModule::asym_key_manager
						attribute. CICM::AsymKeyManager constructs the
						CICM::AsymKeyIterator and CICM::AsymKey interfaces.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 23. Interface Relationship Diagram for AsymKeyManager</t>

					<section title="CICM::AsymKeyManager Attributes">
						<figure>
						  <preamble>AttributeCICM::AsymKeyManager::asymkey_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymKeyIterator asymkey_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable a reference to each asymmetric
							keyset in the module key database to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							  <t>The returned iterator is set to the beginning of the iterated
							  sequence.</t>
							</list>
						</t>
					</section>
					<section title="CICM::AsymKeyManager Methods">
						<figure>
						  <preamble>Method CICM::AsymKeyManager::get_key_by_id()</preamble>
<artwork><![CDATA[CICM::Status get_key_by_id(
	in  CICM::KeyId key_id,
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Retrieves a reference to the asymmetric keyset corresponding
							to the specified infrastructure-specific identifier.</postamble>
						</figure>
						<t>Warning:
							<list>
								<t>This method SHALL be unimplemented if
								CICM::AsymKeyManager::get_key_by_phys_location is
								implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] key_id Unique identifier of the keyset to be retrieved.</t>
								<t>[out] key_ref Reference to keyset corresponding to key
									  identifier.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
								  S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INVALID_ID,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::get_key_by_phys_location()</preamble>
<artwork><![CDATA[CICM::Status get_key_by_phys_location(
	in  CICM::UInt32 phys_location,
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Retrieves a reference to the asymmetric keyset corresponding
							to the specified module physical storage location.</postamble>
						</figure>
						<t>Warning:
							<list>
								<t>This call should only be used when a module utilizes a key
								storage model that requires keys of particular types to be
								stored in specific locations or in situations where keys are
								tied to module capabilities based upon physical location of the
								key. Because of the architectural knowledge of a module
								required, its use is highly discouraged because it virtually
								guarantees that code using it will be incompatible with other
								dissimilar modules.</t>
								<t>This method SHALL be unimplemented if
								CICM::AsymKeyManager::get_key_by_id is implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] phys_location Physical location of the key to be retrieved.</t>
								<t>[out] key_ref Reference to key corresponding to physical
									  location.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
								  S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_PHYSICAL_LOC,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::get_key_last_filled()</preamble>
<artwork><![CDATA[CICM::Status get_key_last_filled(
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Retrieves a reference to the asymmetric keyset corresponding
							to the keyset most recently filled via a key fill device.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>A client program may need to initiate this action if key
								material imported into a module does not contain the
								corresponding key metadata. This method allows a reference to
								the last keyset filled over the key fill interface to be
								referenced to enable metadata to be applied directly to the
								resulting keyset. The error status CICM::S_NOT_AVAILABLE is
								returned if no key is filled.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] key_ref Object representing last filled key.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
								<t>SymKeyManager::get_key_last_filled for the symmetric
								version of this method.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::import_key()</preamble>
<artwork><![CDATA[CICM::Status import_key(
	in  CICM::Buffer key_material,
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Import asymmetric keysets into a cryptographic module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Keysets may be imported into a module as wrapped entities,
								necessitating the use of CICM::Key::unwrap to decrypt the
								keyset prior to use.</t>
								<t>Keyset attributes may optionally be set to create or
								supplement key metadata.</t>
								<t>The format of the key material value is not defined by CICM.
								The Implementation Conformance Statement (see Section 4,
								Conformance and Extensions) must reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Warning:
							<list>
								<t>This method SHALL be unimplemented if
								CICM::AsymKeyManager::import_key_into_phys_location is
								implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] key_material Key material to be imported into the module.</t>
								<t>[out] key_ref Reference to newly imported key.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED,
								  S_KEY_METADATA_MALFORMED, S_KEY_TRUST_ANCHOR,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<t>See also:
							<list>
								<t>CICM::SymKeyManager::import_key for the symmetric version
								of this method.</t>
								<t>CICM::AsymKeyManager::import_key_via_fill for the key fill
								version of this method.</t>
								<t>CICM::AsymKeyManager::import_key_into_phys_location for the
								version of this method that imports key into a specific module
								key location.</t>
								<t>CICM::AsymKeyManager::import_key_via_fill_into_phys_location
								for the version of this method that fills key into a specific
								module key location.</t>
							</list>
						</t>
						<figure>
							<preamble>Method CICM::AsymKeyManager::import_key_into_phys_location()</preamble>
<artwork><![CDATA[CICM::Status import_key_into_phys_location(
	in  CICM::Buffer key_material,
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);]]></artwork>
							<postamble>Import key material into a specific physical key location in
							a cryptographic module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Keysets may be imported into a module as wrapped entities,
								necessitating the use of CICM::Key::unwrap to decrypt the
								keyset prior to use.</t>
								<t>Keyset object attributes may optionally be set to create or
								supplement keyset metadata.</t>
								<t>The format of the key material value is not defined by CICM.
								The Implementation Conformance Statement (see Section 4,
								Conformance and Extensions) must reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Warning:
							<list>
								<t>This call should only be used when a module utilizes a key
								storage model that requires keys of particular types to be
								stored in specific locations or in situations where keys are
								tied to module capabilities based upon physical location of the
								key. Because of the architectural knowledge of a module
								required, its use is highly discouraged because it virtually
								guarantees that code using it will be incompatible with other
								dissimilar modules.</t>
								<t>This method SHALL be unimplemented if
								CICM::AsymKeyManager::import_key is implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] key_material Key material to be imported into the module.</t>
								<t>[in] phys_location Physical location into which to import keyset.</t>
								<t>[out] key_ref Reference to newly imported keyset.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC,
								  S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED,
								  S_KEY_TRUST_ANCHOR, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::import_key_via_fill()</preamble>
<artwork><![CDATA[CICM::Status import_key_via_fill(
	in  CICM::LocalPort fill_port,
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Initiate the import of key material via a key fill
							interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>In some cases, a key fill device can initiate and effect
								the filling of key into a module completely independent of the
								host and thus any API control. In such cases, the host will
								utilize the CICM::AsymKeyManager::get_key_by_id,
								CICM::AsymKeyManager::get_key_by_phys_location, or
								CICM::AsymKeyManager::get_key_last_filled methods after the key
								fill has completed to enable future reference to the keyset.</t>
								<t>Keysets may be imported into a module as wrapped entities,
								necessitating the use of CICM::Key::unwrap to decrypt the key
								prior to use.</t>
								<t>Keyset attributes may optionally be set to create or
								supplement keyset metadata.</t>
							</list>
						</t><t>Warning:
							<list>
								<t>This method SHALL be unimplemented if
								CICM::AsymKeyManager::import_key_via_fill_into_phys_location is
								implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] fill_port Fill port on which to initiate import.</t>
								<t>[out] key_ref Reference to newly imported keyset.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED,
							  S_KEY_METADATA_MALFORMED, S_KEY_FILL_DEVICE_NOT_CONNECTED,
							  S_KEY_FILL_NOT_INITIATED, S_KEY_TRUST_ANCHOR,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::import_key_via_fill_into_phys_location()</preamble>
<artwork><![CDATA[CICM::Status import_key_via_fill_into_phys_location(
	in  CICM::LocalPort fill_port,
	in  CICM::UInt32 phys_location,
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Initiate the import of key material into a specific key
							physical location via a key fill interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>In some cases, a key fill device can initiate and effect
								the filling of key into a module completely independent of the
								host and thus any API control. In such cases, the host will
								utilize the CICM::AsymKeyManager::get_key_by_id,
								CICM::AsymKeyManager::get_key_by_phys_location, or
								CICM::AsymKeyManager::get_key_last_filled methods after the key
								fill has completed to enable future reference to the keyset.</t>
								<t>Keysets may be imported into a module as wrapped entities,
								necessitating the use of CICM::Key::unwrap to decrypt the
								keyset prior to use.</t>
								<t>Keyset attributes may optionally be set to create or
								supplement keyset metadata.</t>
							</list>
						</t><t>Warning:
							<list>
							<t>This call should only be used when a module utilizes a key
							storage model that requires keys of particular types to be
							stored in specific locations or in situations where keys are
							tied to module capabilities based upon physical location of the
							key. Because of the architectural knowledge of a module
							required, its use is highly discouraged because it virtually
							guarantees that code using it will be incompatible with other
							dissimilar modules.</t>
							<t>This method SHALL be unimplemented if
							CICM::AsymKeyManager::import_key_via_fill is
							implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] fill_port Port of the key fill interface.</t>
							<t>[in] phys_location Physical location into which to import keyset.</t>
							<t>[out] key_ref Reference to newly imported keyset.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC,
							  S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED,
							  S_KEY_FILL_DEVICE_NOT_CONNECTED, S_KEY_FILL_NOT_INITIATED,
							  S_KEY_TRUST_ANCHOR, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::generate_key_pair()</preamble>
<artwork><![CDATA[CICM::Status generate_key_pair(
	in  CICM::AsymEncrAlgorithmId algorithm,
	out CICM::AsymKey key_ref
);]]></artwork>
						<postamble>Generate an asymmetric key pair compatible with the
						characteristics of the specified algorithm.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] algorithm Desired algorithm of resulting asymmetric key pair.</t>
							<t>[out] key_ref Reference to newly generated key pair.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AsymKey">
					<figure>
					  <preamble>Interface CICM::AsymKey</preamble>
					  <artwork><![CDATA[interface AsymKey : CICM::Key {]]></artwork>
						<postamble>CICM::AsymKey serves as an abstraction for an asymmetric
						keyset, which may comprise an asymmetric key pair, the public and
						private key components of a keypair, the digital certificate
						corresponding to the keyset public key, one or more verification
						certificates in the certificate chain of trust, and related public
						domain parameters; and supports operations on asymmetric keys,
						including wrapping and unwrapping.</postamble>
					</figure>

					<section title="CICM::AsymKey Inheritance">
						<t>CICM::AsymKey inherits from: CICM::Key.</t>
					</section>
					<section title="CICM::AsymKey Types and Constants">
						<figure>
						  <preamble>Type CICM::AsymKey::Usage</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Usage;]]></artwork>
							<postamble>Asymmetric key usage types.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_ASYM_DATA_ENCIPHERMENT</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_ASYM_DATA_ENCIPHERMENT = 0x00006001;]]></artwork>
							<postamble>Key intended for enciphering data.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_ASYM_KEY_ENCIPHERMENT</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_ASYM_KEY_ENCIPHERMENT = 0x00006002;]]></artwork>
							<postamble>Key intended for enciphering other keys.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_CERT_SIGN</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_CERT_SIGN = 0x00006004;]]></artwork>
							<postamble>Key intended for signing/verifying digital certificates.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_CRL_SIGN</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_CRL_SIGN = 0x00006007;]]></artwork>
						  <postamble>Key intended for signing/verifying certificate revocation lists.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_DIGITAL_SIGNATURE</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_DIGITAL_SIGNATURE = 0x00006008;]]></artwork>
							<postamble>Key intended for producing digital signatures.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_INFRA_KEY_AGREEMENT</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_INFRA_KEY_AGREEMENT = 0x0000600B;]]></artwork>
							<postamble>Key intended for participating in an infrastructure key
							  agreement protocol.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_P2P_KEY_AGREEMENT</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_P2P_KEY_AGREEMENT = 0x0000600D;]]></artwork>
						  <postamble>Key intended for participating in a peer-to-peer key
						  agreement protocol.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_SEED</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_SEED = 0x0000600E;]]></artwork>
							<postamble>Key intended to serve as seed material.</postamble>
						</figure>
					</section>
					<section title="CICM::AsymKey Methods">
						<figure>
						  <preamble>Method CICM::AsymKey::wrap_and_copy()</preamble>
<artwork><![CDATA[CICM::Status wrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::AsymKey wrapped_key
);]]></artwork>
						<postamble>Instruct module to wrap keyset, resulting in two keysets, the
						original unwrapped keyset and the newly wrapped keyset.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] kek Reference to key encryption key.</t>
							<t>[in] algorithm Key wrap algorithm/mode used to wrap keyset.</t>
							<t>[out] wrapped_key Reference to resulting wrapped keyset.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_WRAPPED,
							  S_KEY_NOT_WRAPPABLE, S_KEY_WRAPPED_EXISTS, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::wrap_and_copy for the symmetric version of
							this method.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKey::unwrap_and_copy()</preamble>
<artwork><![CDATA[CICM::Status unwrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::AsymKey unwrapped_key
);]]></artwork>
						<postamble>Instruct module to unwrap key, resulting in two keys, the
						original wrapped key and the newly unwrapped key.</postamble>
						</figure>
						<t>Parameters:
							<list>
							  <t>[in] kek Reference to key decryption key.</t>
							  <t>[in] algorithm Key wrap algorithm/mode used to unwrap keyset.</t>
							  <t>[out] unwrapped_key Reference to resulting unwrapped keyset.</t>
							</list>
						</t><t>Returns:
							<list>
							  <t>
								S_OK, S_GENERAL_ERROR,
								S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
								S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
								S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
								S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
								S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION,
								S_KEY_UNWRAPPED_EXISTS, S_KEY_MALFORMED,
								S_KEY_METADATA_MALFORMED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
								S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT   </t>
							</list>
						</t><t>See also:
							<list>
							  <t>CICM::SymKey::unwrap_and_copy for the symmetric version of
							  this method.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKey::validate_key_usage()</preamble>
<artwork><![CDATA[CICM::Status validate_key_usage(
	in  CICM::AsymKey::Usage usage_type,
	out CICM::Key::UsageStatus valid
);]]></artwork>
						<postamble>Validate that this keyset may be used for a specific purpose.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, a given keyset can be used for multiple
							purposes.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] usage_type Specific purpose to validate.</t>
							<t>[out] valid Indiciates whether or not the key may be used for the
								  specified purpose.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::validate_key_usage for the symmetric version
							of this method.</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AsymKeyIterator">
					<figure>
					  <preamble>Interface CICM::AsymKeyIterator</preamble>
					  <artwork><![CDATA[interface AsymKeyIterator : CICM::Iterator {]]></artwork>
					<postamble>CICM::AsymKeyIterator supports retrieving a reference to each
					usable asymmetric key on a module. CICM::AsymKeyIterator constructs
					the CICM::AsymKey interface.</postamble>
					</figure>
					<section title="CICM::AsymKeyIterator Inheritance">
						<t>CICM::AsymKeyIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::AsymKeyIterator Methods">
						<figure>
						  <preamble>Method CICM::AsymKeyIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::AsymKey asym_key_ref
);]]></artwork>
							<postamble>Returns a reference to the next asymmetric key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Use CICM::Iterator::has_next to determine if additional
							elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] asym_key_ref Reference to next asymmetric key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Symmetric Keys">
				<section title="Interface CICM::SymKeyManager">
					<figure>
					  <preamble>Interface CICM::SymKeyManager</preamble>
					  <artwork><![CDATA[interface SymKeyManager {]]></artwork>
						<postamble>CICM::SymKeyManager supports retrieving, importing,
						generating and deriving symmetric keys; and operating key
						management protocols. It is accessed from CICM::CryptoModule via
						the CICM::CryptoModule::sym_key_manager attribute.
						CICM::SymKeyManager constructs the CICM::KeyProtocolSender,
						CICM::KeyProtocolReceiver, CICM::SymKeyIterator, and CICM::SymKey
						interfaces.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 24. Interface Relationship Diagram for SymKeyManager</t>

					<section title="CICM::SymKeyManager Attributes">
						<figure>
						  <preamble>AttributeCICM::SymKeyManager::symkey_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymKeyIterator symkey_iterator;]]></artwork>
						<postamble>Returns an iterator to enable a reference to each symmetric
						key in the module key database to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The returned iterator is set to the beginning of the
							iterated sequence.</t>
							</list>
						</t>
						<figure>
						  <preamble>AttributeCICM::SymKeyManager::key_protocol_sender</preamble>
						  <artwork><![CDATA[readonly attribute CICM::KeyProtocolSender key_protocol_sender;]]></artwork>
						<postamble>CICM::KeyProtocolSender supports sending key management
						protocol-related messages into a module.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::SymKeyManager::key_protocol_receiver</preamble>
						  <artwork><![CDATA[readonly attribute CICM::KeyProtocolReceiver key_protocol_receiver;]]></artwork>
						<postamble>CICM::KeyProtocolReceiver supports receiving key management
						protocol-related messages from a module. CICM::KeyProtocolReceiver
						constructs the CICM::SymKey interface.</postamble>
						</figure>
					</section>
					<section title="CICM::SymKeyManager Methods">
						<figure>
						  <preamble>Method CICM::SymKeyManager::get_key_by_id()</preamble>
<artwork><![CDATA[CICM::Status get_key_by_id(
	in  CICM::KeyId key_id,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Retrieves a reference to the symmetric key corresponding to
						the specified infrastructure-specific identifier.</postamble>
						</figure>
						<t>Warning:
							<list>
							<t>This method SHALL be unimplemented if
							CICM::SymKeyManager::get_key_by_phys_location is
							implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] key_id Unique identifier of the key to be retrieved.</t>
							<t>[out] key_ref Reference to key corresponding to key
								  identifier.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INVALID_ID,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::get_key_by_phys_location()</preamble>
<artwork><![CDATA[CICM::Status get_key_by_phys_location(
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Retrieves a reference to the symmetric key corresponding to
						the specified module physical storage location.</postamble>
						</figure>
						<t>Warning:
							<list>
							<t>This call should only be used when a module utilizes a key
							storage model that requires keys of particular types to be
							stored in specific locations or in situations where keys are
							tied to module capabilities based upon physical location of the
							key. Because of the architectural knowledge of a module
							required, its use is highly discouraged because it virtually
							guarantees that code using it will be incompatible with other
							dissimilar modules.</t>
							<t>This method SHALL be unimplemented if
							CICM::SymKeyManager::get_key_by_id is implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] phys_location Physical location of the key to be retrieved.</t>
							<t>[out] key_ref Reference to key corresponding to physical
								  location.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_PHYSICAL_LOC,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::get_key_last_filled()</preamble>
<artwork><![CDATA[CICM::Status get_key_last_filled(
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Retrieves a reference to the symmetric key corresponding to
						the key most recently filled via a key fill device.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>A client program may need to initiate this action if key
							material imported into a module does not contain the
							corresponding key metadata. This method allows a reference to
							the last key filled over the key fill interface to be
							referenced to enable metadata to be applied directly to the
							resulting key. The error status CICM::S_NOT_AVAILABLE is
							returned if no key is filled.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] key_ref Reference to last filled key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::import_key()</preamble>
<artwork><![CDATA[CICM::Status import_key(
	in  CICM::Buffer key_material,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Import key material or seed key for pseudorandom data
						generation into a cryptographic module.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Keys may be imported into a module as wrapped entities,
							necessitating the use of CICM::Key::unwrap to decrypt the key
							prior to use.</t>
							<t>Key attributes may optionally be set to create or supplement
							key metadata.</t>
							<t>The format of the key material value is not defined by CICM.
							The Implementation Conformance Statement (see Section 4,
							Conformance and Extensions) must reference a standard format or
							define a module developer-specific format implemented by the
							module for this datatype.</t>
							</list>
						</t><t>Warning:
							<list>
							<t>This method SHALL be unimplemented if
							CICM::SymKeyManager::import_key_into_phys_location is
							implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] key_material Key material to be imported into the module.</t>
							<t>[out] key_ref Reference to newly imported key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED,
							  S_KEY_METADATA_MALFORMED, S_KEY_TRUST_ANCHOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::import_key_into_phys_location()</preamble>
<artwork><![CDATA[CICM::Status import_key_into_phys_location(
	in  CICM::Buffer key_material,
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Import key material or seed key for pseudorandom data
						generation into a specific physical key location in a cryptographic
						module.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Keys may be imported into a module as wrapped entities,
							necessitating the use of CICM::Key::unwrap to decrypt the key
							prior to use.</t>
							<t>Key attributes may optionally be set to create or supplement
							key metadata.</t>
							<t>The format of the key material value is not defined by CICM.
							The Implementation Conformance Statement (see Section 4,
							Conformance and Extensions) must reference a standard format or
							define a module developer-specific format implemented by the
							module for this datatype.</t>
							</list>
						</t><t>Warning:
							<list>
							<t>This call should only be used when a module utilizes a key
							storage model that requires keys of particular types to be
							stored in specific locations or in situations where keys are
							tied to module capabilities based upon physical location of the
							key. Because of the architectural knowledge of a module
							required, its use is highly discouraged because it virtually
							guarantees that code using it will be incompatible with other
							dissimilar modules.</t>
							<t>This method SHALL be unimplemented if
							CICM::SymKeyManager::import_key is implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] key_material Key material to be imported into the module.</t>
							<t>[in] phys_location Physical location into which to import key.</t>
							<t>[out] key_ref Reference to newly imported key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC,
							  S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED,
							  S_KEY_TRUST_ANCHOR, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::import_key_via_fill()</preamble>
<artwork><![CDATA[CICM::Status import_key_via_fill(
	in  CICM::LocalPort fill_port,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Initiate the import of key material via a key fill
						interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, a key fill device can initiate and effect
							the filling of key into a module completely independent of the
							host and thus any API control. In such cases, the host will
							utilize the CICM::SymKeyManager::get_key_by_id,
							CICM::SymKeyManager::get_key_by_phys_location, or
							CICM::SymKeyManager::get_key_last_filled methods after the key
							fill has completed to enable future reference to the key.</t>
							<t>Keys may be imported into a module as wrapped entities,
							necessitating the use of CICM::Key::unwrap to decrypt the key
							prior to use.</t>
							<t>Key attributes may optionally be set to create or supplement
							key metadata.</t>
							</list>
						</t><t>Warning:
							<list>
							<t>This method SHALL be unimplemented if
							CICM::SymKeyManager::import_key_via_fill_into_phys_location is
							implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] fill_port Port of the key fill interface.</t>
							<t>[out] key_ref Reference to newly imported key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED,
							  S_KEY_METADATA_MALFORMED, S_KEY_FILL_DEVICE_NOT_CONNECTED,
							  S_KEY_FILL_NOT_INITIATED, S_KEY_TRUST_ANCHOR,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::import_key_via_fill_into_phys_location()</preamble>
<artwork><![CDATA[CICM::Status import_key_via_fill_into_phys_location(
	in  CICM::LocalPort fill_port,
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Initiate the import of key material into a specific key
						physical location via a key fill interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, a key fill device can initiate and effect
							the filling of key into a module completely independent of the
							host and thus any API control. In such cases, the host will
							utilize the CICM::SymKeyManager::get_key_by_id,
							CICM::SymKeyManager::get_key_by_phys_location, or
							CICM::SymKeyManager::get_key_last_filled methods after the key
							fill has completed to enable future reference to the key.</t>
							<t>Keys may be imported into a module as wrapped entities,
							necessitating the use of CICM::Key::unwrap to decrypt the key
							prior to use.</t>
							<t>Key attributes may optionally be set to create or supplement
							key metadata.</t>
							</list>
						</t><t>Warning:
							<list>
							<t>This call should only be used when a module utilizes a key
							storage model that requires keys of particular types to be
							stored in specific locations or in situations where keys are
							tied to module capabilities based upon physical location of the
							key. Because of the architectural knowledge of a module
							required, its use is highly discouraged because it virtually
							guarantees that code using it will be incompatible with other
							dissimilar modules.</t>
							<t>This method SHALL be unimplemented if
							CICM::SymKeyManager::import_key_via_fill is
							implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] fill_port Port of the key fill interface.</t>
							<t>[in] phys_location Physical location into which to import key.</t>
							<t>[out] key_ref Reference to newly imported key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC,
							  S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED,
							  S_KEY_FILL_DEVICE_NOT_CONNECTED, S_KEY_FILL_NOT_INITIATED,
							  S_KEY_TRUST_ANCHOR, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::generate_key()</preamble>
<artwork><![CDATA[CICM::Status generate_key(
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::SymKey key_ref
)]]></artwork>
						<postamble>Generate a symmetric key compatible with the characteristics
						of the specified algorithm.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] algorithm Desired algorithm of resulting symmetric key.</t>
							<t>[out] key_ref Reference to newly generated key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::derive_key()</preamble>
<artwork><![CDATA[CICM::Status derive_key(
	in  CICM::CharString password,
	in  CICM::Buffer salt,
	in  CICM::UInt32 iteration_count,
	in  CICM::HashAlgorithmId hash_algorithm,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Derives a symmetric key from a password and other parameters
						using a password-based key derivation function (PBKDF).</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] password Password for conversion into a cryptographic
								  key.</t>
							<t>[in] salt Binary salt value.</t>
							<t>[in] iteration_count Positive integer representing number of iterations to
								  apply to hashing algorithm.</t>
							<t>[in] hash_algorithm Hash function applied to derive key.</t>
							<t>[in] algorithm Desired algorithm/mode of resulting symmetric key.</t>
							<t>[out] key_ref Reference to newly derived key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_PASSWORD_INVALID,
							  S_PASSWORD_INVALID_CHAR, S_PASSWORD_INVALID_LEN,
							  S_SALT_INVALID, S_ITERATION_COUNT_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::derive_deterministic_key()</preamble>
<artwork><![CDATA[CICM::Status derive_deterministic_key(
	in  CICM::SymKey key_prod_key,
	in  CICM::CharString shared_secret,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Derives a symmetric key using a distributed deterministic key
						generation scheme.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This may be used by peers in an ad-hoc group who initially
							only share a key production key (KPK) but are subsequently able
							to share an additional secret.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] key_prod_key Key production key.</t>
							<t>[in] shared_secret Text-based secret sharable amongst peers in a group.</t>
							<t>[in] algorithm Desired algorithm/mode of resulting symmetric key.</t>
							<t>[out] key_ref Reference to newly derived key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_PASSWORD_INVALID,
							  S_PASSWORD_INVALID_CHAR, S_PASSWORD_INVALID_LEN</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::SymKey">
					<figure>
					  <preamble>Interface CICM::SymKey</preamble>
					  <artwork><![CDATA[interface SymKey : CICM::Key {]]></artwork>
					<postamble>CICM::SymKey serves as a reference to a symmetric key
					contained within a module and supports operations on symmetric
					keys, including key conversion, updating, wrapping, and unwrapping.</postamble>
					</figure>

					<section title="CICM::SymKey Inheritance">
						<t>CICM::SymKey inherits from: CICM::Key.</t>
					</section>
					<section title="CICM::SymKey Types and Constants">
						<figure>
						  <preamble>Type CICM::SymKey::Usage</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Usage;]]></artwork>
						<postamble>Symmetric key usage types.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::SymKey::C_USAGE_GENERATE_KEYSTREAM</preamble>
<artwork><![CDATA[const CICM::SymKey::Usage
	C_USAGE_GENERATE_KEYSTREAM = 0x0000601A;]]></artwork>
							<postamble>Key intended for generating keystream.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::SymKey::C_USAGE_KEY_PRODUCTION_KEY</preamble>
<artwork><![CDATA[const CICM::SymKey::Usage
	C_USAGE_KEY_PRODUCTION_KEY = 0x0000601C;]]></artwork>
							<postamble>Key intended for producing other keys.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::SymKey::C_USAGE_MESSAGE_AUTHENTICATION_CODE</preamble>
<artwork><![CDATA[const CICM::SymKey::Usage
	C_USAGE_MESSAGE_AUTHENTICATION_CODE = 0x0000601F;]]></artwork>
						  <postamble>Key intended for computing a Message Authentication Code.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::SymKey::C_USAGE_SYM_DATA_ENCIPHERMENT</preamble>
<artwork><![CDATA[const CICM::SymKey::Usage
	C_USAGE_SYM_DATA_ENCIPHERMENT = 0x00006020;]]></artwork>
							<postamble>Key intended for enciphering data.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::SymKey::C_USAGE_SYM_KEY_ENCIPHERMENT</preamble>
<artwork><![CDATA[const CICM::SymKey::Usage
	C_USAGE_SYM_KEY_ENCIPHERMENT = 0x00006023;]]></artwork>
							<postamble>Key intended for enciphering other keys.</postamble>
						</figure>
					</section>
					<section title="CICM::SymKey Attributes">
						<figure>
						  <preamble>Attribute CICM::SymKey::update_count</preamble>
						  <artwork><![CDATA[readonly attribute CICM::UInt32 update_count;]]></artwork>
							<postamble>Key update count.</postamble>
						</figure>
					</section>
					<section title="CICM::SymKey Methods">
						<figure>
						  <preamble>Method CICM::SymKey::update()</preamble>
						  <artwork><![CDATA[CICM::Status update();]]></artwork>
						<postamble>Cryptographically update the key using the key's native
						algorithm. The update modifies the existing key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The new update count resulting from a call to this method
							is available as an attribute of the key object.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_WRAPPED,
							  S_KEY_UPDATE_MAX, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::update_with_algo for the version of this
							method that accepts an algorithm parameter.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKey::update_with_algo()</preamble>
<artwork><![CDATA[CICM::Status update_with_algo(
	in  CICM::SymEncrAlgorithmId algorithm
);]]></artwork>
						<postamble>Cryptographically update the key using the specified key
						update algorithm. The update modifies the existing key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The new update count resulting from a call to this method
							is available as an attribute of the key object.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] algorithm Cryptographic algorithm/mode to use to effect the key
								  update.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_WRAPPED,
							  S_KEY_UPDATE_MAX, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::update for the version of this method that
							does not require an algorithm to be specified.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKey::wrap_and_copy()</preamble>
<artwork><![CDATA[CICM::Status wrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::SymKey wrapped_key
);]]></artwork>
						<postamble>Instruct module to wrap key, resulting in two keys, the
						original unwrapped key and the newly wrapped key.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] kek Reference to key encryption key.</t>
							<t>[in] algorithm Key wrap algorithm/mode used to wrap key.</t>
							<t>[out] wrapped_key Reference to resulting wrapped key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_WRAPPED,
							  S_KEY_NOT_WRAPPABLE, S_KEY_WRAPPED_EXISTS, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::AsymKey::wrap_and_copy for the asymmetric version of
							this method.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKey::unwrap_and_copy()</preamble>
<artwork><![CDATA[CICM::Status unwrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::SymKey unwrapped_key
);]]></artwork>
						<postamble>Instruct module to unwrap key, resulting in two keys, the
						original wrapped key and the newly unwrapped key.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] kek Reference to key decryption key.</t>
							<t>[in] algorithm Key wrap algorithm/mode used to unwrap key.</t>
							<t>[out] unwrapped_key Reference to resulting unwrapped key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION,
							  S_KEY_UNWRAPPED_EXISTS, S_KEY_MALFORMED,
							  S_KEY_METADATA_MALFORMED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::AsymKey::unwrap_and_copy for the asymmetric version
							of this method.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKey::validate_key_usage()</preamble>
<artwork><![CDATA[CICM::Status validate_key_usage(
	in  CICM::SymKey::Usage usage_type,
	out CICM::Key::UsageStatus valid
);]]></artwork>
						<postamble>Validate that this key may be used for a specific
						purpose.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, a given key can be used for multiple
							purposes.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] usage_type Specific purpose to validate.</t>
							<t>[out] valid Indiciates if the key may be used for the specified
								  purpose.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::AsymKey::validate_key_usage for the asymmetric
							version of this method.</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::SymKeyIterator">
					<figure>
					  <preamble>Interface CICM::SymKeyIterator</preamble>
					  <artwork><![CDATA[interface SymKeyIterator : CICM::Iterator {]]></artwork>
					<postamble>CICM::SymKeyIterator supports retrieving a reference to each
					usable symmetric key on a module. CICM::SymKeyIterator constructs
					the CICM::SymKey interface.</postamble>
					</figure>

					<section title="CICM::SymKeyIterator Inheritance">
						<t>CICM::SymKeyIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::SymKeyIterator Methods">
						<figure>
						  <preamble>Method CICM::SymKeyIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::SymKey sym_key_ref
);]]></artwork>
						<postamble>Returns a reference to the next symmetric key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Use CICM::Iterator::has_next to determine if additional
							elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] sym_key_ref Reference to next symmetric key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Key Protocol">
				<t>The key management capabilities described
				here support certain key management protocols, including key
				establishment/distribution protocols such as Diffie-Hellman, EC-DH,
				and EC-MQV; trust anchor management protocols; the importation of
				key white lists (acceptable keys) or black lists (revoked keys or
				keys restricted administratively); and the execution of remote key
				functions. These key protocol IDL interfaces initiate a key
				agreement protocol between two or more entities to establish a
				secret key over an insecure communications channel. CICM channel
				negotiators (CICM::Negotiator) similarly initiate a key agreement
				protocol with a remote entity, but this typically results in an
				ephemeral key, in contrast to these key protocol interfaces which
				result in a persistent symmetric key that can be used by a variety
				of key management and channel management functions.</t>
				<t>For the purposes of these key protocol-related interfaces, a
				client program using the CICM API is only an intermediary in a key
				management protocol being conducted between a cryptographic module
				and other participants in a protocol session. In this role, a
				client program determines which module(s) should be involved and
				conveys the protocol messages, but otherwise does not participate
				in the protocol session. The client may be responsible for
				determining which key agreement protocol to use as well as for the
				reliable transport of messages passed between the peer entities.
				The interactions that comprise a protocol session in its entirety
				may entail a number of exchanges among the participants in the
				protocol. Any results from calls to key protocol methods during the
				course of the protocol exchange must be communicated to the
				appropriate peer entity by the caller. The progress, success, or
				failure of the protocol session is determined by the modules and
				other active participants in the interaction.</t>
				<t>CICM key protocol functionality is exported via two independent
				objects: CICM::KeyProtocolSender for protocol messages inbound to
				the module and CICM::KeyProtocolReceiver for messages outbound from
				the module. Access to each respective object is available via
				CICM::SymKeyManager::key_protocol_sender and
				CICM::SymKeyManager::key_protocol_receiver.</t>
				<t>The key protocol methods support protocol sessions that may be
				long-term interactions potentially extending over several
				invocations of the controlling client program. To allow for this
				possibility, KeyProtocolReceiver::get_from_module may be used to
				"query" a module to determine if a response is ready and, if so, to
				retrieve response traffic (including current session status
				information) from the module. Thus, a single response from the
				module may take the form of a number of queries by the client
				program, with any productive response deferred until the module is
				ready:
				<list>
					<t>query, response is C_PROTOCOL_RECEIVE_BUSY</t>
					<t>query, response is C_PROTOCOL_RECEIVE_BUSY</t>
					<t>...</t>
					<t>query, response is C_PROTOCOL_RECEIVE_BUSY</t>
					<t>query, results returned, response is C_PROTOCOL_RECEIVE_OKAY</t>
				</list>
				</t>
				<t>In the example above, the client program expects either a
				"condition" update from the module as part of the protocol session,
				or the most recent results from the active session. Thus, the
				client program queries the module periodically until it is ready to
				produce a response.</t>
				<t>The traffic relayed by these functions is part of a specific
				protocol session. The protocol governing this session is specified
				with the protocol parameter, either the value
				CICM::IMPLICIT_PROTOCOL_ID, denoting that the message itself
				indicates the protocol, or a unique protocol identifier designating
				the protocol directly. If the protocol parameter is
				CICM::IMPLICIT_PROTOCOL_ID but the message does not indicate the
				protocol, then the method fails, returning the
				CICM::S_PROTO_UNDETERMINED error status.</t>
				<t>The initial message in a protocol exchange can be generated
				either by the cryptographic module or some other party, including
				some party in a key management infrastructure or the client program
				itself. If the initial message is generated by the cryptographic
				module, a two-step process allows the message to be retrieved from
				the module:
				<list style="numbers">
				  <t>The module notifies the client program that a protocol
				  message is available to be retrieved via the CICM module event
				  listener facility (this requires a
				  CICM::ModuleEventListener::C_MODULE_KEY_PROTO_MESSAGE to have
				  been previously registered by the client program). The listener
				  facility provides an opaque buffer as part of the notification
				  that is passed to the module in the following step to identify
				  the specific protocol message involved.</t>
				  <t>The CICM::KeyProtocolReceiver::get_from_module method is used
				  to retrieve the message from the module.</t>
				</list>
				</t>
				<t>If the initial message is generated by some other party, the
				CICM::KeyProtocolSender::put_into_module method is used to convey
				the message into the module.</t>
				<t>Any key protocol-related key fill device interactions are
				outside the scope of the API.</t>
				<t>Individual protocol events do not require a transaction
				identifier. Instead, each message itself indicates where it is to
				be forwarded (i.e. which module or other participant is to receive
				the message). This means that the client program must be capable of
				determining which module to associate with a given message,
				possibly by examining metadata conveyed with the message.</t>

				<section title="Participants in the Interaction">
					<t>There are three types of
					participants in a protocol session using the key protocol
					functionality:
					<list style="symbols">
					  <t>The cryptographic modules themselves. Note that although
					  these methods work with modules individually, there may in fact
					  be several modules involved in a single protocol session, e.g.,
					  to deliver the same key material to several modules available to
					  a host or in a net.</t>
					  <t>The other participants (generally key management
					  infrastructure components) that also take an active part in the
					  session, i.e., those that generate and/or consume messages
					  exchanged in the session (perhaps with status indications
					  embedded in the messages). All active participants, to the extent
					  they find necessary, maintain and update internal status as the
					  session continues.</t>
					  <t>The intermediary client program that conveys the messages
					  among the active participants in the session (the cryptographic
					  modules themselves and the other active participants in the
					  session). Note that a module may generate a message for
					  transmission to another module as part of the protocol
					  session.</t>
					</list></t>
					<t>The CICM API is the interface between the intermediary client
					programs and the cryptographic modules. All exchanges for a
					specific protocol session between a given module and other modules
					or other active participants (Party 1, ..., Party N) are mediated
					by the intermediary client program using CICM. Although the client
					program does not directly participate in the protocol session, the
					client program may be asked during the negotiation process to
					display identifying information about the remote party in the
					protocol to a human user who must determine if the remote party is
					the expected remote party in the protocol and, if so, must
					positively acknowledge this assertion to allow the protocol to
					continue. Some protocol sessions will not require this peer
					validation interaction (e.g., validation of the peer using a trust
					anchor is deemed sufficient or an external trusted display handles
					the user interaction).</t>
					<t>Except for recognizing the specific role of the cryptographic
					modules themselves, assignment of roles in the protocol to the
					active participants is out of scope for this document.</t>
				</section>
				<section title="Return Status, Condition, and Session Status">
					<t>The key
					protocol interfaces convey messages between modules and the
					intermediary client program but do not conduct the actual protocol
					session. However, the client program still needs to know something
					about the state of the session, so the key protocol methods impart
					three types of status information:
					<list style="symbols">
					  <t>Status return value indicates the status of the method call
					  itself. In the event of a failure, it gives an indication of what
					  the failure was. Note that the returned value does not indicate
					  the state of the protocol session itself: It could report a
					  faulty call (e.g., an invalid protocol identifier) even when the
					  protocol session is still making progress, and it could report a
					  successful exchange with the cryptographic module even when the
					  module decides that the session has reached an error
					  condition.</t>
					  <t>The returned condition indication summarizes for the client
					  program the state of the session, perhaps to be used along with
					  other information to suggest what the client program should do
					  next as part of the current protocol session.</t>
					  <t>The current or resulting status of the protocol session is
					  embedded in the message conveyed between the client program and
					  the active participants. The client program typically will not
					  interpret the contents of this message; instead, it will simply
					  convey the message to the appropriate active participants, who
					  may then interpret the status in the message and take the
					  appropriate next step in the protocol.</t>
					</list></t>
				</section>
				<section title="Generic Scenario">
					<t>The following diagram presents a generic
					scenario for a key protocol session. This diagram does not show
					message exchanges with any other active participants, since they
					are out of scope for the API. Note that, although responses from
					the module to the intermediary client program are represented as
					arrows in the diagram, in fact, the module actually conveys the
					response only when the client program explicitly asks or is
					prompted by an event to ask for it.</t>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 25. Generic Scenario for Key
					  Protocol Session Initiated by a Key Infrastructure
					  Component</t>
					<t>The notional key infrastructure-initiated message exchanges are
					as follows:
					<list style="symbols">
					  <t>Event "A1": Start key protocol - The client program receives
					  the first protocol message from a key infrastructure component
					  and sends it to the module using
					  KeyProtocolSender::put_into_module. The returned condition
					  indicates that the protocol session is C_PROTOCOL_SEND_OKAY.</t>
					  <t>Event "M1": Successful start to key protocol - The client
					  program requests the module's response using
					  KeyProtocolReceiver::get_from_module. This response is the
					  module's first message in this exchange and includes the current
					  status of the session. Multiple queries could respond with a BUSY
					  condition before a C_PROTOCOL_SEND_OKAY condition is finally
					  returned. The C_PROTOCOL_SEND_OKAY condition indicates that the
					  session is in progress and a response message has been returned.
					  The client program is responsible for forwarding the resulting
					  response message to another active protocol participant.</t>
					  <t>Event "A2": Send protocol message - The client program
					  forwards the next message in the protocol sequence received from
					  the infrastructure component to the module using the
					  KeyProtocolSender::put_into_module method. The returned condition
					  indicates that the protocol session is C_PROTOCOL_SEND_OKAY.</t>
					  <t>Event "M2": Message C_PROTOCOL_SEND_OKAY, more pending - The
					  module provides another message in this exchange using
					  KeyProtocolReceiver::get_from_module. The returned condition
					  indicates that the protocol session is C_PROTOCOL_SEND_OKAY and a
					  responding message has been returned.</t>
					  <t>Event "An": Send protocol message - The client program
					  forwards what is ultimately the last message in the protocol
					  sequence to the module using
					  KeyProtocolSender::put_into_module.</t>
					  <t>Event "Mn": Message C_PROTOCOL_SEND_OKAY, protocol done - The
					  module provides the corresponding last message in this exchange
					  when the client program queries the module using
					  KeyProtocolReceiver::get_from_module. The returned condition
					  indicates that the protocol session is DONE and the last
					  responding message in this protocol session has been returned. As
					  shown here, the module determines (or at least reports to the
					  client program) when the protocol session is done. Another active
					  participant could plausibly make this determination.</t>
					</list></t>
				</section>
				<section title="Key Agreement Example Using Diffie-Hellman Protocol">
					<t>The
					following example depicts a notional key infrastructure ("Entity
					A") initiating an authenticated Diffie-Hellman Discrete Logarithm
					(DH-DL) key agreement protocol with a cryptographic module ("Entity
					B"). A host running a client program using CICM for interactions
					with the module interposes itself between the key infrastructure
					and the module.</t>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 26. Example of a Two-key
					  Diffie-Hellman Discrete Logarithm (DH-DL) Key Agreement Protocol
					  Initiated by a Key Infrastructure</t>
					<t>The following are the steps required to use CICM in the protocol
					example between a notional key infrastructure ("Entity A") and a
					cryptographic module ("Entity B"):
					<list style="numbers">
					  <t>The following are prepositioned at both communicating
					  elements:
					  <list style="symbols">
						<t>Domain parameters g and p.</t>
						<t>Digital certificate.</t>
						<t>Signature verification key required to validate the
						certificate of the other entity.</t>
						</list></t>
					  <t>"Entity A" generates random value a.</t>
					  <t>"Entity A" calculates A=g^a mod p.</t>
					  <t>"Entity A" signs the value A calculated above using its
					  static private key whose corresponding static public key is
					  contained in its certificate.</t>
					  <t>"Entity A" sends the signed value A and cert-A to the client
					  program on the intermediary host as an opaque binary buffer.</t>
					  <t>The client program on the intermediary host calls
					  KeyProtocolSender::put_into_module to send the opaque binary
					  buffer received by the client program to the module; if a
					  CICM::KeyProtocolSender::C_PROTOCOL_SEND_DISPLAY condition is
					  returned from this call, the following steps SHOULD be performed
					  (the steps do not appear in the diagram):
					  <list style="letters">
						<t>"Entity A" calls CICM::Negotiator::get_remote_info to
						retrieve information about the remote peer; this information
						(including name/organization and classification level) are
						extracted from cert-B and returned in CICM::PeerInfo.</t>
						<t>The client program on the intermediary host displays the
						identifying information returned above in CICM::PeerInfo to a
						human user and asks for positive acknowledgement that the
						entity initiating the protocol is in fact a legal entity to
						initiate the protocol.</t>
						<t>If the human user does not recognize the remote entity and
						declines to give positive acknowledgement, the client program
						abandons the protocol. In this example, positive
						acknowledgement is given, and the client program calls
						CICM::KeyProtocolReceiver::get_from_module to request a
						protocol response.</t>
					  </list></t>
					  <t>"Entity B" generates random value b.</t>
					  <t>"Entity B" calculates B=g^b mod p, using parameters g and p
					  that it previously agreed it would use when initiating a protocol
					  exchange with "Entity A."</t>
					  <t>"Entity B" signs the value B calculated above using its
					  static private key whose corresponding static public key is
					  contained in its certificate.</t>
					  <t>"Entity B" returns an opaque binary buffer containing its
					  signed value B and cert-B to the caller of
					  KeyProtocolReceiver::get_from_module with a condition of
					  DONE.</t>
					  <t>The client program on the intermediary host sends the opaque
					  binary buffer to "Entity A".</t>
					  <t>Both entities verify their peer's certificate is valid.</t>
					  <t>"Entity A" calculates K=B^a mod p.</t>
					  <t>"Entity B" calculates K=A^b mod p.</t>
					  <t>Both entities now share a symmetric key K.</t>
					</list></t>
				</section>
				<section title="Protocol Support Examples">
					<t>As previously stated, these
					methods support a wide range of key management protocols. The
					following is a notional list of such protocols with a description
					of their intended usage:
					<list style="symbols">
					  <t>Key agreement/distribution protocols - Key material can be
					  distributed and keys can be agreed upon using the DH-DL, EC-DH,
					  EC-MQV, or related protocols.</t>
					  <t>Remote key functions - Messages containing key-related
					  commands (i.e., zeroize, rekey) requiring authentication by the
					  module prior to execution may be presented using these
					  functions.</t>
					  <t>Trust anchor management protocols - Trust anchor management
					  commands and data may be sent as opaque data elements which are
					  interpreted by the module in a protocol-specific manner.</t>
					  <t>Key revocation messages - Opaque data elements identifying
					  certificates associated with keys which have been revoked are
					  accepted. The ability to handle a list of revoked keys allows a
					  module to prevent further usage of these keys, including
					  performing key agreement with an entity that is known to have
					  been compromised or no longer possesses the roles or affiliations
					  described in the certificate.</t>
					</list></t>
				</section>
				<section title="Interface CICM::KeyProtocolSender">
					<figure>
					  <preamble>Interface CICM::KeyProtocolSender</preamble>
					  <artwork><![CDATA[interface KeyProtocolSender : CICM::Negotiator {]]></artwork>
					<postamble>CICM::KeyProtocolSender supports sending key management
					protocol-related messages into a module.</postamble>
					</figure>

					<section title="CICM::KeyProtocolSender Inheritance">
						<t>CICM::KeyProtocolSender inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::KeyProtocolSender Types and Constants">
						<figure>
						  <preamble>Type CICM::KeyProtocolSender::Condition</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Condition;]]></artwork>
						<postamble>Condition values summarize for the client program the state
						of the session. This information can be used along with other
						information to suggest what the client program should do next as
						part of the current protocol session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_OKAY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_OKAY = 0x00006045;]]></artwork>
						  <postamble>Denotes that the session is in progress and a response
						  message is available.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_DONE</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_DONE = 0x00006046;]]></artwork>
							<postamble>Denotes that the session terminated successfully.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_ERROR</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_ERROR = 0x00006049;]]></artwork>
						  <postamble>Denotes that the session terminated with an error
						  condition.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_DISPLAY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_DISPLAY = 0x0000604A;]]></artwork>
						  <postamble>As with the C_PROTOCOL_SEND_OKAY condition, denotes that
						  the session is in progress and a response message is available,
						  but additionally denotes that identification information
						  extracted from the remote certificate is available via a call to
						  the CICM::Negotiator::get_remote_info method; the information
						  retrieved from a call to this method must be displayed to a human
						  user on the host and validated before the protocol should be
						  allowed to continue. Note that a trusted display may be employed
						  by the module for the same purpose but, because no API
						  interaction would be involved, the C_PROTOCOL_SEND_DISPLAY
						  condition would not be returned.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_ABORTED</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_ABORTED = 0x0000604C;]]></artwork>
						  <postamble>Denotes that the human user reviewing the remote peer
						  information chose to reject it and abort the protocol.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_MESSAGE_INVALID</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_MESSAGE_INVALID = 0x0000604F;]]></artwork>
						  <postamble>Denotes that the conveyed message was found to be invalid
						  for the protocol. This event does not terminate the protocol
						  session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_MESSAGE_INTEGRITY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_MESSAGE_INTEGRITY = 0x00006051;]]></artwork>
						  <postamble>Denotes that the conveyed message failed one or more
						  integrity checks used in the protocol. This event does not
						  terminate the protocol session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_PROTOCOL_VIOLATION</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_PROTOCOL_VIOLATION = 0x00006052;]]></artwork>
						  <postamble>Denotes that a message or attempted action unexpected at
						  the current point in the protocol session was noted. This event
						  does not terminate the protocol session.</postamble>
						</figure>
					</section>
					<section title="CICM::KeyProtocolSender Methods">
						<figure>
						  <preamble>Method CICM::KeyProtocolSender::put_into_module()</preamble>
<artwork><![CDATA[CICM::Status put_into_module(
	in  CICM::ProtocolId protocol,
	in  CICM::Buffer message,
	out CICM::KeyProtocolSender::Condition condition
);]]></artwork>
						<postamble>Initiate or recommence a key management protocol session,
						forwarding a message to the cryptographic module. If the
						C_PROTOCOL_SEND_DISPLAY condition results, the get_remote_info
						method should be called to retrieve identity information about the
						remote peer for display to and validation by the responsible user
						before the protocol negotiation is allowed to continue.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The format of the conveyed message is not defined by CICM.
							If the client program must be capable of generating the
							message, then the Implementation Conformance Statement (see
							Section 4, Conformance and Extensions) must reference a
							standard format or define a module developer-specific format
							implemented by the module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] protocol Designate the protocol to be followed for this
								  session; the same value must be used for this parameter
								  for all calls to this method or to get_from_module, as
								  part of the same protocol session.</t>
							<t>[in] message Message conveyed to the module as part of the current
								  protocol session.</t>
							<t>[out] condition Condition of the current protocol session; the
								  calling client program must interpret this value to
								  determine what its next action must be.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::KeyProtocolSender::put_into_module_algo for the
							version of this method that accepts an algorithm.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::KeyProtocolSender::put_into_module_algo()</preamble>
<artwork><![CDATA[CICM::Status put_into_module_algo(
	in  CICM::ProtocolId protocol,
	in  CICM::Buffer message,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::KeyProtocolSender::Condition condition
);]]></artwork>
						<postamble>Initiate or recommence a key management protocol session,
						forwarding a message to the cryptographic module. If the
						C_PROTOCOL_SEND_DISPLAY condition results, the get_remote_info
						method should be called to retrieve identity information about the
						remote peer for display to and validation by the responsible user
						before the protocol negotiation is allowed to continue. This method
						differs from KeyProtocolSender::put_into_module in that it enables
						the caller to specify the desired algorithm of the resulting
						symmetric key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The format of the conveyed message is not defined by CICM.
							If the client program must be capable of generating the
							message, then the Implementation Conformance Statement (see
							Section 4, Conformance and Extensions) must reference a
							standard format or define a module developer-specific format
							implemented by the module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] protocol Designate the protocol to be followed for this
								  session; the same value must be used for this parameter
								  for all calls to this method or to get_from_module, as
								  part of the same protocol session.</t>
							<t>[in] message Message conveyed to the module as part of the current
								  protocol session.</t>
							<t>[in] algorithm Algorithm/mode of resulting symmetric key.</t>
							<t>[out] condition Condition of the current protocol session; the
								  calling client program must interpret this value to
								  determine what its next action must be.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::KeyProtocolSender::put_into_module for the version of
							this method that does not require an algorithm.</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::KeyProtocolReceiver">
					<figure>
					  <preamble>Interface CICM::KeyProtocolReceiver</preamble>
					  <artwork><![CDATA[interface KeyProtocolReceiver {]]></artwork>
					<postamble>CICM::KeyProtocolReceiver supports receiving key management
					protocol-related messages from a module. CICM::KeyProtocolReceiver
					constructs the CICM::SymKey interface.</postamble>
					</figure>

					<section title="CICM::KeyProtocolReceiver Types and Constants">
						<figure>
						  <preamble>Type CICM::KeyProtocolReceiver::Condition</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Condition;]]></artwork>
						<postamble>Condition values summarize for the client program the state
						of the session. This information can be used along with other
						information to suggest what the client program should do next as
						part of the current protocol session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_OKAY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_OKAY = 0x00006034;]]></artwork>
						  <postamble>Denotes that the session is in progress and a response
						  message has been returned.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_DONE</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_DONE = 0x00006037;]]></artwork>
							<postamble>Denotes that the session terminated successfully.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_BUSY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_BUSY = 0x00006038;]]></artwork>
						  <postamble>Denotes that the session is in progress but no response
						  message or error indication is available at the current time; in
						  this case, the client program must make additional calls to
						  CICM::KeyProtocolReceiver::get_from_module to determine when the
						  response message has become available and retrieve the
						  message.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_ERROR</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_ERROR = 0x0000603B;]]></artwork>
						  <postamble>Denotes that the session terminated with an error condition
						  and a response message has been returned.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_ABORTED</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_ABORTED = 0x0000603D;]]></artwork>
						  <postamble>Denotes that the human user reviewing the remote peer
						  information chose to reject it and abort the protocol.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_MESSAGE_INVALID</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_MESSAGE_INVALID = 0x0000603E;]]></artwork>
						  <postamble>Denotes that the conveyed message was found to be invalid
						  for the protocol. This event does not terminate the protocol
						  session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_MESSAGE_INTEGRITY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_MESSAGE_INTEGRITY = 0x00006040;]]></artwork>
						  <postamble>Denotes that the conveyed message failed one or more
						  integrity checks used in the protocol. This event does not
						  terminate the protocol session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_VIOLATION</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_VIOLATION = 0x00006043;]]></artwork>
						  <postamble>Denotes that a message or attempted action unexpected at
						  the current point in the protocol session was noted. This event
						  does not terminate the protocol session.</postamble>
						</figure>
					</section>
					<section title="CICM::KeyProtocolReceiver Methods">
						<figure>
						  <preamble>Method CICM::KeyProtocolReceiver::abort()</preamble>
						  <artwork><![CDATA[CICM::Status abort();]]></artwork>
						  <postamble>Abort negotiation.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This method may be called at any point in the negotiation
							process for any reason. However, it must be called in the event
							the identification information for the remote peer does not
							correspond to the expected peer.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_NOT_IN_PROGRESS</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::KeyProtocolReceiver::get_from_module()</preamble>
<artwork><![CDATA[CICM::Status get_from_module(
	in  CICM::ProtocolId protocol,
	out CICM::Buffer message,
	out CICM::KeyProtocolReceiver::Condition condition
);]]></artwork>
							<postamble>Initiate or recommence a key management protocol session,
							soliciting a response from the cryptographic module.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The format of the conveyed message is not defined by CICM.
							If the client program must be capable of interpreting the
							contents of the message, then the Implementation Conformance
							Statement (see Section 4, Conformance and Extensions) must
							reference a standard format or define a module
							developer-specific format implemented by the module for this
							datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] protocol Designate the protocol to be followed for this
								  session; the same value must be used for this parameter
								  for all calls to this method or to
								  CICM::KeyProtocolSender::put_into_module, as part of the
								  same protocol session.</t>
							<t>[out] message Message returned from the module as part of the
								  current protocol session; message may be of length
								  zero.</t>
							<t>[out] condition Condition of the current protocol session; the
								  calling client program must interpret this value to
								  determine what its next action must be.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::KeyProtocolReceiver::get_key()</preamble>
<artwork><![CDATA[CICM::Status get_key(
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>At successful conclusion of a key agreement/distribution
						protocol session (when the returned condition is
						C_PROTOCOL_RECEIVE_DONE), this method is called to retrieve a
						reference to the key resulting from the session.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Note that, in those cases where the protocol session does
							not result in a key (e.g., a key revocation message, key white
							list or black list is presented to the module via this
							interface), calling this method will result in an
							CICM::S_INVALID_STATE error.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] key_ref Reference to key resulting from a successful protocol
								  session.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_NOT_IN_PROGRESS</t>
							</list>
						</t>
					</section>
				</section>
			</section>
		</section>
		<section title="Channel Management">
			<section title="Channel Abstractions">
				<section title="Interface CICM::ChannelManager">
					<figure>
					  <preamble>Interface CICM::ChannelManager</preamble>
<artwork><![CDATA[interface ChannelManager :
	CICM::Answer::ChannelManager,
	CICM::BypassRead::ChannelManager,
	CICM::BypassWrite::ChannelManager,
	CICM::Coprocessor::ChannelManager,
	CICM::Decrypt::ChannelManager,
	CICM::DecryptBypass::ChannelManager,
	CICM::Duplex::ChannelManager,
	CICM::Emit::ChannelManager,
	CICM::Encrypt::ChannelManager,
	CICM::EncryptBypass::ChannelManager {]]></artwork>
					<postamble>CICM::ChannelManager supports the creation and negotiation of
					cryptographic channels. It is accessed from CICM::CryptoModule via
					the CICM::CryptoModule::channel_manager attribute.
					CICM::ChannelManager enables a variety of different channel types
					to be constructed.</postamble>
					</figure>
					<t>Note:
						<list>
						  <t>Conforming implementations need only implement one or more of
						  the ChannelManager's dependencies thereby limiting which
						  negotiators, controllers, streams, and channels are
						  available.</t>
						</list>
					</t>

					<section title="CICM::ChannelManager Inheritance">
						<t>CICM::ChannelManager inherits from: CICM::Answer::ChannelManager,
						CICM::BypassRead::ChannelManager,
						CICM::BypassWrite::ChannelManager,
						CICM::Coprocessor::ChannelManager, CICM::Decrypt::ChannelManager,
						CICM::DecryptBypass::ChannelManager, CICM::Duplex::ChannelManager,
						CICM::Emit::ChannelManager, CICM::Encrypt::ChannelManager and
						CICM::EncryptBypass::ChannelManager.</t>
					</section>
					<section title="CICM::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::ChannelManager::create_controller_group()</preamble>
<artwork><![CDATA[CICM::Status create_controller_group(
	out CICM::ControllerGroup controller_group_ref
);]]></artwork>
						<postamble>Creates a CICM::ControllerGroup to group controllers and
						conduits together.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_group_ref Reference to the created controller group.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Channel">
					<figure>
					  <preamble>Interface CICM::Channel</preamble>
					  <artwork><![CDATA[interface ChannelEventListener {]]></artwork>
					<postamble>Defines the logical path through the module. Interface from
					which all conduit, streams and controllers inherit.
					Channels are created via the CICM::ChannelManager interface.</postamble>
					</figure>

					<section title="CICM::Channel Attributes">
						<figure>
						  <preamble>AttributeCICM::Channel::event_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::ChannelEventManager event_manager;]]></artwork>
						  <postamble>Provides access to the event manager.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::Conduit">
					<figure>
					  <preamble>Interface CICM::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Controller,
	CICM::Stream {]]></artwork>
					<postamble>Interface from which all other conduits are inherited. A
					conduit is a combination of a stream and controller.</postamble>
					</figure>

					<section title="CICM::Conduit Inheritance">
						<t>CICM::Conduit inherits from: CICM::Controller and CICM::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Controller">
					<figure>
					  <preamble>Interface CICM::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::Channel {]]></artwork>
					<postamble>Interface from which all other controllers are inherited.
					Controls general characteristics of a cryptographic transformation,
					but does not provide data to be transformed.</postamble>
					</figure>
					<t>Remarks:
						<list>
						  <t>There may be cases in which a client program wishes to
						  delegate responsibility for sending or receiving data from the
						  module to another process while retaining the authority to manage
						  the channel. To support this task, both processes must share a
						  known local port. The client-program responsible for controlling
						  the channel creates a CICM::Controller of the appropriate type
						  after which the corresponding CICM::Stream may be obtained by the
						  second process. A stream is tied to the specific controller that
						  configured the channel by a common port value.</t>
						</list>
					</t>

					<section title="CICM::Controller Inheritance">
						<t>CICM::Controller inherits from: CICM::Channel.</t>
					</section>
					<section title="CICM::Controller Methods">
						<figure>
						  <preamble>Method CICM::Controller::destroy()</preamble>
						  <artwork><![CDATA[CICM::Status destroy();]]></artwork>
						  <postamble>Destroys the controller.</postamble>
						</figure>
						<t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Stream">
					<figure>
					  <preamble>Interface CICM::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::Channel {};]]></artwork>
					<postamble>Interface from which all streams inherit. Streams manage the
					flow of data on a channel, but not its attributes.</postamble>
					</figure>
					<section title="CICM::Stream Inheritance">
						<t>CICM::Stream inherits from: CICM::Channel.</t>
					</section>
				</section>
			</section>
			<section title="Conduit Abstractions">
				<section title="Interface CICM::AbstractMACConduit">
					<figure>
					  <preamble>Interface CICM::AbstractMACConduit</preamble>
					  <artwork><![CDATA[interface AbstractMACConduit : CICM::Conduit {]]></artwork>
					<postamble>Interface from which other MAC conduits are inherited.</postamble>
					</figure>

					<section title="CICM::AbstractMACConduit Inheritance">
						<t>CICM::AbstractMACConduit inherits from: CICM::Conduit.</t>
					</section>
					<section title="CICM::AbstractMACConduit Attributes">
						<figure>
						  <preamble>AttributeCICM::AbstractMACConduit::mac_key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymKey mac_key;]]></artwork>
						<postamble>The key used for computing the MAC.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::AbstractMACConduit::mac_algorithm</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymMacAlgorithmId mac_algorithm;]]></artwork>
						<postamble>The algorithm used to MAC the data.</postamble>
						</figure>
					</section>
					<section title="CICM::AbstractMACConduit Methods">
						<figure>
						  <preamble>Method CICM::AbstractMACConduit::end_get_mac()</preamble>
<artwork><![CDATA[CICM::Status end_get_mac(
	out CICM::MACBuffer mac
);]]></artwork>
						<postamble>Direct the module to compute and output the MAC value, and
						reset the channel to accept additional data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] mac Computed MAC value.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AbstractSignConduit">
					<figure>
					  <preamble>Interface CICM::AbstractSignConduit</preamble>
					  <artwork><![CDATA[interface AbstractSignConduit : CICM::Conduit {]]></artwork>
					<postamble>Interface from which other sign conduits are inherited.</postamble>
					</figure>

					<section title="CICM::AbstractSignConduit Inheritance">
						<t>CICM::AbstractSignConduit inherits from: CICM::Conduit.</t>
					</section>
					<section title="CICM::AbstractSignConduit Attributes">
						<figure>
						  <preamble>AttributeCICM::AbstractSignConduit::sign_key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymKey sign_key;]]></artwork>
						<postamble>Key used for signing the data.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::AbstractSignConduit::sign_algorithm</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymSigAlgorithmId sign_algorithm;]]></artwork>
						<postamble>Algorithm used to sign the data.</postamble>
						</figure>
					</section>
					<section title="CICM::AbstractSignConduit Methods">
						<figure>
						  <preamble>Method CICM::AbstractSignConduit::end_get_signature()</preamble>
<artwork><![CDATA[CICM::Status end_get_signature(
	out CICM::SigBuffer signature
);]]></artwork>
						<postamble>Direct the module to compute and output the signature, and
						reset the conduit to accept additional data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] signature The computed signature.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AbstractVerifyConduit">
					<figure>
					  <preamble>Interface CICM::AbstractVerifyConduit</preamble>
					  <artwork><![CDATA[interface AbstractVerifyConduit : CICM::Conduit {]]></artwork>
						<postamble>Interface from which other verification conduits are inherited.</postamble>
					</figure>

					<section title="CICM::AbstractVerifyConduit Inheritance">
						<t>CICM::AbstractVerifyConduit inherits from: CICM::Conduit.</t>
					</section>
					<section title="CICM::AbstractVerifyConduit Types and Constants">
						<figure>
						  <preamble>Type CICM::AbstractVerifyConduit::VerifyStatus</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 VerifyStatus;]]></artwork>
						<postamble>Verification status (data verifies/does not verify).</postamble>
						</figure>
						<figure>
							  <preamble>Constant   CICM::AbstractVerifyConduit::C_DATA_VERIFIED</preamble>
<artwork><![CDATA[const CICM::AbstractVerifyConduit::VerifyStatus
	C_DATA_VERIFIED = 0x00006025;]]></artwork>
							  <postamble>Data verifies.</postamble>
						</figure>
						<figure>
							  <preamble>Constant   CICM::AbstractVerifyConduit::C_DATA_NOT_VERIFIED</preamble>
<artwork><![CDATA[const CICM::AbstractVerifyConduit::VerifyStatus
C_DATA_NOT_VERIFIED = 0x00006026;]]></artwork>
							  <postamble>Data does not verify.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::AbstractMACVerifyConduit">
					<figure>
					  <preamble>Interface  CICM::AbstractMACVerifyConduit</preamble>
					  <artwork><![CDATA[interface AbstractMACVerifyConduit : CICM::AbstractVerifyConduit {]]></artwork>
					<postamble>Interface from which other MAC verify conduits are inherited.</postamble>
					</figure>

					<section title="CICM::AbstractMACVerifyConduit Inheritance">
						<t>CICM::AbstractMACVerifyConduit inherits from: CICM::AbstractVerifyConduit.</t>
					</section>
					<section title="CICM::AbstractMACVerifyConduit Attributes">
						<figure>
						  <preamble>AttributeCICM::AbstractMACVerifyConduit::verify_key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymKey verify_key;]]></artwork>
						<postamble>Key used to verify the MAC.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::AbstractMACVerifyConduit::verify_algorithm</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymMacAlgorithmId verify_algorithm;]]></artwork>
						<postamble>Algorithm used to verify the data.</postamble>
						</figure>
					</section>
					<section title="CICM::AbstractMACVerifyConduit Methods">
						<figure>
						  <preamble>Method CICM::AbstractMACVerifyConduit::end_get_verified()</preamble>
<artwork><![CDATA[CICM::Status end_get_verified(
	in  CICM::MACBuffer mac,
	out CICM::AbstractVerifyConduit::VerifyStatus status
);]]></artwork>
						<postamble>Direct the module to compute and output the MAC verification
						status, and reset the channel to accept additional data for
						verification.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] mac Message authentication code.</t>
							<t>[out] status Status indicating whether or not the data
								  verifies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AbstractSigVerifyConduit">
					<figure>
					  <preamble>Interface  CICM::AbstractSigVerifyConduit</preamble>
					  <artwork><![CDATA[interface AbstractSigVerifyConduit : CICM::AbstractVerifyConduit {]]></artwork>
					<postamble>Interface from which other signature verification conduits
					are inherited.</postamble>
					</figure>

					<section title="CICM::AbstractSigVerifyConduit Inheritance">
						<t>CICM::AbstractSigVerifyConduit inherits from: CICM::AbstractVerifyConduit.</t>
					</section>
					<section title="CICM::AbstractSigVerifyConduit Attributes">
						<figure>
						  <preamble>AttributeCICM::AbstractSigVerifyConduit::verify_key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymKey verify_key;]]></artwork>
						<postamble>Key used to verify the signature.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::AbstractSigVerifyConduit::verify_algorithm</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymSigAlgorithmId verify_algorithm;]]></artwork>
						<postamble>Algorithm used to verify the data.</postamble>
						</figure>
					</section>
					<section title="CICM::AbstractSigVerifyConduit Methods">
						<figure>
						  <preamble>Method CICM::AbstractSigVerifyConduit::end_get_verified()</preamble>
<artwork><![CDATA[CICM::Status end_get_verified(
	in  CICM::SigBuffer signature,
	out CICM::AbstractVerifyConduit::VerifyStatus status
);]]></artwork>
						<postamble>Direct the module to compute and output the verification
						status, and reset the channel to accept additional data for
						verification.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] signature Signature.</t>
							<t>[out] status Status indicating whether or not the data
								  verifies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Stream Abstractions">
				<section title="Interface CICM::WriteStream">
					<figure>
					  <preamble>Interface CICM::WriteStream</preamble>
					  <artwork><![CDATA[interface WriteStream : CICM::Stream {]]></artwork>
					<postamble>Interface from which other streams that write data to the
					module inherit.</postamble>
					</figure>

					<section title="CICM::WriteStream Inheritance">
						<t>CICM::WriteStream inherits from: CICM::Stream.</t>
					</section>
					<section title="CICM::WriteStream Types and Constants">
						<figure>
						  <preamble>Type CICM::WriteStream::WriteStatus</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 WriteStatus;]]></artwork>
						<postamble>Status of an non-blocking write.</postamble>
						</figure>
						<figure>
							  <preamble>Constant   CICM::WriteStream::C_WRITE_NOT_READY</preamble>
<artwork><![CDATA[const CICM::WriteStream::WriteStatus
	C_WRITE_NOT_READY = 0x00006067;]]></artwork>
							  <postamble>Module is not ready to receive data for writing.</postamble>
						</figure>
						<figure>
							  <preamble>Constant   CICM::WriteStream::C_WRITE_READY</preamble>
<artwork><![CDATA[const CICM::WriteStream::WriteStatus
	C_WRITE_READY = 0x00006068;]]></artwork>
							  <postamble>Module is ready to receive data for writing.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::ReadStream">
					<figure>
					  <preamble>Interface CICM::ReadStream</preamble>
					  <artwork><![CDATA[interface ReadStream : CICM::Stream {]]></artwork>
					<postamble>Interface from which all other streams that read data from
					the module inherit.</postamble>
					</figure>

					<section title="CICM::ReadStream Inheritance">
						<t>CICM::ReadStream inherits from: CICM::Stream.</t>
					</section>
					<section title="CICM::ReadStream Types and Constants">
						<figure>
						  <preamble>Type CICM::ReadStream::ReadStatus</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 ReadStatus;]]></artwork>
						<postamble>Status of a non-blocking read.</postamble>
						</figure>
						<figure>
							  <preamble>Constant   CICM::ReadStream::C_READ_NOT_READY</preamble>
<artwork><![CDATA[const CICM::ReadStream::ReadStatus
	C_READ_NOT_READY = 0x0000605E;]]></artwork>
							  <postamble>Module does not have data ready for reading.</postamble>
						</figure>
						<figure>
							  <preamble>Constant   CICM::ReadStream::C_READ_READY</preamble>
<artwork><![CDATA[const CICM::ReadStream::ReadStatus
	C_READ_READY = 0x00006061;]]></artwork>
							  <postamble>Module has data ready for reading.</postamble>
						</figure>
					</section>
				</section>
			</section>
			<section title="Controller Abstractions">
				<section title="Interface CICM::MultiDomainController">
					<figure>
					  <preamble>Interface CICM::MultiDomainController</preamble>
					  <artwork><![CDATA[interface MultiDomainController : CICM::Controller {]]></artwork>
					<postamble>Interface from which any other multi-domain-related
					controller or conduit inherits.</postamble>
					</figure>
					<t>Remarks:
						<list>
						  <t>Provides read access to the local and remote port values
						  associated with the controller.</t>
						</list>
					</t>

					<section title="CICM::MultiDomainController Inheritance">
						<t>CICM::MultiDomainController inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::MultiDomainController Attributes">
						<figure>
						  <preamble>AttributeCICM::MultiDomainController::local_port</preamble>
						  <artwork><![CDATA[readonly attribute CICM::LocalPort local_port;]]></artwork>
						  <postamble>Local port associated with this controller.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::MultiDomainController::remote_port</preamble>
						  <artwork><![CDATA[readonly attribute CICM::RemotePort remote_port;]]></artwork>
						  <postamble>Remote port associated with this controller.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::SymKeyController">
					<figure>
					  <preamble>Interface CICM::SymKeyController</preamble>
					  <artwork><![CDATA[interface SymKeyController : CICM::Controller {]]></artwork>
					<postamble>Interface from which all controllers using a symmetric key
					inherit.</postamble>
					</figure>

					<section title="CICM::SymKeyController Inheritance">
						<t>CICM::SymKeyController inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::SymKeyController Attributes">
						<figure>
						  <preamble>Attribute CICM::SymKeyController::key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymKey key;]]></artwork>
						</figure>
					</section>
					<section title="CICM::SymKeyController Methods">
						<figure>
						  <preamble>Method CICM::SymKeyController::update_key()</preamble>
						  <artwork><![CDATA[CICM::Status update_key();]]></artwork>
						<postamble>Cryptographically update the key associated with this
						controller using the key's native algorithm.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>To update an arbitrary key, use CICM::SymKey::update.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::update_key_with_algo for the version of this
							method that accepts an algorithm.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyController::update_key_with_algo()</preamble>
<artwork><![CDATA[CICM::Status update_key_with_algo(
	in  CICM::SymEncrAlgorithmId algorithm
);]]></artwork>
						<postamble>Cryptographically update the key associated with this
						controller using the specified algorithm.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>To update an arbitrary key, use CICM::SymKey::update.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] algorithm Cryptographic algorithm/mode to use to effect the key
								  update.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::update_key for the version of this method
							that does not require an algorithm to be specified.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyController::rollover_key()</preamble>
						  <artwork><![CDATA[CICM::Status rollover_key();]]></artwork>
						<postamble>Specify that the next pre-placed key be used with this
						controller.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>A call to this method may be required when a key reaches
							the end of its specified or usable lifespan or for other
							reasons that require that a controller move to a new key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_NO_NEXT,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::rollover_key_with_key for the version of this
							method that accepts a key.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyController::rollover_key_with_key()</preamble>
<artwork><![CDATA[CICM::Status rollover_key_with_key(
	in  CICM::SymKey next_key
);]]></artwork>
						<postamble>Specify the next pre-placed key to be used with this
						controller.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>A call to this method may be required when a key reaches
							the end of its specified or usable lifespan or for other
							reasons that require that a controller move to a new key.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] next_key Reference to pre-placed key to use with this
								  controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::rollover_key for the version of this Method  for which the key is implicit.</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AsymKeyController">
					<figure>
					  <preamble>Interface CICM::AsymKeyController</preamble>
					  <artwork><![CDATA[interface AsymKeyController : CICM::Controller {]]></artwork>
					<postamble>Interface from which all controllers using an asymmetric key
					inherit.</postamble>
					</figure>

					<section title="CICM::AsymKeyController Inheritance">
						<t>CICM::AsymKeyController inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::AsymKeyController Attributes">
						<figure>
						  <preamble>AttributeCICM::AsymKeyController::key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymKey key;]]></artwork>
						<postamble>Provides read-only access to the key associated with a
						controller.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::NegotiatedController">
					<figure>
					  <preamble>Interface CICM::NegotiatedController</preamble>
<artwork><![CDATA[interface NegotiatedController :
	CICM::MultiDomainController,
	CICM::AsymKeyController,
	CICM::Negotiator {]]></artwork>
					<postamble>Interface from which all other negotiated controllers inherit.
						A controller that uses a negotiated key.</postamble>
					</figure>

					<section title="CICM::NegotiatedController Inheritance">
						<t>CICM::NegotiatedController inherits from:
							CICM::MultiDomainController, CICM::AsymKeyController and
							CICM::Negotiator.</t>
					</section>
					<section title="CICM::NegotiatedController Attributes">
						<figure>
						  <preamble>AttributeCICM::NegotiatedController::negotiated_grade</preamble>
						  <artwork><![CDATA[readonly attribute CICM::Classification negotiated_grade;]]></artwork>
						<postamble>Returns the grade (classification level) of the channel.</postamble>
						</figure>
					</section>
					<section title="CICM::NegotiatedController Methods">
						<figure>
						  <preamble>Method CICM::NegotiatedController::renegotiate()</preamble>
						  <artwork><![CDATA[CICM::Status renegotiate();]]></artwork>
						<postamble>Renegotiates the traffic encryption key with the associated
						peer.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In cases where the key is no longer usable, e.g. it expired
							or was zeroized, the session must be torn down and rebuilt.
							Note that renegotiation may not need to be explicitly initiated
							in all cases because some modules will automatically initiate a
							renegotiation when sensing a certain condition (e.g., key
							expiration, cumulative traffic volume threshold passed,
							etc.).</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH,
							  S_CHANNEL_ERROR</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::NegotiatedController::initiate_grade_change()</preamble>
<artwork><![CDATA[CICM::Status initiate_grade_change(
	in  CICM::Classification new_grade
);]]></artwork>
						<postamble>Requests a change of grade (classification level) for the
						current traffic.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] new_grade
								  New grade for the traffic.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::NegotiatedController::acknowledge_grade_change()</preamble>
						  <artwork><![CDATA[CICM::Status acknowledge_grade_change();]]></artwork>
						  <postamble>Positively acknowledges the requested change of grade.</postamble>
						</figure>
						<t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::SetVectorController">
					<figure>
					  <preamble>Interface CICM::SetVectorController</preamble>
					  <artwork><![CDATA[interface SetVectorController : CICM::Controller {]]></artwork>
					<postamble>Provides access to the state vector associated with a
					controller.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 27. Interface Inheritance Diagram for SetVectorController</t>

					<section title="CICM::SetVectorController Inheritance">
						<t>CICM::SetVectorController inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::SetVectorController Attributes">
						<figure>
						  <preamble>AttributeCICM::SetVectorController::vec</preamble>
						  <artwork><![CDATA[readonly attribute CICM::Vector vec;]]></artwork>
						<postamble>State vector associated with this controller.</postamble>
						</figure>
					</section>
					<section title="CICM::SetVectorController Methods">
						<figure>
						  <preamble>Method CICM::SetVectorController::set_vector()</preamble>
<artwork><![CDATA[CICM::Status set_vector(
	in  CICM::Vector vec
);]]></artwork>
						<postamble>Set channel state vector.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This state value may be set when a controller is initially
							created (initialization vector). It may also be set on a
							block-by-block basis for appropriate algorithms/modes or for
							each time epoch (e.g., for time-of-day encryption).</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] vec State vector.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SetVectorController::set_vector_no_check()</preamble>
<artwork><![CDATA[CICM::Status set_vector_no_check(
	in  CICM::Vector vec
);]]></artwork>
						  <postamble>Set channel state vector without a policy check.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This state value may be set when a controller is initially
							created (initialization vector) or on a per-message basis,
							depending upon how the cryptographic algorithm uses the vector.
							The length and format of the vector are specific to the
							algorithm associated with the channel and system in which the
							channel is being used.</t>
							<t>This version of the set_vector() method may be used on the
							decrypt side, for example, to specify no TOD check in cases
							where TOD rules are not enforced for decryption.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] vec State vector.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SetVectorController::reset_vector()</preamble>
						  <artwork><![CDATA[CICM::Status reset_vector();]]></artwork>
						  <postamble>Reset channel state vector to system-dependent value.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This can be used by the client program to manage
							time-of-day or counter rollover.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::GenVectorController">
					<figure>
					  <preamble>Interface CICM::GenVectorController</preamble>
					  <artwork><![CDATA[interface GenVectorController : CICM::SetVectorController {]]></artwork>
					<postamble>Enables an state vector to be generated.</postamble>
					</figure>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 28. Interface Inheritance Diagram
					  for GenVectorController</t>

					<section title="CICM::GenVectorController Inheritance">
						<t>CICM::GenVectorController inherits from: CICM::SetVectorController.</t>
					</section>
					<section title="CICM::GenVectorController Methods">
						<figure>
						  <preamble>Method CICM::GenVectorController::generate_vector()</preamble>
						  <artwork><![CDATA[CICM::Status generate_vector();]]></artwork>
						<postamble>Generate a vector for this controller utilizing new random
						state.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>It may not be necessary for a client program to explicitly
							generate a vector. Some cryptographic modules will implicitly
							generate an IV, for example, as a byproduct of channel
							creation. In other cases, an existing vector will be associated
							with a controller by calling the
							CICM::SetVectorController::set_vector method.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::GenVectorController::generate_vector_existing_state()</preamble>
						  <artwork><![CDATA[CICM::Status generate_vector_existing_state();]]></artwork>
						<postamble>Generate a vector for this controller utilizing the latest
						unused state.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>It may not be necessary for a client program to explicitly
							generate a vector. Some cryptographic modules will implicitly
							generate an IV, for example, as a byproduct of channel
							creation. In other cases, an existing vector will be associated
							with a controller by calling the
							CICM::SetVectorController::set_vector method.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::ResyncController">
					<figure>
					  <preamble>Interface CICM::ResyncController</preamble>
					  <artwork><![CDATA[interface ResyncController : CICM::Controller {]]></artwork>
					<postamble>Provides methods to resynchronize a controller or conduit.</postamble>
					</figure>

					<section title="CICM::ResyncController Inheritance">
						<t>CICM::ResyncController inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::ResyncController Methods">
						<figure>
						  <preamble>Method CICM::ResyncController::resync()</preamble>
						  <artwork><![CDATA[CICM::Status resync();]]></artwork>
						<postamble>Resynchronize the channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>A client program-initiated resync is required when the host
							is responsible for ensuring cryptographic synchronization is
							maintained because the operating mode used does not enable the
							module to determine that it is out of sync. The action taken by
							the module as the result of a call to this method will differ
							based upon characteristics of the cryptographic algorithm,
							communications path framing, and details of the protocol used
							to achieve cryptographic synchronization between two
							modules.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::ResyncController::resync_with_sync_vector for the
							version of this method that accepts a synchronization
							vector.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::ResyncController::resync_with_sync_vector()</preamble>
<artwork><![CDATA[CICM::Status resync_with_sync_vector(
	in  CICM::Vector vec
);]]></artwork>
						<postamble>Resynchronize the channel, using the specified
						synchronization vector (required by certain operating modes to
						initiate a resync).</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>A client program-initiated resync is required when the host
							is responsible for ensuring cryptographic synchronization is
							maintained because the operating mode used does not enable the
							module to determine that it is out of sync. The action taken by
							the module as the result of a call to this method will differ
							based upon characteristics of the cryptographic algorithm,
							communications path framing, and details of the protocol used
							to achieve cryptographic synchronization among modules.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] vec Synchronization vector to use to resynchronize the
								  channel.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::ResyncController::resync for the version of this
							method that does not require a synchronization vector.</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Channel Negotiation">
				<section title="Negotiating Channels and Controllers">
					<t>When creating an
					encryption or decryption channel using an asymmetric keyset, a
					negotiation process must be initiated between the two communicating
					entities, resulting in an ephemeral symmetric key held by each
					entity. The following details the steps in the negotiation process:
					<list style="numbers">
					  <t>Retrieve a negotiator. The client program uses the
					  CICM::ChannelManager to create the appropriate CICM::Negotiator,
					  thus initiating the negotiation.</t>
					  <t>Validate remote peer. Most systems will use a trust anchor to
					  validate that the remote peer is legitimate and will further
					  verify the peer appears on the appropriate access control
					  list(s). In some cases, the above validation will be sufficient.
					  In others, it will be necessary to display information about the
					  remote peer to a human user to receive a positive response from
					  the user that the displayed peer is the expected peer. This
					  validation procedure differs depending upon the display
					  configuration:
					  <list style="symbols">
						<t>If the system is configured with a trusted display,
						information about the remote peer is displayed to the trusted
						display and the user is solicited for a response which is
						returned to the module. The trusted display interactions take
						place independent of the API.</t>
						<t>If the system is not configured with a trusted display, the
						client program uses CICM::Negotiator::get_remote_info to
						retrieve information about the remote peer and then displays
						this information to the user (independent of CICM) to allow the
						user to determine if this is the expected remote peer; the
						client program calls CICM::Negotiator::abort_negotiation to
						abort the negotiation if the user rejects the remote peer.</t>
					  </list></t>
					  <t>Complete negotiation. The client program explicitly completes
					  the negotiation using the negotiator's complete() method.</t>
					</list></t>
					<t>A successful negotation results in a negotiated controller.</t>
				</section>
				<section title="Interface CICM::Negotiator">
					<figure>
					  <preamble>Interface CICM::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator {]]></artwork>
					<postamble>CICM::Negotiator is an abstraction inherited by controllers
					and CICM::KeyProtocolSender to assist in the management of the
					negotiation process.</postamble>
					</figure>

					<section title="CICM::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::Negotiator::get_remote_info()</preamble>
<artwork><![CDATA[CICM::Status get_remote_info(
	out CICM::PeerInfo peer_info
);]]></artwork>
						</figure>
						<figure>
							<preamble>Method CICM::Negotiator::abort_negotiation()</preamble>
							<artwork><![CDATA[CICM::Status abort_negotiation();]]></artwork>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::PeerInfo">
					<figure>
					  <preamble>Interface CICM::PeerInfo</preamble>
					  <artwork><![CDATA[interface PeerInfo {]]></artwork>
					<postamble>Information about a peer entity participating in a key
					negotiation.</postamble>
					</figure>

					<section title="CICM::PeerInfo Attributes">
						<figure>
						  <preamble>Attribute CICM::PeerInfo::peer_name</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString peer_name;]]></artwork>
						<postamble>Name/organization of remote entity participating in key
						agreement prototcol.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::PeerInfo::classification</preamble>
						  <artwork><![CDATA[readonly attribute CICM::Classification classification;]]></artwork>
						<postamble>Highest security classification level at which the remote
						entity participating in the key agreement protocol is capable of
						communicating.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::PeerInfo::compartment</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString compartment;]]></artwork>
						<postamble>Compartment of remote entity participating in key agreement
						protocol.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::PeerInfo::message</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString message;]]></artwork>
						<postamble>Message to be displayed regarding the remote entities'
						participation in key agreement protocol.</postamble>
						</figure>
					</section>
				</section>
			</section>
			<section title="Encryption Channel Management">
				<figure>
				  <preamble>Namespace CICM::Encrypt</preamble>
				  <artwork><![CDATA[module Encrypt {]]></artwork>
				<postamble>The CICM::Encrypt namespace contains interfaces that support
				encryption operations between two independent security domains.</postamble>
				</figure>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 29. Interface Relationship Diagram
				  for Encryption Channels</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 30. Interface Relationship Diagram
				  for Negotiated Encryption Channels</t>

				<section title="Interface CICM::Encrypt::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::Encrypt::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Encrypt::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of encryption
					negotiators, conduits, controllers, and streams. See
					CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::Encrypt::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Encrypt::Negotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will encrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::SymKey mac_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	out CICM::Encrypt::WithMACNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will MAC and encrypt a stream of data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Negotiation applies only to the negotiation key, not the
							MAC key.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] mac_key_ref
								  Reference to MAC key.</t>
							<t>[in] nego_key_ref
								  Reference to negotiation key.</t>
							<t>[in] mac_algorithm
								  MAC algorithm.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_with_sign_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_with_sign_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey sign_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	out CICM::Encrypt::WithSignNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will sign and encrypt a stream of
						data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Negotiation applies only to the negotiation key, not the
							signature key.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] sign_key_ref
								  Reference to signature key.</t>
							<t>[in] nego_key_ref
								  Reference to negotiation key.</t>
							<t>[in] sign_algorithm
								  Signature algorithm.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_controller()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Encrypt::ControllerNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage an encryption channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::create_encrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Encrypt::Conduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to encrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[in] algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::create_encrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encr_algorithm,
	out CICM::Encrypt::WithMACConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to MAC and encrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] mac_key_ref
								  Reference to MAC key.</t>
							<t>[in] encrypt_key_ref
								  Reference to encryption key.</t>
							<t>[in] mac_algorithm
								  MAC algorithm.</t>
							<t>[in] encr_algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::create_encrypt_with_sign_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_with_sign_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::AsymKey sign_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	in  CICM::SymEncrAlgorithmId encr_algorithm,
	out CICM::Encrypt::WithSignConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to sign and encrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] sign_key_ref
								  Reference to signature key.</t>
							<t>[in] encrypt_key_ref
								  Reference to encryption key.</t>
							<t>[in] sign_algorithm
								  Signature algorithm.</t>
							<t>[in] encr_algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::create_key_wrap_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_key_wrap_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey kek_ref,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::Encrypt::KeyWrapConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to wrap a key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This type of conduit may be used to wrap key material bound
							for a peer cryptographic module. To wrap individual keys
							already in the module, use CICM::Symkey::wrap or
							CICM::Asymkey::wrap.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] kek_ref
								  Reference to key encryption key.</t>
							<t>[in] algorithm
								  Key wrapping algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::create_encrypt_controller()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Encrypt::Controller controller_ref
);]]></artwork>
						<postamble>Create controller to configure and control an encryption
						channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[in] algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::get_encrypt_stream()</preamble>
<artwork><![CDATA[CICM::Status get_encrypt_stream(
	in  CICM::LocalPort local_port,
	out CICM::Encrypt::Stream stream_ref
);]]></artwork>
						<postamble>Create stream associated with previously created controller
						to accept data for transformation.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::Stream">
					<figure>
					  <preamble>Interface CICM::Encrypt::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::WriteStream {]]></artwork>
					<postamble>CICM::Encrypt::Stream supports encryption operations between
					two independent security domains. The resulting stream is capable
					of accepting data for transformation, but not managing the channel.
					It is created by calling CICM::ChannelManager::get_encrypt_stream.</postamble>
					</figure>

					<section title="CICM::Encrypt::Stream Inheritance">
						<t>CICM::Encrypt::Stream inherits from: CICM::WriteStream.</t>
					</section>
					<section title="CICM::Encrypt::Stream Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::Stream::encrypt()</preamble>
<artwork><![CDATA[CICM::Status encrypt(
	in  CICM::Buffer buffer
);]]></artwork>
						<postamble>Sends data to the module to be encrypted. The method blocks
						until data is sent.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] buffer
								  Plaintext to encrypt.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::Stream::encrypt_non_blocking()</preamble>
<artwork><![CDATA[CICM::Status encrypt_non_blocking(
	in  CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);]]></artwork>
						<postamble>Registers a buffer of data to be sent to the module for
						encryption and then immediately returns control to the caller. The
						length of the data is encapsulated in the buffer parameter. The
						caller may use the CICM::Encrypt::Stream::encrypt_poll method to
						proactively poll the channel to determine the status of the
						operation. The caller is responsible for maintaining any necessary
						metadata associated with the transaction_id parameter. Memory
						responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] buffer
								  Plaintext to encrypt.</t>
							<t>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::Encrypt::Stream::encrypt_poll method to determine
								  to which buffer the poll status applies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::Stream::encrypt_poll()</preamble>
<artwork><![CDATA[CICM::Status encrypt_poll(
	in  CICM::TransId transaction_id,
	out CICM::WriteStream::WriteStatus status
);]]></artwork>
						<postamble>Returns the status of the non-blocking encryption operation
						specified by the transaction_id parameter. Memory responsibilities
						and calling conventions shall follow the appropriate IDL language
						mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::Encrypt::Stream::encrypt_non_blocking method that
								  allows the poll operation to determine to which buffer
								  the poll status applies.</t>
							<t>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::KeyWrapStream">
					<figure>
					  <preamble>Interface  CICM::Encrypt::KeyWrapStream</preamble>
					  <artwork><![CDATA[interface KeyWrapStream : CICM::Stream {]]></artwork>
					<postamble>CICM::Encrypt::KeyWrapStream is an abstraction that allows
					key material to be presented to a stream for wrapping prior to
					passing into a different security domain.</postamble>
					</figure>

					<section title="CICM::Encrypt::KeyWrapStream Inheritance">
						<t>CICM::Encrypt::KeyWrapStream inherits from: CICM::Stream.</t>
					</section>
					<section title="CICM::Encrypt::KeyWrapStream Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::KeyWrapStream::wrap_key()</preamble>
<artwork><![CDATA[CICM::Status wrap_key(
	in CICM::Key key_ref
);]]></artwork>
						<postamble>Write the key to be wrapped to the channel stream.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The method blocks until the key has been written.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to key to be wrapped.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_CLASSIFICATION, S_KEY_WRAPPED,
							  S_KEY_NOT_WRAPPABLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::Controller">
					<figure>
					  <preamble>Interface CICM::Encrypt::Controller</preamble>
<artwork><![CDATA[interface Controller :
	CICM::MultiDomainController,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::ResyncController {]]></artwork>
					<postamble>CICM::Encrypt::Controller supports encryption operations
					between two independent security domains. The resulting controller
					is capable of managing the channel, but not accepting data for
					transformation. It is created by calling
					CICM::ChannelManager::create_encrypt_controller.</postamble>
					</figure>

					<section title="CICM::Encrypt::Controller Inheritance">
						<t>CICM::Encrypt::Controller inherits from:
						CICM::MultiDomainController, CICM::SymKeyController,
						CICM::GenVectorController and CICM::ResyncController.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::NegotiatedController">
					<figure>
					  <preamble>Interface  CICM::Encrypt::NegotiatedController</preamble>
<artwork><![CDATA[interface NegotiatedController :
	CICM::NegotiatedController,
	CICM::GenVectorController,
	CICM::ResyncController {]]></artwork>
					<postamble>CICM::Encrypt::NegotiatedController is the negotiated version
					of CICM::Encrypt::Controller. It is the result of a successful
					negotiation by CICM::Encrypt::ControllerNegotiator.</postamble>
					</figure>
					<section title="CICM::Encrypt::NegotiatedController Inheritance">
						<t>CICM::Encrypt::NegotiatedController inherits from:
						CICM::NegotiatedController, CICM::GenVectorController and
						CICM::ResyncController.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::Conduit">
					<figure>
					  <preamble>Interface CICM::Encrypt::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Conduit,
	CICM::Encrypt::Controller,
	CICM::Encrypt::Stream {]]></artwork>
					<postamble>CICM::Encrypt::Conduit supports encryption operations between
					two independent security domains. The resulting conduit is capable
					of both managing the channel and accepting data for transformation.
					It is created by calling
					CICM::ChannelManager::create_encrypt_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::Conduit Inheritance">
						<t>CICM::Encrypt::Conduit
						inherits from: CICM::Conduit, CICM::Encrypt::Controller and
						CICM::Encrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::NegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Encrypt::NegotiatedConduit</preamble>
<artwork><![CDATA[interface NegotiatedConduit :
CICM::Conduit,
CICM::Encrypt::NegotiatedController,
CICM::Encrypt::Stream {]]></artwork>
					<postamble>CICM::Encrypt::NegotiatedConduit is the negotiated version of
					CICM::Encrypt::Conduit. It is the result of a successful
					negotiation by CICM::Encrypt::Negotiator.</postamble>
					</figure>
					<section title="CICM::Encrypt::NegotiatedConduit Inheritance">
						<t>CICM::Encrypt::NegotiatedConduit inherits from:
						CICM::Conduit, CICM::Encrypt::NegotiatedController and
						CICM::Encrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithMACConduit">
					<figure>
					  <preamble>Interface CICM::Encrypt::WithMACConduit</preamble>
<artwork><![CDATA[interface WithMACConduit :
CICM::AbstractMACConduit,
CICM::Encrypt::Conduit {]]></artwork>
					<postamble>CICM::Encrypt::WithMACConduit supports encryption operations
					between two independent security domains with the receipt of a MAC
					value in the initiating domain. The resulting conduit is capable of
					both managing the channel and accepting data for transformation. It
					is created by calling
					CICM::ChannelManager::create_encrypt_with_mac_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithMACConduit Inheritance">
						<t>CICM::Encrypt::WithMACConduit inherits from:
						CICM::AbstractMACConduit and CICM::Encrypt::Conduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithMACNegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Encrypt::WithMACNegotiatedConduit</preamble>
<artwork><![CDATA[interface WithMACNegotiatedConduit :
CICM::AbstractMACConduit,
CICM::Encrypt::NegotiatedConduit {]]></artwork>
					<postamble>CICM::Encrypt::WithMACNegotiatedConduit is the negotiated
					version of CICM::Encrypt::WithMACConduit. It is the result of a
					successful negotiation by CICM::Encrypt::WithMACNegotiator.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithMACNegotiatedConduit Inheritance">
						<t>CICM::Encrypt::WithMACNegotiatedConduit inherits
						from: CICM::AbstractMACConduit and
						CICM::Encrypt::NegotiatedConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithSignConduit">
					<figure>
					  <preamble>Interface  CICM::Encrypt::WithSignConduit</preamble>
<artwork><![CDATA[interface WithSignConduit :
CICM::AbstractSignConduit,
CICM::Encrypt::Conduit {]]></artwork>
					<postamble>CICM::Encrypt::WithSignConduit supports encryption operations
					between two independent security domains with the receipt of a
					signature value in the initiating domain. The resulting conduit is
					capable of both managing the channel and accepting data for
					transformation. It is created by calling
					CICM::ChannelManager::create_encrypt_with_sign_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithSignConduit Inheritance">
						<t>CICM::Encrypt::WithSignConduit inherits from:
						CICM::AbstractSignConduit and CICM::Encrypt::Conduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithSignNegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Encrypt::WithSignNegotiatedConduit</preamble>
<artwork><![CDATA[interface WithSignNegotiatedConduit :
CICM::AbstractSignConduit,
CICM::Encrypt::NegotiatedConduit {]]></artwork>
					<postamble>CICM::Encrypt::WithSignNegotiatedConduit is the negotiated
					version of CICM::Encrypt::WithSignConduit. It is the result of a
					successful negotiation by CICM::Encrypt::WithSignNegotiator.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithSignNegotiatedConduit Inheritance">
						<t>CICM::Encrypt::WithSignNegotiatedConduit inherits
						from: CICM::AbstractSignConduit and
						CICM::Encrypt::NegotiatedConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::KeyWrapConduit">
					<figure>
					  <preamble>Interface  CICM::Encrypt::KeyWrapConduit</preamble>
<artwork><![CDATA[interface KeyWrapConduit :
CICM::Encrypt::Controller,
CICM::Encrypt::KeyWrapStream {]]></artwork>
					<postamble>CICM::Encrypt::KeyWrapConduit supports key wrapping
					operations between two independent security domains. The resulting
					conduit is capable of both managing the channel and accepting keys
					for transformation. It is created by calling
					CICM::ChannelManager::create_key_wrap_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::KeyWrapConduit Inheritance">
						<t>CICM::Encrypt::KeyWrapConduit inherits from:
						CICM::Encrypt::Controller and CICM::Encrypt::KeyWrapStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::ControllerNegotiator">
					<figure>
					  <preamble>Interface  CICM::Encrypt::ControllerNegotiator</preamble>
					  <artwork><![CDATA[interface ControllerNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Encrypt::ControllerNegotiator initiates a negotiation
					to establish a shared key with a remote entity that is used to
					support encryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Encrypt::NegotiatedController which is capable of managing
					the channel, but not accepting data for transformation.
					CICM::Encrypt::ControllerNegotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_controller.</postamble>
					</figure>
					<section title="CICM::Encrypt::ControllerNegotiator Inheritance">
						<t>CICM::Encrypt::ControllerNegotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::Encrypt::ControllerNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::ControllerNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Encrypt::NegotiatedController controller_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated negotiated
						encrypt controller.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::Negotiator">
					<figure>
					  <preamble>Interface CICM::Encrypt::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Encrypt::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains. The
					result of a successful negotiation is a
					CICM::Encrypt::NegotiatedConduit which is capable of both managing
					the channel and accepting data for transformation. CICM::Negotiator
					is created by calling
					CICM::Encrypt::ChannelManager::negotiate_encrypt_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::Negotiator Inheritance">
						<t>CICM::Encrypt::Negotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::Encrypt::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::Negotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Encrypt::NegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated encrypt
						conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithMACNegotiator">
					<figure>
					  <preamble>Interface  CICM::Encrypt::WithMACNegotiator</preamble>
					  <artwork><![CDATA[interface WithMACNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Encrypt::WithMACNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains.
					Additionally, a message authentication code is received in the
					initiating domain. The result of a successful negotiation is a
					CICM::Encrypt::WithMACNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Encrypt::WithMACNegotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_with_mac_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithMACNegotiator Inheritance">
						<t>CICM::Encrypt::WithMACNegotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::Encrypt::WithMACNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::WithMACNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Encrypt::WithMACNegotiatedConduit conduit_ref
);]]></artwork>
							<postamble>Complete negotiation and retrieve a negotiated MAC encrypt conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithSignNegotiator">
					<figure>
					  <preamble>Interface  CICM::Encrypt::WithSignNegotiator</preamble>
					  <artwork><![CDATA[interface WithSignNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Encrypt::WithSignNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains.
					Additionally, a signature value is received in the initiating
					domain. The result of a successful negotiation is a
					CICM::Encrypt::WithSignNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Encrypt::WithSignNegotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_with_sign_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithSignNegotiator Inheritance">
						<t>CICM::Encrypt::WithSignNegotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::Encrypt::WithSignNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::WithSignNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Encrypt::WithSignNegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated sign encrypt
						conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Decryption Channel Management">
				<figure>
				  <preamble>Namespace CICM::Decrypt</preamble>
				  <artwork><![CDATA[module Decrypt {]]></artwork>
				<postamble>The CICM::Decrypt namespace contains interfaces that support
				decryption operations between two independent security domains.</postamble>
				</figure>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 31. Interface Relationship Diagram
				  for Decryption Channels</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 32. Interface Relationship Diagram
				  for Negotiated Decryption Channels</t>

				<section title="Interface CICM::Decrypt::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::Decrypt::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Decrypt::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of decryption
					negotiators, conduits, controllers, and streams. See
					CICM::ChannelManager for additional information.</postamble>
					</figure>
					<section title="CICM::Decrypt::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Decrypt::Negotiator negotiator_ref
);]]></artwork>
						<postamble>Creates a negotiator that, upon successful negotiation,
						results in a CICM::Decrypt::NegotiatedConduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::SymKey verify_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::SymMacAlgorithmId verify_algorithm,
	out CICM::Decrypt::WithMACNegotiator negotiator_ref
);]]></artwork>
						<postamble>Creates a negotiator that, upon successful negotiation,
						results in a CICM::Decrypt::MACNegotiatedConduit.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Negotiation applies only to the negotiation key, not the
							MAC key.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] verify_key_ref
								  Reference to verification key.</t>
							<t>[in] nego_key_ref
								  Reference to negotiation key.</t>
							<t>[in] verify_algorithm
								  Verification algorithm.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_with_verify_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_with_verify_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey verify_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	out CICM::Decrypt::WithVerifyNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will decrypt and verify a stream of
						data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Negotiation applies only to the negotiation key, not the
							signature verification key.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] verify_key_ref
								  Reference to verification key.</t>
							<t>[in] nego_key_ref
								  Reference to negotiation key.</t>
							<t>[in] verify_algorithm
								  Verification algorithm.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_controller()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Decrypt::ControllerNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage a decryption channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::create_decrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Decrypt::Conduit conduit_ref
);]]></artwork>
						  <postamble>Create channel to decrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::create_decrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::SymMacAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Decrypt::WithMACConduit conduit_ref
);]]></artwork>
						<postamble>Create channel to MAC verify and decrypt a stream of
						data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] verify_key_ref
								  Reference to verification key.</t>
							<t>[in] decrypt_key_ref
								  Reference to decryption key.</t>
							<t>[in] verify_algorithm
								  Verification algorithm.</t>
							<t>[in] decrypt_algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::create_decrypt_with_verify_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_with_verify_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::AsymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Decrypt::WithVerifyConduit conduit_ref
);]]></artwork>
						  <postamble>Create channel to verify and decrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] verify_key_ref
								  Reference to verification key.</t>
							<t>[in] decrypt_key_ref
								  Reference to decryption key.</t>
							<t>[in] verify_algorithm
								  Verification algorithm.</t>
							<t>[in] decrypt_algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::create_key_unwrap_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_key_unwrap_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey kek_ref,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::Decrypt::KeyUnwrapConduit conduit_ref
);]]></artwork>
						<postamble>Create channel to unwrap a key. This type of channel may be
						used to bulk unwrap key material originating at a key
						infrastructure component or from a peer cryptographic module. Note
						that, to unwrap individual keys already in the module, use
						CICM::Symkey::unwrap or CICM::Asymkey::unwrap.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] kek_ref
								  Reference to key encryption key.</t>
							<t>[in] algorithm
								  Key unwrapping algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::create_decrypt_controller()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Decrypt::Controller controller_ref
);]]></artwork>
						<postamble>Create controller to configure and control an decryption
						channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::get_decrypt_stream()</preamble>
<artwork><![CDATA[CICM::Status get_decrypt_stream(
	in  CICM::LocalPort local_port,
	out CICM::Decrypt::Stream stream_ref
);]]></artwork>
						<postamble>Create stream associated with previously created controller
						to receive transformed data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::Stream">
					<figure>
					  <preamble>Interface CICM::Decrypt::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::ReadStream {]]></artwork>
					<postamble>CICM::Decrypt::Stream supports decryption operations between
					two independent security domains. The resulting stream is capable
					of accepting transformed data, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_decrypt_stream.</postamble>
					</figure>

					<section title="CICM::Decrypt::Stream Inheritance">
						<t>CICM::Decrypt::Stream inherits from: CICM::ReadStream.</t>
					</section>
					<section title="CICM::Decrypt::Stream Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::Stream::decrypt()</preamble>
<artwork><![CDATA[CICM::Status decrypt(
	out CICM::Buffer buffer
);]]></artwork>
						<postamble>Read plaintext data off of decrypt channel stream. The method
						blocks until data becomes available.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] buffer
								  Plaintext resulting from decryption operation.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INTEGRITY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::Stream::decrypt_non_blocking()</preamble>
<artwork><![CDATA[CICM::Status decrypt_non_blocking(
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);]]></artwork>
						<postamble>Registers a buffer into which plaintext resulting from the
						decryption operation will be copied, and then immediately returns
						control to the caller. The size of the allocated buffer and length
						of the resulting plaintext is encapsulated in the buffer parameter.
						The caller may use the CICM::Decrypt::Stream::decrypt_poll method
						to proactively poll the channel to determine the status of the
						operation. The caller is responsible for maintaining any necessary
						metadata associated with the transaction_id parameter. Memory
						responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] buffer
								  Plaintext resulting from decryption operation.</t>
							<t>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::Decrypt::Stream::decrypt_poll method to determine
								  to which buffer the poll status applies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INTEGRITY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::Stream::decrypt_poll()</preamble>
<artwork><![CDATA[CICM::Status decrypt_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);]]></artwork>
						<postamble>Returns the status of the non-blocking decryption operation
						specified by the transaction_id parameter. Upon completion of the
						operation, the caller must use the metadata associated with the
						transaction_id parameter to determine which buffer has been
						populated. Memory responsibilities and calling conventions shall
						follow the appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::Decrypt::Stream::decrypt_non_blocking method that
								  allows the poll operation to determine to which buffer
								  the poll status applies.</t>
							<t>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::KeyUnwrapStream">
					<figure>
					  <preamble>Interface  CICM::Decrypt::KeyUnwrapStream</preamble>
					  <artwork><![CDATA[interface KeyUnwrapStream : CICM::Stream {]]></artwork>
					<postamble>CICM::Decrypt::KeyUnwrapStream is an abstraction that allows
					unwrapped key material received from another domain to be
					retrieved.</postamble>
					</figure>

					<section title="CICM::Decrypt::KeyUnwrapStream Inheritance">
						<t>CICM::Decrypt::KeyUnwrapStream inherits from:
						CICM::Stream.</t>
					</section>
					<section title="CICM::Decrypt::KeyUnwrapStream Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::KeyUnwrapStream::unwrap_sym_key()</preamble>
<artwork><![CDATA[CICM::Status unwrap_sym_key(
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Read one unwrapped symmetric key off of channel stream and
						return a reference to the key. The method blocks until a key
						becomes available.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to key encryption key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::KeyUnwrapStream::unwrap_asym_key()</preamble>
<artwork><![CDATA[CICM::Status unwrap_asym_key(
	out CICM::AsymKey key_ref
);]]></artwork>
						<postamble>Read one unwrapped asymmetric key off of channel stream and
						return a reference to the key. The method blocks until a key
						becomes available.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to key encryption key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::Controller">
					<figure>
					  <preamble>Interface CICM::Decrypt::Controller</preamble>
<artwork><![CDATA[interface Controller :
	CICM::MultiDomainController,
	CICM::SymKeyController,
	CICM::SetVectorController,
	CICM::ResyncController {]]></artwork>
					<postamble>CICM::Decrypt::Controller supports decryption operations
					between two independent security domains. The resulting controller
					is capable of managing the channel, but not accepting transformed
					data. It is created by calling
					CICM::ChannelManager::create_decrypt_controller.</postamble>
					</figure>
					<section title="CICM::Decrypt::Controller Inheritance">
						<t>CICM::Decrypt::Controller inherits from:
						CICM::MultiDomainController, CICM::SymKeyController,
						CICM::SetVectorController and CICM::ResyncController.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::NegotiatedController">
					<figure>
					  <preamble>Interface  CICM::Decrypt::NegotiatedController</preamble>
<artwork><![CDATA[interface NegotiatedController :
	CICM::NegotiatedController,
	CICM::SetVectorController,
	CICM::ResyncController {]]></artwork>
					<postamble>CICM::Decrypt::NegotiatedController is the negotiated version
					of CICM::Decrypt::Controller. It is the result of a successful
					negotiation by CICM::Decrypt::ControllerNegotiator.</postamble>
					</figure>

					<section title="CICM::Decrypt::NegotiatedController Inheritance">
						<t>CICM::Decrypt::NegotiatedController inherits from:
						CICM::NegotiatedController, CICM::SetVectorController and
						CICM::ResyncController.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::Conduit">
					<figure>
					  <preamble>Interface CICM::Decrypt::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Conduit,
	CICM::Decrypt::Controller,
	CICM::Decrypt::Stream {]]></artwork>
					<postamble>CICM::Decrypt::Conduit supports decryption operations between
					two independent security domains. The resulting conduit is capable
					of both managing the channel and accepting transformed data. It is
					created by calling CICM::ChannelManager::create_decrypt_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::Conduit Inheritance">
						<t>CICM::Decrypt::Conduit
						inherits from: CICM::Conduit, CICM::Decrypt::Controller and
						CICM::Decrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::NegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::NegotiatedConduit</preamble>
<artwork><![CDATA[interface NegotiatedConduit :
	CICM::Conduit,
	CICM::Decrypt::NegotiatedController,
	CICM::Decrypt::Stream {]]></artwork>
					<postamble>CICM::Decrypt::NegotiatedConduit is the negotiated version of
					CICM::Decrypt::Conduit. It is the result of a successful
					negotiation by CICM::Decrypt::Negotiator.</postamble>
					</figure>
					<section title="CICM::Decrypt::NegotiatedConduit Inheritance">
						<t>CICM::Decrypt::NegotiatedConduit inherits from:
						CICM::Conduit, CICM::Decrypt::NegotiatedController and
						CICM::Decrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithMACConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithMACConduit</preamble>
<artwork><![CDATA[interface WithMACConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Decrypt::Conduit {]]></artwork>
					<postamble>CICM::Decrypt::WithMACConduit supports decryption operations
					between two independent security domains with the receipt of an
					indication as to whether MAC verification succeeded or failed in
					the initiating domain. The resulting conduit is capable of both
					managing the channel and accepting data for transformation. It is
					created by calling
					CICM::ChannelManager::create_decrypt_with_mac_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithMACConduit Inheritance">
						<t>CICM::Decrypt::WithMACConduit inherits from:
						CICM::AbstractMACVerifyConduit and CICM::Decrypt::Conduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithMACNegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithMACNegotiatedConduit</preamble>
<artwork><![CDATA[interface WithMACNegotiatedConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Decrypt::NegotiatedConduit {]]></artwork>
					<postamble>CICM::Decrypt::WithMACNegotiatedConduit is the negotiated
					version of CICM::Decrypt::WithMACConduit. It is the result of a
					successful negotiation by CICM::Decrypt::WithMACNegotiator.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithMACNegotiatedConduit Inheritance">
						<t>CICM::Decrypt::WithMACNegotiatedConduit inherits
						from: CICM::AbstractMACVerifyConduit and
						CICM::Decrypt::NegotiatedConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithVerifyConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithVerifyConduit</preamble>
<artwork><![CDATA[interface WithVerifyConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Decrypt::Conduit {]]></artwork>
					<postamble>CICM::Decrypt::WithVerifyConduit supports decryption
					operations between two independent security domains with the
					receipt of an indication as to whether signature verification
					succeeded or failed in the initiating domain. The resulting conduit
					is capable of both managing the channel and accepting transformed
					data. It is created by calling
					CICM::ChannelManager::create_decrypt_with_verify_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithVerifyConduit Inheritance">
						<t>CICM::Decrypt::WithVerifyConduit inherits from:
						CICM::AbstractSigVerifyConduit and CICM::Decrypt::Conduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithVerifyNegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithVerifyNegotiatedConduit</preamble>
<artwork><![CDATA[interface WithVerifyNegotiatedConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Decrypt::NegotiatedConduit {]]></artwork>
					<postamble>CICM::Decrypt::WithVerifyNegotiatedConduit is the negotiated
					version of CICM::Decrypt::WithVerifyConduit. It is the result of a
					successful negotiation by CICM::Decrypt::WithVerifyNegotiator.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithVerifyNegotiatedConduit Inheritance">
						<t>CICM::Decrypt::WithVerifyNegotiatedConduit inherits
						from: CICM::AbstractSigVerifyConduit and
						CICM::Decrypt::NegotiatedConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::KeyUnwrapConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::KeyUnwrapConduit</preamble>
<artwork><![CDATA[interface KeyUnwrapConduit :
	CICM::Decrypt::Controller,
	CICM::Decrypt::KeyUnwrapStream {]]></artwork>
					<postamble>CICM::Decrypt::KeyUnwrapConduit supports key unwrapping
					operations between two independent security domains. The resulting
					conduit is capable of both managing the channel and accepting
					transformed keys. It is created by calling
					CICM::ChannelManager::create_key_unwrap_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::KeyUnwrapConduit Inheritance">
						<t>CICM::Decrypt::KeyUnwrapConduit inherits from:
						CICM::Decrypt::Controller and CICM::Decrypt::KeyUnwrapStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::Negotiator">
					<figure>
					  <preamble>Interface CICM::Decrypt::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Decrypt::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains. The
					result of a successful negotiation is a
					CICM::Decrypt::NegotiatedConduit which is capable of both managing
					the channel and accepting data for transformation.
					CICM::Decrypt::Negotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_conduit.</postamble>
					</figure>

					<section title="CICM::Decrypt::Negotiator Inheritance">
						<t>CICM::Decrypt::Negotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Decrypt::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::Negotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Decrypt::NegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated decrypt
						conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::ControllerNegotiator">
					<figure>
					  <preamble>Interface  CICM::Decrypt::ControllerNegotiator</preamble>
					  <artwork><![CDATA[interface ControllerNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Decrypt::ControllerNegotiator initiates a negotiation
					to establish a shared key with a remote entity that is used to
					support decryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Decrypt::NegotiatedController which is capable of managing
					the channel, but not accepting data for transformation.
					CICM::Decrypt::ControllerNegotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_controller.</postamble>
					</figure>
					<section title="CICM::Decrypt::ControllerNegotiator Inheritance">
						<t>CICM::Decrypt::ControllerNegotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Decrypt::ControllerNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::ControllerNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Decrypt::NegotiatedController controller_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated control-only
						decrypt channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithMACNegotiator">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithMACNegotiator</preamble>
					  <artwork><![CDATA[interface WithMACNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Decrypt::WithMACNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					decryption operations between two independent security domains.
					Additionally, a message authentication code is received in the
					initiating domain. The result of a successful negotiation is a
					CICM::Decrypt::WithMACNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Decrypt::WithMACNegotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_with_mac_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithMACNegotiator Inheritance">
						<t>CICM::Decrypt::WithMACNegotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Decrypt::WithMACNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::WithMACNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Decrypt::WithMACNegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated MAC verify
						decrypt conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithVerifyNegotiator">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithVerifyNegotiator</preamble>
					  <artwork><![CDATA[interface WithVerifyNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Decrypt::WithVerifyNegotiator initiates a negotiation
					to establish a shared key with a remote entity that is used to
					support decryption operations between two independent security
					domains. Additionally, an indication as to whether verification
					succeeded or failed is received in the initiating domain. The
					result of a successful negotiation is a
					CICM::Decrypt::WithVerifyNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Decrypt::WithVerifyNegotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_with_verify_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithVerifyNegotiator Inheritance">
						<t>CICM::Decrypt::WithVerifyNegotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Decrypt::WithVerifyNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::WithVerifyNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Decrypt::WithVerifyNegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated verify and
						decrypt conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Duplex Channel Management">
				<figure>
				  <preamble>Namespace CICM::Duplex</preamble>
				  <artwork><![CDATA[module Duplex {]]></artwork>
				<postamble>The CICM::Duplex namespace contains interfaces that support
				encryption/decryption operations between two independent security
				domains.</postamble>
				</figure>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 33. Interface Relationship Diagram
				  for Duplex Channels</t>

				<section title="Interface CICM::Duplex::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::Duplex::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Duplex::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of
					encryption/decryption negotiators, conduits, controllers, and
					streams. See CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::Duplex::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Duplex::ChannelManager::negotiate_duplex_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_duplex_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Duplex::Negotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a conduit that results will encrypt/decrypt data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Duplex::ChannelManager::negotiate_duplex_controller()</preamble>
<artwork><![CDATA[CICM::Status negotiate_duplex_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Duplex::ControllerNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage a duplex channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Duplex::ChannelManager::create_duplex_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_duplex_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Duplex::Conduit conduit_ref
);]]></artwork>
						<postamble>Create duplex channel to encrypt/decrypt a stream of
						data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Encryption/decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Duplex::ChannelManager::create_duplex_controller()</preamble>
<artwork><![CDATA[CICM::Status create_duplex_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Duplex::Controller controller_ref
);]]></artwork>
						<postamble>Create controller to configure and control a duplex
						channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[in] algorithm
								  Encryption/decryption algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Duplex::ChannelManager::get_duplex_stream()</preamble>
<artwork><![CDATA[CICM::Status get_duplex_stream(
	in  CICM::LocalPort local_port,
	out CICM::Duplex::Stream stream_ref
);]]></artwork>
						<postamble>Create stream associated with previously created controller
						to accept data for transformation.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::Stream">
					<figure>
					  <preamble>Interface CICM::Duplex::Stream</preamble>
<artwork><![CDATA[interface Stream :
	CICM::Encrypt::Stream,
	CICM::Decrypt::Stream {]]></artwork>
					<postamble>CICM::Duplex::Stream supports encryption/decryption
					operations between two independent security domains. The resulting
					stream is capable of accepting data for transformation and
					receiving transformed data, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_duplex_stream.</postamble>
					</figure>
					<section title="CICM::Duplex::Stream Inheritance">
						<t>CICM::Duplex::Stream
						inherits from: CICM::Encrypt::Stream and
						CICM::Decrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::Controller">
					<figure>
					  <preamble>Interface CICM::Duplex::Controller</preamble>
<artwork><![CDATA[interface Controller :
	CICM::Encrypt::Controller,
	CICM::Decrypt::Controller {]]></artwork>
					<postamble>CICM::Duplex::Controller supports encryption/decryption
					operations between two independent security domains. The resulting
					controller is capable of managing the channel, but not accepting
					data for transformation and receiving transformed data. It is
					created by calling CICM::ChannelManager::create_duplex_controller.</postamble>
					</figure>
					<section title="CICM::Duplex::Controller Inheritance">
						<t>CICM::Duplex::Controller inherits from:
						CICM::Encrypt::Controller and CICM::Decrypt::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::NegotiatedController">
					<figure>
					  <preamble>Interface  CICM::Duplex::NegotiatedController</preamble>
<artwork><![CDATA[interface NegotiatedController :
	CICM::Encrypt::NegotiatedController,
	CICM::Decrypt::NegotiatedController {]]></artwork>
					<postamble>CICM::Duplex::NegotiatedController is the negotiated version
					of CICM::Duplex::Controller. It is the result of a successful
					negotiation by CICM::Duplex::ControllerNegotiator.</postamble>
					</figure>
					<section title="CICM::Duplex::NegotiatedController Inheritance">
						<t>CICM::Duplex::NegotiatedController inherits from:
						CICM::Encrypt::NegotiatedController and
						CICM::Decrypt::NegotiatedController.</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::Conduit">
					<figure>
					  <preamble>Interface CICM::Duplex::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Conduit,
	CICM::Duplex::Controller,
	CICM::Duplex::Stream {]]></artwork>
					<postamble>CICM::Duplex::Conduit supports encryption/decryption
					operations between two independent security domains. The resulting
					conduit is capable of both managing the channel and accepting data
					for transformation and receiving transformed data. It is created by
					calling CICM::ChannelManager::create_duplex_conduit.</postamble>
					</figure>
					<section title="CICM::Duplex::Conduit Inheritance">
						<t>CICM::Duplex::Conduit
						inherits from: CICM::Conduit, CICM::Duplex::Controller and
						CICM::Duplex::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::NegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Duplex::NegotiatedConduit</preamble>
<artwork><![CDATA[interface NegotiatedConduit :
	CICM::Duplex::NegotiatedController,
	CICM::Duplex::Stream {]]></artwork>
					<postamble>CICM::Duplex::NegotiatedConduit is the negotiated version of
					CICM::Duplex::Conduit. It is the result of a successful negotiation
					by CICM::Duplex::Negotiator.</postamble>
					</figure>
					<section title="CICM::Duplex::NegotiatedConduit Inheritance">
						<t>CICM::Duplex::NegotiatedConduit inherits from:
						CICM::Duplex::NegotiatedController and CICM::Duplex::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::ControllerNegotiator">
					<figure>
					  <preamble>Interface  CICM::Duplex::ControllerNegotiator</preamble>
					  <artwork><![CDATA[interface ControllerNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Duplex::ControllerNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption/decryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Duplex::NegotiatedController which is capable of managing the
					channel, but not accepting data for transformation.
					CICM::Duplex::ControllerNegotiator is created by calling
					CICM::ChannelManager::negotiate_duplex_controller.</postamble>
					</figure>
					<section title="CICM::Duplex::ControllerNegotiator Inheritance">
						<t>CICM::Duplex::ControllerNegotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Duplex::ControllerNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Duplex::ControllerNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Duplex::NegotiatedController controller_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated control-only
						duplex conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::Negotiator">
					<figure>
					  <preamble>Interface CICM::Duplex::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Duplex::Negotiator initiates a negotiation to establish
					a shared key with a remote entity that is used to support
					encryption/decryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Duplex::NegotiatedConduit which is capable of both managing
					the channel and accepting data for transformation.
					CICM::Duplex::Negotiator is created by calling
					CICM::ChannelManager::negotiate_duplex_conduit.</postamble>
					</figure>
					<section title="CICM::Duplex::Negotiator Inheritance">
						<t>CICM::Duplex::Negotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Duplex::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::Duplex::Negotiator::complete()</preamble>
<artwork><![CDATA[ CICM::Status complete(
	out CICM::Duplex::NegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated duplex
						channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting channel.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Bypass (Send) Channel Managment">
				<figure>
				  <preamble>Namespace CICM::BypassWrite</preamble>
				  <artwork><![CDATA[module BypassWrite {]]></artwork>
				<postamble>The CICM::BypassWrite namespace contains channels that
				support full bypass write operations between two independent
				security domains.</postamble>
				</figure>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 34. Interface Relationship Diagram
				  for Sending Bypass Data</t>

				<section title="Interface CICM::BypassWrite::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::BypassWrite::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::BypassWrite::ChannelManager is an abstraction inherited
					by CICM::ChannelManager that supports the creation of full bypass
					conduits, controllers, and streams for writing. See
					CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::BypassWrite::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::BypassWrite::ChannelManager::create_bypass_write_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_bypass_write_conduit(
	in  CICM::RemotePort remote_port,
	out CICM::BypassWrite::Conduit conduit_ref
);]]></artwork>
						<postamble>Creates a conduit to write bypass data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassWrite::ChannelManager::create_bypass_write_controller()</preamble>
<artwork><![CDATA[CICM::Status create_bypass_write_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	out CICM::BypassWrite::Controller controller_ref
);]]></artwork>
						<postamble>Returns the controller of a channel that writes bypass
						data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>See also:
							<list>
								<t>CICM::BypassWrite::ChannelManager::get_bypass_write_stream
								for the method that returns the channel stream.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassWrite::ChannelManager::get_bypass_write_stream()</preamble>
<artwork><![CDATA[CICM::Status get_bypass_write_stream(
	in  CICM::LocalPort local_port,
	out CICM::BypassWrite::Stream stream_ref
);]]></artwork>
						<postamble>Returns the stream corresponding to a pre-existing controller
						on the given local port.</postamble>
						</figure>
						<t>See also:
							<list>
								<t>CICM::BypassWrite::ChannelManager::create_bypass_write_controller
								for the method that returns the channel controller.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::BypassWrite::Stream">
					<figure>
					  <preamble>Interface CICM::BypassWrite::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::WriteStream {]]></artwork>
					<postamble>CICM::BypassWrite::Stream supports full bypass between two
					independent security domains. The resulting stream is capable of
					accepting data for bypass, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_bypass_write_stream.</postamble>
					</figure>

					<section title="CICM::BypassWrite::Stream Inheritance">
						<t>CICM::BypassWrite::Stream inherits from: CICM::WriteStream.</t>
					</section>
					<section title="CICM::BypassWrite::Stream Methods">
						<figure>
						  <preamble>Method CICM::BypassWrite::Stream::write_bypass()</preamble>
<artwork><![CDATA[CICM::Status write_bypass(
	in  CICM::Buffer buffer
);]]></artwork>
						<postamble>Write bypass data to a channel stream. The method blocks
						until the data has been sent.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] buffer
								  Data to bypass.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN,
							  S_BYPASS_DATARATE_EXCEEDED,
							  S_BYPASS_DATALIMIT_EXCEEDED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassWrite::Stream::write_bypass_non_blocking()</preamble>
<artwork><![CDATA[CICM::Status write_bypass_non_blocking(
	in  CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);]]></artwork>
						<postamble>Registers a buffer of data to be sent to the module for
						bypass and then immediately returns control to the caller. The
						length of the data is encapsulated in the buffer parameter. The
						caller may use the CICM::BypassWrite::Stream::write_bypass_poll
						method to proactively poll the channel to determine the status of
						the operation. The caller is responsible for maintaining any
						necessary metadata associated with the transaction_id parameter.
						Memory responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] buffer
								  Data to bypass.</t>
							<t>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::BypassWrite::Stream::write_bypass_poll method to
								  determine to which buffer the poll status applies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN,
							  S_BYPASS_DATARATE_EXCEEDED,
							  S_BYPASS_DATALIMIT_EXCEEDED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassWrite::Stream::write_bypass_poll()</preamble>
<artwork><![CDATA[CICM::Status write_bypass_poll(
	in  CICM::TransId transaction_id,
	out CICM::WriteStream::WriteStatus status
);]]></artwork>
						<postamble>Returns the status of the non-blocking bypass operation
						specified by the transaction_id parameter. Memory responsibilities
						and calling conventions shall follow the appropriate IDL language
						mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::BypassWrite::Stream::write_bypass_non_blocking
								  method that allows the poll operation to determine to
								  which buffer the poll status applies.</t>
							<t>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::BypassWrite::Controller">
					<figure>
					  <preamble>Interface  CICM::BypassWrite::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::MultiDomainController {};]]></artwork>
					<postamble>CICM::BypassWrite::Controller supports full bypass between
					two independent security domains. The resulting controller is
					capable of managing the channel, but not accepting data for bypass.
					It is created by calling
					CICM::ChannelManager::create_bypass_write_controller.</postamble>
					</figure>
					<section title="CICM::BypassWrite::Controller Inheritance">
						<t>CICM::BypassWrite::Controller inherits from: CICM::MultiDomainController.</t>
					</section>
				</section>
				<section title="Interface CICM::BypassWrite::Conduit">
					<figure>
					  <preamble>Interface CICM::BypassWrite::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Conduit,
	CICM::BypassWrite::Controller,
	CICM::BypassWrite::Stream {]]></artwork>
					<postamble>CICM::BypassWrite::Conduit supports full bypass between two
					security domains. The resulting conduit is capable of both managing
					the channel and accepting data for bypass. It is created by calling
					CICM::ChannelManager::create_bypass_write_conduit.</postamble>
					</figure>
					<section title="CICM::BypassWrite::Conduit Inheritance">
						<t>CICM::BypassWrite::Conduit inherits from:
						CICM::Conduit, CICM::BypassWrite::Controller and
						CICM::BypassWrite::Stream.</t>
					</section>
				</section>
			</section>
			<section title="Bypass (Read) Channel Management">
				<figure>
				  <preamble>Namespace CICM::BypassRead</preamble>
				  <artwork><![CDATA[module BypassRead {]]></artwork>
				<postamble>The CICM::BypassRead namespace contains channels that support
				full bypass read operations between two independent security
				domains.</postamble>
				</figure>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 35. Interface Relationship Diagram for Receiving Bypass Data</t>

				<section title="Interface CICM::BypassRead::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::BypassRead::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::BypassRead::ChannelManager is an abstraction inherited
					by CICM::ChannelManager that supports the creation of full bypass
					conduits, controllers, and streams for reading. See
					CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::BypassRead::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::BypassRead::ChannelManager::create_bypass_read_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_bypass_read_conduit(
	in  CICM::RemotePort remote_port,
	out CICM::BypassRead::Conduit conduit_ref
);]]></artwork>
						<postamble>Creates a conduit to read bypass data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassRead::ChannelManager::create_bypass_read_controller()</preamble>
<artwork><![CDATA[CICM::Status create_bypass_read_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	out CICM::BypassRead::Controller controller_ref
);]]></artwork>
						<postamble>Returns the controller of a channel that reads bypass data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::BypassRead::ChannelManager::get_bypass_read_stream
							for the method that returns the channel stream.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassRead::ChannelManager::get_bypass_read_stream()</preamble>
<artwork><![CDATA[CICM::Status get_bypass_read_stream(
	in  CICM::LocalPort local_port,
	out CICM::BypassRead::Stream stream_ref
);]]></artwork>
						<postamble>Returns the stream corresponding to a pre-existing controller
						on the given local port.</postamble>
						</figure>
						<t>See also:
							<list>
							<t>CICM::BypassRead::ChannelManager::get_bypass_read_controller
							for the method that returns the channel controller.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::BypassRead::Stream">
					<figure>
					  <preamble>Interface CICM::BypassRead::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::ReadStream {]]></artwork>
					<postamble>CICM::BypassRead::Stream supports full bypass between two
					independent security domains. The resulting stream is capable of
					accepting bypassed data, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_bypass_read_stream.</postamble>
					</figure>

					<section title="CICM::BypassRead::Stream Inheritance">
						<t>CICM::BypassRead::Stream inherits from: CICM::ReadStream.</t>
					</section>
					<section title="CICM::BypassRead::Stream Methods">
						<figure>
						  <preamble>Method CICM::BypassRead::Stream::read_bypass()</preamble>
<artwork><![CDATA[CICM::Status read_bypass(
	out CICM::Buffer buffer
);]]></artwork>
						<postamble>Read bypass data off of channel stream. The method blocks
						until data becomes available.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] buffer
								  Bypassed data read from module.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassRead::Stream::read_bypass_non_blocking()</preamble>
<artwork><![CDATA[CICM::Status read_bypass_non_blocking(
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);]]></artwork>
						<postamble>Registers a buffer into which bypass data will be copied, and
						then immediately returns control to the caller. The size of the
						allocated buffer and length of the resulting bypassed data is
						encapsulated in the buffer parameter. The caller may use the
						CICM::BypassRead::Stream::read_bypass_poll method to proactively
						poll the channel to determine the status of the operation. The
						caller is responsible for maintaining any necessary metadata
						associated with the transaction_id parameter. Memory
						responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] buffer
								  Bypassed data to read.</t>
							<t>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::BypassRead::Stream::read_bypass_poll method to
								  determine to which buffer the poll status applies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassRead::Stream::read_bypass_poll()</preamble>
<artwork><![CDATA[CICM::Status read_bypass_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);]]></artwork>
						<postamble>Returns the status of the non-blocking bypass operation
						specified by the transaction_id parameter. Upon completion of the
						operation, the caller must use the metadata associated with the
						transaction_id parameter to determine which buffer has been
						populated. Memory responsibilities and calling conventions shall
						follow the appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::BypassRead::Stream::read_bypass_non_blocking method
								  that allows the poll operation to determine to which
								  buffer the poll status applies.</t>
							<t>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::BypassRead::Controller">
					<figure>
					  <preamble>Interface  CICM::BypassRead::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::MultiDomainController {};]]></artwork>
					<postamble>CICM::BypassRead::Controller supports full bypass between two
					independent security domains. The resulting controller is capable
					of managing the channel, but not accepting bypassed data. It is
					created by calling
					CICM::ChannelManager::create_bypass_read_controller.</postamble>
					</figure>

					<section title="CICM::BypassRead::Controller Inheritance">
						<t>CICM::BypassRead::Controller inherits from: CICM::MultiDomainController.</t>
					</section>
				</section>
				<section title="Interface CICM::BypassRead::Conduit">
					<figure>
					  <preamble>Interface CICM::BypassRead::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Conduit,
	CICM::BypassRead::Controller,
	CICM::BypassRead::Stream {]]></artwork>
					<postamble>CICM::BypassRead::Conduit supports full bypass between two
					independent security domains. The resulting conduit is capable of
					both managing the channel and accepting bypassed data. It is
					created by calling
					CICM::ChannelManager::create_bypass_read_conduit.</postamble>
					</figure>

					<section title="CICM::BypassRead::Conduit Inheritance">
						<t>CICM::BypassRead::Conduit inherits from:
						CICM::Conduit, CICM::BypassRead::Controller and
						CICM::BypassRead::Stream.</t>
					</section>
				</section>
			</section>
			<section title="Encryption with Selective Bypass Channel Management">
				<figure>
				  <preamble>Namespace CICM::EncryptBypass</preamble>
				  <artwork><![CDATA[module EncryptBypass {]]></artwork>
				<postamble>The CICM::EncryptBypass namespace contains interfaces that
				support encryption with selective bypass operations between two
				indepenent security domains.</postamble>
				</figure>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 36. Interface Relationship Diagram
				  for Encryption Channels with Selective Bypass</t>

				<section title="Interface CICM::EncryptBypass::ChannelManager">
					<figure>
					  <preamble>Interface CICM::EncryptBypass::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::EncryptBypass::ChannelManager is an abstraction
					inherited by CICM::ChannelManager that supports the creation of
					encryption with selective bypass negotiators, conduits,
					controllers, and streams. See CICM::ChannelManager for additional
					information.</postamble>
					</figure>
					<t>Remarks:
						<list>
					  <t>Note that if a system is using selective bypass channels to
					  perform header bypass, policy may govern that a system performs
					  the bypass function before the encryption function and performs
					  the bypass function only once.</t>
					</list></t>

					<section title="CICM::EncryptBypass::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::EncryptBypass::ChannelManager::negotiate_encrypt_bypass_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::EncryptBypass::Negotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will selectively encrypt or bypass a
						stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::EncryptBypass::ChannelManager::negotiate_encrypt_bypass_controller()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::EncryptBypass::ControllerNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage an encrypt with bypass
						channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Remote port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::EncryptBypass::ChannelManager::create_encrypt_bypass_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::EncryptBypass::Conduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to selectively encrypt or bypass a stream of  data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[in] algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::EncryptBypass::ChannelManager::create_encrypt_bypass_controller()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::EncryptBypass::Controller controller_ref
);]]></artwork>
						<postamble>Create controller to configure and control an encrypt with
						bypass channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[in] algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::EncryptBypass::ChannelManager::get_encrypt_bypass_stream()</preamble>
<artwork><![CDATA[CICM::Status get_encrypt_bypass_stream(
	in  CICM::LocalPort local_port,
	out CICM::EncryptBypass::Stream stream_ref
);]]></artwork>
						<postamble>Create stream associated with previously created controller
						to accept data for transformation.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::Stream">
					<figure>
					  <preamble>Interface CICM::EncryptBypass::Stream</preamble>
<artwork><![CDATA[interface Stream :
	CICM::Encrypt::Stream,
	CICM::BypassWrite::Stream {]]></artwork>
					<postamble>CICM::EncryptBypass::Stream supports encryption and selective
					bypass operations between two independent security domains. The
					resulting stream is capable of accepting data for transformation,
					but not managing the channel. It is created by calling
					CICM::ChannelManager::get_encrypt_bypass_stream.</postamble>
					</figure>

					<section title="CICM::EncryptBypass::Stream Inheritance">
						<t>CICM::EncryptBypass::Stream inherits from:
						CICM::Encrypt::Stream and CICM::BypassWrite::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::NegotiatedController">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::NegotiatedController</preamble>
					  <artwork><![CDATA[interface NegotiatedController : CICM::Encrypt::NegotiatedController {};]]></artwork>
					<postamble>CICM::EncryptBypass::NegotiatedController is the negotiated
					version of CICM::EncryptBypass::Controller. It is the result of a
					successful negotiation by
					CICM::EncryptBypass::ControllerNegotiator.</postamble>
					</figure>

					<section title="CICM::EncryptBypass::NegotiatedController Inheritance">
						<t>CICM::EncryptBypass::NegotiatedController inherits
						from: CICM::Encrypt::NegotiatedController.</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::Controller">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::Encrypt::Controller {};]]></artwork>
					<postamble>CICM::EncryptBypass::Controller supports encryption and
					selective bypass operations between two independent security
					domains. The resulting controller is capable of managing the
					channel, but not accepting data for transformation/bypass. It is
					created by calling
					CICM::ChannelManager::create_encrypt_bypass_controller.</postamble>
					</figure>
					<section title="CICM::EncryptBypass::Controller Inheritance">
						<t>CICM::EncryptBypass::Controller inherits from:
						CICM::Encrypt::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::Conduit">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Encrypt::Conduit,
	CICM::EncryptBypass::Stream {]]></artwork>
					<postamble>CICM::EncryptBypass::Conduit supports encryption and
					selective bypass operations between two independent security
					domains. The resulting conduit is capable of both managing the
					channel and accepting data for transformation/bypass. It is created
					by calling CICM::ChannelManager::create_encrypt_bypass_conduit.</postamble>
					</figure>

					<section title="CICM::EncryptBypass::Conduit Inheritance">
						<t>CICM::EncryptBypass::Conduit inherits from:
						CICM::Encrypt::Conduit and CICM::EncryptBypass::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::NegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::NegotiatedConduit</preamble>
<artwork><![CDATA[interface NegotiatedConduit :
	CICM::Encrypt::NegotiatedController,
	CICM::EncryptBypass::Stream {]]></artwork>
					<postamble>CICM::EncryptBypass::NegotiatedConduit is the negotiated
					version of CICM::EncryptBypass::Conduit. It is the result of a
					successful negotiation by CICM::EncryptBypass::Negotiator.</postamble>
					</figure>

					<section title="CICM::EncryptBypass::NegotiatedConduit Inheritance">
						<t>CICM::EncryptBypass::NegotiatedConduit inherits
						from: CICM::Encrypt::NegotiatedController and
						CICM::EncryptBypass::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::ControllerNegotiator">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::ControllerNegotiator</preamble>
					  <artwork><![CDATA[interface ControllerNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::EncryptBypass::ControllerNegotiator initiates a
					negotiation to establish a shared key with a remote entity that is
					used to support encryption and selective bypass operations between
					two independent security domains. The result of a successful
					negotiation is a CICM::EncryptBypass::NegotiatedController which is
					capable of managing the channel, but not accepting data for
					transformation/bypass. CICM::EncryptBypass::ControllerNegotiator is
					created by calling
					CICM::ChannelManager::negotiate_encrypt_bypass_controller.</postamble>
					</figure>

					<section title="CICM::EncryptBypass::ControllerNegotiator Inheritance">
						<t>CICM::EncryptBypass::ControllerNegotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::EncryptBypass::ControllerNegotiator Methods">
						<figure>
						  <preamble>Method CICM::EncryptBypass::ControllerNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::EncryptBypass::NegotiatedController controller_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated encrypt bypass
						control-only channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::Negotiator">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::EncryptBypass::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption and bypass operations between two independent security
					domains. Additionally, selective bypass is supported on the same
					conduit. The result of a successful negotiation is a
					CICM::EncryptBypass::NegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation/bypass.
					CICM::EncryptBypass::Negotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_bypass_conduit.</postamble>
					</figure>
					<section title="CICM::EncryptBypass::Negotiator Inheritance">
						<t>CICM::EncryptBypass::Negotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::EncryptBypass::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::EncryptBypass::Negotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::EncryptBypass::NegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated encrypt bypass
						conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
  							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Decryption with Selective Bypass Channel Management">
				<figure>
				  <preamble>Namespace CICM::DecryptBypass</preamble>
				  <artwork><![CDATA[module DecryptBypass {]]></artwork>
				<postamble>The CICM::DecryptBypass namespace contains interfaces that
				support decryption with selective bypass operations between two
				independent security domains.</postamble>
				</figure>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 37. Interface Relationship Diagram
				  for Decryption Channels with Selective Bypass</t>

				<section title="Interface CICM::DecryptBypass::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::DecryptBypass::ChannelManager is an abstraction
					inherited by CICM::ChannelManager that supports the creation of
					decryption with selective bypass negotiators, conduits,
					controllers, and streams. See CICM::ChannelManager for additional
					information.</postamble>
					</figure>
					<t>Remarks:
						<list>
						  <t>CICM does not specify the structure of the data that is read
						  from a selective bypass channel which may contain special
						  formatting to indicate which subset of the data was bypassed. The
						  Implementation Conformance Statement (see Section 4, Conformance
						  and Extensions) must reference a standard format or define a
						  module developer-specific format implemented by the module for
						  data read from selective bypass channels.</t>
						</list>
					</t>

					<section title="CICM::DecryptBypass::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::DecryptBypass::ChannelManager::negotiate_decrypt_bypass_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::DecryptBypass::Negotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will selectively decrypt or bypass a
						stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::DecryptBypass::ChannelManager::negotiate_decrypt_bypass_controller()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::DecryptBypass::ControllerNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage a decrypt with bypass
						channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::DecryptBypass::ChannelManager::create_decrypt_bypass_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::DecryptBypass::Conduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to selectively decrypt or bypass a stream of data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Both decrypted and bypassed data are read from the same
							stream using the appropriate decrypt() call; the entity reading
							from this stream must distinguish between decrypted and
							bypassed data, if necessary.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::DecryptBypass::ChannelManager::create_decrypt_bypass_controller()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::DecryptBypass::Controller controller_ref
);]]></artwork>
						<postamble>Create controller to configure and control a decrypt with
						bypass channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::DecryptBypass::ChannelManager::get_decrypt_bypass_stream()</preamble>
<artwork><![CDATA[CICM::Status get_decrypt_bypass_stream(
	in  CICM::LocalPort local_port,
	out CICM::DecryptBypass::Stream stream_ref
);]]></artwork>
						<postamble>Create stream associated with previously created controller
						to receive transformed data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Both decrypted and bypassed data are read from the same
							stream using the appropriate decrypt() call; the entity reading
							from this stream must distinguish between decrypted and
							bypassed data, if necessary.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::Stream">
					<figure>
					  <preamble>Interface CICM::DecryptBypass::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::Decrypt::Stream {};]]></artwork>
					<postamble>CICM::DecryptBypass::Stream supports decryption and selective
					bypass operations between two independent security domains. The
					resulting stream is capable of accepting transformed/bypassed data,
					but not managing the channel. It is created by calling
					CICM::ChannelManager::get_decrypt_bypass_stream.</postamble>
					</figure>
					<t>Remarks:
						<list>
						  <t>CICM does not specify the structure of the data that is read
						  from a selective bypass channel which may contain special
						  formatting to indicate which subset of the data was bypassed. The
						  Implementation Conformance Statement (see Section 4, Conformance
						  and Extensions) must reference a standard format or define a
						  module developer-specific format implemented by the module for
						  data read from selective bypass channels.</t>
						</list>
					</t>

					<section title="CICM::DecryptBypass::Stream Inheritance">
						<t>CICM::DecryptBypass::Stream inherits from:
						CICM::Decrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::Controller">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::Decrypt::Controller {]]></artwork>
					<postamble>CICM::DecryptBypass::Controller supports decryption and
					selective bypass operations between two independent security
					domains. The resulting controller is capable of managing the
					channel, but not accepting transformed/bypassed data. It is created
					by calling CICM::ChannelManager::create_decrypt_bypass_controller.</postamble>
					</figure>
					<section title="CICM::DecryptBypass::Controller Inheritance">
						<t>CICM::DecryptBypass::Controller inherits from:
						CICM::Decrypt::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::NegotiatedController">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::NegotiatedController</preamble>
					  <artwork><![CDATA[interface NegotiatedController : CICM::Decrypt::NegotiatedController {]]></artwork>
					<postamble>CICM::DecryptBypass::NegotiatedController is the negotiated
					version of CICM::DecryptBypass::Controller. It is the result of a
					successful negotiation by
					CICM::DecryptBypass::ControllerNegotiator.</postamble>
					</figure>

					<section title="CICM::DecryptBypass::NegotiatedController Inheritance">
						<t>CICM::DecryptBypass::NegotiatedController inherits from: CICM::Decrypt::NegotiatedController.</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::Conduit">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Decrypt::Conduit,
	CICM::DecryptBypass::Controller,
	CICM::DecryptBypass::Stream {]]></artwork>
					<postamble>CICM::DecryptBypass::Conduit supports decryption and
					selective bypass operations between two independent security
					domains. The resulting conduit is capable of both managing the
					channel and accepting transformed/bypassed data. It is created by
					calling CICM::ChannelManager::create_decrypt_bypass_conduit.</postamble>
					</figure>

					<section title="CICM::DecryptBypass::Conduit Inheritance">
						<t>CICM::DecryptBypass::Conduit inherits from:
						CICM::Decrypt::Conduit, CICM::DecryptBypass::Controller and
						CICM::DecryptBypass::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::NegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::NegotiatedConduit</preamble>
<artwork><![CDATA[interface NegotiatedConduit :
	CICM::Decrypt::NegotiatedConduit,
	CICM::DecryptBypass::NegotiatedController,
	CICM::DecryptBypass::Stream {]]></artwork>
					<postamble>CICM::DecryptBypass::NegotiatedConduit is the negotiated
					version of CICM::DecryptBypass::Conduit. It is the result of a
					successful negotiation by CICM::DecryptBypass::Negotiator.</postamble>
					</figure>

					<section title="CICM::DecryptBypass::NegotiatedConduit Inheritance">
						<t>CICM::DecryptBypass::NegotiatedConduit inherits
						from: CICM::Decrypt::NegotiatedConduit,
						CICM::DecryptBypass::NegotiatedController and
						CICM::DecryptBypass::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::ControllerNegotiator">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::ControllerNegotiator</preamble>
					  <artwork><![CDATA[interface ControllerNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::DecryptBypass::ControllerNegotiator initiates a
					negotiation to establish a shared key with a remote entity that is
					used to support encryption and selective bypass operations between
					two independent security domains. The result of a successful
					negotiation is a CICM::DecryptBypass::NegotiatedController which is
					capable of managing the channel, but not accepting data for
					transformation. CICM::DecryptBypass::ControllerNegotiator is
					created by calling
					CICM::ChannelManager::negotiate_decrypt_bypass_controller.</postamble>
					</figure>

					<section title="CICM::DecryptBypass::ControllerNegotiator Inheritance">
						<t>CICM::DecryptBypass::ControllerNegotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::DecryptBypass::ControllerNegotiator Methods">
						<figure>
						  <preamble>Method CICM::DecryptBypass::ControllerNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::DecryptBypass::NegotiatedController controller_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated control-only
						decrypt bypass channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::Negotiator">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::DecryptBypass::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains.
					Additionally, selective bypass is supported on the same conduit.
					The result of a successful negotiation is a
					CICM::DecryptBypass::NegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::DecryptBypass::Negotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_bypass_conduit.</postamble>
					</figure>

					<section title="CICM::DecryptBypass::Negotiator Inheritance">
						<t>CICM::DecryptBypass::Negotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::DecryptBypass::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::DecryptBypass::Negotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::DecryptBypass::NegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated decrypt bypass
						conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Random, Pseudorandom and Keystream Channel Management">
				<figure>
				  <preamble>Namespace CICM::Emit</preamble>
				  <artwork><![CDATA[module Emit {]]></artwork>
				<postamble>The CICM::Emit namespace contains interfaces that generate
				data originating in a cryptographic module such as random,
				pseudorandom, and keystream data.</postamble>
				</figure>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 38. Interface Relationship Diagram for Keystream Generation and Random Channels</t>

				<section title="Interface CICM::Emit::ChannelManager">
					<figure>
					  <preamble>Interface CICM::Emit::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Emit::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of conduits and
					controllers to generate keystream, pseudorandom, and random data.
					See CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::Emit::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_key_stream_gen_controller()</preamble>
<artwork><![CDATA[CICM::Status create_key_stream_gen_controller(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Emit::KeyStreamGenController controller_ref
);]]></artwork>
						<postamble>Create controller to generate keystream.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to keystream generation key.</t>
							<t>[in] algorithm
								  Keystream generation algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_pseudorandom_controller()</preamble>
<artwork><![CDATA[CICM::Status create_pseudorandom_controller(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey seed,
	out CICM::Emit::PseudoRandomController controller_ref
);]]></artwork>
						  <postamble>Create controller to generate pseudorandom data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] seed
								  Seed material for pseudorandom generator.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX,
							  S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_random_controller()</preamble>
<artwork><![CDATA[CICM::Status create_random_controller(
	in  CICM::RemotePort remote_port,
	out CICM::Emit::RandomController controller_ref
);]]></artwork>
						  <postamble>Create controller to generate random data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_key_stream_gen_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_key_stream_gen_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Emit::KeyStreamGenConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to generate keystream.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to keystream generation key.</t>
							<t>[in] algorithm
								  Keystream generation algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_pseudorandom_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_pseudorandom_conduit(
	in  CICM::SymKey seed,
	out CICM::Emit::PseudoRandomConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to generate pseudorandom data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] seed
								  Seed material for pseudorandom generator.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX,
							  S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_random_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_random_conduit(
	out CICM::Emit::RandomConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to generate random data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX,
							  S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::GetStream">
					<figure>
					  <preamble>Interface CICM::Emit::GetStream</preamble>
					  <artwork><![CDATA[interface GetStream : CICM::ReadStream {]]></artwork>
					<postamble>CICM::Emit::GetStream is an abstraction inherited by conduits
					in the CICM::Emit namespace that allows data to be read from the
					stream.</postamble>
					</figure>

					<section title="CICM::Emit::GetStream Inheritance">
						<t>CICM::Emit::GetStream inherits from: CICM::ReadStream.</t>
					</section>

					<section title="CICM::Emit::GetStream Methods">
						<figure>
						  <preamble>Method CICM::Emit::GetStream::get()</preamble>
<artwork><![CDATA[CICM::Status get(
	in  CICM::UInt32 length,
	out CICM::Buffer buffer
);]]></artwork>
						<postamble>Reads a buffer of data from the module. The method blocks
						until data becomes available.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] length
								  Number of bytes to retrieve.</t>
							<t>[out] buffer
								  Buffer of data read from stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::GetStream::get_non_blocking()</preamble>
<artwork><![CDATA[CICM::Status get_non_blocking(
	in  CICM::UInt32 length,
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);]]></artwork>
						<postamble>Registers a buffer into which transformed data will be
						copied, and then control immediately returns to the caller. The
						size of the allocated buffer and length of the resulting
						transformed data is encapsulated in the buffer parameter. The
						caller may use the CICM::Emit::GetStream::get_poll method to
						proactively poll the channel to determine the status of the
						operation. The caller is responsible for maintaining any necessary
						metadata associated with the transaction_id parameter. Memory
						responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] length
								  Number of bytes to retrieve.</t>
							<t>[out] buffer
								  Transformed data.</t>
							<t>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::Emit::GetStream::get_poll method to determine to
								  which buffer the poll status applies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::GetStream::get_poll()</preamble>
<artwork><![CDATA[CICM::Status get_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);]]></artwork>
						<postamble>Returns the status of the non-blocking get operation
						specified by the transaction_id parameter. Upon completion of the
						operation, the caller must use the metadata associated with the
						transaction_id parameter to determine which buffer has been
						populated. Memory responsibilities and calling conventions shall
						follow the appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::Emit::GetStream::get_non_blocking method that
								  allows the poll operation to determine to which buffer
								  the poll status applies.</t>
							<t>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::Controller">
					<figure>
					  <preamble>Interface CICM::Emit::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::Controller {]]></artwork>
					<postamble>CICM::Emit::Controller is an abstraction from which all other
					controllers in the CICM::Emit namespace inherit.</postamble>
					</figure>

					<section title="CICM::Emit::Controller Inheritance">
						<t>CICM::Emit::Controller inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::Emit::Controller Attributes">
						<figure>
						  <preamble>AttributeCICM::Emit::Controller::remote_port</preamble>
						  <artwork><![CDATA[readonly attribute CICM::RemotePort remote_port;]]></artwork>
						<postamble>The remote port associated with this controller.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::Emit::RandomController">
					<figure>
					  <preamble>Interface  CICM::Emit::RandomController</preamble>
					  <artwork><![CDATA[interface RandomController : CICM::Emit::Controller {};]]></artwork>
					<postamble>CICM::Emit::RandomController supports creating a channel to
					read random data from a module. The resulting controller is capable
					of managing the channel, but not reading random data. It is created
					by calling CICM::ChannelManager::create_random_controller.</postamble>
					</figure>
					<section title="CICM::Emit::RandomController Inheritance">
						<t>CICM::Emit::RandomController inherits from: CICM::Emit::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::RandomConduit">
					<figure>
					  <preamble>Interface CICM::Emit::RandomConduit</preamble>
<artwork><![CDATA[interface RandomConduit :
	CICM::Conduit,
	CICM::Emit::GetStream {]]></artwork>
					<postamble>CICM::Emit::RandomConduit supports reading random data from a
					module. The resulting conduit is capable of both managing the
					channel and reading random data. It is created by calling
					CICM::ChannelManager::create_random_conduit.</postamble>
					</figure>

					<section title="CICM::Emit::RandomConduit Inheritance">
						<t>CICM::Emit::RandomConduit inherits from:
						CICM::Conduit and CICM::Emit::GetStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::PseudoRandomController">
					<figure>
					  <preamble>Interface  CICM::Emit::PseudoRandomController</preamble>
<artwork><![CDATA[interface PseudoRandomController :
	CICM::SymKeyController,
	CICM::Emit::Controller {]]></artwork>
					<postamble>CICM::Emit::PseudoRandomController supports creating a
					channel to read pseudorandom data from a module. The resulting
					controller is capable of managing the channel, but not reading
					pseudorandom data. It is created by calling
					CICM::ChannelManager::create_pseudorandom_controller.</postamble>
					</figure>

					<section title="CICM::Emit::PseudoRandomController Inheritance">
						<t>CICM::Emit::PseudoRandomController inherits from:
						CICM::SymKeyController and CICM::Emit::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::PseudoRandomConduit">
					<figure>
					  <preamble>Interface  CICM::Emit::PseudoRandomConduit</preamble>
<artwork><![CDATA[interface PseudoRandomConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::Emit::GetStream {]]></artwork>
					<postamble>CICM::Emit::PseudoRandomConduit supports reading pseudorandom
					data from a module. The resulting conduit is capable of both
					managing the channel and reading pseudorandom data. It is created
					by calling CICM::ChannelManager::create_pseudorandom_conduit.</postamble>
					</figure>
					<section title="CICM::Emit::PseudoRandomConduit Inheritance">
						<t>CICM::Emit::PseudoRandomConduit inherits from:
						CICM::Conduit, CICM::SymKeyController and
						CICM::Emit::GetStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::KeyStreamGenController">
					<figure>
					  <preamble>Interface  CICM::Emit::KeyStreamGenController</preamble>
<artwork><![CDATA[interface KeyStreamGenController :
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::Emit::Controller {]]></artwork>
					<postamble>CICM::Emit::KeyStreamGenController supports creating a
					channel to read keystream from a module. The resulting controller
					is capable of managing the channel, but not reading keystream. It
					is created by calling
					CICM::ChannelManager::create_key_stream_gen_controller.</postamble>
					</figure>

					<section title="CICM::Emit::KeyStreamGenController Inheritance">
						<t>CICM::Emit::KeyStreamGenController inherits from:
						CICM::SymKeyController, CICM::GenVectorController and
						CICM::Emit::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::KeyStreamGenConduit">
					<figure>
					  <preamble>Interface  CICM::Emit::KeyStreamGenConduit</preamble>
<artwork><![CDATA[interface KeyStreamGenConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::Emit::GetStream {]]></artwork>
					<postamble>CICM::Emit::KeyStreamGenConduit supports reading keystream
					from a module. The resulting conduit is capable of both managing
					the channel and reading keystream. It is created by calling
					CICM::ChannelManager::create_key_stream_gen_conduit.</postamble>
					</figure>

					<section title="CICM::Emit::KeyStreamGenConduit Inheritance">
						<t>CICM::Emit::KeyStreamGenConduit inherits from:
						CICM::Conduit, CICM::SymKeyController, CICM::GenVectorController
						and CICM::Emit::GetStream.</t>
					</section>
				</section>
			</section>
			<section title="Integrity Channel Management">
				<figure>
				  <preamble>Namespace CICM::Answer</preamble>
				  <artwork><![CDATA[module Answer {]]></artwork>
				<postamble>The CICM::Answer namespace contains interfaces that support
				cryptographic operations that return an "answer" such a hash or a
				signature within a single security domain.</postamble>
				</figure>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 39. Interface Relationship Diagram for Channels that Return an "Answer"</t>

				<section title="Interface CICM::Answer::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::Answer::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Answer::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of conduits to
					sign, MAC, and hash data. See CICM::ChannelManager for additional
					information.</postamble>
					</figure>

					<section title="CICM::Answer::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_hash_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_hash_conduit(
	in  CICM::HashAlgorithmId algorithm,
	out CICM::Answer::HashConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to calculate and generate a hash value.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] algorithm
								  Hash algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_mac_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymMacAlgorithmId algorithm,
	out CICM::Answer::MACConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to calculate and generate a MAC.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to MAC key.</t>
							<t>[in] algorithm
								  MAC algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_mac_verify_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_mac_verify_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymMacAlgorithmId algorithm,
	out CICM::Answer::MACVerifyConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to verify a MAC.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to verification key.</t>
							<t>[in] algorithm
								  MAC algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_sign_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_sign_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::SignConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to calculate and generate a signature.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to signature key.</t>
							<t>[in] algorithm
								  Signature algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_sign_hash_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_sign_hash_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::SignHashConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to calculate and generate a signature
						accepting a previously generated hash value as input.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to signature key.</t>
							<t>[in] algorithm
								  Signature algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_verify_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_verify_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::VerifyConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to verify a signature.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to verification key.</t>
							<t>[in] algorithm
								  Verification algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_verify_hash_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_verify_hash_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::VerifyHashConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to verify a signature accepting a previously
						generated hash value as input.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to verification key.</t>
							<t>[in] algorithm
								  Verification algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::PutStream">
					<figure>
					  <preamble>Interface CICM::Answer::PutStream</preamble>
					  <artwork><![CDATA[interface PutStream : CICM::Stream {]]></artwork>
					<postamble>A stream that can write data to a module.</postamble>
					</figure>

					<section title="CICM::Answer::PutStream Inheritance">
						<t>CICM::Answer::PutStream inherits from: CICM::Stream.</t>
					</section>
					<section title="CICM::Answer::PutStream Methods">
						<figure>
						  <preamble>Method CICM::Answer::PutStream::put()</preamble>
<artwork><![CDATA[CICM::Status put(
	in  CICM::Buffer buffer
);]]></artwork>
						<postamble>Sends data to the module for transformation.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This method blocks until the data is sent to the
							module.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] buffer
								  Buffer to write to the module.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::HashConduit">
					<figure>
					  <preamble>Interface CICM::Answer::HashConduit</preamble>
<artwork><![CDATA[interface HashConduit :
	CICM::Conduit,
	CICM::Answer::PutStream {]]></artwork>
					<postamble>CICM::Answer::HashConduit supports hashing operations within
					a single security domain. It is created by calling
					CICM::ChannelManager::create_hash_conduit.</postamble>
					</figure>
					<t>Remarks:
						<list>
							<t>Keyed hashes are supported by MAC channels.</t>
						</list>
					</t>

					<section title="CICM::Answer::HashConduit Inheritance">
						<t>CICM::Answer::HashConduit inherits from:
						CICM::Conduit and CICM::Answer::PutStream.</t>
					</section>
					<section title="CICM::Answer::HashConduit Attributes">
						<figure>
						  <preamble>AttributeCICM::Answer::HashConduit::algorithm</preamble>
						  <artwork><![CDATA[readonly attribute CICM::HashAlgorithmId algorithm;]]></artwork>
						<postamble>Algorithm used to compute the hash.</postamble>
						</figure>
					</section>
					<section title="CICM::Answer::HashConduit Methods">
						<figure>
						  <preamble>Method CICM::Answer::HashConduit::end_get_hash()</preamble>
<artwork><![CDATA[CICM::Status end_get_hash(
	out HashBuffer hash
);]]></artwork>
						<postamble>Direct the module to compute and output the message digest
						value, and reset the conduit to accept additional data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] hash
								  Resulting hash.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::MACConduit">
					<figure>
					  <preamble>Interface CICM::Answer::MACConduit</preamble>
<artwork><![CDATA[interface MACConduit :
	CICM::AbstractMACConduit,
	CICM::Answer::PutStream {]]></artwork>
					<postamble>CICM::Answer::MACConduit supports message authentication code
					operations within a single security domain. It is created by
					calling CICM::ChannelManager::create_mac_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::MACConduit Inheritance">
						<t>CICM::Answer::MACConduit inherits from:
						CICM::AbstractMACConduit and CICM::Answer::PutStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::MACVerifyConduit">
					<figure>
					  <preamble>Interface  CICM::Answer::MACVerifyConduit</preamble>
<artwork><![CDATA[interface MACVerifyConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Answer::PutStream {]]></artwork>
					<postamble>CICM::Answer::MACVerifyConduit supports message
					authentication code verification operations within a single
					security domain. It is created by calling
					CICM::ChannelManager::create_mac_verify_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::MACVerifyConduit Inheritance">
						<t>CICM::Answer::MACVerifyConduit inherits from:
						CICM::AbstractMACVerifyConduit and CICM::Answer::PutStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::SignConduit">
					<figure>
					  <preamble>Interface CICM::Answer::SignConduit</preamble>
<artwork><![CDATA[interface SignConduit :
	CICM::AbstractSignConduit,
	CICM::Answer::PutStream {]]></artwork>
					<postamble>CICM::Answer::SignConduit supports signature operations
					within a single security domain. It is created by calling
					CICM::ChannelManager::create_sign_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::SignConduit Inheritance">
						<t>CICM::Answer::SignConduit inherits from:
						CICM::AbstractSignConduit and CICM::Answer::PutStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::SignHashConduit">
					<figure>
					  <preamble>Interface  CICM::Answer::SignHashConduit</preamble>
					  <artwork><![CDATA[interface SignHashConduit : CICM::Answer::SignConduit {};]]></artwork>
					<postamble>CICM::Answer::SignHashConduit supports signature operations
					accepting a pre-generated hash value within a single security
					domain. It is created by calling
					CICM::ChannelManager::create_sign_hash_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::SignHashConduit Inheritance">
						<t>CICM::Answer::SignHashConduit inherits from:
						CICM::Answer::SignConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::VerifyConduit">
					<figure>
					  <preamble>Interface CICM::Answer::VerifyConduit</preamble>
<artwork><![CDATA[interface VerifyConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Answer::PutStream {]]></artwork>
					<postamble>CICM::Answer::VerifyConduit supports verification operations
					within a single security domain. It is created by calling
					CICM::ChannelManager::create_verify_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::VerifyConduit Inheritance">
						<t>CICM::Answer::VerifyConduit inherits from:
						CICM::AbstractSigVerifyConduit and CICM::Answer::PutStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::VerifyHashConduit">
					<figure>
					  <preamble>Interface  CICM::Answer::VerifyHashConduit</preamble>
					  <artwork><![CDATA[interface VerifyHashConduit : CICM::Answer::VerifyConduit {};]]></artwork>
					<postamble>CICM::Answer::VerifyHashConduit supports verification
					operations accepting a pre-generated hash value within a single
					security domain. It is created by calling
					CICM::ChannelManager::create_verify_hash_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::VerifyHashConduit Inheritance">
						<t>CICM::Answer::VerifyHashConduit inherits from:
						CICM::Answer::VerifyConduit.</t>
					</section>
				</section>
			</section>
			<section title="Single-Domain Channel Management">
				<figure>
				  <preamble>Namespace CICM::Coprocessor</preamble>
				  <artwork><![CDATA[module Coprocessor {]]></artwork>
				<postamble>The CICM::Coprocessor namespace contains interfaces that
				support encryption/decryption operations within a single security
				domain.</postamble>
				</figure>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 40. Interface Relationship Diagram
				  for Single-Domain Encryption Channels</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 41. Interface Relationship Diagram
				  for Single-Domain Decryption Channels</t>

				<section title="Interface CICM::Coprocessor::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Coprocessor::ChannelManager is an abstraction inherited
					by CICM::ChannelManager that supports the creation of conduits to
					encrypt and decrypt data within a single security domain. See
					CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::Coprocessor::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_encrypt_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Coprocessor::EncryptConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to encrypt a stream of data within a single
						security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[in] algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_encrypt_with_mac_conduit(
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::EncryptWithMACConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to MAC and encrypt a stream of data within a
						single security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] mac_key_ref
								  Reference to MAC key.</t>
							<t>[in] encrypt_key_ref
								  Reference to encryption key.</t>
							<t>[in] mac_algorithm
								  MAC algorithm.</t>
							<t>[in] encrypt_algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_with_sign_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_encrypt_with_sign_conduit(
	in  CICM::AsymKey sign_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::EncryptWithSignConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to sign and encrypt a stream of data within a
						single security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] sign_key_ref
								  Reference to signature key.</t>
							<t>[in] encrypt_key_ref
								  Reference to encryption key.</t>
							<t>[in] sign_algorithm
								  Signature algorithm.</t>
							<t>[in] encrypt_algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_decrypt_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Coprocessor::DecryptConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to decrypt a stream of data within a single
						security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_decrypt_with_mac_conduit(
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::DecryptWithMACConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to MAC verify and decrypt a stream of data
						within a single security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] mac_key_ref
								  Reference to MAC key.</t>
							<t>[in] decrypt_key_ref
								  Reference to decryption key.</t>
							<t>[in] mac_algorithm
								  MAC algorithm.</t>
							<t>[in] encrypt_algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_with_verify_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_decrypt_with_verify_conduit(
	in  CICM::AsymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Coprocessor::DecryptWithVerifyConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to verify and decrypt a stream of data within
						a single security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] verify_key_ref
								  Reference to verification key.</t>
							<t>[in] decrypt_key_ref
								  Reference to decryption key.</t>
							<t>[in] verify_algorithm
								  Verification algorithm.</t>
							<t>[in] decrypt_algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::Stream">
					<figure>
					  <preamble>Interface CICM::Coprocessor::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::Stream {]]></artwork>
					<postamble>CICM::Coprocessor::Stream is an abstraction inherited by all
					conduits in the CICM::Coprocessor namespace.</postamble>
					</figure>

					<section title="CICM::Coprocessor::Stream Inheritance">
						<t>CICM::Coprocessor::Stream inherits from: CICM::Stream.</t>
					</section>
					<section title="CICM::Coprocessor::Stream Methods">
						<figure>
						  <preamble>Method CICM::Coprocessor::Stream::get_final_buffer()</preamble>
<artwork><![CDATA[CICM::Status get_final_buffer(
	out CICM::Buffer buffer
);]]></artwork>
						<postamble>Returns the final block of transformed data, if available.
						The method blocks until data becomes available.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In certain cases, it may be necessary to retrieve the last
							transformed block of data, if, for example, a partial block
							remains after the last full block was retrieved. This call
							MUST be called after all data is supplied to the module
							and MUST precede any end_get_* calls.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] buffer
								  Buffer of data read from stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::EncryptConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::EncryptConduit</preamble>
<artwork><![CDATA[interface EncryptConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::ResyncController,
	CICM::Coprocessor::Stream {]]></artwork>
					<postamble>CICM::Coprocessor::EncryptConduit supports encryption
					operations within a single security domain. The resulting conduit
					is capable of managing the channel, accepting data for
					transformation, and receiving the result. It is created by calling
					CICM::ChannelManager::create_coprocessor_encrypt_conduit.</postamble>
					</figure>
					<section title="CICM::Coprocessor::EncryptConduit Inheritance">
						<t>CICM::Coprocessor::EncryptConduit inherits from:
						CICM::Conduit, CICM::SymKeyController, CICM::GenVectorController,
						CICM::ResyncController and CICM::Coprocessor::Stream.</t>
					</section>
					<section title="CICM::Coprocessor::EncryptConduit Methods">
						<figure>
						  <preamble>Method CICM::Coprocessor::EncryptConduit::encrypt()</preamble>
<artwork><![CDATA[CICM::Status encrypt(
	in  CICM::Buffer plaintext,
	out CICM::Buffer ciphertext
);]]></artwork>
						<postamble>Send plaintext to the module to be encrypted, receiving the
						ciphertext resulting from the transformation as the result.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] plaintext
								  Plaintext to encrypt.</t>
							<t>[out] ciphertext
								  Ciphertext resulting from encryption operation.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN, S_CHANNEL_BUFFER_LEN</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::EncryptWithMACConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::EncryptWithMACConduit</preamble>
<artwork><![CDATA[interface EncryptWithMACConduit :
	CICM::AbstractMACConduit,
	CICM::Coprocessor::EncryptConduit {]]></artwork>
					<postamble>CICM::Coprocessor::EncryptWithMACConduit supports encryption
					with MAC operations within a single security domain. The resulting
					conduit is capable of managing the channel, accepting data for
					transformation, and receiving the result (both ciphertext and a MAC
					value). It is created by calling
					CICM::ChannelManager::create_coprocessor_encrypt_with_mac_conduit.</postamble>
					</figure>

					<section title="CICM::Coprocessor::EncryptWithMACConduit Inheritance">
						<t>CICM::Coprocessor::EncryptWithMACConduit inherits
						from: CICM::AbstractMACConduit and
						CICM::Coprocessor::EncryptConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::EncryptWithSignConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::EncryptWithSignConduit</preamble>
<artwork><![CDATA[interface EncryptWithSignConduit :
	CICM::AbstractSignConduit,
	CICM::Coprocessor::EncryptConduit {]]></artwork>
					<postamble>CICM::Coprocessor::EncryptWithSignConduit supports encryption
					with signature operations within a single security domain. The
					resulting conduit is capable of managing the channel, accepting
					data for transformation, and receiving the result (both ciphertext
					and a signature). It is created by calling
					CICM::ChannelManager::create_coprocessor_encrypt_with_sign_conduit.</postamble>
					</figure>

					<section title="CICM::Coprocessor::EncryptWithSignConduit Inheritance">
						<t>CICM::Coprocessor::EncryptWithSignConduit inherits
						from: CICM::AbstractSignConduit and
						CICM::Coprocessor::EncryptConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::DecryptConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::DecryptConduit</preamble>
<artwork><![CDATA[interface DecryptConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::SetVectorController,
	CICM::ResyncController,
	CICM::Coprocessor::Stream {]]></artwork>
					<postamble>CICM::Coprocessor::DecryptConduit supports decryption
					operations within a single security domain. The resulting conduit
					is capable of managing the channel, accepting data for
					transformation, and receiving the result. It is created by calling
					CICM::ChannelManager::create_coprocessor_decrypt_conduit.</postamble>
					</figure>

					<section title="CICM::Coprocessor::DecryptConduit Inheritance">
						<t>CICM::Coprocessor::DecryptConduit inherits from:
						CICM::Conduit, CICM::SymKeyController, CICM::SetVectorController,
						CICM::ResyncController and CICM::Coprocessor::Stream.</t>
					</section>
					<section title="CICM::Coprocessor::DecryptConduit Methods">
						<figure>
						  <preamble>Method CICM::Coprocessor::DecryptConduit::decrypt()</preamble>
<artwork><![CDATA[CICM::Status decrypt(
	in  CICM::Buffer ciphertext,
	out CICM::Buffer plaintext
);]]></artwork>
						<postamble>Send ciphertext to the module to be decrypted, receiving the
						plaintext resulting from the transformation as the result.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] ciphertext
								  Ciphertext to decrypt.</t>
							<t>[out] plaintext
								  Plaintext resulting from decryption operation.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN, S_CHANNEL_BUFFER_LEN</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::DecryptWithMACConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::DecryptWithMACConduit</preamble>
<artwork><![CDATA[interface DecryptWithMACConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Coprocessor::DecryptConduit {]]></artwork>
					<postamble>CICM::Coprocessor::DecryptWithMACConduit supports encryption
					with MAC verification operations within a single security domain.
					The resulting conduit is capable of managing the channel, accepting
					data for transformation, and receiving the result (both plaintext
					and an indication as to whether verification succeeded or failed).
					It is created by calling
					CICM::ChannelManager::create_coprocessor_decrypt_with_mac_conduit.</postamble>
					</figure>

					<section title="CICM::Coprocessor::DecryptWithMACConduit Inheritance">
						<t>CICM::Coprocessor::DecryptWithMACConduit inherits
						from: CICM::AbstractMACVerifyConduit and
						CICM::Coprocessor::DecryptConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::DecryptWithVerifyConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::DecryptWithVerifyConduit</preamble>
<artwork><![CDATA[interface DecryptWithVerifyConduit :
CICM::AbstractSigVerifyConduit,
CICM::Coprocessor::DecryptConduit {]]></artwork>
					<postamble>CICM::Coprocessor::DecryptWithVerifyConduit supports
					encryption with signature verification operations within a single
					security domain. The resulting conduit is capable of managing the
					channel, accepting data for transformation, and receiving the
					result (both plaintext and an indication as to whether verification
					succeeded or failed). It is created by calling
					CICM::ChannelManager::create_coprocessor_decrypt_with_verify_conduit.</postamble>
					</figure>

					<section title="CICM::Coprocessor::DecryptWithVerifyConduit Inheritance">
						<t>CICM::Coprocessor::DecryptWithVerifyConduit
						inherits from: CICM::AbstractSigVerifyConduit and
						CICM::Coprocessor::DecryptConduit.</t>
					</section>
				</section>
			</section>
			<section title="Channel Event Management">
				<section title="Interface CICM::ChannelEventManager">
					<figure>
					  <preamble>Interface CICM::ChannelEventManager</preamble>
					  <artwork><![CDATA[interface ChannelEventManager {]]></artwork>
					<postamble>CICM::ChannelEventManager supports registering and
					unregistering user-defined channel event listeners
					(CICM::ChannelEventListener) for specific channel events. It is
					accessed from any channel via its CICM::Channel::event_manager
					attribute.</postamble>
					</figure>
					<t>Remarks:
						<list>
						<t>In certain cases it may be necessary for a channel to
						asynchronously notify a client program of an event. Client
						programs can register to receive channel notifications using
						CICM::ChannelEventManager. This manager enables a client
						program to register a listener (callback) method designed to
						handle a specific condition. The event method prototype
						provided by the client program is defined in
						CICM::ChannelEventListener. CICM::ChannelEventListener also
						defines the conditions that may result in a notification,
						including: channel failure or channel destruction.</t>
						</list>
					</t>
					<t>{FIGURE REMOVED}</t>
					<t>Figure 42. Interface Relationship Diagram for ChannelEventManager</t>

					<section title="CICM::ChannelEventManager Methods">
						<figure>
						  <preamble>Method CICM::ChannelEventManager::register()</preamble>
<artwork><![CDATA[CICM::Status register(
	in  CICM::ChannelEventListener::ChannelEvent event,
	in  CICM::ChannelEventListener listener
);]]></artwork>
						<postamble>Registers the listener for a specific channel event.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The provided listener applies only to the client program
							from which the registration is initiated.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] event
								  Event for which this listener is being
								  registered.</t>
							<t>[in] listener
								  Listener that will receive a notification about the
								  specified event.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_HOST_RESOURCES,
							  S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE,
							  S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_EVENT_REGISTERED, S_EVENT_NOT_SUPPORTED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::ChannelEventManager::unregister()</preamble>
<artwork><![CDATA[CICM::Status unregister(
	in  CICM::ChannelEventListener::ChannelEvent event
);]]></artwork>
						<postamble>Unregisters the listener associated with the specified
						event.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The listener associated with the specified event is only
							unregistered from the client program from which this method is
							called.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] event
								  Event that will no longer have a listener associated
								  with it.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_HOST_RESOURCES,
							  S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE,
							  S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_EVENT_NOT_REGISTERED</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::ChannelEventListener">
					<figure>
					  <preamble>Interface CICM::ChannelEventListener</preamble>
					  <artwork><![CDATA[interface ChannelEventListener {]]></artwork>
					<postamble>CICM::ChannelEventListener is unlike other CICM interfaces in
					that the interface is implemented by the developer of the client
					program to service a specific channel event and is then registered
					via the CICM::ChannelEventManager.</postamble>
					</figure>

					<section title="CICM::ChannelEventListener Types and Constants">
						<figure>
						  <preamble>Type CICM::ChannelEventListener::ChannelEvent</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 ChannelEvent;]]></artwork>
						<postamble>Events for which a ChannelEventListener can be notified.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ChannelEventListener::C_CHANNEL_DATA_AVAILABLE</preamble>
<artwork><![CDATA[const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_DATA_AVAILABLE = 0x00004001;]]></artwork>
							<postamble>Data from remote peer is available.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ChannelEventListener::C_CHANNEL_ERROR</preamble>
<artwork><![CDATA[const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_ERROR = 0x00004002;]]></artwork>
							<postamble>General error has occurred on the channel.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ChannelEventListener::C_CHANNEL_INSUFFICIENT_ENTROPY</preamble>
<artwork><![CDATA[const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_INSUFFICIENT_ENTROPY = 0x00004004;]]></artwork>
							<postamble>Insufficient entropy available on the channel.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ChannelEventListener::C_CHANNEL_LOST_SYNC</preamble>
<artwork><![CDATA[const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_LOST_SYNC = 0x00004007;]]></artwork>
						  <postamble>Cryptographic synchronization with remote peer has been
						  lost; this may not be detectable by the cryptographic
						  module.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ChannelEventListener::C_CHANNEL_PEER_RESET</preamble>
<artwork><![CDATA[const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_PEER_RESET = 0x00004008;]]></artwork>
						  <postamble>Remote peer is no longer available; this may not be
						  detectable by the cryptographic module.</postamble>
						</figure>
					</section>
					<section title="CICM::ChannelEventListener Methods">
						<figure>
						  <preamble>Method CICM::ChannelEventListener::event_occurred()</preamble>
<artwork><![CDATA[ void event_occurred(
	in  CICM::ChannelEventListener::ChannelEvent event,
	in  CICM::Buffer event_data
);]]></artwork>
						<postamble>Method implemented by client program that receives a message
						about a channel event that occurred. An opaque data field with
						additional information about the event in a module-specific format
						may optionally be provided with the event itself.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The format of the event data value is not defined by CICM.
							The Implementation Conformance Statement (see Section 4,
							Conformance and Extensions) must reference a standard format or
							define a module-specific format for this datatype.</t>
							</list>
						</t><t>Note:
							<list>
							<t>Because this method is called by the runtime system and not
							a client program, it does not return a status value.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] event
								  Event that occurred.</t>
							<t>[in] event_data
								  Opaque data associated with the event.</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Channel Groups">
				<section title="Interface CICM::ControllerGroup">
					<figure>
					  <preamble>Interface CICM::ControllerGroup</preamble>
					  <artwork><![CDATA[interface ControllerGroup {]]></artwork>
					<postamble>Group of controllers and/or conduits.</postamble>
					</figure>
					<t>Remarks:
						<list>
						  <t>All of the controllers in a controller group share certain
						  characteristics, such as a state vector. Whenever a shared
						  characteristic is changed on a member of the group, the change is
						  applied to all members of the group. Thus, if a client program
						  has grouped controllers/conduits to follow advancing TOD rules,
						  for example, when one controller/conduit performs an operation at
						  time X as expressed in the TOD value, all other grouped
						  controllers/conduits are prohibited from using a TOD value
						  earlier than time X.</t>
						</list>
					</t>
					<section title="CICM::ControllerGroup Methods">
						<figure>
						  <preamble>Method CICM::ControllerGroup::add()</preamble>
<artwork><![CDATA[CICM::Status add(
	in CICM::Controller controller_ref
);]]></artwork>
						  <postamble>Add a controller or conduit to this controller group.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] controller_ref
								  Controller to add to the group.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_IN_GROUP,
							  S_CHANNEL_CLASSIFICATION</t>
							</list>
						</t>
					</section>
				</section>
			</section>
		</section>
	</section>
	<section title="Conformance and Extensions">
		<section title="Conformance">
			<t>Many modules will not require the
			implementation of the full specification to support a module's
			capabilities. Thus, the CICM conformance model was developed to be
			flexible. This model does not normatively prescribe the
			implementation of specific functional subsets of the specification.
			Instead, CICM outlines a normative Implementation Conformance
			Statement (ICS) and associated documentation that SHALL be supplied
			with any conformant implementation.</t>
			<t>The ICS guides the developer of a library for a specific module
			to record the implementation state and presence of extensions for
			each section of the specification. The gradations of the
			implementation state are relatively coarse: "implemented,"
			"partially implemented," or "not implemented." Extensions are
			identified as interface extensions or status code extensions, and
			are recorded as "existing" or "not-existing." An analysis of the
			resulting matrix enables a software developer using the API or an
			architect designing a system integrating with a specific
			cryptographic module to quickly determine if a developer's library
			will meet user requirements. Those specification sections marked
			"partially implemented" or for which extensions are indicated may
			require additional analysis to determine what elements have been
			extended or are not implemented, and the resulting repercussions on
			the system utilizing the library.</t>
			<t>CICM interfaces are organized into three major sections: module
			management, channel management, and key management. Each section is
			partitioned differently into logical subsections in the ICS. The
			module management section is partitioned into subsections by
			individual module managers. The channel management section is
			partitioned into subsections by channel type. And the key
			management section is partitioned into subsections by the type of
			key and class of operation performed on the key.</t>
			<t>An Implementation Data Specification (IDS) based on the ICS also
			is required. For each implemented interface containing an
			 opaque data parameter (module-specific or
			infrastructure-specific parameter not described in detail in the
			specification), the IDS requires a detailed specification of the
			data structure for each parameter.</t>
			<t>An implementation conforms to the specification if it meets the
			following conditions:
			<list style="symbols">
			  <t>A CICM library implementation SHALL include only the subset
			  of interfaces corresponding to the functionality supported by the
			  module for which it was designed. The implementation SHOULD
			  implement the full subset of interfaces implemented by the
			  module. A library SHALL implement a non-zero set of interfaces
			  corresponding to functionality implemented by the module that
			  reasonably maps back to the CICM interface and is appropriate for
			  the system in use.</t>
			  <t>A CICM library SHALL minimally implement the CICMRoot and
			  CryptoModule interfaces, both fundamental parts of the
			  specification without which no other interfaces can be
			  implemented. The CryptoModule interfaces SHALL implement
			  minimally one manager, which must be at least "partially"
			  implemented (e.g., simply implementing non-functional inherited
			  or dependent interfaces is non-conformant).</t>
			  <t>A CICM library SHALL be made available with a corresponding
			  ICS.</t>
			  <t>A CICM library SHALL be made available with an IDS
			  corresponding to its ICS. The format of any module-specific data
			  structures defined as opaque data elements in the specification
			  with which a client program using CICM must have knowledge SHALL
			  be documented by the module developer and SHALL be made available
			  as the IDS. If the implementation implements no interfaces with
			  opaque data parameters and includes no extensions, the IDS SHALL
			  state that the implementation requires no IDS entries.</t>
			  <t>A CICM interface is only conformant if it also implements any
			  inherited and all dependent interfaces (e.g., an
			  Encrypt::WithSignConduit requires that symmetric keys and
			  asymmetric keysets also be implemented). The exception is the
			  CICM::ChannelManager, which only requires the implementation of
			  one or more of its inherited interfaces.</t>
			  <t>Any interfaces that are not implemented precisely as
			  specified in the normative portion of the specification SHALL be
			  identified as extensions to the specification.</t>
			  <t>Extensions to the CICM specification SHALL NOT contradict nor
			  cause the non-conformance of functionality defined in the
			  normative specification, SHALL follow the requirements and
			  guidelines of the normative specification, and SHALL be clearly
			  described in supporting documentation.</t>
			  <t>Memory responsibilities and calling conventions SHALL follow
			  the appropriate IDL language mapping conventions.</t>
			</list></t>
			<section title="Implementation Conformance Statement Contents">
				<t>A library
				implementation conforming to the CICM specification SHALL be
				accompanied by an ICS. The ICS is generated by the module developer
				or implementer of a CICM-conformant library for a specific
				cryptographic module configuration (including any associated
				hardware/firmware/software) and SHALL contain the following
				information:
				<list style="symbols">
				  <t>Details regarding the product and version of the
				  specification to which it conforms, including:
				  <list style="symbols">
					<t>CICM version number</t>
					<t>Product manufacturer/name, version number (hardware,
					firmware, and software)</t>
					<t>Configuration details, including patch state</t>
					<t>Date of claim</t>
				  </list></t>

				  <t>Capability Support Matrix, listing the major sections of the
				  specification and their implementation state ("I"=implemented,
				  "P"=partially implemented, and "N"=not implemented), and the
				  presence of any extensions</t>
				  <t>List of developer-defined extensions to specification.
				  Extensions SHALL be divided into four classes: Interface  extensions,
				  status code extensions, event listener extensions,
				  and constant extensions. Extensions SHALL be documented as
				  specified in the IDS.</t>
				  <t>List of unique identifiers for all supported cryptographic
				  algorithms, organized by class of algorithm, and all supported
				  key agreement protocols; each algorithm/protocol unique
				  identifier SHALL be in CICM-specified format (refer to the
				  section "Generating Unique Identifiers").</t>
				</list></t>
				<t>A sample CICM ICS is presented on the following pages.</t>
				<t>[SAMPLE ICS REMOVED]</t>
			</section>
			<section title="Implementation Data Specification Contents">
				<t>The IDS serves
				as the detailed supporting documentation for the ICS. Conformance
				with the CICM specification requires that:
				<list style="symbols">
				  <t>Each implemented interface that accepts an opaque data object
				  SHALL reference an existing standard or document the data
				  structure associated with that object in sufficient detail to
				  allow an implementer to create new objects and manipulate
				  existing objects. The exception to this requirement is those
				  cases where a client program will NOT be allowed to manipulate
				  the opaque data object (e.g.,
				  CICM::KeyProtocolReceiver::get_from_module or
				  CICM::PackageImporter::import_segment).</t>
				  <t>Each interface extension listed in the ICS SHALL be clearly
				  described in the IDS and SHALL be documented in a manner similar
				  to the normative CICM documentation.</t>
				  <t>Each status code extension listed in the ICS SHALL be
				  referenced in the IDS with a corresponding description, numeric
				  code, and a list of CICM interfaces to which the extension
				  applies.</t>
				  <t>Each module or channel event listener extension listed in the
				  ICS SHALL be referenced in the IDS with corresponding
				  description, numeric code, and data structure definition
				  associated with the event_data parameter, if applicable.</t>
				  <t>Each extended constant value listed in the ICS shall be
				  referenced in the IDS with corresponding description and numeric
				  code.</t>
				</list></t>
				<t>Examples of interfaces requiring an IDS entry to be conformant
				include:
				<list style="symbols">
				  <t>CICM::SymKeyManager::get_key_by_id, where the key identifier
				  is specific to the key management system in use.</t>
				  <t>CICM::LogManager::retrieve, where the log returned from the
				  method call will vary from module-to-module.</t>
				  <t>CICM::ModuleEventListener::event_occurred, where the
				  event_data parameter passed to a client program as part of an
				  event notification is system specific.</t>
				</list></t>
				<t>Note that the event listener callbacks
				(CICM::ModuleEventListener::event_occurred and
				CICM::ChannelEventListener::event_occurred) require that the
				event_data parameter be described for each event type implemented.</t>
			</section>
			<section title="Generating Unique Identifiers">
				<t>CICM does not provide a list
				of algorithms with their corresponding normative unique
				identifiers. Instead, normative guidance is provided for generating
				the identifiers for the different classes of algorithms defined in
				the specification and for key agreement protocols. These
				identifiers are used by software developers when specifying
				algorithms or protocols as parameters to CICM methods. This
				identifier generation guidance is intended to promote
				interoperability, and encourage the use of the same identifier for
				algorithms among vendors.</t>
				<!--[LN] We need to use ABNF notation. -->
				<t>Three major components may be combined to form a unique
				algorithm identifier: an algorithm (ALGO), that may be precisely
				specified as an encryption algorithm (ENCRALGO), signature
				algorithm (SIGALGO), MAC algorithm (MACALGO), or hash algorithm
				(HASHALGO); a mode (MODE); and an encoding scheme (SCHEME), that
				may be precisely specified as an encryption scheme (ENCRSCHEME) or
				a signature scheme (SIGSCHEME). Note that some components above may
				not apply to certain algorithms. In addition, applicable modes and
				components need not always be specified. For encryption and
				signature algorithms, if a length is required, the length SHALL be
				appended to the algorithm without a dash ("-") delimiter.
				Otherwise, components are concatenated with a dash ("-").</t>
				<t>Alternatively, an identifier can consist of a simple personality
				designation (PERSONALITY). The personality consists of a
				combination of parameters that comprise a logically complete
				crypto, and specifies a specific equipment type or configuration
				for which algorithm, mode, and any other parameters are implicit.
				The designation may contain dashes.</t>
				<t>Certain algorithms may be appropriate for and thus listed under
				more than one algorithm class. Below are the classes of algorithms
				and format of the identifiers for each class:</t>
				<t>Asymmetric encryption algorithm identifiers (AsymEncrAlgorithmId)
					<list>
						<t>Format: ENCRALGO [ "-" ENCRSCHEME ] | PERSONALITY</t>
						<t>Examples: "RSA1024-OAEP"</t>
					</list>
				</t><t>Asymmetric signature algorithm identifiers (AsymSigAlgorithmId)
					<list>
						<t>Format: SIGALGO [ "-" HASHALGO [ "-" SIGSCHEME ]] | PERSONALITY</t>
						<t>Examples: "DSA-SHA1" or "RSA1024-SHA256-PKCS1V1_5"</t>
					</list>
				</t><t>Symmetric encryption algorithm identifiers (SymEncrAlgorithmId)
					<list>
						<t>Format: ENCRALGO | PERSONALITY</t>
						<t>Examples: "AES128" or "3DES"</t>
					</list>
				</t><t>Symmetric MAC algorithm identifiers (SymMacAlgorithmId)
					<list>
						<t>Format: MACALGO [ - HASHALGO ] | PERSONALITY</t>
						<t>Examples: "HMAC-SHA1" or "UMAC"</t>
					</list>
				</t><t>Hash algorithm identifiers (HashAlgorithmId)
					<list>
						<t>Format: HASHALGO | PERSONALITY</t>
						<t>Examples: "MD5" or "SHA1"</t>
					</list>
				</t><t>Key wrap algorithm identifiers (KeyWrapAlgorithmId)
					<list>
						<t>Format: ENCRALGO | PERSONALITY</t>
						<t>Examples: AESKW</t>
					</list>
				</t>
				<t>Two major components may be combined to form a key agreement
				protocol identifier: the key agreement protocol including its
				version number (KEYAGREEPROTO) and the protocol's associated
				algorithm suite including its version number (ALGOSUITE). The
				following is the format for key agreement protocol identifiers.</t>
				<t>Key agreement protocol identifier (ProtocolId)
					<list>
						<t>Format: KEYAGREEPROTO "-" ALGOSUITE</t>
						<t>Examples: "IKE2.0-FIREFLY"</t>
					</list>
				</t>
				<t>Note that the resulting identifiers may not be compatible with
				those identifiers defined for other module developers'
				implementations. A client program utilizing an identifier
				corresponding to one algorithm for a specific module may be
				required to modify the identifier for the same algorithm for a
				different type of module. Discrepancies may be discovered through a
				brief review of the ICS "Supported Algorithms" section.</t>
			</section>
			<section title="Conformance Verification">
				<t>In the future, test assertions may
				be made available to allow results from different organizations to
				be compared, and to provide proof of conformance to the
				specification.</t>
			</section>
		</section>
		<section title="Extensions">
			<t>An extension is a mechanism to define
			functionality beyond what is defined in the official specification.
			In the interest of promoting interoperability, extensions to the
			specification are discouraged except where necessary. Extensions to
			the specification enable module developers to add functionality
			unanticipated by the specification developers and to support
			proprietary features.</t>

			<section title="Extending an Interface">
				<t>Developers may augment CICM
				interfaces by extending CICM IDL by adding new methods/attributes
				to existing interfaces or by deriving off existing CICM interfaces.
				Extensions SHALL be documented in the ICS.</t>
			</section>
			<section title="Extending Codes">
				<t>CICM codes are constants that share a
				single 32-bit space. A number of datatypes for different purposes
				correspond to ranges in this space. The "CICM" codes are
				normatively defined in the specification; the "extended" codes are
				module developer-defined extensions. The codes, with their
				corresponding ranges and uses, are as follows:</t>
				<t>CICM status codes
					<list><t>0x00000000 - 0x00001000</t></list>
				</t><t>Extended status codes
					<list><t>0x00001001 - 0x00002000</t></list>
				</t><t>CICM module event codes
					<list><t>0x00002001 - 0x00003000</t></list>
				</t><t>Extended module event codes
					<list><t>0x00003001 - 0x00004000</t></list>
				</t><t>CICM channel event codes
					<list><t>0x00004001 - 0x00005000</t></list>
				</t><t>Extended channel event codes
					<list><t>0x00005001 - 0x00006000</t></list>
				</t><t>CICM generic constants
					<list><t>0x00006001 - 0x00007000</t></list>
				</t><t>Extended generic constants
					<list><t>0x00007001 - 0x00008000</t></list>
				</t><t>RESERVED
					<list><t>0x00008001 - 0x7FFFFFFF</t></list>
				</t>
				<t>Normatively-defined CICM codes SHOULD be used whenever possible.
				If any of the extended codes above are defined, they SHALL be
				documented as specified below.</t>

				<section title="Extending Status Codes">
					<t>The return value from CICM methods
					informs the caller of the status of the call. CICM does not utilize
					the IDL exception mechanism to report errors.</t>
					<t>The specification normatively defines a set of error codes in
					the range of 0x00000000 - 0x00001000, which may not be modified or extended. A
					block of codes in the range of 0x00001001 - 0x00002000 are reserved for module developer-defined
					status codes. Any codes defined in this range SHALL be documented
					in the ICS.</t>
				</section>
				<section title="Extending Module/Channel Event Codes">
					<t>The specification
					supports registering and unregistering user-defined channel event
					listeners for specific module and channel events. Module events in
					the range of 0x00003001 - 0x00004000 and channel events in the range of
					0x00004001 - 0x00005000 are normatively defined and may not be
					modified or extended. A block of module events in the range
					0x00003001 - 0x00004000 and channel events in the range of
					0x00005001 - 0x00006000 are reserved for module developer-defined
					events. Any codes defined in this range SHALL be documented in the
					ICS.</t>
				</section>
				<section title="Extending Constants">
					<t>A number of constants are normatively
					defined for specification use in the range of
					0x00006001 - 0x00007000. Module developer-defined constants may be
					specified in the range of 0x00007001 - 0x00008000.
					Any constants defined in this range SHALL
					be documented in the ICS.</t>
				</section>
			</section>
		</section>
	</section>
    <section title="IANA Considerations">
      <t>This memo makes no request to IANA.</t>
      <t>Note to RFC Editor: this section may be removed on
      publication as an RFC.</t>
    </section>
    <section title="Security Considerations">
      <t>While security issues are not addressed in this document, 
	  implementations SHOULD consider issues discussed in <xref target="RFC3552">RFC 3552</xref>.</t>
    </section>
  </middle>
  <back>
    <!-- Back material. -->
    <references title="Normative References">
      <?rfc include="reference.RFC.2119" ?>
      <?rfc include="reference.RFC.3552" ?>
      </references>
    <section anchor="status-codes" title="Status Codes">
		<t>Each method defined in CICM returns a status
		value to inform the caller as to the outcome of the call. The
		documentation for each individual method lists the status codes
		that may be returned in the event a call to the method results in
		failure.</t>
		<t>The status value CICM::S_OK is returned if a method completes
		successfully. The output parameters of any methods that return a
		status other than CICM::S_OK are invalid and SHALL NOT be
		referenced or used.</t>
		<t>CICM methods can fail for a variety of reasons, including:
		<list style="symbols">
		  <t>Invalid, illegal, out-of-range, or poorly formed
		  parameters</t>
		  <t>Resources insufficient or unavailable</t>
		  <t>Unsupported capabilities</t>
		  <t>Policy violation</t>
		  <t>Hardware failure.</t>
		</list></t>
		<t>For additional information concerning extending status codes,
		see Section 4, Conformance and Extensions.</t>
		<t>CICM status codes are defined below.</t>

		<t>S_OK = 0x00000000<list><t>No error.</t></list></t>
		<t>S_GENERAL_ERROR = 0x00000003<list><t>Unrecoverable error occurred, potentially leaving module in an inconsistent state.</t></list></t>
		<t>S_NON_FUNCTIONAL = 0x00000005<list><t>Tamper event or other condition has rendered module non-functional.</t></list></t>
		<t>S_OPERATION_FAILED = 0x00000006<list><t>Method encountered a general failure, but detailed information about the failure is not available.</t></list></t>
		<t>S_POLICY_VIOLATION = 0x00000009<list><t>Module policy does not permit the requested action.</t></list></t>
		<t>S_MODULE_RESOURCES = 0x0000000A<list><t>Module resources necessary to perform the requested operation are not available.</t></list></t>
		<t>S_HOST_RESOURCES = 0x0000000C<list><t>Host resources necessary to perform the requested operation are not available.</t></list></t>
		<t>S_INVALID_STATE = 0x0000000F<list><t>Module is in a state that does not allow this operation to be performed.</t></list></t>
		<t>S_ALARM_STATE = 0x00000011<list><t>Module has entered an alarm state.</t></list></t>
		<t>S_MODULE_NOT_AVAILABLE = 0x00000012<list><t>Module has been powered down, disconnected, or is otherwise unavailable..</t></list></t>
		<t>S_TIMEOUT = 0x00000014<list><t>Time to receive response from call exceeded threshold.</t></list></t>
		<t>S_NOT_AUTHENTICATED = 0x00000017<list><t>User has not authenticated to module.</t></list></t>
		<t>S_NOT_AUTHORIZED = 0x00000018<list><t>User is not authorized to call method.</t></list></t>
		<t>S_MODULE_DOES_NOT_EXIST = 0x0000001B<list><t>No module with the specified unique identifier exists.</t></list></t>
		<t>S_MODULE_IN_USE = 0x0000001D<list><t>Module test initiated when channels or other module resources are in use.</t></list></t>
		<t>S_NOT_AVAILABLE = 0x0000001E<list><t>Information is not available or cannot be found.</t></list></t>
		<t>S_INVALID_VECTOR = 0x00000021<list><t>Invalid vector provided; this may be because the length or format of the vector is inappropriate for the algorithm or system with which the vector is being used.</t></list></t>
		<t>S_INVALID_DATA_BUFFER = 0x00000022<list><t>Data in user-specified buffer parameter is invalid.</t></list></t>
		<t>S_KEY_USED_INVALID = 0x00000024<list><t>Key specified as parameter to method is invalid; this could denote that the key has been zeroized, a failed parity check, or other conditions that prevent the use of the key.</t></list></t>
		<t>S_KEY_USED_EXPIRED = 0x00000027<list><t>Key specified as parameter to method has expired and may not be used.</t></list></t>
		<t>S_KEY_USED_CLASSIFICATION = 0x00000028<list><t>Key specified as parameter to method at wrong classification level.</t></list></t>
		<t>S_KEY_USED_WRAPPED = 0x0000002B<list><t>Key specified as parameter to method may not be used in the context until it has been unwrapped.</t></list></t>
		<t>S_KEY_USED_CONTEXT = 0x0000002D<list><t>Attempt to use key in an illegal context as defined by the module; e.g., a key is specified for use on a channel but, due to module architecture, the key is unavailable to that channel.</t></list></t>
		<t>S_KEY_USED_COMPONENT_NOT_AVAIL = 0x0000002E<list><t>Asymmetric key specified as parameter to method contains only a public key (possibly in a certificate) or only a private key, when the other component is needed by the called method.</t></list></t>
		<t>S_KEY_INVALID = 0x00000030<list><t>Key is invalid; this could denote that the key has been zeroized, a failed parity check, or other conditions that prevent the use of the key.</t></list></t>
		<t>S_KEY_EXPIRED = 0x00000033<list><t>Key has expired and may not be used.</t></list></t>
		<t>S_KEY_INCOMPATIBLE = 0x00000035<list><t>Key type (e.g., TEK, KEK) incompatible with intended usage.</t></list></t>
		<t>S_KEY_CLASSIFICATION = 0x00000036<list><t>Key at wrong classification level.</t></list></t>
		<t>S_KEY_WRAPPED = 0x00000039<list><t>Key may not be used in this context until it has been unwrapped.</t></list></t>
		<t>S_KEY_NOT_WRAPPED = 0x0000003A<list><t>Key is not wrapped.</t></list></t>
		<t>S_KEY_NOT_WRAPPABLE = 0x0000003C<list><t>Module is not able to wrap key.</t></list></t>
		<t>S_KEY_NOT_EXPORTABLE = 0x0000003F<list><t>Key is not exportable, potentially because it has not been wrapped or other policy disallows it.</t></list></t>
		<t>S_KEY_WRAPPED_EXISTS = 0x00000041<list><t>Wrapped key already exists.</t></list></t>
		<t>S_KEY_UNWRAPPED_EXISTS = 0x00000042<list><t>Unwrapped key already exists.</t></list></t>
		<t>S_KEY_UPDATE_MAX = 0x00000044<list><t>Maximum number of updates for this key has been exceeded.</t></list></t>
		<t>S_KEY_INVALID_ID = 0x00000047<list><t>Invalid key identifier specified.</t></list></t>
		<t>S_KEY_PHYSICAL_LOC = 0x00000048<list><t>Invalid key physical location specified.</t></list></t>
		<t>S_KEY_ILLEGAL_CONVERSION = 0x0000004B<list><t>Target algorithm is incompatible with algorithm associated with specified key.</t></list></t>
		<t>S_KEY_MALFORMED = 0x0000004D<list><t>Key material supplied is malformed.</t></list></t>
		<t>S_KEY_METADATA_MALFORMED = 0x0000004E<list><t>Key metadata supplied is malformed.</t></list></t>
		<t>S_KEY_NO_NEXT = 0x00000050<list><t>No next key available for rollover.</t></list></t>
		<t>S_KEY_WRONG_TYPE = 0x00000053<list><t>Illegal attempt to process a symmetric key with an asymmetric method or an asymmetric key with a symmetric method.</t></list></t>
		<t>S_KEY_FILL_DEVICE_NOT_CONNECTED = 0x00000055<list><t>Key fill device not connected.</t></list></t>
		<t>S_KEY_FILL_NOT_INITIATED = 0x00000056<list><t>Manual key fill device interaction not initiated within system-defined time limit.</t></list></t>
		<t>S_KEY_TRUST_ANCHOR = 0x00000059<list><t>Trust anchor required but is unavailable.</t></list></t>
		<t>S_LOCAL_PORT_INVALID = 0x0000005A<list><t>Local port specified is invalid.</t></list></t>
		<t>S_LOCAL_PORT_INCOMPATIBLE = 0x0000005C<list><t>Local port specified cannot be used in intended manner.</t></list></t>
		<t>S_LOCAL_PORT_IN_USE = 0x0000005F<list><t>Local port specified is currently in use.</t></list></t>
		<t>S_REMOTE_PORT_INVALID = 0x00000060<list><t>Remote port specified is invalid.</t></list></t>
		<t>S_REMOTE_PORT_IN_USE = 0x00000063<list><t>Remote port specified is currently in use.</t></list></t>
		<t>S_ALGO_INVALID = 0x00000065<list><t>Malformed string or unsupported/invalid algorithm specified.</t></list></t>
		<t>S_ALGO_INCOMPATIBLE = 0x00000066<list><t>Algorithm incompatible with intended usage (e.g., encryption, signature, hashing).</t></list></t>
		<t>S_TOKEN_NOT_PRESENT = 0x00000069<list><t>Token must be inserted to perform the requested operation and no token is available to the module.</t></list></t>
		<t>S_TOKEN_ADMIN_NOT_PRESENT = 0x0000006A<list><t>Administrator token must be inserted to perform the requested operation and either no token is present or the inserted token is not an administrator token.</t></list></t>
		<t>S_TOKEN_ACCESS = 0x0000006C<list><t>Token I/O error.</t></list></t>
		<t>S_TOKEN_RESOURCES = 0x0000006F<list><t>Token resources necessary to perform the requested operation are not available.</t></list></t>
		<t>S_TOKEN_ASSOC_EXISTS = 0x00000071<list><t>Association between module and token already exists.</t></list></t>
		<t>S_TOKEN_ASSOC_AT_MODULE = 0x00000072<list><t>Association failed because module will allow no new associations.</t></list></t>
		<t>S_TOKEN_ASSOC_AT_TOKEN = 0x00000074<list><t>Association failed because token will allow no new associations.</t></list></t>
		<t>S_TOKEN_ASSOC_NOT_EXIST = 0x00000077<list><t>Association between module and token does not exist at the module, at the token, or both.</t></list></t>
		<t>S_TOKEN_ASSOC_GENERAL = 0x00000078<list><t>Unspecified token association error occurred.</t></list></t>
		<t>S_TOKEN_DISASSOC_GENERAL = 0x0000007B<list><t>Unspecified token disassociation error occurred.</t></list></t>
		<t>S_TOKEN_REC_NOT_FOUND = 0x0000007D<list><t>Specified record not found.</t></list></t>
		<t>S_TOKEN_TIMEOUT = 0x0000007E<list><t>Timeout for insertion of token has been exceeded.</t></list></t>
		<t>S_TOKEN_LAST_ASSOCIATED = 0x00000081<list><t>Cannot disassociate the last associated token from this module.</t></list></t>
		<t>S_PACKAGE_NOT_ACTIVATABLE = 0x00000082<list><t>Specified package is not executable.</t></list></t>
		<t>S_PACKAGE_ACTIVATED = 0x00000084<list><t>Specified package is currently running.</t></list></t>
		<t>S_PACKAGE_NOT_ACTIVE = 0x00000087<list><t>Specified package is not currently running.</t></list></t>
		<t>S_PACKAGE_INVALID = 0x00000088<list><t>Specified package is invalid.</t></list></t>
		<t>S_PACKAGE_TYPE_INVALID = 0x0000008B<list><t>Specified package type is invalid.</t></list></t>
		<t>S_PACKAGE_KEY_NOT_AVAILABLE = 0x0000008D<list><t>Package is encrypted and the key specified for use to decrypt package is not available on the module.</t></list></t>
		<t>S_PACKAGE_KEY_NOT_SPECIFIED = 0x0000008E<list><t>Package is encrypted but no key is specified to decrypt it.</t></list></t>
		<t>S_LOG_ENTRY_INVALID = 0x00000090<list><t>Log entry is invalid.</t></list></t>
		<t>S_EVENT_REGISTERED = 0x00000093<list><t>An event has already been registered by this process for this event type.</t></list></t>
		<t>S_EVENT_NOT_REGISTERED = 0x00000095<list><t>An event has not been registered by this process for this event type.</t></list></t>
		<t>S_EVENT_NOT_SUPPORTED = 0x00000096<list><t>Event is not supported in this implementation.</t></list></t>
		<t>S_TRUSTED_DISPLAY = 0x00000099<list><t>Peer information is available at trusted display.</t></list></t>
		<t>S_NEGOTIATION_ABORTED = 0x0000009A<list><t>Negotiation was aborted.</t></list></t>
		<t>S_NEGOTIATION_FAILURE = 0x0000009C<list><t>Negotiation failed.</t></list></t>
		<t>S_NEGOTIATION_IN_PROGRESS = 0x0000009F<list><t>Negotiation is already in progress.</t></list></t>
		<t>S_NEGOTIATION_NOT_IN_PROGRESS = 0x000000A0<list><t>No negotiation has been initiated.</t></list></t>
		<t>S_NEGOTIATION_TIMEOUT = 0x000000A3<list><t>Negotiation timed out.</t></list></t>
		<t>S_CERT_LOCAL_INVALID = 0x000000A5<list><t>Local certificate used in a key negotiation is invalid; the certificate may be corrupted or does not verify.</t></list></t>
		<t>S_CERT_LOCAL_EXPIRED = 0x000000A6<list><t>Local certificate used in a key negotiation has expired.</t></list></t>
		<t>S_CERT_REMOTE_INVALID = 0x000000A9<list><t>Remote certificate used in a key negotiation is invalid; the certificate may be corrupted or does not verify.</t></list></t>
		<t>S_CERT_REMOTE_EXPIRED = 0x000000AA<list><t>Remote certificate used in a key negotiation has expired.</t></list></t>
		<t>S_CERT_REMOTE_PATH = 0x000000AC<list><t>Certificates to enable verification of remote certificate's certification path are not available.</t></list></t>
		<t>S_PROTO_INVALID = 0x000000AF<list><t>Malformed string or unsupported/invalid protocol specified.</t></list></t>
		<t>S_PROTO_INCOMPATIBLE = 0x000000B1<list><t>Protocol specified is incompatible with intended usage.</t></list></t>
		<t>S_PROTO_UNDETERMINED = 0x000000B2<list><t>An "implicit" protocol has been specified, but the protocol message does not indicate the protocol.</t></list></t>
		<t>S_CHANNEL_ERROR = 0x000000B4<list><t>Generic conduit/controller error encountered.</t></list></t>
		<t>S_CHANNEL_PEER_RESET = 0x000000B7<list><t>Peer crypto reset conduit/controller or conduit/controller ceased operation.</t></list></t>
		<t>S_CHANNEL_MAX = 0x000000B8<list><t>Limit on total number of conduits/controllers has been reached.</t></list></t>
		<t>S_CHANNEL_NOT_FOUND = 0x000000BB<list><t>Conduit/controller not found.</t></list></t>
		<t>S_CHANNEL_IO_ERROR = 0x000000BD<list><t>Conduit/controller I/O error.</t></list></t>
		<t>S_CHANNEL_DATA_INVALID = 0x000000BE<list><t>Input data to cryptographic operation is invalid (e.g., plaintext for encryption or ciphertext for decryption).</t></list></t>
		<t>S_CHANNEL_DATA_INVALID_LEN = 0x000000C0<list><t>Plaintext (for encryption) or ciphertext (for decryption) input data to cryptographic operation has an inappropriate length; this could denote that the data is too short, too long, or is not a multiple of some particular block size.</t></list></t>
		<t>S_CHANNEL_BUFFER_LEN = 0x000000C3<list><t>Output of function is too large for supplied buffer.</t></list></t>
		<t>S_CHANNEL_IN_GROUP = 0x000000C5<list><t>Conduit/controller already exists as part of group.</t></list></t>
		<t>S_CHANNEL_CLASSIFICATION = 0x000000C6<list><t>Conduits/controllers are not of the same classification.</t></list></t>
		<t>S_BYPASS_DATARATE_EXCEEDED = 0x000000C9<list><t>Bypass data rate exceeded.</t></list></t>
		<t>S_BYPASS_DATALIMIT_EXCEEDED = 0x000000CA<list><t>Bypass data limit exceeded.</t></list></t>
		<t>S_INTEGRITY = 0x000000CC<list><t>In those cases where an encryption algorithm supplies both confidentiality and integrity (an integrity value is transmitted with the ciphertext), the final decrypt may fail with this integrity error if the integrity check fails.</t></list></t>
		<t>S_AUTHENTICATION_FAILED = 0x000000CF<list><t>Authentication to the module failed; this could denote that a password is incorrect or that additional authentication data supplied is invalid.</t></list></t>
		<t>S_USER_AUTHENTICATED = 0x000000D1<list><t>Specified user has already authenticated to module.</t></list></t>
		<t>S_USERNAME_INVALID = 0x000000D2<list><t>Username is invalid.</t></list></t>
		<t>S_USER_EXISTS = 0x000000D4<list><t>User already exists.</t></list></t>
		<t>S_USER_INVALID = 0x000000D7<list><t>User does not exist.</t></list></t>
		<t>S_ROLE_INVALID = 0x000000D8<list><t>Role does not exist.</t></list></t>
		<t>S_ROLE_ASSOCIATED = 0x000000DB<list><t>User already associated with this role.</t></list></t>
		<t>S_ROLE_NOT_ASSOCIATED = 0x000000DD<list><t>User not associated with this role.</t></list></t>
		<t>S_ROLE_MAX = 0x000000DE<list><t>Maximum number of roles already associated with this user.</t></list></t>
		<t>S_PASSWORD_INVALID = 0x000000E1<list><t>Specified password does not meet module policy.</t></list></t>
		<t>S_PASSWORD_INVALID_CHAR = 0x000000E2<list><t>Specified password has invalid characters in it.</t></list></t>
		<t>S_PASSWORD_INVALID_LEN = 0x000000E4<list><t>Length of specified password is either too long or too short.</t></list></t>
		<t>S_SALT_INVALID = 0x000000E7<list><t>Invalid salt specified.</t></list></t>
		<t>S_ITERATION_COUNT_INVALID = 0x000000E8<list><t>Invalid iteration count specified.</t></list></t>
		<t>S_INSUFFICIENT_ENTROPY = 0x000000EB<list><t>Insufficient entropy available. </t></list></t>
    </section>
  </back>
</rfc>