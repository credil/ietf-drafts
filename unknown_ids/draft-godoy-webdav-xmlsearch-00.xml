<?xml version="1.0" encoding="UTF-8"?>
<!--
    This XML document is the output of clean-for-DTD.xslt; a tool that strips
    extensions to RFC2629(bis) from documents for processing with xml2rfc.
-->
<?rfc toc="yes" ?>

<?rfc symrefs="yes" ?>

<?rfc sortrefs="yes"?>

<?rfc iprnotified="no" ?>

<?rfc strict="yes" ?>

<?rfc rfcedstyle="yes" ?>

<?rfc autobreaks="no" ?>

<?rfc comments="yes" ?>

<?rfc emoticonic="yes" ?>

<?rfc symrefs="yes" ?>

<?rfc notedraftinprogress="yes"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc category="exp" ipr="full3978" docName="draft-godoy-webdav-xmlsearch-00" submissionType="independent" obsoletes="" updates=""><front><title abbrev="WebDAV Search Grammar for XML Properties">A WebDAV Search Grammar for XML Properties</title><author initials="R J" surname="Godoy" fullname="Roberto Javier Godoy"><organization abbrev="Universidad Nacional del Litoral">UNL - Facultad de Ingenieria y Ciencias Hidricas</organization><address><postal><street>Ciudad Universitaria, Ruta Nac. 168</street><code>Paraje "El Pozo"</code><city>S3001XAI</city><country>Argentina</country></postal><email>rjgodoy@fich.unl.edu.ar</email></address></author><author initials="H" surname="Minni" fullname="Hugo Minni"><organization abbrev="Universidad Nacional del Litoral">UNL - Facultad de Ingenieria y Ciencias Hidricas</organization><address><postal><street>Ciudad Universitaria, Ruta Nac. 168</street><code>Paraje "El Pozo"</code><city>S3001XAI</city><country>Argentina</country></postal><email>hminni@fich.unl.edu.ar</email></address></author><date day="13" month="January" year="2008"/><abstract><t>This document specifies XS:xml-search, a search grammar 
        for use with the Web Distributed Authoring and Versioning (WebDAV) SEARCH protocol.
        XS:xml-search extends the DAV:basicsearch grammar with XPath expressions 
        which are evaluated on properties whose values are XML fragments.</t><t>
        The full expression power of XPath may exceed the requirement in simple use cases, therefore
        some provisions are made in order to reduce the cost of implementing this specification, 
        as well as the computational cost of evaluating allowed queries. 
        </t></abstract></front><middle><section title="Introduction" toc="default"><t> 
This document specifies XS:xml-search, an OPTIONAL search grammar for use with the Web Distributed Authoring and Versioning (WebDAV) SEARCH protocol. 
The search grammar defined by this document is a superset of DAV:basicsearch <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>. 
</t><t>The intent of this document is to extend the DAV:basicsearch grammar for dealing with properties whose values are XML fragments.
Since the WebDAV property namespace is flat, and resources may have at most one value for a property of a given name (Section 9.1 of <xref target="RFC4918" pageno="false" format="default"/>),
XML documents allowing repeatable elements cannot be expressed as a set of independent WebDAV properties (i.e by mapping some elements to properties),
and the DAV:basicsearch schema cannot be applied to such XML content because it deals with property values as a whole.
<cref anchor="note-intent"> The authors' motivation for writing this specification
is allowing metadata to be searchable when presented as a WebDAV property. 
Since it may be encoded as specified by a third-party schema, 
it should not be modified in order to conform WebDAV. 
</cref>
</t><t>XS:xml-search is proposed as a different search grammar because it defines
a new element (namely XS:filter) that modify the query semantics. 
Had this been an extension of DAV:basicsearch, a server would have ignored 
the XS:filter elements (according to Section 17 of <xref target="RFC4918" pageno="false" format="default"/>) 
yielding results different from those requested by the client.
<cref source="RFC4918" anchor="note-RFC4918-sect17">
"(...) servers MUST process received XML 
documents as if unexpected elements and
attributes (and all children of unrecognized 
elements) were not there" </cref>
</t><section title="Notational conventions" toc="default"><t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
and "OPTIONAL" in this document are to be interpreted as
described in <xref target="RFC2119" pageno="false" format="default"/>.</t><t>This specification defines elements in the urn:ietf:params:xml:ns:webdav-xml-search XML namespace.
(hereinafter referred to as the "XS namespace", though the prefix binding "XS:" is not normative).
In natural language, an element like "xml-search" in this namespace is sometimes referred to as
"XS:xml-search" (without quotes).
<cref anchor="note-namespace">
Since this protocol is experimental, the authors do not suggest new elements
in order to not pollute the "DAV:" namespace. Thus, an experimental implementation
of this protocol will not conflict with the following requirement from RFC 4918:

"(...) an XML element in the "DAV:" namespace SHOULD NOT be used in the request or
response body unless that XML element is explicitly defined in an
IETF RFC reviewed by a WebDAV working group."
</cref>.
</t><t>In element definitions, an element name prefixed with "XS:" refers to an element in the XS namespace, 
and un-prefixed element names refers to elements in the "DAV:" namespace.</t><t>
The DTD fragments are normative up to extensibility rules defined in <xref target="extensibility" pageno="false" format="default"/>.
Unless noted otherwise, ordering of declared content is not significative.
</t><t>
Note: when an error condition is described, it is said that "the server MUST return" some indication of that error.
Unless stated otherwise, if several errors occurs at the same time, any of them MAY be reported and any of them MAY be omitted
as long as one of them is reported.
</t></section><section title="Terms" toc="default"><t>This document uses the terms defined in 
<xref target="RFC2616" pageno="false" format="default"/>, <xref target="RFC4918" pageno="false" format="default"/>, <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>
and this section. Some definitions of frequently used terms from <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/> are 
informatively included here.</t><t><iref item="Dynamic Context" subitem="" primary="false"/>
Dynamic Context: (of an XPath expression) "the dynamic context of an expression is defined as information 
that is available at the time the expression is evaluated."
(Section 2.1.2, <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>)
</t><t><iref item="Dynamic Evaluation Phase (DEP)" subitem="" primary="false"/>
Dynamic Evaluation Phase (DEP): "The dynamic evaluation phase is the phase during which the value of an expression is computed.
It occurs after completion of the static analysis phase." 
(Section 2.3.3.2, <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>)
</t><t><iref item="Dynamic Error" subitem="" primary="false"/>
Dynamic Error: "A dynamic error is an error that must be detected during the dynamic evaluation 
phase and may be detected during the static analysis phase. Numeric overflow is an example of a dynamic error."
(Section 2.3.1, <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>)
</t><t><iref item="Implementation-defined" subitem="" primary="false"/>
Implementation-defined: "indicates an aspect that MAY differ between implementations, 
but MUST be specified by the implementor for each particular implementation."
(Section 1, <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>)
</t><t><iref item="Implementation-dependent" subitem="" primary="false"/>
Implementation-dependent: "indicates an aspect that MAY differ between implementations, 
is not specified by [this or any other] specification, and is not required to be specified 
by the implementor for any particular implementation."
(Section 1, <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>)
</t><t><iref item="Role" subitem="" primary="false"/>

Role: a context within XS:xml-search where the DAV:prop element is expected. 
A role is "plain" if the DAV:prop element occurs as a direct child of DAV:select, DAV:where, or DAV:order,
and it is "filtered" (also referred as XPath-enabled) if the DAV:prop element occurs as a direct child of XS:XPath.
</t><t><iref item="Static Analysis Phase (SAP)" subitem="" primary="false"/>
Static Analysis Phase (SAP): "The static analysis phase depends on the expression itself and on the static context. 
The static analysis phase does not depend on input data (other than schemas)."
(Section 2.3.3.1, <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>)
</t><t><iref item="Static Context" subitem="" primary="false"/>
Static Context: (of an XPath expression) "the static context of an expression is the information 
that is available during static analysis of the expression, prior to its evaluation."
(Section 2.1.1, <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>)
</t><t><iref item="Static Error" subitem="" primary="false"/>
Static Error: "A static error is an error that MUST be detected during the static 
analysis phase. A syntax error is an example of a static error."
(Section 2.3.1, <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>)
</t><t><iref item="Type Error" subitem="" primary="false"/>
Type Error: "A type error may be raised during the static analysis phase or the dynamic 
evaluation phase. During the static analysis phase, a type error occurs when the static 
type of an expression does not match the expected type of the context in which the expression 
occurs. During the dynamic evaluation phase, a type error occurs when the dynamic type of a value 
does not match the expected type of the context in which the value occurs."
(Section 2.3.1, <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>)
</t></section><section title="Overview" toc="default"><t><xref target="propfind" pageno="false" format="default"/> summarizes how this query grammar matches the PROPFIND response, 
according to the requirement imposed by Section 2.3.2 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>.
</t><t>
<xref target="XPath" pageno="false" format="default"/> describes XS:xml-search as an XPath host language, i.e., a language where XPath expressions 
are embedded.
Some items from the XPath specification are defined in that section, 
while other are left to the criteria of the implementors.
This section also includes design decisions in order to reduce the implementation cost of this specification, 
as well as the computational cost of allowed queries.
</t><t>
<xref target="discovery" pageno="false" format="default"/> describes how this grammar is advertised, 
according to the mechanisms for discovery of supported query grammars,
defined in Section 3 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>.
This include the Allow and DASL headers in OPTIONS responses (<xref target="DASL-header" pageno="false" format="default"/>),
the DAV:supported-query-grammar-set property (<xref target="DAV:sqgs" pageno="false" format="default"/>) 
and Query Schema Discovery (<xref target="QSD-intro" pageno="false" format="default"/> and <xref target="QSD" pageno="false" format="default"/>). 
</t><t>
<xref target="grammar" pageno="false" format="default"/> describes the grammar of a XS:xml-search query.
This includes extending the specification of selection (<xref target="DAV:select" pageno="false" format="default"/>)
query criteria (<xref target="DAV:where" pageno="false" format="default"/>)
and ordering (<xref target="DAV:orderby" pageno="false" format="default"/>) with respect to DAV:basicsearch. 
Additionally, some status (<xref target="status_code" pageno="false" format="default"/> to <xref target="status_code_propstat" pageno="false" format="default"/>) and precondition/postcondition codes
(<xref target="preconditions" pageno="false" format="default"/>) are defined.
</t><t>
<xref target="QSD" pageno="false" format="default"/> describes the Query Schema for advertising supported features about properties (<xref target="QSD-prop" pageno="false" format="default"/>)
and operators (<xref target="QSD-op" pageno="false" format="default"/>) available in a XS:xml-search query.
</t><t>
<xref target="extensibility" pageno="false" format="default"/> describes the specified behaviour when unexpected elements are found,
providing a common ground for allowing clients that implement arbitrary extensions
to interoperate with other implementations which does not include it.
</t></section><section title="XS:xml-search and the PROPFIND response" anchor="propfind" toc="default"><t>A XS:xml-search response describes a subset of the elements which are 
 described by a PROPFIND response that lists the same properties on the same scope and with the same depth. 
 If a server supports specifying several scopes in a single query, and these scopes exist, 
 then the XS:xml-search response will  describe a subset of the elements in several PROPFIND responses (one PROPFIND for each scope).</t><t>The properties included in a XS:xml-search response are those specified within the DAV:select element of the request.
In that context, DAV:allprop and DAV:prop are understood as in PROPFIND, hence both methods returns the same properties.
In addition, XS:xml-search introduce a new way for selecting properties: 
XS:filter, which "filters" elements from some property value according to an XPath expression. If XS:filter is used, the XS:xml-search response will contain a subset
of elements from the filtered property, while the PROPFIND response will contain the complete value.</t><t>Queries may impose conditions about which or how many resources will be included in the response, 
 and servers may truncate the response at their choice. Thus, a SEARCH response
 may not include some resources from the specified scope, while all of them have to be included when using PROPFIND. 
 </t><t>Furthermore, XS:xml-search defines additional preconditions and postconditions codes that are not used with a PROPFIND response.</t></section></section><section title="XPath" anchor="XPath" toc="default"><t>There are several items in XPath that are implementation-defined. 
Some of them are defined in this section (as this protocol specifies an XPath host language) 
while other are left to the criteria of the implementors.</t><t>* Some components of the static and dynamic contexts are constrained (<xref target="XPath-contexts" pageno="false" format="default"/>).</t><t>* A way for reporting errors and warnings is specified (<xref target="XPath-errors" pageno="false" format="default"/>).</t><t>* In some expressions, supporting numeric predicates is OPTIONAL (section <xref target="XPath-predicate" pageno="false" format="default"/>).</t><t>* Implementations of this protocol MUST be based on the rules of 
<xref target="W3C.REC-xml11-20060816" pageno="false" format="default"/> and 
<xref target="W3C.REC-xml-names11-20060816" pageno="false" format="default"/>, and apply them consistently.</t><t>* The self, child, and attribute axes MUST be supported. An implementation MAY support other axes, 
as described in the query schema. (Note: the abbreviated steps ".." and "//" are not supported, unless
the parent and descendant-or-self axes respectively are supported.)</t><t>* Support for the "Static Typing Feature" and "Static Typing Extensions" (Appendix F.1 of <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>) is implementation-defined.</t><section title="Static and Dynamic Contexts" anchor="XPath-contexts" toc="default"><t>This specification defines REQUIRED values for some components of the XPath static and dynamic context. 
Unless specified otherwise, the constant values specified below MUST NOT be overwritten.
Components not listed here are "implementation-dependent".</t><t>Evaluation of an expression that relies on one or more "unassigned" components raises the static error err:XPST0001 (if the component is static)
or the dynamic error err:XPDY0002 (if the component is dynamic).</t><texttable title=""><preamble>REQUIRED static values</preamble><ttcol width="30%" align="left">Component</ttcol><ttcol align="left">Specified Value</ttcol><c>XPath 1.0 compatibility mode</c><c>"false".</c><c/><c> </c><c>Statically known namespaces</c><c>All the namespace bindings in scope at the XS:XPath element where the expression occurs plus
                                                     ("fn:", "http://www.w3.org/2005/ XPath- functions") unless overwritten.</c><c/><c> </c><c>Default element/type namespace</c><c>The default namespace of the XS:XPath element where the expression occurs 
                                                     ("none" if there is no default namespace).</c><c/><c> </c><c>Default function namespace</c><c>None.</c><c/><c> </c><c>Function signatures</c><c>None (may be overwritten).</c><c/><c> </c><c>Statically known collations</c><c>At least "http://www.iana.org/assignments/collation/ default"
                                        and applicable wildcard collations (Sections 3.1 and 3.2 of <xref target="RFC4790" pageno="false" format="default"/>).
                                        MAY be augmented with an implementation-defined set of collations.</c><c/><c> </c><c>Default collation</c><c>The collation matched by "http://www.iana.org/assignments/collation/ default" 
                                        (the actual collation is implementation-defined)</c><c/><c> </c><c>Base URI</c><c>Unassigned.</c><c/><c> </c><c>Statically known documents</c><c>Initially unassigned. Overwriteable with an implementation-defined value.</c><c/><c> </c><c>Statically known collections</c><c>Initially unassigned. Overwriteable with an implementation-defined value.</c><c/><c> </c><c>Statically known default collection type</c><c>node()*</c></texttable><texttable title=""><preamble>REQUIRED dynamic values</preamble><ttcol align="left">Component</ttcol><ttcol align="left">Specified Value</ttcol><c>Function implementations</c><c>Implementation-defined, MUST be consistent with function signatures.</c><c/><c> </c><c>Current dateTime</c><c>REQUIRED implementation-dependent value.</c><c/><c> </c><c>Implicit timezone</c><c>REQUIRED implementation-defined value.</c><c/><c> </c><c>Available documents</c><c>Initially unassigned. Overwriteable with an implementation-defined value.</c><c/><c> </c><c>Available collections</c><c>Initially unassigned. Overwriteable with an implementation-defined value.</c><c/><c> </c><c>Default collection</c><c>Initially unassigned. Overwriteable with an implementation-defined value.</c></texttable></section><section title="Error and warnings" anchor="XPath-errors" toc="default"><t>
This section describes the method by which XPath errors and warnings are reported.
Error conditions are defined in <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>, 
and warning conditions are OPTIONAL and implementation-defined.</t><t>For conformance with <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>, implementations MAY report any non-empty subset of errors.
Additionally, if there is an error (other than a XPath error) that causes the request to be rejected, implementations MAY report the latter,
with no mention to the XPath errors.
</t><t>
The idref attributes of XS:xpath-error and XS:warning MAY be used to refer to the id attribute of the XS:xpath element 
whose content raised the error or warning. 

The mechanism that implementations use to return additional information is implementation-defined. 
</t><section title="Warnings" toc="default"><t>The XS:warning element contains at least one XML element, and MUST NOT contain text or mixed content. 
Children of the XS:warning element represent warnings signaled during the analysis of the expression.
</t><t>
<iref item="Element" subitem="XS:warning" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!ELEMENT XS:warning ANY>
<!ATTLIST XS:warning idref NAME #IMPLIED>
]]></artwork></figure>
</t><t>The DAV:multistatus and DAV:response elements, when used in response to XS:xml-search queries, 
are modified to include an OPTIONAL XS:warning element. 

Warnings raised during SAP apply to the whole query and 
are reported within the XS:warning element contained by DAV:multistatus.

Warnings raised during DEP only apply to a particular resource
and are reported within the DAV:response for that resource.
</t><iref item="Element" subitem="DAV:multistatus" primary="false"/><iref item="Element" subitem="DAV:response" primary="false"/><t><figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!ELEMENT multistatus (response*, responsedescription?, 
                       XS:warning?) >

<!ELEMENT response (href, ((href*, status)|(propstat+)), 
                    error?, XS:warning?, 
                    responsedescription?, score?)
]]></artwork></figure>
</t></section><section title="Errors (in SAP)" anchor="errors-SAP" toc="default"><t>
Errors (either static, dynamic or type errors) detected during SAP
invalidates the request. These kind of errors are reported through a XS:xpath-error element 
included in a response whose root element is DAV:error. The response status code is 400 (Bad Request).

<iref item="Element" subitem="XS:xpath-error" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!ELEMENT XS:xpath-error ANY>
<!ATTLIST XS:xpath-error idref NAME #IMPLIED>
]]></artwork></figure>

The XS:xpath-error element MUST contain one or more elements describing the error. For instance, 
if an err:XPST0003 were raised (i.e. the XPath static error 0003: "a XPath expression is not a valid instance of the grammar") the response would be:

<iref item="Example" subitem="XS:XPath-error (in SAP)" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="message/http" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
HTTP/1.1 400 Bad Request
Content-Type: text/xml; charset="utf-8"
Content-Length: xxx

<error xmlns="DAV:">
  <XS:XPath-error 
      xmlns:XS="urn:ietf:params:xml:ns:webdav-xml-search">
    <err:XPST0003 xmlns:err="http://www.w3.org/2005/xqt-errors"/>  
  </XS:XPath-error>
</error>
]]></artwork></figure></t><t>(Note: the use of the "err:" prefix follows the convention of <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/> but it is not normative.)</t></section><section title="Errors (in DEP)" toc="default"><t>
An expression may be statically valid and raise an error under some dynamic conditions.
Dynamic and type errors detected during DEP only invalidates the expression which raises them, 
when evaluated with the actual values of some resource property.
</t><t>
A server MAY ignore errors detected in DEP if:
<vspace blankLines="0"/>   -The error occurs within DAV:order, 
but that ordering criteria is not used (because other orders take precedence, or because the query matches one or no resource).
<vspace blankLines="0"/>   -The error occurs within DAV:where part, and it does not affect the result.
For instance, the error in (FALSE AND ERROR) may be omitted because the result would have been FALSE anyway, 
and the error in (TRUE OR ERROR) may be omitted because the result would have been TRUE anyway. 
</t><t>If the error is not ignored, and the XPath expression was specified within the DAV:select part,
it MAY be reported in the DAV:propstat element for the current property and resource. 
Otherwise it MAY be reported in the DAV:response element for the current resource. In both cases 
the status code 409 (Conflict) MUST be used.
</t><t>
Although errors in DEP depend on the value of the property,
an error that is too frequent might have been caused by mistakes in the client's request.="I-D.reschke-webdav-search" pageno="false" formaV:response elements, all of which represent failures because of the same error, 
a server MAY report an error in DEP as a general failure invalidating the query itself, 
even if it is possible to evaluate other resources and properties.
<cref anchor="error-DEP">
Besides, handling dynamic errors on a separate basis imposes an additional requirement, then
supporting this feature is left to the criteria of implementors.
</cref>
</t><t>
 When an error raised in DEP is reported as a general failure, 
 the response will be marshaled as in <xref target="errors-SAP" pageno="false" format="default"/>,
 but the response status code MUST be 409 (Conflict) instead of 400 (Bad Request). 
</t><t>
For instance, if err:XPTY0004 were raised during DEP ("the dynamic type of a value does not match a required type"),
the response would be:

<iref item="Example" subitem="XS:XPath-error (in DEP)" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="message/http" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
HTTP/1.1 409 Conflict
Content-Type: text/xml; charset="utf-8"
Content-Length: xxx

<error xmlns="DAV:">
  <XS:XPath-error 
      xmlns:XS="urn:ietf:params:xml:ns:webdav-xml-search">
    <err:XPTY0004 xmlns:err="http://www.w3.org/2005/xqt-errors"/>  
  </XS:XPath-error>
</error>
]]></artwork></figure></t><t>the dynamic type of a value does not match a required type</t></section></section><section title="Numeric Predicates" anchor="XPath-predicate" toc="default"><t>
"A step is a part of a path expression that generates a sequence of items and then filters the sequence 
by zero or more predicates." (Section 3.2.1 of <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>).
A step expression may be either a FilterExpr or an AxisExpr.
</t><t>
"A predicate consists of an expression, called a predicate expression, enclosed in square brackets. 
A predicate serves to filter a sequence, retaining some items and discarding others."
(Section 3.2.2 of <xref target="W3C.PR-xpath20-20061121" pageno="false" format="default"/>)
</t><t>
Support for numeric predicates and other references to the context position 
-e.g. by evaluating the fn:position() function- depends on the sequence where the predicate applies.
</t><t>
Supporting numeric predicates in FilterExpr is OPTIONAL. 
If the step expression is an AxisStep, the requirement level depends on the specified axis. It is:</t><t>
* NOT RECOMMENDED for the namespace and attribute axes, 
  because the relative order of elements within these axes is implementation-dependent. 
  <vspace blankLines="0"/>
* Always REQUIRED for the parent, self, and ancestor axes.
  <vspace blankLines="0"/>
* For the child, preceding-sibling and following-sibling axes: 
  RECOMMENDED if the sequence order is semantically meaningful, OPTIONAL otherwise.
  <vspace blankLines="0"/>
* Always OPTIONAL for the descendant, descendant-or-self, ancestor-or-self, preceding, and following axes.
  <vspace blankLines="0"/>  
<cref anchor="note-context-position">
When supporting numeric predicates and context position references
there is a trade-off between expressive power and implementation costs.
</cref>
</t><t>The way this feature is supported when it is not REQUIRED is implementation-dependent.</t></section></section><section title="Discovery of the Query Grammar" anchor="discovery" toc="default"><t>
If a resource supports the SEARCH method, then the server MUST list SEARCH in the Allow header,
as described in Section 3.1 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>.
</t><section title="The DASL Response Header" anchor="DASL-header" toc="default"><t>The DASL response header indicates server support for a query grammar in the OPTIONS method. 
(Section 3.2 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>)
The value of this header is a URI that indicates the type of grammar supported. 

Servers MUST return the following header when the 
OPTIONS method is invoked on any arbiter that supports the XS:xml-search grammar:</t><iref item="Example" subitem="DASL Response Header" primary="false"/><t>   DASL:&lt;urn:ietf:params:xml:ns:webdav-xml-search&gt;</t></section><section title="DAV:supported-query-grammar-set" anchor="DAV:sqgs" toc="default"><t>The WebDAV property DAV:supported-query-grammar-set is REQUIRED for any server supporting either 
<xref target="RFC3253" pageno="false" format="default"/> and/or <xref target="RFC3744" pageno="false" format="default"/> and identifies the XML based query grammars that 
are supported by the search arbiter resource (Section 3.3 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>). 

Servers implementing DAV:supported-query-grammar-set MUST report the following grammar
for each arbiter resource supporting XS:xml-search:<vspace blankLines="0"/> 

<iref item="Example" subitem="DAV:supported-query-grammar-set" primary="false"/> 
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<DAV:grammar xmlns:DAV="DAV:">
  <XS:xml-search 
    xmlns:XS="urn:ietf:params:xml:ns:webdav-xml-search"/> 
</DAV:grammar>]]></artwork></figure>
</t></section><section title="Discovery of the XS:xml-search Query Schema" anchor="QSD-intro" toc="default"><t>
Query Schema Discovery (QSD) is requested by means of the SEARCH method, including an entity with a DAV:query-schema-discovery root element.
As specified in Section 4.1 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>,
the response body takes the form of a DAV:multistatus element (Section 13 of <xref target="RFC4918" pageno="false" format="default"/>), 
where DAV:response is extended to hold the returned query grammar inside a DAV:query-schema container element. 
</t><t>
If the DAV:query-schema-discovery element contains XS:xml-search, then the response marshaling MUST be performed as described in this section
and <xref target="QSD" pageno="false" format="default"/>.
</t><t>
Since the supported query grammars may depend on the scope,
the XS:xml-search element (when used for QSD) MAY contain a DAV:from element. 
Other content is unexpected in this context.
</t><t>If several scopes are specified and the server supports multiple scopes,
then the response MUST only contain those descriptions that are common to each scope. 
</t><t><iref item="Example" subitem="QSD request" primary="false"/> 
Request:
<figure title="" align="left" alt="" width="" height=""><artwork type="message/http" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
SEARCH / HTTP/1.1
Host: host.example
Content-Type: application/xml
Content-Length: xxx

<query-schema-discovery xmlns="DAV:"> 
  <XS:xml-search 
    xmlns:XS="urn:ietf:params:xml:ns:webdav-xml-search"/>
</query-schema-discovery>
]]></artwork></figure>
</t><t><iref item="Example" subitem="QSD response" primary="false"/> 
Response:
<figure title="" align="left" alt="" width="" height=""><artwork type="message/http" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
HTTP/1.1 207 Multistatus
Content-Type: application/xml
Content-Length: xxx

<multistatus xmlns="DAV:">
  <response>  
    <href>http://host.example</href>
    <status>HTTP/1.1 200 OK</status>
    <query-schema>
      <XS:xml-search-schema
        xmlns:XS="urn:ietf:params:xml:ns:webdav-xml-search"/>
        <!-- (See Section 5 for the actual contents) -->
      </XS:xml-search-schema>
    </query-schema>
  </response>
</multistatus> 
]]></artwork></figure>
</t></section></section><section title="The XS:xml-search Grammar" anchor="grammar" toc="default"><t> 
The elements used in XS:xml-search conform the semantics given in <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>:A=" the DAV:basicsearch grammar, and all the operators defined in Section 5 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/> 
(i.e. %all_ops;) are valid in the context of a XS:xml-search query. 
Additionally, some elements in the "DAV:" namespace are allowed to contain 
specific elements from the XS:xml-search grammar.
</t><t>Therefore, the semantics of a DAV:basicsearch valid query is preserved when the 
DAV:basicsearch content is submitted as a XS:xml-search query.
</t><t> This grammar also allows the additional element XS:filter as well as optional implementation-defined operators.
The XS:filter element specifies an XPath expression (rooted on a single property, i.e. the root element is the property 
whose name is included in the DAV:prop element). It is both a query-operator and a special construct valid within 
DAV:select and DAV:order elements.
</t><t>
<iref item="Element" subitem="XS:xml-search" primary="false"/>
<iref item="Element" subitem="DAV:select" primary="false"/>
<iref item="Element" subitem="XS:filter" primary="false"/>
<iref item="Element" subitem="XS:XPath" primary="false"/>
<iref item="Element" subitem="DAV:where" primary="false"/>
<iref item="Element" subitem="DAV:not" primary="false"/>
<iref item="Element" subitem="DAV:and" primary="false"/>
<iref item="Element" subitem="DAV:or" primary="false"/>
<iref item="Element" subitem="XS:is-well-formed" primary="false"/>
<iref item="Element" subitem="DAV:order" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!-- "XS:xml-search" element -->
<!ELEMENT XS:xml-search (select?, from, where?, orderby?, limit?) >
 
<!-- "DAV:select" element -->
<!ELEMENT select     ( (allprop | prop | XS:filter)+ )>
<!ELEMENT XS:filter  (prop, XS:XPath)>
<!ELEMENT XS:XPath    #PCDATA >
    
<!-- "DAV:where" element -->
<!ENTITY % ext_ops "XS:filter | XS:is-well-formed" >
<!ELEMENT where       (  %all_ops;|%ext_ops;)      >

<!ELEMENT not         (  %all_ops;|%ext_ops;   )   >
<!ELEMENT and         ( (%all_ops;|%ext_ops;)+ )   >
<!ELEMENT or          ( (%all_ops;|%ext_ops;)+ )   >

<!ELEMENT XS:is-well-formed ( prop )               > 

<!-- "DAV:order" element for XS:xml-search-->

<!ELEMENT order      ((prop | score | XS:filter), 
                      (ascending | descending)?)
                      
]]></artwork></figure></t><section title="Accepted Role Precondition" toc="default"><t>
If the XS:xml-search request includes a property with a role which is not acceptable (e.g. 
the request specifies a filtered selection of a property which is not XPath-enabled
or it specifies ordering by a non-sortable property), the server MUST reply with a 422 
(Unprocessable Entity) status code.

The response's DAV:error element MUST contain at least one XS:acceptable-role preconditions 
(<xref target="preconditions" pageno="false" format="default"/>) describing the failure for each rejected property.</t><t>If the request is not accepted because of a XS:acceptable-role precondition, 
the server SHOULD report all the failures, so that if the client removes the conflicting 
properties then the modified query will succeed this test.</t><t>If a property violates the preconditions for a role in both plain and filtered forms, 
then the filtered form MAY be omitted in the error response. (This rule does not applies for DAV:selectable 
since a property may not be specified for both plain and filtered selection in the same request).</t><t>Rejections because of several reasons (e.g. because a property is neither DAV:searchable nor DAV:selectable) 
MAY be reported by means of a single XS:acceptable-role element.
The DAV:prop element within XS:acceptable-role must contain a single property element.</t><t>
If QSD is supported, a property used in a role described in the QSD response for the search scopes
MUST NOT be rejected.
</t><t>When a XS:filter element refers to a live property that is known not to be well-formed XML 
(because the XML syntax is not enforced for that property), the server SHOULD reject the request 
as described in this section, instead of accepting the query and reporting a 409 (Conflict) for each occurrence.
(This implies that, if such property is mentioned in the QSD, its description SHOULD NOT include any XPath-enabled role.)
</t></section><section title="Selection" anchor="DAV:select" toc="default"><t>
DAV:select defines the result record, which is a set of properties and values (Section 5.3 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>). 
The allowed children are DAV:allprop and DAV:prop (defined in Section 14 of <xref target="RFC4918" pageno="false" format="default"/>) and XS:filter (defined in this document).
</t><t>
If the DAV:select element is omitted, the successful response MUST only contain the URIs of matched resources 
in one or more DAV:response elements with status code 204 (No content). The response root element is DAV:multistatus.

If an error occurs, it MUST be reported as described for the non-empty case.
</t><t>The rest of this section describes the handling of non-empty DAV:select elements</t><t>
For each resource matching the query criteria and scope, the results from all the XS:filter selection-elements 
(i.e all the XS:filter elements included within a DAV:select element) referred to the same property MUST be returned 
into a single property of the DAV:response. 
Because of filtering, the response is not required to be valid even if the selected property contains an XML document 
that is valid according to some DTD or XML schema.</t><t>For each resource matching the query criteria and scope, and for each property selected through XS:filter:</t><t>- When the actual property value does not contain a well-formed XML fragment, a DAV:propstat with 409 
(Conflict) code and postcondition code XS:property-must-be-well-formed-xml MUST be returned for that resource and property 
(since the query semantics is not appropriate for the actual property value).
</t><t>- If the actual property value contains a well-formed XML fragment, the matched elements are aggregated into the XML fragment 
for that property and resource.</t><t>- If no elements are matched for that property and resource, it will be reported as an empty element. 
</t><t>If a property does not exist, the server MUST either omit the selected property from that resource record-set
or return it within a 404 (Not Found) status code DAV:propstat.<cref anchor="note-OPTIONAL-404">
The 404 status code for missing properties is OPTIONAL in order to avoid an extensive response
if the client selects several properties that are seldom defined. 
Note this behaviour is different from the PROPFIND case, where the 404 status code is REQUIRED for missing properties (Section 9.1 of [RFC 4918], page 35).
</cref>
</t><t>
A client MUST NOT request both the plain property value and the filtered one, since it is ambiguous (or, in the best case, redundant) 
<cref anchor="note-select-prop-filter">
If the property value is not well-formed XML specifying both DAV:prop and XS:filter is ambiguous because
a 409 (Conflict) status code must be returned per XS:filter and the complete property value must be returned per DAV:prop. 
On the other hand, if the property value were well-formed XML, one of those elements would have to be ignored.
</cref>.

Hence, if DAV:select contains one or more XS:filter elements 
referring a property that is also selected via a plain DAV:prop element, 
the server MUST return a 400 (Bad Request) response. </t><t>For instance, the following DAV:select element causes a 400 response:</t><iref item="Example" subitem="Bad Request, DAV:select" primary="false"/><t><figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<select xmlns="DAV:">
   <filter>
    <prop xmlns:A="http://a.example/"/>
      <A:property/>
    </prop>
    <XPath>//foo</XPath>
  </filter>
  <prop xmlns:A="http://a.example/"/>
      <A:property/>
  </prop>
</select> 
]]></artwork></figure></t><t>
If DAV:allprop is specified, it is understood as in a PROPFIND request <xref target="RFC4918" pageno="false" format="default"/>:
(i.e., properties defined in RFC 4918, at a minimum, plus dead properties MUST be returned).
Hence, the set of properties selected by allprop vary from resource to resource.</t><t>
If the request includes not only DAV:allprop but also one or more DAV:prop elements specifying properties which 
are already returned per DAV:allprop, or the request includes a property twice in DAV:prop elements, 
then the redundant properties MUST be ignored (i.e. a single property value will be returned). 
This behaviour is similar to that of the DAV:include element in a PROPFIND request (but DAV:include is not defined
for XS:xml-search requests).
</t><t>
There is no error when a property that would be returned per DAV:allprop is also specified within a XS:filter element
(since the client may not be aware of the properties that will be returned when DAV:allprop is specified).
This combination MUST be addressed as follows:<vspace blankLines="0"/>
    - The XS:filter elements are processed as usual. This result in properties contained in DAV:propstat; 
elements with status code 200, 4xx or 5xx (as appropriate).<vspace blankLines="0"/>
    - Each property that would have been returned per DAV:allprop in a PROPFIND request
and was not included within a XS:filter element, is selected.<vspace blankLines="0"/>
</t></section><section title="Query criteria" anchor="DAV:where" toc="default"><t>The DAV:where element specifies optional query criteria.
Only those resources that verify the query criteria
are included in the result set.
</t><section title="DAV:prop operand" toc="default"><t>
The result of the DAV:prop operand is the value of the specified property of the resource being evaluated.
If the property is a live one, the result datatype SHOULD be the actual property datatype.
If the property is dead, or the server chooses to ignore the live property datatype, the result MUST be
of type xs:string.
</t><t>
Note: "A property name is a universally unique identifier that is associated with a schema that provides information about the syntax and
semantics of the property." (Section 4.4 of <xref target="RFC4918" pageno="false" format="default"/>). Therefore, each property name SHOULD be permanently associated 
with at most one datatype.
</t></section><section title="Literal Operands" toc="default"><t>DAV:literal and DAV:typed-literal allow literal values to be placed in an expression.</t><t>
When used with the operators defined in <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>:<vspace blankLines="0"/>
   - The type of a DAV:literal value MUST be the type of the other operand in the expression.<vspace blankLines="0"/>
   - The type of a DAV:typed-literal value MUST be the type specified in the xsi:type attribute, or 
xs:string if no type was specified. The value of the other operand MUST be casted to this type.
</t><t>
A request with a DAV:typed-literal specifying an unknown type MUST be rejected
 by returning a response with status code 422 (Unprocessable Entity) 
 and precondition code XS:known-literal-type.
 The xs:string type MUST NOT be unknown.
</t></section><section title="Relational operators" toc="default"><t>
The relational operators take a property and literal operand.
XS:xml-search inherits the five relational operators defined in <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>:
DAV:eq, DAV:lt, DAV:gt, DAV:lte and DAV:gte.
</t><t>For each property and pair of values being compared:<vspace blankLines="0"/>
   - per Section 4.2.1 of <xref target="W3C.REC-xmlschema-2-20041028" pageno="false" format="default"/> the result of 
DAV:eq; is always defined, then DAV:eq; MUST NOT return NULL.<vspace blankLines="0"/>
   - all of DAV:lt, DAV:gt, DAV:lte and DAV:gte MUST be either undefined or consistently defined.
If they are defined, they MUST also conform the result of DAV:eq (i.e., A == B iff A&lt;=B and A&gt;=B).
</t><t>
If the property type is known and it is a complex type, the result of these operations SHOULD be undefined.
<cref anchor="note-comparison-complex-type">
This seems to be a MUST in [draft-reschke-webdav-search-14] Section 5.5.4, but is relaxed here since the property
would be treated as xs:string if the type were ignored.</cref>
(Values within such properties may be compared by means of XPath predicates.)
</t><t> 
If the property type is known and it is a simple built-in ordered type, the order relation used in the comparison 
SHOULD be that defined in <xref target="W3C.REC-xmlschema-2-20041028" pageno="false" format="default"/>.     
</t><t>If the property type is known and it is a simple type, 
an implementation-dependent order relation MAY be used.
If a partial order is used, then trying to compare two values which are not comparable yields an undefined result.
</t><t>
In any case, the collation algorithm is implementation-dependent.
</t><t>
 Other operators and operands retain the behaviours defined in <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>.
</t></section><section title="The XS:filter operator" toc="default"><t>When used inside a DAV:where element (or a sub-element thereof) XS:filter evaluates as:<vspace blankLines="0"/>
   - TRUE if (and only if)  the XPath expression matches at least one element,<vspace blankLines="0"/>
   - FALSE if (and only if) no element within the property is matched,<vspace blankLines="0"/>
   - NULL if (and only if)  the property does not exist or its value is not a well-formed XML fragment. 
</t></section><section title="The XS:is-well-formed operator" toc="default"><t>The XS:is-well-formed operator takes a DAV:prop operand
and returns:<vspace blankLines="0"/>
   - TRUE if (and only if)  the property value is a well formed XML fragment.<vspace blankLines="0"/>
   - FALSE if (and only if) the property value is not a well formed XML fragment.<vspace blankLines="0"/>
   - NULL if (and only if)  the property does not exist. 
</t><t>Supporting this operator is REQUIRED for properties which are XS:searchable, and OPTIONAL 
for properties which are only DAV:searchable.
</t></section></section><section title="Ordering" anchor="DAV:orderby" toc="default"><t>
DAV:orderby specifies a lexicographical order on the set of DAV:response to be returned.
Comparisons are applied as they occur in the DAV:orderby element, earlier comparisons being more significant
(Section 5.6 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>).
</t><t>When used within XS:xml-search, a DAV:orderby element MUST contain one or more DAV:order elements, 
which are allowed to contain a DAV:prop, a DAV:score or a XS:filter elements.</t><t>
When DAV:order contains a DAV:prop element, the ascending (alternatively, descending) order MUST be consistent with the comparison 
performed by DAV:lte (alternatively, DAV:gte):<vspace blankLines="0"/>
 - If A&lt;=B (alternatively, A&gt;=B) according to DAV:lte, then A collates before B.<vspace blankLines="0"/>
 - If A&lt;=B (alternatively, A&gt;=B) is undefined, then the collation order is implementation-dependent.<vspace blankLines="0"/>
</t><t>When DAV:order contains a DAV:score element, an integer comparison is performed on each DAV:score value 
computed for the DAV:contains operation.
</t><t>When DAV:order contains a XS:filter element, result-sets will be 
logically partitioned in three equivalence classes, based on the evaluation of XS:filter 
(as defined in <xref target="DAV:where" pageno="false" format="default"/>). The equivalence classes are totally ordered (in ascending order) as: 
NULL &lt; false &lt; true.
</t><t>ria and the ordering criteria), &#13;
the server may aing among all the responses for which the XS:filter element evaluates to the same value)
is implementation-dependent. (The order specified for the item-type in the sequence returned by the xpath expression 
MAY be used.)</t></section><section title="SEARCH Status Codes for responses to XS:xml-search queries" anchor="status_code" toc="default"><t>
   - 207 (Multistatus) The server accepted the request. The result set are returned within a 
DAV:multistatus; element. <vspace blankLines="0"/>
   - 400 (Bad Request) Error in SAP, or the query includes both a plain DAV:prop and a XS:filter specifying the same property name.<vspace blankLines="0"/>
   - 403 (Forbidden)   The server rejected the request because the user has no privileges for performing queries under the specified arbiter resource.<vspace blankLines="0"/>
   - 404 (Not found)   The arbiter resource does not exist.<vspace blankLines="0"/>
   - 409 (Conflict)    Error in DEP (general failure) or invalid scope.<vspace blankLines="0"/>
   - 422 (Unprocessable Entity) <vspace blankLines="0"/>
       A property was specified in a role which is rejected for that property. <vspace blankLines="0"/>
       An unknown type was specified in DAV:typed-literal.<vspace blankLines="0"/>
       A required extension is not supported.<vspace blankLines="0"/>
</t><t>Other status codes may be returned (redirections, client errors, server errors), with the meaning defined in <xref target="RFC2616" pageno="false" format="default"/>.</t><t>The 207 status code MUST be used if and only if a result set is included in the response 
(an empty result set is allowed if the query does not match any resource).</t><t>If the query could not be performed because of several errors, 
the error which is reported is implementation-dependent.</t><t>If the client has no privileges for testing whether the arbiter exists 
then 403 (Forbidden) SHOULD be used instead of 404 (Not found).
If the client has no privileges for accessing the specified scope then 409 (Conflict) MUST be returned
</t></section><section title="Status Codes for Use in 'response' Elements" anchor="status_code_response" toc="default"><t>
   - 204 (No Content) if the resource exists and no selection list was specified 
(i.e. the DAV:select element is empty).<vspace blankLines="0"/>
   - 209 (Conflict) Error in DEP. The search was invalidated for 
resources identified by DAV:href elements in the response.</t><t>If a selection list was specified, the response MUST NOT contain a DAV:status element, 
but a DAV:propstat listing the selected properties.</t><t>If the client has no privileges for testing whether a resource exists, 
that resource MUST be silently omitted from the response.</t><t>5xx status codes MAY be used if a error occurs when accessing the resource.</t></section><section title="Status Codes for Use in 'propstat' Elements" anchor="status_code_propstat" toc="default"><t>
   - 200 (OK) for each selected property, if the property exists.<vspace blankLines="0"/>
   - 403 (Forbidden) if the client has no privileges for accessing the selected property.<vspace blankLines="0"/>
   - 404 (Not Found) for each property selected through DAV:allprop, DAV:prop or XS:filter if the property does not exist (OPTIONAL).<vspace blankLines="0"/>
   - 409 (Conflict) if a property specified in a selection XS:filter element does not contains well-formed XML.
The associated postcondition MUST be XS:property-must-be-well-formed-xml.
</t><t>If the client has no privileges for testing whether the property exists, the server SHOULD either omit the property or return a 404 (Not found) status code (instead of 403).</t><t>5xx status codes MAY be used if a error occurs when accessing the property value.</t></section><section title="Precondition and postcondition Codes" anchor="preconditions" toc="default"><section title="XS:property-must-be-well-formed-xml" toc="default"><iref item="Element" subitem="XS:property-must-be-well-formed-xml" primary="false"/><t><vspace blankLines="0"/></t><t>Type: postcondition</t><t>Use with: /multistatus/response/propstat/error, 409 Conflict</t><t>Purpose: the actual property value does not contain a well-formed XML fragment, 
and the property was specified in a XS:filter element.</t><t><figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!ELEMENT XS:property-must-be-well-formed-xml EMPTY>
]]></artwork></figure></t></section><section title="XS:acceptable-role" toc="default"><iref item="Element" subitem="XS:acceptable-role" primary="false"/><t><vspace blankLines="0"/></t><t>Type: precondition</t><t>Use with: /error, 422 Unprocessable Entity</t><t>Purpose: the XS:xml-search request includes a property for a role where it is not acceptable.</t><t><figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!ELEMENT XS:acceptable-role (prop, searchable?,
                              selectable?, sortable?)> 
]]></artwork></figure></t></section><section title="XS:XPath-error" toc="default"><iref item="Element" subitem="XS:XPath-error" primary="false"/><t><vspace blankLines="0"/></t><t>Type:  precondition/postcondition</t><t>Use with:<vspace blankLines="0"/>
   /error, 400 Bad Request (precondition)<vspace blankLines="0"/>
   /error, 409 Conflict (precondition)<vspace blankLines="0"/>
   /multistatus/response/error, 409 Conflict (postcondition)<vspace blankLines="0"/>
   /multistatus/response/propstat/error, 409 Conflict (postcondition)</t><t>Purpose: The query includes an XPath expression that raises an error.</t><t>(see <xref target="XPath-errors" pageno="false" format="default"/>.)</t></section><section title="DAV:search-scope-valid" toc="default"><iref item="Element" subitem="DAV:search-scope-valid" primary="false"/><t><vspace blankLines="0"/></t><t>Type:  precondition</t><t>Use with: /error, 409 Conflict</t><t>Defined in <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/></t></section><section title="XS:known-literal-type" toc="default"><iref item="Element" subitem="XS:known-literal-type" primary="false"/><t><vspace blankLines="0"/></t><t>Type:  precondition</t><t>Use with: /error, 422 Unprocessable Entity</t><t>Purpose: The query includes a DAV:typed-literal which specifies an unknown data-type. 
The data-type name is included into the element content.</t><t><figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!ELEMENT XS:known-literal-type #PCDATA>
]]></artwork></figure></t></section></section></section><section title="Query Schema for XS:xml-search" anchor="QSD" toc="default"><t>The query schema provides information about the set of available properties and implemented operators.</t><t>The query schema is marshaled within a XS:xml-search-schema element. This element contains an unordered set of
property descriptions (DAV:propdesc) and operator description rules (XS:opdesc-rule).</t><iref item="Element" subitem="XS:xml-search-schema" primary="false"/><iref item="Element" subitem="DAV:propdesc" primary="false"/><iref item="Element" subitem="XS:selectable" primary="false"/><iref item="Element" subitem="XS:searchable" primary="false"/><iref item="Element" subitem="XS:sortable" primary="false"/><t> 
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!ELEMENT XS:xml-search-schema  (propdesc|XS:opdesc-rule)* ) >
]]></artwork></figure></t><section title="Property descriptions" anchor="QSD-prop" toc="default"><t>The semantics of DAV:propdesc, when used within a XS:xml-search-schema is extended for describing 
whether a property may be used as root element of a XPath expression within a XS:filter element.</t><t>
Since XS:filter may appear in three different places (the record-set definition, the query criteria and the ordering criteria), 
the server may allow or disallow it on a separate basis. If XS:selectable, XS:searchable or XS:sortable is present, then the server MUST allow 
this property to be used within a XS:filter element in the applicable context (role)
</t><t><figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!ELEMENT propdesc           (prop|any-other-property), datatype?,
                             (searchable | XS:searchable)?,
                             (selectable | XS:selectable)?,
                             (sortable   | XS:sortable?),
                              caseless?,   XS:axis* >


<!ELEMENT XS:selectable       EMPTY >
<!ELEMENT XS:searchable       EMPTY >
<!ELEMENT XS:sortable         EMPTY >

<!ELEMENT XS:axis EMPTY>
<!ATTLIST XS:axis name (namespace | parent  | ancestor 
                  | preceding-sibling  | following-sibling 
                  | descendant-or-self | ancestor-or-self 
                  | preceding | following) #REQUIRED>
]]></artwork></figure></t><t>Properties which are XS:selectable or XS:searchable are also DAV:selectable or DAV:searchable respectively.
For instance, if a property may be selected through a XPath expression then it is plainly selectable,
and if a property may be used within a XS:filter query criterion then it may be used as an operand of DAV:is-defined, DAV:is-well-formed. 
</t><t>
Properties which are XS:sortable are not DAV:sortable, because comparison of complex types is undefined.
Properties MUST NOT be DAV:sortable and XS:sortable at the same time. </t><t>
The server MUST allow described properties to be used in the role for which they were advertised.
This hint does not assert whether the property is defined on every resource in the scope,
and does not assert whether the property value is well-formed XML.
</t><t>There SHOULD be one description for DAV:any-other-property. There MUST NOT be
more than one description for each property, and one description for DAV:any-other-property.
</t><t>The "name" attribute of the XS:axis element specifies the name of an optional axis which is supported 
for the property being described.</t></section><section title="Operator descriptions" anchor="QSD-op" toc="default"><t>
Operators are described in a way that borrows some elements from ABNF <xref target="RFC4234" pageno="false" format="default"/> (namely repetitions and alternatives).
This approach allows a flexible and compact description of operators.

<cref anchor="note-opdesc">
The operator description is only intended for discovering whether the server implements an extension operator.
The DAV:operators element from [I-D.reschke-webdav-search] is not adopted here, 
because it cannot describe the mandatory operators.
On the other hand, while XML Schemas would have sufficed for this purpose, 
this approach would have required XS:xml-search clients to be in conformance
to the XML Representation of Schemas,
which is much more than necessary for achieving the above mentioned goal
(given that the operators are not too complex).
The chosen approach is compared to ABNF, in order to avoid further relation with features
that are available in XML schemas. 
</cref>
</t><iref item="Element" subitem="XS:operator" primary="false"/><iref item="Element" subitem="XS:operand-XPath" primary="false"/><iref item="Element" subitem="XS:operand-nested-op" primary="false"/><iref item="Element" subitem="XS:opdesc-rule" primary="false"/><iref item="Element" subitem="XS:alternative" primary="false"/><iref item="Element" subitem="XS:repetition" primary="false"/><t>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!-- "XS:operator" element -->
<!ELEMENT XS:operator             EMPTY               >
<!ATTLIST XS:operator name        NAME   #REQUIRED    >
<!ATTLIST XS:operator namespace   CDATA  
   "urn:ietf:params:xml:ns:webdav-xml-search"         >


<!-- terminal elements -->
<!ENTITY  % XS:terminal       (operand-literal| 
                               operand-typed-literal| 
                               operand-property|
                               XS:operand-XPath|
                               XS:operand-nested-op) >

<!ELEMENT XS:operand-XPath       EMPTY>
<!ELEMENT XS:operand-nested-op   EMPTY>

<!-- content model description-->
<!ELEMENT XS:opdesc-rule (XS:operator+,
                         (XS:alternative|XS:repetition|%terminal;)*
)>

<!ELEMENT XS:alternative (XS:repetition|%terminal;)>

<!ELEMENT XS:repetition  (XS:alternative|XS:repetition|%terminal;)* >
<!ATTLIST XS:repetition   atleast    CDATA "0" >
<!ATTLIST XS:repetition   atmost     CDATA "infinity" >
]]></artwork></figure></t><section title="XS:opdesc-rule and XS:operator" anchor="DAV:opdesc" toc="default"><t>XS:operator references the name of an operator. Several operators may be defined by the same XS:opdesc-rule, and 
several XS:opdesc-rule may define incremental alternatives (that is, an initial rule may match one or more
alternatives, with later rule definitions adding to the set of alternatives, as in the ABNF construction Rule1 =/ Rule2 defined in
section 3.3 of <xref target="RFC4234" pageno="false" format="default"/>).
</t><t>

For instance,

<iref item="Example" subitem="XS:opdesc-rule" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
  <opdesc-rule>
    <operator name="lt" namespace="DAV:"/>
    <operator name="gt" namespace="DAV:"/>
    <operand-property/>
    <alternative>
      <operand-literal/>
      <operand-typed-literal/>
    </alternative>
  </opdesc-rule>
]]></artwork></figure> 

is equivalent to

<iref item="Example" subitem="XS:opdesc-rule" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
  <opdesc-rule>
    <operator name="lt" namespace="DAV:"/>
    <operand-property/>
    <operand-literal/>
  </opdesc-rule>
  
  <opdesc-rule>
    <operator name="lt" namespace="DAV:"/>
    <operand-property/>
    <operand-typed-literal/>
  </opdesc-rule>
  
  <opdesc-rule>
    <operator name="gt" namespace="DAV:"/>
    <operand-property/>
    <operand-literal/>
  </opdesc-rule>
  
  <opdesc-rule>
    <operator name="gt" namespace="DAV:"/>
    <operand-property/>
    <operand-typed-literal/>
  </opdesc-rule>      
]]></artwork></figure>
</t><t>
Mandatory operators SHOULD be omitted from the actual schema returned by a server (since their grammar is implied).
If an operator is defined or enhanced by an extension of this protocol, the server MUST return rules 
(i.e. one or more XS:opdesc-rule elements) for them. If the enhanced operator is a mandatory one, then the alternative rule applies. Hence, if
the response includes 

<iref item="Example" subitem="XS:opdesc-rule" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
  <opdesc-rule>
    <operator name="eq" namespace="DAV:"/>
    <operand-property/>
    <FOO:operand-bar xmlns:FOO="http://foo.example/"/>
  </opdesc-rule>
]]></artwork></figure>

it means that the DAV:eq operator accepts a pair of (property, foo:bar) operands, 
as well as it accepts the above-defined (property, literal) and (property, typed-literal) alternatives (from the implicit grammar).
</t><t>The order in which operands are described is significant, 
because the ordering of operands within a expression is significant.</t></section><section title="XS:repetition" toc="default"><t>The semantics of element XS:repetition is similar to the ABNF Variable Repetition (e.g: *Rule) defined in Section 3.6 of <xref target="RFC4234" pageno="false" format="default"/>.</t><t>The optional attributes "atleast" and "atmost" indicates minimum and maximum allowed occurrences of the described content.</t><t>Default values are atleast="0" and atmost="infinity" so that 
&lt;XS:repetition&gt; allows any number of occurrences, including zero;
&lt;XS:repetition atleast="1"&gt; requires at least one, with no upper limit;
&lt;XS:repetition atleast="3" atmost="3"&gt; allows exactly 3 and 
&lt;XS:repetition atleast="1" atmost="2"&gt; allows one or two.
</t></section><section title="XS:alternative" toc="default"><t>The semantics of element XS:alternative is similar to the ABNF Alternatives (e.g: Rule1 / Rule2) defined in Section 3.2 of <xref target="RFC4234" pageno="false" format="default"/>.</t><t>For instance, &lt;XS:alternative&gt; &lt;XS:operand-literal/&gt; &lt;XS:operand-typed-literal/&gt; &lt;/XS:alternative&gt; will accept either 
an operand-typed-literal or an operand-literal but not both.
</t></section><section title="Implied operator description" anchor="query-schema" toc="default"><t>The following query schema describes the operators specified in this document, 
as well as the operators from <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>,
as they would be reported in a QSD response.</t><t>
This description is implied, i.e. servers SHOULD NOT include it in the response 
because these operators with these signatures are mandatory. 
</t><t><iref item="Example" subitem="Implied operator description" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<xsl-search-schema xmlns="DAV:"
  
  <XS:opdesc-rule>
    <XS:operator name="eq"  namespace="DAV:"/>
    <XS:operator name="gt"  namespace="DAV:"/>
    <XS:operator name="lt"  namespace="DAV:"/>
    <XS:operator name="lte" namespace="DAV:"/>
    <XS:operator name="gte" namespace="DAV:"/>
    <operand-property/>
    <operand-literal/>
  </XS:opdesc-rule>
  
  <XS:opdesc-rule>
    <XS:operator name="not" namespace="DAV:"/>
    <XS:operand-nested-op/>
  </XS:opdesc-rule>

  <XS:opdesc-rule>
    <XS:operator name="and" namespace="DAV:"/>
    <XS:operator name="or"  namespace="DAV:"/>  
    <XS:repetition atleast="1">
      <XS:operand-nested-op/>
    </XS:repetition>
  </XS:opdesc-rule>
    
  <XS:opdesc-rule>
    <XS:operator name="filter"/>
    <operand-property/>
    <XS:operand-XPath/>
  </XS:opdesc-rule>

  <XS:opdesc-rule>
    <XS:operator name="is-defined" namespace="DAV:"/>
    <XS:operator name="is-well-formed"/>
    <operand-property/>
  </XS:opdesc-rule>
  
  <XS:opdesc-rule>
    <XS:operator name="is-collection" namespace="DAV:"/>
  </XS:opdesc-rule>
   
</xsl-search-schema>
]]></artwork></figure>
</t><t>The DAV:is-collection operator is supported because XS:xml-search extends DAV:basicsearch grammar. 
It can be expressed  by using XS:filter as:</t><t>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
 <XS:filter>
  <prop><resourcetype/></prop>
  <XS:xpath>/collection</XS:xpath>
 </XS:filter>
]]></artwork></figure>
</t><t>Tests for other resource types, as well as test for no resource type 
may be expressed by the XS:filter operator (provided that DAV:resourcetype is XS:searchable).
For instance, testing whether a resource has no resource type may be expressed as:
</t><t>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
 <XS:filter>
  <prop><resourcetype/></prop>
  <XS:xpath>count(/*)==0</XS:xpath>
 </XS:filter> 
]]></artwork></figure>
</t></section><section title="Extended operator description for DAV:typed-literal Operand" toc="default"><t>The DAV:eq, DAV:gt, DAV:lt, DAV:lte, and DAV:gte operators 
MAY accept a DAV:typed-literal operand, instead of DAV:literal. 
This alternative is not implied (i.e. if supported, it MUST be included in the QSD response). 
If  DAV:typed-literal were supported (as defined in <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>),
the QSD response would include the following rule:
</t><t><iref item="Example" subitem="Extended operator description for DAV:typed-literal operand" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
  <XS:opdesc-rule>
    <XS:operator name="eq"  namespace="DAV:"/>
    <XS:operator name="gt"  namespace="DAV:"/>
    <XS:operator name="lt"  namespace="DAV:"/>
    <XS:operator name="lte" namespace="DAV:"/>
    <XS:operator name="gte" namespace="DAV:"/>
    <operand-property/>
    <operand-typed-literal/>
  </XS:opdesc-rule>
]]></artwork></figure>
</t><section title="Description of DAV:like Operator" toc="default"><t>If the DAV:like operator is supported (as described in Section 5.2.2 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>, 
the following rule MUST be included in the QSD:</t><t><iref item="Example" subitem="Description of DAV:like Operator" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
  <XS:opdesc-rule>
    <XS:operator name="like"  namespace="DAV:"/>
    <operand-property/>    
    <operand-literal/>
  </XS:opdesc-rule>
]]></artwork></figure>
</t></section></section></section></section><section title="XML Extensibility" anchor="extensibility" toc="default"><t>
The extensibility mechanism from Section 17 of <xref target="RFC4918" pageno="false" format="default"/> 
(i.e., to process received XML documents as if unexpected elements and attributes, 
and all children of unrecognized elements, were not present)
may be inappropriate when dealing with queries 
because they would not be evaluated as specified by the client 
(e.g. the query criteria may be loosen or the result record or may be incomplete).
The omission of unexpected content might not be realized by the client.
</t><t>The extension attribute provides a mean for distinguishing whether the extension was recognized or ignored,
raising a precondition error in the latter case. The attribute value MUST be either "required" or "optional". 
For conformance with <xref target="RFC4918" pageno="false" format="default"/> and Section 5.2.2 of <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>, 
when this attribute is not specified its value defaults to "required" when the element occurs as a descendant of DAV:where, 
and "optional" anywhere else.  
</t><t>
Any element allows the following attributes (where "..." represents the element type name):
<iref item="Attribute" subitem="extension" primary="false"/>
<iref item="Attribute" subitem="id" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!ATTLIST ... extension (required|optional) #IMPLIED>
<!ATTLIST ... id         ID                 #IMPLIED>
]]></artwork></figure>
</t><t>
When an unexpected or unknown element is present in the request, the server MUST:<vspace blankLines="0"/> 
   - Ignore it (and its descendants), 
if the value of the "extension" attribute for that element is "optional" (or the 
"extension" attribute is missing and the element is not a descendant of DAV:where). 
The request is then processed as if the element were not there.<vspace blankLines="0"/> 
   - Fail with status code 422 (Unprocessable Entity) and precondition code XS:unexpected-content,
if the value of the "extension" attribute for that element is "required" 
(or if there is no "extension" attribute and the element is a descendant of DAV:where).
In this case, the attrname attribute of XS:unexpected-content MUST NOT be specified.
If the element has an "id" attribute, the idref attribute of the XS:unexpected-content precondition 
MUST be the element id, otherwise the "idref" attribute MUST NOT be specified.
</t><t>
When an unexpected or unknown attribute occurs within an expected element, 
the server MUST proceed as if the element itself were unexpected or unknown. 
In addition, if the element is required (as explained above), 
the attrname attribute of the XS:unexpected-content precondition 
MUST be assigned with the name of the offending attribute.
</t><t>
<iref item="Element" subitem="XS:unexpected-content" primary="false"/>
<iref item="Attribute" subitem="idref (XS:unexpected-content element)" primary="false"/>
<iref item="Attribute" subitem="attrname (XS:unexpected-content element)" primary="false"/>
<figure title="" align="left" alt="" width="" height=""><artwork type="text/xml" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
<!ELEMENT XS:unexpected-content EMPTY>
<!ATTLIST XS:unexpected-content idref    NMTOKEN #IMPLIED>
<!ATTLIST XS:unexpected-content attrname NMTOKEN #IMPLIED>
]]></artwork></figure>
If present, the idref attribute MUST match the value of some ID attribute in the request.
</t></section><section title="Security Considerations" toc="default"><t>The security considerations of WebDAV SEARCH <xref target="I-D.reschke-webdav-search" pageno="false" format="default"/>, 
and WebDAV <xref target="RFC4918" pageno="false" format="default"/>, as well as those of HTTP/1.1 <xref target="RFC2616" pageno="false" format="default"/>
and XML <xref target="RFC3023" pageno="false" format="default"/> are applicable to the WebDAV extension described in this document.
</t></section><section title="IANA Considerations" toc="default"><t>This document defines XML elements in a XML namespace described by a URN 
conforming the registry mechanism described in <xref target="RFC3688" pageno="false" format="default"/>.
The following URI assignment is requested
</t><t>URI: urn:ietf:params:xml:ns:webdav-xml-search</t><t>Registrant Contact: See the "Author's Address" section of this document.</t><t>XML: None.  Namespace URIs do not represent an XML specification.</t><t>Reference: The last version of this document. </t></section></middle><back><references title="Normative References"><reference anchor="RFC2119"><front><title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title><author initials="S." surname="Bradner" fullname="Scott Bradner"><organization>Harvard University</organization><address><postal><street>1350 Mass. Ave.</street><street>Cambridge</street><street>MA 02138</street></postal><phone>- +1 617 495 3864</phone><email>sob@harvard.edu</email></address></author><date year="1997" month="March"/><area>General</area><keyword>keyword</keyword><abstract><t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list><t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t><t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front><seriesInfo name="BCP" value="14"/><seriesInfo name="RFC" value="2119"/><format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/><format type="HTML" octets="17491" target="http://xml.resource.org/public/rfc/html/rfc2119.html"/><format type="XML" octets="5777" target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"/></reference><reference anchor="RFC4918"><front><title>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</title><author initials="L." surname="Dusseault" fullname="L. Dusseault"><organization/></author><date year="2007" month="June"/><abstract><t>Web Distributed Authoring and Versioning (WebDAV) consists of a set of methods, headers, and content-types ancillary to HTTP/1.1 for the management of resource properties, creation and management of resource collections, URL namespace manipulation, and resource locking (collision avoidance).&lt;/t&gt;&lt;t&gt; RFC 2518 was published in February 1999, and this specification obsoletes RFC 2518 with minor revisions mostly due to interoperability experience. [STANDARDS TRACK]</t></abstract></front><seriesInfo name="RFC" value="4918"/><format type="TXT" octets="276352" target="ftp://ftp.isi.edu/in-notes/rfc4918.txt"/></reference><reference anchor="RFC3253"><front><title abbrev="Versioning Extensions to WebDAV">Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)</title><author initials="G." surname="Clemm" fullname="Geoffrey Clemm"><organization>Rational Software</organization><address><postal><street>20 Maguire Road</street><city>Lexington</city><region>MA</region><code>02421</code><country>US</country></postal><email>geoffrey.clemm@rational.com</email></address></author><author initials="J." surname="Amsden" fullname="Jim Amsden"><organization>IBM</organization><address><postal><street>3039 Cornwallis</street><street>Research Triangle Park</street><region>NC</region><code>27709</code><country>US</country></postal><email>jamsden@us.ibm.com</email></address></author><author initials="T." surname="Ellison" fullname="Tim Ellison"><organization>IBM</organization><address><postal><street>Hursley Park</street><city>Winchester</city><code>S021 2JN</code><country>UK</country></postal><email>tim_ellison@uk.ibm.com</email></address></author><author initials="C." surname="Kaler" fullname="Christopher Kaler"><organization>Microsoft</organization><address><postal><street>One Microsoft Way</street><city>Redmond</city><region>WA</region><code>90852</code><country>US</country></postal><email>ckaler@microsoft.com</email></address></author><author initials="J." surname="Whitehead" fullname="Jim Whitehead"><organization abbrev="U.C. Santa Cruz">UC Santa Cruz, Dept. of Computer Science</organization><address><postal><street>1156 High Street</street><city>Santa Cruz</city><region>CA</region><code>95064</code><country>US</country></postal><email>ejw@cse.ucsc.edu</email></address></author><date year="2002" month="March"/><abstract><t>
   This document specifies a set of methods, headers, and resource types
   that define the WebDAV (Web Distributed Authoring and Versioning)
   versioning extensions to the HTTP/1.1 protocol.  WebDAV versioning
   will minimize the complexity of clients that are capable of
   interoperating with a variety of versioning repository managers, to
   facilitate widespread deployment of applications capable of utilizing
   the WebDAV Versioning services.  WebDAV versioning includes automatic
   versioning for versioning-unaware clients, version history
   management, workspace management, baseline management, activity
   management, and URL namespace versioning.
</t></abstract></front><seriesInfo name="RFC" value="3253"/><format type="TXT" octets="245514" target="ftp://ftp.isi.edu/in-notes/rfc3253.txt"/><format type="HTML" octets="429660" target="http://xml.resource.org/public/rfc/html/rfc3253.html"/><format type="XML" octets="305030" target="http://xml.resource.org/public/rfc/xml/rfc3253.xml"/></reference><reference anchor="RFC3744"><front><title abbrev="WebDAV Access Control Protocol">Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol</title><author initials="G." surname="Clemm" fullname="Geoffrey Clemm"><organization>IBM</organization><address><postal><street>20 Maguire Road</street><city>Lexington</city><region>MA</region><code>02421</code></postal><email>geoffrey.clemm@us.ibm.com</email></address></author><author initials="J. F." surname="Reschke" fullname="Julian F. Reschke"><organization abbrev="greenbytes">greenbytes GmbH</organization><address><postal><street>Salzmannstrasse 152</street><city>Muenster</city><region>NW</region><code>48159</code><country>Germany</country></postal><email>julian.reschke@greenbytes.de</email></address></author><author initials="E." surname="Sedlar" fullname="Eric Sedlar"><organization>Oracle Corporation</organization><address><postal><street>500 Oracle Parkway</street><city>Redwood Shores</city><region>CA</region><code>94065</code></postal><email>eric.sedlar@oracle.com</email></address></author><author initials="J." surname="Whitehead" fullname="Jim Whitehead"><organization abbrev="U.C. Santa Cruz">U.C. Santa Cruz, Dept. of Computer Science</organization><address><postal><street>1156 High Street</street><city>Santa Cruz</city><region>CA</region><code>95064</code></postal><email>ejw@cse.ucsc.edu</email></address></author><date year="2004" month="May"/><abstract><t>
        This document specifies a set of methods, headers, message bodies,
        properties, and reports that define Access Control extensions to the
        WebDAV Distributed Authoring Protocol.  This protocol permits a client to
        read and modify access control lists that instruct a server whether to
        allow or deny operations upon a resource (such as HyperText Transfer
        Protocol (HTTP) method invocations) by a given principal.  A lightweight
        representation of principals as Web resources supports integration of a
        wide range of user management repositories.  Search operations allow
        discovery and manipulation of principals using human names.
      </t></abstract></front><seriesInfo name="RFC" value="3744"/><format type="TXT" octets="146623" target="ftp://ftp.isi.edu/in-notes/rfc3744.txt"/><format type="HTML" octets="228863" target="http://xml.resource.org/public/rfc/html/rfc3744.html"/><format type="XML" octets="171435" target="http://xml.resource.org/public/rfc/xml/rfc3744.xml"/></reference><reference anchor="RFC2616"><front><title abbrev="HTTP/1.1">Hypertext Transfer Protocol -- HTTP/1.1</title><author initials="R." surname="Fielding" fullname="Roy T. Fielding"><organization abbrev="UC Irvine">Department of Information and Computer Science</organization><address><postal><street>University of California, Irvine</street><city>Irvine</city><region>CA</region><code>92697-3425</code></postal><facsimile>+1(949)824-1715</facsimile><email>fielding@ics.uci.edu</email></address></author><author initials="J." surname="Gettys" fullname="James Gettys"><organization abbrev="Compaq/W3C">World Wide Web Consortium</organization><address><postal><street>MIT Laboratory for Computer Science, NE43-356</street><street>545 Technology Square</street><city>Cambridge</city><region>MA</region><code>02139</code></postal><facsimile>+1(617)258-8682</facsimile><email>jg@w3.org</email></address></author><author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul"><organization abbrev="Compaq">Compaq Computer Corporation</organization><address><postal><street>Western Research Laboratory</street><street>250 University Avenue</street><city>Palo Alto</city><region>CA</region><code>94305</code></postal><email>mogul@wrl.dec.com</email></address></author><author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen"><organization abbrev="W3C/MIT">World Wide Web Consortium</organization><address><postal><street>MIT Laboratory for Computer Science, NE43-356</street><street>545 Technology Square</street><city>Cambridge</city><region>MA</region><code>02139</code></postal><facsimile>+1(617)258-8682</facsimile><email>frystyk@w3.org</email></address></author><author initials="L." surname="Masinter" fullname="Larry Masinter"><organization abbrev="Xerox">Xerox Corporation</organization><address><postal><street>MIT Laboratory for Computer Science, NE43-356</street><street>3333 Coyote Hill Road</street><city>Palo Alto</city><region>CA</region><code>94034</code></postal><email>masinter@parc.xerox.com</email></address></author><author initials="P." surname="Leach" fullname="Paul J. Leach"><organization abbrev="Microsoft">Microsoft Corporation</organization><address><postal><street>1 Microsoft Way</street><city>Redmond</city><region>WA</region><code>98052</code></postal><email>paulle@microsoft.com</email></address></author><author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee"><organization abbrev="W3C/MIT">World Wide Web Consortium</organization><address><postal><street>MIT Laboratory for Computer Science, NE43-356</street><street>545 Technology Square</street><city>Cambridge</city><region>MA</region><code>02139</code></postal><facsimile>+1(617)258-8682</facsimile><email>timbl@w3.org</email></address></author><date year="1999" month="June"/><abstract><t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers . A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t><t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front><seriesInfo name="RFC" value="2616"/><format type="TXT" octets="422317" target="ftp://ftp.isi.edu/in-notes/rfc2616.txt"/><format type="PS" octets="5529857" target="ftp://ftp.isi.edu/in-notes/rfc2616.ps"/><format type="PDF" octets="550558" target="ftp://ftp.isi.edu/in-notes/rfc2616.pdf"/><format type="HTML" octets="636125" target="http://xml.resource.org/public/rfc/html/rfc2616.html"/><format type="XML" octets="493420" target="http://xml.resource.org/public/rfc/xml/rfc2616.xml"/></reference><reference anchor="RFC3023"><front><title>XML Media Types</title><author initials="M." surname="Murata" fullname="M. Murata"><organization/></author><author initials="S." surname="St. Laurent" fullname="S. St. Laurent"><organization/></author><author initials="D." surname="Kohn" fullname="D. Kohn"><organization/></author><date year="2001" month="January"/><abstract><t>This document standardizes five new media types -- text/xml, application/xml, text/xml-external-parsed-entity, application/xml- external-parsed-entity, and application/xml-dtd -- for use in exchanging network entities that are related to the Extensible Markup Language (XML).  This document also standardizes a convention (using the suffix '+xml') for naming media types outside of these five types when those media types represent XML MIME (Multipurpose Internet Mail Extensions) entities. [STANDARDS TRACK]</t></abstract></front><seriesInfo name="RFC" value="3023"/><format type="TXT" octets="86011" target="ftp://ftp.isi.edu/in-notes/rfc3023.txt"/></reference><reference anchor="RFC3688"><front><title>The IETF XML Registry</title><author initials="M." surname="Mealling" fullname="M. Mealling"><organization/></author><date year="2004" month="January"/><abstract><t>This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas.</t></abstract></front><seriesInfo name="BCP" value="81"/><seriesInfo name="RFC" value="3688"/><format type="TXT" octets="17325" target="ftp://ftp.isi.edu/in-notes/rfc3688.txt"/></reference><reference anchor="RFC4790"><front><title>Internet Application Protocol Collation Registry</title><author initials="C." surname="Newman" fullname="C. Newman"><organization/></author><author initials="M." surname="Duerst" fullname="M. Duerst"><organization/></author><author initials="A." surname="Gulbrandsen" fullname="A. Gulbrandsen"><organization/></author><date year="2007" month="March"/><abstract><t>Many Internet application protocols include string-based lookup, searching, or sorting operations.  However, the problem space for searching and sorting international strings is large, not fully explored, and is outside the area of expertise for the Internet Engineering Task Force (IETF).  Rather than attempt to solve such a large problem, this specification creates an abstraction framework so that application protocols can precisely identify a comparison function, and the repertoire of comparison functions can be extended in the future. [STANDARDS TRACK]</t></abstract></front><seriesInfo name="RFC" value="4790"/><format type="TXT" octets="55591" target="ftp://ftp.isi.edu/in-notes/rfc4790.txt"/></reference><reference anchor="I-D.reschke-webdav-search"><front><title>Web Distributed Authoring and Versioning (WebDAV) SEARCH</title><author initials="J" surname="Reschke" fullname="Julian Reschke"><organization/></author><date month="November" day="15" year="2007"/><abstract><t>This document specifies a set of methods, headers, properties and content-types composing WebDAV SEARCH, an application of the HTTP/1.1 protocol to efficiently search for DAV resources based upon a set of client-supplied criteria.</t></abstract></front><seriesInfo name="Internet-Draft" value="draft-reschke-webdav-search-14"/><format type="TXT" target="http://www.ietf.org/internet-drafts/draft-reschke-webdav-search-14.txt"/></reference><reference anchor="W3C.PR-xpath20-20061121" target="http://www.w3.org/TR/2006/PR-xpath20-20061121"><front><title>XML Path Language (XPath) 2.0</title><author initials="A." surname="Berglund" fullname="Anders Berglund"><organization/></author><author initials="S." surname="Boag" fullname="Scott Boag"><organization/></author><author initials="D." surname="Chamberlin" fullname="Don Chamberlin"><organization/></author><author initials="M." surname="Fernández" fullname="Mary F. Fernández"><organization/></author><author initials="M." surname="Kay" fullname="Michael Kay"><organization/></author><author initials="J." surname="Robie" fullname="Jonathan Robie"><organization/></author><author initials="J." surname="Siméon" fullname="Jérôme Siméon"><organization/></author><date month="November" day="21" year="2006"/></front><seriesInfo name="World Wide Web Consortium PR" value="PR-xpath20-20061121"/><format type="HTML" target="http://www.w3.org/TR/2006/PR-xpath20-20061121"/></reference><reference anchor="W3C.REC-xml11-20060816" target="http://www.w3.org/TR/2006/REC-xml11-20060816"><front><title>Extensible Markup Language (XML) 1.1 (Second Edition)</title><author initials="E." surname="Maler" fullname="Eve Maler"><organization/></author><author initials="C." surname="Sperberg-McQueen" fullname="C. M. Sperberg-McQueen"><organization/></author><author initials="J." surname="Cowan" fullname="John Cowan"><organization/></author><author initials="J." surname="Paoli" fullname="Jean Paoli"><organization/></author><author initials="T." surname="Bray" fullname="Tim Bray"><organization/></author><author initials="F." surname="Yergeau" fullname="François Yergeau"><organization/></author><date month="August" day="16" year="2006"/></front><seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xml11-20060816"/><format type="HTML" target="http://www.w3.org/TR/2006/REC-xml11-20060816"/></reference><reference anchor="W3C.REC-xml-names11-20060816" target="http://www.w3.org/TR/2006/REC-xml-names11-20060816"><front><title>Namespaces in XML 1.1 (Second Edition)</title><author initials="D." surname="Hollander" fullname="Dave Hollander"><organization/></author><author initials="A." surname="Layman" fullname="Andrew Layman"><organization/></author><author initials="R." surname="Tobin" fullname="Richard Tobin"><organization/></author><author initials="T." surname="Bray" fullname="Tim Bray"><organization/></author><date month="August" day="16" year="2006"/></front><seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xml-names11-20060816"/><format type="HTML" target="http://www.w3.org/TR/2006/REC-xml-names11-20060816"/></reference><reference anchor="W3C.REC-xmlschema-2-20041028" target="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028"><front><title>XML Schema Part 2: Datatypes Second Edition</title><author initials="A." surname="Malhotra" fullname="Ashok Malhotra"><organization/></author><author initials="P." surname="Biron" fullname="Paul V. Biron"><organization/></author><date month="October" day="28" year="2004"/></front><seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xmlschema-2-20041028"/><format type="HTML" target="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028"/></reference></references><references title="Informative References"><reference anchor="RFC4234"><front><title abbrev="ABNF">Augmented BNF for Syntax Specifications: ABNF</title><author fullname="Dave Crocker" initials="D." role="editor" surname="Crocker"><organization>Brandenburg InternetWorking</organization><address><postal><street>675 Spruce Dr.</street><city>Sunnyvale</city><region>CA</region><code>94086</code><country>US</country></postal><phone>+1.408.246.8253</phone><email>dcrocker@bbiw.net</email></address></author><author fullname="Paul Overell" initials="P." surname="Overell"><organization>THUS plc.</organization><address><postal><street>1/2 Berkeley Square, </street><street>99 Berkeley Street</street><city>Glasgow</city><code>G3 7HR</code><country>UK</country></postal><email>paul.overell@thus.net</email></address></author><date year="2005" month="October"/><keyword>ABNF</keyword><keyword>Augmented</keyword><keyword>Backus-Naur</keyword><keyword>Form</keyword><keyword>electronic</keyword><keyword>mail</keyword><abstract><t>Internet technical specifications often need to define a formal	
			syntax.  Over the years, a modified version of Backus-Naur Form	
			(BNF), called Augmented BNF (ABNF), has been popular among many	
			Internet specifications.  The current specification documents ABNF.	
			It balances compactness and simplicity, with reasonable	
			representational power.  The differences between standard BNF and	
			ABNF involve naming rules, repetition, alternatives, order-	
			independence, and value ranges.  This specification also supplies	
			additional rule definitions and encoding for a core lexical analyzer	
			of the type common to several Internet specifications.
      </t></abstract></front><seriesInfo name="RFC" value="4234"/><format type="TXT" octets="26351" target="ftp://ftp.isi.edu/in-notes/rfc4234.txt"/><format type="HTML" octets="52334" target="http://xml.resource.org/public/rfc/html/rfc4234.html"/><format type="XML" octets="37285" target="http://xml.resource.org/public/rfc/xml/rfc4234.xml"/></reference></references><section title="Example XS:xml-search query" toc="default"><t>
This example shows a request/response exchange 
for selecting the DAV:getcontentlength property 
and the &lt;M:title&gt; and first &lt;M:author&gt; elements of the &lt;M:metadata&gt; property,
from resources which are directly contained in the http://host.example.com/ collection,
such that the title (as described by a M:title element within the M:metadata property)
starts with letter "S". The first results will have at least one M:author element present.
</t><t>
The response describes two resources:<vspace blankLines="0"/> 
   - foo.pdf, with DAV:getcontentlength = 65536, author = "John Doe" and title = "Sample Title"<vspace blankLines="0"/>
   - bar.txt, with DAV:getcontentlength = 1024, title = "Sample Anonymous Resource" and no author.<vspace blankLines="0"/>
</t><t>
Request: 
<figure title="" align="left" alt="" width="" height=""><artwork type="message/http" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
SEARCH / HTTP/1.1
Host: host.example.com
Content-Type: application/xml
Content-Length: xxx

<XS:xml-search xmlns="DAV:"
   xmlns:XS="urn:ietf:params:xml:ns:webdav-xml-search"
   xmlns:M ="http://example.org/metadata">
  <select>
    <XS:filter>
      <prop><M:metadata/></prop>
      <XS:xpath>/M:author[1]|/M:title</XS:xpath>
    </XS:filter>
    <prop><getcontentlength/></prop>
  </select>
  <from>
    <scope>
      <href>http://host.example.com/</href>
      <depth>1<depth>
    </scope> 
  </from>
  <where>
    <XS:filter>
      <prop><M:metadata/></prop>
      <XS:xpath>starts-with(/M:title,'S')</XS:xpath>
    </XS:filter>
  </where>
  <orderby>
    <order>
      <XS:filter>
        <prop><M:metadata/></prop>
        <XS:xpath>/M:author</XS:xpath>   
      </XS:filter>
      <descending>
    </order>
  </orderby>
</XS:xml-search>
]]></artwork></figure>
</t><t>
Response:
<figure title="" align="left" alt="" width="" height=""><artwork type="message/http" xml:space="preserve" name="" align="left" alt="" width="" height=""><![CDATA[
HTTP/1.1 207 Multi-Status
Content-Type: text/xml; charset="utf-8"
Content-Length: xxx

<multistatus xmlns="DAV:"
   xmlns:XS="urn:ietf:params:xml:ns:webdav-xml-search"
   xmlns:M ="http://example.org/metadata" >
  <response>
    <href>http://host.example.com/foo.pdf</href>
    <propstat>
      <prop>
        <getcontentlength>65536</getcontentlength>
        <M:metadata>
          <M:author>John Doe</M:author>
          <M:title>Sample title</M:title>
        </M:metadata>      
      </prop>
      <status>HTTP/1.1 200 OK<status>    
    </propstat>
  </response>  
  <response>
    <href>http://host.example.com/bar.txt</href>
    <propstat>
      <prop>
        <getcontentlength>1024</getcontentlength>
        <M:metadata>
          <M:title>Sample Anonymous Resource</M:title>
        </M:metadata>      
      </prop>
      <status>HTTP/1.1 200 OK<status>    
    </propstat>
  </response>  
</multistatus>  
]]></artwork></figure>
</t></section></back></rfc>