<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc authorship="yes"?>
<?rfc tocappendix="yes"?>
<rfc category="std" docName="draft-ietf-roll-rpl-07" ipr="trust200902">
  <front>
    <title abbrev="draft-ietf-roll-rpl-07">RPL: IPv6 Routing Protocol for Low
    power and Lossy Networks</title>

    <author fullname="Tim Winter" initials="T" role="editor" surname="Winter">
      <organization></organization>

      <address>
        <email>wintert@acm.org</email>
      </address>
    </author>

    <author fullname="Pascal Thubert" initials="P" role="editor"
            surname="Thubert">
      <organization abbrev="Cisco Systems">Cisco Systems</organization>

      <address>
        <postal>
          <street>Village d'Entreprises Green Side</street>

          <street>400, Avenue de Roumanille</street>

          <street>Batiment T3</street>

          <city>Biot - Sophia Antipolis</city>

          <code>06410</code>

          <country>FRANCE</country>
        </postal>

        <phone>+33 497 23 26 34</phone>

        <email>pthubert@cisco.com</email>
      </address>
    </author>

    <author fullname="ROLL Design Team" initials="" surname="ROLL Design Team">
      <organization>IETF ROLL WG</organization>

      <address>
        <email>rpl-authors@external.cisco.com</email>
      </address>
    </author>

    <date day="8" month="March" year="2010" />

    <area>Routing Area</area>

    <workgroup>Networking Working Group</workgroup>

    <keyword>Draft</keyword>

    <abstract>
      <t>Low power and Lossy Networks (LLNs) are a class of network in which
      both the routers and their interconnect are constrained: LLN routers
      typically operate with constraints on (any subset of) processing power,
      memory and energy (battery), and their interconnects are characterized
      by (any subset of) high loss rates, low data rates and instability. LLNs
      are comprised of anything from a few dozen and up to thousands of LLN
      routers, and support point-to-point traffic (between devices inside the
      LLN), point-to-multipoint traffic (from a central control point to a
      subset of devices inside the LLN) and multipoint-to-point traffic (from
      devices inside the LLN towards a central control point). This document
      specifies the IPv6 Routing Protocol for LLNs (RPL), which provides a
      mechanism whereby multipoint-to-point traffic from devices inside the
      LLN towards a central control point, as well as point-to-multipoint
      traffic from the central control point to the devices inside the LLN, is
      supported. Support for point-to-point traffic is also available.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Low power and Lossy Networks (LLNs) consist of largely of constrained
      nodes (with limited processing power, memory, and sometimes energy when
      they are battery operated). These routers are interconnected by lossy
      links, typically supporting only low data rates, that are usually
      unstable with relatively low packet delivery rates. Another
      characteristic of such networks is that the traffic patterns are not
      simply unicast, but in many cases point-to-multipoint or
      multipoint-to-point. Furthermore such networks may potentially comprise
      up to thousands of nodes. These characteristics offer unique challenges
      to a routing solution: the IETF ROLL Working Group has defined
      application-specific routing requirements for a Low power and Lossy
      Network (LLN) routing protocol, specified in <xref
      target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
      target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
      target="RFC5673"></xref>, and <xref target="RFC5548"></xref>. This
      document specifies the IPv6 Routing Protocol for Low power and lossy
      networks (RPL).</t>

      <section title="Design Principles">
        <t>RPL was designed with the objective to meet the requirements
        spelled out in <xref
        target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
        target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
        target="RFC5673"></xref>, and <xref target="RFC5548"></xref>. Because
        those requirements are heterogeneous and sometimes incompatible in
        nature, the approach is first taken to design a protocol capable of
        supporting a core set of functionalities corresponding to the
        intersection of the requirements. As the RPL design evolves optional
        features may be added to address some application specific
        requirements. This is a key protocol design decision providing a
        granular approach in order to restrict the core of the protocol to a
        minimal set of functionalities, and to allow each implementation of
        the protocol to be optimized differently. All "MUST" application
        requirements that cannot be satisfied by RPL will be specifically
        listed in the Appendix A, accompanied by a justification.</t>

        <t>A network may run multiple instances of RPL concurrently. Each such
        instance may serve different and potentially antagonistic constraints
        or performance criteria. This document defines how a single instance
        operates.</t>

        <t>RPL is a generic protocol that is to be deployed by instantiating
        the generic operation described in this document with a specific
        objective function (OF) (which ties together metrics, constraints, and
        an optimization objective) to realize a desired objective in a given
        environment.</t>

        <t>A set of companion documents to this specification will provide
        further guidance in the form of applicability statements specifying a
        set of operating points appropriate to the Building Automation, Home
        Automation, Industrial, and Urban application scenarios.</t>
      </section>

      <section title="Expectations of Link Layer Type">
        <t>RPL does not rely on any particular features of a specific link
        layer technology. RPL is designed to be able to operate over a variety
        of different link layers, including but not limited to, low power
        wireless or PLC (Power Line Communication) technologies.</t>

        <t>Implementers may find <xref target="RFC3819">RFC 3819</xref> a
        useful reference when designing a link layer interface between RPL and
        a particular link layer technology.</t>
      </section>
    </section>

    <section anchor="Terminology" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>

      <t>Additionally, this document uses terminology from <xref
      target="I-D.ietf-roll-terminology"></xref>, and introduces the following
      terminology: <list hangIndent="6" style="hanging">
          <t hangText="DAG:">Directed Acyclic Graph. A directed graph having
          the property that all edges are oriented in such a way that no
          cycles exist. All edges are contained in paths oriented toward and
          terminating at one or more root nodes.</t>

          <t hangText="DAG root:">A DAG root is a node within the DAG that has
          no outgoing edges. Because the graph is acyclic, by definition all
          DAGs must have at least one DAG root and all paths terminate at a
          DAG root.</t>

          <t hangText="Destination Oriented DAG (DODAG):">A DAG rooted at a
          single destination, i.e. at a single DAG root (the DODAG root) with
          no outgoing edges.</t>

          <t hangText="DODAG root:">A DODAG root is the DAG root of a
          DODAG.</t>

          <t hangText="Rank:">The rank of a node in a DAG identifies the nodes
          position with respect to a DODAG root. The farther away a node is
          from a DODAG root, the higher is the rank of that node. The rank of
          a node may be a simple topological distance, or may more commonly be
          calculated as a function of other properties as described later.</t>

          <t hangText="DODAG parent:">A parent of a node within a DODAG is one
          of the immediate successors of the node on a path towards the DODAG
          root. The DODAG parent of a node will have a lower rank than the
          node itself. (See <xref target="RankComparison"></xref>).</t>

          <t hangText="DODAG sibling:">A sibling of a node within a DODAG is
          defined in this specification to be any neighboring node which is
          located at the same rank within a DODAG. Note that siblings defined
          in this manner do not necessarily share a common DODAG parent. (See
          <xref target="RankComparison"></xref>).</t>

          <t hangText="Sub-DODAG">The sub-DODAG of a node is the set of other
          nodes in the DODAG that might use a path towards the DODAG root that
          contains that node. Nodes in the sub-DODAG of a node have a greater
          rank than that node itself (although not all nodes of greater rank
          are necessarily in the sub-DODAG of that node). (See <xref
          target="RankComparison"></xref>).</t>

          <t hangText="DODAGID:">The identifier of a DODAG root. The DODAGID
          must be unique within the scope of a RPL Instance in the LLN.</t>

          <t hangText="DODAG Iteration:">A specific sequence number iteration
          ("version") of a DODAG with a given DODAGID.</t>

          <t hangText="RPL Instance:">A set of possibly multiple DODAGs. A
          network may have more than one RPL Instance, and a RPL node can
          participate in multiple RPL Instances. Each RPL Instance operates
          independently of other RPL Instances. This document describes
          operation within a single RPL Instance. In RPL, a node can belong to
          at most one DODAG per RPL Instance. The tuple (RPLInstanceID,
          DODAGID) uniquely identifies a DODAG.</t>

          <t hangText="RPLInstanceID:">Unique identifier of a RPL
          Instance.</t>

          <t hangText="DODAGSequenceNumber:">A sequential counter that is
          incremented by the root to form a new Iteration of a DODAG. A DODAG
          Iteration is identified uniquely by the (RPLInstanceID, DODAGID,
          DODAGSequenceNumber) tuple.</t>

          <t hangText="Up:">Up refers to the direction from leaf nodes towards
          DODAG roots, following the orientation of the edges within the
          DODAG.</t>

          <t hangText="Down:">Down refers to the direction from DODAG roots
          towards leaf nodes, going against the orientation of the edges
          within the DODAG.</t>

          <t hangText="Objective Code Point (OCP):">An identifier, used to
          indicate which Objective Function is in use for forming a DODAG. The
          Objective Code Point is further described in <xref
          target="I-D.ietf-roll-routing-metrics"></xref>.</t>

          <t hangText="Objective Function (OF):">Defines which routing
          metrics, optimization objectives, and related functions are in use
          in a DODAG. The Objective Function is further described in <xref
          target="I-D.ietf-roll-routing-metrics"></xref>.</t>

          <t hangText="Goal:">The Goal is a host or set of hosts that satisfy
          a particular application objective / OF. Whether or not a DODAG can
          provide connectivity to a goal is a property of the DODAG. For
          example, a goal might be a host serving as a data collection point,
          or a gateway providing connectivity to an external
          infrastructure.</t>

          <t hangText="Grounded:">A DODAG is said to be grounded, when the
          root can reach the Goal of the objective function.</t>

          <t hangText="Floating:">A DODAG is floating if is not Grounded. A
          floating DODAG is not expected to reach the Goal defined for the
          OF.</t>
        </list></t>

      <t>As they form networks, LLN devices often mix the roles of 'host' and
      'router' when compared to traditional IP networks. In this document,
      'host' refers to an LLN device that can generate but does not forward
      RPL traffic, 'router' refers to an LLN device that can forward as well
      as generate RPL traffic, and 'node' refers to any RPL device, either a
      host or a router.</t>
    </section>

    <section anchor="ProtocolModel" title="Protocol Overview">
      <t>The aim of this section is to describe RPL in the spirit of <xref
      target="RFC4101"></xref>. Protocol details can be found in further
      sections.</t>

      <section anchor="UpwardTopology" title="Topology">
        <t>This section describes how the basic RPL topologies, and the rules
        by which these are constructed, i.e. the rules governing DODAG
        formation.</t>

        <section anchor="TopologyIdentifiers" title="Topology Identifiers">
          <t>RPL uses four identifiers to track and control the topology:
          <list style="symbols">
              <t>The first is a RPLInstanceID. A RPLInstanceID identifies a
              set of one or more DODAGs. All DODAGs in the same RPL Instance
              use the same OF. A network may have multiple RPLInstanceIDs,
              each of which defines an independent set of DODAGs, which may be
              optimized for different OFs and/or applications. The set of
              DODAGs identified by a RPLInstanceID is called a RPL
              Instance.</t>

              <t>The second is a DODAGID. The scope of a DODAGID is a RPL
              Instance. The combination of RPLInstanceID and DODAGID uniquely
              identifies a single DODAG in the network. A RPL Instance may
              have multiple DODAGs, each of which has an unique DODAGID.</t>

              <t>The third is a DODAGSequenceNumber. The scope of a
              DODAGSequenceNumber is a DODAG. A DODAG is sometimes
              reconstructed from the DODAG root, by incrementing the
              DODAGSequenceNumber. The combination of RPLInstanceID, DODAGID,
              and DODAGSequenceNumber uniquely identifies a DODAG
              Iteration.</t>

              <t>The fourth is rank. The scope of rank is a DODAG Iteration.
              Rank establishes a partial order over a DODAG Iteration,
              defining individual node positions with respect to the DODAG
              root.</t>
            </list></t>
        </section>

        <section title="DODAG Information">
          <t>For each DODAG that a node is, or may become, a member of, the
          implementation should conceptually keep track of the following
          information. The data structures described in this section are
          intended to illustrate a possible implementation to aid in the
          description of the protocol, but are not intended to be
          normative.</t>

          <t><list style="symbols">
              <t>RPLInstanceID</t>

              <t>DODAGID</t>

              <t>DODAGSequenceNumber</t>

              <t>DAG Metric Container, including DAGObjectiveCodePoint</t>

              <t>A set of Destination Prefixes offered by the DODAG root and
              available via paths upwards along the DODAG</t>

              <t>A set of DODAG parents</t>

              <t>A set of DODAG siblings</t>

              <t>A timer to govern the sending of RPL control messages</t>
            </list></t>
        </section>
      </section>

      <section title="Instances, DODAGs, and DODAG Iterations">
        <t>Each RPL Instance constructs a routing topology optimized for a
        certain Objective Function (OF). A RPL Instance may provide routes to
        certain destination prefixes, reachable via the DODAG roots. A single
        RPL Instance contains one or more Destination Oriented DAG (DODAG)
        roots. These roots may operate independently, or may coordinate over a
        non-LLN backchannel.</t>

        <t>Each root has a unique identifier, the DODAGID<!--, such that nodes can
        identify the DODAG root-->.</t>

        <t>A RPL Instance may comprise:</t>

        <t><list style="symbols">
            <t>a single DODAG with a single root <list>
                <t>For example, a DODAG optimized to minimize latency rooted
                at a single centralized lighting controller in a home
                automation application.</t>
              </list></t>

            <t>multiple uncoordinated DODAGs with independent roots (differing
            DODAGIDs) <list>
                <t>For example, multiple data collection points in an urban
                data collection application that do not have an always-on
                backbone suitable to coordinate to form a single DODAG, and
                further use the formation of multiple DODAGs as a means to
                dynamically and autonomously partition the network.</t>
              </list></t>

            <t>a single DODAG with a single virtual root coordinating LLN
            sinks (with the same DODAGID) over some non-LLN backbone<list>
                <t>For example, multiple border routers operating with a
                reliable backbone, e.g. in support of a 6LowPAN application,
                that are capable to act as logically equivalent sinks to the
                same DODAG.</t>
              </list></t>

            <t>a combination of the above as suited to some application
            scenario.</t>
          </list></t>

        <t>Traffic is bound to a specific RPL Instance by a marking in the
        flow label of the IPv6 header. Traffic originating in support of a
        particular application may be tagged to follow an appropriate RPL
        instance which enables certain (path) properties, for example to
        follow paths optimized for low latency or low energy. The provisioning
        or automated discovery of a mapping between a RPLInstanceID and a type
        or service of application traffic is beyond the scope of this
        specification.</t>

        <t>An example of a RPL Instance comprising a number of DODAGs is
        depicted in <xref target="figInstance"></xref>. A DODAG Iteration (two
        "versions" of the same DODAG) is depicted in <xref
        target="figDODAGIteration"></xref>.</t>

        <figure anchor="figInstance" title="RPL Instance">
          <artwork><![CDATA[
 
  +----------------------------------------------------------------+
  |                                                                |
  | +--------------+                                               |
  | |              |                                               |
  | |     (R1)     |            (R2)                   (Rn)        |
  | |     /  \     |            /| \                  / |  \       |
  | |    /    \    |           / |  \                /  |   \      |
  | |  (A)    (B)  |         (C) |  (D)     ...    (F) (G)  (H)    |
  | |  /|\     |\  |         /   |   |\             |   |    |     |
  | | : : :    : : |        :   (E)  : :            :   :    :     |
  | |              |            / \                                |
  | +--------------+           :   :                               |
  |      DODAG                                                     |
  |                                                                | 
  +----------------------------------------------------------------+
                             RPL Instance                           
]]></artwork>
        </figure>

        <figure anchor="figDODAGIteration" title="DODAG Iteration">
          <artwork><![CDATA[
                                                                     
         +----------------+                +----------------+        
         |                |                |                |        
         |      (R1)      |                |      (R1)      |        
         |      /  \      |                |      /         |        
         |     /    \     |                |     /          |        
         |   (A)    (B)   |         \      |   (A)          |        
         |   /|\     |\   |    ------\     |   /|\          |        
         |  : : (C)  : :  |           \    |  : : (C)       |        
         |                |           /    |        \       |        
         |                |    ------/     |         \      |        
         |                |         /      |         (B)    |        
         |                |                |          |\    |        
         |                |                |          : :   |        
         |                |                |                |        
         +----------------+                +----------------+        
             Sequence N                       Sequence N+1           
                                                                     
]]></artwork>
        </figure>
      </section>

      <section title="Traffic Flows">
        <section title="Multipoint-to-Point Traffic">
          <t>Multipoint-to-Point (MP2P) is a dominant traffic flow in many LLN
          applications (<xref
          target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
          target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
          target="RFC5673"></xref>, <xref target="RFC5548"></xref>). The
          destinations of MP2P flows are designated nodes that have some
          application significance, such as providing connectivity to the
          larger Internet or core private IP network. RPL supports MP2P
          traffic by allowing MP2P destinations to be reached via DODAG
          roots.</t>
        </section>

        <section title="Point-to-Multipoint Traffic">
          <t>Point-to-multipoint (P2MP) is a traffic pattern required by
          several LLN applications (<xref
          target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
          target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
          target="RFC5673"></xref>, <xref target="RFC5548"></xref>). RPL
          supports P2MP traffic by using a destination advertisement mechanism
          that provisions routes toward destination prefixes and away from
          roots. Destination advertisements can update routing tables as the
          underlying DODAG topology changes.</t>
        </section>

        <section title="Point-to-Point Traffic">
          <t>RPL DODAGs provide a basic structure for point-to-point (P2P)
          traffic. For a RPL network to support P2P traffic, a root must be
          able to route packets to a destination. Nodes within the network may
          also have routing tables to destinations. A packet flows towards a
          root until it reaches an ancestor that has a known route to the
          destination.</t>

          <t>RPL also supports the case where a P2P destination is a 'one-hop'
          neighbor.</t>

          <t>RPL neither specifies nor precludes additional mechanisms for
          computing and installing more optimal routes to support arbitrary
          P2P traffic.</t>
        </section>
      </section>

      <section title="Upward Routes and DODAG Construction">
        <t>RPL provisions routes up towards DODAG roots, forming a DODAG
        optimized according to the Objective Function (OF) in use. RPL nodes
        construct and maintain these DODAGs through exchange of DODAG
        Information Object (DIO) messages. Undirected links between siblings
        are also identified during this process, which can be used to provide
        additional diversity.</t>

        <section title="DODAG Information Object (DIO)">
          <t>A DIO identifies the RPL Instance, the DODAGID, the values used
          to compute the RPL Instance's objective function, and the present
          DODAG Sequence Number. It can also include additional routing and
          configuration information. The DIO includes a measure derived from
          the position of the node within the DODAG, the rank, which is used
          for nodes to determine their positions relative to each other and to
          inform loop avoidance/detection procedures. RPL exchanges DIO
          messages to establish and maintain routes.</t>

          <t>RPL adapts the rate at which nodes send DIO messages. When a
          DODAG is detected to be inconsistent or needs repair, RPL sends DIO
          messages more frequently. As the DODAG stabilizes, the DIO message
          rate tapers off, reducing the maintenance cost of a steady and
          well-working DODAG.</t>

          <t>This document defines an ICMPv6 Message Type "RPL Control
          Message", which is capable of carrying a DIO.</t>
        </section>

        <section title="DAG Repair">
          <t>RPL supports global repair over the DODAG. A DODAG Root may
          increment the DODAG Sequence Number, thereby initiating a new DODAG
          iteration. This institutes a global repair operation, revising the
          DODAG and allowing nodes to choose an arbitrary new position within
          the new DODAG iteration.</t>

          <t>RPL supports mechanisms which may be used for local repair within
          the DODAG iteration. The DIO message specifies the necessary
          parameters as configured from the DODAG root. Local repair options
          include the allowing a node, upon detecting a loss of connectivity
          to a DODAG it is a member of, to:</t>

          <t><list style="symbols">
              <t>Poison its sub-DODAG by advertising an effective rank of
              INFINITY to its sub-DODAG, OR detach and form a floating DODAG
              in order to preserve inner connectivity within its
              sub-DODAG.</t>

              <t>Move down within the DODAG iteration (i.e. increase its rank)
              in a limited manner, no further than a bound configured by the
              DODAG root via the DIO so as not to count all the way to
              infinity. Such a move may be undertaken after waiting an
              appropriate poisoning interval, and should allow the node to
              restore connectivity to the DODAG Iteration, if at all
              possible.</t>
            </list></t>
        </section>

        <section title="Grounded and Floating DODAGs">
          <t>DODAGs can be grounded or floating. A grounded DODAG offers
          connectivity to to a goal. A floating DODAG offers no such
          connectivity, and provides routes only to nodes within the DODAG.
          Floating DODAGs may be used, for example, to preserve inner
          connectivity during repair.</t>
        </section>

        <section title="Administrative Preference">
          <t>An implementation/deployment may specify that some DODAG roots
          should be used over others through an administrative preference.
          Administrative preference offers a way to control traffic and
          engineer DODAG formation in order to better support application
          requirements or needs.</t>
        </section>

        <section title="Objective Function (OF)">
          <t>The Objective Function (OF) implements the optimization
          objectives of route selection within the RPL Instance. The OF is
          identified by an Objective Code Point (OCP) within the DIO, and its
          specification also indicates the metrics and constraints in use. The
          OF also specifies the procedure used to compute rank within a DODAG
          iteration. Further details may be found in <xref
          target="I-D.ietf-roll-routing-metrics"></xref>, <xref
          target="I-D.ietf-roll-of0"></xref>, and related companion
          specifications.</t>

          <t>By using defined OFs that are understood by all nodes in a
          particular deployment, and by referencing these in the DIO message,
          RPL nodes may work to build optimized LLN routes using a variety of
          application and implementation specific metrics and goals.</t>

          <t>In the case where a node is unable to encounter a suitable RPL
          Instance using a known Objective Function, it may be configured to
          join a RPL Instance using an unknown Objective Function - but in
          that case only acting as a leaf node.</t>
        </section>

        <section title="Distributed Algorithm Operation">
          <t>A high level overview of the distributed algorithm which
          constructs the DODAG is as follows:</t>

          <t><list style="symbols">
              <t>Some nodes are configured to be DODAG roots, with associated
              DODAG configuration.</t>

              <t>Nodes advertise their presence, affiliation with a DODAG,
              routing cost, and related metrics by sending link-local
              multicast DIO messages.</t>

              <t>Nodes may adjust the rate at which DIO messages are sent in
              response to stability or detection of routing
              inconsistencies.</t>

              <t>Nodes listen for DIOs and use their information to join a new
              DODAG, or to maintain an existing DODAG, as according to the
              specified Objective Function and rank-based loop avoidance
              rules.</t>

              <t>Nodes provision routing table entries, for the destinations
              specified by the DIO, via their DODAG parents in the DODAG
              iteration. Nodes may provision a DODAG parent as a default
              gateway.<!-- TBD:  Nodes provision routing table entries for
              the destinations specified by the DIO.  A node creates a
              separate routing table entry for each destination and DODAG
              parent that can serve as the next hop to that destination--></t>

              <t>Nodes may identify DODAG siblings within the DODAG iteration
              to increase path diversity.</t>

              <t>Using DIOs, and possibly information in data packets, RPL
              nodes detect possible routing loops. When a RPL node detects a
              possible routing loop, it may adapt its DIO transmission rate to
              apply a local repair to the topology.</t>
            </list></t>
        </section>
      </section>

      <section title="Downward Routes and Destination Advertisement">
        <t>RPL constructs and maintains DODAGs with DIO messages to establish
        upward routes: it uses Destination Advertisement Object (DAO) messages
        to establish downward routes along the DODAG as well as other routes.
        DAO messages are an optional feature for applications that require
        P2MP or P2P traffic. DIO messages advertise whether destination
        advertisements are enabled within a given DODAG.</t>

        <section title="Destination Advertisement Object (DAO)">
          <t>A Destination Advertisement Object (DAO) conveys destination
          information upwards along the DODAG so that a DODAG root (and other
          intermediate nodes) can provision downward routes. A DAO message
          includes prefix information to identify destinations, a capability
          to record routes in support of source routing, and information to
          determine the freshness of a particular advertisement.</t>

          <t>Nodes that are capable of maintaining routing state may aggregate
          routes from DAO messages that they receive before transmitting a DAO
          message. Nodes that are not capable of maintaining routing state may
          attach a next-hop address to the Reverse Route Stack contained
          within the DAO message. The Reverse Route Stack is subsequently used
          to generate piecewise source routes over regions of the LLN that are
          incapable of storing downward routing state.</t>

          <t>A special case of the DAO message, termed a no-DAO, is used to
          clear downward routing state that has been provisioned through DAO
          operation.</t>

          <t>This document defines an ICMPv6 Message Type "RPL Control
          Message", which is capable of carrying a DAO.</t>

          <section title="'One-Hop' Neighbors">
            <t>In addition to sending DAOs toward DODAG roots, RPL nodes may
            occasionally emit a link-local multicast DAO message advertising
            available destination prefixes. This mechanism allow provisioning
            a trivial 'one-hop' route to local neighbors.</t>
          </section>
        </section>
      </section>

      <section anchor="ConstrainedLLNs"
               title="Routing Metrics and Constraints Used By RPL">
        <t>Routing metrics are used by routing protocols to compute shortest
        paths. Interior Gateway Protocols (IGPs) such as IS-IS (<xref
        target="RFC5120"></xref>) and OSPF (<xref target="RFC4915"></xref>)
        use static link metrics. Such link metrics can simply reflect the
        bandwidth or can also be computed according to a polynomial function
        of several metrics defining different link characteristics; in all
        cases they are static metrics. Some routing protocols support more
        than one metric: in the vast majority of the cases, one metric is used
        per (sub)topology. Less often, a second metric may be used as a
        tie-breaker in the presence of Equal Cost Multiple Paths (ECMP). The
        optimization of multiple metrics is known as an NP complete problem
        and is sometimes supported by some centralized path computation
        engine.</t>

        <t>In contrast, LLNs do require the support of both static and dynamic
        metrics. Furthermore, both link and node metrics are required. In the
        case of RPL, it is virtually impossible to define one metric, or even
        a composite metric, that will satisfy all use cases.</t>

        <t>In addition, RPL supports constrained-based routing where
        constraints may be applied to both link and nodes. If a link or a node
        does not satisfy a required constraint, it is 'pruned' from the
        candidate list, thus leading to a constrained shortest path.</t>

        <t>The set of supported link/node constraints and metrics is specified
        in <xref target="I-D.ietf-roll-routing-metrics"></xref>.</t>

        <t>The role of the Objective Function is to specify which routing
        metrics and constraints are in use, and how these are used, in
        addition to the objectives used to compute the (constrained) shortest
        path.</t>

        <t><list hangIndent="11" style="hanging">
            <t hangText="Example 1:">Shortest path: path offering the shortest
            end-to-end delay</t>

            <t hangText="Example 2:">Constrained shortest path: the path that
            does not traverse any battery-operated node and that optimizes the
            path reliability</t>
          </list></t>

        <section title="Loop Avoidance">
          <t>RPL guarantees neither loop free path selection nor strong global
          convergence. In order to reduce control overhead, however, such as
          the cost of the count-to-infinity problem, RPL avoids creating loops
          when undergoing topology changes. Furthermore, RPL includes
          rank-based mechanisms for detecting loops when they do occur. RPL
          uses this loop detection to ensure that packets make forward
          progress within the DODAG iteration and trigger repairs when
          necessary.</t>

          <section title="Greediness and Rank-based Instabilities">
            <t>Once a node has joined a DODAG iteration, RPL disallows certain
            behaviors, including greediness, in order to prevent resulting
            instabilities in the DODAG iteration.</t>

            <t>If a node is allowed to be greedy and attempts to move deeper
            in the DODAG iteration, beyond its most preferred parent, in order
            to increase the size of the parent set, then an instability can
            result.</t>

            <t>Suppose a node is willing to receive and process a DIO messages
            from a node in its own sub-DODAG, and in general a node deeper
            than itself. In this case, a possibility exists that a feedback
            loop is created, wherein two or more nodes continue to try and
            move in the DODAG iteration while attempting to optimize against
            each other. In some cases, this will result in instability. It is
            for this reason that RPL limits the cases where a node may process
            DIO messages from deeper nodes to some forms of local repair. This
            approach creates an 'event horizon', whereby a node cannot be
            influenced beyond some limit into an instability by the action of
            nodes that may be in its own sub-DODAG.</t>
          </section>

          <section title="DODAG Loops">
            <t>A DODAG loop may occur when a node detaches from the DODAG and
            reattaches to a device in its prior sub-DODAG. This may happen in
            particular when DIO messages are missed. Strict use of the DAG
            sequence number can eliminate this type of loop, but this type of
            loop may possibly be encountered when using some local repair
            mechanisms.</t>
          </section>

          <section title="DAO Loops">
            <t>A DAO loop may occur when the parent has a route installed upon
            receiving and processing a DAO message from a child, but the child
            has subsequently cleaned up the related DAO state. This loop
            happens when a no-DAO was missed and persists until all state has
            been cleaned up. RPL includes loop detection mechanisms that may
            mitigate the impact of DAO loops and trigger their repair.</t>

            <t>In the case where stateless DAO operation is used, i.e. source
            routing specifies the down routes, then DAO Loops should not occur
            on the stateless portions of the path.</t>
          </section>

          <section title="Sibling Loops">
            <t>Sibling loops could occur if a group of siblings kept choosing
            amongst themselves as successors such that a packet does not make
            forward progress. This specification limits the number of times
            that sibling forwarding may be used at a given rank, in order to
            prevent sibling loops.</t>
          </section>
        </section>

        <section anchor="DAGRank" title="Rank Properties">
          <t>The rank of a node is a scalar representation of the location of
          that node within a DODAG iteration. The rank is used to avoid and
          detect loops, and as such must demonstrate certain properties. The
          exact calculation of the rank is left to the Objective Function, and
          may depend on parents, link metrics, and the node configuration and
          policies.</t>

          <t>The rank is not a cost metric, although its value can be derived
          from and influenced by metrics. The rank has properties of its own
          that are not necessarily those of all metrics: <list hangIndent="8"
              style="hanging">
              <t hangText="Type:">Rank is an abstract scalar. Some metrics are
              boolean (e.g. grounded), others are statistical and better
              expressed as a tuple like an expected value and a variance. Some
              OCPs use not one but a set of metrics bound by a piece of
              logic.</t>

              <t hangText="Function:">Rank is the expression of a relative
              position within a DODAG iteration with regard to neighbors and
              is not necessarily a good indication or a proper expression of a
              distance or a cost to the root.</t>

              <t hangText="Stability:">The stability of the rank determines
              the stability of the routing topology. Some dampening or
              filtering might be applied to keep the topology stable, and thus
              the rank does not necessarily change as fast as some physical
              metrics would. A new DODAG iteration would be a good opportunity
              to reconcile the discrepancies that might form over time between
              metrics and ranks within a DODAG iteration.</t>

              <t hangText="Granularity:">Rank is coarse grained. A fine
              granularity would prevent the selection of siblings.</t>

              <t hangText="Properties:">Rank is strictly monotonic, and can be
              used to validate a progression from or towards the root. A
              metric, like bandwidth or jitter, does not necessarily exhibit
              this property.</t>

              <t hangText="Abstract:">Rank does not have a physical unit, but
              rather a range of increment per hop, where the assignment of
              each increment is to be determined by the implementation.</t>
            </list></t>

          <t>The rank value feeds into DODAG parent selection, according to
          the RPL loop-avoidance strategy. Once a parent has been added, and a
          rank value for the node within the DODAG has been advertised, the
          nodes further options with regard to DODAG parent selection and
          movement within the DODAG are restricted in favor of loop
          avoidance.</t>

          <section anchor="RankComparison" title="Rank Comparison (DAGRank())">
            <t>Rank may be thought of as a fixed point number, where the
            position of the decimal point between the integer part and the
            fractional part is determined by MinHopRankIncrease.
            MinHopRankIncrease is the minimum increase in rank between a node
            and any of its DODAG parents. When an objective function computes
            rank, the objective function operates on the entire (i.e. 16-bit)
            rank quantity. When rank is compared, e.g. for determination of
            parent/sibling relationships or loop detection, the integer
            portion of the rank is to be used. The integer portion of the Rank
            is computed by the DAGRank() macro as follows:</t>

            <figure>
              <artwork><![CDATA[
                                                                     
           DAGRank(rank) = floor(rank/MinHopRankIncrease)            
                                                                     
]]></artwork>
            </figure>

            <t>MinHopRankIncrease is provisioned at the DODAG Root and
            propagated in the DIO message. For efficient implementation the
            MinHopRankIncrease SHOULD be a power of 2. An implementation may
            configure a value MinHopRankIncrease as appropriate to balance
            between the loop avoidance logic of RPL (i.e. selection of
            eligible parents and siblings) and the metrics in use.</t>

            <t>By convention in this document, using the macro DAGRank(node)
            may be interpreted as DAGRank(node.rank), where node.rank is the
            rank value as maintained by the node.</t>

            <t>A node A has a rank less than the rank of a node B if
            DAGRank(A) is less than DAGRank(B).</t>

            <t>A node A has a rank equal to the rank of a node B if DAGRank(A)
            is equal to DAGRank(B).</t>

            <t>A node A has a rank greater than the rank of a node B if
            DAGRank(A) is greater than DAGRank(B).</t>
          </section>

          <section title="Rank Relationships">
            <t>The computation of the rank MUST be done in such a way so as to
            maintain the following properties for any nodes M and N that are
            neighbors in the LLN:</t>

            <t><list hangIndent="8" style="hanging">
                <t hangText="DAGRank(M) is less than DAGRank(N):">In this
                case, the position of M is closer to the DODAG root than the
                position of N. Node M may safely be a DODAG parent for Node N
                without risk of creating a loop. Further, for a node N, all
                parents in the DODAG parent set must be of rank less than
                DAGRank(N). In other words, the rank presented by a node N
                MUST be greater than that presented by any of its parents.</t>

                <t hangText="DAGRank(M) equals DAGRank(N):">In this case the
                positions of M and N within the DODAG and with respect to the
                DODAG root are similar (identical). In some cases, Node M may
                be used as a successor by Node N, which however entails the
                chance of creating a loop (which must be detected and resolved
                by some other means).</t>

                <t hangText="DAGRank(M) is greater than DAGRank(N):">In this
                case, the position of M is farther from the DODAG root than
                the position of N. Further, Node M may in fact be in the
                sub-DODAG of Node N. If node N selects node M as DODAG parent
                there is a risk to create a loop.</t>
              </list></t>

            <t>As an example, the rank could be computed in such a way so as
            to closely track ETX when the objective function is to minimize
            ETX, or latency when the objective function is to minimize
            latency, or in a more complicated way as appropriate to the
            objective function being used within the DODAG.</t>
          </section>
        </section>
      </section>
    </section>

    <section anchor="RPLControlMessage" title="ICMPv6 RPL Control Message">
      <t>This document defines the RPL Control Message, a new ICMPv6 message.
      In accordance with <xref target="RFC4443"></xref>, the RPL Control
      Message has the following format:</t>

      <t><figure anchor="ICMPFormat" title="RPL Control Message">
          <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                         Message Body                          +
    |                                                               |
]]></artwork>
        </figure></t>

      <t>The RPL Control message is an ICMPv6 information message with a
      requested Type of 155.</t>

      <t>The Code field identifies the type of RPL Control Message. This
      document defines three codes for the following RPL Control Message
      types:</t>

      <t><list style="symbols">
          <t>0x01: DODAG Information Solicitation (<xref
          target="DAGInformationSolicitation"></xref>)</t>

          <t>0x02: DODAG Information Object (<xref
          target="DAGInformationObject"></xref>)</t>

          <t>0x04: Destination Advertisement Object (<xref
          target="DestinationAdvertisementObject"></xref>)</t>
        </list></t>
    </section>

    <section anchor="UpwardRoutes" title="Upward Routes">
      <t>This section describes how RPL discovers and maintains upward routes.
      It describes DODAG Information Objects (DIOs), the messages used to
      discover and maintain these routes. It specifies how RPL generates and
      responds to DIOs. It also describes DODAG Information Solicitation (DIS)
      messages, which are used to trigger DIO transmissions.</t>

      <section anchor="DAGInformationObject"
               title="DODAG Information Object (DIO)">
        <t>The DODAG Information Object carries information that allows a node
        to discover a RPL Instance, learn its configuration parameters, select
        a DODAG parent set, and maintain the upward routing topology.</t>

        <section anchor="DIOBase" title="DIO Base Format">
          <t>DIO Base is an always-present container option in a DIO message.
          Every DIO MUST include a DIO Base.</t>

          <t><figure anchor="DIObase" title="DIO Base">
              <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |G|A|T|S|0| Prf |   Sequence    |             Rank              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | RPLInstanceID |     DTSN      |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
    |                                                               |
    +                                                               +
    |                            DODAGID                            |
    +                                                               +
    |                                                               |
    +                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                               |   sub-option(s)...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
            </figure></t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="Control Field:">The DAG Control Field has three
              flags and one field: <list hangIndent="6" style="hanging">
                  <t hangText="Grounded (G):">The Grounded (G) flag indicates
                  whether the upward routes this node advertises provide
                  connectivity to the set of addresses which are
                  application-defined goals. If the flag is set, the DODAG is
                  grounded and provides such connectivity. If the flag is
                  cleared, the DODAG is floating and may not provide such
                  connectivity.</t>

                  <t hangText="Destination Advertisement Supported (A):">The
                  Destination Advertisement Supported (A) flag indicates
                  whether the root of this DODAG can collect and use downward
                  route state. If the flag is set, nodes in the network are
                  enabled to exchange destination advertisements messages to
                  build downward routes (<xref
                  target="DownwardRoutes"></xref>).<!-- and cross-routes (<xref target="CrossRoutes"></xref>)-->
                  If the flag is cleared, destination advertisement messages
                  are disabled and the DODAG maintains only upward routes.</t>

                  <t hangText="Destination Advertisement Trigger (T):">The
                  Destination Advertisement Trigger (T) flag indicates a
                  complete refresh of downward routes. If the flag is set,
                  then a refresh of downward route state is to take place over
                  the entire DODAG. If the flag is cleared, the downward route
                  maintenance is in its normal mode of operation. The further
                  details of this process are described in <xref
                  target="DownwardRoutes"></xref>.</t>

                  <t hangText="Destination Advertisements Stored (S):">The
                  Destination Advertisements Stored (S) flag is used to
                  indicate that a non-root ancestor is storing routing table
                  entries learned from DAO messaging. If the flag is set, then
                  a non-root ancestor is known to be storing routing table
                  entries learned from DAO messages. If the flag is cleared,
                  only the root node may be storing routing table entries
                  learned from DAO messaging. This flag is further described
                  in <xref target="DownwardRoutes"></xref>.</t>

                  <t hangText="DODAGPreference (Prf):">A 3-bit unsigned
                  integer that defines how preferable the root of this DODAG
                  is compared to other DODAG roots within the instance.
                  DAGPreference ranges from 0x00 (least preferred) to 0x07
                  (most preferred). The default is 0 (least preferred). <xref
                  target="DAGDiscovery"></xref> describes how DAGPreference
                  affects DIO processing.</t>
                </list></t>

              <t>Unassigned bits of the Control Field are reserved. They MUST
              be set to zero on transmission and MUST be ignored on
              reception.</t>

              <t hangText="Sequence Number:">8-bit unsigned integer set by the
              DODAG root. <xref target="DAGDiscovery"></xref> describes the
              rules for sequence numbers and how they affect DIO
              processing.</t>

              <t hangText="Rank:">16-bit unsigned integer indicating the DODAG
              rank of the node sending the DIO message. <xref
              target="DAGDiscovery"></xref> describes how Rank is set and how
              it affects DIO processing.</t>

              <t hangText="RPLInstanceID:">8-bit field set by the DODAG root
              that indicates which RPL Instance the DODAG is part of.</t>

              <t
              hangText="Destination Advertisement Trigger Sequence Number (DTSN):">8-bit
              unsigned integer set by the node issuing the DIO message. The
              Destination Advertisement Trigger Sequence Number (DTSN) flag is
              used as part of the procedure to maintain downward routes. The
              details of this process are described in <xref
              target="DownwardRoutes"></xref>.</t>

              <t hangText="DODAGID:">128-bit unsigned integer set by a DODAG
              root which uniquely identifies a DODAG. Possibly derived from
              the IPv6 address of the DODAG root.</t>
            </list></t>
        </section>

        <section anchor="DIOBaseRules" title="DIO Base Rules">
          <t><list style="numbers">
              <t>If the 'A' flag of a DIO Base is cleared, the 'T' flag MUST
              also be cleared.</t>

              <t>For the following DIO Base fields, a node that is not a DODAG
              root MUST advertise the same values as its preferred DODAG
              parent (defined in <xref target="parentset"></xref>). Therefore,
              if a DODAG root does not change these values, every node in a
              route to that DODAG root eventually advertises the same values
              for these fields. These fields are: <?rfc subcompact="yes"?><list>
                  <t>Grounded (G)</t>

                  <t>Destination Advertisement Supported (A)</t>

                  <t>Destination Advertisement Trigger (T)</t>

                  <t>DAGPreference (Prf)</t>

                  <t>Sequence</t>

                  <t>RPLInstanceID</t>

                  <t>DODAGID</t>
                </list><?rfc subcompact="no"?></t>

              <t>A node MAY update the following fields at each hop: <?rfc subcompact="yes"?><list>
                  <t>Destination Advertisements Stored (S)</t>

                  <t>DAGRank</t>

                  <t>DTSN</t>
                </list><?rfc subcompact="no"?></t>

              <t>The DODAGID field each root sets MUST be unique within the
              RPL Instance.</t>
            </list></t>
        </section>

        <section anchor="DIOSuboptions" title="DIO Suboptions">
          <t>This section describes the format of DIO suboptions and the five
          suboptions this document defines: Pad 1, Pad N, DAG Metric
          Container, DAG Destination Prefix, and DAG Configuration.</t>

          <section title="DIO Suboption Format">
            <t>The Pad N, DAG Metric Container, DAG Destination Prefix, and
            DAG Configuration suboptions all follow this format: <figure
                anchor="DIOsub" title="DIO Suboption Generic Format">
                <artwork><![CDATA[
     0                   1                   2      
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
    |  Subopt. Type |       Suboption Length        | Suboption Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
]]></artwork>
              </figure></t>

            <t><list hangIndent="6" style="hanging">
                <t hangText="Suboption Type:">8-bit identifier of the type of
                suboption.</t>

                <t hangText="Suboption Length:">16-bit unsigned integer,
                representing the length in octets of the suboption, not
                including the suboption Type and Length fields.</t>

                <t hangText="Suboption Data:">A variable length field that
                contains data specific to the option.</t>
              </list></t>

            <t>The following subsections specify the DIO message suboptions
            which are currently defined for use in the DODAG Information
            Object.</t>

            <t>When processing a DIO message containing a suboption for which
            the Suboption Type value is not recognized by the receiver, the
            receiver MUST silently ignore the unrecognized option and continue
            to process the following suboption, correctly handling any
            remaining options in the message.</t>

            <!--
                <t>Implementations MUST silently ignore any DIO message
                suboptions options that they do not understand.</t>
            -->

            <t>DIO message suboptions may have alignment requirements.
            Following the convention in IPv6, options with alignment
            requirements are aligned in a packet such that multi-octet values
            within the Option Data field of each option fall on natural
            boundaries (i.e., fields of width n octets are placed at an
            integer multiple of n octets from the start of the header, for n =
            1, 2, 4, or 8).</t>
          </section>

          <section title="Pad1">
            <t>The Pad1 suboption format is as follows:</t>

            <t><figure anchor="DIOsubPad1" title="Pad 1">
                <artwork><![CDATA[
     0
     0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+
    |   Type = 0    |
    +-+-+-+-+-+-+-+-+
]]></artwork>
              </figure></t>

            <t>NOTE! the format of the Pad1 option is a special case - it has
            neither Option Length nor Option Data fields.</t>

            <t>The Pad1 option is used to insert one or two octets of padding
            in the DIO message to enable suboptions alignment. If more than
            two octets of padding is required, the PadN option, described
            next, should be used rather than multiple Pad1 options.</t>
          </section>

          <section title="PadN">
            <t>The PadN suboption format is as follows:</t>

            <t><figure anchor="DIOsubPadN" title="Pad N">
                <artwork><![CDATA[
     0                   1                   2      
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
    |   Type = 1    |       Suboption Length        | Suboption Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
]]></artwork>
              </figure></t>

            <t>The PadN suboption is used to insert three or more octets of
            padding in the DIO message to enable suboptions alignment. For N
            (N &gt; 2) octets of padding, the Suboption Length field contains
            the value N-3, and the Option Data consists of N-3 zero-valued
            octets. PadN Option data MUST be ignored by the receiver.</t>
          </section>

          <section anchor="DIOMetricContainer" title="Metric Container">
            <t>The Metric Container suboption format is as follows:</t>

            <t><figure anchor="DIOsubLLNMetric" title="Metric Container">
                <artwork><![CDATA[
     0                   1                   2      
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
    |   Type = 2    |       Suboption Length        | Metric Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
]]></artwork>
              </figure></t>

            <t>The Metric Container is used to report metrics along the DODAG.
            The Metric Container may contain a number of discrete node, link,
            and aggregate path metrics as chosen by the implementer. The
            Suboption Length field contains the length in octets of the Metric
            Data. The order, content, and coding of the Metric Container data
            is as specified in <xref
            target="I-D.ietf-roll-routing-metrics"></xref>.</t>

            <t>The processing and propagation of the Metric Container is
            governed by implementation specific policy functions.</t>
          </section>

          <section title="Destination Prefix">
            <t>The Destination Prefix suboption format is as follows:</t>

            <t><figure anchor="DIOsubDestinationPrefix"
                title="DAG Destination Prefix">
                <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 3    |      Suboption Length         |Resvd|Prf|Resvd|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        Prefix Lifetime                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Prefix Length |                                               |
    +-+-+-+-+-+-+-+-+                                               |
    |             Destination Prefix (Variable Length)              |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
              </figure></t>

            <t>The Destination Prefix suboption is used to indicate that
            connectivity to the specified destination prefix is available from
            the DODAG root, or from another node located upwards along the
            DODAG on the path to the DODAG root. This may be useful in cases
            where more than one LBR is operating within the LLN and offering
            connectivity to different administrative domains, e.g. a home
            network and a utility network. In such cases, upon observing the
            Destination Prefixes offered by a particular DODAG, a node MAY
            decide to join multiple DODAGs in support of a particular
            application.</t>

            <t>The Suboption Length is coded as the length of the suboption in
            octets, excluding the Type and Length fields.</t>

            <t>Prf is the Route Preference as in <xref
            target="RFC4191"></xref>. The reserved fields MUST be set to zero
            on transmission and MUST be ignored on receipt.</t>

            <t>The Prefix Lifetime is a 32-bit unsigned integer representing
            the length of time in seconds (relative to the time the packet is
            sent) that the Destination Prefix is valid for route
            determination. The lifetime is initially set by the node that owns
            the prefix and denotes the valid lifetime for that prefix (similar
            to AdvValidLifetime <xref target="RFC4861"></xref>). The value
            might be reduced by the originator and/or en-route nodes that will
            not provide connectivity for the whole valid lifetime. A value of
            all one bits (0xFFFFFFFF) represents infinity. A value of all zero
            bits (0x00000000) indicates a loss of reachability.</t>

            <t>The Prefix Length is an 8-bit unsigned integer that indicates
            the number of leading bits in the destination prefix.</t>

            <t>The Destination Prefix contains Prefix Length significant bits
            of the destination prefix. The remaining bits of the Destination
            Prefix, as required to complete the trailing octet, are set to
            0.</t>

            <t>In the event that a DIO message may need to specify
            connectivity to more than one destination, the Destination Prefix
            suboption may be repeated.</t>
          </section>

          <section title="DODAG Configuration">
            <t>The DODAG Configuration suboption format is as follows:</t>

            <t><figure anchor="DIOsubDAGConfig" title="DODAG Configuration">
                <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 4    |            Length             | DIOIntDoubl.  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  DIOIntMin.   |   DIORedun.   |  MaxRankInc   | MinHopRankInc |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
              </figure></t>

            <t>The DODAG Configuration suboption is used to distribute
            configuration information for DODAG Operation through the DODAG.
            The information communicated in this suboption is generally static
            and unchanging within the DODAG, therefore it is not necessary to
            include in every DIO. This suboption MAY be included occasionally
            by the DODAG Root, and MUST be included in response to a unicast
            request, e.g. a unicast DODAG Information Solicitation (DIS)
            message.</t>

            <t>The Length is coded as 5.</t>

            <t>DIOIntervalDoublings is an 8-bit unsigned integer, configured
            on the DODAG root and used to configure the trickle timer (see
            <xref target="TrickleImplementation"></xref> for details on
            trickle timers) governing when DIO message should be sent within
            the DODAG. DIOIntervalDoublings is the number of times that the
            DIOIntervalMin is allowed to be doubled during the trickle timer
            operation.</t>

            <t>DIOIntervalMin is an 8-bit unsigned integer, configured on the
            DODAG root and used to configure the trickle timer governing when
            DIO message should be sent within the DODAG. The minimum
            configured interval for the DIO trickle timer in units of ms is
            2^DIOIntervalMin. For example, a DIOIntervalMin value of 16ms is
            expressed as 4.</t>

            <t>DIORedundancyConstant is an 8-bit unsigned integer used to
            configure suppression of DIO transmissions. DIORedundancyConstant
            is the minimum number of relevant incoming DIOs required to
            suppress a DIO transmission. If the value is 0xFF then the
            suppression mechanism is disabled.</t>

            <t>MaxRankInc, 8-bit unsigned integer, is the DAGMaxRankIncrease.
            This is the allowable increase in rank in support of local repair.
            If DAGMaxRankIncrease is 0 then this mechanism is disabled.</t>

            <t>MinHopRankInc, 8-bit unsigned integer, is the
            MinHopRankIncrease as described in <xref
            target="RankComparison"></xref>.</t>
          </section>
        </section>
      </section>

      <section anchor="DAGInformationSolicitation"
               title="DODAG Information Solicitation (DIS)">
        <t>The DODAG Information Solicitation (DIS) message may be used to
        solicit a DODAG Information Object from a RPL node. Its use is
        analogous to that of a Router Solicitation; a node may use DIS to
        probe its neighborhood for nearby DODAGs. The DODAG Information
        Solicitation carries no additional message body. <xref
        target="DIOTransmission"></xref> describes how nodes respond to a
        DIS.</t>
      </section>

      <section anchor="DAGDiscovery"
               title="Upward Route Discovery and Maintenance">
        <t>Upward route discovery allows a node to join a DODAG by discovering
        neighbors that are members of the DODAG and identifying a set of
        parents. The exact policies for selecting neighbors and parents is
        implementation-dependent. This section specifies the set of rules
        those policies must follow for interoperability.</t>

        <section anchor="RPLInstance" title="RPL Instance">
          <t><list>
              <t>A RPLInstanceID MUST be unique across an LLN.</t>

              <t>A node MAY belong to multiple RPL Instances.</t>
            </list></t>

          <t>Within a given LLN, there may be multiple, logically independent
          RPL instances. This document describes how a single instance
          behaves.</t>
        </section>

        <section anchor="parentset"
                 title="Neighbors and Parents within a DODAG Iteration">
          <t>RPL's upward route discovery algorithms and processing are in
          terms of three logical sets of link-local nodes. First, the
          candidate neighbor set is a subset of the nodes that can be reached
          via link-local multicast. The selection of this set is
          implementation-dependent and OF-dependent. Second, the parent set is
          a restricted subset of the candidate neighbor set. Finally, the
          preferred parent, a set of size one, is an element of the parent set
          that is the preferred next hop in upward routes.</t>

          <t>More precisely: <list style="numbers">
              <t>The DODAG parent set MUST be a subset of the candidate
              neighbor set.</t>

              <t>A DODAG root MUST have a DODAG parent set of size zero.</t>

              <t>A node that is not a DODAG root MAY maintain a DODAG parent
              set of size greater than or equal to one.</t>

              <t>A node's preferred DODAG parent MUST be a member of its DODAG
              parent set.</t>

              <t>A node's rank MUST be greater than all elements of its DODAG
              parent set.</t>

              <t>When Neighbor Unreachability Detection (NUD), or an
              equivalent mechanism, determines that a neighbor is no longer
              reachable, a RPL node MUST NOT consider this node in the
              candidate neighbor set when calculating and advertising routes
              until it determines that it is again reachable. Routes through
              an unreachable neighbor MUST be eliminated from the routing
              table.</t>
            </list></t>

          <t>These rules ensure that there is a consistent partial order on
          nodes within the DODAG. As long as node ranks do not change,
          following the above rules ensures that every node's route to a DODAG
          root is loop-free, as rank decreases on each hop to the root. The OF
          can guide candidate neighbor set and parent set selection, as
          discussed in <xref
          target="I-D.ietf-roll-routing-metrics"></xref>.</t>
        </section>

        <section anchor="DAGDiscoveryRules"
                 title="Neighbors and Parents across DODAG Iterations">
          <t>The above rules govern a single DODAG iteration. The rules in
          this section define how RPL operates when there are multiple DODAG
          iterations:</t>

          <section anchor="DAGDiscoveryRulesSeq" title="DODAG Iteration">
            <t><list style="numbers">
                <t>The tuple (RPLInstanceID, DODAGID, DODAGSequenceNumber)
                uniquely defines a DODAG Iteration. Every element of a node's
                DODAG parent set, as conveyed by the last heard DIO from each
                DODAG parent, MUST belong to the same DODAG iteration.
                Elements of a node's candidate neighbor set MAY belong to
                different DODAG Iterations.<!-- TBD restrict siblings?--></t>

                <t>A node is a member of a DODAG iteration if every element of
                its DODAG parent set belongs to that DODAG iteration, or if
                that node is the root of the corresponding DODAG.</t>

                <t>A node MUST NOT send DIOs for DODAG iterations of which it
                is not a member.</t>

                <t>DODAG roots MAY increment the DODAGSequenceNumber that they
                advertise and thus move to a new DODAG iteration. When a DODAG
                root increments its DODAGSequenceNumber, it MUST follow the
                conventions of Serial Number Arithmetic as described in <xref
                target="RFC1982"></xref>.</t>

                <t>Within a given DODAG, a node that is a not a root MUST NOT
                advertise a DODAGSequenceNumber higher than the highest
                DODAGSequenceNumber it has heard. Higher is defined as the
                greater-than operator in <xref target="RFC1982"></xref>.</t>

                <t>Once a node has advertised a DODAG iteration by sending a
                DIO, it MUST NOT be member of a previous DODAG iteration of
                the same DODAG (i.e. with the same RPLInstanceID, the same
                DODAGID, and a lower DODAGSequenceNumber). Lower is defined as
                the less-than operator in <xref target="RFC1982"></xref>.</t>
              </list></t>

            <t>Within a particular implementation, a DODAG root may increment
            the DODAGSequenceNumber periodically, at a rate that depends on
            the deployment. In other implementations, loop detection may be
            considered sufficient to solve routing issues, and the DODAG root
            may increment the DODAGSequenceNumber only upon administrative
            intervention. Another possibility is that nodes within the LLN
            have some means by which they can signal detected routing
            inconsistencies or suboptimalities to the DODAG root, in order to
            request an on-demand DODAGSequenceNumber increment (i.e. request a
            global repair of the DODAG).</t>

            <t>When the DODAG parent set becomes empty on a node that is not a
            root, (i.e. the last parent has been removed, causing the node to
            no longer be associated with that DODAG), then the DODAG
            information should not be suppressed until after the expiration of
            an implementation-specific local timer in order to observe if the
            DODAGSequenceNumber has been incremented, should any new parents
            appear for the DODAG.</t>

            <t>As the DODAGSequenceNumber is incremented, a new DODAG
            Iteration spreads outward from the DODAG root. Thus a parent that
            advertises the new DODAGSequenceNumber can not possibly belong to
            the sub-DODAG of a node that still advertises an older
            DODAGSequenceNumber. A node may safely add such a parent, without
            risk of forming a loop, without regard to its relative rank in the
            prior DODAG Iteration. This is equivalent to jumping to a
            different DODAG.</t>

            <t>As a node transitions to new DODAG Iterations as a consequence
            of following these rules, the node will be unable to advertise the
            previous DODAG Iteration (prior DODAGSequenceNumber) once it has
            committed to advertising the new DODAG Iteration.</t>

            <t>During transition to a new DODAG Iteration, a node may decide
            to forward packets via 'future parents' that belong to the same
            DODAG (same RPLInstanceID and DODAGID), but are observed to
            advertise a more recent (incremented) DODAGSequenceNumber.</t>
          </section>

          <section anchor="DAGDiscoveryRulesRoot" title="DODAG Roots">
            <t><list style="numbers">
                <t>A DODAG root that does not have connectivity to the set of
                addresses described as application-level goals, MUST NOT set
                the Grounded bit.</t>

                <t>A DODAG root MUST advertise a rank of ROOT_RANK.</t>

                <t>A node whose DODAG parent set is empty MAY become the DODAG
                root of a floating DODAG. It MAY also set its DAGPreference
                such that it is less preferred.</t>
              </list></t>

            <t>An LLN node that is a goal for the Objective Function is the
            root of its own grounded DODAG, at rank ROOT_RANK.</t>

            <t>In a deployment that uses a backbone link to federate a number
            of LLN roots, it is possible to run RPL over that backbone and use
            one router as a "backbone root". The backbone root is the virtual
            root of the DODAG, and exposes a rank of BASE_RANK over the
            backbone. All the LLN roots that are parented to that backbone
            root, including the backbone root if it also serves as LLN root
            itself, expose a rank of ROOT_RANK to the LLN, and are part of the
            same DODAG, coordinating DODAGSequenceNumber and other DODAG root
            determined parameters with the virtual root over the backbone.</t>
          </section>

          <section anchor="DAGSelection" title="DODAG Selection">
            <t>The DODAGPreference (Prf) provides an administrative mechanism
            to engineer the self-organization of the LLN, for example
            indicating the most preferred LBR. If a node has the option to
            join a more preferred DODAG while still meeting other optimization
            objectives, then the node will generally seek to join the more
            preferred DODAG as determined by the OF. All else being equal, it
            is left to the implementation to determine which DODAG is most
            preferred, possibly based on additional criteria beyond Prf and
            the OF.</t>
          </section>

          <section anchor="DAGDiscoveryRulesMove"
                   title="Rank and Movement within a DODAG Iteration">
            <t><list style="numbers">
                <t>A node MUST NOT advertise a rank less than or equal to any
                member of its parent set within the DODAG Iteration.</t>

                <t>A node MAY advertise a rank lower than its prior
                advertisement within the DODAG Iteration.</t>

                <t>Let L be the lowest rank within a DODAG iteration that a
                given node has advertised. Within the same DODAG Iteration,
                that node MUST NOT advertise an effective rank higher than L +
                DAGMaxRankIncrease. INFINITE_RANK is an exception to this
                rule: a node MAY advertise an INFINITE_RANK at any time. (This
                corresponds to a limited rank increase for the purpose of
                local repair within the DODAG Iteration.)</t>

                <t>A node MAY, at any time, choose to join a different DODAG
                within a RPL Instance. Such a join has no rank restrictions,
                unless that different DODAG is a DODAG Iteration of which that
                node has previously been a member, in which case the rule of
                the previous bullet (3) must be observed. Until a node
                transmits a DIO indicating its new DODAG membership, it MUST
                forward packets along the previous DODAG.</t>

                <t>A node MAY, at any time after hearing the next
                DODAGSequenceNumber Iteration advertised from suitable DODAG
                parents, choose to migrate to the next DODAG Iteration within
                the DODAG.</t>
              </list></t>

            <t>Conceptually, an implementation is maintaining a DODAG parent
            set within the DODAG Iteration. Movement entails changes to the
            DODAG parent set. Moving up does not present the risk to create a
            loop but moving down might, so that operation is subject to
            additional constraints.</t>

            <t>When a node migrates to the next DODAG Iteration, the DODAG
            parent and sibling sets need to be rebuilt for the new iteration.
            An implementation could defer to migrate for some reasonable
            amount of time, to see if some other neighbors with potentially
            better metrics but higher rank announce themselves. Similarly,
            when a node jumps into a new DODAG it needs to construct new DODAG
            parent/sibling sets for this new DODAG.</t>

            <t>When a node moves to improve its position, it must conceptually
            abandon all DODAG parents and siblings with a rank larger than
            itself. As a consequence of the movement it may also add new
            siblings. Such a movement may occur at any time to decrease the
            rank, as per the calculation indicated by the OF. Maintenance of
            the parent and sibling sets occurs as the rank of candidate
            neighbors is observed as reported in their DIOs.</t>

            <t>If a node needs to move down a DODAG that it is attached to,
            causing the rank to increase, then it MAY poison its routes and
            delay before moving as described in <xref
            target="DAGDiscoveryRulesPoison"></xref>.</t>

            <!-- TBD turn this into an implementation note?
                <t>If a node has selected a new set of DAG parents but has not
                jumped yet (because it is waiting for DAG Hop timer to
                elapse), the node is UNSTABLE and MUST NOT send DIOs for that
                DAG.</t>
                -->
          </section>

          <section anchor="DAGDiscoveryRulesPoison"
                   title="Poisoning a Broken Path">
            <t><list style="numbers">
                <t>A node MAY poison, in order to avoid being used as an
                ancestor by the nodes in its sub-DODAG, by advertising an
                effective rank of INFINITE_RANK and resetting the associated
                DIO trickle timer to cause this INFINITE_RANK to be announced
                promptly.</t>

                <t>The node MAY advertise an effective rank of INFINITE_RANK
                for an arbitrary number of DIO timer events, before announcing
                a new rank.</t>

                <t>As per <xref target="DAGDiscoveryRulesMove"></xref>, the
                node MUST advertise INFINITE_RANK within the DODAG iteration
                in which it participates, if its revision in rank would exceed
                the maximum rank increase.</t>
              </list></t>

            <t>An implementation may choose to employ this poisoning mechanism
            when a node loses all of its current parents, i.e. the set of
            DODAG parents becomes depleted, and it can not jump to an
            alternate DODAG. An alternate mechanism is to form a floating
            DODAG.</t>

            <t>The motivation for delaying announcement of the revised route
            through multiple DIO events is to (i) increase tolerance to DIO
            loss, (ii) allow time for the poisoning action to propagate, and
            (iii) to develop an accurate assessment of its new rank. Such
            gains are obtained at the expense of potentially increasing the
            delay before portions of the network are able to re-establish
            upwards routes. Path redundancy in the DODAG reduces the
            significance of either effect, since children with alternate
            parents should be able to utilize those alternates and retain
            their rank while the detached parent re-establishes its rank.</t>

            <t>Although an implementation may advertise INFINITE_RANK for the
            purposes of poisoning, it is not expected to be equivalent to
            setting the rank to INFINITE_RANK, and an implementation would
            likely retain its rank value prior to the poisoning in some form,
            for purpose of maintaining its effective position within (L +
            DAGMaxRankIncrease).</t>
          </section>

          <section anchor="DAGDiscoveryRulesdetach" title="Detaching">
            <t><list style="numbers">
                <t>A node unable to stay connected to a DODAG within a given
                DODAG iteration MAY detach from this DODAG iteration. A node
                that detaches becomes root of its own floating DODAG and
                SHOULD immediately advertise this new situation in a DIO as an
                alternate to poisoning.</t>
              </list></t>
          </section>

          <section anchor="DAGDiscoveryRulesfollow" title="Following a Parent">
            <t><list style="numbers">
                <t>If a node receives a DIO from one of its DODAG parents,
                indicating that the parent has left the DODAG, that node
                SHOULD stay in its current DODAG through an alternative DODAG
                parent, if possible. It MAY follow the leaving parent.</t>
              </list></t>

            <t>A DODAG parent may have moved, migrated to the next DODAG
            Iteration, or jumped to a different DODAG. A node should give some
            preference to remaining in the current DODAG, if possible, but
            ought to follow the parent if there are no other options.</t>
          </section>
        </section>

        <section title="DIO Message Communication">
          <t>When an DIO message is received, the receiving node must first
          determine whether or not the DIO message should be accepted for
          further processing, and subsequently present the DIO message for
          further processing if eligible.</t>

          <t><list style="numbers">
              <t>If the DIO message is malformed, then the DIO message is not
              eligible for further processing and is silently discarded. A RPL
              implementation MAY log the reception of a malformed DIO
              message.</t>

              <t>If the sender of the DIO message is a member of the candidate
              neighbor set, then the DIO is eligible for further
              processing.</t>
            </list></t>

          <section title="DIO Message Processing">
            <t>As DIO messages are received from candidate neighbors, the
            neighbors may be promoted to DODAG parents by following the rules
            of DODAG discovery as described in <xref
            target="DAGDiscovery"></xref>. When a node places a neighbor into
            the DODAG parent set, the node becomes attached to the DODAG
            through the new DODAG parent node.</t>

            <t>The most preferred parent should be used to restrict which
            other nodes may become DODAG parents. Some nodes in the DODAG
            parent set may be of a rank less than or equal to the most
            preferred DODAG parent. (This case may occur, for example, if an
            energy constrained device is at a lesser rank but should be
            avoided as per an optimization objective, resulting in a more
            preferred parent at a greater rank).</t>
          </section>
        </section>

        <section anchor="DIOTransmission" title="DIO Transmission">
          <t>Each node maintains a timer, that governs when to multicast DIO
          messages. This timer is a trickle timer, as detailed in <xref
          target="TrickleImplementation"></xref>. The DIO Configuration Option
          includes the configuration of a RPL Instance's trickle timer.</t>

          <t><list style="symbols">
              <t>When a node detects or causes an inconsistency, it MUST reset
              the trickle timer.</t>

              <t>When a node migrates to a new DODAG Iteration it MUST reset
              the trickle timer to its minimum value</t>

              <t>When a node detects an inconsistency when forwarding a
              packet, as detailed in <xref target="loopdetect"></xref>, the
              node MUST reset the trickle timer.</t>

              <t>When a node receives a multicast DIS message, it MUST reset
              the trickle timer to its minimum value.</t>

              <t>When a node receives a unicast DIS message, it MUST unicast a
              DIO message in response, and the response MUST include the DODAG
              Configuration Object. This provides a means that an
              interrogating node may be guaranteed to receive the DODAG
              Configuration Object, which otherwise might not be included at
              the option of the sender. In this case the node SHOULD NOT reset
              the trickle timer.</t>

              <t>If a node is not a member of a DODAG, it MUST suppress
              transmission of DIO messages.</t>

              <t>When a node is initialized, it MAY be configured to remain
              silent and not multicast any DIO messages until it has
              encountered and joined a DODAG (perhaps initially probing for a
              nearby DODAG with an DIS message). Alternately, it MAY choose to
              root its own floating DODAG and begin multicasting DIO messages
              using a default trickle configuration. The second case may be
              advantageous if it is desired for independent nodes to begin
              aggregating into scattered floating DODAGs, in the absence of a
              grounded node, for example in support of LLN installation and
              commissioning.</t>
            </list></t>

          <!--
          <t>Note that if multiple DAG roots are participating in the same
          DAG, i.e. offering DIO messages with the same DODAGID, then they must
          coordinate with each other to ensure that their DIO messages are
          consistent when they emit DIO messages. In particular the Sequence
          number must be identical from each DAG root, regardless of which of
          the multiple DAG roots issues the DIO message, and changes to the
          Sequence number should be issued at the same time. The specific
          mechanism of this coordination, e.g. along a non-LLN network between
          DAG roots, is beyond the scope of this specification.</t>
          -->

          <section anchor="TrickleImplementation"
                   title="Trickle Timer for DIO Transmission">
            <t>RPL treats the construction of a DODAG as a consistency
            problem, and uses a trickle timer <xref target="Levis08"></xref>
            to control the rate of control broadcasts.</t>

            <t>For each DODAG that a node is part of (i.e. one DODAG per RPL
            Instance), the node must maintain a single trickle timer. The
            required state contains the following conceptual items:</t>

            <t><list hangIndent="6" style="hanging">
                <t hangText="I:">The current length of the communication
                interval</t>

                <t hangText="T:">A timer with a duration set to a random value
                in the range [I/2, I]</t>

                <t hangText="C:">Redundancy Counter</t>

                <t hangText="I_min:">The smallest communication interval in
                milliseconds. This value is learned from the DIO message as
                (2^DIOIntervalMin)ms. The default value is
                DEFAULT_DIO_INTERVAL_MIN.</t>

                <t hangText="I_doublings:">The number of times I_min should be
                doubled before maintaining a constant rate, i.e. I_max = I_min
                * 2^I_doublings. This value is learned from the DIO message as
                DIOIntervalDoublings. The default value is
                DEFAULT_DIO_INTERVAL_DOUBLINGS.</t>
              </list></t>

            <section title="Resetting the Trickle Timer">
              <t>The trickle timer for a DODAG is reset by:</t>

              <t><list style="numbers">
                  <t>Setting I_min and I_doublings to the values learned from
                  the DODAG root via a received DIO message.</t>

                  <t>Setting C to zero.</t>

                  <t>If I is not equal to I_min: <list style="numbers">
                      <t>Setting I to I_min.</t>

                      <t>Setting T to a random value as described above.</t>

                      <t>Restarting the trickle timer to expire after a
                      duration T</t>
                    </list></t>
                </list></t>

              <t>When a node learns about a DODAG through a DIO message, and
              makes the decision to join this DODAG, it initializes the state
              of the trickle timer by resetting the trickle timer and
              listening. Each time it hears a redundant DIO message for this
              DODAG, it MAY increment C. The exact determination of what
              constitutes a redundant DIO message is left to an
              implementation; it could for example include DIOs that advertise
              the same rank.</t>

              <t>When the timer fires at time T, the node compares C to the
              redundancy constant, DIORedundancyConstant. If C is less than
              that value, or if the DIORedundancyConstant value is 0xFF, the
              node generates a new DIO message and multicasts it. When the
              communication interval I expires, the node doubles the interval
              I so long as it has previously doubled it fewer than I_doubling
              times, resets C, and chooses a new T value.</t>
            </section>

            <section anchor="TrickleInconsistencies"
                     title="Determination of Inconsistency">
              <t>The trickle timer is reset whenever an inconsistency is
              detected within the DODAG, for example:</t>

              <t><list style="symbols">
                  <t>The node joins a new DODAG</t>

                  <t>The node moves within a DODAG</t>

                  <t>The node receives a DIO message from a DODAG parent that
                  updates the information learned from a prior DIO message for
                  that DODAG Parent</t>

                  <t>A DODAG parent forwards a packet intended to move up,
                  indicating an inconsistency and possible loop.</t>

                  <t>A metric communicated in the DIO message is determined to
                  be inconsistent, as according to a implementation specific
                  path metric selection engine.</t>

                  <t>The rank of a DODAG parent has changed.</t>
                </list></t>
            </section>
          </section>
        </section>

        <section title="DODAG Selection">
          <t>The DODAG selection is implementation and algorithm dependent.
          Nodes SHOULD prefer to join DODAGs for RPLInstanceIDs advertising
          OCPs and destinations compatible with their implementation specific
          objectives. In order to limit erratic movements, and all metrics
          being equal, nodes SHOULD keep their previous selection. Also, nodes
          SHOULD provide a means to filter out a parent whose availability is
          detected as fluctuating, at least when more stable choices are
          available.</t>

          <t>When connection to a fixed network is not possible or preferable
          for security or other reasons, scattered DODAGs MAY aggregate as
          much as possible into larger DODAGs in order to allow connectivity
          within the LLN.</t>

          <t>A node SHOULD verify that bidirectional connectivity and adequate
          link quality is available with a candidate neighbor before it
          considers that candidate as a DODAG parent.</t>
        </section>
      </section>

      <section title="Operation as a Leaf Node">
        <t>In some cases a RPL node may attach to a DODAG as a leaf node only.
        One example of such a case is when a node does not understand the RPL
        Instance's OF. A leaf node does not extend DODAG connectivity but
        still needs to advertise its presence using DIOs. A node operating as
        a leaf node must obey the following rules:</t>

        <t><list style="numbers">
            <t>It MUST NOT transmit DIOs containing the DAG Metric
            Container.</t>

            <t>Its DIOs must advertise a DAGRank of INFINITE_RANK.</t>

            <t>It MAY transmit unicast DAOs as described in <xref
            target="DownwardDiscovery"></xref>.</t>

            <t>It MAY transmit multicast DAOs to the '1 hop' neighborhood as
            described in <xref target="MulticastDAO"></xref>.</t>
          </list></t>
      </section>

      <section title="Administrative Rank">
        <!-- TBD should this go with `Guidelines for OF?' -->

        <t>In some cases it might be beneficial to adjust the rank advertised
        by a node beyond that computed by the OF based on some implementation
        specific policy and properties of the node. For example, a node that
        has limited battery should be a leaf unless there is no other choice,
        and may then augment the rank computation specified by the OF in order
        to expose an exaggerated rank.</t>
      </section>

      <section anchor="DAGCollision" title="Collision">
        <t>A race condition occurs if 2 nodes send DIO messages at the same
        time and then attempt to join each other. This might happen, for
        example, between nodes which act as DODAG root of their own DODAGs. In
        order to detect the situation, LLN Nodes time stamp the sending of DIO
        message. Any DIO message received within a short link-layer-dependent
        period introduces a risk. It left to the implementation to define the
        duration of the risk window.</t>

        <t>There is risk of a collision when a node receives and processes a
        DIO within the risk window. For example, it may occur that two nodes
        are associated with different DODAGs and near-simultaneously send DIO
        messages, which are received and processed by both, and possibly
        result in both nodes simultaneously deciding to attach to each other.
        As a remedy, in the face of a potential collision, as determined by
        receiving a DIO within the risk window, the DIO message is not
        processed. It is expected that subsequent DIOs would not cross.</t>
      </section>
    </section>

    <section anchor="DownwardRoutes" title="Downward Routes">
      <t>This section describes how RPL discovers and maintains downward
      routes. Messages containing the Destination Advertisement Object (DAO),
      used to construct downward routes, are described. The downward routes
      are necessary in support of P2MP flows, from the DODAG roots toward the
      leaves. It specifies non-storing and storing behavior of nodes with
      respect to DAO messaging and DAO routing table entries. Nodes, as
      according to their resources and the implementation, may selectively
      store routing table entries learned from DAO messages, or may instead
      propagate the DAO information upwards while adding source routing
      information. A further optimization is described whereby DAO messages
      may be used to populate routing table entries for the '1-hop' neighbors,
      which may be useful in some cases as a shortcut for P2P flows.</t>

      <section anchor="DestinationAdvertisementObject"
               title="Destination Advertisement Object (DAO)">
        <t>The Destination Advertisement Object (DAO) is used to propagate
        destination information upwards along the DODAG.</t>

        <t><figure anchor="DAObject"
            title="The Destination Advertisement Object (DAO)">
            <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |         DAO Sequence          |           DAO Rank            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | RPLInstanceID |   Route Tag   | Prefix Length |    RRCount    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          DAO Lifetime                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Destination Prefix (Variable Length)              |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Reverse Route Stack (Variable Length)             |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   sub-option(s)...
    +-+-+-+-+-+-+-+-+
]]></artwork>
          </figure></t>

        <t><list hangIndent="6" style="hanging">
            <t hangText="DAO Sequence:">16-bit unsigned integer. Incremented
            by the node that owns the prefix for each new DAO message for that
            prefix.</t>

            <t hangText="DAO Rank:">16-bit unsigned integer indicating the DAO
            Rank associated with the advertised Destination Prefix. The DAO
            Rank is analogous to the Rank in the DIO message in that it may be
            used to convey a relative distance to the Destination Prefix as
            computed by the Objective Function in use over the DODAG. It
            serves as a mechanism by which an ancestor node may order
            alternate DAO paths.</t>

            <t hangText="RPLInstanceID:">8-bit field indicating the topology
            instance associated with the DODAG, as learned from the DIO.</t>

            <t hangText="Route Tag:">8-bit unsigned integer. The Route Tag may
            be used to give a priority to prefixes that should be stored. This
            may be useful in cases where intermediate nodes are capable of
            storing a limited amount of routing state. The further
            specification of this field and its use is under
            investigation.</t>

            <t hangText="Prefix Length:">8-bit unsigned integer. Number of
            valid leading bits in the IPv6 Prefix.</t>

            <t hangText="RRCount:">8-bit unsigned integer. This counter is
            used to count the number of entries in the Reverse Route Stack. A
            value of '0' indicates that no Reverse Route Stack is present.</t>

            <t hangText="DAO Lifetime:">32-bit unsigned integer. The length of
            time in seconds (relative to the time the packet is sent) that the
            prefix is valid for route determination. A value of all one bits
            (0xFFFFFFFF) represents infinity. A value of all zero bits
            (0x00000000) indicates a loss of reachability.</t>

            <t hangText="Destination Prefix:">Variable-length field
            identifying an IPv6 destination address, prefix, or multicast
            group. The Prefix Length field contains the number of valid
            leading bits in the prefix. The bits in the prefix after the
            prefix length (if any) are reserved and MUST be set to zero on
            transmission and MUST be ignored on receipt.</t>

            <t hangText="Reverse Route Stack:">Variable-length field
            containing a sequence of RRCount (possibly compressed) IPv6
            addresses. A node that adds on to the Reverse Route Stack will
            append to the list and increment the RRCount.</t>
          </list></t>

        <section anchor="DAOSuboptions" title="DAO Suboptions">
          <t>The DAO message may optionally include a number of
          suboptions.</t>

          <t>The DAO suboptions are in the same format as the DIO Suboptions
          described in <xref target="DAOSuboptions"></xref>.</t>

          <t>In particular, a DAO message may include a DAG Metric Container
          suboption as described in <xref target="DIOMetricContainer"></xref>.
          This suboption may be present in implementations where the DAO Rank
          is insufficient to optimize a path to the DAO Destination
          Prefix.</t>
        </section>
      </section>

      <section anchor="DownwardDiscovery"
               title="Downward Route Discovery and Maintenance">
        <section title="Overview">
          <t>Destination Advertisement operation produces DAO messages that
          flow up the DODAG, provisioning downward routing state for
          destination prefixes available in the sub-DODAG of the DODAG root,
          and possibly other nodes. The routing state provisioned with this
          mechanism is in the form of soft-state routing table entries. DAO
          messages are able to record loose source routing information as by
          propagate up the DODAG. This mechanism is flexible to support the
          provisioning of paths which consist of fully specified source
          routes, piecewise source routes, or hop-by-hop routes as according
          to the implementation and the capabilities of the nodes.</t>

          <t>Destination Advertisement may or may not be enabled over a DODAG
          rooted at a DODAG root. This is an a priori configuration determined
          by the implementation/deployment and not generally changed during
          the operation of the RPL LLN.</t>

          <t>When Destination Advertisement is enabled:</t>

          <t><list style="numbers">
              <t>Some nodes in the LLN MAY store at least one routing table
              entry for a particular destination learned from a DAO. Such a
              node is termed a 'storing node', with respect to that particular
              destination.</t>

              <t>Some nodes are capable to store at least one routing table
              entry for every unique destination observed from all DAOs that
              pass through. Such a node is termed a 'fully storing node'.</t>

              <t>DODAG roots nodes SHOULD be fully-storing nodes.</t>

              <t>Other nodes in the DODAG are not required to store routing
              table entries for any particular destinations observed in DAOs.
              Nodes that do not store routing table entries from DAOs are
              termed 'non-storing nodes', with respect to a particular
              destination.</t>

              <t>Non-storing nodes MUST participate in the construction of
              piecewise source routes as they propagate the DAO message, as
              described in <xref target="DAONonStoring"></xref>.</t>

              <t>Storing nodes MUST store any source route information
              received from the DAO (RRStack) in the routing table entry
              entry. If a node is not capable to do this then it must act as a
              non-storing node with respect to that particular
              destination.</t>

              <t>Storing nodes MUST use piecewise source routes in order to
              forward data across a non-storing region of the LLN. The source
              routing mechanism is to be described in a companion
              specification. (If a node is not capable to do this, then that
              node MUST NOT operate as a storing node).</t>
            </list></t>
        </section>

        <section title="Mode of Operation">
          <t><list style="symbols">
              <t>DAO Operation may not be required for all use cases.</t>

              <t>Some applications may only need support for
              collection/upward/MP2P flow with no acknowledgement/reciprocal
              traffic.</t>

              <t>Some DODAGs may not support DAO Operation, which could mean
              that DAO Operation is wasteful overhead.</t>

              <t>As a special case, multicast DAO operation may be used to
              populate 'one-hop' neighborhood routing table entries, and is
              distinct from the unicast DAO operation used to establish
              downward routes along the DODAG.</t>
            </list></t>

          <t><list style="numbers">
              <t>The 'A' flag in the DIO as conveyed from the DODAG root
              serves to enable/disable DAO operation over the entire DODAG.
              This flag should be administratively provisioned a priori at the
              DODAG root as a function of the implementation/deployment and
              not tend to change.</t>

              <t>When DAO Operation is disabled, a node SHOULD NOT emit
              DAOs.</t>

              <t>When DAO Operation is disabled, a node MAY ignore received
              DAOs.</t>
            </list></t>
        </section>

        <section title="Destination Advertisement Parents">
          <t><list style="symbols">
              <t>Nodes will select a subset of their DODAG Parents to whom
              DAOs will be sent<list style="symbols">
                  <t>This subset is the set of 'DAO Parents'</t>

                  <t>Each DAO parent MUST be a DODAG Parent. (Not all DODAG
                  parents need to be DAO parents).</t>

                  <t>Operation with more than DAO Parent requires
                  consideration of such issues as DAO fan-out and path
                  diversity, to be elaborated in a future version of this
                  specification.</t>
                </list></t>

              <t>The selection of DAO parents is implementation specific and
              may be based on selecting the DODAG Parents that offer the best
              upwards cost (as opposed to downwards or mixed), as determined
              by the metrics in use and the Objective Function.</t>

              <t>When DAO messages are unicast to the DAO Parent, the identity
              of the DAO Parent (DODAGID x DAGSequenceNumber) combined with
              the RPLInstanceID in the DAO message unambiguously associates
              the DAO message, and thus the particular destination prefix,
              with a DODAG Iteration.</t>

              <t>When DAO messages are unicast to the DAO Parent, the DAO Rank
              may be updated as according to the implementation and Objective
              Function in use to reflect the relative (aggregated) cost of
              reaching the Destination Prefix through that DAO parent. As a
              further extension, a DAO Suboption for the Metric Container may
              be included.</t>
            </list></t>
        </section>

        <section title="Operation of DAO Storing Nodes">
          <section title="DAO Routing Table Entry">
            <?rfc subcompact="yes"?>

            <t>A DAO Routing Table Entry conceptually contains the following
            elements:</t>

            <t><list style="symbols">
                <t>Advertising Neighbor Information <list style="symbols">
                    <t>IPv6 Addr</t>

                    <t>Interface ID</t>
                  </list></t>

                <t>To which DAO Parents has this entry been reported</t>

                <t>Retry Counter</t>

                <t>Logical equivalent of DAO Content: <list style="symbols">
                    <t>DAO Sequence</t>

                    <t>DAO Rank</t>

                    <t>DAO Lifetime</t>

                    <t>Route tag (used to prioritize which destination entries
                    should be stored)</t>

                    <t>Destination Prefix (or Address or Mcast Group)</t>

                    <t>RR Stack*</t>
                  </list></t>
              </list></t>

            <?rfc subcompact="no"?>

            <t>The DAO Routing Table Entry is logically associated with the
            following states:</t>

            <t><list hangIndent="12" style="hanging">
                <t hangText="CONNECTED">This entry is 'owned' by the node - it
                is manually configured and is considered as a 'self' entry for
                DAO Operation</t>

                <t hangText="REACHABLE">This entry has been reported from a
                neighbor of the node. This state includes the following
                substates: <list hangIndent="10" style="hanging">
                    <t hangText="CONFIRMED">This entry is active, newly
                    validated, and usable</t>

                    <t hangText="PENDING">This entry is active, awaiting
                    validation, and usable. A Retry Counter is associated with
                    this substate</t>
                  </list></t>

                <t hangText="UNREACHABLE">This entry is being cleaned up. This
                entry may be suppressed when the cleanup process is
                complete.</t>
              </list></t>

            <t>When an attempt is to be made to report the DAO entry to DAO
            Parents, the DAO Entry record is logically marked to indicate that
            an attempt has not yet been made for each parent. As the unicast
            attempts are completed for each parent, this mark may be cleared.
            This mechanism may serve to limit DAO entry updates for each
            parent to a subset that needs to be reported.</t>

            <section title="DAO Routing Table Entry Management">
              <figure title="DAO Routing Table Entry FSM">
                <artwork><![CDATA[
                                                                     
        +---------------------------------+                          
        |                                 |                          
        |            REACHABLE            |    +-------------+       
        |                                 |    |             |       
        |        +-----------+            |    |  CONNECTED  |       
  (*)----------->|           |-------+    |    |             |       
        |        | Confirmed |       |    |    +-------------+       
        |    +-->|           |---+   |    |                          
        |    |   +-----------+   |   |    |                          
        |    |                   |   |    |                          
        |    |                   |   |    |                          
        |    |                   |   |    |                          
        |    |   +-----------+   |   |    |    +-------------+       
        |    |   |           |<--+   +-------->|             |       
        |    +---|  Pending  |            |    | UNREACHABLE |       
        |        |           |---------------->|             |--->(*)
        |        +-----------+            |    +-------------+       
        |                                 |                          
        +---------------------------------+                          
                                                                     
]]></artwork>
              </figure>

              <section title="Operation in the CONNECTED state">
                <t><list style="numbers">
                    <t>CONNECTED DAO entries are to be provisioned outside of
                    the context of RPL, e.g. through a management API. An
                    implementation SHOULD provide a means to provision/manage
                    CONNECTED DAO entries, including whether they are to be
                    redistributed in RPL.</t>
                  </list></t>
              </section>

              <section title="Operation in the REACHABLE state">
                <t><list style="numbers">
                    <t>When a REACHABLE(*) entry times out, i.e. the DAO
                    Lifetime has elapsed, the entry MUST be placed into the
                    UNREACHABLE state and no-DAO SHOULD be scheduled to send
                    to the node's DAO Parents.</t>

                    <t>When a no-DAO for a REACHABLE(*) entry is received with
                    a newer DAO Sequence Number, the entry MUST be placed into
                    the UNREACHABLE state and no-DAO SHOULD be scheduled to
                    send to the node's DAO Parents.</t>

                    <t>When a REACHABLE(*) entry is to be removed because NUD
                    or equivalent has determined that the next-hop neighbor is
                    no longer reachable, the entry MUST be placed into the
                    UNREACHABLE state and no-DAO SHOULD be scheduled to send
                    to the node's DAO Parents.</t>

                    <t>When a REACHABLE(*) entry is to be removed because an
                    associated Forwarding Error has been returned by the
                    next-hop neighbor, the entry MUST be placed into the
                    UNREACHABLE state and no-DAO SHOULD be scheduled to send
                    to the node's DAO Parents.</t>

                    <t>When a DAO (or no-DAO) for a REACHABLE(*) entry is
                    received with an older or unchanged DAO Sequence Number,
                    then the DAO (or no-DAO) SHOULD be ignored and the
                    associated entry MUST NOT be updated with the stale
                    information.</t>
                  </list></t>

                <section title="REACHABLE(Confirmed)">
                  <t><list style="numbers">
                      <t>When a DAO for a previously unknown (or UNREACHABLE)
                      destination is received and is to be stored, it MUST be
                      entered into the routing table in the
                      REACHABLE(Confirmed) state, and a DAO SHOULD be
                      scheduled to send to the node's DAO Parents. Alternately
                      the node may behave as a non-storing node with respect
                      to this destination.</t>

                      <t>When a DAO for a REACHABLE(Confirmed) entry is
                      received with a newer DAO Sequence Number, the entry
                      MUST be updated with the logical equivalent of the DAO
                      contents and a DAO SHOULD be scheduled to send to the
                      node's DAO Parents.</t>

                      <t>When a DAO for a REACHABLE(Confirmed) entry is
                      expected, e.g. because a DIO to request a DAO refresh is
                      sent, then the DAO entry MUST be placed in the
                      REACHABLE(Pending) state and the associated Retry
                      Counter MUST be set to 0.</t>
                    </list></t>
                </section>

                <section title="REACHABLE(Pending)">
                  <t><list style="numbers">
                      <t>When a DAO for a REACHABLE(Pending) entry is received
                      with a newer DAO Sequence Number, the entry MUST be
                      updated with the logical equivalent of the DAO contents
                      and the entry MUST be placed in the REACHABLE(Confirmed)
                      state.</t>

                      <t>When a DAO for a REACHABLE(Pending) entry is
                      expected, e.g. because DAO has (again) been triggered
                      with respect to that neighbor, then the associated Retry
                      Counter MUST be incremented.</t>

                      <t>When the associated Retry Counter for a
                      REACHABLE(Pending) entry reaches a maximum threshold,
                      the entry MUST be placed into the UNREACHABLE state and
                      no-DAO SHOULD be scheduled to send to the node's DAO
                      Parents.</t>
                    </list></t>
                </section>
              </section>

              <section anchor="DAOUnreachable"
                       title="Operation in the UNREACHABLE state">
                <t><list style="numbers">
                    <t>An implementation SHOULD bound the time that the entry
                    is allocated in the UNREACHABLE state. Upon the equivalent
                    expiry of the related timer (RemoveTimer), the entry
                    SHOULD be suppressed.</t>

                    <t>While the entry is in the UNREACHABLE state a node
                    SHOULD make a reasonable attempt to report a no-DAO to
                    each of the DAO parents.</t>

                    <t>When the node has completed an attempt to report a
                    no-DAO to each of the DAO parents, the entry SHOULD be
                    suppressed.</t>
                  </list></t>
              </section>
            </section>
          </section>
        </section>

        <section anchor="DAONonStoring"
                 title="Operation of DAO Non-storing Nodes">
          <t><list style="numbers">
              <t>When a DAO is received from a child by a node who will not
              store a routing table entry for the DAO, the node MUST schedule
              to pass the DAO contents along to its DAO parents. Prior to
              passing the DAO along, the node MUST process the DAO as follows,
              in order that information necessary to construct a loose source
              route may be accumulated within the DAO payload as it moves up
              the DODAG:<list style="numbers">
                  <t>The most recent addition to the RRStack (the 'next
                  waypoint') is investigated to determine if the node already
                  has a route provisioned to the waypoint. If the node already
                  has such a route, then it is not necessary to add additional
                  information to the RRStack. The node SHOULD NOT modify the
                  RRStack further.</t>

                  <t>If the node does not have a route provisioned to the next
                  waypoint, then the node MUST append the address of the child
                  to the RRStack, and increment RRCount.</t>
                </list></t>
            </list></t>
        </section>

        <section anchor="ScheduleDAO"
                 title="Scheduling to Send DAO (or no-DAO)">
          <t><list style="numbers">
              <t>An implementation SHOULD arrange to rate-limit the sending of
              DAOs.</t>

              <t>When scheduling to send a DAO, an implementation SHOULD
              equivalently start a timer (DelayDAO) to delay sending the DAO.
              If the DelayDAO timer is already running then the DAO may be
              considered as already scheduled, and implementation SHOULD leave
              the timer running at its present duration.</t>
            </list></t>

          <t><list style="symbols">
              <t>When computing the delay before sending a DAO, in order to
              increase the effectiveness of aggregation, an implementation MAY
              allow time to receive DAOs from its sub-DODAG prior to emitting
              DAOs to its DAO Parents. <list style="symbols">
                  <t>The scheduled delay in such cases may be, for example,
                  such that DAO_LATENCY/DAGRank(self_rank) &lt;= DelayDAO &lt;
                  DAO_LATENCY/DAGRank(parent_rank), where DAGRank() is defined
                  as in <xref target="DAGRank"></xref>, such that nodes deeper
                  in the DODAG may tend to report DAO messages first before
                  their parent nodes will report DAO messages. Note that this
                  suggestion is intended as an optimization to allow efficient
                  aggregation -- it is not required for correct operation in
                  the general case.</t>
                </list></t>
            </list></t>
        </section>

        <section title="Triggering DAO Message from the Sub-DODAG">
          <t>Triggering DAO messages from the Sub-DODAG occurs by using the
          following control fields with the rules described below:</t>

          <t>The DTSN field from the DIO is a sequence number that is part of
          the mechanism to trigger DAO messages. The motivation to use a
          sequence number is to provide some means of reliable signaling to
          the sub-DODAG-- whereas a control flag that is activated for a short
          time may be unobserved by the sub-DODAG if the triggering DIO
          messages are lost, the DTSN increment may be observed later even if
          some DIO messages have been lost since the sequence number
          increment.</t>

          <t>The 'T' flag provides a way to signal the refresh of DAO
          information over the entire DODAG iteration. Whereas a DTSN
          increment may only trigger a DAO refresh as far as the nearest
          storing node (because a storing node will not increment its own DTSN
          in response, as described in the rules below), the assertion of the
          'T' flag in conjunction with an incremented DTSN will 'punch
          through' storing nodes to elicit a DAO refresh from the entire DODAG
          Iteration.</t>

          <t>The 'S' flag provides a way to signal to a sub-DODAG that there
          is at least one non-root node somewhere in the set of DODAG
          ancestors, where that non-root node is a storing node. This allows
          for an optimization-- when it is clear to a non-storing node that
          the root node can be the only storing ancestor, then that node does
          not necessarily need to trigger updates from its sub-DODAG when it
          modifies its DAO parent set. The motivation here is that the root
          node should be able to update its stored source routing information
          for the affected sub-DODAG based only on receiving DAO information
          concerning the link that changed. In the other case, when the 'S'
          flag is set, the non-storing node does not have a means to determine
          which DAO information may (or may not) need to be updated in the
          intermediate storing node so it must trigger DAO messages in order
          to update the intermediate storing node. Please note that some
          aspects of the proper use of the 'S' flag remain under
          investigation.</t>

          <t>Further examples of triggering DAO messages are contained in
          <xref target="Examples"></xref>.</t>

          <t>The control fields are used to trigger DAO messages as
          follows:</t>

          <t><list style="numbers">
              <t>The DODAG root MUST clear the 'S' flag when it emits DIO
              messages.</t>

              <t>Non-root nodes that store routing table entries learned from
              DAOs MUST set the 'S' flag when they emit DIO messages.</t>

              <t>A node that has any DAO Parent with the 'S' flag set MUST
              also set the 'S' flag when it emits DIO messages.</t>

              <t>A node that has all DAO Parents with cleared 'S' flags, and
              does not store routing table entries learned from DAOs, MUST
              clear the 'S' flag when it emits DIO messages.</t>

              <t>A DAO Trigger Sequence Number (DTSN) MUST be maintained by
              each node per RPL Instance. The DTSN, in conjunction with the
              'T' flag from the DIO message, provides a means by which DAO
              messages may be reliably triggered in the event of topology
              change.</t>

              <t>The DTSN MUST be advertised by the node in the DIO
              message.</t>

              <t>A node keeps track of the DTSN that it has heard from the
              last DIO from each of its DAO Parents. Note that there is one
              DTSN maintained per DAO Parent- each DAO Parent may
              independently increment it at will.</t>

              <t>A node that is not a fully-storing node SHOULD increment its
              own DTSN when it adds a new parent, that parent having the 'S'
              flag set, to its DAO Parent set. It MAY defer advertising the
              increment as long as it has a DAO parent that already provides
              adequate connectivity.</t>

              <t>A node that is not a fully-storing node MUST increment its
              own DTSN when it receives a DIO from a DAO Parent that contains
              a newly incremented DTSN. (The newly incremented DTSN is
              detected by comparing the value received in the DIO with the
              value last recorded for that DAO parent).</t>

              <t>A fully-storing node MUST increment its own DTSN when it
              receives a DIO from a DAO Parent that contains a newly
              incremented DTSN and a set 'T' flag.</t>

              <t>When a storing or non-storing node joins a new DODAG
              iteration, it SHOULD increment its DTSN as if the 'T' flag has
              been set.</t>

              <t>DAO Transmission SHOULD be scheduled when a new parent is
              added to the DAO Parent set.</t>

              <t>A node that receives a newly incremented DTSN from a DAO
              Parent MUST schedule a DAO transmission.</t>
            </list></t>

          <t><list style="symbols">
              <t>When a node that is not fully-storing sees a DTSN increment,
              it will increment its own DTSN. This will cause the DTSN
              increment to extend down the DODAG to the first fully-storing
              node, which will send its DAOs back up, rebuilding source routes
              information along the way to the first node that incremented the
              DTSN, who then may report the new DAO information to its new
              parent.</t>

              <t>When a fully-storing node sees a DTSN increment, it is caused
              to reissue its entire set of routing table entries learned from
              DAOs (or an aggregated subset thereof), but will not need to
              increment its own DTSN. The 'DTSN increment wave' stops when it
              encounters fully-storing nodes.</t>

              <t>When a fully-storing node sees a DTSN increment AND the 'T'
              flag is set, it does increment its own DTSN as well. The 'T'
              flag 'punches through' all nodes, causing all routing tables in
              the entire sub-DODAG to be refreshed.</t>
            </list></t>
        </section>

        <section title="Sending DAO Messages to DAO Parents">
          <t><list style="numbers">
              <t>When storing nodes send DAO messages for stored entries the
              RRStack SHOULD be cleared in the DAO message.</t>

              <t>DAO Messages sent to DAO Parents MUST be unicast.<list
                  style="symbols">
                  <t>The IPv6 Source Address is the node sending the DAO
                  message.</t>

                  <t>The IPv6 Destination Address is DAO parent.</t>
                </list></t>

              <t>When the appointed time arrives (DelayDAO) for the
              transmission of DAO messages (with jitter as appropriate) for
              the requested entries, the implementation MAY aggregate the the
              entries into a reduced numbers of DAOs to be reported to each
              parent, and perform compression if possible.</t>

              <t>Note: it is NOT RECOMMENDED that a DAO Transmission (No-DAO)
              be scheduled when a DAO Parent is removed from the DAO Parent
              set.</t>
            </list></t>
        </section>

        <section anchor="MulticastDAO"
                 title="Multicast Destination Advertisement Messages">
          <t>A special case of DAO operation, distinct from unicast DAO
          operation, is multicast DAO operation which may be used to populate
          '1-hop' routing table entries.</t>

          <t><list style="numbers">
              <t>A node MAY multicast a DAO message to the link-local scope
              all-nodes multicast address FF02::1.</t>

              <t>A multicast DAO message MUST be used only to advertise
              information about self, i.e. prefixes directly connected to or
              owned by this node, such as a multicast group that the node is
              subscribed to or a global address owned by the node.</t>

              <t>A multicast DAO message MUST NOT be used to relay
              connectivity information learned (e.g. through unicast DAO) from
              another node.</t>

              <t>Information obtained from a multicast DAO MAY be installed in
              the routing table and MAY be propagated by a node in unicast
              DAOs.</t>

              <t>A node MUST NOT perform any other DAO related processing on a
              received multicast DAO, in particular a node MUST NOT perform
              the actions of a DAO parent upon receipt of a multicast DAO.</t>
            </list></t>

          <t><list style="symbols">
              <t>The multicast DAO may be used to enable direct P2P
              communication, without needing the RPL routing structure to
              relay the packets.</t>

              <t>The multicast DAO does not presume any DODAG relationship
              between the emitter and the receiver.</t>
            </list></t>
        </section>
      </section>
    </section>

    <!--
    <section anchor="CrossRoutes" title="Cross-Routes"></section>
    -->

    <section anchor="forwarding"
             title="Packet Forwarding and Loop Avoidance/Detection">
      <section anchor="PacketForwarding"
               title="Suggestions for Packet Forwarding">
        <t>When forwarding a packet to a destination, precedence is given to
        selection of a next-hop successor as follows:</t>

        <t><list style="numbers">
            <t>In the scope of this specification, it is preferred to select a
            successor from a DODAG iteration that matches the RPLInstanceID
            marked in the IPv6 header of the packet being forwarded.</t>

            <t>If a local administrative preference favors a route that has
            been learned from a different routing protocol than RPL, then use
            that successor.</t>

            <t>If there is an entry in the routing table matching the
            destination that has been learned from a multicast destination
            advertisement (e.g. the destination is a one-hop neighbor), then
            use that successor.</t>

            <t>If there is an entry in the routing table matching the
            destination that has been learned from a unicast destination
            advertisement (e.g. the destination is located down the
            sub-DODAG), then use that successor.</t>

            <t>If there is a DODAG iteration offering a route to a prefix
            matching the destination, then select one of those DODAG parents
            as a successor.</t>

            <t>If there is a DODAG parent offering a default route then select
            that DODAG parent as a successor.</t>

            <t>If there is a DODAG iteration offering a route to a prefix
            matching the destination, but all DODAG parents have been tried
            and are temporarily unavailable (as determined by the forwarding
            procedure), then select a DODAG sibling as a successor.</t>

            <t>Finally, if no DODAG siblings are available, the packet is
            dropped. ICMP Destination Unreachable may be invoked. An
            inconsistency is detected.</t>
          </list></t>

        <t>TTL MUST be decremented when forwarding. If the packet is being
        forwarded via a sibling, then the TTL MAY be decremented more
        aggressively (by more than one) to limit the impact of possible
        loops.</t>

        <t>Note that the chosen successor MUST NOT be the neighbor that was
        the predecessor of the packet (split horizon), except in the case
        where it is intended for the packet to change from an up to an down
        flow, such as switching from DIO routes to DAO routes as the
        destination is neared.</t>
      </section>

      <section anchor="loopdetect" title="Loop Avoidance and Detection">
        <t>RPL loop avoidance mechanisms are kept simple and designed to
        minimize churn and states. Loops may form for a number of reasons,
        from control packet loss to sibling forwarding. RPL includes a
        reactive loop detection technique that protects from meltdown and
        triggers repair of broken paths.</t>

        <t>RPL loop detection uses information that is placed into the packet
        in the IPv6 flow label. The IPv6 flow label is defined in <xref
        target="RFC2460"></xref> and its operation is further specified in
        <xref target="RFC3697"></xref>. For the purpose of RPL operations, the
        flow label is constructed as follows:</t>

        <t><figure anchor="flowlabel" title="RPL Flow Label">
            <artwork><![CDATA[
     0                   1                   2       
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |O|S|R|F|  SenderRank   | RPLInstanceID |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
]]></artwork>
          </figure></t>

        <t><list hangIndent="6" style="hanging">
            <t hangText="Down 'O' bit:">1-bit flag indicating whether the
            packet is expected to progress up or down. A router sets the 'O'
            bit when the packet is expect to progress down (using DAO routes),
            and resets it when forwarding towards the root of the DODAG
            iteration. A host MUST set the bit to 0.</t>

            <t hangText="Sibling 'S' bit:">1-bit flag indicating whether the
            packet has been forwarded via a sibling at the present rank, and
            denotes a risk of a sibling loop. A host sets the bit to 0.</t>

            <t hangText="Rank-Error 'R' bit:">1-bit flag indicating whether a
            rank error was detected. A rank error is detected when there is a
            mismatch in the relative ranks and the direction as indicated in
            the 'O' bit. A host MUST set the bit to 0.</t>

            <t hangText="Forwarding-Error 'F' bit:">1-bit flag indicating that
            this node can not forward the packet further towards the
            destination. The 'F' bit might be set by sibling that can not
            forward to a parent a packet with the Sibling 'S' bit set, or by a
            child node that does not have a route to destination for a packet
            with the down 'O' bit set. A host MUST set the bit to 0.</t>

            <t hangText="SenderRank:">8-bit field set to zero by the source
            and to DAGRank(rank) by a router that forwards inside the RPL
            network. (Note that the case where DAGRank(rank) does not fit into
            8 bits is under investigation.)</t>

            <t hangText="RPLInstanceID:">8-bit field indicating the DODAG
            instance along which the packet is sent.</t>
          </list></t>

        <section title="Source Node Operation">
          <t>A packet that is sourced at a node connected to a RPL network or
          destined to a node connected to a RPL network MUST be issued with
          the flow label zeroed out, but for the RPLInstanceID field.</t>

          <t>If the source is aware of the RPLInstanceID that is preferred for
          the flow, then it MUST set the RPLInstanceID field in the flow label
          accordingly, otherwise it MUST set it to the
          RPL_DEFAULT_INSTANCE.</t>

          <t>If a compression mechanism such as 6LoWPAN is applied to the
          packet, the flow label MUST NOT be compressed even if it is set to
          all zeroes.</t>
        </section>

        <section title="Router Operation">
          <section title="Conformance to RFC 3697">
            <t><xref target="RFC3697"></xref> mandates that the Flow Label
            value set by the source MUST be delivered unchanged to the
            destination node(s).</t>

            <t>In order to restore the flow label to its original value, an
            RPL router that delivers a packet to a destination connected to a
            RPL network or that routes a packet outside the RPL network MUST
            zero out all the fields but the RPLInstanceID field that must be
            delivered without a change.</t>
          </section>

          <section title="Instance Forwarding">
            <t>Instance IDs are used to avoid loops between DODAGs from
            different origins. DODAGs that constructed for antagonistic
            constraints might contain paths that, if mixed together, would
            yield loops. Those loops are avoided by forwarding a packet along
            the DODAG that is associated to a given instance.</t>

            <t>The RPLInstanceID is placed by the source in the flow label.
            This RPLInstanceID MUST match the RPL Instance onto which the
            packet is placed by any node, be it a host or router.</t>

            <t>When a router receives a packet that specifies a given
            RPLInstanceID and the node can forward the packet along the DODAG
            associated to that instance, then the router MUST do so and leave
            the RPLInstanceID flag unchanged.</t>

            <t>If any node can not forward a packet along the DODAG associated
            to the RPLInstanceID in the flow label, then the node SHOULD
            discard the packet.</t>
          </section>

          <section title="DAG Inconsistency Loop Detection">
            <t>The DODAG is inconsistent if the direction of a packet does not
            match the rank relationship. A receiver detects an inconsistency
            if it receives a packet with either: <list>
                <t>the 'O' bit set (to down) from a node of a higher rank.</t>

                <t>the 'O' bit reset (for up) from a node of a lesser
                rank.</t>

                <t>the 'S' bit set (to sibling) from a node of a different
                rank.</t>
              </list></t>

            <t>When the DODAG root increments the DODAGSequenceNumber a
            temporary rank discontinuity may form between the next iteration
            and the prior iteration, in particular if nodes are adjusting
            their rank in the next iteration and deferring their migration
            into the next iteration. A router that is still a member of the
            prior iteration may choose to forward a packet to a (future)
            parent that is in the next iteration. In some cases this could
            cause the parent to detect an inconsistency because the
            rank-ordering in the prior iteration is not necessarily the same
            as in the next iteration and the packet may be judged to not be
            making forward progress. If the sending router is aware that the
            chosen successor has already joined the next iteration, then the
            sending router MUST update the SenderRank to INFINITE_RANK as it
            forwards the packets across the discontinuity into the next DODAG
            iteration in order to avoid a false detection of rank
            inconsistency.</t>

            <!--
            <t>The propagation of a new sequence creates local
            inconsistencies. In particular, it is possible for a router to
            forward a packet to a future parent (same instance, same DODAGID,
            higher sequence) without a loop, regardless of the rank of that
            parent. In that case, the sending router MUST present itself as a
            host on the future DODAG iteration and use a rank of INFINITE_RANK
            as it forwards the packets via a future parent to avoid a false
            positive.</t>
            -->

            <t>One inconsistency along the path is not considered as a
            critical error and the packet may continue. But a second detection
            along the path of a same packet should not occur and the packet is
            dropped.</t>

            <t>This process is controlled by the Rank-Error bit in the Flow
            Label. When an inconsistency, is detected on a packet, if the
            Rank-Error bit was not set then the Rank-Error bit is set. If it
            was set the packet is discarded and the trickle timer is
            reset.</t>
          </section>

          <section title="Sibling Loop Avoidance">
            <t>When a packet is forwarded along siblings, it cannot be checked
            for forward progress and may loop between siblings. Experimental
            evidence has shown that one sibling hop can be very useful but is
            generally sufficient to avoid loops. Based on that evidence, this
            specification enforces the simple rule that a packet may not make
            2 sibling hops in a row.</t>

            <t>When a host issues a packet or when a router forwards a packet
            to a non-sibling, the Sibling bit in the packet must be reset.
            When a router forwards to a sibling: if the Sibling bit was not
            set then the Sibling bit is set. If the Sibling bit was set then
            then the router SHOULD return the packet to the sibling that that
            passed it with the Forwarding-Error 'F' bit set.</t>
          </section>

          <section title="DAO Inconsistency Loop Detection and Recovery">
            <t>A DAO inconsistency happens when router that has an down DAO
            route via a child that is a remnant from an obsolete state that is
            not matched in the child. With DAO inconsistency loop recovery, a
            packet can be used to recursively explore and cleanup the obsolete
            DAO states along a sub-DODAG.</t>

            <t>In a general manner, a packet that goes down should never go up
            again. If DAO inconsistency loop recovery is applied, then the
            router SHOULD send the packet to the parent that passed it with
            the Forwarding-Error 'F' bit set. Otherwise the router MUST
            silently discard the packet.</t>
          </section>

          <section title="Forward Path Recovery">
            <t>Upon receiving a packet with a Forwarding-Error bit set, the
            node MUST remove the routing states that caused forwarding to that
            neighbor, clear the Forwarding-Error bit and attempt to send the
            packet again. The packet may its way to an alternate neighbor. If
            that alternate neighbor still has an inconsistent DAO state via
            this node, the process will recurse, this node will set the
            Forwarding-Error 'F' bit and the routing state in the alternate
            neighbor will be cleaned up as well.</t>
          </section>
        </section>
      </section>
    </section>

    <section title="Multicast Operation">
      <t>This section describes further the multicast routing operations over
      an IPv6 RPL network, and specifically how unicast DAOs can be used to
      relay group registrations up. Wherever the following text mentions
      Multicast Listener Discovery (MLD), one can read MLDv2 (<xref
      target="RFC3810"></xref>) or v3.</t>

      <t>As is traditional, a listener uses a protocol such as MLD with a
      router to register to a multicast group.</t>

      <t>Along the path between the router and the DODAG root, MLD requests
      are mapped and transported as DAO messages within the RPL protocol; each
      hop coalesces the multiple requests for a same group as a single DAO
      message to the parent(s), in a fashion similar to proxy IGMP, but
      recursively between child router and parent up to the root.</t>

      <t>A router might select to pass a listener registration DAO message to
      its preferred parent only, in which case multicast packets coming back
      might be lost for all of its sub-DODAG if the transmission fails over
      that link. Alternatively the router might select to copy additional
      parents as it would do for DAO messages advertising unicast
      destinations, in which case there might be duplicates that the router
      will need to prune.</t>

      <t>As a result, multicast routing states are installed in each router on
      the way from the listeners to the root, enabling the root to copy a
      multicast packet to all its children routers that had issued a DAO
      message including a DAO for that multicast group, as well as all the
      attached nodes that registered over MLD.</t>

      <t>For unicast traffic, it is expected that the grounded root of an
      DODAG terminates RPL and MAY redistribute the RPL routes over the
      external infrastructure using whatever routing protocol is used there.
      For multicast traffic, the root MAY proxy MLD for all the nodes attached
      to the RPL routers (this would be needed if the multicast source is
      located in the external infrastructure). For such a source, the packet
      will be replicated as it flows down the DODAG based on the multicast
      routing table entries installed from the DAO message.</t>

      <t>For a source inside the DODAG, the packet is passed to the preferred
      parents, and if that fails then to the alternates in the DODAG. The
      packet is also copied to all the registered children, except for the one
      that passed the packet. Finally, if there is a listener in the external
      infrastructure then the DODAG root has to further propagate the packet
      into the external infrastructure.</t>

      <t>As a result, the DODAG Root acts as an automatic proxy Rendezvous
      Point for the RPL network, and as source towards the Internet for all
      multicast flows started in the RPL LLN. So regardless of whether the
      root is actually attached to the Internet, and regardless of whether the
      DODAG is grounded or floating, the root can serve inner multicast
      streams at all times.</t>
    </section>

    <section anchor="MaintenanceRoutingAdjacency"
             title="Maintenance of Routing Adjacency">
      <t>The selection of successors, along the default paths up along the
      DODAG, or along the paths learned from destination advertisements down
      along the DODAG, leads to the formation of routing adjacencies that
      require maintenance.</t>

      <t>In IGPs such as OSPF <xref target="RFC4915"></xref> or IS-IS <xref
      target="RFC5120"></xref>, the maintenance of a routing adjacency
      involves the use of Keepalive mechanisms (Hellos) or other protocols
      such as BFD (<xref target="I-D.ietf-bfd-base"></xref>) and MANET
      Neighborhood Discovery Protocol (NHDP <xref
      target="I-D.ietf-manet-nhdp"></xref>). Unfortunately, such an approach
      is not desirable in constrained environments such as LLN and would lead
      to excessive control traffic in light of the data traffic with a
      negative impact on both link loads and nodes resources. Overhead to
      maintain the routing adjacency should be minimized. Furthermore, it is
      not always possible to rely on the link or transport layer to provide
      information of the associated link state. The network layer needs to
      fall back on its own mechanism.</t>

      <t>Thus RPL makes use of a different approach consisting of probing the
      neighbor using a Neighbor Solicitation message (see <xref
      target="RFC4861"></xref>). The reception of a Neighbor Advertisement
      (NA) message with the "Solicited Flag" set is used to verify the
      validity of the routing adjacency. Such mechanism MAY be used prior to
      sending a data packet. This allows for detecting whether or not the
      routing adjacency is still valid, and should it not be the case, select
      another feasible successor to forward the packet.</t>
    </section>

    <section title="Guidelines for Objective Functions">
      <t>An Objective Function (OF) allows for the selection of a DODAG to
      join, and a number of peers in that DODAG as parents. The OF is used to
      compute an ordered list of parents. The OF is also responsible to
      compute the rank of the device within the DODAG iteration.</t>

      <t>The Objective Function is indicated in the DIO message using an
      Objective Code Point (OCP), as specified in <xref
      target="I-D.ietf-roll-routing-metrics"></xref>, and indicates the method
      that must be used to construct the DODAG (e.g. "minimize the path cost
      using the ETX metric and avoid 'Blue' links"). The Objective Code Points
      are specified in <xref target="I-D.ietf-roll-routing-metrics"></xref>,
      <xref target="I-D.ietf-roll-of0"></xref>, and related companion
      specifications.</t>

      <t>Most Objective Functions are expected to follow the same abstract
      behavior: <list style="symbols">
          <t>The parent selection is triggered each time an event indicates
          that a potential next hop information is updated. This might happen
          upon the reception of a DIO message, a timer elapse, or a trigger
          indicating that the state of a candidate neighbor has changed.</t>

          <t>An OF scans all the interfaces on the device. Although there may
          typically be only one interface in most application scenarios, there
          might be multiple of them and an interface might be configured to be
          usable or not for RPL operation. An interface can also be configured
          with a preference or dynamically learned to be better than another
          by some heuristics that might be link-layer dependent and are out of
          scope. Finally an interface might or not match a required criterion
          for an Objective Function, for instance a degree of security. As a
          result some interfaces might be completely excluded from the
          computation, while others might be more or less preferred.</t>

          <t>An OF scans all the candidate neighbors on the possible
          interfaces to check whether they can act as a router for a DODAG.
          There might be multiple of them and a candidate neighbor might need
          to pass some validation tests before it can be used. In particular,
          some link layers require experience on the activity with a router to
          enable the router as a next hop.</t>

          <t>An OF computes self's rank by adding to the rank of the candidate
          a value representing the relative locations of self and the
          candidate in the DODAG iteration.<list style="symbols">
              <t>The increase in rank must be at least MinHopRankIncrease.
              (This prevents the creation of a path of sibling links
              connecting a child with its parent.)</t>

              <t>To keep loop avoidance and metric optimization in alignment,
              the increase in rank should reflect any increase in the metric
              value. For example, with a purely additive metric such as ETX,
              the increase in rank can be made proportional to the increase in
              the metric.</t>

              <t>Candidate neighbors that would cause self's rank to increase
              are not considered for parent selection</t>
            </list></t>

          <t>Candidate neighbors that advertise an OF incompatible with the
          set of OF specified by the policy functions are ignored.</t>

          <t>As it scans all the candidate neighbors, the OF keeps the current
          best parent and compares its capabilities with the current candidate
          neighbor. The OF defines a number of tests that are critical to
          reach the objective. A test between the routers determines an order
          relation. <list style="symbols">
              <t>If the routers are roughly equal for that relation then the
              next test is attempted between the routers,</t>

              <t>Else the best of the 2 becomes the current best parent and
              the scan continues with the next candidate neighbor</t>

              <t>Some OFs may include a test to compare the ranks that would
              result if the node joined either router</t>
            </list></t>

          <t>When the scan is complete, the preferred parent is elected and
          self's rank is computed as the preferred parent rank plus the step
          in rank with that parent.</t>

          <t>Other rounds of scans might be necessary to elect alternate
          parents and siblings. In the next rounds: <list style="symbols">
              <t>Candidate neighbors that are not in the same DODAG are
              ignored</t>

              <t>Candidate neighbors that are of greater rank than self are
              ignored</t>

              <t>Candidate neighbors of an equal rank to self (siblings) are
              ignored for parent selection</t>

              <t>Candidate neighbors of a lesser rank than self (non-siblings)
              are preferred</t>
            </list></t>
        </list></t>
    </section>

    <section title="RPL Constants and Variables">
      <t>Following is a summary of RPL constants and variables.</t>

      <t><list hangIndent="6" style="hanging">
          <!--
          <t hangText="ZERO_LIFETIME">This is the special value of a lifetime
          that indicates immediate death and removal. ZERO_LIFETIME has a
          value of 0.</t>
          -->

          <t hangText="BASE_RANK">This is the rank for a virtual root that
          might be used to coordinate multiple roots. BASE_RANK has a value of
          0.</t>

          <t hangText="ROOT_RANK">This is the rank for a DODAG root. ROOT_RANK
          has a value of 1.</t>

          <t hangText="INFINITE_RANK">This is the constant maximum for the
          rank. INFINITE_RANK has a value of 0xFFFF.</t>

          <t hangText="RPL_DEFAULT_INSTANCE">This is the RPLInstanceID that is
          used by this protocol by a node without any overriding policy.
          RPL_DEFAULT_INSTANCE has a value of 0.</t>

          <t hangText="DEFAULT_DIO_INTERVAL_MIN">TBD (To be determined)</t>

          <t hangText="DEFAULT_DIO_INTERVAL_DOUBLINGS">TBD (To be
          determined)</t>

          <t hangText="DEFAULT_DIO_REDUNDANCY_CONSTANT">TBD (To be
          determined)</t>

          <t hangText="DIO Timer">One instance per DODAG that a node is a
          member of. Expiry triggers DIO message transmission. Trickle timer
          with variable interval in [0,
          DIOIntervalMin..2^DIOIntervalDoublings]. See <xref
          target="TrickleImplementation"></xref></t>

          <t hangText="DAG Sequence Number Increment Timer">Up to one instance
          per DODAG that the node is acting as DODAG root of. May not be
          supported in all implementations. Expiry triggers revision of
          DODAGSequenceNumber, causing a new series of updated DIO message to
          be sent. Interval should be chosen appropriate to propagation time
          of DODAG and as appropriate to application requirements (e.g.
          response time vs. overhead).</t>

          <t hangText="DelayDAO Timer">Up to one instance per DAO parent (the
          subset of DODAG parents chosen to receive destination
          advertisements) per DODAG. Expiry triggers sending of DAO message to
          the DAO parent. See <xref target="ScheduleDAO"></xref></t>

          <t hangText="RemoveTimer">Up to one instance per DAO entry per
          neighbor (i.e. those neighbors that have given DAO messages to this
          node as a DODAG parent) Expiry triggers a change in state for the
          DAO entry, setting up to do unreachable (No-DAO) advertisements or
          immediately deallocating the DAO entry if there are no DAO parents.
          See <xref target="DAOUnreachable"></xref></t>
        </list></t>
    </section>

    <section anchor="Manageability" title="Manageability Considerations">
      <t>The aim of this section is to give consideration to the manageability
      of RPL, and how RPL will be operated in LLN beyond the use of a MIB
      module. The scope of this section is to consider the following aspects
      of manageability: fault management, configuration, accounting and
      performance.</t>

      <section title="Control of Function and Policy">
        <section title="Initialization Mode">
          <t>When a node is first powered up, it may either choose to stay
          silent and not send any multicast DIO message until it has joined a
          DODAG, or to immediately root a transient DODAG and start sending
          multicast DIO messages. A RPL implementation SHOULD allow
          configuring whether the node should stay silent or should start
          advertising DIO messages.</t>

          <t>Furthermore, the implementation SHOULD to allow configuring
          whether or not the node should start sending an DIS message as an
          initial probe for nearby DODAGs, or should simply wait until it
          received DIO messages from other nodes that are part of existing
          DODAGs.</t>
        </section>

        <section title="DIO Base option">
          <t>RPL specifies a number of protocol parameters.</t>

          <t>A RPL implementation SHOULD allow configuring the following
          routing protocol parameters, which are further described in <xref
          target="DIOBase"></xref>:</t>

          <?rfc subcompact="yes"?>

          <t><list hangIndent="6" style="hanging">
              <t hangText="DAGPreference"></t>

              <t hangText="RPLInstanceID"></t>

              <t hangText="DAGObjectiveCodePoint"></t>

              <t hangText="DODAGID"></t>

              <t hangText="Destination Prefixes"></t>

              <t hangText="DIOIntervalDoublings"></t>

              <t hangText="DIOIntervalMin"></t>

              <t hangText="DIORedundancyConstant"></t>

              <t></t>

              <t hangText="DAG Root behavior:">In some cases, a node may not
              want to permanently act as a DODAG root if it cannot join a
              grounded DODAG. For example a battery-operated node may not want
              to act as a DODAG root for a long period of time. Thus a RPL
              implementation MAY support the ability to configure whether or
              not a node could act as a DODAG root for a configured period of
              time.</t>

              <t></t>

              <t hangText="DODAG Table Entry Suppression">A RPL implementation
              SHOULD provide the ability to configure a timer after the
              expiration of which logical equivalent of the DODAG table that
              contains all the records about a DODAG is suppressed, to be
              invoked if the DODAG parent set becomes empty.</t>
            </list></t>

          <?rfc subcompact="no"?>
        </section>

        <section title="Trickle Timers">
          <t>A RPL implementation makes use of trickle timer to govern the
          sending of DIO message. Such an algorithm is determined a by a set
          of configurable parameters that are then advertised by the DODAG
          root along the DODAG in DIO messages.</t>

          <t>For each DODAG, a RPL implementation MUST allow for the
          monitoring of the following parameters, further described in <xref
          target="TrickleImplementation"></xref>:</t>

          <?rfc subcompact="yes"?>

          <t><list hangIndent="6" style="hanging">
              <t hangText="I"></t>

              <t hangText="T"></t>

              <t hangText="C"></t>

              <t hangText="I_min"></t>

              <t hangText="I_doublings"></t>
            </list></t>

          <?rfc subcompact="no"?>

          <t>A RPL implementation SHOULD provide a command (for example via
          API, CLI, or SNMP MIB) whereby any procedure that detects an
          inconsistency may cause the trickle timer to reset.</t>
        </section>

        <section title="DAG Sequence Number Increment">
          <t>A RPL implementation may allow by configuration at the DODAG root
          to refresh the DODAG states by updating the DODAGSequenceNumber. A
          RPL implementation SHOULD allow configuring whether or not periodic
          or event triggered mechanism are used by the DODAG root to control
          DODAGSequenceNumber change.</t>
        </section>

        <section title="Destination Advertisement Timers">
          <t>The following set of parameters of the DAO messages SHOULD be
          configurable:</t>

          <t><list style="symbols">
              <t>The DelayDAO timer</t>

              <t>The Remove timer</t>
            </list></t>
        </section>

        <section title="Policy Control">
          <t>DAG discovery enables nodes to implement different policies for
          selecting their DODAG parents.</t>

          <t>A RPL implementation SHOULD allow configuring the set of
          acceptable or preferred Objective Functions (OF) referenced by their
          Objective Codepoints (OCPs) for a node to join a DODAG, and what
          action should be taken if none of a node's candidate neighbors
          advertise one of the configured allowable Objective Functions.</t>

          <t>A node in an LLN may learn routing information from different
          routing protocols including RPL. It is in this case desirable to
          control via administrative preference which route should be favored.
          An implementation SHOULD allow for specifying an administrative
          preference for the routing protocol from which the route was
          learned.</t>

          <t>A RPL implementation SHOULD allow for the configuration of the
          "Route Tag" field of the DAO messages according to a set of rules
          defined by policy.</t>
        </section>

        <section title="Data Structures">
          <t>Some RPL implementation may limit the size of the candidate
          neighbor list in order to bound the memory usage, in which case some
          otherwise viable candidate neighbors may not be considered and
          simply dropped from the candidate neighbor list.</t>

          <t>A RPL implementation MAY provide an indicator on the size of the
          candidate neighbor list.</t>
        </section>
      </section>

      <section title="Information and Data Models">
        <t>The information and data models necessary for the operation of RPL
        will be defined in a separate document specifying the RPL SNMP
        MIB.</t>
      </section>

      <section title="Liveness Detection and Monitoring">
        <t>The aim of this section is to describe the various RPL mechanisms
        specified to monitor the protocol.</t>

        <t>As specified in <xref target="UpwardTopology"></xref>, an
        implementation is expected to maintain a set of data structures in
        support of DODAG discovery:</t>

        <t><list style="symbols">
            <t>The candidate neighbors data structure</t>

            <t>For each DODAG: <list style="symbols">
                <t>A set of DODAG parents</t>
              </list></t>
          </list></t>

        <section title="Candidate Neighbor Data Structure">
          <t>A node in the candidate neighbor list is a node discovered by the
          some means and qualified to potentially become of neighbor or a
          sibling (with high enough local confidence). A RPL implementation
          SHOULD provide a way monitor the candidate neighbors list with some
          metric reflecting local confidence (the degree of stability of the
          neighbors) measured by some metrics.</t>

          <t>A RPL implementation MAY provide a counter reporting the number
          of times a candidate neighbor has been ignored, should the number of
          candidate neighbors exceeds the maximum authorized value.</t>
        </section>

        <section title="Directed Acyclic Graph (DAG) Table">
          <t>For each DAG, a RPL implementation is expected to keep track of
          the following DODAG table values:</t>

          <t><list style="symbols">
              <t>DODAGID</t>

              <t>DAGObjectiveCodePoint</t>

              <t>A set of Destination Prefixes offered upwards along the
              DODAG</t>

              <t>A set of DODAG Parents</t>

              <t>timer to govern the sending of DIO messages for the DODAG</t>

              <t>DODAGSequenceNumber</t>
            </list></t>

          <t>The set of DODAG parents structure is itself a table with the
          following entries:</t>

          <t><list style="symbols">
              <t>A reference to the neighboring device which is the DAG
              parent</t>

              <t>A record of most recent information taken from the DAG
              Information Object last processed from the DODAG Parent</t>

              <t>A flag reporting if the Parent is a DAO Parent as described
              in <xref target="DownwardRoutes"></xref></t>
            </list></t>
        </section>

        <section title="Routing Table">
          <t>For each route provisioned by RPL operation, a RPL implementation
          MUST keep track of the following:</t>

          <t><list style="symbols">
              <t>Destination Prefix</t>

              <t>Destination Prefix Length</t>

              <t>Lifetime Timer</t>

              <t>Next Hop</t>

              <t>Next Hop Interface</t>

              <t>Flag indicating that the route was provisioned from one
              of:<list>
                  <t>Unicast DAO message</t>

                  <t>DIO message</t>

                  <t>Multicast DAO message</t>
                </list></t>
            </list></t>
        </section>

        <section title="Other RPL Monitoring Parameters">
          <t>A RPL implementation SHOULD provide a counter reporting the
          number of a times the node has detected an inconsistency with
          respect to a DODAG parent, e.g. if the DODAGID has changed.</t>

          <t>A RPL implementation MAY log the reception of a malformed DIO
          message along with the neighbor identification if avialable.</t>
        </section>

        <section title="RPL Trickle Timers">
          <t>A RPL implementation operating on a DODAG root MUST allow for the
          configuration of the following trickle parameters:</t>

          <t><list style="symbols">
              <t>The DIOIntervalMin expressed in ms</t>

              <t>The DIOIntervalDoublings</t>

              <t>The DIORedundancyConstant</t>
            </list></t>

          <t>A RPL implementation MAY provide a counter reporting the number
          of times an inconsistency (and thus the trickle timer has been
          reset).</t>
        </section>
      </section>

      <section title="Verifying Correct Operation">
        <t>This section has to be completed in further revision of this
        document to list potential Operations and Management (OAM) tools that
        could be used for verifying the correct operation of RPL.</t>
      </section>

      <section title="Requirements on Other Protocols and Functional Components">
        <t>RPL does not have any impact on the operation of existing
        protocols.</t>
      </section>

      <section title="Impact on Network Operation">
        <t>To be completed.</t>
      </section>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Security Considerations for RPL are to be developed in accordance
      with recommendations laid out in, for example, <xref
      target="I-D.tsao-roll-security-framework"></xref>.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <section title="RPL Control Message">
        <t>The RPL Control Message is an ICMP information message type that is
        to be used carry DODAG Information Objects, DODAG Information
        Solicitations, and Destination Advertisement Objects in support of RPL
        operation.</t>

        <t>IANA has defined a ICMPv6 Type Number Registry. The suggested type
        value for the RPL Control Message is 155, to be confirmed by IANA.</t>
      </section>

      <section title="New Registry for RPL Control Codes">
        <t>IANA is requested to create a registry, RPL Control Codes, for the
        Code field of the ICMPv6 RPL Control Message.</t>

        <t>New codes may be allocated only by an IETF Consensus action. Each
        code should be tracked with the following qualities:</t>

        <t><list style="symbols">
            <t>Code</t>

            <t>Description</t>

            <t>Defining RFC</t>
          </list></t>

        <t>Three codes are currently defined:</t>

        <texttable title="RPL Control Codes">
          <ttcol align="center">Code</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0x01</c>

          <c>DODAG Information Solicitation</c>

          <c>This document</c>

          <c>0x02</c>

          <c>DODAG Information Object</c>

          <c>This document</c>

          <c>0x04</c>

          <c>Destination Advertisement Object</c>

          <c>This document</c>
        </texttable>
      </section>

      <section title="New Registry for the Control Field of the DIO Base">
        <t>IANA is requested to create a registry for the Control field of the
        DIO Base.</t>

        <t>New fields may be allocated only by an IETF Consensus action. Each
        field should be tracked with the following qualities:</t>

        <t><list style="symbols">
            <t>Bit number (counting from bit 0 as the most significant
            bit)</t>

            <t>Capability description</t>

            <t>Defining RFC</t>
          </list></t>

        <t>Four groups are currently defined:</t>

        <texttable title="DIO Base Flags">
          <ttcol align="center">Bit</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0</c>

          <c>Grounded DODAG (G)</c>

          <c>This document</c>

          <c>1</c>

          <c>Destination Advertisement Supported (A)</c>

          <c>This document</c>

          <c>2</c>

          <c>Destination Advertisement Trigger (T)</c>

          <c>This document</c>

          <c>3</c>

          <c>Destination Advertisements Stored (S)</c>

          <c>This document</c>

          <c>5,6,7</c>

          <c>DODAG Preference (Prf)</c>

          <c>This document</c>
        </texttable>
      </section>

      <section title="DODAG Information Object (DIO) Suboption">
        <t>IANA is requested to create a registry for the DIO Base
        Suboptions</t>

        <texttable title="DODAG Information Option (DIO) Base Suboptions">
          <ttcol align="center">Value</ttcol>

          <ttcol align="left">Meaning</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0</c>

          <c>Pad1 - DIO Padding</c>

          <c>This document</c>

          <c>1</c>

          <c>PadN - DIO suboption padding</c>

          <c>This document</c>

          <c>2</c>

          <c>DAG Metric Container</c>

          <c>This Document</c>

          <c>3</c>

          <c>Destination Prefix</c>

          <c>This Document</c>

          <c>4</c>

          <c>DAG Timer Configuration</c>

          <c>This Document</c>
        </texttable>
      </section>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The authors would like to acknowledge the review, feedback, and
      comments from Emmanuel Baccelli, Dominique Barthel, Yusuf Bashir,
      Phoebus Chen, Mathilde Durvy, Manhar Goindi, Mukul Goyal, Anders Jagd,
      Quentin Lampin, Jerry Martocci, Alexandru Petrescu, and Don Sturek.</t>

      <t>The authors would like to acknowledge the guidance and input provided
      by the ROLL Chairs, David Culler and JP Vasseur.</t>

      <t>The authors would like to acknowledge prior contributions of Robert
      Assimiti, Mischa Dohler, Julien Abeille, Ryuji Wakikawa, Teco Boot,
      Patrick Wetterwald, Bryan Mclaughlin, Carlos J. Bernardos, Thomas
      Watteyne, Zach Shelby, Caroline Bontoux, Marco Molteni, Billy Moon, and
      Arsalan Tavakoli, which have provided useful design considerations to
      RPL.</t>
    </section>

    <section title="Contributors">
      <t>RPL is the result of the contribution of the following members of the
      ROLL Design Team, including the editors, and additional contributors as
      listed below:</t>

      <figure>
        <artwork><![CDATA[
JP Vasseur
Cisco Systems, Inc
11, Rue Camille Desmoulins
Issy Les Moulineaux,   92782
France

Email: jpv@cisco.com


Thomas Heide Clausen
LIX, Ecole Polytechnique, France

Phone: +33 6 6058 9349
EMail: T.Clausen@computer.org
URI:   http://www.ThomasClausen.org/


Philip Levis
Stanford University
358 Gates Hall, Stanford University
Stanford, CA  94305-9030
USA

Email: pal@cs.stanford.edu
 

Richard Kelsey
Ember Corporation
Boston, MA
USA

Phone: +1 617 951 1225
Email: kelsey@ember.com


Jonathan W. Hui
Arch Rock Corporation
501 2nd St. Ste. 410
San Francisco, CA  94107
USA

Email: jhui@archrock.com


Kris Pister
Dust Networks
30695 Huntwood Ave.
Hayward,   94544
USA

Email: kpister@dustnetworks.com


Anders Brandt
Zensys, Inc.
Emdrupvej 26
Copenhagen, DK-2100
Denmark

Email: abr@zen-sys.com


Stephen Dawson-Haggerty
UC Berkeley
Soda Hall, UC Berkeley
Berkeley, CA  94720
USA

Email: stevedh@cs.berkeley.edu


    ]]></artwork>
      </figure>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>

      <?rfc include="reference.RFC.2460"?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.I-D.ietf-roll-building-routing-reqs.xml'?>

      <?rfc include='reference.I-D.ietf-roll-home-routing-reqs.xml'?>

      <?rfc include='reference.RFC.3697'?>

      <?rfc include='reference.RFC.5673'?>

      <?rfc include="reference.RFC.5548"?>

      <?rfc include='reference.I-D.ietf-roll-terminology.xml'?>

      <?rfc include='reference.I-D.ietf-roll-routing-metrics.xml'?>

      <?rfc include='reference.I-D.ietf-roll-of0.xml'?>

      <?rfc include='reference.I-D.tsao-roll-security-framework.xml'?>

      <!--      <?rfc include="reference.RFC.2453"?> -->

      <?rfc include="reference.RFC.3819"?>

      <?rfc include="reference.RFC.4101"?>

      <?rfc include="reference.RFC.4191"?>

      <?rfc include="reference.RFC.4443"?>

      <?rfc include="reference.RFC.4861"?>

      <?rfc include="reference.RFC.4915"?>

      <?rfc include="reference.RFC.5120"?>

      <?rfc include="reference.RFC.1982"?>

      <?rfc include='reference.RFC.3810'?>

      <?rfc include="reference.I-D.ietf-bfd-base.xml"?>

      <?rfc include="reference.I-D.ietf-manet-nhdp.xml"?>

      <reference anchor="Levis08"
                 target="http://portal.acm.org/citation.cfm?id=1364804">
        <front>
          <title abbrev="Levis08">The Emergence of a Networking Primitive in
          Wireless Sensor Networks</title>

          <author fullname="Philip Levis" initials="P." surname="Levis">
            <organization></organization>
          </author>

          <author fullname="Eric Brewer" initials="E." surname="Brewer">
            <organization></organization>
          </author>

          <author fullname="David Culler" initials="D." surname="Culler">
            <organization></organization>
          </author>

          <author fullname="David Gay" initials="D." surname="Gay">
            <organization></organization>
          </author>

          <author fullname="Samuel Madden" initials="S." surname="Madden">
            <organization></organization>
          </author>

          <author fullname="Neil Patel" initials="N." surname="Patel">
            <organization></organization>
          </author>

          <author fullname="Joe Polastre" initials="J." surname="Polastre">
            <organization></organization>
          </author>

          <author fullname="Scott Shenker" initials="S." surname="Shenker">
            <organization></organization>
          </author>

          <author fullname="Robert Szewczyk" initials="R." surname="Szewczyk">
            <organization></organization>
          </author>

          <author fullname="Alec Woo" initials="A." surname="Woo">
            <organization></organization>
          </author>

          <date month="July" year="2008" />
        </front>

        <seriesInfo name="Communications of the ACM," value="v.51 n.7" />

        <format target="http://portal.acm.org/citation.cfm?id=1364804"
                type="HTML" />
      </reference>
    </references>

    <section anchor="Requirements" title="Requirements">
      <section title="Protocol Properties Overview">
        <t>RPL demonstrates the following properties, consistent with the
        requirements specified by the application-specific requirements
        documents.</t>

        <section title="IPv6 Architecture">
          <t>RPL is strictly compliant with layered IPv6 architecture.</t>

          <t>Further, RPL is designed with consideration to the practical
          support and implementation of IPv6 architecture on devices which may
          operate under severe resource constraints, including but not limited
          to memory, processing power, energy, and communication. The RPL
          design does not presume high quality reliable links, and operates
          over lossy links (usually low bandwidth with low packet delivery
          success rate).</t>
        </section>

        <section title="Typical LLN Traffic Patterns">
          <t>Multipoint-to-Point (MP2P) and Point-to-multipoint (P2MP) traffic
          flows from nodes within the LLN from and to egress points are very
          common in LLNs. Low power and lossy network Border Router (LBR)
          nodes may typically be at the root of such flows, although such
          flows are not exclusively rooted at LBRs as determined on an
          application-specific basis. In particular, several applications such
          as building or home automation do require P2P (Point-to-Point)
          communication.</t>

          <t>As required by the aforementioned routing requirements documents,
          RPL supports the installation of multiple paths. The use of multiple
          paths include sending duplicated traffic along diverse paths, as
          well as to support advanced features such as Class of Service (CoS)
          based routing, or simple load balancing among a set of paths (which
          could be useful for the LLN to spread traffic load and avoid fast
          energy depletion on some, e.g. battery powered, nodes).
          Conceptually, multiple instances of RPL can be used to send traffic
          along different topology instances, the construction of which is
          governed by different Objective Functions (OF). Details of RPL
          operation in support of multiple instances are beyond the scope of
          the present specification.</t>
        </section>

        <section title="Constraint Based Routing">
          <t>The RPL design supports constraint based routing, based on a set
          of routing metrics and constraints. The routing metrics and
          constraints for links and nodes with capabilities supported by RPL
          are specified in a companion document to this specification, <xref
          target="I-D.ietf-roll-routing-metrics"></xref>. RPL signals the
          metrics, constraints, and related Objective Functions (OFs) in use
          in a particular implementation by means of an Objective Code Point
          (OCP). Both the routing metrics, constraints, and the OF help
          determine the construction of the Directed Acyclic Graphs (DAG)
          using a distributed path computation algorithm.</t>
        </section>
      </section>

      <section title="Deferred Requirements">
        <t>NOTE: RPL is still a work in progress. At this time there remain
        several unsatisfied application requirements, but these are to be
        addressed as RPL is further specified.</t>
      </section>
    </section>

    <section anchor="Examples" title="Examples">
      <section title="DAO Operation When Only the Root Node Stores DAO Information">
        <t>Consider the example of <xref target="DAOExample1"></xref>. In this
        example only the root node, (LBR*), will store DAO information. This
        is not known, nor is it required to be known, to all nodes a priori.
        Rather, each node is able to observe from the state of the 'S' flag
        that no ancestor, with the exception of the root node, stores DAO
        information.</t>

        <figure anchor="DAOExample1" title="Only Root Node Stores DAOs">
          <artwork><![CDATA[
                                                                     
                               (LBR*)                                
                                /  \                                 
                               /    \                                
                              /      \                               
                          (11)        (12)                           
                            |          |                             
                            |          |                             
                            |          |                             
                          (21)        (22)                           
                              \                                      
                               \                                     
                                \                                    
                                (31)                                 
                                /  \                                 
                               /    \                                
                              /      \                               
                          (41)        (42)                           
                            :          :                             
                                                                     
]]></artwork>
        </figure>

        <t>In this example: <list style="symbols">
            <t>The 'S' flag is cleared in DIO messages emitted by (LBR*),
            because (LBR*) is the DODAG root.</t>

            <t>The 'S' flag is cleared in all DIO messages emitted by all
            other nodes, because no other node stores DAO information.</t>

            <t>(LBR*) has learned from DAO messages how to reach node (31)
            with a source route via {(11) (21)}.</t>

            <t>All source routes to nodes in the sub-DODAG of node (31),
            including nodes (41), (42), and others will include the prefix
            {(11) (21) (31)}</t>

            <t>Node (31) maintains a DTSN, (31).DTSN, that it will advertise
            in DIO messages.</t>
          </list></t>

        <t>Suppose now that there is a topology change within the same DODAG
        iteration, causing node (31) to evict node (21) as a DAO parent and
        add node (22) as a DAO parent: <list style="numbers">
            <t>Node (31) will schedule a DAO transmission because it has added
            a new node (22) to its DAO parent set.</t>

            <t>Node (31) need not increment (31).DTSN at this event, because
            in this example no DAO parents have the 'S' flag set. Specifically
            this indicates to Node (31) that there are no intermediate storing
            nodes that may need to be explicitly updated with DAO information
            from it's sub-DODAG. Hence nodes (41), (42), and by extension the
            sub-DODAG of node (31) will not subsequently observe an
            incremented (31).DTSN and the sub-DODAG will not emit DAOs.</t>

            <t>A new flow of DAOs for node (31) reaches the (LBR*), updating
            the source route information for node (31) to include the new path
            {(12) (22)}.</t>

            <t>(LBR*) may implicitly update all source routes that must
            transit node (31), i.e. the sub-DODAG of node (31), to use the
            updated source route prefix {(12) (22)} instead of {(11)
            (21)}.</t>
          </list></t>

        <t>Thus the use of the 'S' flag in the case where only the root node
        stores DAO information has allowed an optimization whereby only a DAO
        update for the node that changed its DAO parent set, (31), needs to be
        sent to the DODAG root.</t>
      </section>

      <section title="DAO Operation When All Nodes Fully Store DAO Information">
        <t>Consider the example of <xref target="DAOExample2"></xref>. In this
        example all nodes will fully store DAO information.</t>

        <figure anchor="DAOExample2" title="All Nodes Store DAOs">
          <artwork><![CDATA[
                                                                     
                               (LBR*)                                
                                /  \                                 
                               /    \                                
                              /      \                               
                         (11*)        (12*)                          
                            |          |                             
                            |          |                             
                            |          |                             
                         (21*)        (22*)                          
                              \                                      
                               \                                     
                                \                                    
                               (31*)                                 
                                /  \                                 
                               /    \                                
                              /      \                               
                         (41*)        (42*)                          
                            :          :                             
                                                                     
]]></artwork>
        </figure>

        <t>In this example: <list style="symbols">
            <t>The 'S' flag is cleared in DIO messages emitted by (LBR*),
            because (LBR*) is the DODAG root.</t>

            <t>The 'S' flag is set in DIO messages emitted by all non-root
            nodes because each non-root node stores DAO information.</t>

            <t>Source routing state is effectively not provisioned in this
            example, because each node has been able to store hop-by-hop
            routing state for each destination, possibly aggregated, as
            learned from DAOs. For example, node (11*) will have learned and
            stored information from a DAO to the effect that node (41*) is
            routable through a next hop of node (21*). Node (12*) on the other
            hand does not necessarily have a route provisioned to node
            (41*).</t>
          </list></t>

        <t>Suppose now that there is a topology change within the same DODAG
        iteration, causing node (31*) to evict node (21*) as a DAO parent and
        add node (22*) as a DAO parent: <list style="numbers">
            <t>Node (31*) will schedule a DAO transmission because it has
            added a new node (22*) to its DAO parent set.<!-- The implementation may have explicitly marked node (22*) for
                 the update.--></t>

            <t>Node (31) need not increment (31).DTSN, because it is a fully
            storing node and does not need to trigger DAO information from its
            sub-DODAG.</t>

            <t>Node (31) gives a DAO Update to node (22*). Presuming that node
            (22*) has received the update, node (22*) will store the new
            entries for routes including the sub-DODAG of node (31*),
            including nodes (41*) and (42*). Node (22*) will schedule a DAO
            transmission for the new entries.</t>

            <t>Similarly, node (22*) updates node (12*) and node (12*) updates
            (LBR*). Hop-by-hop routing state for the sub-DODAG of node (31*)
            is now provisioned at nodes (12*) and (22*).</t>
          </list></t>

        <t>Thus the addition to the DAO Parent set at the fully storing node
        (31*) does not elicit additional DAO-related traffic from its
        sub-DODAG. The intermediate nodes along the 'new' downward path are
        updated by DAO messages along the new path.</t>

        <t>Suppose next that the DODAG root triggers a refresh of DAO
        information over the same DODAG Iteration. (Note that the DODAG root
        might also trigger a DAO refresh but allow other topology changes at
        the same time by incrementing the DODAG Sequence Number to cause a
        move to the next DODAG Iteration).: <list style="numbers">
            <t>(LBR*) will increment its DTSN and issue a DIO with the 'T'
            flag set.</t>

            <t>Nodes (11*) and (12*) will increment their own DTSNs in
            response to observing in the DIO from LBR a new DTSN and the 'T'
            flag being set. They will reset their trickle timers to cause the
            issue of new DIOs with the 'T' flag set. These nodes will also
            schedule a DAO transmission in response to observing a new DTSN
            from their DAO Parent, (LBR*). (This DAO transmission may be
            scheduled with a sufficient delay computed based on rank to allow
            a chance for the sub-DODAGs of the nodes to report DAO messages
            prior to the nodes reporting their own DAO information to (LBR*).
            This is implementation specific and may allow a chance for DAO
            aggregation.).</t>

            <t>Node (21*) receives a DIO from node (11*) and observes the new
            (11*).DTSN as well as the set 'T' flag. Node (21*) increments its
            own DTSN, resets the trickle timer, and schedules a DAO
            transmission.</t>

            <t>Similarly, as each node observes the incremented DTSN with the
            'T' flag set from each of its parents, each node will increment
            its own DTSN, reset the DIO trickle timer, and schedule a DAO
            transmission.</t>
          </list></t>

        <t>Thus the entire DODAG iteration has been re-armed to send DAO
        messages based on the (LBR*)'s assertion of the 'T' flag. Note that
        normally a DTSN increment would cause no further action in a sub-DODAG
        beyond the first fully storing node that is encountered, but that in
        this case the 'T' flag effectively provides a means to 'punch through'
        all fully storing nodes.</t>
      </section>

      <section title="DAO Operation When Nodes Have Mixed Capabilities">
        <t>Consider the example of <xref target="DAOExample3"></xref>. In this
        example some nodes are capable of storing DAO information and some are
        not.</t>

        <figure anchor="DAOExample3" title="Mixed Capability DAO Operation">
          <artwork><![CDATA[
                                                                     
                               (LBR*)                                
                                /  \                                 
                               /    \                                
                              /      \                               
                          (11)        (12*)                          
                            |          |                             
                            |          |                             
                            |          |                             
                          (21)        (22)                          
                              \                                      
                               \                                     
                                \                                    
                                (31)                                 
                                /  \                                 
                               /    \                                
                              /      \                               
                          (41)        (42*)                          
                            :          :                             
                                                                     
]]></artwork>
        </figure>

        <t>In this example: <list style="symbols">
            <t>The 'S' flag is cleared in DIO messages emitted by (LBR*),
            because (LBR*) is the DODAG root.</t>

            <t>The 'S' flag is set in DIO messages emitted by (12*), because
            it is a storing node.</t>

            <t>The 'S' flag will be set in DIO messages emitted by nodes that
            contain node (12*) (or more generally any non-root storing node)
            as a DAO parent/ancestor. This indicates that somewhere along the
            DAO path there is a non-root storing node that may need to have
            its state updated (by a DAO refresh) in certain conditions.</t>
          </list></t>

        <t>Suppose that there is a topology change within the same DODAG
        iteration, causing node (31) to add node (22) as a DAO parent: <list
            style="numbers">
            <t>Node (31) will schedule a DAO transmission because it has added
            a new node (22) to its DAO parent set. Node (31) will increment
            (31).DTSN because node (22) has set the 'S' flag in its DIO
            messages. Node (31) will reset its DIO trickle timer.</t>

            <t>Node (31)'s trickle timer will then expire and a DIO is issued
            and received by node's (41) and (42*).</t>

            <t>Node (41) is a non-storing node. It will increment (41).DTSN in
            response to observing the increment in (31).DTSN, and reset its
            trickle timer. This results finally in the reliable (thanks to the
            DTSN) triggering of a DAO update from node (41)'s sub-DODAG.</t>

            <t>As node (41) receives DAO updates from its sub-DODAG it updates
            the DAOs with source routing information as necessary and passes
            them on to node (31), along with its own (node (41)) DAO
            update.</t>

            <t>Meanwhile, node (42*) is a fully storing node. It observes the
            increment to (31).DTSN and schedules a DAO update. Node (42*) does
            not need to increment (42*).DTSN, since it is a fully storing node
            it does not need to solicit DAO updates from its sub-DODAG in this
            case. At the scheduled time Node (42*) reissues its DAO
            information to node (31).</t>

            <t>Node (31) receives the DAO messages from its sub-DODAG, adds
            source routing information as necessary, and issues DAO updates to
            node (22).</t>

            <t>Node (22) similarly receives DAO messages from node (31),
            updates source routing information as necessary, and issues DAO
            updates to node (12*).</t>

            <t>The intermediate storing node (12*) has now received from DAO
            messages the information necessary to provision routing state for
            node (31) and its sub-DODAG. As downwards traffic is routed
            through node (12*) it is able to consult source routing
            information that was learned from the DAO messages as needed to
            specify routes down the DAG across the non-storing nodes (22),
            (31), ...</t>
          </list></t>
      </section>
    </section>

    <section anchor="TODO" title="Outstanding Issues">
      <t>This section enumerates some outstanding issues that are to be
      addressed in future revisions of the RPL specification.</t>

      <section title="Additional Support for P2P Routing">
        <t>In some situations the baseline mechanism to support arbitrary P2P
        traffic, by flowing upwards along the DODAG until a common ancestor is
        reached and then flowing down, may not be suitable for all application
        scenarios. A related scenario may occur when the down paths setup
        along the DODAG by the destination advertisement mechanism are not the
        most desirable downward paths for the specific application scenario
        (in part because the DODAG links may not be symmetric). It may be
        desired to support within RPL the discovery and installation of more
        direct routes 'across' the DAG. Such mechanisms need to be
        investigated.</t>
      </section>

      <!--   DONE  (pending Extension Header vs. Flow Label)
      <section title="Loop Detection">
        <t>It is under investigation to complement the loop avoidance
        strategies provided by RPL with a loop detection mechanism that may be
        employed when traffic is forwarded.</t>
      </section>
      -->

      <section title="Destination Advertisement / DAO Fan-out">
        <t>When DAO messages are relayed to more than one DODAG parent, in
        some cases a situation may be created where a large number of DAO
        messages conveying information about the same destination flow upwards
        along the DAG. It is desirable to bound/limit the
        multiplication/fan-out of DAO messages in this manner. Some aspects of
        the Destination Advertisement mechanism remain under investigation,
        such as behavior in the face of links that may not be symmetric.</t>

        <t>In general, the utility of providing redundancy along downwards
        routes by sending DAO messages to more than one parent is under
        investigation.</t>

        <!-- This has now been addressed with DTSN, 'S', and 'T' flag:
        <t>The use of suitable triggers, such as the 'T' flag, to trigger DA
        operation within an affected sub-DODAG, is under investigation.
        Further, the ability to limit scope of the affected depth within the
        sub-DODAG is under investigation (e.g. if a stateful node can proxy
        for all nodes 'behind' it, then there may be no need to propagate the
        triggered 'T' flag further).</t>
        -->
      </section>

      <section title="Source Routing">
        <t>In support of nodes that maintain minimal routing state, and to
        make use of the collection of piecewise source routes from the
        destination advertisement mechanism, there needs to be some
        investigation of a mechanism to specify, attach, and follow source
        routes for packets traversing the LLN.</t>
      </section>

      <section title="Address / Header Compression">
        <t>In order to minimize overhead within the LLN it is desirable to
        perform some sort of address and/or header compression, perhaps via
        labels, addresses aggregation, or some other means. This is still
        under investigation.</t>
      </section>

      <section title="Managing Multiple Instances">
        <t>A network may run multiple instances of RPL concurrently. Such a
        network will require methods for assigning and otherwise managing
        RPLInstanceIDs. This will likely be addressed in a separate
        document.</t>
      </section>
    </section>
  </back>
</rfc>
