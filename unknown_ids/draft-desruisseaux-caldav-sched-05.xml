<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" "bibxml/reference.RFC.2119.xml">
<!ENTITY rfc2445 PUBLIC "" "bibxml/reference.RFC.2445.xml">
<!ENTITY rfc2446 PUBLIC "" "bibxml/reference.RFC.2446.xml">
<!ENTITY rfc2447 PUBLIC "" "bibxml/reference.RFC.2447.xml">
<!ENTITY rfc2616 PUBLIC "" "bibxml/reference.RFC.2616.xml">
<!ENTITY rfc2818 PUBLIC "" "bibxml/reference.RFC.2818.xml">
<!ENTITY rfc3744 PUBLIC "" "bibxml/reference.RFC.3744.xml">
<!ENTITY rfc3864 PUBLIC "" "bibxml/reference.RFC.3864.xml">
<!ENTITY rfc4791 PUBLIC "" "bibxml/reference.RFC.4791.xml">
<!ENTITY rfc4918 PUBLIC "" "bibxml/reference.RFC.4918.xml">
<!ENTITY W3C.REC-xml-20060816 PUBLIC "" "bibxml4/reference.W3C.REC-xml-20060816.xml">
]>
<?rfc rfcedstyle="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<!-- default = 3 -->
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<!--<?rfc strict="yes"?> -->
<!--<?rfc comments="yes"?> -->
<!--<?rfc inline="yes"?> -->
<rfc category="std" ipr="full3978" docName="draft-desruisseaux-caldav-sched-05">
  <front>
    <title abbrev="CalDAV Schedule">CalDAV Scheduling Extensions to WebDAV</title>
    <author initials="C." surname="Daboo" fullname="Cyrus Daboo">
      <organization abbrev="Apple Inc.">Apple Inc.</organization>
      <address>
        <postal>
          <street>1 Infinite Loop</street>
          <city>Cupertino</city>
          <region>CA</region>
          <code>95014</code>
          <country>USA</country>
        </postal>
        <email>cyrus@daboo.name</email>
        <uri>http://www.apple.com/</uri>
      </address>
    </author>
    <author initials="B." surname="Desruisseaux" fullname="Bernard Desruisseaux">
      <organization abbrev="Oracle">Oracle Corporation</organization>
      <address>
        <postal>
          <street>600 Blvd. de Maisonneuve West</street>
          <street>Suite 1900</street>
          <city>Montreal</city>
          <region>QC</region>
          <code>H3A 3J2</code>
          <country>CANADA</country>
        </postal>
        <email>bernard.desruisseaux@oracle.com</email>
        <uri>http://www.oracle.com/</uri>
      </address>
    </author>
    <date/>
    <area>Applications</area>
    <keyword>calsched</keyword>
    <keyword>calsch</keyword>
    <keyword>caldav</keyword>
    <keyword>calendar</keyword>
    <keyword>calendaring</keyword>
    <keyword>scheduling</keyword>
    <keyword>webdav</keyword>
    <keyword>iCal</keyword>
    <keyword>iCalendar</keyword>
    <keyword>iTIP</keyword>
    <keyword>text/calendar</keyword>
    <keyword>HTTP</keyword>
    <abstract>
      <t>This document defines extensions to the CalDAV "calendar-access" feature to specify a standard way of performing scheduling transactions with iCalendar-based calendar components. This document defines the "calendar-auto-schedule" feature of CalDAV.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introduction">
      <t>
        This document specifies an extension to the <xref target="RFC4791">CalDAV "calendar-access" feature</xref> to enable scheduling of <xref target="RFC2445">iCalendar-based</xref> calendar components between calendar users. This extension leverages the scheduling methods defined in the iCalendar Transport-independent Interoperability Protocol <xref target="RFC2446">iTIP</xref> to permit calendar users to perform scheduling transactions such as schedule, reschedule, respond to scheduling request or cancel scheduled calendar components, as well as search for busy time information.
      </t>
      <t>
        <xref target="RFC2446">iTIP</xref> outlines a model where calendar users exchange scheduling messages with one another. Often times, calendar user agents are made responsible for generating and sending scheduling messages as well as processing incoming scheduling messages. This approach yields a number of problems, including:
        <list style="symbols">
          <t>The handling of incoming scheduling messages and the updates to calendars imposed by these messages only occurs when calendar user agents are active.</t>
          <t>For most updates to a calendar, calendar user agents need to address a separate scheduling message to the "Organizer" or the "Attendees".</t>
          <t>Due to the update latency it is possible for calendars of different calendar users to reflect different, inaccurate states.</t>
        </list>
      </t>
      <t>This specification is using an alternative approach where the server is made responsible for sending most scheduling messages and processing most incoming scheduling messages. This approach frees the calendar user agents from the delivery and processing of most scheduling messages and ensures better consistency of users' calendar data. The simple operation of creating, modifying or deleting a calendar object resource in a calendar is enough to trigger the CalDAV server to deliver appropriate scheduling messages to the calendar users.</t>
      <t>Discussion of this Internet-Draft is taking place on the mailing list &lt;http://lists.osafoundation.org/mailman/listinfo/ietf-caldav&gt;.</t>
      <section title="Level of Support for iTIP">
        <t>While the scheduling features described in this specification are based on <xref target="RFC2446">iTIP</xref>, some of its more complex features have deliberately not been implemented, in order to keep this specification simple. In particular, the following <xref target="RFC2446">iTIP</xref> features are not supported:
            <list style="symbols">
              <t>Sending scheduling messages with the scheduling methods "PUBLISH", "COUNTER", and "DECLINECOUNTER"</t>
                <t>Delegating an Event to another calendar user</t>
                <t>Changing the "Organizer"</t>
                <t>Forwarding to an uninvited calendar user</t>
            </list>
        The goal of this specification is to provide the essential scheduling features needed, and it is anticipated that future extensions will be developed to address the more complex features if the demand arises.</t>
      </section>
      <section title="XML Namespaces">
        <t>Definitions of XML elements in this document use XML element type declarations (as found in XML Document Type Declarations), described in Section 3.2 of <xref target="W3C.REC-xml-20060816"/>.</t>
        <t>The namespace "urn:ietf:params:xml:ns:caldav" is reserved for the XML elements defined in this specification, or in other Standards Track IETF RFCs written to extend CalDAV. It MUST NOT be used for proprietary extensions.</t>
        <t>Note that the XML declarations used in this document are incomplete, in that they do not include namespace information. Thus, the reader MUST NOT use these declarations as the only way to create valid CalDAV properties or to validate CalDAV XML element types. Some of the declarations refer to XML elements defined by WebDAV which use the "DAV:" namespace. Wherever such elements appear, they are explicitly given the "DAV:" prefix to help avoid confusion. Additionally, some of the elements used here are defined in <xref target="RFC4791">CalDAV</xref>.</t>
        <t>Also note that some CalDAV XML element names are identical to WebDAV XML element names, though their namespace differs. Care MUST be taken not to confuse the two sets of names.</t>
      </section>
<!-- XML Namespace -->
      <section title="Notational Conventions">
        <t>The augmented BNF used by this document to describe protocol elements is described in Section 2.1 of <xref target="RFC2616">HTTP</xref>. Because this augmented BNF uses the basic production rules provided in Section 2.2 of <xref target="RFC2616">HTTP</xref>, those rules apply to this document as well.</t>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>
        <t>When XML element types in the namespaces "DAV:" and "urn:ietf:params:xml:ns:caldav" are referenced in this document outside of the context of an XML fragment, the string "DAV:" and "CALDAV:" will be prefixed to the element types respectively.</t>
      </section>
<!-- Notational Conventions -->
      <section title="Terminology">
        <t>
<?rfc compact="no" ?>
          <list style="hanging">
            <t hangText="Calendar user agent (CUA):">Software with which the calendar user communicates with a calendar service or local calendar store to access calendar information.</t>
            <t hangText="Calendar collection:">Same as <xref target="RFC4791">CalDAV "calendar-access"</xref>.</t>
            <t hangText="Scheduling calendar collection:">Calendar collection that supports automatic scheduling transactions.</t>
            <t hangText="Basic calendar collection:">Calendar collections as defined in <xref target="RFC4791">CalDAV "calendar-access"</xref> are referred to as basic calendar collections.  Scheduling calendar collections are not basic calendar collections.</t>
            <t hangText="Calendar object resource:">Same as <xref target="RFC4791">CalDAV "calendar-access"</xref>.</t>
            <t hangText="Scheduling object resource:">Calendar object resource contained in a scheduling calendar collection for which the server will take care of sending scheduling messages and processing incoming scheduling messages on behalf of the owner of the calendar collection.</t>
            <t hangText="Organizer scheduling object resource:">Scheduling object resource owned by an "Organizer".</t>
            <t hangText="Attendee scheduling object resource:">Scheduling object resource owned by an "Attendee".</t>
            <t hangText="Automatic scheduling transaction:">Add, change or remove operations on a scheduling object resource in a scheduling calendar collection for which the server will deliver scheduling messages to other users.</t>
            <t hangText="Explicit scheduling request:">Scheduling requests targeted at a scheduling Outbox collection such as search for busy time information as well as refresh requests.</t>
            <t hangText="Scheduling message:">Calendar object resource that describes a scheduling transaction such as publish, schedule, reschedule, respond to scheduling requests, or cancel calendar components.</t>
            <t hangText="Scheduling Outbox collection:">Resource at which explicit scheduling requests can be targeted.</t>
            <t hangText="Scheduling Inbox collection:">A collection in which a recipient's incoming scheduling messages are delivered.</t>
          </list>
<?rfc compact="yes" ?>
        </t>
      </section>
<!-- Terminology-->
    </section>
<!-- Introduction -->
    <section title="CalDAV Scheduling Support" anchor="support.discovery">
      <t>In order for a server to support the scheduling extensions defined in this specification it MUST support the <xref target="RFC4791">CalDAV "calendar-access" feature</xref> and all of its dependencies.</t>
      <t>A server that supports the features described in this document MUST include "calendar-auto-schedule" as a field in the DAV response header from an OPTIONS request on any resource that supports any scheduling actions, properties, privileges or methods.</t>
        <figure>
          <preamble>&gt;&gt; Request &lt;&lt;</preamble>
          <artwork><![CDATA[
OPTIONS /lisa/calendar/outbox/ HTTP/1.1
Host: cal.example.com
        ]]></artwork>
        </figure>
        <figure>
          <preamble>&gt;&gt; Response &lt;&lt;</preamble>
          <artwork><![CDATA[
HTTP/1.1 204 No Content
Date: Thu, 31 Mar 2005 09:00:00 GMT
Allow: OPTIONS, GET, HEAD, POST, DELETE, TRACE,
Allow: PROPFIND, PROPPATCH, LOCK, UNLOCK, REPORT, ACL
DAV: 1, 2, 3, access-control
DAV: calendar-access, calendar-auto-schedule
        ]]></artwork>
        </figure>
        <t>
          In this example, the OPTIONS response indicates that the server supports both the "calendar-access" and "calendar-auto-schedule" features and that resource "/lisa/calendar/outbox/" supports the properties, reports, methods, and privileges defined in this specification.
        </t>
    </section>
<!-- support.discovery -->
    <section title="Scheduling Process">
      <t>The process of scheduling a meeting between different parties often involves a series of steps with different "actors" playing particular roles during the whole process. Typically there is a meeting "Organizer" whose role is to setup a meeting between one or more meeting "Attendees", and this is done by sending out invitations and handling responses from each "Attendee".</t>
      <t>This process can typically be broken down into two phases.</t>
      <t>In the first phase, the "Organizer" tries to determine a time for the meeting that ought to be acceptable to each "Attendee". This involves finding out when each "Attendee" is available during the period of time in which the meeting needs to occur (or simply finding a suitable time for all attendees to come together for the meeting), and determining when the most appropriate time is for which each "Attendee" is free. This process is called a "freebusy" lookup.</t>
      <t>In the second phase, the "Organizer" sends out invitations to each "Attendee" using the time determined from the freebusy lookup - or a suitable guess as to an appropriate time based on other factors if freebusy lookup is not feasible. Then, some "Attendees" may choose to attend at the time provided by the "Organizer", while others may decline to attend. Once the "Organizer" has received the replies from the "Attendees" the "Organizer" can take appropriate action to confirm the meeting, reschedule it or perhaps cancel it.</t>
      <t>The user "expectation" as to how a calendaring and scheduling system should respond in each of these two phases is somewhat different. In the case of a freebusy lookup, users expect to get back results immediately so that they can then move on to the invitation phase as quickly as possible. In the case of invitations, it is expected that each "Attendee" will reply with their participation status in their own time, so delays in receiving replies are anticipated. Thus calendaring and scheduling systems should treat these two operational phases in different ways to accommodate the user expectations, and this specification does that.</t>
      <t>
        The scenario above covers the case of scheduling events ("VEVENT" components) between calendar users, and doing freebusy lookups ("VFREEBUSY" components). However, <xref target="RFC2446">iTIP</xref> also allows exchange of "VTODO" and "VJOURNAL" components. Since this specification is based on iTIP, "VTODO" and "VJOURNAL" components can also be used. For the majority of the following discussion, scheduling of events and freebusy lookups will be discussed as these are the more common operations.
      </t>
      <t>In this specification there are two primary modes of carrying out a scheduling transaction. For an "automatic scheduling transaction", calendar data created, modified or removed from calendar collections cause scheduling operations to occur. For an "explicit scheduling request", scheduling operations are triggered by an HTTP POST request to a special resource. iTIP freebusy lookups and iTIP "METHOD:REFRESH" operations are done via explicit scheduling requests. All other scheduling methods defined in iTIP, except for "PUBLISH", "COUNTER", and "DECLINECOUNTER" which are not supported, are done via automatic scheduling transactions.</t>
      <section title="Scheduling Collections">
        <t>This specification introduces new collection resource types that are used for managing resources specific to scheduling, in addition to basic calendar object resources.</t>
        <section title="Scheduling Calendar Collection">
            <t>A "scheduling calendar collection" is a calendar collection, as defined by <xref target="RFC4791">CalDAV "calendar-access"</xref>, in which creation, modification or deletion of a scheduling object resource that impacts other calendar users, will cause automatic scheduling transactions to occur.</t>
            <t>A scheduling calendar collection MUST report the DAV:collection, CALDAV:calendar and CALDAV:schedule-calendar XML elements in the value of the DAV:resourcetype property.  The element type declaration for the new CALDAV:schedule-calendar is:
                    <figure><artwork><![CDATA[
       <!ELEMENT schedule-calendar EMPTY>
                      ]]></artwork></figure></t>
                    <t>Example: 
                    <figure><artwork><![CDATA[
       <D:resourcetype xmlns:D="DAV:"
                       xmlns:C="urn:ietf:params:xml:ns:caldav">
         <D:collection />
         <C:calendar />
         <C:schedule-calendar />
       </D:resourcetype>
                      ]]></artwork></figure></t>
            <t>As per <xref target="RFC4791">CalDAV "calendar-access"</xref>, servers may automatically provision calendar collections, in which case they can automatically make those scheduling calendar collections if appropriate.</t>
            <t>The MKCALENDAR method request defined in <xref target="RFC4791">CalDAV "calendar-access"</xref> is extended by this specification in the following ways:
                <list style="numbers">
                    <t>If an MKCALENDAR request does not have a request body, the server MUST create a scheduling calendar collection if the request succeeds.</t>
                    <t>If an MKCALENDAR request has a request body specifying WebDAV properties to set and the DAV:resourcetype property is not included in the list of properties to set, then the server MUST create a scheduling calendar collection if the request succeeds.</t>
                    <t>If an MKCALENDAR request has a request body specifying WebDAV properties to set and the DAV:resourcetype property is included in the list of properties to set, then the server MUST create a calendar collection of the type determined by the value of the DAV:resourcetype property if the request succeeds.</t>
                </list>
            </t>
            <t>
              The DAV:resourcetype property on a calendar collection MUST
              be immutable.  Once a calendar collection has been created,
              servers MUST NOT change it from a scheduling calendar
              collection to a basic calendar collection, or vice versa.
            </t>
            <t>Servers MUST support scheduling for all iCalendar component types reported in the CALDAV:supported-calendar-component-set property on a scheduling calendar collection. Also, servers MUST support scheduling for all the media types reported in the CALDAV:supported-calendar-data property on a scheduling calendar collection.</t>
        </section>
          <section anchor="schedule-outbox" title="Scheduling Outbox Collection">
            <t>A scheduling Outbox collection is used as the target for initiating the processing of manual scheduling messages. Currently the only defined use for this is for "VEVENT", "VTODO", and "VJOURNAL" "REFRESH" iTIP messages as well as "VFREEBUSY" "REQUEST" iTIP messages to request a synchronous freebusy lookup for a number of calendar users.</t>
            <t>A scheduling Outbox collection MUST report the DAV:collection and CALDAV:schedule-outbox XML elements in the value of the DAV:resourcetype property. The element type declaration for CALDAV:schedule-outbox is: 
            <figure><artwork><![CDATA[
       <!ELEMENT schedule-outbox EMPTY>
              ]]></artwork></figure></t>
            <t>Example: 
            <figure><artwork><![CDATA[
       <D:resourcetype xmlns:D="DAV:">
         <D:collection/>
         <C:schedule-outbox xmlns:C="urn:ietf:params:xml:ns:caldav"/>
       </D:resourcetype>
              ]]></artwork></figure></t>
            <t>New WebDAV <xref target="RFC3744">ACL</xref> privileges can be used on the scheduling Outbox collection to control who is allowed to send scheduling messages on behalf of the calendar user associated with the scheduling Outbox collection. See <xref target="privileges"/> for more details.</t>
            <t>A scheduling Outbox collection MUST NOT be a child (at any depth) of a calendar collection resource.</t>
			<t>A scheduling Outbox collection MAY have a CALDAV:supported-calendar-data WebDAV property defined on it as per <xref target="RFC4791">CalDAV "calendar-access"</xref> Section 5.2.4. When present this indicates the allowed media types for scheduling messages POST'ed to the scheduling Outbox collection.</t>
          </section>
          <section anchor="schedule-inbox" title="Scheduling Inbox Collection">
            <t>A scheduling Inbox collection contains incoming scheduling messages. These may be requests sent by an "Organizer", or replies sent by an "Attendee" in response to a request.</t>
            <t>A scheduling Inbox collection MUST report the DAV:collection and CALDAV:schedule-inbox XML elements in the value of the DAV:resourcetype property. The element type declaration for CALDAV:schedule-inbox is: 
            <figure><artwork><![CDATA[
       <!ELEMENT schedule-inbox EMPTY>
              ]]></artwork></figure></t>
            <t>Example: 
            <figure><artwork><![CDATA[
       <D:resourcetype xmlns:D="DAV:">
         <D:collection/>
         <C:schedule-inbox xmlns:C="urn:ietf:params:xml:ns:caldav"/>
       </D:resourcetype>
              ]]></artwork></figure></t>
            <t>Every resource in the scheduling Inbox collection MUST be a valid calendar object resource that defines a scheduling message (i.e., an iCalendar object that follows the iTIP semantic). Note that unlike calendar collections defined by the CalDAV "calendar-access" feature, there are no restrictions on the nature of the resources stored (e.g., there is no need to verify that the "UID" property of each resource is unique) beyond the restrictions of iTIP itself. The removal of the "UID" restriction, in particular, is needed because multiple scheduling messages may be sent for one particular calendar component, and each of those will have the same "UID" property in the calendar object resource. This also implies that a scheduling Inbox collection cannot contain any types of WebDAV collection resources.</t>
            <t>New WebDAV <xref target="RFC3744">ACL</xref> privileges can be set on the scheduling Inbox collection to control who the user associated with the scheduling Inbox collection will accept scheduling messages from. See <xref target="privileges"/> for more details.</t>
            <t>A scheduling Inbox collection MUST NOT be a child (at any depth) of a calendar collection resource.</t>
			<t>A scheduling Inbox collection MAY have a CALDAV:supported-calendar-data WebDAV property defined on it as per <xref target="RFC4791">CalDAV "calendar-access"</xref> Section 5.2.4. When present this indicates the allowed media types for scheduling messages delivered to the scheduling Inbox collection.</t>
			<t>A scheduling Inbox collection MAY have a CALDAV:calendar-timezone WebDAV property defined on it as per <xref target="RFC4791">CalDAV "calendar-access"</xref> Section 5.2.2. When present this contains a time zone that the server can use when calendar date-time operations are carried out, for example when a time-range CALDAV:calendar-query REPORT is targeted at a scheduling Inbox collection.</t>
          </section>
      </section>
      <section title="Automatic Scheduling Transactions">
        <section title="Introduction">
          <t>When a calendar object resource is created, modified or removed from a scheduling calendar collection that supports the operations defined in this specification (either via a PUT, DELETE, COPY or MOVE HTTP request), the server examines the calendar data and checks to see whether the data represents a scheduling object resource. If it does, the server will take care of automatically sending and processing scheduling messages to the appropriate recipients. Several types of scheduling operation can occur in this case, equivalent to iTIP "REQUEST", "REPLY", "CANCEL" and "ADD" operations.</t>
          <t>When a scheduling transaction is processed by the server, it will attempt to deliver a scheduling message to each recipient.</t>
        </section>
        <section title="Identifying Scheduling Object Resources">
          <t>
            The server will only perform automatic scheduling transactions on creations, modifications, and deletions of valid scheduling object resources. There are two types of scheduling object resources: organizer scheduling object resources, and attendee scheduling object resources.
          </t>
          <t>
            A calendar object resource is considered to be a valid organizer scheduling object resource if the "ORGANIZER" iCalendar property is present and set in all the calendar components to a value that matches one of the calendar user addresses of the owner of the scheduling calendar collection.
          </t>
          <t>
            A calendar object resource is considered to be a valid attendee scheduling object resource if the "ORGANIZER" iCalendar property is present and set in all the calendar components to the same value and doesn't match one of the calendar user addresses of the owner of the scheduling calendar collection, and that one of the "ATTENDEE" iCalendar property values match one of the calendar user addresses of the owner of the scheduling calendar collection.
          </t>
          <t>
            The creation of attendee scheduling object resources will typically be done by the server in cases where a default scheduling calendar collection is defined. In cases where no default scheduling calendar collection is defined, the server MAY prevent calendar user agents from forging attendee scheduling object resources by forbidding their creation or imposing restrictions on their creation. For instance, a server MAY require the presence of a scheduling message, received from the "ORGANIZER" with the same "UID" property value, in the scheduling Inbox collection of the owner of the scheduling calendar collection.
          </t>
        </section>
        <section title="Handling Scheduling Object Resources">
          <t>The server's behavior when processing a scheduling object resource depends on whether it is owned by the "Organizer" or an "Attendee" specified in the calendar data.</t>
          <section title='Organizer Scheduling Object Resources'>
            <t>An "Organizer" can create, modify or remove a scheduling object resource by issuing HTTP requests with an appropriate method. The create, modify and remove behaviors for the server are each described next, and the way these are invoked via HTTP requests is described in <xref target="http_methods"/>.</t>
            <section title='Actions on "Organizer" Scheduling Object Resource'>
              <section title="Create">
                <t>When a scheduling object resource is created by the "Organizer", the server will inspect each "ATTENDEE" property to determine which ones have the "SCHEDULE-AGENT" iCalendar property parameter.</t>
                <t>For each "Attendee" the server will determine whether to attempt to deliver a scheduling message into the "Attendee's" scheduling Inbox collection, based on the table below:</t>
                <figure>
                  <artwork><![CDATA[
               +------------------+-------------+
               | SCHEDULE-AGENT   | iTIP METHOD |
               +==================+=============+
               | SERVER (default) | REQUEST     |
               +------------------+-------------+
               | CLIENT           | --          |
               +------------------+-------------+
               | NONE             | --          |
               +------------------+-------------+
                  ]]></artwork>
                </figure>
                <t>The attempt to deliver the scheduling message will either succeed or fail. In all cases, the server MUST add a "SCHEDULE-STATUS" iCalendar property parameter to the "ATTENDEE" iCalendar property in the scheduling object resource being created, and set its value as described in <xref target="schedule-status-value"/>. This will result in the created calendar object resource differing from the calendar data sent in the HTTP request. As a result clients SHOULD reload the calendar data from the server as soon as it is stored in order to update to the new server generated state information. Servers MUST NOT set the "SCHEDULE-STATUS" property on any "ATTENDEE" properties for "Attendees" that were not sent a scheduling message.</t>
                <t>Restrictions:
                  <list style="numbers">
                    <t>The server MUST reject any attempt to set the "PARTSTAT" iCalendar property parameter value of the "ATTENDEE" iCalendar property of other users in the calendar object resource to a value other than "NEEDS-ACTION" if the "SCHEDULE-AGENT" property parameter value is not present or set to the value "SERVER".</t>
                    <t>The server MUST reject any attempt to create a duplicate scheduling object resource in any of the scheduling calendar collections owned by the "Organizer". A duplicate scheduling object resource is one with the same "UID" as an existing scheduling object resource.</t>
                    <t>The server MUST take into account scheduling privileges when handling the creation of a scheduling object resource as described in <xref target="privileges"/>.</t>
                  </list>
                </t>
              </section>
              <section title="Modify">
                <t>When a scheduling object resource is modified by the "Organizer", the server will inspect each "ATTENDEE" property in the new calendar data to determine which ones have the "SCHEDULE-AGENT" iCalendar property parameter. It will then need to compare this with the "ATTENDEE" properties in the existing calendar object resource that is being modified.</t>
                <t>
                  For each "Attendee" in the old and new calendar data on a per-instance basis, and taking into account the addition or removal of "Attendees", the server will determine whether to attempt to deliver a scheduling message to the "Attendee". The following table determines whether the server needs to delivery a scheduling message, and if so using which iTIP scheduling method. The heading values "SERVER", "CLIENT" and "NONE" makes reference to the "SCHEDULE-AGENT" parameter value of the "ATTENDEE" property, and the heading values "&lt;Absent&gt;" and "&lt;Removed&gt;" are used to cover the cases where the "ATTENDEE" property was not present (Old) or has been removed (New).
                </t>
                <figure>
                  <artwork><![CDATA[
+---------------+-----------------------------------------------+
|               |                     New                       |
|    ATTENDEE   +-----------+-----------+-----------+-----------+
|               | <Removed> | SERVER    | CLIENT    | NONE      |
|               |           | (default) |           |           |
+===+===========+===========+===========+===========+===========+
|   | <Absent>  |  --       | REQUEST / | --        | --        |
|   |           |           | ADD       |           |           |
|   +-----------+-----------+-----------+-----------+-----------+
|   | SERVER    |  CANCEL   | REQUEST   | CANCEL    | CANCEL    |
| O | (default) |           |           |           |           |
| l +-----------+-----------+-----------+-----------+-----------+
| d | CLIENT    |  --       | REQUEST / | --        | --        |
|   |           |           | ADD       |           |           |
|   +-----------+-----------+-----------+-----------+-----------+
|   | NONE      |  --       | REQUEST / | --        | --        |
|   |           |           | ADD       |           |           |
+---+-----------+-----------+-----------+-----------+-----------+ 
                  ]]></artwork>
                </figure>
                <t>The attempt to deliver the scheduling message will either succeed or fail. In all cases, the server MUST add a "SCHEDULE-STATUS" iCalendar property parameter to the "ATTENDEE" iCalendar property in the scheduling object resource being modified, and set its value as described in <xref target="schedule-status-value"/>. This will result in the created calendar object resource differing from the calendar data sent in the HTTP request. As a result clients SHOULD reload the calendar data from the server as soon as it is stored in order to update to the new server generated state information.</t>
                <t>Restrictions:
                <list style="numbers">
                    <t>The client MUST NOT change the "PARTSTAT" iCalendar property parameter value on any "ATTENDEE" iCalendar property in the calendar object resource to a value other than "NEEDS-ACTION" if the "SCHEDULE-AGENT" property parameter value is not present or set to the value "SERVER".</t>
                    <t>The client MUST NOT change the "UID" iCalendar property parameter value in the scheduling object resource.</t>
                    <t>The server MUST take into account scheduling privileges when handling the modification of a scheduling object resources as described in Section <xref target="privileges"/>.</t>
                </list>
                </t>
              </section>
              <section title="Remove">
                <t>When a scheduling object resource is removed by the "Organizer", the server will inspect each "ATTENDEE" property in the scheduling object resource being removed to determine which ones have the "SCHEDULE-AGENT" iCalendar property parameter.</t>
                <t>For each "Attendee" the server will determine whether to attempt to deliver a scheduling message into the "Attendee's" scheduling Inbox collection, based on the table below:</t>
                <figure>
                  <artwork><![CDATA[
               +------------------+-------------+
               | SCHEDULE-AGENT   | iTIP METHOD |
               +==================+=============+
               | SERVER (default) | CANCEL      |
               +------------------+-------------+
               | CLIENT           | --          |
               +------------------+-------------+
               | NONE             | --          |
               +------------------+-------------+
                  ]]></artwork>
                </figure>
                <t>The attempt to deliver the scheduling message will either succeed or fail. In all cases, the server MUST add a "SCHEDULE-STATUS" iCalendar property parameter to the "ATTENDEE" iCalendar property in the scheduling object resource being created, and set its value as described in <xref target="schedule-status-value"/>. This will result in the created calendar object resource differing from the calendar data sent in the HTTP request. As a result clients SHOULD reload the calendar data from the server as soon as it is stored in order to update to the new server generated state information. Servers MUST NOT set the "SCHEDULE-STATUS" property on any "ATTENDEE" properties for "Attendees" that were not sent a scheduling message.</t>
                <t>Restrictions:
                <list style="numbers">
                    <t>The server MUST take into account scheduling privileges when handling the removal of a scheduling object resource as described in <xref target="privileges"/>.</t>
                </list>
                </t>
              </section>
            </section>
          </section>
          <section title='Attendee Scheduling Object Resources'>
            <t>An "Attendee" can create, modify or remove a scheduling object resource by issuing HTTP requests with an appropriate method. The create, modify and remove behaviors for the server are each described next, and the way these are invoked via HTTP requests is described in <xref target="http_methods"/>.</t>
            <section title="Actions on a Scheduling Object Resource">
              <section title='Allowed "Attendee" Changes'>
                <t>Attendees need to some changes to a scheduling object resource, though the key scheduling properties such as start, end, location, summary etc. are typically under the control of the "Organizer" of the event.</t>
                <t>The server MUST allow attendees to:
                  <list style="numbers">
                  <t>change their own "PARTSTAT" iCalendar property parameter value.</t>
                  <t>add or remove "X-" iCalendar property parameters on their own "ATTENDEE" properties.</t>
                  <t>add, modify or remove any "TRANSP" iCalendar properties.</t>
                  <t>add, modify or remove any "X-" iCalendar properties in any component.</t>
                  <t>add, modify or remove any "VALARM" iCalendar components.</t>
                  <t>add, modify or remove "PRODID", "CALSCALE" or "X-" iCalendar properties within the top-level "VCALENDAR" component.</t>
                  <t>create new components to represent overridden recurrence instances, provided the only changes to the recurrence instance follow the rules above.</t>
                  </list>
                </t>
              </section>
              <section title="Create">
                <t>A scheduling object resource is created by an "Attendee" when the client creates a scheduling object resource corresponding to an unprocessed scheduling message currently in that "Attendee's" scheduling Inbox collection.</t>
                <t>The "Attendee" is allowed to make changes as noted above.</t>
                <t>If the "Attendee" changes one or more "PARTSTAT" iCalendar property values on any component, or adds an overridden component with a changed "PARTSTAT" property, then the server MUST deliver an iTIP"REPLY"
scheduling message to the "Organizer" to indicate the new participation status of the "Attendee".</t>
                <t>The attempt to deliver the scheduling message will either succeed or fail. In all cases, the server MUST add a "SCHEDULE-STATUS" iCalendar property parameter to the "ORGANIZER" iCalendar property in the scheduling object resource being created, and set its value as described in <xref target="schedule-status-value"/>. This will result in the created calendar object resource differing from the calendar data sent in the HTTP request. As a result clients SHOULD reload the calendar data from the server as soon as it is stored in order to update to the new server generated state information.</t>
              </section>
              <section title="Modify">
                <t>Behavior is as per the Create action above.</t>
              </section>
              <section title="Remove">
                <t>When a scheduling object resource is removed by the "Attendee", one of two possibilities exist:
                  <list style="numbers">
                    <t>If the HTTP request contains a request header "Schedule-Reply" set to the value "T" or there is no "Schedule-Reply" request header, then the server MUST attempt to deliver a scheduling message to the "Organizer" indicating that the "Attendee" has a "PARTSTAT" iCalendar property parameter value set to "DECLINED", i.e., the "Attendee" has chosen not to attend any instances. If the server is unable to deliver the scheduling message, the remove action MUST fail, and an appropriate "SCHEDULE-STATUS" iCalendar property parameter set on the "ORGANIZER" property in the scheduling object resource stored by the server.</t>
                    <t>If the HTTP request contains a request header "Schedule-Reply" set to the value "F", the server MUST NOT attempt to deliver a scheduling message. The resource is simply removed. This provides the client a way to silently remove unwanted scheduling attempts.</t>
                  </list>
                </t>
              </section>
            </section>
          </section>
          <section anchor="http_methods" title="HTTP Methods">
            <t>This section describes how use of various HTTP methods on a scheduling object resource will cause a create, modify or remove action on that resource as described above.</t>
            <section title="PUT">
              <t>When a PUT method request is received, the server will execute the following actions, provided all appropriate pre-conditions are met:</t>
              <texttable>
                <ttcol>Existing Destination Resource</ttcol>
                <ttcol>Resulting Destination Resource</ttcol>
                <ttcol>Server Action</ttcol>
                <c>None</c>
                <c>Calendar object resource</c>
                <c>None</c>
                <c>None</c>
                <c>Scheduling object resource</c>
                <c>Create</c>
                <c>Calendar object resource</c>
                <c>Calendar object resource</c>
                <c>None</c>
                <c>Calendar object resource</c>
                <c>Scheduling object resource</c>
                <c>Create</c>
                <c>Scheduling object resource</c>
                <c>Calendar object resource</c>
                <c>Remove</c>
                <c>Scheduling object resource</c>
                <c>Scheduling object resource</c>
                <c>Modify</c>
              </texttable>
            </section>
            <section title="COPY">
              <t>When a COPY method request is received, the server will execute the same behavior as described above for a PUT method, with appropriate pre-conditions applied.</t>
            </section>
            <section title="MOVE">
              <t>When a MOVE method request is received:
              <list>
                <t>when moving from a basic calendar collection, into a scheduling calendar collection, the server will execute the same behavior as described above for a PUT method, with appropriate pre-conditions applied.</t>
                <t>when moving from a scheduling calendar collection, into a basic calendar collection, the server will execute the behavior shown in <xref target="table_MOVE1"/>.</t>
                <t>when moving from a scheduling calendar collection, into a scheduling calendar collection, no special behavior occurs, though appropriate pre-conditions are applied.</t>
                </list>
              </t>
              <texttable anchor="table_MOVE1">
                <ttcol>Source Resource</ttcol>
                <ttcol>Server Action</ttcol>
                <c>Calendar object resource</c>
                <c>None</c>
                <c>Scheduling object resource</c>
                <c>Remove</c>
              </texttable>
            </section>
            <section title="DELETE">
              <t>When a DELETE method is targeted at a scheduling object resource the server will execute the Remove action.</t>
              <t>When a DELETE method is targeted at a scheduling calendar collection the server will execute the Remove action on all scheduling object resources contained in the scheduling calendar collection.</t>
            </section>
          </section>
        </section>
      </section>
      <section anchor="auto-process" title="Processing of incoming scheduling messages">
        <t>Scheduling operations can cause the delivery of a scheduling message into an "Organizer's" or "Attendee's" scheduling Inbox collection. In the former case the scheduling messages are replies or refresh requests from "Attendees", in the latter case the scheduling messages are requests, cancellations or additions from the "Organizer".</t>
        <t>In some cases the server will automatically process the scheduling message, in other cases the scheduling message will be left for the client to process. In each case, the scheduling message in the scheduling Inbox collection is used as an indicator to the client that a scheduling operation has taken place.</t>
        <section title='Automatic processing for the "Organizer"'>
          <section title='Processing an "Attendee" reply'>
            <t>For a scheduling message reply sent by an "Attendee", the server first locates the corresponding scheduling object resource belonging to the "Organizer".</t>
            <t>The server MUST then update the "PARTSTAT" iCalendar parameter value of each "ATTENDEE" iCalendar property in the scheduling object resource to match the changes indicated in the reply (taking into account the fact that an "Attendee" could have created a new overridden iCalendar component to indicate different participation status on one or more instances of a recurring event).</t>
            <t>The server MUST also update or add the "SCHEDULE-STATUS" property parameter on each matching "ATTENDEE" iCalendar property and sets its value to that of the "REQUEST-STATUS" property in the reply, or to "2.0" if "REQUEST-STATUS" is not present (also taking into account recurrence instances).</t>
            <t>At the same time, the server MUST add the CALDAV:schedule-state WebDAV property with the value CALDAV:schedule-processed (see <xref target="PROPERTY_schedule-state"/>) to the scheduling message in the Inbox scheduling collection.</t>
            <t>The server MUST send scheduling messages to all the other "Attendees" indicating the change in participation status of the "Attendee" replying, subject to the recurrence requirements of <xref target="recurrence_handling"/>.</t>
          </section>
          <section title='Processing an "Attendee" refresh'>
            <t>TODO: write something here.</t>
          </section>
        </section>
        <section title='Automatic processing for the "Attendee"'>
          <t>For a scheduling message sent by the "Organizer", the server first tries to locate a corresponding scheduling object resource belonging to the "Attendee". If no matching scheduling object resource exists, the server treats the scheduling message as a new message, otherwise it is treated as an update.</t>
          <section title="Processing a new scheduling message">
            <t>When a scheduling message for a new calendar components is detected, two possibilities exist, depending on whether a <xref target="default_calendar">"default" calendar</xref> is set for the "Attendee":
              <list style="numbers">
                <t>if no valid default calendar is set, the server leaves the scheduling message in the scheduling Inbox collection, but it MUST add the CALDAV:schedule-state WebDAV property with the value CALDAV:schedule-unprocessed (see <xref target="PROPERTY_schedule-state"/>) to the scheduling message. It is then up to the client to explicitly process the scheduling message and remove it from the scheduling Inbox collection once it has done so.</t>
                <t>if a valid default calendar is set, the server MUST process the scheduling message and create an appropriate scheduling object resource in the default calendar set for the "Attendee". At the same time it MUST add the CALDAV:schedule-state WebDAV property with the value CALDAV:schedule-processed (see <xref target="PROPERTY_schedule-state"/>) to the scheduling message.</t>
              </list>
            </t>
          </section>
          <section title="Processing a scheduling message update">
            <t>When an update to scheduling message is detected, the server MUST update the matching scheduling object resource belonging to the "Attendee" to reflect the changes proposed in the scheduling message. At the same time it MUST add the CALDAV:schedule-state WebDAV property with the value CALDAV:schedule-processed (see <xref target="PROPERTY_schedule-state"/>) to the scheduling message.</t>
          </section>
        </section>
        <section title="Processing by the client">
          <t>When a client detects a scheduling message in the scheduling Inbox collection it needs to look at the CALDAV:schedule-state WebDAV property on the resource and act accordingly:
            <list style="numbers">
              <t>if CALDAV:schedule-state is set to CALDAV:schedule-unprocessed, then it is the client's responsibility to process the scheduling message and remove it from the scheduling Inbox collection once it has done so.</t>
              <t>if CALDAV:schedule-state is set to CALDAV:schedule-processed, then the server has already processed the scheduling message, but has left it in the scheduling Inbox collection to serve as a notification to the client that a change has been made to the corresponding scheduling object resource. It is then the client's responsibility to remove the scheduling object resource from the scheduling Inbox collection once it has made note of the fact that a change has occurred.</t>
            </list>
          </t>
        </section>
      </section>
      <section title="Explicit Scheduling Request">
        <t>An explicit scheduling request sends a scheduling message via an HTTP POST request targeted at a scheduling Outbox collection. Full details can be found in <xref target="schedule"/>.</t>
      </section>
      <section title="Other Considerations">
        <section anchor="recurrence_handling" title="Handling recurring items">
          <section title="Restricting what is sent">
            <t>When delivering scheduling messages for recurring calendar components to "Attendees", servers MUST ensure that "Attendees" only get information about recurrence instances that explicitly include them as an "Attendee".</t>
            <t>For example, if an "Attendee" is invited to a single recurrence instance of a recurring event, and no others, the scheduling objet resource contained in the "Organizer's" scheduling calendar collection will contain an overridden instance in the form of a separate calendar component. That separate calendar component will include the "ATTENDEE" property referencing the "one-off" "Attendee". That "Attendee" will not be listed in any other calendar components in the scheduling object resource. The scheduling message that will be delivered to the "Attendee" will only contain information about this overridden instance.</t>
            <t>As another example, an "Attendee" could be excluded from one instance of a recurring event. In that case the scheduling object resource contained in the scheduling calendar collection of the "Organizer" will include an overridden instance with an "ATTENDEE" list that does not include the "Attendee" being excluded. The scheduling message that will be delivered to the "Attendee" will not specify the overridden instance but rather include an "EXDATE" property to the master recurring component defining the recurrence set.</t>
            <t>This requirement is needed to ensure that "Attendees" only have access to calendar data for items they have been explicitly invited to.</t>
          </section>
          <section title='"Attendee" overrides'>
            <t>When a recurring scheduling message is sent to an "Attendee", that "Attendee" may wish to reply with different participation status on one or more recurrence instances. In order to do that it will need to add an overridden iCalendar component for the instances with different participation status, and send that as a reply back to the "Organizer". The "Organizer" will then need to incorporate any new overridden instances into the matching scheduling object resource to ensure that the "Attendee's" participation status is accurately recorded for all recurrence instances.</t>
          </section>
        </section>
        <section anchor="default_calendar" title="Handling the Default Calendar">
          <t>A calendar user may have multiple calendars representing different "spheres of activity". However, scheduling requests are targeted at calendar users and not a specific calendar of a calendar user. Often it is not appropriate to automatically deliver a scheduling message to a particular calendar because that scheduling message refers to an event for a different "sphere of activity". By storing all incoming scheduling requests in a separate special collection, clients can process the requests in that collection and choose which calendar ("sphere of activity") the request belongs to and make its own arrangements to place the relevant calendar object in that calendar.</t>
          <t>This specification defines the concept of a "default" scheduling calendar collection. If a valid default scheduling calendar collection is specified, then servers are required to automatically process new scheduling messages and create the appropriate scheduling object resource in the default calendar collection. If there is no valid default calendar, then the server does not automatically process new scheduling messages, and instead leaves it up to the client to process the scheduling message and create the appropriate scheduling object resource in a scheduling calendar collection chosen by the calendar user.</t>
          <t>In order to manage this behavior, a new CALDAV:schedule-default-calendar-URL WebDAV property is defined for use on scheduling Inbox collections. This property is used to define the default calendar collection, if one is required. See <xref target="PROPERTY_schedule-default-calendar-URL"/>.</t>
        </section>
        <section title="DTSTAMP and SEQUENCE properties">
          <t>Whenever the server generates a scheduling message for delivery to a recipient, it MUST ensure that a "DTSTAMP" iCalendar property is present and MUST set the value to the UTC time that the scheduling message was generated (as required by iCalendar).</t>
          <t><xref target="RFC2446">iTIP</xref> places certain requirements on how the "SEQUENCE" iCalendar property value in scheduling messages changes. The server MUST ensure that for each type of scheduling operation, the "SEQUENCE" iCalendar property value is appropriately updated. If the client does not update the "SEQUENCE" iCalendar property itself when that is required, the server MUST update the property and change any scheduling object resource accordingly.</t>
        </section>
        <section title="Schedule Status Values" anchor="schedule-status-value">
            <t>When scheduling with an "Attendee" there are two types of status information that can be returned during the transaction. The first status information is a "delivery" status that indicates whether the scheduling message from the "Organizer" to the "Attendee" was delivered or not, or what the current status of delivery is. The second status information is a "reply" status corresponding to the "Attendee's" own "REQUEST-STATUS" information from the scheduling message reply that is sent back to the "Organizer".</t>
            <t>Similarly, when an "Attendee" sends a reply back to the "Organizer", there will be "delivery" status information for the scheduling message sent to the "Organizer". However, there is no "REQUEST-STATUS" sent back by the "Organizer", so there is no equivalent of the "reply" status as per scheduling messages to "Attendees".</t>
            <t>The "delivery" status information on an "ORGANIZER" or "ATTENDEE" iCalendar property is conveyed in the "SCHEDULE-STATUS" property parameter value (<xref target="schedule-status"/>). The status code value for "delivery" status can be one of the following:</t>
            <texttable>
                <ttcol>Delivery Status Code</ttcol>
                <ttcol>Description</ttcol>
                <c>1.0</c>
                <c>The scheduling message is pending, that is, the server is still in the process of sending the message. The status code value can be expected to change once the server has completed its sending and delivery attempts.</c>
                <c>&nbsp;</c>
                <c>&nbsp;</c>
                <c>1.1</c>
                <c>The scheduling message has been successfully sent. However, the server does not have explicit information about whether the scheduling message was successfully delivered to the recipient. This state van occur with "store and forward" style scheduling protocols such as <xref target="RFC2447">iMIP</xref> (iTIP using email).</c>
                <c>&nbsp;</c>
                <c>&nbsp;</c>
                <c>1.2</c>
                <c>The scheduling message has been successfully delivered.</c>
                <c>&nbsp;</c>
                <c>&nbsp;</c>
                <c>3.7</c>
                <c>The scheduling message was not delivered because the server did not recognize the calendar user address of the recipient as being a supported URI.</c>
                <c>&nbsp;</c>
                <c>&nbsp;</c>
                <c>3.8</c>
                <c>The scheduling message was not delivered because access privileges do not allow it.</c>
                <c>&nbsp;</c>
                <c>&nbsp;</c>
                <c>5.1</c>
                <c>The scheduling message was not delivered because the server could not complete delivery of the message. This is likely due to a temporary failure, and the originator can try to send the message again at a later time.</c>
                <c>&nbsp;</c>
                <c>&nbsp;</c>
                <c>5.2</c>
                <c>The scheduling message was not delivered because the server was not able to find a suitable way to deliver the message. This is likely a permanent failure, and the originator should not try to send the message again, at least without verifying/correcting the calendar user address of the recipient.</c>
                <c>&nbsp;</c>
                <c>&nbsp;</c>
                <c>5.3</c>
                <c>The scheduling message was not delivered and was rejected because scheduling with that recipient is not allowed. This is likely a permanent failure, and the originator should not try to send the message again.</c>
            </texttable>
            <t>The status code for "reply" status can be any of the valid <xref target="RFC2446">iTIP</xref> "REQUEST-STATUS" values.</t>
        </section>
        <section title="Error Handling">
          <t>TODO: e.g., how to deal with failed cancels.</t>
        </section>
        <section title='"Organizer" is an "Attendee"'>
          <t>The "Organizer" of a scheduled calendar component may also be an "Attendee" of that calendar component. In such cases the server MUST NOT send a scheduling message to the "Attendee" that matches the "Organizer".</t>
        </section>
      </section>
    </section>
<!-- Process -->
    <section anchor="new-icalendar" title="New iCalendar Parameters">
      <t>This section describes additions to <xref target="RFC2445">iCalendar</xref> to support CalDAV scheduling.</t>
       <section title="Schedule Agent">
         <t>
           <list style="hanging">
             <t hangText="Parameter Name:">SCHEDULE-AGENT</t>
             <t hangText="Purpose:">Indicates what agent is expected to handle scheduling for the corresponding "Attendee".</t>
             <t hangText="Format Definition:">This property parameter is defined by the following notation: 
             <figure><artwork><![CDATA[
   scheduleagentparam = "SCHEDULE-AGENT" "="
                     ("SERVER"       ; The server handles scheduling
                    / "CLIENT"       ; The client handles scheduling
                    / "NONE"         ; No automatic scheduling
                    / x-name         ; Experimental type
                    / iana-token)    ; Other IANA registered
                                     ; type
   ; Default is SERVER
                 ]]></artwork></figure></t>
             <t hangText="Description:">This property parameter MAY be present on any "ATTENDEE" iCalendar property. In the absence of this parameter, the value "SERVER" MUST be used for the default behavior. The value determines whether or not an automatic scheduling transaction on a server will cause a scheduling message to be sent to the corresponding calendar user identified by the "ATTENDEE" property value. When the value "SERVER" is specified (or the parameter is absent) then it is the server's responsibility to send a scheduling messages as part of an automatic scheduling transaction. When the value "CLIENT" is specified, that indicates that the client is handling scheduling messages with the calendar user itself. When "NONE" is specified, no scheduling messages are being sent to the calendar user.</t>
             <t>Servers MUST NOT include this parameter in any scheduling messages sent as the result of an automatic scheduling transaction.</t>
             <t>Clients SHOULD NOT include this parameter in any scheduling messages that they themselves send.</t>
             <t hangText="Example:">
               <figure>
                 <artwork><![CDATA[
   ATTENDEE;SCHEDULE-AGENT=SERVER:mailto:cyrus@example.org
                 ]]></artwork>
               </figure>
             </t>
           </list>
         </t>
       </section>
       <section title="Schedule Status" anchor="schedule-status">
         <t>
           <list style="hanging">
             <t hangText="Parameter Name:">SCHEDULE-STATUS</t>
             <t hangText="Purpose:">Indicates the status code returned from processing of the most recent scheduling message sent to the corresponding "Attendee", or received from the corresponding "Organizer".</t>
             <t hangText="Format Definition:">This property parameter is defined by the following notation: 
             <figure><artwork><![CDATA[
   schedulestatusparam = "SCHEDULE-STATUS" "=" statcode
   ; statcode defined in RFC2445.
                 ]]></artwork></figure></t>
             <t hangText="Description:">This property parameter may be present on any "ATTENDEE" or "ORGANIZER" iCalendar property.</t>
             <t>Servers MUST add this parameter to any "ATTENDEE" properties corresponding to calendar users who were sent a scheduling message via an automatic scheduling transaction. Clients SHOULD NOT change or remove this parameter if it was provided by the server. In the case where the client is handling the scheduling the client MAY add, change or remove this parameter to indicate the last scheduling message status it received.</t>
             <t>Servers MUST add this parameter to any "ORGANIZER" properties corresponding to calendar users who were sent a scheduling message reply by an "Attendee" via an automatic scheduling transaction. Clients SHOULD NOT change or remove this parameter if it was provided by the server. In the case where the client is handling the scheduling the client MAY add, change or remove this parameter to indicate the last scheduling message status it received.</t>
             <t>Servers MUST NOT include this parameter in any scheduling messages sent as the result of an automatic scheduling transaction.</t>
             <t>Clients SHOULD NOT include this parameter in any scheduling messages that they themselves send.</t>
            <t>Suitable values for this property parameter are described in <xref target="schedule-status-value"/>.</t>
             <t hangText="Example:">
               <figure>
                 <artwork><![CDATA[
   ATTENDEE;SCHEDULE-STATUS="2.0":mailto:cyrus@example.org
                 ]]></artwork>
               </figure>
             </t>
           </list>
         </t>
      </section>
    </section>
    <section anchor="webdav-headers" title="New WebDAV Request Header">
      <t>The CalDAV scheduling extension defines the following new WebDAV request headers for use with CalDAV.</t>
      <section anchor="schedule-reply-header" title="Schedule-Reply Request Header">
        <figure>
          <artwork><![CDATA[
          ScheduleReply = "Schedule-Reply" ":" ("T" | "F")
          ]]></artwork>
        </figure>
        <t>When an HTTP DELETE request occurs on a scheduling object resource, and the Schedule-Reply header is not present, or present and set to the value "T", the server MUST send an appropriate iTIP "CANCEL" 
scheduling message as part of its normal automatic scheduling transaction processing.</t>
        <t>When an HTTP DELETE request occurs on a scheduling object resource, and the Schedule-Reply header is set to the value "F", the server MUST NOT send an iTIP scheduling message as part of its normal automatic scheduling transaction processing.</t>
        <t>The Schedule-Reply request header is used by a client to indicate to a server whether or not an automatic scheduling transaction should occur when an "Attendee" deletes a scheduling object resource. In particular it controls whether an iTIP "CANCEL" message is sent to the "Organizer" as a result of the deletion. There are situations in which unsolicited scheduling messages need to be silently deleted (or ignored) for security or privacy reasons. The new header allows the scheduling message to be suppressed if such a need arises.</t>
        <t>All scheduling object resources MUST support the Schedule-Reply header.</t>
      </section>
    </section>
    <section anchor="webdav-properties" title="New WebDAV Properties">
      <t>The CalDAV scheduling extension defines the following new WebDAV properties for use with CalDAV.</t>
      <section anchor="PROPERTY_schedule-calendar-transp" title="CALDAV:schedule-calendar-transp Property">
        <t>
<?rfc compact="no" ?>
          <list style="hanging">
            <t hangText="Name:">schedule-calendar-transp</t>
            <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
            <t hangText="Purpose:">Determines whether the calendar object resources in a calendar collection will affect the owner's freebusy.</t>
            <t hangText="Protected:">This property MAY be protected and SHOULD NOT be returned by a PROPFIND allprop request (as defined in Section 14.2 of <xref target="RFC4918">WebDAV</xref>).</t>
            <t hangText="COPY/MOVE behavior:">This property value SHOULD be kept during a MOVE operation, but is normally re-initialized when a resource is created with a COPY. It should not be set in a COPY.</t>
            <t hangText="Description:">This property SHOULD be defined on all calendar object resources. If present, it contains one of two XML elements that indicate whether the calendar object resources should contribute to the owner's freebusy or not. When the 'opaque' element is used, all calendar object resources MUST contribute to freebusy, assuming access privileges and other iCalendar properties allow it to. When the 'transparent' XML element is used, all calendar object resources MUST NOT contribute to freebusy.</t>
            <t hangText="Definition:">
              <figure>
                <artwork><![CDATA[
<!ELEMENT schedule-calendar-transp (opaque|transparent) >

<!ELEMENT opaque      EMPTY>
<!-- Calendar object resources affect owner freebusy -->

<!ELEMENT transparent EMPTY>
<!-- Calendar object resources never affect owner freebusy -->
                   ]]></artwork>
              </figure>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
<C:schedule-calendar-transp
     xmlns:C="urn:ietf:params:xml:ns:caldav">
  <C:opaque/>
</C:schedule-calendar-transp>
                   ]]></artwork>
              </figure>
            </t>
          </list>
<?rfc compact="yes" ?>
        </t>
      </section>
      <section anchor="PROPERTY_schedule-default-calendar-URL" title="CALDAV:schedule-default-calendar-URL Property">
        <t>
<?rfc compact="no" ?>
          <list style="hanging">
            <t hangText="Name:">schedule-default-calendar-URL</t>
            <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
            <t hangText="Purpose:">Specifies a default calendar for an attendee that will automatically have new scheduling messages deposited into it when they arrive.</t>
            <t hangText="Protected:">This property MAY be protected in the case where a server supports only a single scheduling calendar collection, or does not support changing the default calendar, or does not support a default calendar.</t>
            <t hangText="COPY/MOVE behavior:">This property is only defined on a scheduling Inbox collection which cannot be moved or copied.</t>
            <t hangText="Description:">This property MAY be defined on a scheduling Inbox collection. If present, it contains zero or one DAV:href XML elements. When a DAV:href element is present, its value indicates a URL to a scheduling calendar collection that is used as the default calendar. When no DAV:href element is present, it indicates that there is no default calendar. In the absence of this property there is no default calendar.</t>
            <t hangText="Definition:">
              <figure>
                <artwork><![CDATA[
<!ELEMENT schedule-default-calendar-URL (DAV:href?) >
                   ]]></artwork>
              </figure>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
<C:schedule-default-calendar-URL xmlns:D="DAV:"
     xmlns:C="urn:ietf:params:xml:ns:caldav">
  <D:href>/calendars/users/cdaboo/calendar/</D:href>
</C:schedule-default-calendar-URL>
                   ]]></artwork>
              </figure>
            </t>
          </list>
<?rfc compact="yes" ?>
        </t>
      </section>
      <section anchor="PROPERTY_schedule-state" title="CALDAV:schedule-state Property">
        <t>
<?rfc compact="no" ?>
          <list style="hanging">
            <t hangText="Name:">schedule-state</t>
            <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
            <t hangText="Purpose:">Indicates whether a scheduling message in a scheduling Inbox collection has been processed as part of an automatic scheduling transaction.</t>
            <t hangText="Protected:">This property MUST be protected as only the server can carry out automatic processing of scheduling messages.</t>
            <t hangText="COPY/MOVE behavior:">This property is only defined on a scheduling message in a scheduling Inbox collection. If a scheduling message is copied or moved into a scheduling Inbox collection, this property MUST NOT be set.</t>
            <t hangText="Description:">This property MAY be defined on a scheduling resource in a scheduling Inbox collection. If present, it contains one of two XML elements. When the CALDAV:schedule-unprocessed XML element is used, it indicates that the scheduling message has not been automatically processed by the server, and thus needs action on the part of the client. When the CALDAV:schedule-processed XML element is used, it indicates that automatic processing of the scheduling message has taken place, so no scheduling operations are needed by the client.</t>
            <t hangText="Definition:">
              <figure>
                <artwork><![CDATA[
<!ELEMENT schedule-state (schedule-processed|schedule-unprocessed) >

<!ELEMENT schedule-processed   EMPTY>
<!-- Scheduling message has been automatically processed -->

<!ELEMENT schedule-unprocessed EMPTY>
<!-- Scheduling message has not been automatically processed -->
                   ]]></artwork>
              </figure>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
<C:schedule-state xmlns:C="urn:ietf:params:xml:ns:caldav">
  <C:schedule-processed/>
</C:schedule-state>
                   ]]></artwork>
              </figure>
            </t>
          </list>
<?rfc compact="yes" ?>
        </t>
      </section>
    </section>
    <section title="New Preconditions">
      <section title="Additional Preconditions for PUT, COPY and MOVE">
        <t>This specification requires additional Preconditions for the PUT, COPY and MOVE methods. The preconditions are:
        <?rfc compact="no" ?>
        <list>
            <t>(CALDAV:unique-scheduling-object-resource): Only one scheduling object with a particular iCalendar property "UID" value MUST exist in the system for each "Organizer" and each "Attendee".</t>
            <t>(CALDAV:same-organizer-in-all-components): All the calendar components in a scheduling object resource being stored in a scheduling calendar collection MUST contain the same "ORGANIZER" property value if the "ORGANIZER" property is present.</t>
        </list>
        <?rfc compact="yes" ?>
        </t>
      </section>
      <section title="Additional Preconditions for PUT">
        <t>This specification requires additional Preconditions for the PUT method. The preconditions are:
        <?rfc compact="no" ?>
        <list>
            <t>(CALDAV:allowed-organizer-scheduling-object-change): The following restrictions exist for the "PARTSTAT" property value in scheduling object resources created or modified by an "Organizer":
                <list style="numbers">
                    <t>when creating a scheduling object resource the "Organizer" MUST NOT set the "PARTSTAT" iCalendar parameter value to anything other than "NEEDS-ACTION" if the corresponding "ATTENDEE" property includes the "SCHEDULE-AGENT" iCalendar parameter with its value set to "SERVER".</t>
                    <t>when modifying a scheduling object resource the "Organizer" MUST NOT change the "PARTSTAT" iCalendar parameter value to anything other than "NEEDS-ACTION" if the corresponding "ATTENDEE" property includes the "SCHEDULE-AGENT" iCalendar parameter with its value set to "SERVER".</t>
                </list>
            </t>
            <t>(CALDAV:allowed-attendee-scheduling-object-change): When creating or modifying a scheduling object resource in a scheduling calendar collection, the "Attendee" can only make the following changes:
                <list style="numbers">
                    <t>any iCalendar parameter on any "ATTENDEE" property whose value corresponds to the calendar user address of the "Attendee"</t>
                    <t>add, change or remove a "TRANSP" property in any component</t>
                    <t>add, change or remove a "COMMENT" property in any component</t>
                    <t>add, change or remove a "PERCENT-COMPLETE" property in any component</t>
                    <t>add, change or remove the "PRODID" property in the top-level "VCALENDAR" component</t>
                    <t>add, change or remove the "CALSCALE" property in the top-level "VCALENDAR" component</t>
                    <t>add, change or remove any "VALARM" components</t>
                    <t>create overridden recurring instances with only changes as detailed above</t>
                </list>
                The "Attendee" MUST NOT make any other type of change.
          </t>
        </list>
        <?rfc compact="yes" ?>
        </t>
      </section>
      <section title="Additional Precondition for PROPPATCH">
        <t>This specification requires an additional Precondition for the property response elements in PROPPATCH method response. The precondition is:
        <?rfc compact="no" ?>
        <list>
            <t>(CALDAV:valid-schedule-default-calendar-URL): When the server allows the client to change the CALDAV:schedule-default-calendar-URL property on a scheduling Inbox collection, the URL specified in any DAV:href element MUST reference a scheduling calendar collection owned by the owner of the scheduling Inbox collection.</t>
        </list>
        <?rfc compact="yes" ?>
        </t>
      </section>
    </section>
    <section anchor="scheduling" title="Scheduling">
      <section anchor="schedule" title="POST Method">
        <t>The POST method submits a scheduling or freebusy message to one or more recipients by targeting the request at the URI of a scheduling Outbox collection. The request body of a POST method MUST contain a scheduling message or freebusy message (e.g., an iCalendar object that follows the iTIP semantic). The resource identified by the Request-URI MUST be a resource collection of type <xref target="schedule-outbox">CALDAV:schedule-outbox</xref>.</t>
        <t>Only specific types of scheduling message are allowed in a POST request on a scheduling Outbox collection:</t>
        <texttable>
          <ttcol>iTIP METHOD</ttcol>
          <ttcol>COMPONENT</ttcol>
          <c>PUBLISH</c>
          <c>None</c>
          <c>REQUEST</c>
          <c>VFREEBUSY</c>
          <c>REPLY</c>
          <c>None</c>
          <c>ADD</c>
          <c>None</c>
          <c>CANCEL</c>
          <c>None</c>
          <c>REFRESH</c>
          <c>Any except VTIMEZONE, VFREEBUSY</c>
          <c>COUNTER</c>
          <c>None</c>
          <c>DECLINECOUNTER</c>
          <c>None</c>
        </texttable>
        <t>Servers SHOULD reject any scheduling message that is not allowed. However, for backwards compatibility with earlier version of this specification, servers MAY return a valid schedule response result indicating success for the iTIP operation being executed.</t>
        <t>Preconditions:
        <?rfc compact="no" ?>
        <list>
            <t>(CALDAV:supported-collection): The Request-URI MUST identify the location of a scheduling Outbox collection;</t>
            <t>(CALDAV:supported-calendar-data): The resource submitted in the POST request MUST be a supported media type (e.g., "text/calendar") for scheduling or freebusy messages;</t>
            <t>(CALDAV:valid-calendar-data): The resource submitted in the POST request MUST be valid data for the media type being specified (e.g., valid iCalendar object);</t>
            <t>(CALDAV:valid-scheduling-message): The resource submitted in the POST request MUST obey all restrictions specified for the POST request (e.g., the scheduling message follows the restrictions of iTIP);</t>
            <t>(CALDAV:originator-allowed): The currently authenticated user MUST be granted the CALDAV:schedule-deliver privilege or a suitable sub-privilege on the scheduling Outbox collection being targeted by the request;</t>
            <t>(CALDAV:organizer-allowed): The calendar user identified by the "ORGANIZER"
 property in the POST request's scheduling message MUST be the calendar user (or one of the calendar users) associated with the scheduling Outbox collection being targeted by the request when the scheduling message is an outgoing scheduling message;</t>
            <t>(CALDAV:max-resource-size): The resource submitted in the POST request MUST have an octet size less than or equal to the value of the CALDAV:max-resource-size property value <xref target="RFC4791"/>on the scheduling Outbox collection targeted by the request;</t>
            <t>(CALDAV:attachments-allowed): The resource submitted in the POST request MUST NOT contain any inline ATTACH properties;</t>
        </list>
        <?rfc compact="yes" ?>
        </t>
        <t>Postconditions: None</t>
        <section title="Handling a REFRESH">
          <t>When an iTIP REFRESH scheduling message is executed, the server delivers the scheduling message to the calendar user specified by the "ORGANIZER"
 property value in the scheduling object resource that was POST'ed.</t>
        </section>
        <section anchor="schedule-response" title="Response to a POST request">
          <t>A POST request may deliver a scheduling message to one or more calendar user recipients. Since the behavior of each recipient may vary, it is useful to get response status information for each recipient in the overall POST response. This specification defines a new XML response to convey multiple recipient status.</t>
          <t>A response to a POST method that indicates status for one or more recipients MUST be a CALDAV:schedule-response XML element. This MUST contain one or more CALDAV:response elements for each recipient, with each of those containing elements that indicate which recipient they correspond to, the scheduling status of the request for that recipient, any error codes and an optional description. See <xref target="schedule_response_element"/>.</t>
          <t>In the case of a freebusy request, the CALDAV:response elements can also contain CALDAV:calendar-data elements which contain freebusy information (e.g., an iCalendar VFREEBUSY component) indicating the busy state of the corresponding recipient, assuming that the freebusy request for that recipient succeeded.</t>
        </section>
        <section anchor="post-status-codes" title="Status Codes for use with the POST method">
          <t>The following are examples of response codes one would expect to be used for this method. Note, however, that unless explicitly prohibited any 2/3/4/5xx series response code may be used in a response.</t>
          <t>
<?rfc compact="no" ?>
            <list>
              <t>200 (OK) - The command succeeded.</t>
              <t>201 (Created) - The command succeeded and a new resource was created in the scheduling Outbox collection.</t>
              <t>400 (Bad Request) - The client has provided an invalid scheduling message.</t>
              <t>403 (Forbidden) - The client cannot submit a scheduling message to the specified Request-URI.</t>
              <t>404 (Not Found) - The URL in the Request-URI was not present.</t>
              <t>423 (Locked) - The specified resource is locked and the client either is not a lock owner or the lock type requires a lock token to be submitted and the client did not submit it.</t>
              <t>507 (Insufficient Storage) - The server did not have sufficient space to record the scheduling message in a scheduling Outbox collection being targeted by the POST request.</t>
            </list>
<?rfc compact="yes" ?>
          </t>
        </section>
<!-- post-status-codes -->
        <section anchor="schedule-example" title="Example - Simple meeting invitation refresh">
          <figure>
            <preamble>&gt;&gt; Request &lt;&lt;</preamble>
            <artwork><![CDATA[
POST /bernard/calendar/outbox/ HTTP/1.1
Host: cal.example.com
Content-Type: text/calendar
Content-Length: xxxx

BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Example Corp.//CalDAV Client//EN
METHOD:REFRESH
BEGIN:VEVENT
UID:43777-876@example.com
DTSTAMP:20040901T200200Z
ORGANIZER:mailto:lisa@example.com
ATTENDEE;PARTSTAT=NEEDS-ACTION;RSVP=TRUE;ROLE=RE
 Q-PARTICIPANT;CUTYPE=INDIVIDUAL;CN=Bernard Desr
 uisseaux:mailto:bernard@example.com
END:VEVENT
END:VCALENDAR
]]></artwork>
          </figure>
          <figure>
            <preamble>&gt;&gt; Response &lt;&lt;</preamble>
            <artwork><![CDATA[
HTTP/1.1 200 OK
Date: Thu, 02 Sep 2004 16:53:32 GMT
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<C:schedule-response xmlns:D="DAV:"
             xmlns:C="urn:ietf:params:xml:ns:caldav">
<C:response>
  <C:recipient>mailto:lisa@example.com</C:recipient>
  <C:request-status>2.0;Success</C:request-status>
  <D:responsedescription>Delivered to recipient
  scheduling inbox</D:responsedescription>
</C:response>
</C:schedule-response>
]]></artwork>
          </figure>
          <t>In this example, the client requests the server to deliver a "REFRESH" scheduling message to the "Organizer" of the meeting mailto:lisa@example.com. The response indicates that delivery to the relevant scheduling Inbox collection of the "Organizer" was accomplished successfully.</t>
        </section>
<!-- schedule-example -->
        <section anchor="schedule-fb-example" title="Example - Freebusy lookup">
          <figure>
            <preamble>&gt;&gt; Request &lt;&lt;</preamble>
            <artwork><![CDATA[
POST /lisa/calendar/outbox/ HTTP/1.1
Host: cal.example.com
Content-Type: text/calendar
Content-Length: xxxx

BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Example Corp.//CalDAV Client//EN
METHOD:REQUEST
BEGIN:VFREEBUSY
DTSTAMP:20040901T200200Z
ORGANIZER:mailto:lisa@example.com
DTSTART:20040902T000000Z
DTEND:20040903T000000Z
UID:34222-232@example.com
ATTENDEE;CN=Bernard Desruisseaux:mailto:bernard@
 example.com
ATTENDEE;CN=Cyrus Daboo:mailto:cyrus@example.com
END:VFREEBUSY
END:VCALENDAR
]]></artwork>
          </figure>
          <figure>
            <preamble>&gt;&gt; Response &lt;&lt;</preamble>
            <artwork><![CDATA[
HTTP/1.1 200 OK
Date: Thu, 02 Sep 2004 16:53:32 GMT
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<C:schedule-response xmlns:D="DAV:"
             xmlns:C="urn:ietf:params:xml:ns:caldav">
<C:response>
  <C:recipient>mailto:bernard@example.com</C:recipient>
  <C:request-status>2.0;Success</C:request-status>
  <C:calendar-data>BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Example Corp.//CalDAV Server//EN
METHOD:REPLY
BEGIN:VFREEBUSY
DTSTAMP:20040901T200200Z
ORGANIZER:mailto:lisa@example.com
DTSTART:20040902T000000Z
DTEND:20040903T000000Z
UID:34222-232@example.com
ATTENDEE;CN=Bernard Desruisseaux:mailto:bernard@
 example.com
FREEBUSY;FBTYPE=BUSY-UNAVAILABLE:20040902T000000Z/
 20040902T090000Z,20040902T170000Z/20040903T000000Z
END:VFREEBUSY
END:VCALENDAR
</C:calendar-data>
</C:response>
<C:response>
  <C:recipient>mailto:cyrus@example.com</C:recipient>
  <C:request-status>2.0;Success</C:request-status>
  <C:calendar-data>BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Example Corp.//CalDAV Server//EN
METHOD:REPLY
BEGIN:VFREEBUSY
DTSTAMP:20040901T200200Z
ORGANIZER:mailto:lisa@example.com
DTSTART:20040902T000000Z
DTEND:20040903T000000Z
UID:34222-232@example.com
ATTENDEE;CN=Cyrus Daboo:mailto:cyrus@example.com
FREEBUSY;FBTYPE=BUSY-UNAVAILABLE:20040902T000000Z/
 20040902T090000Z,20040902T170000Z/20040903T000000Z
FREEBUSY;FBTYPE=BUSY:20040902T120000Z/20040902T130000Z
END:VFREEBUSY
END:VCALENDAR
</C:calendar-data>
</C:response>
</C:schedule-response>
]]></artwork>
          </figure>
          <t>In this example, the client requests the server to determine the busy information of the calendar users mailto:bernard@example.com and mailto:cyrus@example.com, over the time range specified by the scheduling message sent in the request. The response includes "VFREEBUSY" components for each of those calendar users with their busy time indicated.</t>
        </section>
      </section>
      <section anchor="schedule-incoming" title="Retrieving incoming scheduling messages">
        <t>Incoming scheduling messages will be stored in a scheduling Inbox collection. As per <xref target="reports"/>, CalDAV "calendar-access" reports work on scheduling collections, so the client can use those to get partial information on scheduling messages in the scheduling Inbox collection.</t>
      </section>
    </section>
<!-- http.headers -->
    <section title="Scheduling Access Control">
      <section title="Scheduling Privileges" anchor="privileges">
        <t>
          CalDAV servers MUST support and adhere to the requirements of
          <xref target="RFC3744">WebDAV ACL</xref>. Furthermore, CalDAV
          servers that advertise support for the "calendar-auto-schedule"
          feature MUST also support the scheduling privileges defined in
          this section.
        </t>
        <t>
          All the scheduling privileges MUST be non-abstract and
          MUST appear in the DAV:supported-privilege-set property
          of scheduling Outbox and Inbox collections on which they are defined.
        </t>
        <t>
          The tables specified in <xref target="privilege_summary"/> clarifies which scheduling methods (e.g., "REQUEST" "REPLY" etc.) are controlled by each scheduling privilege defined in this section.
        </t>
		<section title="Privileges on Scheduling Inbox Collections">
			<t>This section defines new WebDAV ACL privileges that are for use on scheduling Inbox collections. These privileges determine whether a calendar user is allowed to have scheduling messages delivered to the calendar user who "owns" the scheduling Inbox collection. This allows calendar users to choose which other calendar users can schedule with them.</t>
			<t>The privileges defined in this section are ignored if applied to a resource other than a scheduling Inbox collection.</t>

        <section title="CALDAV:schedule-deliver Privilege"
                 anchor="PRIVILEGE_schedule-deliver">
          <t>
            CALDAV:schedule-deliver is an aggregate privilege that
            contains all the scheduling privileges that control
            the processing and delivery of incoming scheduling
            messages, that is, CALDAV:schedule-deliver-invite and
            CALDAV:schedule-deliver-reply, as well as freebusy requests
            targeted at the owner of the scheduling Inbox collection,
            that is, CALDAV:schedule-query-freebusy.
          </t>
          <t>
            <![CDATA[<!ELEMENT schedule-deliver EMPTY >]]>
          </t>
        </section>

        <section title="CALDAV:schedule-deliver-invite Privilege"
                 anchor="PRIVILEGE_schedule-deliver-invite">
          <t>
            The CALDAV:schedule-deliver-invite privilege controls the
            processing and delivery of scheduling messages coming from
            an "Organizer".
          </t>
          <t>
            <![CDATA[<!ELEMENT schedule-deliver-invite EMPTY >]]>
          </t>
        </section>

        <section title="CALDAV:schedule-deliver-reply Privilege"
                 anchor="PRIVILEGE_schedule-deliver-reply">
          <t>
            The CALDAV:schedule-deliver-reply privilege controls the
            processing and delivery of scheduling messages coming from
            an "Attendee".
          </t>
          <t>
            <![CDATA[<!ELEMENT schedule-deliver-reply EMPTY >]]>
          </t>
        </section>

        <section title="CALDAV:schedule-query-freebusy Privilege"
                 anchor="PRIVILEGE_schedule-query-freebusy">
          <t>
            The CALDAV:schedule-query-freebusy privilege controls
            freebusy requests targeted at the owner of the
            scheduling Inbox collection.
          </t>
          <t>
            <![CDATA[<!ELEMENT schedule-query-freebusy EMPTY >]]>
          </t>
        </section>
    	</section>

		<section title="Privileges on Scheduling Outbox Collections">
			<t>This section defines new WebDAV ACL privileges that are defined for use on scheduling Outbox collections. These privileges determine which calendar users are allowed to send scheduling messages on behalf of the calendar user who "owns" the scheduling Outbox collection. This allows calendar users to choose other calendar users who can act on their behalf to schedule with other calendar users (e.g., assistants working on behalf of their boss).</t>
			<t>The privileges defined in this section are ignored if applied to a resource other than a scheduling Outbox collection.</t>

        <section title="CALDAV:schedule-send Privilege"
                 anchor="PRIVILEGE_schedule-send">
          <t>
            CALDAV:schedule-send is an aggregate privilege that contains
            all the scheduling privileges that control the use of
            methods that will cause scheduling messages to be delivered
            to other users, that is, CALDAV-schedule-send-invite
            and CALDAV-schedule-send-reply, as well as freebusy
            requests to be targeted at other users, that is,
            CALDAV-schedule-send-freebusy.
          </t>
          <t>
            <![CDATA[<!ELEMENT schedule-send EMPTY >]]>
          </t>
        </section>

        <section title="CALDAV:schedule-send-invite Privilege"
                 anchor="PRIVILEGE_schedule-send-invite">
          <t>
            The CALDAV:schedule-send-invite privilege controls the sending of
 			scheduling messages by "Organizers".
          </t>
          <t>
            Users granted the DAV:bind privilege on a scheduling calendar
            collection, or DAV:write privilege on scheduling object
            resources, will also need the CALDAV:schedule-send-invite
            privilege granted on the scheduling Outbox collection of the
            owner of the scheduling calendar collection or scheduling
            object resource in order to be allowed to create, modify
            or delete scheduling object resources in a way that will
            trigger the CalDAV server to deliver organizer scheduling
            messages to other calendar users.
          </t>
          <t>
            <![CDATA[<!ELEMENT schedule-send-invite EMPTY >]]>
          </t>
        </section>

        <section title="CALDAV:schedule-send-reply Privilege"
                 anchor="PRIVILEGE_schedule-send-reply">
          <t>
            The CALDAV:schedule-send-invite privilege controls the sending of
 			scheduling messages by "Attendees".
          </t>
          <t>
            Users granted the DAV:bind privilege on a scheduling calendar
            collection, or DAV:write privilege on scheduling object
            resources, will also need the CALDAV:schedule-send-reply
            privilege granted on the scheduling Outbox collection of the
            owner of the scheduling calendar collection or scheduling
            object resource in order to be allowed to create, modify or
            delete scheduling object resources in a way that will trigger
            the CalDAV server to deliver attendee scheduling messages to
            other calendar users.
          </t>
          <t>
            <![CDATA[<!ELEMENT schedule-send-reply EMPTY >]]>
          </t>
        </section>

        <section title="CALDAV:schedule-send-freebusy Privilege"
                 anchor="PRIVILEGE_schedule-send-freebusy">
          <t>
            The CALDAV:schedule-send-freebusy privilege controls the use of
            the POST method to submit scheduling messages that specify the
            scheduling method "REQUEST" with a "VFREEBUSY" calendar component.
          </t>
          <t>
            <![CDATA[<!ELEMENT schedule-send-freebusy EMPTY >]]>
          </t>
        </section>
		</section>

        <section title="Aggregation of Scheduling Privileges">
          <t>
            Server implementations MUST aggregate the scheduling
            privileges as follows:
            <?rfc compact="no"?>
            <list>
              <t>
                DAV:all MUST contain CALDAV:schedule-send and
                CALDAV:schedule-deliver;
              </t>
              <t>
                CALDAV:schedule-send MUST contain
                CALDAV:schedule-send-invite,
                CALDAV:schedule-send-reply, and
                CALDAV:schedule-send-freebusy;
              </t>
              <t>
                CALDAV:schedule-deliver MUST contain
                CALDAV:schedule-deliver-invite,
                CALDAV:schedule-deliver-reply, and
                CALDAV:schedule-query-freebusy.
              </t>
            </list>
            <?rfc compact="yes"?>
          </t>
          <t>
            The following diagram illustrates how scheduling privileges
            are aggregated according to the above requirements.
            <figure>
              <artwork><![CDATA[
      [DAV:all] (aggregate)
          |
          +-- [CALDAV:schedule-deliver] (aggregate)
          |      |
          |      +-- [CALDAV:schedule-deliver-invite]
          |      +-- [CALDAV:schedule-deliver-reply]
          |      +-- [CALDAV:schedule-query-freebusy]
          |
          +-- [CALDAV:schedule-send] (aggregate)
                 |
                 +-- [CALDAV:schedule-send-invite]
                 +-- [CALDAV:schedule-send-reply]
                 +-- [CALDAV:schedule-send-freebusy]
]]></artwork>
            </figure>
          </t>
        </section>
      </section>
<!-- privileges -->
      <section anchor="principal.properties" title="Additional Principal Properties">
        <t>This section defines new properties for WebDAV principal resources as defined in <xref target="RFC3744">RFC3744</xref>. These properties are likely to be protected but the server MAY allow them to be written by appropriate users.</t>
        <section anchor="PROPERTY_schedule-inbox-URL" title="CALDAV:schedule-inbox-URL Property">
          <t>
<?rfc compact="no" ?>
            <list style="hanging">
              <t hangText="Name:">schedule-inbox-URL</t>
              <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
              <t hangText="Purpose:">Identify the URL of the scheduling Inbox collection owned by the associated principal resource.</t>
              <t hangText="Conformance:">This property MAY be protected and SHOULD NOT be returned by a PROPFIND allprop request (as defined in Section 14.2 of <xref target="RFC4918">WebDAV</xref>).</t>
              <t hangText="Description:">This property is needed for a client to determine where the scheduling Inbox collection of the current user is located so that processing of scheduling messages can occur.</t>
              <t hangText="Definition:">
                <figure>
                  <artwork><![CDATA[
   <!ELEMENT schedule-inbox-URL (DAV:href)>
                    ]]></artwork>
                </figure>
              </t>
            </list>
<?rfc compact="yes" ?>
          </t>
        </section>
<!-- PROPERTY_schedule-inbox-URL -->
        <section anchor="PROPERTY_schedule-outbox-URL" title="CALDAV:schedule-outbox-URL Property">
          <t>
<?rfc compact="no" ?>
            <list style="hanging">
              <t hangText="Name:">schedule-outbox-URL</t>
              <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
              <t hangText="Purpose:">Identify the URL of the scheduling Outbox collection owned by the associated principal resource.</t>
              <t hangText="Conformance:">This property MAY be protected and SHOULD NOT be returned by a PROPFIND allprop request (as defined in Section 14.2 of <xref target="RFC4918">WebDAV</xref>).</t>
              <t hangText="Description:">This property is needed for a client to determine where the scheduling Outbox collection of the current user is located so that sending of scheduling messages can occur.</t>
              <t hangText="Definition:">
                <figure>
                  <artwork><![CDATA[
   <!ELEMENT schedule-outbox-URL DAV:href>
                    ]]></artwork>
                </figure>
              </t>
            </list>
<?rfc compact="yes" ?>
          </t>
        </section>
<!-- PROPERTY_schedule-outbox-URL -->
        <section anchor="PROPERTY_calendar-user-address-set" title="CALDAV:calendar-user-address-set Property">
          <t>
<?rfc compact="no" ?>
            <list style="hanging">
              <t hangText="Name:">calendar-user-address-set</t>
              <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
              <t hangText="Purpose:">Identify the calendar addresses of the associated principal resource.</t>
              <t hangText="Conformance:">This property MAY be protected and SHOULD NOT be returned by a PROPFIND allprop request (as defined in Section 14.2 of <xref target="RFC4918">WebDAV</xref>). Support for this property is REQUIRED. This property SHOULD be searchable using the DAV:principal-property-search REPORT. The DAV:principal-search-property-set REPORT SHOULD identify this property as such.</t>
              <t hangText="Description:">This property is needed to map calendar user addresses in iCalendar data to principal resources and their associated scheduling Inbox and Outbox collections. In the event that a user has no well defined identifier for their calendar user address, the URI of their principal resource can be used.</t>
              <t hangText="Definition:">
                <figure>
                  <artwork><![CDATA[
   <!ELEMENT calendar-user-address-set (DAV:href*)>
                    ]]></artwork>
                </figure>
              </t>
              <t hangText="Example:">
                <figure>
                  <artwork><![CDATA[
   <C:calendar-user-address-set xmlns:D="DAV:"
                         xmlns:C="urn:ietf:params:xml:ns:caldav">
     <D:href>mailto:bernard@example.com</D:href>
     <D:href>mailto:bernard.desruisseaux@example.com</D:href>
   </C:calendar-user-address-set>
]]></artwork>
                </figure>
              </t>
            </list>
<?rfc compact="yes" ?>
          </t>
        </section>
<!-- PROPERTY_calendar-user-address-set -->
        <section anchor="PROPERTY_calendar-user-type" title="CALDAV:calendar-user-type Property">
          <t>
<?rfc compact="no" ?>
            <list style="hanging">
              <t hangText="Name:">calendar-user-type</t>
              <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
              <t hangText="Purpose:">Identifies the calendar user type of the associated principal resource.</t>
              <t hangText="Conformance:">This property MAY be protected and SHOULD NOT be returned by a PROPFIND allprop request (as defined in Section 14.2 of <xref target="RFC4918">WebDAV</xref>). Support for this property is OPTIONAL. This property SHOULD be searchable using the DAV:principal-property-search REPORT. The DAV:principal-search-property-set REPORT SHOULD identify this property as such.</t>
              <t hangText="Description:">This property is used to indicate the type of calendar user associated with the principal resource. Its value is the same as the iCalendar "CUTYPE" property parameter that can be used on "ATTENDEE" properties.</t>
              <t hangText="Definition:">
                <figure>
                  <artwork><![CDATA[
   <!ELEMENT calendar-user-type #PCDATA>
   <!-- The supported values are those defined in iCalendar [RFC2445]
        Section 4.2.3 for the "CUTYPE" -->
                    ]]></artwork>
                </figure>
              </t>
              <t hangText="Example:">
                <figure>
                  <artwork><![CDATA[
   <C:calendar-user-type
        xmlns:C="urn:ietf:params:xml:ns:caldav">INDIVIDUAL<
    /C:calendar-user-type>
]]></artwork>
                </figure>
              </t>
            </list>
<?rfc compact="yes" ?>
          </t>
      </section>
<!-- principal.properties -->
    </section>
<!-- Scheduling Access Control -->
    </section>
<!-- Calendaring Reports -->
    <section anchor="reports" title="Reports">
      <t>This specification extends the CALDAV:calendar-query and CALDAV:calendar-multiget reports to return results for calendar object resources in scheduling Inbox collections when the report directly targets such a collection, i.e., the Request-URI for a REPORT MUST be the URI of the scheduling Inbox collection or of a child resource within a scheduling Inbox collection. A report run on a regular collection that includes a scheduling Inbox collection as a child resource at any depth MUST NOT examine or return any calendar object resources from within any scheduling Inbox collections.</t>
	  <t>When a CALDAV:calendar-query REPORT includes a time-range query and targets a scheduling Inbox collection, if any calendar object resources contain "VEVENT" calendar components that do not include a "DTSTART" iCalendar property (as allowed by <xref target="RFC2446">iTIP</xref>) then such components MUST always match the time-range query test.</t>
      <t>Note that the CALDAV:free-busy-query report is NOT supported on scheduling Inbox collections.</t>
    </section>
    <section title="XML Element Definitions">
      <section anchor="schedule_response_element" title="CALDAV:schedule-response XML Element">
        <t>
<?rfc compact="no" ?>
          <list style="hanging">
            <t hangText="Name:">schedule-response</t>
            <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
            <t hangText="Purpose:">Contains the set of responses for a POST method request.</t>
            <t hangText="Description:">See <xref target="schedule-response"/>.</t>
            <t hangText="Definition:">
              <figure>
                <artwork><![CDATA[
    <!ELEMENT schedule-response (response*)>
]]></artwork>
              </figure>
            </t>
          </list>
<?rfc compact="yes" ?>
        </t>
      </section>
      <section anchor="response_element" title="CALDAV:response XML Element">
        <t>
<?rfc compact="no" ?>
          <list style="hanging">
            <t hangText="Name:">response</t>
            <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
            <t hangText="Purpose:">Contains a single response for a POST method request.</t>
            <t hangText="Description:">See <xref target="schedule-response"/>.</t>
            <t hangText="Definition:">
              <figure>
                <artwork><![CDATA[
<!ELEMENT response (recipient,
                    request-status,
                    calendar-data?,
                    DAV:error?,
                    DAV:responsedescription?)>
]]></artwork>
              </figure>
            </t>
          </list>
<?rfc compact="no" ?>
        </t>
      </section>
      <section anchor="recipient_element" title="CALDAV:recipient XML Element">
        <t>
<?rfc compact="no" ?>
          <list style="hanging">
            <t hangText="Name:">recipient</t>
            <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
            <t hangText="Purpose:">The calendar user address (recipient header value) that the enclosing response for a POST method request is for.</t>
            <t hangText="Description:">See <xref target="schedule-response"/>.</t>
            <t hangText="Definition:">
              <figure>
                <artwork><![CDATA[
    <!ELEMENT recipient (DAV:href)>
            ]]></artwork>
              </figure>
            </t>
          </list>
<?rfc compact="yes" ?>
        </t>
      </section>
      <section anchor="response_status_element" title="CALDAV:request-status XML Element">
        <t>
<?rfc compact="no" ?>
          <list style="hanging">
            <t hangText="Name:">request-status</t>
            <t hangText="Namespace:">urn:ietf:params:xml:ns:caldav</t>
            <t hangText="Purpose:">The iTIP "REQUEST-STATUS" property value for this response.</t>
            <t hangText="Description:">See <xref target="schedule-response"/>.</t>
            <t hangText="Definition:">
              <figure>
                <artwork><![CDATA[
    <!ELEMENT request-status #PCDATA>
            ]]></artwork>
              </figure>
            </t>
          </list>
<?rfc compact="yes" ?>
        </t>
      </section>
    </section>
    <section title="Security Considerations">
      <t>The process of scheduling involves the sending and receiving of scheduling messages. As a result, the security problems related to messaging in general are relevant here. In particular the authenticity of the scheduling messages needs to be verified absolutely. Servers and clients MUST use an HTTP connection protected with TLS as defined in <xref target="RFC2818"/> for all scheduling transactions.</t>
      <section title="Verifying scheduling requests">
                <t>When handling an implicit scheduling operation:</t>
        <?rfc compact="no" ?>
                <t>
                  <list>
                    <t>Servers MUST verify that the currently authenticated user has the CALDAV:schedule-deliver privilege or a suitable sub-privilege on the scheduling Outbox collection of the DAV:owner of the scheduling calendar collection in which a scheduling object resource is being manipulated.</t>
                    <t>Servers MUST verify that the principal associated with the DAV:owner of the scheduling calendar collection in which a scheduling object resource is being manipulated contains a CALDAV:schedule-outbox-URL property value.</t>
                    <t>Servers MUST only deliver scheduling messages to recipients when the principal associated with the DAV:owner of the scheduling calendar collection in which a scheduling object resource is being manipulated has the CALDAV:schedule privilege or a suitable sub-privilege on the scheduling Inbox collections for recipient.</t>
                    <t>To prevent impersonation of calendar users, the server MUST verify that the "ORGANIZER" property in an organizer scheduling object resource matches one of the calendar user addresses of the DAV:owner of the schedule calendar collection in which the resource is stored.</t>
                    <t>To prevent spoofing of an existing scheduling object resource, servers MUST verify that the "UID" iCalendar property value in a new scheduling object resource does not match that of an existing scheduling object resource with a different "ORGANIZER" property value.</t>
                  </list>
                </t>
        <?rfc compact="yes" ?>
                <t>When handling a POST request on a scheduling Outbox collection:</t>
        <?rfc compact="no" ?>
                <t>
                  <list>
                    <t>Servers MUST verify that the currently authenticated user has the CALDAV:schedule-deliver privilege or a suitable sub-privilege on the scheduling Outbox collection targeted by the request.</t>
                    <t>Servers MUST verify that the principal associated with the calendar user address specified in the "ORGANIZER" property of the scheduling message data in the request contains a CALDAV:schedule-outbox-URL property value that matches the scheduling Outbox collection targeted by the request.</t>
                    <t>Servers MUST verify that the principal associated with the calendar user address specified in the "ORGANIZER" property of the scheduling message data in the request has the CALDAV:schedule privilege or a suitable sub-privilege on all of the scheduling Inbox collections for those recipients to whom a scheduling message is being delivered.</t>
                  </list>
                </t>
        <?rfc compact="yes" ?>
      </section>
    </section>
    <section title="IANA Consideration" anchor="IANA">
        <section title="HTTP header registration">
            <t>This specification registers one new header for use with HTTP as per <xref target="RFC3864"/>.</t>
            <section title="Schedule-Reply Request Header Registration" anchor="iana_schedule_reply">
                <t>Header field name: Schedule-Reply</t>

                <t>Applicable protocol: http</t>

                <t>Status: standard</t>

                <t>Author/Change controller: IETF</t>

                <t>Specification document(s): this specification</t>

                <t>Related information: none</t>
            </section>
        </section>
        <section title="iCalendar Registrations">
          <t>This specification registers two new iCalendar property parameters as defined in <xref target="new-icalendar"/>.</t>
        </section>
    </section>
<!-- IANA -->
    <section title="Acknowledgements">
      <t>The authors would like to thank the following individuals for contributing their ideas and support for writing this specification: Mike Douglass, Lisa Dusseault, Arnaud Quillaud, Julian F. Reschke, Wilfredo Sanchez Vega, Simon Vaillancourt, and Jim Whitehead.</t>
      <t>The authors would also like to thank the Calendaring and Scheduling Consortium for advice with this specification, and for organizing interoperability testing events to help refine it.</t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
    &rfc2119;
    &rfc2445;
    &rfc2446;
    &rfc2616;
    &rfc2818;
    &rfc3744;
    &rfc3864;
    &rfc4791;
    &rfc4918;
    &W3C.REC-xml-20060816;
    </references>
    <references title="Informative References">
    &rfc2447;
    </references>
        <section title="Scheduling Privileges Summary" anchor="privilege_summary">
          <section title="Scheduling Inbox Privileges">
            <t>The following tables specify which scheduling privileges grant the right to a calendar user to deliver a scheduling message to the scheduling Inbox collection of another calendar user. The appropriate behavior depends on the calendar component type in the scheduling message and the scheduling "METHOD" in use.</t>
            <figure>
              <artwork><![CDATA[
                                  +-----------------------+
                                  |   METHOD for VEVENT   |
                                  +---+---+---+---+---+---+
                                  | P | R | R | A | C | R |
                                  | U | E | E | D | A | E |
                                  | B | Q | P | D | N | F |
                                  | L | U | L |   | C | R |
                                  | I | E | Y |   | E | E |
    +----------------------------+| S | S |   |   | L | S |
    | Scheduling Inbox Privilege || H | T |   |   |   | H |
    +============================++===+===+===+===+===+===+
    | schedule-deliver           || * | * | * | * | * | * |
    |   schedule-deliver-invite  || * | * |   | * | * |   |
    |   schedule-deliver-reply   ||   |   | * |   |   | * |
    |   schedule-query-freebusy  ||   |   |   |   |   |   |
    +----------------------------++---+---+---+---+---+---+
    ]]></artwork>
            </figure>
            <figure>
              <artwork><![CDATA[
                                  +-----------------------+
                                  |   METHOD for VTODO    |
                                  +---+---+---+---+---+---+
                                  | P | R | R | A | C | R |
                                  | U | E | E | D | A | E |
                                  | B | Q | P | D | N | F |
                                  | L | U | L |   | C | R |
                                  | I | E | Y |   | E | E |
    +----------------------------+| S | S |   |   | L | S |
    | Scheduling Inbox Privilege || H | T |   |   |   | H |
    +============================++===+===+===+===+===+===+
    | schedule-deliver           || * | * | * | * | * | * |
    |   schedule-deliver-invite  || * | * |   | * | * |   |
    |   schedule-deliver-reply   ||   |   | * |   |   | * |
    |   schedule-query-freebusy  ||   |   |   |   |   |   |
    +----------------------------++---+---+---+---+---+---+
    ]]></artwork>
            </figure>
            <figure>
              <artwork><![CDATA[
                                  +-----------------------+
                                  |  METHOD for VJOURNAL  |
                                  +-------+-------+-------+
                                  |   P   |   A   |   C   | 
                                  |   U   |   D   |   A   | 
                                  |   B   |   D   |   N   | 
                                  |   L   |       |   C   | 
                                  |   I   |       |   E   | 
    +----------------------------+|   S   |       |   L   | 
    | Scheduling Inbox Privilege ||   H   |       |       | 
    +============================++=======+=======+=======+
    | schedule-deliver           ||   *   |   *   |   *   | 
    |   schedule-deliver-invite  ||   *   |   *   |   *   | 
    |   schedule-deliver-reply   ||       |       |       | 
    |   schedule-query-freebusy  ||       |       |       | 
    +----------------------------++-------+-------+-------+
    ]]></artwork>
            </figure>
            <figure>
              <artwork><![CDATA[
                                  +---------------+
                                  |  METHOD for   |
                                  |   VFREEBUSY   |
                                  +-------+-------+
                                  |   P   |   R   |
                                  |   U   |   E   |
                                  |   B   |   Q   |
                                  |   L   |   U   |
                                  |   I   |   E   |
    +----------------------------+|   S   |   S   |
    | Scheduling Inbox Privilege ||   H   |   T   |
    +============================++=======+=======+
    | schedule-deliver           ||   *   |   *   |
    |   schedule-deliver-invite  ||   *   |       |
    |   schedule-deliver-reply   ||       |       |
    |   schedule-query-freebusy  ||       |   *   |
    +----------------------------++-------+-------+
    ]]></artwork>
            </figure>
          </section>
          <section title="Scheduling Outbox Privileges">
            <t>The following tables specify which scheduling privileges grant the right to a calendar user to submit a scheduling message to another calendar user, either as the result of an explicit scheduling request or an automatic scheduling transaction. The appropriate behavior depends on the calendar component type in the scheduling message and the scheduling "METHOD" in use.</t>
            <figure>
              <artwork><![CDATA[
                                   +-------------------+
                                   | METHOD for VEVENT |
                                   +---+---+---+---+---+
                                   | R | R | A | C | R |
                                   | E | E | D | A | E |
                                   | Q | P | D | N | F |
                                   | U | L |   | C | R |
                                   | E | Y |   | E | E |
    +-----------------------------+| S |   |   | L | S |
    | Scheduling Outbox Privilege || T |   |   |   | H |
    +=============================++===+===+===+===+===+
    | schedule-send               || * | * | * | * | * |
    |   schedule-send-invite      || * |   | * | * |   |
    |   schedule-send-reply       ||   | * |   |   | * |
    |   schedule-send-freebusy    ||   |   |   |   |   |
    +-----------------------------++---+---+---+---+---+
    ]]></artwork>
            </figure>
            <figure>
              <artwork><![CDATA[
                                   +-------------------+
                                   | METHOD for VTODO  |
                                   +---+---+---+---+---+
                                   | R | R | A | C | R |
                                   | E | E | D | A | E |
                                   | Q | P | D | N | F |
                                   | U | L |   | C | R |
                                   | E | Y |   | E | E |
    +-----------------------------+| S |   |   | L | S |
    | Scheduling Outbox Privilege || T |   |   |   | H |
    +=============================++===+===+===+===+===+
    | schedule-send               || * | * | * | * | * |
    |   schedule-send-invite      || * |   | * | * |   |
    |   schedule-send-reply       ||   | * |   |   | * |
    |   schedule-send-freebusy    ||   |   |   |   |   |
    +-----------------------------++---+---+---+---+---+
    ]]></artwork>
            </figure>
            <figure>
              <artwork><![CDATA[

                                   +-----------------------+
                                   |  METHOD for VJOURNAL  |
                                   +-------+-------+-------+
                                   |   P   |   A   |   C   | 
                                   |   U   |   D   |   A   | 
                                   |   B   |   D   |   N   | 
                                   |   L   |       |   C   | 
                                   |   I   |       |   E   | 
    +-----------------------------+|   S   |       |   L   | 
    | Scheduling Outbox Privilege ||   H   |       |       | 
    +=============================++=======+=======+=======+
    | schedule-send               ||   *   |   *   |   *   | 
    |   schedule-send-invite      ||   *   |   *   |   *   |
    |   schedule-send-reply       ||       |       |       |
    |   schedule-send-freebusy    ||       |       |       |
    +-----------------------------++-------+-------+-------+
    ]]></artwork>
            </figure>
            <figure>
              <artwork><![CDATA[
                                   +---------------+
                                   |  METHOD for   |
                                   |  VFREEBUSY    |
                                   +-------+-------+
                                   |   P   |   R   |
                                   |   U   |   E   |
                                   |   B   |   Q   |
                                   |   L   |   U   |
                                   |   I   |   E   |
    +-----------------------------+|   S   |   S   |
    | Scheduling Outbox Privilege ||   H   |   T   |
    +=============================++=======+=======+
    | schedule-send               ||   *   |   *   |
    |   schedule-send-invite      ||   *   |       |
    |   schedule-send-reply       ||       |       |
    |   schedule-send-freebusy    ||       |   *   |
    +-----------------------------++-------+-------+
    ]]></artwork>
            </figure>
          </section>
        </section>
    <section title="Example Workflows">
    </section>
    <section title="Changes (to be removed prior to publication as an RFC)">
      <section title="Changes in -05">
        <t>This draft has changed substantially since the -04 version. The primary reason for this change was implementation experience from a number of vendors who implemented products based on the earlier drafts. Experience showed that the client/server interaction was not reliable in keeping scheduling messages synchronized between organizer and attendees. In addition the latency in updates due to clients being offline proved unacceptable to users. These issues led to the redesign of this specification to support a server-based processing model that eliminates all the problems seen previously. Whilst this adds significant complexity to the server in that it needs to be a full blown iTIP processing agent, it does remove a lot of the same complexity from clients, opening up the possibility of supporting complex scheduling behaviors even with "thin" clients.</t>
		<t>In the judgement of the authors, we consider this new specification to be a substantial improvement over the old one and believe it represents a stronger protocol that will lead to better interoperability.</t>
      </section>
    </section>
<!-- Changes -->
  </back>
</rfc>

<!-- TODO:

- Allow "Attendee" Changes: "Attendees" should be allowed to modify their
  own RSVP parameter to remember whether they already sent a reply or not.

- SCHEDULE-STATUS on ORGANIZER: In each recurrence instance?

-->

