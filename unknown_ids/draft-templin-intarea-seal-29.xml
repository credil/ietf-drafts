<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict='yes'?>
<?rfc iprnotified='no'?>
<rfc category="std" docName="draft-templin-intarea-seal-29.txt"
     ipr="trust200902">
  <front>
    <title abbrev="SEAL">The Subnetwork Encapsulation and Adaptation Layer
    (SEAL)</title>

    <author fullname="Fred L. Templin" initials="F. L." role="editor"
            surname="Templin">
      <organization>Boeing Research &amp; Technology</organization>

      <address>
        <postal>
          <street>P.O. Box 3707</street>

          <city>Seattle</city>

          <region>WA</region>

          <code>98124</code>

          <country>USA</country>
        </postal>

        <email>fltemplin@acm.org</email>
      </address>
    </author>

    <date day="11" month="March" year="2011" />

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <abstract>
      <t>For the purpose of this document, a subnetwork is defined as a
      virtual topology configured over a connected IP network routing region
      and bounded by encapsulating border nodes. These virtual topologies are
      manifested by tunnels that may span multiple IP and/or sub-IP layer
      forwarding hops, and can introduce failure modes due to packet
      duplication and/or links with diverse Maximum Transmission Units (MTUs).
      This document specifies a Subnetwork Encapsulation and Adaptation Layer
      (SEAL) that accommodates such virtual topologies over diverse underlying
      link technologies.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>As Internet technology and communication has grown and matured, many
      techniques have developed that use virtual topologies (including tunnels
      of one form or another) over an actual network that supports the
      Internet Protocol (IP) <xref target="RFC0791"></xref><xref
      target="RFC2460"></xref>. Those virtual topologies have elements that
      appear as one hop in the virtual topology, but are actually multiple IP
      or sub-IP layer hops. These multiple hops often have quite diverse
      properties that are often not even visible to the endpoints of the
      virtual hop. This introduces failure modes that are not dealt with well
      in current approaches.</t>

      <t>The use of IP encapsulation (also known as "tunneling") has long been
      considered as the means for creating such virtual topologies. However,
      the insertion of an outer IP header reduces the effective path MTU
      visible to the inner network layer. When IPv4 is used, this reduced MTU
      can be accommodated through the use of IPv4 fragmentation, but
      unmitigated in-the-network fragmentation has been found to be harmful
      through operational experience and studies conducted over the course of
      many years <xref target="FRAG"></xref><xref target="FOLK"></xref><xref
      target="RFC4963"></xref>. Additionally, classical path MTU discovery
      <xref target="RFC1191"></xref> has known operational issues that are
      exacerbated by in-the-network tunnels <xref
      target="RFC2923"></xref><xref target="RFC4459"></xref>. The following
      subsections present further details on the motivation and approach for
      addressing these issues.</t>

      <section title="Motivation">
        <t>Before discussing the approach, it is necessary to first understand
        the problems. In both the Internet and private-use networks today,
        IPv4 is ubiquitously deployed as the Layer 3 protocol. The two primary
        functions of IPv4 are to provide for 1) addressing, and 2) a
        fragmentation and reassembly capability used to accommodate links with
        diverse MTUs. While it is well known that the IPv4 address space is
        rapidly becoming depleted, there is a lesser-known but growing
        consensus that other IPv4 protocol limitations have already or may
        soon become problematic.</t>

        <t>First, the IPv4 header Identification field is only 16 bits in
        length, meaning that at most 2^16 unique packets with the same
        (source, destination, protocol)-tuple may be active in the Internet at
        a given time <xref target="I-D.ietf-intarea-ipv4-id-update"></xref>.
        Due to the escalating deployment of high-speed links (e.g., 1Gbps
        Ethernet), however, this number may soon become too small by several
        orders of magnitude for high data rate packet sources such as tunnel
        endpoints <xref target="RFC4963"></xref>. Furthermore, there are many
        well-known limitations pertaining to IPv4 fragmentation and reassembly
        &ndash; even to the point that it has been deemed
        &ldquo;harmful&rdquo; in both classic and modern-day studies (see
        above). In particular, IPv4 fragmentation raises issues ranging from
        minor annoyances (e.g., in-the-network router fragmentation <xref
        target="RFC1981"></xref>) to the potential for major integrity issues
        (e.g., mis-association of the fragments of multiple IP packets during
        reassembly <xref target="RFC4963"></xref>).</t>

        <t>As a result of these perceived limitations, a
        fragmentation-avoiding technique for discovering the MTU of the
        forward path from a source to a destination node was devised through
        the deliberations of the Path MTU Discovery Working Group (PMTUDWG)
        during the late 1980&rsquo;s through early 1990&rsquo;s (see Appendix
        D). In this method, the source node provides explicit instructions to
        routers in the path to discard the packet and return an ICMP error
        message if an MTU restriction is encountered. However, this approach
        has several serious shortcomings that lead to an overall
        &ldquo;brittleness&rdquo; <xref target="RFC2923"></xref>.</t>

        <t>In particular, site border routers in the Internet are being
        configured more and more to discard ICMP error messages coming from
        the outside world. This is due in large part to the fact that
        malicious spoofing of error messages in the Internet is trivial since
        there is no way to authenticate the source of the messages <xref
        target="RFC5927"></xref>. Furthermore, when a source node that
        requires ICMP error message feedback when a packet is dropped due to
        an MTU restriction does not receive the messages, a path MTU-related
        black hole occurs. This means that the source will continue to send
        packets that are too large and never receive an indication from the
        network that they are being discarded. This behavior has been
        confirmed through documented studies showing clear evidence of path
        MTU discovery failures in the Internet today <xref
        target="TBIT"></xref><xref target="WAND"></xref><xref
        target="SIGCOMM"></xref>.</t>

        <t>The issues with both IPv4 fragmentation and this
        &ldquo;classical&rdquo; method of path MTU discovery are exacerbated
        further when IP tunneling is used <xref target="RFC4459"></xref>. For
        example, ingress tunnel endpoints (ITEs) may be required to forward
        encapsulated packets into the subnetwork on behalf of hundreds,
        thousands, or even more original sources in the end site. If the ITE
        allows IPv4 fragmentation on the encapsulated packets, persistent
        fragmentation could lead to undetected data corruption due to
        Identification field wrapping. If the ITE instead uses classical IPv4
        path MTU discovery, it may be inconvenienced by excessive ICMP error
        messages coming from the subnetwork that may be either suspect or
        contain insufficient information for translation into error messages
        to be returned to the original sources.</t>

        <t>Although recent works have led to the development of a robust
        end-to-end MTU determination scheme <xref target="RFC4821"></xref>,
        this approach requires tunnels to present a consistent MTU the same as
        for ordinary links on the end-to-end path. Moreover, in current
        practice existing tunneling protocols mask the MTU issues by selecting
        a "lowest common denominator" MTU that may be much smaller than
        necessary for most paths and difficult to change at a later date. Due
        to these many consideration, a new approach to accommodate tunnels
        over links with diverse MTUs is necessary.</t>
      </section>

      <section title="Approach">
        <t>For the purpose of this document, a subnetwork is defined as a
        virtual topology configured over a connected network routing region
        and bounded by encapsulating border nodes. Example connected network
        routing regions include Mobile Ad hoc Networks (MANETs), enterprise
        networks and the global public Internet itself. Subnetwork border
        nodes forward unicast and multicast packets over the virtual topology
        across multiple IP and/or sub-IP layer forwarding hops that may
        introduce packet duplication and/or traverse links with diverse
        Maximum Transmission Units (MTUs).</t>

        <t>This document introduces a Subnetwork Encapsulation and Adaptation
        Layer (SEAL) for tunneling network layer protocols (e.g., IP, OSI,
        etc.) over IP subnetworks that connect Ingress and Egress Tunnel
        Endpoints (ITEs/ETEs) of border nodes. It provides a modular
        specification designed to be tailored to specific associated tunneling
        protocols. A transport-mode of operation is also possible, and
        described in Appendix C. SEAL accommodates links with diverse MTUs,
        protects against off-path denial-of-service attacks, and can be
        configured to enable efficient duplicate packet detection through the
        use of a minimal mid-layer encapsulation.</t>

        <t>SEAL specifically treats tunnels that traverse the subnetwork as
        ordinary links that must support network layer services. As for any
        link, tunnels that use SEAL must provide suitable networking services
        including best-effort datagram delivery, integrity and consistent
        handling of packets of various sizes. As for any link whose media
        cannot provide suitable services natively, tunnels that use SEAL
        employ link-level adaptation functions to meet the legitimate
        expectations of the network layer service. As this is essentially a
        link level adaptation, SEAL is therefore permitted to alter packets
        within the subnetwork as long as it restores them to their original
        form when they exit the subnetwork. The mechanisms described within
        this document are designed precisely for this purpose.</t>

        <t>SEAL encapsulation provides extended identification fields as well
        as a mid-layer segmentation and reassembly capability that allows
        simplified cutting and pasting of packets. Moreover, SEAL engages both
        tunnel endpoints in ensuring a functional path MTU on the path from
        the ITE to the ETE. This is in contrast to "stateless" approaches
        which seek to avoid MTU issues by selecting a lowest common
        denominator MTU value that may be overly conservative for the vast
        majority of tunnel paths and difficult to change even when larger MTUs
        become available.</t>

        <t>The following sections provide the SEAL normative specifications,
        while the appendices present non-normative additional
        considerations.</t>
      </section>
    </section>

    <section title="Terminology and Requirements">
      <t>The following terms are defined within the scope of this
      document:</t>

      <t><list style="hanging">
          <t hangText="subnetwork"><vspace />a virtual topology configured
          over a connected network routing region and bounded by encapsulating
          border nodes.</t>

          <t hangText="Ingress Tunnel Endpoint"><vspace />a virtual interface
          over which an encapsulating border node (host or router) sends
          encapsulated packets into the subnetwork.</t>

          <t hangText="Egress Tunnel Endpoint"><vspace />a virtual interface
          over which an encapsulating border node (host or router) receives
          encapsulated packets from the subnetwork.</t>

          <t hangText="inner packet"><vspace />an unencapsulated network layer
          protocol packet (e.g., IPv6 <xref target="RFC2460"></xref>, IPv4
          <xref target="RFC0791"></xref>, OSI/CLNP <xref
          target="RFC1070"></xref>, etc.) before any mid-layer or outer
          encapsulations are added. Internet protocol numbers that identify
          inner packets are found in the IANA Internet Protocol registry <xref
          target="RFC3232"></xref>.</t>

          <t hangText="mid-layer packet"><vspace />a packet resulting from
          adding mid-layer encapsulating headers to an inner packet.</t>

          <t hangText="outer IP packet"><vspace />a packet resulting from
          adding an outer IP header (and possibly other outer headers) to a
          mid-layer packet.</t>

          <t hangText="packet-in-error"><vspace />the leading portion of an
          invoking data packet encapsulated in the body of an error control
          message (e.g., an ICMPv4 <xref target="RFC0792"></xref> error
          message, an ICMPv6 <xref target="RFC4443"></xref> error message,
          etc.).</t>

          <t hangText="Packet Too Big (PTB)"><vspace />a control plane message
          indicating an MTU restriction, e.g., an ICMPv6 "Packet Too Big"
          message <xref target="RFC4443"></xref>, an ICMPv4 "Fragmentation
          Needed" message <xref target="RFC0792"></xref>, an SCMP "Packet Too
          Big" message (see: Section 4.5), etc.</t>

          <t hangText="IP, IPvX, IPvY"><vspace />used to generically refer to
          either IP protocol version, i.e., IPv4 or IPv6.</t>
        </list></t>

      <t>The following abbreviations correspond to terms used within this
      document and elsewhere in common Internetworking nomenclature:</t>

      <t><list>
          <t>DF - the IPv4 header "Don't Fragment" flag <xref
          target="RFC0791"></xref><vspace /></t>

          <t>ETE - Egress Tunnel Endpoint<vspace /></t>

          <t>HLEN - the sum of MHLEN and OHLEN<vspace /></t>

          <t>ITE - Ingress Tunnel Endpoint<vspace /></t>

          <t>MHLEN - the length of any mid-layer headers and
          trailers<vspace /></t>

          <t>MRU - Maximum Reassembly Unit<vspace /></t>

          <t>MTU - Maximum Transmission Unit<vspace /></t>

          <t>OHLEN - the length of any outer encapsulating headers and
          trailers<vspace /></t>

          <t>S_IFT - SEAL Inner Fragmentation Threshold <vspace /></t>

          <t>S_MRU - SEAL Maximum Reassembly Unit<vspace /></t>

          <t>S_MSS - SEAL Maximum Segment Size<vspace /></t>

          <t>SCMP - the SEAL Control Message Protocol<vspace /></t>

          <t>SEAL - Subnetwork Encapsulation and Adaptation
          Layer<vspace /></t>

          <t>SEAL_PORT - a TCP/UDP service port number used for
          SEAL<vspace /></t>

          <t>SEAL_PROTO - an IPv4 protocol number used for SEAL<vspace /></t>

          <t>TE - Tunnel Endpoint (i.e., either ingress or egress)
          <vspace /></t>

          <t>VET - Virtual Enterprise Traversal<vspace /></t>
        </list></t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>. When used in lower case (e.g., must, must not,
      etc.), these words MUST NOT be interpreted as described in <xref
      target="RFC2119"></xref>, but are rather interpreted as they would be in
      common English.</t>
    </section>

    <section title="Applicability Statement">
      <t>SEAL was originally motivated by the specific case of subnetwork
      abstraction for Mobile Ad hoc Networks (MANETs), however it soon became
      apparent that the domain of applicability also extends to subnetwork
      abstractions over enterprise networks, ISP networks, SOHO networks, the
      global public Internet itself, and any other connected network routing
      region. SEAL along with the Virtual Enterprise Traversal (VET) <xref
      target="I-D.templin-intarea-vet"></xref> tunnel virtual interface
      abstraction are the functional building blocks for a new Internetworking
      architecture based on Routing and Addressing in Networks with Global
      Enterprise Recursion (RANGER) <xref target="RFC5720"></xref><xref
      target="RFC6139"></xref> and the Internet Routing Overlay Network (IRON)
      <xref target="RFC6179"></xref>.</t>

      <t>SEAL provides a network sublayer for encapsulation of an inner
      network layer packet within outer encapsulating headers. For example,
      for IPvX in IPvY encapsulation (e.g., as IPv4/SEAL/IPv6), the SEAL
      header appears as a subnetwork encapsulation as seen by the inner IP
      layer. SEAL can also be used as a sublayer within a UDP data payload
      (e.g., as IPv4/UDP/SEAL/IPv6 similar to Teredo <xref
      target="RFC4380"></xref>), where UDP encapsulation is typically used for
      Network Address Translator (NAT) traversal as well as operation over
      subnetworks that give preferential treatment to the "core" Internet
      protocols (i.e., TCP and UDP). The SEAL header is processed the same as
      for IPv6 extension headers, i.e., it is not part of the outer IP header
      but rather allows for the creation of an arbitrarily extensible chain of
      headers in the same way that IPv6 does.</t>

      <t>SEAL supports a segmentation and reassembly capability for adapting
      the network layer to the underlying subnetwork characteristics, where
      the Egress Tunnel Endpoint (ETE) determines how much or how little
      reassembly it is willing to support. In the limiting case, the ETE can
      avoid reassembly altogether and act as a passive observer that simply
      informs the Ingress Tunnel Endpoint (ITE) of any MTU limitations and
      otherwise discards all packets that arrive as multiple fragments. This
      mode is useful for determining an appropriate MTU for tunneling between
      performance-critical routers connected to high data rate subnetworks
      such as the Internet DFZ, for unidirectional tunneling in which the ETE
      is stateless, and for other uses in which reassembly would present too
      great of a burden for the routers or end systems.</t>

      <t>When the ETE supports reassembly, the tunnel can be used to transport
      packets that are too large to traverse the path without fragmentation.
      In this mode, the ITE determines the tunnel MTU based on the largest
      packet the ETE is capable of reassembling rather than on the MTU of the
      smallest link in the path. Therefore, tunnel endpoints that use SEAL can
      transport packets that are much larger than the underlying subnetwork
      links themselves can carry in a single piece.</t>

      <t>SEAL tunnels may be configured over paths that include not only
      ordinary physical links, but also virtual links that may include other
      tunnels. An example application would be linking two geographically
      remote supercomputer centers with large MTU links by configuring a SEAL
      tunnel across the Internet. A second example would be support for sub-IP
      segmentation over low-end links, i.e., especially over wireless
      transmission media such as IEEE 802.15.4, broadcast radio links in
      Mobile Ad-hoc Networks (MANETs), Very High Frequency (VHF) civil
      aviation data links, etc.</t>

      <t>Many other use case examples are anticipated, and will be identified
      as further experience is gained.</t>
    </section>

    <section title="SEAL Protocol Specification">
      <t>The following sections specify the operation of the SEAL
      protocol.</t>

      <section title="VET Interface Model">
        <t>SEAL is an encapsulation sublayer used within VET non-broadcast,
        multiple access (NBMA) tunnel virtual interfaces. Each VET interface
        connects an ITE to one or more ETE "neighbors" via tunneling across an
        underlying enterprise network, or "subnetwork". The tunnel neighbor
        relationship between the ITE and each ETE may be either unidirectional
        or bidirectional.</t>

        <t>A unidirectional tunnel neighbor relationship allows the near end
        TE to send data packets forward to the far end TE, while the far end
        only returns control messages when necessary. A bidirectional tunnel
        neighbor relationship is one over which both TEs can exchange both
        data and control messages.</t>

        <t>Implications of the VET unidirectional and bidirectional models for
        SEAL will be discussed further throughout the remainder of the
        document.</t>
      </section>

      <section title="SEAL Model of Operation">
        <t>SEAL supports a multi-level segmentation and reassembly capability
        for the transmission of unicast and multicast packets across an
        underlying IP subnetwork with heterogeneous links. First, the ITE can
        use IPv4 fragmentation to fragment inner IPv4 packets before SEAL
        encapsulation if necessary. Secondly, the SEAL layer itself provides a
        simple cutting-and-pasting capability for mid-layer packets that can
        be used to avoid IP fragmentation on the outer packet. Finally,
        ordinary IP fragmentation is permitted on the outer packet after SEAL
        encapsulation and allows the TEs to detect and tune out any
        in-the-network fragmentation.</t>

        <t>SEAL-enabled ITEs encapsulate each inner packet in any mid-layer
        headers and trailers, segment the resulting mid-layer packet into
        multiple segments if necessary, then append a SEAL header and any
        outer encapsulations to each segment. As an example, for IPv6 within
        IPv4 encapsulation a single-segment inner IPv6 packet encapsulated in
        any mid-layer headers and trailers, followed by the SEAL header,
        followed by any outer headers and trailers, followed by an outer IPv4
        header would appear as shown in <xref target="encaps1"></xref>:</t>

        <t><figure anchor="encaps1"
            title="SEAL Encapsulation - Single Segment">
            <artwork><![CDATA[                                    +--------------------+
                                    ~  outer IPv4 header ~
                                    +--------------------+
I                                   ~  other outer hdrs  ~
n                                   +--------------------+
n                                   ~    SEAL Header     ~
e      +--------------------+       +--------------------+
r      ~  mid-layer headers ~       ~  mid-layer headers ~
       +--------------------+       +--------------------+
I -->  |                    |  -->  |                    |
P -->  ~     inner IPv6     ~  -->  ~     inner IPv6     ~
v -->  ~       Packet       ~  -->  ~       Packet       ~
6 -->  |                    |  -->  |                    |
       +--------------------+       +--------------------+
P      ~ mid-layer trailers ~       ~ mid-layer trailers ~
a      +--------------------+       +--------------------+
c                                   ~   outer trailers   ~
k         Mid-layer packet          +--------------------+
e      after mid-layer encaps.
t                                      Outer IPv4 packet
                                  after SEAL and outer encaps.]]></artwork>
          </figure></t>

        <t>As a second example, for IPv4 within IPv6 encapsulation an inner
        IPv4 packet requiring three SEAL segments would appear as three
        separate outer IPv6 packets, where the mid-layer headers are carried
        only in segment 0 and the mid-layer trailers are carried in segment 2
        as shown in <xref target="encaps2"></xref>:</t>

        <figure anchor="encaps2"
                title="SEAL Encapsulation - Multiple Segments">
          <artwork><![CDATA[+------------------+   +------------------+   +------------------+
~  outer IPv6 hdr  ~   ~  outer IPv6 hdr  ~   ~  outer IPv6 hdr  ~
+------------------+   +------------------+   +------------------+
~ other outer hdrs ~   ~ other outer hdrs ~   ~ other outer hdrs ~
+------------------+   +------------------+   +------------------+
~ SEAL hdr (SEG=0) ~   ~ SEAL hdr (SEG=1) ~   ~ SEAL hdr (SEG=2) ~
+------------------+   +------------------+   +------------------+
~  mid-layer hdrs  ~   |                  |   |    inner IPv4    |
+------------------+   |    inner IPv4    |   ~  Packet Segment  ~
|    inner IPv4    |   ~  Packet Segment  ~   | (Len may be != L)|
~  Packet Segment  ~   |   (Length = L)   |   +------------------+
|   (Length = L)   |   |                  |   ~ mid-layer trails ~
+------------------+   +------------------+   +------------------+
~  outer trailers  ~   ~  outer trailers  ~   ~  outer trailers  ~
+------------------+   +------------------+   +------------------+

Segment 0 (includes    Segment 1 (no mid-     Segment 2 (includes
  mid-layer hdrs)        layer encaps)         mid-layer trails)]]></artwork>
        </figure>

        <t></t>

        <t>The ITE inserts the SEAL header according to the specific tunneling
        protocol. Examples include the following:<list style="symbols">
            <t>For simple encapsulation of an inner network layer packet
            within an outer IPvX header (e.g., <xref
            target="RFC1070"></xref><xref target="RFC2003"></xref><xref
            target="RFC2473"></xref><xref target="RFC4213"></xref>, etc.), the
            ITE inserts the SEAL header between the inner packet and outer
            IPvX headers as: IPvX/SEAL/{inner packet}.</t>

            <t>For encapsulations over transports such as UDP (e.g., <xref
            target="RFC4380"></xref>), the ITE inserts the SEAL header between
            the outer transport layer header and the mid-layer packet, e.g.,
            as IPvX/UDP/SEAL/{mid-layer packet}. Here, the UDP header is seen
            as an "other outer header".</t>
          </list>The SEAL header includes a Nonce value and (optionally) an
        Identification value which routers within the subnetwork can use for
        duplicate packet detection and both TEs can use for SEAL
        segmentation/reassembly.</t>

        <t>The following sections specify the SEAL header format and
        SEAL-related operations of the ITE and ETE.</t>
      </section>

      <section title="SEAL Header Format">
        <t>The SEAL header is formatted as follows:</t>

        <t><figure anchor="minimal" title="SEAL Header Format ">
            <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |VER|C|A|I|R|F|M|  NEXTHDR/SEG  |                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             Nonce             |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Identification (when necessary)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure></t>

        <t>where the header fields are defined as:</t>

        <t><list style="hanging">
            <t hangText="VER (2)"><vspace />a 2-bit version field. This
            document specifies Version 0 of the SEAL protocol, i.e., the VER
            field encodes the value 0.</t>

            <t hangText="C (1)"><vspace />the "Control/Data" bit. Set to 1 by
            the ITE in SEAL Control Message Protocol (SCMP) control messages,
            and set to 0 in ordinary data packets.</t>

            <t hangText="A (1)"><vspace />the "Acknowledgement Requested" bit.
            Set to 1 by the ITE in data packets for which it wishes to receive
            an explicit acknowledgement from the ETE.</t>

            <t hangText="I (1)"><vspace />the "Identification Field Included"
            bit. Set to 1 if the SEAL header includes a 32-bit packet
            Identification field (see below); set to 0 otherwise.</t>

            <t hangText="R (1)"><vspace />the "Redirects Permitted" bit. Set
            to 1 if the ITE is willing to accept SCMP redirects (see: Section
            4.6); set to 0 otherwise.</t>

            <t hangText="F (1)"><vspace />the "First Segment" bit. Set to 1 if
            this SEAL protocol packet contains the first segment (i.e.,
            Segment #0) of a mid-layer packet.</t>

            <t hangText="M (1)"><vspace />the "More Segments" bit. Set to 1 if
            this SEAL protocol packet contains a non-final segment of a
            multi-segment mid-layer packet.</t>

            <t hangText="NEXTHDR/SEG (8)">an 8-bit field. When 'F'=1, encodes
            the next header Internet Protocol number the same as for the IPv4
            protocol and IPv6 next header fields. When 'F'=0, encodes a
            segment number of a multi-segment mid-layer packet. (The segment
            number 0 is reserved.)</t>

            <t hangText="Nonce (48)"><vspace />a 48-bit nonce value used by
            the ITE to prove authorization of sending inner packets with
            specific addresses. Set to a random value in an initial exchange
            with the ETE.</t>

            <t hangText="Identification (32)"><vspace />a 32-bit per-packet
            identification field. Present only when the I bit is set to 1 (see
            above).</t>
          </list>Setting of the various bits and fields of the SEAL header is
        specified in the following sections.</t>
      </section>

      <section title="ITE Specification">
        <section title="Tunnel Interface MTU">
          <t>The tunnel interface must present a fixed MTU to the inner
          network layer as the size for admission of inner packets into the
          interface. Since VET NBMA tunnel virtual interfaces may support a
          large set of ETEs that accept widely varying maximum packet sizes,
          however, a number of factors should be taken into consideration when
          selecting a tunnel interface MTU.</t>

          <t>Due to the ubiquitous deployment of standard Ethernet and similar
          networking gear, the nominal Internet cell size has become 1500
          bytes; this is the de facto size that end systems have come to
          expect will either be delivered by the network without loss due to
          an MTU restriction on the path or a suitable ICMP Packet Too Big
          (PTB) message returned. When large packets sent by end systems incur
          additional encapsulation at an ITE, however, they may be dropped
          silently within the tunnel since the network may not always deliver
          the necessary PTBs <xref target="RFC2923"></xref>.</t>

          <t>The ITE should therefore set a tunnel interface MTU of at least
          1500 bytes plus extra room to accommodate any additional
          encapsulations that may occur on the path from the original source.
          The ITE can also set smaller MTU values; however, care must be taken
          not to set so small a value that original sources would experience
          an MTU underflow. In particular, IPv6 sources must see a minimum
          path MTU of 1280 bytes, and IPv4 sources should see a minimum path
          MTU of 576 bytes.</t>

          <t>The ITE can alternatively set an indefinite MTU on the tunnel
          interface such that all inner packets are admitted into the
          interface without regard to size. For ITEs that host applications
          that use the tunnel interface directly, this option must be
          carefully coordinated with protocol stack upper layers since some
          upper layer protocols (e.g., TCP) derive their packet sizing
          parameters from the MTU of the outgoing interface and as such may
          select too large an initial size. This is not a problem for upper
          layers that use conservative initial maximum segment size estimates
          and/or when the tunnel interface can reduce the upper layer's
          maximum segment size, e.g., by reducing the size advertised in the
          MSS option of outgoing TCP messages.</t>

          <t>The inner network layer protocol consults the tunnel interface
          MTU when admitting a packet into the interface. For non-SEAL inner
          IPv4 packets with the IPv4 Don't Fragment (DF) bit set to 0, if the
          packet is larger than the tunnel interface MTU the inner IPv4 layer
          uses IPv4 fragmentation to break the packet into fragments no larger
          than the tunnel interface MTU. The ITE then admits each fragment
          into the interface as an independent packet.</t>

          <t>For all other inner packets, the inner network layer admits the
          packet if it is no larger than the tunnel interface MTU; otherwise,
          it drops the packet and sends a PTB error message to the source with
          the MTU value set to the tunnel interface MTU. The message must
          contain as much of the invoking packet as possible without the
          entire message exceeding the network layer minimum MTU (e.g., 576
          bytes for IPv4, 1280 bytes for IPv6, etc.). For SEAL packets that
          would undergo recursive encapsulation, however, the inner layer must
          send a SEAL PTB message instead of a PTB of the inner network layer
          (see: Section 4.4.3).</t>

          <t>In light of the above considerations, the ITE SHOULD configure an
          indefinite MTU on tunnel *router* interfaces, since these may be
          required to carry recursively-nested SEAL encapsulations. The ITE
          MAY instead set a finite MTU on tunnel *host* interfaces. Any
          necessary tunnel adaptations are then performed by the SEAL layer
          within the tunnel interface as described in the following
          sections.</t>
        </section>

        <section title="Tunnel Interface Soft State">
          <t>The ITE maintains per-ETE soft state within the tunnel interface,
          e.g., in a neighbor cache. The soft state includes the
          following:</t>

          <t><list style="symbols">
              <t>a Mid-layer Header Length (MHLEN); set to the length of any
              mid-layer encapsulation headers and trailers that must be added
              before SEAL segmentation.</t>

              <t>an Outer Header Length (OHLEN); set to the length of the
              outer IP, SEAL and other outer encapsulation headers and
              trailers.</t>

              <t>a total Header Length (HLEN); set to MHLEN plus OHLEN.</t>

              <t>a SEAL Maximum Segment Size (S_MSS). The ITE initializes
              S_MSS to the minimum MTU of the underlying interfaces if the
              underlying interface MTUs can be determined (otherwise, the ITE
              initializes S_MSS to "infinity"). The ITE decreases or increased
              S_MSS based on any SCMP "Packet Too Big (PTB)" messages received
              (see Section 4.6).</t>

              <t>a SEAL Maximum Reassembly Unit (S_MRU). If the ITE is not
              configured to use SEAL segmentation, it initializes S_MRU to the
              constant value 0 and ignores any S_MRU values reported by the
              ETE. Otherwise, the ITE initializes S_MRU to "infinity" (i.e.,
              the largest possible inner packet size) and decreases or
              increases S_MRU based on any SCMP PTB messages received from the
              ETE (see Section 4.6). When (S_MRU&gt;(S_MSS*256)), the ITE uses
              (S_MSS*256) as the effective S_MRU value.</t>

              <t>a SEAL Inner Fragmentation Threshold (S_IFT); used to
              determine a maximum fragment size for fragmentable IPv4 packets.
              Required only for tunnels that support encapsulation with IPv4
              as the inner network layer protocol. The ITE should use a "safe"
              estimate for S_IFT that would be highly unlikely to trigger
              additional fragmentation on the path to the ETE. This estimate
              SHOULD be selected such that S_IFT &lt;= MAX(S_MSS, MS_MRU);
              more specifically, it is RECOMMENDED that the ITE set S_IFT to
              512 unless it can determine a more accurate safe value (e.g.,
              via probing).</t>

              <t>a set of 48 bit Nonce values that are randomly-initialized
              and used to fill the SEAL header field of the same name for
              packets sent to this ETE.</t>

              <t>a per-Nonce 32 bit Identification value that is
              randomly-initialized and monotonically-incremented for each
              packet sent using the corresponding Nonce.</t>
            </list>Note that S_MSS and S_MRU include the length of the outer
          and mid-layer encapsulating headers and trailers (i.e., HLEN), since
          the ETE must retain the headers and trailers during reassembly. Note
          also that the ITE maintains S_MSS and S_MRU as 32-bit values such
          that inner packets larger than 64KB (e.g., IPv6 jumbograms <xref
          target="RFC2675"></xref>) can be accommodated when appropriate for a
          given subnetwork.</t>
        </section>

        <section title="Submitting Packets for Encapsulation">
          <t>Once an inner packet/fragment has been admitted into the tunnel
          interface, it transitions from the inner network layer and becomes
          subject to SEAL layer processing. The ITE then examines each packet
          to determine whether it is too large for SEAL encapsulation, then
          submits the packet for encapsulation according to whether it is
          "fragmentable" (discussed in the next paragraph) or "unfragmentable"
          (discussed in the following paragraph).</t>

          <t>For IPv4 packets with DF=0 in the IPv4 header, if the packet is
          no larger than S_IFT the ITE submits the packet for encapsulation.
          Otherwise, the ITE uses inner IPv4 fragmentation to break the packet
          into IPv4 fragments no larger than S_IFT bytes. For non-SEAL IPv4
          packets, the ITE then submits each fragment for encapsulation
          separately. For SEAL IPv4 packets, the ITE instead uses the first
          fragment to prepare an SCMP PTB message with Code=0 to return to the
          source (see: Section 4.6.1.1) then discards each fragment.</t>

          <t>For all other packets, if the packet is larger than (MAX(S_MRU,
          S_MSS) - HLEN), the ITE discards it and sends a PTB message to the
          source with an MTU value of (MAX(S_MRU, S_MSS) - HLEN); otherwise,
          the ITE submits the packet for encapsulation. The ITE must include
          the length of the uncompressed headers and trailers when calculating
          HLEN even if the tunnel is using header compression. The ITE is also
          permitted to submit inner packets for encapsulation if they can be
          accommodated in a single SEAL segment (i.e., no larger than S_MSS)
          even if they are larger than the ETE would be willing to reassemble
          if fragmented (i.e., larger than S_MRU) - see: Section 4.5.1.</t>
        </section>

        <section title="Mid-Layer Encapsulation">
          <t>After inner IP fragmentation (if necessary), the ITE next
          encapsulates each inner packet/fragment in the MHLEN bytes of any
          mid-layer headers and trailers. The ITE then submits the mid-layer
          packet for SEAL segmentation and encapsulation.</t>
        </section>

        <section title="SEAL Segmentation">
          <t>If the ITE is configured to use SEAL segmentation, it checks the
          length of the resulting packet after mid-layer encapsulation to
          determine whether segmentation is needed. If the length of the
          resulting mid-layer packet plus OHLEN is larger than S_MSS but no
          larger than S_MRU the ITE performs SEAL segmentation by breaking the
          mid-layer packet into N segments (N &lt;= 256) that are no larger
          than (S_MSS - OHLEN) bytes each. Each segment, except the final one,
          MUST be of equal length. The first byte of each segment MUST begin
          immediately after the final byte of the previous segment, i.e., the
          segments MUST NOT overlap. The ITE SHOULD generate the smallest
          number of segments possible, e.g., it SHOULD NOT generate 6 smaller
          segments when the packet could be accommodated with 4 larger
          segments.</t>

          <t>This SEAL segmentation process ignores the fact that the
          mid-layer packet may be unfragmentable outside of the subnetwork.
          The process is a mid-layer (not an IP layer) operation employed by
          the ITE to adapt the mid-layer packet to the subnetwork path
          characteristics, and the ETE will restore the packet to its original
          form during reassembly. Therefore, the fact that the packet may have
          been segmented within the subnetwork is not observable outside of
          the subnetwork.</t>
        </section>

        <section title="SEAL Encapsulation">
          <t>Following SEAL segmentation, the ITE next encapsulates each
          segment in a SEAL header formatted as specified in Section 4.3.</t>

          <t>For the first segment, the ITE then sets F=1, and sets M=1 if
          there are more segments or sets M=0 otherwise. The ITE then sets
          NEXTHDR to the Internet Protocol number corresponding to the
          encapsulated inner packet. For example, the ITE sets NEXTHDR to the
          value '4' for encapsulated IPv4 packets <xref
          target="RFC2003"></xref>, the value '41' for encapsulated IPv6
          packets <xref target="RFC2473"></xref><xref
          target="RFC4213"></xref>, the value '50' for encapsulated IPsec/ESP
          payloads <xref target="RFC4301"></xref><xref
          target="RFC4303"></xref>, the value '80' for encapsulated OSI
          packets <xref target="RFC1070"></xref>, etc.</t>

          <t>For each non-initial segment of an N-segment mid-layer packet (N
          &lt;= 256), the ITE instead sets (F=0; M=1; SEG=1) in the SEAL
          header of the first non-initial segment, sets (F=0; M=1; SEG=2) in
          the next non-initial segment, etc., and sets (F=0; M=0; SEG=N-1) in
          the final segment. (Note that the value SEG=0 is not used, since the
          initial segment encodes a NEXTHDR value and not a SEG value.)</t>

          <t>For each segment (i.e., both initial and non-initial), the ITE
          then sets C=0, sets R=1 if it is willing to accept SCMP redirects
          (see Section 4.6) and sets A=1 if an explicit acknowledgement is
          required (see Section 4.4.9). The ITE then sets the Nonce field to a
          randomly-initialized constant value that identifies itself to the
          neighboring ETE.</t>

          <t>Finally, the ITE maintains a randomly-initialized per-Nonce
          packet identification value as additional per-ETE soft state. For
          each SEAL segment of a multi-segment SEAL packet, the ITE sets I=1
          and includes the current identification value in a trailing 32-bit
          Identification field in the SEAL header of each segment. For each
          SEAL packet that will be sent as a single segment, however, the ITE
          MAY set I=0 and omit the trailing Identification field. Whether or
          not the Identification field was included, the ITE then
          monotonically increments the identification value (modulo 2^32) for
          the next SEAL packet to be sent to the ETE.</t>
        </section>

        <section title="Outer Encapsulation">
          <t>Following SEAL encapsulation, the ITE next encapsulates each SEAL
          segment in the requisite outer headers and trailers according to the
          specific encapsulation format (e.g., <xref target="RFC1070"></xref>,
          <xref target="RFC2003"></xref>, <xref target="RFC2473"></xref>,
          <xref target="RFC4213"></xref>, etc.), except that it writes
          'SEAL_PROTO' in the protocol field of the outer IP header (when
          simple IP encapsulation is used) or writes 'SEAL_PORT' in the outer
          destination service port field (e.g., when IP/UDP encapsulation is
          used).</t>

          <t>When IPv4 is used as the outer encapsulation layer, the ITE
          finally sets the DF flag in the IPv4 header of each segment. If the
          path to the ETE correctly implements IP fragmentation (see: Section
          4.4.9), the ITE sets DF=0; otherwise, it sets DF=1.</t>

          <t>When IPv6 is used as the outer encapsulation layer, the "DF" flag
          is absent but implicitly set to 1. The packet therefore will not be
          fragmented within the subnetwork, since IPv6 deprecates
          in-the-network fragmentation.</t>
        </section>

        <section title="Sending SEAL Protocol Packets">
          <t>Following outer encapsulation, the ITE sends each outer packet
          that encapsulates a segment of the same mid-layer packet over the
          same underlying link in canonical order, i.e., segment 0 first,
          followed by segment 1, etc., and finally segment N-1.</t>
        </section>

        <section title="Probing Strategy">
          <t>When IPv4 is used as the outer encapsulation layer, the ITE
          should perform a qualification exchange over each underlying link to
          determine whether each subnetwork path to the ETE correctly
          implements IPv4 fragmentation. The qualification exchange can be
          performed either as an initial probe or in-band with real data
          packets, and should be repeated periodically since the subnetwork
          paths may change due to dynamic routing.</t>

          <t>To perform this qualification, the ITE prepares a probe packet
          that is no larger than 576 bytes (e.g., a NULL packet with A=1 and
          NEXTHDR="No Next Header" <xref target="RFC2460"></xref> in the SEAL
          header), then splits the packet into two outer IPv4 fragments and
          sends both fragments to the ETE over the same underlying link. If
          the ETE returns an SCMP PTB message with Code=0 (see Section
          4.6.1.1), then the subnetwork path correctly implements IPv4
          fragmentation and subsequent data packets can be sent with DF=0 in
          the outer header to enable the preferred method of probing. If the
          ETE returns an SCMP PTB message with Code=2, however, the ITE is
          obliged to set DF=1 for future packets sent over that underlying
          link since a middlebox in the network is reassembling the IPv4
          fragments before they are delivered to the ETE.</t>

          <t>In addition to any control plane probing, all SEAL encapsulated
          data packets sent by the ITE are considered implicit probes. SEAL
          encapsulated packets that use IPv4 as the outer layer of
          encapsulation with DF=0 will elicit SCMP PTB messages from the ETE
          if any IPv4 fragmentation occurs in the path. SEAL encapsulated
          packets that use either IPv6 or IPv4 with DF=1 as the outer layer of
          encapsulation may be dropped by a router on the path to the ETE
          which will also return an ICMP PTB message to the ITE. If the
          message includes enough information (see Section 4.4.10), the ITE
          can then use the Nonce and Identification values within the
          packet-in-error to determine whether the PTB message corresponds to
          one of its recent packet transmissions.</t>

          <t>The ITE should also send explicit probes, periodically, to verify
          that the ETE is still reachable. The ITE sets A=1 in the SEAL header
          of a segment to be used as an explicit probe, where the probe can be
          either an ordinary data packet segment or a NULL packet (see above).
          The probe will elicit an SCMP PTB message with Code=2 from the ETE
          as an acknowledgement (see Section 4.6.1.1).</t>
        </section>

        <section title="Processing ICMP Messages">
          <t>When the ITE sends outer IP packets, it may receive ICMP error
          messages <xref target="RFC0792"></xref><xref
          target="RFC4443"></xref> from either the ETE or routers within the
          subnetwork. The ICMP messages include an outer IP header, followed
          by an ICMP header, followed by a portion of the outer IP packet that
          generated the error (also known as the "packet-in-error"). The ITE
          can use the Nonce and Identification values encoded in the SEAL
          header within the packet-in-error to confirm that the ICMP message
          came from either the ETE or an on-path router, and can use any
          additional information to determine whether to accept or discard the
          message.</t>

          <t>The ITE should specifically process raw ICMPv4 Protocol
          Unreachable messages and ICMPv6 Parameter Problem messages with Code
          "Unrecognized Next Header type encountered" as a hint that the ETE
          does not implement the SEAL protocol; specific actions that the ITE
          may take in this case are out of scope.</t>
        </section>

        <section title="Black Hole Detection">
          <t>In some subnetwork paths, ICMP error messages may be lost due to
          filtering or may not contain enough information due to a router in
          the path not observing the recommendations of <xref
          target="RFC1812"></xref>. The ITE can use explicit probing as
          described in Section 4.4.9 to determine whether the path to the ETE
          is silently dropping packets (also known as a "black hole"). For
          example, when the ITE is obliged to set DF=1 in the outer headers of
          data packets it should send explicit probe packets, periodically, in
          order to detect path MTU increases or decreases.</t>
        </section>
      </section>

      <section title="ETE Specification">
        <section title="Reassembly Buffer Requirements">
          <t>The ETE SHOULD support the minimum IP-layer reassembly
          requirements specified for IPv4 (i.e., 576 bytes <xref
          target="RFC1812"></xref>) and IPv6 (i.e., 1500 bytes <xref
          target="RFC2460"></xref>). The ETE SHOULD also support SEAL-layer
          reassembly for inner packets of at least 1280 bytes in length and
          MAY support reassembly for larger inner packets. The ETE records the
          SEAL-layer reassembly buffer size in a soft-state variable "S_MRU"
          (see: Section 4.5.2).</t>

          <t>The ETE may instead omit the reassembly function altogether and
          set S_MRU=0, but this may cause tunnel MTU underruns in some
          environments resulting in an unusable link. When reassembly is
          supported, the ETE must retain the outer IP, SEAL and other outer
          headers and trailers during both IP-layer and SEAL-layer reassembly
          for the purpose of associating the fragments/segments of the same
          packet, and must also configure a SEAL-layer reassembly buffer that
          is no smaller than the IP-layer reassembly buffer. Hence, the
          ETE:</t>

          <t><list style="symbols">
              <t>SHOULD configure an outer IP-layer reassembly buffer of at
              least the minimum specified for the outer IP protocol
              version.</t>

              <t>SHOULD configure a SEAL-layer reassembly buffer S_MRU size of
              at least (1280 + HELN) bytes, and</t>

              <t>MUST be capable of discarding inner packets that require
              IP-layer and/or SEAL-layer reassembly and that are larger than
              (S_MRU - HLEN).</t>
            </list></t>

          <t>The ETE is permitted to accept inner packets that did not undergo
          IP-layer and/or SEAL-layer reassembly even if they are larger than
          (S_MRU - HELN) bytes. Hence, S_MRU is a maximum *reassembly* size,
          and may be less than the largest packet size the ETE is able to
          receive when no reassembly is required.</t>
        </section>

        <section title="Tunnel Interface Soft State">
          <t>The ETE maintains a per-interface default S_MRU value to be
          applied for all unidirectional tunnel neighbors, and can also
          maintain individual per-ITE S_MRU values that override the default.
          The ETE also maintains per-ITE soft state to track the Nonce values
          used by the ITE.</t>

          <t>For each bidirectional tunnel neighbor, the ETE also tracks the
          outer IP source addresses (and also port numbers when outer UDP
          encapsulation is used) of packets received from the ITE and
          associates the most recent values received with the corresponding
          Nonce. In this way, the Nonce provides a stable handle for the ETE
          to use for return traffic to the ITE even if the outer IP source
          address and port numbers in packets received from the ITE
          change.</t>
        </section>

        <section title="IP-Layer Reassembly">
          <t>The ETE submits unfragmented SEAL protocol IP packets for
          SEAL-layer reassembly as specified in Section 4.5.4. The ETE instead
          performs standard IP-layer reassembly for multi-fragment SEAL
          protocol IP packets as follows.</t>

          <t>The ETE should maintain conservative IP-layer reassembly cache
          high- and low-water marks. When the size of the reassembly cache
          exceeds this high-water mark, the ETE should actively discard
          incomplete reassemblies (e.g., using an Active Queue Management
          (AQM) strategy) until the size falls below the low-water mark. The
          ETE should also actively discard any pending reassemblies that
          clearly have no opportunity for completion, e.g., when a
          considerable number of new fragments have been received before a
          fragment that completes a pending reassembly has arrived. Following
          successful IP-layer reassembly, the ETE submits the reassembled
          packet for SEAL-layer reassembly as specified in Section 4.5.4.</t>

          <t>When the ETE processes the IP first fragment (i.e., one with MF=1
          and Offset=0 in the IP header) of a fragmented SEAL packet, it sends
          an SCMP PTB message with Code=0 back to the ITE (see Section
          4.6.1.1). When the ETE processes an IP fragment that would cause the
          reassembled outer packet to be larger than the IP-layer reassembly
          buffer following reassembly, it discontinues the reassembly and
          discards any further fragments of the same packet.</t>
        </section>

        <section title="SEAL-Layer Reassembly">
          <t>Following IP reassembly (if necessary), the ETE examines each
          mid-layer data packet (i.e., those with C=0 in the SEAL header)
          packet) to determine whether an SCMP error message is required. If
          the mid-layer data packet has an incorrect value in the SEAL header
          the ETE discards the packet and returns an SCMP "Parameter Problem"
          message (see Section 4.6.1.4). Next, if the SEAL header has A=1 and
          the packet did not arrive as multiple outer IP fragments, the ETE
          sends an SCMP PTB message with Code=2 back to the ITE (see Section
          4.6.1.1). The ETE next submits single-segment mid-layer packets for
          decapsulation and delivery to upper layers (see Section 4.5.5). The
          ETE instead performs SEAL-layer reassembly for multi-segment
          mid-layer packets with I=1 in the SEAL header as follows.</t>

          <t>The ETE adds each segment of a multi-segment mid-layer packet
          with I=1 in the SEAL header to a SEAL-layer pending-reassembly queue
          according to the Nonce and Identification values found in the SEAL
          header. The ETE performs SEAL-layer reassembly through simple
          in-order concatenation of the encapsulated segments of the same
          mid-layer packet from N consecutive SEAL segments. SEAL-layer
          reassembly requires the ETE to maintain a cache of recently received
          segments for a hold time that would allow for nominal inter-segment
          delays. When a SEAL reassembly times out, the ETE discards the
          incomplete reassembly and returns an SCMP "Time Exceeded" message to
          the ITE (see Section 4.6.1.4). As for IP-layer reassembly, the ETE
          should also maintain a conservative reassembly cache high- and
          low-water mark and should actively discard any pending reassemblies
          that clearly have no opportunity for completion, e.g., when a
          considerable number of new SEAL packets have been received before a
          packet that completes a pending reassembly has arrived.</t>

          <t>If the ETE receives a SEAL packet for which a segment with the
          same Nonce and Identification value is already in the queue, it must
          determine whether to accept the new segment and release the old, or
          drop the new segment. If accepting the new segment would cause an
          inconsistency with other segments already in the queue (e.g.,
          differing segment lengths), the ETE drops the segment that is least
          likely to complete the reassembly. When the ETE has already received
          the SEAL first segment (i.e., one with F=1 and M=1 in the SEAL
          header) of a SEAL protocol packet that arrived as multiple SEAL
          segments, and accepting the current segment would cause the size of
          the reassembled packet to exceed S_MRU, the ETE schedules the
          reassembly resources for garbage collection and sends an SCMP PTB
          message with Code=1 back to the ITE (see Section 4.6.1.1).</t>

          <t>After all segments are gathered, the ETE reassembles the packet
          by concatenating the segments encapsulated in the N consecutive SEAL
          packets beginning with the initial segment (i.e., SEG=0) and
          followed by any non-initial segments 1 through N-1. That is, for an
          N-segment mid-layer packet, reassembly entails the concatenation of
          the SEAL-encapsulated packet segments with the same value in the
          Identification field and with (F=1, M=1) in the first SEAL header,
          followed by (F=0, M=1, SEG=1) in the next SEAL header, followed by
          (F=0, M=1, SEG=2), etc., up to (F=0, M=0, SEG=(N-1)) in the final
          SEAL header. Following successful SEAL-layer reassembly, the ETE
          submits the reassembled mid-layer packet for decapsulation and
          delivery to upper layers as specified in Section 4.5.5.</t>

          <t>The ETE must not perform SEAL-layer reassembly for multi-segment
          mid-layer packets with I=0 in the SEAL header. The ETE instead
          silently drops all segments with I=0 and either F=0 or (F=1; M=1) in
          the SEAL header and sends an SCMP Parameter Problem message back to
          the ITE.</t>
        </section>

        <section title="Decapsulation and Delivery to Upper Layers">
          <t>Following any necessary IP- and SEAL-layer reassembly, the ETE
          discards the outer headers and trailers and performs any mid-layer
          transformations on the mid-layer packet. The ETE next discards the
          mid-layer headers and trailers, and delivers the inner packet to the
          upper-layer protocol indicated either in the SEAL NEXTHDR field or
          the next header field of the mid-layer packet (i.e., if the packet
          included mid-layer encapsulations). The ETE instead silently
          discards the inner packet if it was a NULL packet (see Section
          4.4.9).</t>
        </section>
      </section>

      <section title="The SEAL Control Message Protocol (SCMP)">
        <t>SEAL uses a companion SEAL Control Message Protocol (SCMP) based on
        the same message format as the Internet Control Message Protocol for
        IPv6 (ICMPv6) <xref target="RFC4443"></xref>. Each SCMP message is
        embedded within an SCMP packet which begins with the same outer header
        format as would be used for outer encapsulation of a SEAL data packet
        (see: Section 4.4.7). The following sections specify the generation
        and processing of SCMP messages:</t>

        <section title="Generating SCMP Messages">
          <t>SCMP messages may be generated by either ITEs or ETEs (i.e., by
          any TE) using the same message Type and Code values specified for
          ordinary ICMPv6 messages in <xref target="RFC4443"></xref>. SCMP is
          also used to carry other ICMPv6 message types and their associated
          options as specified in other documents (e.g., <xref
          target="RFC4191"></xref><xref target="RFC4861"></xref>, etc.). The
          general format for SCMP messages is shown in <xref
          target="control"></xref>:</t>

          <t><figure anchor="control" title="SCMP Message Format">
              <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |     Code      |          Checksum             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                         Message Body                          ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  As much of invoking SEAL data                |
   ~                packet as possible without the SCMP            ~
   |                  packet exceeding 576 bytes (*)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   (*) also known as the "packet-in-error"]]></artwork>
            </figure></t>

          <t>TEs generate solicitation messages (e.g., an SCMP echo request,
          an SCMP router/neighbor solicitation, a SEAL data packet with A=1,
          etc.) for the purpose of triggering an SCMP response. TEs generate
          solicited SCMP messages (e.g., an SCMP echo reply, an SCMP
          router/neighbor advertisement, an SCMP PTB message, etc.) in
          response to explicit solicitations, and also generate SCMP error
          messages in response to errored SEAL data packets. As for ICMP, TEs
          must not generate SCMP error message in response to other SCMP
          messages.</t>

          <t>As for ordinary ICMPv6 messages, the SCMP message begins with a 4
          byte header that includes 8-bit Type and Code fields followed by a
          16-bit Checksum field followed by a variable-length Message Body.
          The TE sets the Type and Code fields to the same values that would
          appear in the corresponding ICMPv6 message and also formats the
          Message Body the same as for the corresponding ICMPv6 message.</t>

          <t>The Message Body is followed by the leading portion of the
          invoking SEAL data packet (i.e., the "packet-in-error") IFF the
          packet-in-error would also be included in the corresponding ICMPv6
          message. If the SCMP message will include a packet-in-error, the TE
          includes as much of the leading portion of the invoking SEAL data
          packet as possible beginning with the outer IP header and extending
          to a length that would not cause the entire SCMP packet following
          outer encapsulation to exceed 576 bytes (see: <xref
          target="scmpencaps"></xref>).</t>

          <t>The TE then calculates the SCMP message Checksum the same as
          specified for ICMPv6 messages except that it does not prepend a
          pseudo-header of the outer IP header since the Nonce and
          Identification values already give sufficient assurance against
          mis-delivery. (The Checksum calculation procedure is therefore
          identical to that used for ICMPv4 <xref target="RFC0792"></xref>.)
          The TE then encapsulates the SCMP message in the outer headers as
          shown in <xref target="scmpencaps"></xref>:</t>

          <t><figure anchor="scmpencaps" title="SCMP Message Encapsulation">
              <artwork><![CDATA[                                    +--------------------+
                                    ~  outer IPv4 header ~
                                    +--------------------+
                                    ~  other outer hdrs  ~
                                    +--------------------+
                                    ~    SEAL Header     ~
       +--------------------+       +--------------------+
       ~ SCMP message header~  -->  ~ SCMP message header~
       +--------------------+  -->  +--------------------+
       ~  SCMP message body ~  -->  ~  SCMP message body ~
       +--------------------+  -->  +--------------------+
       ~   packet-in-error  ~  -->  ~  packet-in-error   ~
       +--------------------+       +--------------------+
                                    ~   outer trailers   ~
            SCMP Message            +--------------------+
        before encapsulation
                                          SCMP Packet
                                      after encapsulation]]></artwork>
            </figure></t>

          <t>When a TE generates an SCMP message in response to an SCMP
          solicitation or an ordinary SEAL data packet (i.e., a "solicitation
          packet"), it sets the outer IP destination and source addresses of
          the SCMP packet to the solicitation's source and destination
          addresses (respectively). (If the destination address in the
          solicitation was multicast, the TE instead sets the outer IP source
          address of the SCMP packet to an address assigned to the underlying
          IP interface.) The TE then sets the Nonce and I flag in the SEAL
          header of the SCMP packet to the same values that appeared in the
          solicitation. If the I flag is set to 1, the TE also includes the
          Identification field that it received in the solicitation.</t>

          <t>When a TE generates an unsolicited SCMP message, it sets the
          outer IP destination and source addresses of the SCMP packet the
          same as it would for ordinary SEAL data packets. The TE then sets
          the Nonce and I flag in the SEAL header of the SCMP packet to the
          same values that it would use to send an ordinary SEAL data packet.
          If the I flag is set to 1, the TE also includes the Identification
          field that it received in the solicitation.</t>

          <t>For all SCMP messages, the TE then sets the other flag bits in
          the SEAL header to C=1, A=0, R=0, F=1, and M=0. It next sets the
          NEXTHDR/SEG field to 0 and sends the SCMP packet to the tunnel
          neighbor.</t>

          <section title="Generating SCMP Packet Too Big (PTB) Messages">
            <t>An ETE generates an SCMP "Packet Too Big" (PTB) message under
            one of the following cases:</t>

            <t><list style="symbols">
                <t>Case 0: when it receives the IP first fragment (i.e., one
                with MF=1 and Offset=0 in the outer IP header) of a SEAL
                protocol packet that arrived as multiple IP fragments, or:</t>

                <t>Case 1: when it has already received the SEAL first segment
                (i.e., one with F=1 and M=1 in the SEAL header) of a SEAL
                protocol packet that arrived as multiple SEAL segments, and
                accepting the current segment would cause the size of the
                reassembled packet to exceed S_MRU, or:</t>

                <t>Case 2: when it receives a SEAL protocol data packet with
                A=1 in the SEAL header that did not arrive as multiple IP
                fragments (i.e., one that does not also match Case 0).</t>
              </list></t>

            <t>The ETE prepares an SCMP PTB message the same as for the
            corresponding ICMPv6 PTB message, except that it writes the S_MRU
            value for this ITE in the MTU field (i.e., even if the S_MRU value
            is 0). For cases 0 and 2 above, the packet-in-error field includes
            the leading portion of the IP packet or fragment that triggered
            the condition. For case 1 above, the packet-in-error field
            includes the leading portion of the SEAL first segment, beginning
            with the encapsulating outer IP header.</t>

            <t>Finally, the ETE writes the value 0, 1 or 2 in the Code field
            of the PTB message according to whether the reason for generating
            the message was due to the corresponding case number from the list
            of cases above.</t>

            <t>NOTE CAREFULLY that, unlike cases 0 and 1 above, case 2 is not
            an error condition and does not necessarily signify packet loss.
            Instead, it is a control plane acknowledgement of a data plane
            probe. NOTE ALSO that if the ETE generates a Case 0 SCMP PTB
            message, then it MUST NOT also generate a Case 2 PTB message on
            behalf of the same SEAL segment.</t>
          </section>

          <section title="Generating SCMP Neighbor Discovery Messages">
            <t>An ITE generates an SCMP "Neighbor Solicitation" (SNS) or
            "Router Solicitation" (SRS) message when it needs to solicit a
            response from an ETE. An ETE generates a solicited SCMP "Neighbor
            Advertisement" (SNA) or "Router Advertisement" (SRA) message when
            it receives an SNS/SRS message. Any TE may also generate
            unsolicited SNA/SRA messages that are not triggered by a specific
            solicitation event.</t>

            <t>The TE generates SNS, SNA, SRS and SRA messages the same as
            described for the corresponding IPv6 Neighbor Discovery (ND)
            messages (see: <xref target="RFC4861"></xref>).</t>
          </section>

          <section title="Generating SCMP Redirect Messages">
            <t>An ETE generates an SCMP "Redirect" message when it receives a
            SEAL data packet with R=1 in the SEAL header and needs to inform
            the ITE of a better next hop. The ETE generates SCMP Redirect
            messages as described in <xref
            target="I-D.templin-intarea-vet"></xref>, and includes Route
            Information Options (RIOs) <xref target="RFC4191"></xref> to
            inform the ITE of a better next hop for a set of IP prefixes
            instead of only a single destination. The SCMP Redirect message
            therefore supports both network and host redirection instead of
            only host redirection.</t>
          </section>

          <section title="Generating Other SCMP Messages">
            <t>An ETE generates an SCMP "Destination Unreachable -
            Communication with Destination Administratively Prohibited"
            message when its association with the ITE is bidirectional and it
            receives a SEAL packet with a Nonce and/or Identification that
            does not correspond to this ITE (see: Section 4.7).</t>

            <t>An ETE generates an SCMP "Destination Unreachable" message with
            an appropriate code under the same circumstances that an IPv6
            system would generate an ICMPv6 Destination Unreachable message
            using the same code. The SCMP Destination Unreachable message is
            formatted the same as for ICMPv6 Destination Unreachable
            messages.</t>

            <t>An ETE generates an SCMP "Parameter Problem" message when it
            receives a SEAL packet with an incorrect value in the SEAL header,
            and generates an SCMP "Time Exceeded" message when it garbage
            collects an incomplete SEAL data packet reassembly. The message
            formats used are the same as for the corresponding ICMPv6
            messages.</t>

            <t>Generation of all other SCMP message types is outside the scope
            of this document.</t>
          </section>
        </section>

        <section title="Processing SCMP Messages">
          <t>An ITE processes any solicited and error SCMP message it receives
          as long as it can verify that the corresponding SCMP packet was sent
          from an on-path ETE. The ITE can verify that the SCMP packet came
          from an on-path ETE by checking that the Nonce and Identification
          values in the SEAL header of the packet corresponds to one of its
          recently-sent SEAL data packets or SCMP solicitation packets.</t>

          <t>For each solicited and error SCMP message it receives, the ITE
          first verifies that the identifying information is acceptable, then
          verifies that the Checksum in the SCMP message header is correct. If
          the identifying information and/or checksum are incorrect, the ITE
          discards the message; otherwise, it processes the message the same
          as for ordinary ICMPv6 messages.</t>

          <t>Any TE may also receive unsolicited SCMP messages (e.g., SNS,
          SRS, SNA, SRA, etc.) from the tunnel neighbor. The TE sends SCMP
          response messages in response to solicitations, but does not
          otherwise process the unsolicited SCMP messages as an indication of
          tunnel neighbor liveness.</t>

          <t>Finally, TEs process solicited and error SCMP messages as an
          indication that the tunnel neighbor is responsive, i.e., in the same
          manner implied for IPv6 Neighbor Unreachability Detection "hints of
          forward progress" (see: <xref target="RFC4861"></xref>).</t>

          <section title="Processing SCMP PTB Messages">
            <t>An ITE may receive an SCMP PTB message after it sends a SEAL
            data packet to an ETE (see: Section 4.6.1.1). The packet-in-error
            within the PTB message consists of the encapsulating IP/*/SEAL
            headers followed by the inner packet in the form in which the ITE
            received it prior to SEAL encapsulation.</t>

            <t>If the PTB message has Code=2 in the SCMP header the ITE
            processes the message as a response to an explicit probe request
            then discards the message. If the PTB has Code=0 or Code=1 in the
            SCMP header, however, the ITE processes the message as an
            indication of an MTU limitation.</t>

            <t>if the PTB has Code =0, the ITE first verifies that the outer
            IP header in the packet-in-error encodes an IP first fragment,
            then examines the outer IP header length field to determine a new
            S_MSS value as follows:</t>

            <t><list style="symbols">
                <t>If the length is no less than 1280, the ITE records the
                length as the new S_MSS value.</t>

                <t>If the length is less than the current S_MSS value and also
                less than 1280, the ITE can discern that IP fragmentation is
                occurring but it cannot determine the true MTU of the
                restricting link due to the possibility that a router on the
                path is generating runt first fragments.</t>
              </list>In this latter case, the ITE may need to search for a
            reduced S_MSS value through an iterative searching strategy that
            parallels the IPv4 Path MTU Discovery "plateau table" procedure in
            a similar fashion as described in Section 5 of <xref
            target="RFC1191"></xref>. This searching strategy may entail
            multiple iterations in which the ITE sends additional SEAL data
            packets using a reduced S_MSS and receives additional SCMP PTB
            messages, but the process should quickly converge. During this
            process, it is essential that the ITE reduce S_MSS based on the
            first SCMP PTB message received under the current S_MSS size, and
            refrain from further reducing S_MSS until SCMP PTB messages
            pertaining to packets sent under the new S_MSS are received.</t>

            <t>For both Code=0 and Code=1 PTB messages, the ITE next records
            the value in the MTU field of the SCMP PTB message as the new
            S_MRU value for this ETE and examines the inner packet within the
            packet-in-error. If the inner packet was unfragmentable (see:
            Section 4.4.3) and larger than (MAX(S_MRU, S_MSS) - HLEN), the ITE
            then sends a transcribed PTB message appropriate for the inner
            packet to the original source with MTU set to (MAX(S_MRU, S_MSS) -
            HLEN). (In the case of nested SEAL encapsulations, the transcribed
            PTB message will itself be an SCMP PTB message). If the inner
            packet is fragmentable, however, the ITE instead reduces its inner
            fragmentation S_IFT estimate to a size no larger than S_MSS for
            this ETE (see: Section 4.4.3) and does not send a transcribed PTB.
            In that case, some fragmentable packets may be silently discarded
            but future fragmentable packets will subsequently undergo inner
            fragmentation based on this new S_IFT estimate.</t>

            <t>The ITE may alternatively ignore the S_MSS and S_MRU values,
            thus disabling SEAL-layer segmentation. In that case, the ITE
            sends all SEAL-encapsulated packets as single segments and
            implements stateless MTU discovery. In that case, if the ITE
            receives an SCMP PTB message from the ETE with Code=0 and with a
            degenerate length value in the outer IP header, it can send a
            translated PTB message back to the source listing a slightly
            smaller MTU size than the length value in the inner IP header. For
            example, if the ITE receives an SCMP PTB message with Code=0,
            outer IP length 256 and inner IP length 1500, it can send a PTB
            message listing an MTU of 1400 back to the source. If the ITE
            subsequently receives an SCMP PTB message with Code=0, outer IP
            length 256 and inner IP length 1400, it can send a PTB message
            listing an MTU of 1300 back to the source, etc.</t>

            <t>Actual plateau table values for this "step-down" MTU
            determination procedure are up to the implementation, which may
            consult Section 7 of <xref target="RFC1191"></xref> for
            non-normative example guidance.</t>
          </section>

          <section title="Processing SCMP Neighbor Discovery Messages">
            <t>An ETE may receive SNS/SRS messages from an ITE as the initial
            leg in a neighbor discovery exchange. An ITE may also receive both
            solicited and unsolicited SNA/SRA messages from an ETE.</t>

            <t>The TE processes SNS/SRS and SNA/SRA messages the same as
            described for the corresponding IPv6 Neighbor Discovery (ND)
            messages (see: <xref target="RFC4861"></xref>).</t>
          </section>

          <section title="Processing SCMP Redirect Messages">
            <t>An ITE may receive SCMP Redirect messages after sending a SEAL
            data packet with R=1 in the SEAL header to an ETE. The ITE
            processes the Redirects as specified in <xref
            target="I-D.templin-intarea-vet"></xref>.</t>
          </section>

          <section title="Processing Other SCMP Messages">
            <t>An ITE may receive an SCMP "Destination Unreachable -
            Communication with Destination Administratively Prohibited"
            message after it sends a SEAL data packet to a bidirectional
            neighbor. The ITE processes the message as an indication that it
            needs to (re)synchronize with the ETE (see: Section 4.7).</t>

            <t>An ITE may receive other SCMP "Destination Unreachable"
            messages with an appropriate code under the same circumstances
            that an IPv6 node would receive an ICMPv6 Destination Unreachable
            message. The ITE processes the message the same as for the
            corresponding ICMPv6 Destination Unreachable messages.</t>

            <t>An ITE may receive an SCMP "Parameter Problem" message when the
            ETE receives a SEAL packet with an incorrect value in the SEAL
            header. The ITE should examine the incorrect SEAL header field
            setting to determine whether a different setting should be used in
            subsequent packets.</t>

            <t>.An ITE may receive an SCMP "Time Exceeded" message when the
            ETE garbage collects an incomplete SEAL data packet reassembly.
            The ITE should consider the message as an indication of
            congestion.</t>

            <t>Processing of all other SCMP message types is outside the scope
            of this document.</t>
          </section>
        </section>
      </section>

      <section title="Tunnel Endpoint Synchronization">
        <t>The tunnel neighbor relationship between a pair of SEAL TEs can be
        either unidirectional or bidirectional. A unidirectional relationship
        can be used when TE 'A' will tunnel data packets directly to TE 'B',
        but 'B' will not tunnel data packets directly to 'A'. A bidirectional
        relationship is necessary when both TEs will tunnel data packets
        directly to one another.</t>

        <t>In order to establish a bidirectional tunnel neighbor relationship,
        the initiating TE (call it "A") performs a reliable exchange (e.g., a
        short TCP transaction) with the responding TE (call it "B"). The
        application layer details of the transaction are out of scope for this
        document, and indeed need not be standardized as long as both TEs
        observe the same specifications. Note that a short transaction instead
        of a persistent connection is advised if the outer network layer
        protocol addresses may change, e.g., due to a mobility event, due to
        loss of state in network middleboxes, etc. If there is assurance that
        the outer network layer protocol addresses will not change, then a
        persistent connection may be used.</t>

        <t>During the transaction, "A" and "B" first authenticate themselves
        to each other, then exchange information regarding the inner network
        layer prefixes that will be used for conveying inner packets that will
        be forwarded over the tunnel. Both TEs then select one or more
        randomly-generated Nonces, where each Nonce represents a different
        underlying link over which the tunnel interface is configured. Both
        TEs then register their Nonces with each other to establish the
        appropriate bidirectional tunnel neighbor soft state (see Sections
        4.4.2 and 4.5.2).</t>

        <t>Following this bidirectional tunnel neighbor establishment, the TEs
        monitor the soft state for liveness, e.g., using Neighbor
        Unreachability Detection hints of forward progress. When one of the
        TEs wishes to terminate the relationship, it performs another short
        transaction to request the termination, then both TEs delete their
        respective tunnel soft state.</t>

        <t>Outbound and inbound traffic engineering between bidirectional
        tunnel neighbors is then coordinated by a link management agent that
        monitors the underlying link paths over which the tunnel is
        configured, and can remain continuous even if the paths through one or
        more of the underlying links has failed. When one TE detects that
        most/all underlying link paths to the other TE have failed, however,
        it terminates the bidirectional tunnel neighbor relationship.</t>

        <t>This bidirectional tunnel neighbor establishment is most commonly
        initiated by a client TE in establishing a connection with a serving
        TE, e.g., when a customer router within a home network establishes a
        connection with a serving router in a provider network, when a mobile
        handset connects with a serving router in a cellular operator network,
        etc.</t>
      </section>
    </section>

    <section title="Link Requirements">
      <t>Subnetwork designers are expected to follow the recommendations in
      Section 2 of <xref target="RFC3819"></xref> when configuring link
      MTUs.</t>
    </section>

    <section title="End System Requirements">
      <t>SEAL provides robust mechanisms for returning PTB messages; however,
      end systems that send unfragmentable IP packets larger than 1500 bytes
      are strongly encouraged to implement their own end-to-end MTU assurance,
      e.g., using Packetization Layer Path MTU Discovery per <xref
      target="RFC4821"></xref>.</t>
    </section>

    <section title="Router Requirements">
      <t>IPv4 routers within the subnetwork are strongly encouraged to
      implement IPv4 fragmentation such that the first fragment is the largest
      and approximately the size of the underlying link MTU, i.e., they should
      avoid generating runt first fragments.</t>

      <t>IPv6 routers within the subnetwork are required to generate the
      necessary PTB messages when they drop outer IPv6 packets due to an MTU
      restriction.</t>
    </section>

    <section title="IANA Considerations">
      <t>The IANA is instructed to allocate an IP protocol number for
      'SEAL_PROTO' in the 'protocol-numbers' registry.</t>

      <t>The IANA is instructed to allocate a Well-Known Port number for
      'SEAL_PORT' in the 'port-numbers' registry.</t>

      <t>The IANA is instructed to establish a "SEAL Protocol" registry to
      record SEAL Version values. This registry should be initialized to
      include the initial SEAL Version number, i.e., Version 0.</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>Unlike IPv4 fragmentation, overlapping fragment attacks are not
      possible due to the requirement that SEAL segments be non-overlapping.
      This condition is naturally enforced due to the fact that each
      consecutive SEAL segment begins at offset 0 with respect to the previous
      SEAL segment.</t>

      <t>An amplification/reflection attack is possible when an attacker sends
      IP first fragments with spoofed source addresses to an ETE, resulting in
      a stream of SCMP messages returned to a victim ITE. The Nonce and
      Identification values in the encapsulated segment of the spoofed IP
      first fragment provides mitigation for the ITE to detect and discard
      spurious SCMP messages.</t>

      <t>The SEAL header is sent in-the-clear (outside of any IPsec/ESP
      encapsulations) the same as for the outer IP and other outer headers. In
      this respect, the threat model is no different than for IPv6 extension
      headers. As for IPv6 extension headers, the SEAL header is protected
      only by L2 integrity checks and is not covered under any L3 integrity
      checks.</t>

      <t>SCMP messages carry the Nonce and Identification values of the
      packet-in-error. Therefore, when an ITE receives an SCMP message it can
      unambiguously associate it with the SEAL data packet that triggered the
      error. When the TEs are synchronized, the ETE can also detect off-path
      spoofing attacks.</t>

      <t>Security issues that apply to tunneling in general are discussed in
      <xref target="I-D.ietf-v6ops-tunnel-security-concerns"></xref>.</t>
    </section>

    <section title="Related Work">
      <t>Section 3.1.7 of <xref target="RFC2764"></xref> provides a high-level
      sketch for supporting large tunnel MTUs via a tunnel-level segmentation
      and reassembly capability to avoid IP level fragmentation, which is in
      part the same approach used by SEAL. SEAL could therefore be considered
      as a fully functioned manifestation of the method postulated by that
      informational reference.</t>

      <t>Section 3 of <xref target="RFC4459"> </xref> describes inner and
      outer fragmentation at the tunnel endpoints as alternatives for
      accommodating the tunnel MTU; however, the SEAL protocol specifies a
      mid-layer segmentation and reassembly capability that is distinct from
      both inner and outer fragmentation.</t>

      <t>Section 4 of <xref target="RFC2460"></xref> specifies a method for
      inserting and processing extension headers between the base IPv6 header
      and transport layer protocol data. The SEAL header is inserted and
      processed in exactly the same manner.</t>

      <t>The concepts of path MTU determination through the report of
      fragmentation and extending the IP Identification field were first
      proposed in deliberations of the TCP-IP mailing list and the Path MTU
      Discovery Working Group (MTUDWG) during the late 1980's and early
      1990's. SEAL supports a report fragmentation capability using bits in an
      extension header (the original proposal used a spare bit in the IP
      header) and supports ID extension through a 16-bit field in an extension
      header (the original proposal used a new IP option). A historical
      analysis of the evolution of these concepts, as well as the development
      of the eventual path MTU discovery mechanism for IP, appears in Appendix
      D of this document.</t>
    </section>

    <section title="SEAL Advantages over Classical Methods">
      <t>The SEAL approach offers a number of distinct advantages over the
      classical path MTU discovery methods <xref target="RFC1191"></xref>
      <xref target="RFC1981"></xref>:</t>

      <t><list style="numbers">
          <t>Classical path MTU discovery always results in packet loss when
          an MTU restriction is encountered. Using SEAL, IP fragmentation
          provides a short-term interim mechanism for ensuring that packets
          are delivered while SEAL adjusts its packet sizing parameters.</t>

          <t>Classical path MTU may require several iterations of dropping
          packets and returning PTB messages until an acceptable path MTU
          value is determined. Under normal circumstances, SEAL determines the
          correct packet sizing parameters in a single iteration.</t>

          <t>Using SEAL, ordinary packets serve as implicit probes without
          exposing data to unnecessary loss. SEAL also provides an explicit
          probing mode not available in the classic methods.</t>

          <t>Using SEAL, ETEs encapsulate SCMP error messages in outer and
          mid-layer headers such that packet-filtering network middleboxes
          will not filter them the same as for "raw" ICMP messages that may be
          generated by an attacker.</t>

          <t>The SEAL approach ensures that the tunnel either delivers or
          deterministically drops packets according to their size, which is a
          required characteristic of any IP link.</t>

          <t>Most importantly, all SEAL packets have Identification values
          that are sufficiently long to be used for duplicate packet detection
          purposes and to associate ICMP error messages with actual packets
          sent without requiring per-packet state; hence, SEAL avoids certain
          denial-of-service attack vectors open to the classical methods.</t>
        </list></t>
    </section>

    <section anchor="acknowledge" title="Acknowledgments">
      <t>The following individuals are acknowledged for helpful comments and
      suggestions: Jari Arkko, Fred Baker, Iljitsch van Beijnum, Oliver
      Bonaventure, Teco Boot, Bob Braden, Brian Carpenter, Steve Casner, Ian
      Chakeres, Noel Chiappa, Remi Denis-Courmont, Remi Despres, Ralph Droms,
      Aurnaud Ebalard, Gorry Fairhurst, Washam Fan, Dino Farinacci, Joel
      Halpern, Sam Hartman, John Heffner, Thomas Henderson, Bob Hinden,
      Christian Huitema, Eliot Lear, Darrel Lewis, Joe Macker, Matt Mathis,
      Erik Nordmark, Dan Romascanu, Dave Thaler, Joe Touch, Mark Townsley, Ole
      Troan, Margaret Wasserman, Magnus Westerlund, Robin Whittle, James
      Woodyatt, and members of the Boeing Research &amp; Technology NST
      DC&amp;NT group.</t>

      <t>Path MTU determination through the report of fragmentation was first
      proposed by Charles Lynn on the TCP-IP mailing list in 1987. Extending
      the IP identification field was first proposed by Steve Deering on the
      MTUDWG mailing list in 1989.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.0791"?>

      <?rfc include="reference.RFC.0792"?>

      <?rfc include="reference.RFC.4443"?>

      <?rfc include="reference.RFC.3971"?>

      <?rfc include="reference.RFC.4861"?>

      <?rfc include="reference.RFC.2119"?>

      <?rfc include="reference.RFC.2460"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1063"?>

      <?rfc include="reference.RFC.1191"?>

      <?rfc include="reference.RFC.1981"?>

      <?rfc include="reference.RFC.2003"?>

      <?rfc include="reference.RFC.2473"?>

      <?rfc include="reference.RFC.2923"?>

      <?rfc include="reference.RFC.3366"?>

      <?rfc include="reference.RFC.3819"?>

      <?rfc include="reference.RFC.4213"?>

      <?rfc include="reference.RFC.1812"?>

      <?rfc include="reference.RFC.4380"?>

      <?rfc include="reference.RFC.4301"?>

      <?rfc include="reference.RFC.4303"?>

      <?rfc include="reference.RFC.4459"?>

      <?rfc include="reference.RFC.4821"?>

      <?rfc include="reference.RFC.4963"?>

      <?rfc include="reference.RFC.2764"?>

      <?rfc include="reference.RFC.2675"?>

      <?rfc include="reference.RFC.5445"?>

      <?rfc include="reference.RFC.1070"?>

      <?rfc include="reference.RFC.3232"?>

      <?rfc include="reference.RFC.4191"?>

      <?rfc include="reference.RFC.4987"?>

      <?rfc include="reference.RFC.5720"?>

      <?rfc include="reference.I-D.templin-intarea-vet"?>

      <?rfc include="reference.RFC.6179"?>

      <?rfc include="reference.RFC.6139"?>

      <?rfc include="reference.RFC.5927"?>

      <?rfc include="reference.I-D.ietf-v6ops-tunnel-security-concerns"?>

      <?rfc include="reference.I-D.ietf-intarea-ipv4-id-update"?>

      <reference anchor="FRAG">
        <front>
          <title>Fragmentation Considered Harmful</title>

          <author fullname="Christopher Kent" initials="C" surname="Kent">
            <organization></organization>
          </author>

          <author fullname="Jeffrey Mogul" initials="J" surname="Mogul">
            <organization></organization>
          </author>

          <date month="October" year="1987" />
        </front>
      </reference>

      <reference anchor="FOLK">
        <front>
          <title>Beyond Folklore: Observations on Fragmented Traffic</title>

          <author fullname="Colleen Shannon" initials="C" surname="Shannon">
            <organization></organization>
          </author>

          <author fullname="David Moore" initials="D" surname="Moore">
            <organization></organization>
          </author>

          <author fullname="k claffy" initials="k" surname="claffy">
            <organization></organization>
          </author>

          <date month="December" year="2002" />
        </front>
      </reference>

      <reference anchor="MTUDWG">
        <front>
          <title>IETF MTU Discovery Working Group mailing list,
          gatekeeper.dec.com/pub/DEC/WRL/mogul/mtudwg-log, November 1989 -
          February 1995.</title>

          <author fullname="" initials="" surname="">
            <organization></organization>
          </author>

          <date month="" year="" />
        </front>
      </reference>

      <reference anchor="TCP-IP">
        <front>
          <title>Archive/Hypermail of Early TCP-IP Mail List,
          http://www-mice.cs.ucl.ac.uk/multimedia/misc/tcp_ip/, May 1987 - May
          1990.</title>

          <author fullname="" initials="" surname="">
            <organization></organization>
          </author>

          <date month="" year="" />
        </front>
      </reference>

      <reference anchor="TBIT">
        <front>
          <title>Measuring Interactions Between Transport Protocols and
          Middleboxes</title>

          <author fullname="Alberto Medina" initials="A" surname="Medina">
            <organization></organization>
          </author>

          <author fullname="Mark Allman" initials="M" surname="Allman">
            <organization></organization>
          </author>

          <author fullname="Sally Floyd" initials="S" surname="Floyd">
            <organization></organization>
          </author>

          <date month="October" year="2004" />
        </front>
      </reference>

      <reference anchor="WAND">
        <front>
          <title>Inferring and Debugging Path MTU Discovery Failures</title>

          <author fullname="Matthew Luckie" initials="M" surname="Luckie">
            <organization></organization>
          </author>

          <author fullname="Kenjiro Cho" initials="K" surname="Cho">
            <organization></organization>
          </author>

          <author fullname="Bill Owens" initials="B" surname="Owens">
            <organization></organization>
          </author>

          <date month="October" year="2005" />
        </front>
      </reference>

      <reference anchor="SIGCOMM">
        <front>
          <title>Measuring Path MTU Discovery Behavior</title>

          <author fullname="Matthew Luckie" initials="M" surname="Luckie">
            <organization></organization>
          </author>

          <author fullname="Ben Stasiewicz" initials="B" surname="Stasiewicz">
            <organization></organization>
          </author>

          <date month="November" year="2010" />
        </front>
      </reference>
    </references>

    <section title="Reliability">
      <t>Although a SEAL tunnel may span an arbitrarily-large subnetwork
      expanse, the IP layer sees the tunnel as a simple link that supports the
      IP service model. Since SEAL supports segmentation at a layer below IP,
      SEAL therefore presents a case in which the link unit of loss (i.e., a
      SEAL segment) is smaller than the end-to-end retransmission unit (e.g.,
      a TCP segment).</t>

      <t>Links with high bit error rates (BERs) (e.g., IEEE 802.11) use
      Automatic Repeat-ReQuest (ARQ) mechanisms <xref target="RFC3366"></xref>
      to increase packet delivery ratios, while links with much lower BERs
      typically omit such mechanisms. Since SEAL tunnels may traverse
      arbitrarily-long paths over links of various types that are already
      either performing or omitting ARQ as appropriate, it would therefore
      often be inefficient to also require the tunnel to perform ARQ.</t>

      <t>When the SEAL ITE has knowledge that the tunnel will traverse a
      subnetwork with non-negligible loss due to, e.g., interference, link
      errors, congestion, etc., it can solicit Segment Reports from the ETE
      periodically to discover missing segments for retransmission within a
      single round-trip time. However, retransmission of missing segments may
      require the ITE to maintain considerable state and may also result in
      considerable delay variance and packet reordering.</t>

      <t>SEAL may also use alternate reliability mechanisms such as Forward
      Error Correction (FEC). A simple FEC mechanism may merely entail
      gratuitous retransmissions of duplicate data, however more efficient
      alternatives are also possible. Basic FEC schemes are discussed in <xref
      target="RFC5445"></xref>.</t>

      <t>The use of ARQ and FEC mechanisms for improved reliability are for
      further study.</t>
    </section>

    <section title="Integrity">
      <t>Each link in the path over which a SEAL tunnel is configured is
      responsible for link layer integrity verification for packets that
      traverse the link. As such, when a multi-segment SEAL packet with N
      segments is reassembled, its segments will have been inspected by N
      independent link layer integrity check streams instead of a single
      stream that a single segment SEAL packet of the same size would have
      received. Intuitively, a reassembled packet subjected to N independent
      integrity check streams of shorter-length segments would seem to have
      integrity assurance that is no worse than a single-segment packet
      subjected to only a single integrity check steam, since the integrity
      check strength diminishes in inverse proportion with segment length. In
      any case, the link-layer integrity assurance for a multi-segment SEAL
      packet is no different than for a multi-fragment IPv6 packet.</t>

      <t>Fragmentation and reassembly schemes must also consider
      packet-splicing errors, e.g., when two segments from the same packet are
      concatenated incorrectly, when a segment from packet X is reassembled
      with segments from packet Y, etc. The primary sources of such errors
      include implementation bugs and wrapping IP ID fields. In terms of
      implementation bugs, the SEAL segmentation and reassembly algorithm is
      much simpler than IP fragmentation resulting in simplified
      implementations. In terms of wrapping ID fields, when IPv4 is used as
      the outer IP protocol, the 16-bit IP ID field can wrap with only 64K
      packets with the same (src, dst, protocol)-tuple alive in the system at
      a given time <xref target="RFC4963"></xref> increasing the likelihood of
      reassembly mis-associations. However, SEAL ensures that any outer IPv4
      fragmentation and reassembly will be short-lived and tuned out as soon
      as the ITE receives an SCMP PTB mesage, and SEAL segmentation and
      reassembly uses a much longer Identification field. Therefore,
      reassembly mis-associations of IP fragments nor of SEAL segments should
      be prohibitively rare.</t>
    </section>

    <section title="Transport Mode">
      <t>SEAL can also be used in "transport-mode", e.g., when the inner layer
      comprises upper-layer protocol data rather than an encapsulated IP
      packet. For instance, TCP peers can negotiate the use of SEAL (e.g., by
      inserting a 'SEAL_OPTION' TCP option during connection establishment)
      for the carriage of protocol data encapsulated as IPv4/SEAL/TCP. In this
      sense, the "subnetwork" becomes the entire end-to-end path between the
      TCP peers and may potentially span the entire Internet.</t>

      <t>If both TCPs agree on the use of SEAL, their protocol messages will
      be carried as IPv4/SEAL/TCP and the connection will be serviced by the
      SEAL protocol using TCP (instead of an encapsulating tunnel endpoint) as
      the transport layer protocol. The SEAL protocol for transport mode
      otherwise observes the same specifications as for Section 4.</t>
    </section>

    <section title="Historic Evolution of PMTUD">
      <t>The topic of Path MTU discovery (PMTUD) saw a flurry of discussion
      and numerous proposals in the late 1980's through early 1990. The
      initial problem was posed by Art Berggreen on May 22, 1987 in a message
      to the TCP-IP discussion group <xref target="TCP-IP"></xref>. The
      discussion that followed provided significant reference material for
      [FRAG]. An IETF Path MTU Discovery Working Group <xref
      target="MTUDWG"></xref> was formed in late 1989 with charter to produce
      an RFC. Several variations on a very few basic proposals were
      entertained, including:</t>

      <t><list style="numbers">
          <t>Routers record the PMTUD estimate in ICMP-like path probe
          messages (proposed in [FRAG] and later <xref
          target="RFC1063"></xref>)</t>

          <t>The destination reports any fragmentation that occurs for packets
          received with the "RF" (Report Fragmentation) bit set (Steve
          Deering's 1989 adaptation of Charles Lynn's Nov. 1987 proposal)</t>

          <t>A hybrid combination of 1) and Charles Lynn's Nov. 1987 (straw
          RFC draft by McCloughrie, Fox and Mogul on Jan 12, 1990)</t>

          <t>Combination of the Lynn proposal with TCP (Fred Bohle, Jan 30,
          1990)</t>

          <t>Fragmentation avoidance by setting "IP_DF" flag on all packets
          and retransmitting if ICMPv4 "fragmentation needed" messages occur
          (Geof Cooper's 1987 proposal; later adapted into <xref
          target="RFC1191"></xref> by Mogul and Deering).</t>
        </list></t>

      <t>Option 1) seemed attractive to the group at the time, since it was
      believed that routers would migrate more quickly than hosts. Option 2)
      was a strong contender, but repeated attempts to secure an "RF" bit in
      the IPv4 header from the IESG failed and the proponents became
      discouraged. 3) was abandoned because it was perceived as too
      complicated, and 4) never received any apparent serious consideration.
      Proposal 5) was a late entry into the discussion from Steve Deering on
      Feb. 24th, 1990. The discussion group soon thereafter seemingly lost
      track of all other proposals and adopted 5), which eventually evolved
      into <xref target="RFC1191"></xref> and later <xref
      target="RFC1981"></xref>.</t>

      <t>In retrospect, the "RF" bit postulated in 2) is not needed if a
      "contract" is first established between the peers, as in proposal 4) and
      a message to the MTUDWG mailing list from jrd@PTT.LCS.MIT.EDU on Feb 19.
      1990. These proposals saw little discussion or rebuttal, and were
      dismissed based on the following the assertions:</t>

      <t><list style="symbols">
          <t>routers upgrade their software faster than hosts</t>

          <t>PCs could not reassemble fragmented packets</t>

          <t>Proteon and Wellfleet routers did not reproduce the "RF" bit
          properly in fragmented packets</t>

          <t>Ethernet-FDDI bridges would need to perform fragmentation (i.e.,
          "translucent" not "transparent" bridging)</t>

          <t>the 16-bit IP_ID field could wrap around and disrupt reassembly
          at high packet arrival rates</t>
        </list>The first four assertions, although perhaps valid at the time,
      have been overcome by historical events. The final assertion is
      addressed by the mechanisms specified in SEAL.</t>
    </section>
  </back>
</rfc>
