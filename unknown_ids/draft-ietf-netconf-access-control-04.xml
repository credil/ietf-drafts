<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY rfc2865 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2865.xml'>
    <!ENTITY rfc3688 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3688.xml'>
    <!ENTITY rfc5277 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5277.xml'>
    <!ENTITY rfc5607 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5607.xml'>
    <!ENTITY rfc6020 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6020.xml'>
    <!ENTITY rfc6021 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6021.xml'>
<!-- not used.  add a reference?
    <!ENTITY xmlspec PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml2/reference.W3C.REC-xml.xml'>
-->
    <!ENTITY netconfspec PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-netconf-4741bis.xml'>
    <!ENTITY netconfsshspec PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-netconf-rfc4742bis.xml'>
]>

<rfc category="std" 
     docName="draft-ietf-netconf-access-control-04" 
     ipr="trust200902">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes"?>
<?rfc comments="no" ?>
<?rfc inline="no" ?>
<?rfc editing="no" ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="no" ?>
<?rfc compact="no"?>
<?rfc iprnotified="no"?>

 <front>
  <title abbrev="NACM">
    Network Configuration Protocol Access Control Model
  </title>
  <author fullname="Andy Bierman" 
          initials="A.B."
          surname="Bierman">
   <organization>Brocade</organization>
   <address>
     <email>andy.bierman@brocade.com</email>
   </address>
  </author>
  <author fullname="Martin Bjorklund" 
          initials="M.B."
          surname="Bjorklund">
   <organization>Tail-f Systems</organization>
   <address>
    <email>mbj@tail-f.com</email>
   </address>
  </author>

  <date />
  <area>Management</area>
  <workgroup>Internet Engineering Task Force</workgroup>
  <keyword>NETCONF</keyword>
  <keyword>YANG</keyword>
  <keyword>XML</keyword>
  <abstract>
   <t>
    The standardization of network configuration interfaces for use 
    with the NETCONF protocol requires a structured and secure 
    operating environment that promotes human usability and 
    multi-vendor interoperability.  There is a need for standard
    mechanisms to restrict NETCONF protocol access for particular
    users to a pre-configured subset of all available NETCONF
    operations and content.  This document discusses requirements
    for a suitable access control model, and provides one solution
    that meets these requirements.
   </t>
  </abstract>
 </front>

 <middle>
  <section title="Introduction">
    <t>
      The NETCONF protocol does not provide any standard mechanisms to
      restrict the operations and content that each user is authorized
      to use.
    </t>
    <t>
      There is a need for inter-operable management of the
      controlled access to operator selected portions of the
      available NETCONF content within a particular server.
    </t>
    <t>
      This document addresses access control mechanisms for the
      Operation and Content layers of NETCONF, as defined in <xref
      target="I-D.ietf-netconf-4741bis"/>, and <xref
      target="RFC5277"/>.  It contains three main sections:
      <list style="numbers">
        <t>Access Control Design Objectives</t>
        <t>NETCONF Access Control Model (NACM)</t>
        <t>YANG Data Model (ietf-netconf-acm.yang)</t>
      </list>
    </t>

    <section title="Terminology">
      <section title="Requirements Notation">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119"/>.
        </t>
      </section>

      <section title="NETCONF Terms">
        <t>
          The following terms are defined in 
          <xref target="I-D.ietf-netconf-4741bis"/> and 
          are not redefined here:
          <list style="symbols">
            <t>client</t>
            <t>datastore</t>
            <t>operation</t>
            <t>protocol operation</t>
            <t>server</t>
            <t>session</t>
            <t>user</t>
          </list>
        </t>
      </section>

      <section title="YANG Terms">
        <t>
          The following terms are defined in 
          <xref target="RFC6020"/> and 
          are not redefined here:
          <list style="symbols">
            <t>data node</t>
            <t>data definition statement</t>
          </list>
        </t>
      </section>

      <section title="NACM Terms">
        <t>
          The following terms are used throughout this documentation:
          <list style="hanging">
            <t hangText="access control:">
              A security feature provided by the NETCONF server,
              that allows an operator to restrict access to a
              subset of all NETCONF protocol operations and data,
              based on various criteria.
            </t>
            <t hangText="access control model (ACM):">
              A conceptual model used to configure and monitor
              the access control procedures desired by the operator
              to enforce a particular access control policy.
            </t>
            <t hangText="access control rule:">
              The conceptual criteria used to determine if a
              particular NETCONF protocol operation will be
              permitted or denied.
            </t>
            <t hangText="access operation:">
	      How a request attempts to access a conceptual object.
	      One of "read", "create", "delete", "update", and
	      "execute".
	    </t>
            <t hangText="recovery session:">
              A special administrative session that is given
              unlimited NETCONF access, and is exempt from all access 
              control enforcement.  The specific mechanism(s) used
              by an implementation to control and identify whether
              a session is a recovery session or not are outside
              the scope of this document.
            </t>
          </list>
        </t>
      </section>
    </section>
  </section>

  <section title="Access Control Design Objectives">
    <t>
      [Editor's note: some things described here are requirements
      (MUST, SHOULD, etc), but some things are descriptions how NACM
      works, e.g. 2.4.1, 2.4.3...]
    </t>

    <section title="Protocol Control Points">
      <t>
        The NETCONF protocol allows new operations to be
        added at any time, and the YANG data modeling language
        supports this feature.  It is not possible to
        design an ACM for NETCONF which
        only focuses on a static set of operations,
        like some other protocols.  Since few assumptions
        can be made about an arbitrary protocol operation,
        the NETCONF architectural server components need to
        be protected at several conceptual control points.
      </t>
      <t>
        <figure anchor="control_points">
          <artwork><![CDATA[
              +-------------+          +-------------+
 client       |  protocol   |          |   prune     |      client
 request -->  |  operation  |          | restricted  | ---> reply
              |  allowed?   |          | <rpc-reply> |
              +-------------+          |   nodes?    |
                    |                  +-------------+
                    | if any datastore or
                    | state data is accessed
                    | by the operation
                    V
              +-------------+          +----------------+
              |  data node  |          |   prune        | 
              |   access    |          | restricted     |
              |  allowed?   |          | <notification> | ---> client
              +-------------+          | event or data? |     session
                                       +----------------+
            ]]>
          </artwork>
        </figure>
      </t>
      <t>
        The following access control points are defined:
        <list style="hanging">
          <t hangText="protocol operation:">
            Configurable permission to invoke specific protocol operations
            is required.  Wildcard or multiple target mechanisms
            to reduce configuration and effort are also required.
          </t>
          <t hangText="NETCONF datastore:">
            Configurable permission to read and/or alter
            specific data nodes within any conceptual datastore
            is required.  Wildcard or multiple target mechanisms
            to reduce configuration and effort are also required.
          </t>
          <t hangText="RPC Reply Content:">
            Configurable permission to read
            specific data nodes within any conceptual RPC output
            section is required.  Unauthorized data is
            silently omitted from the reply, instead of
            dropping the reply or sending an "access-denied" error.
          </t>
          <t hangText="Notification Content:">
            Configurable permission to receive
            specific notification event types
            is required.
          </t>
        </list>
      </t>           
    </section>
    <section title="Simplicity">
      <t>
        Experience has shown that a complicated ACM will not
        be widely deployed, because it is too hard to use.
        The key factor that is ignored in such solutions
        is the concept of "localized cost".  It needs to
        be easy to do simple things, and possible to do
        complex things, instead of hard to do everything.
      </t>
      <t>
        Configuration of the access control system needs to be as
        simple as possible.  Simple and common tasks need to be easy
        to configure, and require little expertise or domain-specific
        knowledge.  Complex tasks are possible using additional
        mechanisms, which may require additional expertise.
      </t>
      <t>
        A single set of access control rules SHOULD be able
        to control all types of NETCONF protocol operation invocation, 
        all conceptual datastore access, and all NETCONF session output.
      </t>
      <t>
        Access control SHOULD be defined with a small and familiar 
        set of permissions, while still allowing full control
        of NETCONF datastore access.
      </t>
      <t>
        Access control does not need to be applied to NETCONF &lt;hello&gt;
        messages.
      </t>
    </section>
    <section title="Procedural Interface">
      <t>
        The NETCONF protocol uses a procedural interface model,
        and an extensible set of protocol operations.
        Access control for any possible protocol operation is required.
      </t>
      <t>
        It MUST be possible to configure the ACM to permit or 
        deny access to specific NETCONF operations.
      </t>
      <t>
        YANG modules SHOULD be designed so that different access
        levels for input parameters to protocol operations is not required.
        Use of generic operations should be avoided, and separate
        operations defined instead, if different access levels are needed.
      </t>
    </section>
    <section title="Datastore Access">
      <t>
        It MUST be possible to control access to specific nodes
        and subtrees within the conceptual NETCONF datastore.
      </t>
      <t>
        The same access control rules apply to all conceptual
        datastores.  For example, the candidate configuration
        or the running configuration.
      </t>
      <t>
        Only the standard NETCONF datastores (candidate, running,
        and startup) are controlled by the ACM.  Local or remote
        files or datastores accessed via the &lt;url&gt;
        parameter are optional to support.
      </t>
      <t>
        The non-volatile startup configuration needs to be loaded
        at boot-time into the running configuration without applying any
        access control rules.  Access control is applied
        after the server has booted, and user sessions are active.
      </t>

      <section title="Access Rights">
        <t>
          A small set of hard-wired datastore access rights is needed
          to control access to all possible NETCONF datastore operations,
          including vendor extensions to the standard operation set.
        </t>
        <t>
          The familiar "CRUDX" model can support all NETCONF operations:
          <list style="symbols">
            <t>
              Create:  Allows the client to add a new data node 
              instance to a datastore.
            </t>
            <t>
              Read: Allows the client to read a data node instance 
              from a datastore, or receive the notification event type.
            </t>
            <t>
              Update: Allows the client to update an existing data 
              node instance in a datastore.
            </t>
            <t>
              Delete: Allows the client to delete a data node 
              instance from a datastore.
            </t>
            <t>
              eXec: Allows the client to execute the protocol operation.
            </t>
          </list>
        </t>
      </section>

      <section title="&lt;get&gt; and &lt;get-config&gt; Operations">
        <t>
          Data nodes to which the client does not have read access,
          either directly or via wildcard access, are silently omitted
          from the &lt;rpc-reply&gt; message.  This is done to
          allow NETCONF filters for &lt;get&gt; and &lt;get-config&gt;
          to function properly,
          instead of causing an "access-denied" error because
          the filter criteria would otherwise include unauthorized
          read access to some data nodes.  For NETCONF filtering 
          purposes, the selection criteria is applied to the
          subset of nodes that the client is authorized to read,
          not the entire datastore.
        </t>
      </section>

      <section title="&lt;edit-config&gt; Operation">
        <t>
          The NACM access rights are not directly coupled to the
          &lt;edit-config&gt; "operation" attribute, although they are
          similar.  Instead, a NACM access right applies to all
          operations which would result in a particular access
          operation to the target datastore. This section describes
          how these access rights apply to the specific datastore
          operations supported by the &lt;edit-config&gt; operation.
        </t>
        <t>
          If the effective operation is "none"
          (i.e., default-operation="none")
          for a particular data node, 
          then no access control is applied to that data node.
        </t>
        <t>
          A "create", "merge", or "replace" operation on a datastore node
          which would result in the creation of a new data node instance,
          for which the user does not have "create" access permission, is
          rejected with an "access-denied" error.
        </t>
        <t>
          A "merge" or "replace" operation on a datastore node
          which would result in the modification of an existing 
          data node instance,
          for which the user does not have "update" access permission, is
          rejected with an "access-denied" error.
        </t>
        <t>
          A "replace", "delete", or "remove" operation on a datastore
          node which would result in the deletion of an existing data
          node instance, for which the user does not have "delete"
          access permission, is rejected with an "access-denied"
          error.
        </t>
        <t>
          A "merge" operation may include data nodes which do not alter
          portions of the existing datastore.  For example, a 
          container or list node 
          may be present for naming purposes, but does not actually alter
          the corresponding datastore node.  These unaltered data nodes 
          within the
          scope of a "merge" operation are ignored by the server,
          and do not require any access rights by the client.
        </t>
	<t>
	  [Editor's note: ditto for "replace" (and copy-config...)
	  Note that with this rule, a client w/o read access can guess
	  db content by sending merge requests - if access-denied is
	  not returned, it means the db has that value.]
	</t>
        <t>
          A "merge" operation may include data nodes, but not include
          particular child data nodes that are present in the datastore.
          These missing data nodes within the
          scope of a "merge" operation are ignored by the server,
          and do not require any access rights by the client.
        </t>
        <t>
          The contents of specific restricted datastore nodes MUST NOT
          be exposed in any &lt;rpc-error&gt; elements
          within the reply.
        </t>
      </section>

      <section title="&lt;copy-config&gt; Operation">
        <t>
          Access control for the &lt;copy-config&gt; operation
          requires special consideration because the operator is
          replacing the entire target datastore.  Read access to the
          entire source datastore, and write access to the entire
          target datastore is needed for this operation to succeed.
        </t>
	<t>
          The server SHOULD determine the exact nodes in the
          target datastore which are actually different,
          and only check write access permissions for this
          set of nodes, which could be empty.
          
	  For example, if a session can read the entire datastore, 
          but only change one leaf, that session SHOULD be
	  able to edit and save that one leaf.
          E.g., the &lt;copy-config&gt; operation from 
          &lt;running&gt; to &lt;startup&gt; SHOULD succeed
          if the only effective changes are for data nodes that session
          is authorized to change.
	</t>
        <t>
          A client MUST have access to every datastore node, even ones that are
          not present in the source configuration data.
        </t>
        <t>
          For example, consider a common use-case such as a simple
          backup and restore procedure.  The operator (client) MUST
          have full read access to the datastore in order to receive a
          complete copy of its contents.  If the server simply omits
          these subtrees from the reply, and that copy is later used
          to restore the server datastore, the server will interpret
          the missing nodes as a request to delete those nodes, and
          return an error.
        </t>
      </section>
    </section>

    <section title="Users and Groups">
      <t>
        The server MUST obtain a user name from the
        underlying NETCONF transport, such as an SSH
        user name.
      </t>
      <t>
        It MUST be possible to specify access control rules
        for a single user or a configurable group of users.
      </t>
      <t>
        The ACM MUST support the concept of administrative groups,
        to support the well-established distinction between
        a root account and other types of less-privileged
        conceptual user accounts.
        These groups MUST be configurable by the operator.
      </t>
      <t>
        It MUST be possible to delegate the user-to-group mapping to a
        central server, such as a RADIUS server <xref
        target="RFC2865"/> <xref target="RFC5607"/>.  Since
        authentication is performed by the NETCONF transport layer,
        and RADIUS performs authentication and service authorization
        at the same time, it MUST be possible for the underlying
        NETCONF transport to report a set of group names associated
        with the user to the server.
      </t>
    </section>
    <section title="Maintenance">
      <t>
        It SHOULD be possible to disable part or all of the
        access control model without deleting any configuration.
      </t>
    </section>
    <section title="Configuration Capabilities">
      <t>
        Suitable control and monitoring mechanisms
        are needed to allow an operator to easily manage all
        aspects of the ACM behavior. A standard data model,
        suitable for use with the &lt;edit-config&gt; operation
        MUST be available for this purpose.
      </t>
      <t>
        Access control rules to restrict operations on specific 
        subtrees within the configuration datastore MUST
        be supported. Existing mechanisms
        can be used to identify the subtree(s) for this purpose.
      </t>
    </section>
    <section title="Identifying Security Holes">
      <t>
        One of the most important aspects of the data model
        documentation, and biggest concerns during deployment,
        is the identification of security-sensitive content.
        This applies to operations in NETCONF, not just data
        and notifications.
      </t>
      <t>
        It is mandatory for security-sensitive objects
        to be documented in the Security Considerations
        section of an RFC.  This is nice, but it
        is not good enough, for the following reasons:
        <list style="symbols">
          <t>
            This documentation-only approach forces operators to
            study the RFC and determine if there are any
            potential security holes introduced by a new
            YANG module.
          </t>
          <t>
            If any security holes are identified, then 
            the operator can study some more RFC text, 
            and determine how to close the security hole(s).
          </t>
          <t>
            The ACM on each server can be configured to
            close the security holes, e.g., require
            privileged access to read or write the
            specific data identified in the Security
            Considerations section.
          </t>
          <t>
            If the ACM is not pre-configured, then there
            will be a time window of vulnerability,
            after the new module is loaded, and before
            the new access control rules for that module
            are configured, enabled, and debugged.
          </t>
        </list>
      </t>
      <t>
        Often, the operator just wants to disable
        default access to the secure content, so
        no inadvertent or malicious changes can be made
        to the server.  This allows the default rules
        to be more lenient, without significantly
        increasing the security risk.
      </t>
      <t>
        A data model designer needs to be able to 
        use machine-readable statements to identify
        NETCONF content which needs to be protected by default.
        This will allow client and server tools to automatically
        close data-model specific security holes, by
        denying access to sensitive data unless the user is
        explicitly authorized to perform the requested operation.
      </t>
    </section>
    <section title="Data Shadowing">
      <t>
        One of the more complicated security administration problems is
        identifying data nodes which shadow or mirror the content of
        another data node.  An access control rule to prevent read
        operations for a particular node may be insufficient
        to prevent access to the data node with the copied value.
      </t>
      <t>
        If the description statement, other documentation, or
        no documentation exists to identify a data shadow problem,
        then it may not be detected.
      </t>
      <t>
        Since NETCONF allows any vendor operation to be added
        to the protocol, there is no way to reliably identify
        all of the operations that may expose copies of sensitive 
        data nodes in &lt;rpc-reply&gt; messages.
      </t>
      <t>
        A NETCONF server MUST ensure that unauthorized access to
        its conceptual datastores and non-configuration data nodes
        is prevented.
      </t>
      <t>
        It is beyond the
        scope of this document to define access control enforcement
        procedures for underlying device instrumentation that may
        exist to support the NETCONF server operation.  An operator
        can identify each operation that the server provides,
        and decide if it needs any access control applied to it.
      </t>
      <t>
        Proprietary protocol operations SHOULD be properly documented 
        by the vendor,
        so it is clear to operators what data nodes (if any) are affected by
        the operation, and what information (if any) is returned
        in the &lt;rpc-reply&gt; message.
      </t>
    </section>

    <section title="NETCONF Specific Requirements">
      <t>
        The server MUST be able to identify the specific protocol
        access request at the 4 access control points defined above.
      </t>
      <t>
        The server MUST be able to identify any datastore access
        request, even for proprietary operations.
      </t>
      <t>
        A client MUST always be authorized to
        invoke the &lt;close-session&gt; operation,
        defined in <xref target="I-D.ietf-netconf-4741bis"/>.
      </t>
      <t>
        A client MUST always be authorized to
        receive the &lt;replayComplete&gt; and
        &lt;notificationComplete&gt; notification events,
        defined in <xref target="RFC5277"/>
      </t>
      <t>
        The set of module name strings used within
        one particular server MUST be unique.
      </t>
    </section>
  </section>

  <section title="NETCONF Access Control Model (NACM)"
	   anchor="acm">
    <section title="Introduction">
      <t>
        This section provides a high-level overview of the
        access control model structure.  It describes the
        NETCONF protocol message processing model, and the conceptual
        access control requirements within that model.
      </t>

      <section title="Features">
        <t>
          The NACM data model provides the following features:
          <list style="symbols">
            <t>
              Independent control of RPC, data, and notification
              access.
            </t>
            <t>
              Simple access control rules configuration
              data model that is easy to use.
            </t>
            <t>
              The concept of an emergency recovery session 
              is supported, but configuration of the server
              for this purpose is beyond the scope of this document.
              An emergency recovery session will bypass all access 
              control enforcement, in order to allow it to 
              initialize or repair the NACM configuration.
            </t>
            <t>
              A simple and familiar set of datastore permissions is
              used.
            </t>
            <t>
              Support for YANG security tagging (e.g., 
              nacm:secure extension) allows default security
              modes to automatically exclude sensitive data.
            </t>
            <t>
              Separate default access modes for read, write, and
              execute permissions.
            </t>
            <t>
              Access control rules are applied to configurable groups
              of users.
            </t>
            <t>
              The entire ACM can be disabled during
              operation, in order to debug operational problems.
            </t>
            <t>
              Access control rules are simple to configure.
            </t>
            <t>
              The number of denied protocol operation requests
              and denied datastore write requests can be
              monitored by the client.
            </t>
            <t>
              Simple unconstrained YANG instance identifiers
              are used to configure access control rules for
              specific data nodes.
            </t>
	    <!--
		FIXME: should we define any std debug mechansisms,
		e.g. an operation which would report any non-reachable
		rules?   some way to log triggered rules?
	    -->

          </list>
        </t>
      </section>

      <section title="External Dependencies">
        <t>
          The <xref target="I-D.ietf-netconf-4741bis">NETCONF</xref> protocol
          is used for all management purposes within this document.
          It is expected that the mandatory transport mapping
          <xref target="I-D.ietf-netconf-rfc4742bis">NETCONF Over SSH</xref> is
          also supported by the server, and that the server has
          access to the user name associated with each session.
        </t>
        <t>
          The <xref target="RFC6020">
            YANG Data Modeling Language</xref>
          is used to define the NETCONF data models
          specified in this document.
        </t>
      </section>

      <section title="Message Processing Model">
        <t>
          The following diagram shows the NETCONF message
          flow model, including the points at which access
          control is applied, during NETCONF message processing.
        </t>

        <t>
          <figure anchor="NACM_model">
            <artwork>
<![CDATA[
                 +-------------------------+
                 |       session           |
                 |      (username)         |
                 +-------------------------+
                    |                 ^
                    V                 |
          +--------------+     +---------------+
          |   message    |     |   message     |
          | dispatcher   |     |   generator   |
          +--------------+     +---------------+
               |                  ^         ^
               V                  |         |
      +===========+     +-------------+   +----------------+
      |   <rpc>   |---> | <rpc-reply> |   | <notification> |
      | acc. ctl  |     |  generator  |   |  generator     |
      +===========+     +-------------+   +----------------+
            |              ^    ^                ^
            V       +------+    |                |
      +-----------+ |   +=============+  +================+
      |   <rpc>   | |   | <rpc-reply> |  | <notification> |
      | processor |-+   |  acc. ctl   |  |  access ctl    |
      +-----------+     +=============+  +================+
            |   |                  ^        ^
            V   +----------------+ |        |
      +===========+              | |        |
      | data node |              | |        |
      | acc. ctl  | -----------+ | |        |
      +===========+            | | |        |
            |                  | | |        |
            V                  V V |        |
      +---------------+      +-----------------+
      | configuration | ---> |     server      |
      |   datastore   |      | instrumentation |
      |               | <--- |                 |
      +---------------+      +-----------------+

]]>
            </artwork>
          </figure>
        </t>
        <t>
          The following high-level sequence of conceptual processing steps
          is executed for each received &lt;rpc&gt; message,
          if access control enforcement is enabled:
         <list style="symbols">
           <t>
             Access control is applied to all &lt;rpc&gt; messages
             (except &lt;close-session&gt;)
             received by the server, individually, for each active session,
             unless the session is identified as a "recovery session".
           </t>
           <t>
             If the session is authorized to execute the specified RPC
             operation, then processing continues, otherwise
             the request is rejected with an "access-denied" error.
           </t>
           <t>
             If the configuration datastore or conceptual state data
             is accessed by the protocol operation,
             then the data node access MUST be authorized.
             If the session is authorized to perform the requested
             operation on the requested data, then processing continues.
           </t>
         </list>
       </t>

       <t>
         The following sequence of conceptual processing steps
         is executed for each generated notification event,
         if access control enforcement is enabled:
         <list style="symbols">
           <t>
             Server instrumentation generates a conceptual notification,
             for a particular subscription.
           </t>
           <t>
             The notification access control enforcer checks the
             notification event type, and if it is one which
             the session is not authorized to read, then the
             notification is dropped for that subscription.
           </t>
         </list>
       </t>
      </section>
    </section>

    <section title="Model Components">
      <t>
        This section defines the conceptual components
        related to access control model.
      </t>

     <section title="Users">
       <t>
         A "user" is the conceptual entity that is associated
         with the access permissions granted to a particular session.
         A user is identified by a string which MUST be unique 
         within the server.
       </t>
       <t>
         As described in <xref target="I-D.ietf-netconf-4741bis"/>,
         the user name string is derived from the transport layer
         during session establishment.  If the transport layer cannot
         authenticate the user, the session is terminated.
       </t>
       <t>
         The server MAY support a "recovery session" mechanism,
         which will bypass all access control enforcement.
         This is useful for restricting initial access
         and repairing a broken access control configuration.
       </t>
     </section>

     <section title="Groups">
       <t>
         Access to a specific NETCONF operation is granted to
         a session, associated with a group, not a user.
       </t>
       <t>
         A group is identified by its name.  All group names MUST be
         unique within the server.
       </t>
       <t>
         A group member is identified by a user name string.
       </t>
       <t>
         The same user may be configured in multiple groups.
       </t>
     </section>

     <section title="Sessions">
       <t>
         A session is simply a NETCONF session, which is the
         entity that is granted access to specific NETCONF
         operations.
       </t>
       <t>
         A session is associated with a single user name for the
         lifetime of the session.
       </t>
     </section>

     <section title="Access Permissions">
       <t>
         The access permissions are the NETCONF protocol specific
         set of permissions that have
         been assigned to a particular session.
       </t>
       <t>
         The same access permissions MUST stay in effect for
         the processing of a particular message.
       </t>
       <t>
	 The server MUST use the access control rules in effect
	 at the time the message is processed.
       </t>
       <t>
         The access control model treats protocol operation execution
         separately from configuration datastore access
         and outgoing messages:
         <list style="hanging">
           <t hangText="create:">
             Permission to create conceptual server data.
           </t>
           <t hangText="read:">
             Read access to conceptual server data, &lt;rpc-reply&gt; and
             &lt;notification&gt; content.
           </t>
           <t hangText="update:">
             Permission to modify existing conceptual server data.
           </t>
           <t hangText="delete:">
             Permission to delete existing conceptual server data.
           </t>
           <t hangText="exec:">
             Permission to invoke a protocol operation.
           </t>
         </list>
       </t>
     </section>

     <section title="Global Enforcement Controls">
       <t>
         There are four global controls that are used to
         help control how access control is enforced.
       </t>
       <section title="enable-nacm Switch">
       <t>
         A global "enable-nacm" on/off switch is provided to enable
         or disable all access control enforcement.
         When this global switch is set to "true", then all access
         requested are checked against the access control rules,
         and only permitted if configured to allow the
         specific access request.
         When this global switch is set to "false", then all access
         requested are permitted.
       </t>
       </section>
       <section title="read-default Switch">
       <t>
         An on/off "read-default" switch is provided to
         enable or disable default access
         to receive data in replies and notifications.
         When the "enable-nacm" global switch is set to "true", then this
         global switch is relevant, if no matching
         access control rule is found to explicitly
         permit or deny read access to the requested
         NETCONF datastore data or notification event type.
       </t>
       <t>
         When this global switch is set to "permit", and no matching
         access control rule is found for the NETCONF
         datastore read or notification event requested, then access
         is permitted.
       </t>
       <t>
         When this global switch is set to "deny", and no matching
         access control rule is found for the NETCONF
         datastore read or notification event requested, then access
         is denied.
       </t>
       </section>
       <section title="write-default Switch">
       <t>
         An on/off "write-default" switch is provided to
         enable or disable default access
         to alter configuration data.
         When the "enable-nacm" global switch is set to "true", then this
         global switch is relevant, if no matching
         access control rule is found to explicitly
         permit or deny write access to the requested
         NETCONF datastore data.
       </t>
       <t>
         When this global switch is set to "permit", and no matching
         access control rule is found for the NETCONF
         datastore write requested, then access is permitted.
       </t>
       <t>
         When this global switch is set to "deny", and no matching
         access control rule is found for the NETCONF
         datastore write requested, then access
         is denied.
       </t>
       </section>
       <section title="exec-default Switch">
       <t>
         An on/off "exec-default" switch is provided to
         enable or disable default access
         to execute protocol operations.
         When the "enable-nacm" global switch is set to "true",
         then this global switch is relevant, if no matching
         access control rule is found to explicitly
         permit or deny access to the requested
         NETCONF protocol operation.
       </t>
       <t>
         When this global switch is set to "permit", and no matching
         access control rule is found for the NETCONF
         protocol operation requested, then access is permitted.
       </t>
       <t>
         When this global switch is set to "deny", and no matching
         access control rule is found for the NETCONF
         protocol operation requested, then access is denied.
       </t>
       </section>
     </section>

     <section title="Access Control Rules">
       <t>
         There are 4 types of rules available in NACM:
         <list style="hanging">
           <t hangText="module rule:">
             Controls access for definitions in
             a specific module, identified by its 
             name.
           </t>
           <t hangText="protocol operation rule:">
             Controls access for a 
             specific protocol operation, identified by its 
             module and name.
           </t>
           <t hangText="data node rule:">
             Controls access for a 
             specific data node, identified by its 
             path location within the conceptual
             XML document for the data node.
           </t>
           <t hangText="notification rule:">
             Controls access for a 
             specific notification event type, identified by its 
             module and name.
           </t>
         </list>
       </t>
     </section>
   </section>

   <section title="Access Control Enforcement Procedures">
     <t>
       There are seven separate phases that need to be addressed,
       four of which are related to the NETCONF message processing model.
       In addition, the initial start-up mode for a NETCONF server,
       session establishment, and "access-denied" error handling
       procedures also need to be considered.
     </t>

     <section title="Initial Operation">
       <t>
         Upon the very first start-up of the NETCONF server,
         the access control configuration will probably
         not be present.  If it isn't,
         a server MUST NOT allow any write access to
         any session role except a "recovery session",
         if supported.
       </t>
       <t>
         Access control rules are not enforced before or while the
         non-volatile configuration data is processed and loaded into
         the running configuration, when the server is booting
         or rebooting.  Access rules are enforced any time a
         request is initiated from a user session.
         Access control is not enforced for 
         server-initiated access requests, such as the
         initial load of the running datastore, during bootup.
       </t>
     </section>

     <section title="Session Establishment">
       <t>
         The access control model applies specifically
         to the well-formed XML content transferred between a client
         and a server, after session establishment has been completed,
         and after the &lt;hello&gt; exchange has been successfully
         completed.
       </t>
       <t>
         A server SHOULD NOT include any sensitive information
         in any &lt;capability&gt; elements within the 
         &lt;hello&gt; exchange.
       </t>
       <t>
         Once session establishment is completed, and a user
         has been authenticated, the NETCONF transport layer reports
         the user name and a possibly empty set of group names
         associated with the user to the NETCONF server.  The NETCONF
         server will enforce the access control rules, based on the
         supplied user name, group names, and the configuration
         data stored on the server.
       </t>
     </section>

     <section title='"access-denied" Error Handling'>
       <t>
         The "access-denied" error-tag is generated when
         the access control system denies access to either a
         request to invoke a protocol operation or a request to
         perform a particular operation on the configuration
         datastore.
       </t>
       <t>
         A server MUST NOT include any sensitive information
         in any &lt;error-info&gt; elements within the 
         &lt;rpc-error&gt; response.
       </t>
     </section>

     <section title="Incoming RPC Message Validation">
       <t>
         The diagram below shows the basic 
         conceptual structure of the access control processing model
         for incoming NETCONF &lt;rpc&gt; messages, within a server.
       </t>

       <t>
         <figure anchor="NACM_incoming">
           <artwork>
<![CDATA[

                NETCONF server
               +------------+
               |    XML     |
               |   message  |
               | dispatcher |
               +------------+
                      |
                      |
                      V
               +------------+
               | NC-base NS |
               |   <rpc>    |
               +------------+
                 |   |  |
                 |   |  +-------------------------+
                 |   +------------+               |
                 V                V               V
            +-----------+ +---------------+ +------------+
            | acme NS   | | NC-base NS    | | NC-base NS |
            | <my-edit> | | <edit-config> | | <unlock>   |
            +-----------+ +---------------+ +------------+
                   |               |
                   |               |
                   V               V
                 +----------------------+
                 |                      |
                 |    configuration     |
                 |      datastore       |
                 +----------------------+

]]>
           </artwork>
         </figure>
       </t>
       <t>
         Access control begins with the message dispatcher.
       </t>
       <t>
         After the server validates the &lt;rpc&gt; element,
         and determines the namespace URI and the element
         name of the protocol operation being requested, the RPC access
         control enforcer verifies that the session is authorized
         to invoke the protocol operation.
       </t>
       <t>
         The protocol operation is authorized by following these steps:
         <list style="numbers">
           <t>
             If the "enable-nacm" leaf is set to "false", then the
             protocol operation is permitted.
           </t>
           <t>
             If the requesting session is identified as a "recovery session",
             then the protocol operation is permitted.
           </t>
           <t>
             If the requested operation is the NETCONF
             &lt;close-session&gt; operation, then
             the protocol operation is permitted.
           </t>
           <t>
             Check all the "group" entries for ones that contain
             a "user-name" entry that equals the user name for
             the session making the request.  Add to these groups the
             set of groups provided by the transport layer.
           </t>
           <t>
             If no groups are found, continue with step 10. <!-- <xref
	     target="rpc-default"/>.-->
	     <!-- ugh. this shows up as "continue with Paragraph 10".
	          not pretty.  revert to the previous text?
                  or hardcode the step number here...

             If no groups are found, continue with step 10.

             <list style="symbols">
               <t>
                 If the requested protocol operation is
                 associated with a YANG module
                 advertised in the server capabilities,
                 and the rpc statement contains a
                 nacm:secure or nacm:very-secure extension,
                 then the protocol operation is denied.
               </t>
               <t>
                 If the "exec-default" leaf is set to "permit", then
                 permit the protocol operation, otherwise deny the
                 request.
               </t>
             </list>
	     -->
           </t>
	   <t>
	     Process all rule-list entries, in order.  If a
	     rule-list's "group" leaf-list does not match any
	     of the user's groups, proceed to the next rule-list entry.
	   </t>
	   <t>
	     For each rule-list entry found, process all rules, in
	     order, until a rule that matches the requested operation
	     is found.  A rule matches if all of the following
	     criteria are met:
             <list style="symbols">
               <t>
		 The rule's "module-name" leaf is "*", or equals the
		 name of the YANG module where the protocol operation
		 is defined.
	       </t>
	       <t>
		 The rule does not have a "rule-type" defined, or the
		 "rule-type" is "protocol-operation" and the
		 "rpc-name" is "*" or equals the name of the requested protocol
		 operation.
	       </t>
	       <t>
		 The rule's "access-operations" leaf has the "exec" bit
		 set, or has the special value "*".
	       </t>
	     </list>
	   </t>
	   <t>
             If a matching rule is found, then the "action" leaf
             is checked.  If it is equal to "permit", then the protocol
             operation is permitted, otherwise it is denied.
	   </t>
	   <t>
	     Otherwise, no matching rule was found in any rule-list
	     entry.
	   </t>
           <t anchor="rpc-default">
	     If the requested protocol operation is defined in a
	     YANG module advertised in the server capabilities, and
	     the "rpc" statement contains a "nacm:secure" or
	     a "nacm:very-secure" statement, then the protocol operation
	     is denied.
           </t>
           <t>
	     If the "exec-default" leaf is set to "permit", then
	     permit the protocol operation, otherwise deny the
	     request.
           </t>
         </list>
       </t>
       <t>
         If the session is not authorized to invoke the protocol operation
         then an &lt;rpc-error&gt; is generated with the following 
         information:
         <list style="hanging">
           <t hangText="error-tag:">access-denied</t>
           <t hangText="error-path:">
	     Identifies the requested protocol operation.  For
	     example:
	     <figure>
	       <artwork>
		 <![CDATA[
      <error-path
        xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
          /nc:rpc/nc:edit-config
      </error-path>
]]></artwork>
	     </figure>
	     represents the &lt;edit-config&gt; operation in the
	     NETCONF base namespace.
           </t>
         </list>
       </t>
       <t>
         If a datastore is accessed, either directly or as a side
         effect of the protocol operation, then the server MUST
         intercept the operation and make sure the session is
         authorized to perform the requested operation on the
         specified data, as defined in <xref target="node-access"/>.
       </t>
     </section>  

     <section title="Data Node Access Validation" anchor="node-access">
       <t>
         If a data node within a datastore is accessed, then the
         server MUST ensure that the client session is authorized to
         perform the requested read, create, update, or delete
         operation on the specified data node.
       </t>
       <t>
         The data node access request is authorized by following 
         these steps:
         <list style="numbers">
           <t>
             If the "enable-nacm" leaf is set to "false", then the
             protocol operation is permitted.
           </t>
           <t>
             If the requesting session is identified as a 
             "recovery session", then the protocol operation is permitted.
           </t>
           <t>
             Check all the "group" entries for ones that contain
             a "user-name" entry that equals the user name for
             the session making the request.  Add to these groups the
             set of groups provided by the transport layer.
           </t>
           <t>
             If no groups are found, continue with step 9. <!-- <xref
             target="data-node-default">step 9</xref>. -->
           </t>
	   <t>
	     Process all rule-list entries, in order.  If a
	     rule-list's "group" leaf-list does not match any
	     of the user's groups, proceed to the next rule-list entry.
	   </t>
	   <t>
	     For each rule-list entry found, process all rules, in
	     order, until a rule that matches the requested operation
	     is found.  A rule matches if all of the following
	     criteria are met:
             <list style="symbols">
               <t>
		 The rule's "module-name" leaf is "*", or equals the
		 name of the YANG module where the protocol operation
		 is defined.
	       </t>
	       <t>
		 The rule does not have a "rule-type" defined, or the
		 "rule-type" is "data-node" and the "path" matches the
		 requested data node.
	       </t>
	       <t>
		 For a read operation, the rule's
		 "access-operations" leaf has the "read" bit set, or
		 has the special value "*".
	       </t>
	       <t>
		 For a creation operation, the rule's
		 "access-operations" leaf has the "create" bit set, or
		 has the special value "*".
	       </t>
	       <t>
		 For a deletion operation, the rule's
		 "access-operations" leaf has the "delete" bit set, or
		 has the special value "*".
	       </t>
	       <t>
		 For an update operation, the rule's
		 "access-operations" leaf has the "update" bit set, or
		 has the special value "*".
	       </t>
	     </list>
	   </t>
	   <t>
             If a matching rule is found, then the "action" leaf
             is checked.  If it is equal to "permit", then the
             data node access is permitted, otherwise it is denied.
             For a read operation, "denied" means that the requested
             data is not returned in the reply.
	   </t>
	   <t>
	     Otherwise, no matching rule was found in any rule-list
	     entry.
	   </t>
           <t anchor="data-node-default">
             For a read operation, if the requested data node is defined
             in a YANG module advertised in the server capabilities,
             and the data definition statement contains a
             "nacm:very-secure" statement, then the requested data
             node is not included in the reply.
           </t>
           <t>
             For a write operation, if the requested data node is
             defined in a YANG module advertised in the server
             capabilities, and the data definition statement contains
             a "nacm:secure" or a "nacm:very-secure" statement, then
             the data node access request is denied.
           </t>
           <t>
             For a read operation, if the "read-default" leaf is set to
             "permit", then include the requested data node in the reply,
             otherwise do not include the requested data node in the reply.
           </t>
           <t>
             For a write operation, if the "write-default" leaf is set
             to "permit", then permit the data node access request,
             otherwise deny the request.
           </t>
         </list>
       </t>
     </section>

     <section title="Outgoing &lt;notification&gt; Authorization">
       <t>
         Configuration of access control rules specifically
         for descendant nodes of the notification event type
         element are outside the scope of this document.
         If the session is authorized to receive the
         notification event type, then it is also 
         authorized to receive any data it contains.
       </t>
       <t>
         The following figure shows the conceptual message processing
         model for outgoing &lt;notification&gt; messages.
       </t>

       <t>
         <figure anchor="NACM_outgoing_notification">
           <artwork>
             <![CDATA[

                NETCONF server
               +------------+
               |    XML     |
               |   message  |
               | generator  |
               +------------+
                     ^
                     |
             +----------------+
             | <notification> |
             |  generator     |
             +----------------+
                     ^
                     |
            +=================+
            | <notification>  |
            |  access control |
            |  <eventType>    |
            +=================+ 
                     ^
                     |
         +------------------------+
         | server instrumentation |
         +------------------------+
                   |     ^
                   V     |
          +----------------------+
          |    configuration     |
          |      datastore       |
          +----------------------+

]]>
           </artwork>
         </figure>
       </t>
       <t>
         The generation of a notification for a specific subscription
         is authorized by following these steps:
         <list style="numbers">
           <t>
             If the "enable-nacm" leaf is set to "false", then the
             notification is permitted.
           </t>
           <t>
             If the session is identified as a "recovery session",
             then the notification is permitted.
           </t>
           <t>
             If the notification is the NETCONF
             &lt;replayComplete&gt; or &lt;notificationComplete&gt;
             event type, then
             the notification is permitted.
           </t>
           <t>
             Check all the "group" entries for ones that contain
             a "user-name" entry that equals the user name for
             the session making the request.  Add to these groups the
             set of groups provided by the transport layer.
           </t>
           <t>
             If no groups are found, continue with step 10. <!-- <xref
	     target="notif-default">step 10</xref>.-->
	   </t>
	   <t>
	     Process all rule-list entries, in order.  If a
	     rule-list's "group" leaf-list does not match any
	     of the user's groups, proceed to the next rule-list entry.
	   </t>
	   <t>
	     For each rule-list entry found, process all rules, in
	     order, until a rule that matches the requested operation
	     is found.  A rule matches if all of the following
	     criteria are met:
             <list style="symbols">
               <t>
		 The rule's "module-name" leaf is "*", or equals the
		 name of the YANG module where the protocol operation
		 is defined.
	       </t>
	       <t>
		 The rule does not have a "rule-type" defined, or the
		 "rule-type" is "notification" and the
		 "notification-name" is "*", equals the name of the
		 notification.
	       </t>
	       <t>
		 The rule's "access-operations" leaf has the "read" bit
		 set, or has the special value "*".
	       </t>
	     </list>
	   </t>
	   <t>
             If a matching rule is found, then the "action" leaf
             is checked.  If it is equal to "permit", then permit the
             notification, otherwise drop the notification for the
             associated subscription.
	   </t>
	   <t>
	     Otherwise, no matching rule was found in any rule-list
	     entry.
	   </t>
           <t anchor="notif-default">
	     If the requested notification is defined in a YANG module
	     advertised in the server capabilities, and the
	     "notification" statement contains a
	     "nacm:very-secure" statement, then the notification is
	     dropped for the associated subscription.
           </t>
           <t>
	     If the "read-default" leaf is set to "permit", then
	     permit the notification, otherwise drop the notification
	     for the associated subscription.
           </t>
         </list>
       </t>
     </section>
   </section>

   <section title="Data Model Definitions" anchor="DM">
     <t>
       This section defines the semantics of the 
       conceptual data structures found in the data model
       in <xref target="DM"/>.
     </t>

     <section title="Data Organization">
       <t>
         The top-level element is called &lt;nacm&gt;, and it
         is defined in the "ietf-netconf-acm" module's namespace. 
       </t>
       <t>
         There are several data structures defined as child nodes
         of the &lt;nacm&gt; element:
         <list style="hanging">
           <t hangText="leaf &lt;enable-nacm&gt;:">
             On/off boolean switch to enable or disable
             access control enforcement.
           </t>
           <t hangText="leaf &lt;read-default&gt;:">
             Enumeration to permit or deny
             default read access requests.
           </t>
           <t hangText="leaf &lt;write-default&gt;:">
             Enumeration to permit or deny
             default write access requests.
           </t>
           <t hangText="leaf &lt;exec-default&gt;:">
             Enumeration to permit or deny
             default protocol operation execution requests.
           </t>
           <t hangText="leaf &lt;denied-rpcs&gt;:">
             Read-only counter of the number of
             times the server has denied an RPC
             operation request, since the last reboot
             of the server.
           </t>
           <t hangText="leaf &lt;denied-data-writes&gt;:">
             Read-only counter of the number of
             times the server has denied a
             data node write request, since the last reboot
             of the server.
           </t>
           <t hangText="leaf &lt;denied-notifications&gt;:">
             Read-only counter of the number of
             times the server has denied a
             notification, since the last reboot
             of the server.
           </t>
           <t hangText="container &lt;groups&gt;:">
             Configures the groups used within the access
             control system.
             <list style="hanging">
               <t hangText="list &lt;group&gt;:">
                 A list of user names belonging to the
                 same administrative group.
               </t>
             </list>
           </t>
           <t hangText="container &lt;rules&gt;:">
             Configures the access control rules used 
             within the server.
             <list style="hanging">
               <t hangText="list &lt;rule-list&gt;:">
                 An ordered collection of related access control rules.
		 <list style="hanging">
		   <t hangText="list &lt;rule&gt;:">
		     Configures the access control rules for protocol
		     operation invocation, configuration datastore
		     access, and for controlling delivery of
		     &lt;notification&gt; events.
		   </t>
		 </list>
	       </t>
	     </list>
           </t>
         </list>
       </t>
     </section>

     <section title="YANG Module">
       <t>
         The following YANG module specifies
         the normative NETCONF content that MUST
         by supported by the server.
       </t>
       <t>
	 The ietf-netconf-acm YANG module imports typedefs from <xref
	 target="RFC6021"/>.
       </t>
       <t>
         <figure anchor="YANG_module">
           <artwork><![CDATA[
// RFC Ed.: please update the date to the date of publication
<CODE BEGINS> file="ietf-netconf-acm@2011-06-14.yang"

module ietf-netconf-acm {

  namespace "urn:ietf:params:xml:ns:yang:ietf-netconf-acm";

  prefix "nacm";

  import ietf-yang-types {
    prefix yang;
  }

  organization
    "IETF NETCONF (Network Configuration) Working Group";


  contact
    "WG Web:   <http://tools.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>

     WG Chair: Mehmet Ersue
               <mailto:mehmet.ersue@nsn.com>

     WG Chair: Bert Wijnen
               <mailto:bertietf@bwijnen.net>

     Editor:   Andy Bierman
               <mailto:andy.bierman@brocade.com>

     Editor:   Martin Bjorklund
               <mailto:mbj@tail-f.com>";

  description 
    "NETCONF Server Access Control Model.

     Copyright (c) 2011 IETF Trust and the persons identified as
     authors of the code. All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD
     License set forth in Section 4.c of the IETF Trust's
     Legal Provisions Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.";
  // RFC Ed.: replace XXXX with actual RFC number and
  // remove this note

  // RFC Ed.: remove this note
  // Note: extracted from draft-ietf-netconf-access-control-04.txt

  // RFC Ed.: please update the date to the date of publication
  revision "2011-06-14" {
    description
      "Initial version";
    reference 
      "RFC XXXX: Network Configuration Protocol
                 Access Control Model";
  }

  /*
   * Extension statements
   */

  extension secure {
    description
      "Used to indicate that the data model node 
       represents a sensitive security system parameter.

       If present, and the NACM module is enabled (i.e.,
       /nacm/enable-nacm object equals 'true'), the NETCONF server
       will only allow the designated 'recovery session' to have 
       write or execute access to the node.  An explicit access 
       control rule is required for all other users.

       The 'secure' extension MAY appear within a data definition
       statement or rpc statement.  It is ignored otherwise.";
  }

  extension very-secure {
    description
      "Used to indicate that the data model node 
       controls a very sensitive security system parameter.

       If present, and the NACM module is enabled (i.e.,
       /nacm/enable-nacm object equals 'true'), the NETCONF server
       will only allow the designated 'recovery session' to have
       read, write, or execute access to the node.  An explicit
       access control rule is required for all other users.

       The 'very-secure' extension MAY appear within a data
       definition statement, rpc statement, or notification
       statement.  It is ignored otherwise.";
  }

  /*
   * Derived types
   */

  typedef user-name-type {
    type string {
      length "1..max";
    }
    description
      "General Purpose User Name string.";
  }

  typedef matchall-string-type {
    type string {
      pattern "\*";
    }
    description
      "The string containing a single asterisk '*' is used
       to conceptually represent all possible values
       for the particular leaf using this data type.";
  }
  
  typedef access-operations-type {
    type bits {
      bit create {
        description
          "Any operation that creates a
           new instance of the specified data is a create
           operation.";
      }
      bit read {
        description
          "Any operation or notification that
           returns data to an application is a read 
           operation.";
      }
      bit update {
        description
          "Any operation that alters an existing
           data node is an update operation.";
      }
      bit delete {
        description
          "Any operation that removes a datastore
           node instance is a delete operation.";
      }
      bit exec {
        description
          "Execution access to the specified RPC operation.
           Any RPC operation invocation is an exec operation.";
      }
    }
    description 
      "NETCONF Access Operation.";
  }

  typedef group-name-type {
    type string {
      length "1..max";
      pattern "[^\*].*";
    }
    description 
      "Name of administrative group that can be
       assigned to the user, and specified in
       an access control rule-list.";
  }

  typedef action-type {
    type enumeration {
      enum permit {
        description
          "Requested action is permitted.";
      }
      enum deny {
        description
          "Requested action is denied.";
      }
    }
    description
      "Action taken by the server when a particular
       rule matches.";
  }

  typedef node-instance-identifier {
    type yang:xpath1.0;
    description
      "Path expression used to represent a special 
       data node instance identifier string.
     
       A node-instance-identifier value is an 
       unrestricted YANG instance-identifier expression.
       All the same rules as an instance-identifier apply
       except predicates for keys are optional.  If a key
       predicate is missing, then the node-instance-identifier
       represents all possible server instances for that key.

       This XPath expression is evaluated in the following context:

         o  The set of namespace declarations are those in scope on
            the leaf element where this type is used.

         o  The set of variable bindings contains one variable,
            'USER', which contains the name of user of the current
             session.

         o  The function library is the core function library, but
            note that due to the syntax restrictions of an
            instance-identifier, no functions are allowed.

         o  The context node is the root node in the data tree.";
  }

  container nacm {
    nacm:very-secure;

    description
      "Parameters for NETCONF Access Control Model.";

    leaf enable-nacm {
      type boolean;
      default true;
      description
        "Enable or disable all NETCONF access control
         enforcement.  If 'true', then enforcement
         is enabled.  If 'false', then enforcement
         is disabled.";
    } 

    leaf read-default {
      type action-type;
      default "permit";
      description
        "Controls whether read access is granted if
         no appropriate rule is found for a
         particular read request.";
    }

    leaf write-default {
      type action-type;
      default "deny";
      description
        "Controls whether create, update, or delete access
         is granted if no appropriate rule is found for a
         particular write request.";
    }

    leaf exec-default {
      type action-type;
      default "permit";
      description
        "Controls whether exec access is granted if no appropriate
         rule is found for a particular RPC operation request.";
    }

    leaf denied-rpcs {
      type yang:zero-based-counter32;
      config false;
      mandatory true;
      description
        "Number of times an RPC operation request was denied
         since the server last restarted.";
    }

    leaf denied-data-writes {
      type yang:zero-based-counter32;
      config false;
      mandatory true;
      description
        "Number of times a request to alter a data node
         was denied, since the server last restarted.";
    }

    leaf denied-notifications {
      type yang:zero-based-counter32;
      config false;
      mandatory true;
      description
        "Number of times a notification was denied
         since the server last restarted.";
    }

    container groups {
      description
        "NETCONF Access Control Groups.";

      list group {
        key name;

        description
          "One NACM Group Entry.";

        leaf name {
          type group-name-type;
          description 
            "Group name associated with this entry.";
        }

        leaf-list user-name {
          type user-name-type;
          description 
            "Each entry identifies the user name of 
             a member of the group associated with 
             this entry.";
        }
      }
    }

    list rule-list {
      key "name";
      ordered-by user;
      description
        "An ordered collection of access control rules.";
      
      leaf name {
        type string {
          length "1..256";
        }
        description
          "Arbitrary name assigned to the rule-list.";
      }
      leaf-list group {
        type union {
          type matchall-string-type;
          type group-name-type;
        }
        description
          "List of administrative groups that will be
           assigned the associated access rights
           defined by the 'rule' list.

           The string '*' indicates that all groups apply to the
           entry.";
      }

      list rule {
        key "name";
        ordered-by user;
        description
          "One access control rule.

           Rules are processed in user-defined order until a match is
           found.  A rule matches if 'module-name', 'rule-type', and
           'access-operations' matches the request.  If a rule
           matches, the 'action' leaf determines if access is granted
           or not.";

        leaf name {
          type string {
            length "1..256";
          }
          description
            "Arbitrary name assigned to the rule.";
        }
        
        leaf module-name {
          type union {
            type matchall-string-type;
            type string;
          }
          default "*";
          description
            "Name of the module associated with this rule.

             This leaf matches if it has the value '*', or if the
             object being accessed is defined in the module with the
             specified module name.";
        }
        choice rule-type {
          description
            "This choice matches if all leafs present in the rule
             matches the request.  If no leafs are present, the
             choice matches all requests.";
          case protocol-operation {
            leaf rpc-name {
              type union {
                type matchall-string-type;
                type string;
              }
              description
                "This leaf matches if it has the value '*', or if its
                 value equals the requested RPC operation name.";
            }
          }
          case notification {
            leaf notification-name {
              type union {
                type matchall-string-type;
                type string;
              }
              description
                "This leaf matches if it has the value '*', or if its
                 value equals the requested notification name.";
            }
          }
          case data-node {
            leaf path {
              type node-instance-identifier;
              mandatory true;
              description
                "Data Node Instance Identifier associated with the data
                 node controlled by this rule.

                 Configuration data or state data instance 
                 identifiers start with a top-level data node.  A
                 complete instance identifier is required for this
                 type of path value.

                 The special value '/' refers to all possible data
                 store contents.";
            }
          }
        }

        leaf access-operations {
          type union {
            type matchall-string-type;
            type access-operations-type;
          }
          default "*";
          description
            "Access operations associated with this rule.

             This leaf matches if it has the value '*', or if the
             bit corresponding to the requested operation is set.";
        }

        leaf action {
          type action-type;
          mandatory true;
          description
            "The access control action associated with the
             rule.  If a rule is determined to match a
             particular request, then this object is used
             to determine whether to permit or deny the
             request.";
        }
        
        leaf comment {
          type string;
          description
            "A textual description of the access rule.";
        }
      }
    }
  }
}


<CODE ENDS>
             ]]></artwork>
         </figure>
       </t>
     </section>

   </section>

   <section anchor="IANA" title="IANA Considerations">
     <t>
       There are two actions that are requested of IANA:
       This document registers one URI in "The IETF XML Registry".
       Following the format in <xref target="RFC3688"/>, 
       the following has been registered.
     </t>
     <t>
       <figure>
         <artwork><![CDATA[
     URI: urn:ietf:params:xml:ns:yang:ietf-netconf-acm
     Registrant Contact: The IESG.
     XML: N/A, the requested URI is an XML namespace.
             ]]></artwork>
       </figure>
     </t>
     <t>
       This document registers one module in the "YANG Module Names"
       registry.  Following the format in <xref target="RFC6020" />, 
       the following has been registered.

       <figure>
         <artwork><![CDATA[
     name: ietf-netconf-acm
     namespace: urn:ietf:params:xml:ns:yang:ietf-netconf-acm
     prefix: nacm
     reference: RFC XXXX
        // RFC Ed.: Replace XXX with actual RFC number 
        // and remove this note
             ]]></artwork>
       </figure>
     </t>
   </section>

   <section anchor="Security" title="Security Considerations">
     <t>
       This entire document discusses access control
       requirements and mechanisms for restricting
       NETCONF protocol behavior within a given session.
     </t>

     <t>
       Configuration of the access control system is
       highly sensitive to system security.  A server may
       choose not to allow any user configuration to
       some portions of it, such as the global security level,
       or the groups which allowed access to system resources.
     </t>

     <t>
       This document incorporates the optional use of a "recovery session"
       mechanism, which can be used to bypass access control
       enforcement in emergencies, such as NACM configuration errors
       which disable all access to the server. 
       The configuration and identification of such
       a recovery session mechanism are outside the scope of this document.
     </t>

     <t>
       There is a risk that invocation of 
       non-standard protocol operations will have undocumented side effects.
       An administrator needs to construct access control rules
       such that the configuration datastore is protected
       from such side effects.  Also, such protocol operations
       SHOULD never be invoked by a session during a "recovery session".
     </t>

     <t>
       There is a risk that non-standard protocol operations, or
       even the standard &lt;get&gt; operation, may
       return data which "aliases" or "copies" sensitive data
       from a different data object.
       In this case, the namespace and/or the element name
       will not match the values for the sensitive data,
       which is then fully or partially copied into a different
       namespace and/or element.  An administrator needs to
       avoid using data models which use this practice.
     </t>

     <t>
       An administrator needs to restrict write access to all
       configurable objects within this data model.
     </t>
     <t>
       If write access is allowed for configuration of
       access control rules, then care needs to be taken
       not to disrupt the access control enforcement.
     </t>
     <t>
       An administrator needs to restrict read access to the
       following objects within this data model, which reveal
       access control configuration which could be considered
       sensitive.
       <list style="symbols">
         <t>enable-nacm</t>
         <t>read-default</t>
         <t>write-default</t>
         <t>exec-default</t>
         <t>groups</t>
         <t>rules</t>
       </list>
     </t>
   </section>
  </section>
 </middle>

  <!--  ***** BACK MATTER ***** -->
 <back>
  <references title="Normative References">
    &rfc2119;
    &rfc3688;
    &rfc5277;
    &rfc6020;
    &rfc6021;
    &netconfspec;
    &netconfsshspec;
  </references>

  <references title="Informative References">
    &rfc2865;
    &rfc5607;
  </references>

  <section title="Usage Examples">
    <t>
      The following XML snippets are provided as examples only, 
      to demonstrate how NACM can be configured to perform
      some access control tasks.
    </t>
    <section title="&lt;groups&gt; Example">
      <t>
        There needs to be at least one &lt;group&gt; entry
        in order for any of the access control rules
        to be useful.
      </t>
      <t>
        The following XML shows arbitrary groups,
        and is not intended to represent any particular
        use-case.
      </t>
      <t>
        <figure>
          <artwork><![CDATA[
<nacm xmlns="urn:ietf:params:xml:ns:yang:ietf-netconf-acm">
  <groups>
    <group>
      <name>admin</name>
      <user-name>admin</user-name>
      <user-name>andy</user-name>
    </group>

    <group>
      <name>monitor</name>
      <user-name>wilma</user-name>
      <user-name>bam-bam</user-name>
    </group>

    <group>
      <name>guest</name>
      <user-name>guest</user-name>
      <user-name>guest@example.com</user-name>
    </group>
  </groups>
</nacm>


            ]]>
          </artwork>
        </figure>
      </t>
      <t>
        This example shows 3 groups:
        <list style="numbers">
          <t>
            The "admin" group contains 2 users named "admin" and "andy".
          </t>
          <t>
            The "monitor" group contains 2 users named 
            "wilma" and "bam-bam".
          </t>
          <t>
            The "guest" group contains 2 users named 
            "guest" and "guest@example.com".
          </t>
        </list>
      </t>
    </section>

    <section title="Module Rule Example">
      <t>
        Module rules are used to control access to all the content
        defined in a specific module.  A module rule has the
        &lt;module-name&gt; leaf set, but no case in the "rule-type"
        choice.
      </t>
      <t>
        <figure>
          <artwork><![CDATA[
<nacm xmlns="urn:ietf:params:xml:ns:yang:ietf-netconf-acm">
  <rule-list>
    <name>guest</name>
    <group>guest</group>

    <rule>
      <name>mod-1</name>
      <module-name>ietf-netconf-monitoring</module-name>
      <access-operations>*</access-operations>
      <action>deny</action>
      <comment>
          Do not allow guests any access to the netconf 
          monitoring information.
      </comment>
    </rule>
  </rule-list>

  <rule-list>
    <name>monitor example</name>
    <group>monitor</group>

    <rule>
      <name>mod-2</name>
      <module-name>ietf-netconf-monitoring</module-name>
      <access-operations>read</access-operations>
      <action>permit</action>
      <comment>
          Allow read access to the netconf 
          monitoring information.
      </comment>
    </rule>
    <rule>
      <name>mod-3</name>
      <module-name>*</module-name>
      <access-operations>exec</access-operations>
      <action>permit</action>
      <comment>
          Allow invocation of the
          supported server operations.
      </comment>
    </rule>
  </rule-list>

  <rule-list>
    <name>admin example</name>
    <group>admin</group>

    <rule>
      <name>mod-4</name>
      <module-name>*</module-name>
      <access-operations>*</access-operations>
      <action>permit</action>
      <comment>
          Allow the admin group complete access to all
          operations and data.
      </comment>
    </rule>
  </rule-list>
</nacm>


            ]]>
          </artwork>
        </figure>
      </t>
      <t>
        This example shows 4 module rules:
        <list style="hanging">
          <t hangText="mod-1:">
            This rule prevents the guest group from
            reading any monitoring information in
            the ietf-netconf-monitoring YANG module.
          </t>
          <t hangText="mod-2:">
            This rule allows the monitor group to read the
            ietf-netconf-monitoring YANG module.
          </t>
          <t hangText="mod-3:">
            This rule allows the monitor group to invoke any
            protocol operation supported by the server.
          </t>
          <t hangText="mod-4:">
            This rule allows the admin group complete access
            to all content in the server.  No subsequent rule
            will match for the admin group, because of this 
            module rule.
          </t>
        </list>
      </t>
    </section>

    <section title="RPC Rule Example">
      <t>
        RPC rules are used to control access to
        a specific protocol operation.
      </t>
      <t>
        <figure>
          <artwork><![CDATA[
<nacm xmlns="urn:ietf:params:xml:ns:yang:ietf-netconf-acm">
  <rule-list>
    <name>guest</name>
    <group>monitor</group>
    <group>guest</group>

    <rule>
      <name>rpc-1</name>
      <module-name>ietf-netconf</module-name>
      <rpc-name>kill-session</rpc-name>
      <access-operations>exec</access-operations>
      <action>deny</action>
      <comment>
        Do not allow the monitor or guest group
        to kill another session.
      </comment>
    </rule>
    <rule>
      <name>rpc-2</name>
      <module-name>ietf-netconf</module-name>
      <rpc-name>delete-config</rpc-name>
      <access-operations>exec</access-operations>
      <action>deny</action>
      <comment>
        Do not allow monitor or guest group
        to delete any configurations.
      </comment>
    </rule>
  </rule-list>

  <rule-list>
    <name>monitor</name>
    <group>monitor</group>

    <rule>
      <name>rpc-3</name>
      <module-name>ietf-netconf</module-name>
      <rpc-name>edit-config</rpc-name>
      <access-operations>exec</access-operations>
      <action>permit</action>
      <comment>
        Allow the monitor group to edit the configuration.
      </comment>
    </rule>
  </rule-list>

</nacm>

            ]]>
          </artwork>
        </figure>
      </t>
      <t>
        This example shows 3 protocol operation rules:
        <list style="hanging">
          <t hangText="rpc-1:">
            This rule prevents the monitor or guest groups 
            from invoking the NETCONF
            &lt;kill-session&gt; protocol operation.
          </t>
          <t hangText="rpc-2:">
            This rule prevents the monitor or guest groups 
            from invoking the NETCONF
            &lt;delete-config&gt; protocol operation.
          </t>
          <t hangText="rpc-3:">
            This rule allows the monitor group
            to invoke the NETCONF
            &lt;edit-config&gt; protocol operation.
            This rule will have no real effect 
            unless the "exec-default" leaf is set to "deny".
          </t>
        </list>
      </t>
    </section>

    <section title="Data Rule Example">
      <t>
        Data rules are used to control access to
        specific (config and non-config) data nodes
        within the NETCONF content provided by the server.
      </t>
      <t>
        <figure>
          <artwork><![CDATA[
<nacm xmlns="urn:ietf:params:xml:ns:yang:ietf-netconf-acm">
  <rule-list>
    <name>guest rules</name>
    <group>guest</group>

    <rule>
      <name>data-1</name>
      <path xmlns:n="urn:ietf:params:xml:ns:yang:ietf-netconf-acm">
        /n:nacm
      </path>
      <access-operations>*</access-operations>
      <action>deny</action>
      <comment>
        Deny the guest group any access to the /nacm data.
      </comment>
    </rule>
  </rule-list>

  <rule-list>
    <name>monitor rules</name>
    <group>monitor</group>

    <rule>
      <name>data-acme-config</name>
      <path xmlns:acme="http://example.com/ns/netconf">
        /acme:acme-netconf/acme:config-parameters
      </path>
      <access-operations>
        read create update delete
      </access-operations>
      <action>permit</action>
      <comment>
        Allow the monitor group complete access to the acme
        netconf configuration parameters.  Showing long form
        of 'access-operations' instead of shorthand.
      </comment>
    </rule>
  </rule-list>

  <rule-list>
    <name>dummy-itf</name>
    <group>guest monitor</group>

    <rule>
      <name>dummy-itf</name>
      <path xmlns:acme="http://example.com/ns/itf">
        /acme:interfaces/acme:interface[acme:name='dummy']
      </path>
      <access-operations>read update</access-operations>
      <action>permit</action>
      <comment>
        Allow the monitor and guest groups read
        and update access to the dummy interface.
      </comment>
    </rule>
  </rule-list>

  <rule-list>
    <name>admin rules</name>
    <rule>
      <name>admin-itf</name>
      <path xmlns:acme="http://example.com/ns/itf">
        /acme:interfaces/acme:interface
      </path>
      <access-operations>*</access-operations>
      <action>permit</action>
      <comment>
        Allow admin full access to all acme interfaces.
      </comment>
    </rule>
  </rule-list>
</nacm>

            ]]>
          </artwork>
        </figure>
      </t>
      <t>
        This example shows 4 data rules:
        <list style="hanging">
          <t hangText="data-1:">
            This rule denies the guest group
            any access to the &lt;nacm&gt; subtree.
            Note that the default namespace is only
            applicable because this subtree is defined
            in the same namespace as the &lt;data-rule&gt;
            element.
          </t>
          <t hangText="data-acme-config:">
            This rule gives the monitor group
            read-write access to the acme &lt;config-parameters&gt;.
          </t>
          <t hangText="dummy-itf:">
            This rule gives the monitor and guest groups
            read-update access to the acme &lt;interface&gt;.
            entry named "dummy".  This entry cannot be created or
            deleted by these groups, just altered.
          </t>
          <t hangText="admin-itf:">
            This rule gives the admin group
            read-write access to all acme &lt;interface&gt;.
            entries.  This is an example of an unreachable rule
            because the "mod-3" rule already gives the admin
            group full access to this data.
          </t>
        </list>
      </t>
    </section>

    <section title="Notification Rule Example">
      <t>
        Notification rules are used to control access to
        a specific notification event type.
      </t>
      <t>
        <figure>
          <artwork><![CDATA[
<nacm xmlns="urn:ietf:params:xml:ns:yang:ietf-netconf-acm">
  <rule-list>
    <name>sys</name>
    <group>monitor</group>
    <group>guest</group>
    
    <rule>
      <name>notif-1</name>
      <module-name>acme-system</module-name>
      <notification-name>sys-config-change</notification-name>
      <access-operations>read</access-operations>
      <action>deny</action>
      <comment>
        Do not allow the guest or monitor groups 
        to receive config change events.
      </comment>
    </rule>
  </rule-list>
</nacm>

            ]]>
          </artwork>
        </figure>
      </t>
      <t>
        This example shows 1 notification rule:
        <list style="hanging">
          <t hangText="notif-1:">
            This rule prevents the monitor or guest groups 
            from receiving the
            acme &lt;sys-config-change&gt; event type.
          </t>
        </list>
      </t>
    </section>
  </section>

  <section title="Change Log"> 
    <t>
      -- RFC Ed.: remove this section before publication.
    </t>

    <section title="03-04">
      <t>
	Introduced rule-lists to group related rules together.
      </t>
      <t>
        Moved "module-rule", "rpc-rule", "notification-rule", and
        "data-rule" into one common "rule", with a choice to select between
        the four variants.
      </t>
      <t>
        Changed "superuser" to "recovery session", and adjusted text
        throughout document for this change.
      </t>
      <t>
        Clarified behavior of global default NACM parameters,
        enable-nacm, read-default, write-default, exec-default.
      </t>
      <t>
        Clarified when access control is applied during system
        initialization.
      </t>
    </section>

    <section title="02-03">
      <t>
        Fixed improper usage of RFC 2119 keywords.
      </t>
      <t>
        Changed term usage of "database" to "datastore".
      </t>
      <t>
        Clarified that "secure" and "very-secure" extensions only 
        apply if the /nacm/enable-nacm object is "true".
      </t>
    </section>

    <section title="01-02">
      <t>
        Removed authentication text and objects.
      </t>
      <t>
        Changed module name from ietf-nacm to ietf-netconf-acm.
      </t>
      <t>
        Updated NETCONF and YANG terminology.        
      </t>
      <t>
        Removed open issues section.
      </t>
      <t>
        Changed some must to MUST in requirements section.
      </t>
    </section>

    <section title="00-01">
      <t>
        Updated YANG anf YANG Types references.
      </t>
      <t>
        Updated module namespace URI to standard format.
      </t>
      <t>
        Updated module header meta-data to standard format.
      </t>
      <t>
        Filled in IANA section.
      </t>
    </section>

    <section title="00">
      <t>
        Initial version cloned from 
        draft-bierman-netconf-access-control-02.txt.
      </t>
    </section>
  </section>
 </back>

</rfc>

