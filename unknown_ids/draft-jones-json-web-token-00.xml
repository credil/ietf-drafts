<?xml version="1.0" encoding="US-ASCII"?>
<!-- edited with XMLSpy v2010 rel. 3 sp1 (x64) (http://www.altova.com) by Yaron Y. Goland (Microsoft) -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY OASIS.saml-core-2.0-os PUBLIC "" "http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml">
<!ENTITY W3C.CR-xml11-20021015 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-xml11-20021015.xml">
<!ENTITY RFC2045 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY RFC2104 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC3275 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3275.xml">
<!ENTITY RFC3339 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
<!ENTITY RFC3447 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY RFC3629 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml">
<!ENTITY RFC3986 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4122 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4122.xml">
<!ENTITY RFC4627 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC4648 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC5226 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
]>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-jones-json-web-token-00"
     ipr="trust200902">
  <front>
    <title>JSON Web Token (JWT)</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones"> <!-- role="editor" -->
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
      <organization>Google</organization>
      <address>
	<email>balfanz@google.com</email>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>independent</organization>
      <address>
	<email>ve7jtb@ve7jtb.com</email>
      </address>
    </author>

    <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland">
      <organization>Microsoft</organization>
      <address>
	<email>yarong@microsoft.com</email>
      </address>
    </author>

    <author fullname="John Panzer" initials="J." surname="Panzer">
      <organization>Google</organization>
      <address>
	<email>jpanzer@google.com</email>
      </address>
    </author>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>Nomura Research Institute</organization>
      <address>
	<email>n-sakimura@nri.co.jp</email>
      </address>
    </author>

    <date day="28" month="December" year="2010" />

    <area>Applications</area>

    <keyword>RFC</keyword>

    <keyword>Request for Comments</keyword>

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <keyword>Assertion</keyword>

    <keyword>Claim</keyword>

    <keyword>Simple Web Token</keyword>

    <keyword>Security Token</keyword>

    <keyword>SWT</keyword>

    <keyword>JSON Web Token</keyword>

    <keyword>JWT</keyword>

    <keyword>JavaScript Object Notation</keyword>

    <keyword>JSON</keyword>

    <abstract>
      <t>JSON Web Token (JWT) defines a token format that can encode
      claims transferred between two parties. The claims in a JWT are
      encoded as a JSON object that is digitally signed.</t>
    </abstract>

    <note title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t>JSON Web Token (JWT) is a simple token format intended for
      space constrained environments such as HTTP Authorization
      headers and URI query parameters. JWTs encode the claims to be
      transmitted as a JSON object (as defined in <xref
      target="RFC4627">RFC 4627</xref>) that is base64url encoded and
      digitally signed.</t>

     <t>The suggested pronunciation of JWT is the same as the English word "jot".</t>
    </section>

    <section title="Terminology">
      <t><list style="hanging">

          <t hangText="JSON Web Token (JWT)">A string consisting of
          three JWT Token Segments: the JWT Envelope Segment, the JWT
          Claim Segment, and the JWT Crypto Segment, in that order,
          with the segments being separated by period ('.')
          characters.</t>

          <t hangText="JWT Token Segment">One of the three parts that
          make up a JSON Web Token (JWT).  JWT Token Segments are
          always base64url encoded values.</t>

          <t hangText="JWT Envelope Segment">A JWT Token Segment
          containing a base64url encoded JSON object that describes
          the signature applied to the JWT Claim Segment.</t>

          <t hangText="JWT Claim Segment">A JWT Token Segment
          containing a base64url encoded JSON object that encodes the
          claims represented by the JWT.</t>

          <t hangText="JWT Crypto Segment">A JWT Token Segment
          containing base64url encoded cryptographic signature
          material that secures the JWT Crypto Segment's contents.</t>

          <t hangText="Decoded JWT Envelope Segment">A JWT Envelope Segment that
          has been base64url decoded back into a JSON object.</t>

          <t hangText="Decoded JWT Claim Segment">A JWT Claim Segment that
          has been base64url decoded back into a JSON object.</t>

          <t hangText="Decoded JWT Crypto Segment">A JWT Crypto Segment that
          has been base64url decoded back into cryptographic material.</t>

          <t hangText="Base64url Encoding">For the purposes of this specification, 
          this term always refers to the he URL- and filename-safe Base64
          encoding described in <xref target="RFC4648">RFC 4648</xref>, Section 5,
          with the '=' padding characters omitted, as permitted by Section 3.2;
          see <xref target="base64urllogic"></xref> for more details.</t>

        </list></t>
    </section>

    <section title="JSON Web Token (JWT) Overview">

      <t>JWTs represent a set of claims as a JSON object that is
      base64url encoded and digitally signed.  As per <xref
      target="RFC4627">RFC 4627</xref> Section 2.2, the JSON object
      consists of zero or more name/value pairs (or members), where
      the names are strings and the values are arbitrary JSON values.
      These members are the claims represented by the JWT.  The JSON
      object is base64url encoded to produce the JWT Claim Segment. An
      accompanying base64url encoded JSON envelope object describes
      the signature method used.</t>

      <t>The names within the object MUST be unique.  The names within
      the JSON object are referred to as Claim Names.  The
      corresponding values are referred to as Claim Values.</t>

      <t>JWTs contain a signature that ensures the integrity of the
      content of the JSON Claim Segment.  This signature value is
      carried in the JWT Crypto Segment.  The JSON Envelope object
      MUST contain an "alg" parameter, the value of which is a string
      that unambiguously identifies the algorithm used to sign the JWT
      Claim Segment to produce the JWT Crypto Segment.</t>

      <section title="Example JWT">

      <t>The following is an example of a JSON object that can be
      encoded to produce a JWT:</t>

      <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

      <t>Base64url encoding the UTF-8 representation of the JSON
      object yields this JWT Claim Segment value:</t>

      <artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

      <t>The following example JSON envelope object declares that the
      encoded object is a JSON Web Token (JWT) and the JWT Claim
      Segment is signed using the HMAC SHA-256 algorithm:</t>

      <artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork>

      <t>Base64url encoding the UTF-8 representation of the JSON envelope
      object yields this JWT Envelope Segment value:</t>

      <artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork>

      <t>Signing the JWT Claim Segment with the HMAC SHA-256 algorithm
      and base64url encoding the result, as per <xref
      target="SigningWithHMACSHA256"></xref>, yields this JWT Crypto Segment value:</t>

      <artwork><![CDATA[35usWj9X8HwGS-CDcx1JP2NmqcrLwZ4EKp8sNThf3cY]]></artwork>

      <t>Combining these segments in the order
      Envelope.Claims.Signature with period characters between the
      segments yields this complete JWT (with line breaks for display
      purposes only):</t>

      <artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
35usWj9X8HwGS-CDcx1JP2NmqcrLwZ4EKp8sNThf3cY]]></artwork>

      <t>This computation is illustrated in more detail in <xref
      target="HMACSHA256Example"></xref>.</t>

      </section>
    </section>

    <section title="JWT Claims">

      <t>The members of the JSON object represented by the Decoded JWT
      Claim Segment contain the claims. Note however, that the set of
      claims a JWT must contain to be considered valid is
      context-dependent and is outside the scope of this
      specification.</t>

      <t>There are three classes of JWT Claim Names:  Reserved Claim Names, Public Claim Names, and Private Claim Names.</t>

      <section title="Reserved Claim Names" anchor="ReservedClaimName">
	<t>The following claim names are reserved. None of the claims
	defined in the table below are intended to be mandatory, but
	rather, provide a starting point for a set of useful,
	interoperable claims.  All the names are short because a core
	goal of JWTs is for the tokens themselves to be short.</t>

	<texttable title="Reserved Claim Definitions" anchor="ClaimTable">

	  <ttcol align="left">Claim Name</ttcol>
	  <ttcol align="left">JSON Value Type</ttcol>
	  <ttcol align="left">Claim Syntax</ttcol>
	  <ttcol align="left">Claim Semantics</ttcol>

	  <c>exp</c>
	  <c>integer</c>
	  <c>IntDate</c>
	  <c>The "exp" (expiration time) claim identifies the
	  expiration time on or after which the token MUST NOT be
	  accepted for processing.  The processing of the "exp" claim
	  requires that the current date/time MUST be before the
	  expiration date/time listed in the "exp" claim. Implementers
	  MAY provide for some small leeway, usually no more than a
	  few minutes, to account for clock skew.  This claim is
	  OPTIONAL.</c>

	  <c>iss</c>
	  <c>string</c>
	  <c>StringAndURI</c>
	  <c>The "iss" (issuer) claim identifies the principal that
	  issued the JWT.  The processing of this claim is generally
	  application specific.  This claim is OPTIONAL.</c>

	  <c>aud</c>
	  <c>string</c>
	  <c>StringAndURI</c>
	  <c>The "aud" (audience) claim identifies the audience that
	  the JWT is intended for.  The processing of this claim
	  requires that if a JWT consumer receives a JWT with an "aud"
	  value that does not identify itself as the JWT audience,
	  then the JWT MUST be rejected.  The interpretation of the
	  audience value is generally application specific.  This
	  claim is OPTIONAL.</c>

	  <c>typ</c>
	  <c>string</c>
	  <c>StringAndURI</c>
	  <c>The "typ" (type) claim is used to declare a type for the
	  contents this JWT.  The value MAY be a <xref
	  target="RFC2045">MIME</xref> type.  This claim is
	  OPTIONAL.</c>

	</texttable>

	<t>Additional reserved claim names MAY be defined via the IANA
	JSON Web Token Claims registry, as per <xref
	target="IANA"></xref>.  The syntaxes referred to above
	are:</t>

	<texttable anchor="SyntaxDefinitions">
	  <ttcol align="left">Syntax Name</ttcol>
	  <ttcol align="left">Syntax Definition</ttcol>

	  <c>StringAndURI</c>
	  <c>Any string value MAY be used but a value containing a ":"
	  character MUST be a URI as defined in <xref
	  target="RFC3986">RFC 3986</xref>.</c>

	  <c>URI</c>
	  <c>A URI as defined in <xref target="RFC3986">RFC 3986</xref>.</c>

	  <c>IntDate</c>
	  <c>The number of seconds from 1970-01-01T0:0:0Z as measured
	  in UTC until the desired date/time. See <xref
	  target="RFC3339">RFC 3339</xref> for details regarding
	  date/times in general and UTC in particular.</c>
	</texttable>

      </section>

      <section title="Public Claim Names" anchor="PublicClaimName">

        <t>Claim names can be defined at will by those using
        JWTs. However, in order to prevent collisions, any new claim
        name SHOULD either be defined in the IANA
        JSON Web Token Claims registry or be defined as
        a URI that contains a collision resistant namespace. Examples
        of collision resistant namespaces include:

          <list style="symbols">
            <t>Domain Names,</t>

            <t>Object Identifiers (OIDs) as defined in the ITU-T X 660 and X
            670 Recommendation series or</t>

            <t>Universally Unique IDentifier (UUID) as defined in <xref
            target="RFC4122">RFC 4122</xref>.</t>
          </list>
        In each case, the definer of the name or value MUST take
        reasonable precautions to make sure they are in control of the part of
        the namespace they use to define the claim name.</t>
      </section>

      <section title="Private Claim Names" anchor="PrivateClaimName">

         <t>A producer and consumer of a JWT may agree to any claim
         name that is not a Reserved Name <xref target="ReservedClaimName"></xref>
	 or a Public Name <xref target="PublicClaimName"></xref>. Unlike
         Public Names, these private names are subject to collision and
         should be used with caution.</t>

      </section>
    </section>

    <section title="JWT Envelope">

      <t>The members of the JSON object represented by the Decoded JWT
      Envelope Segment describe the signature applied to the JWT Claim
      Segment and optionally additional properties of the JWT.
      Implementations MUST understand the entire contents of the
      envelope; otherwise, the JWT MUST be rejected for
      processing.</t>

      <section title="Reserved Envelope Parameter Names" anchor="ReservedEnvelopeParameterName">
	<t>The following envelope parameter names are reserved.  All
	the names are short because a core goal of JWTs is for the
	tokens themselves to be short.</t>

	<texttable title="Reserved Envelope Parameter Definitions" anchor="EnvelopeParameterTable">

	  <ttcol align="left">Envelope Parameter Name</ttcol>
	  <ttcol align="left">JSON Value Type</ttcol>
	  <ttcol align="left">Envelope Parameter Syntax</ttcol>
	  <ttcol align="left">Envelope Parameter Semantics</ttcol>

	  <c>alg</c>
	  <c>string</c>
	  <c>StringAndURI</c>
	  <c>The "alg" (algorithm) envelope parameter identifies the
	  cryptographic algorithm used to secure the JWT.  A list of
	  reserved alg values is in <xref target="AlgTable"></xref>.
	  The processing of the "alg" (algorithm) envelope parameter,
	  if present, requires that the value of the "alg" envelope
	  parameter MUST be one that is both supported and for which
	  there exists a key for use with that algorithm associated
	  with the issuer of the JWT.  Note however, that if the "iss"
	  (issuer) claim is not included in the JWT Claim Segment,
	  then the manner in which the issuer is determined is
	  application specific. This envelope parameter is
	  REQUIRED.</c>

	  <c>typ</c>
	  <c>string</c>
	  <c>StringAndURI</c>
	  <c>The "typ" (type) envelope parameter is used to declare
	  that this data structure is a JWT.  If a "typ" parameter is
	  present, its value MUST be "JWT".  This envelope parameter
	  is OPTIONAL.  (Non-normative note: Other values could be
	  used by other specifications to declare data structures
	  other than JWTs, for instance, encrypted JSON tokens.)</c>

	  <c>keyid</c>
	  <c>string</c>
	  <c>String</c>
	  <c>The "keyid" (key ID) envelope parameter is a hint
	  indicating which specific key owned by the signer should be
	  used to validate the signature.  This allows signers to
	  explicitly signal a change of key to recipients. Omitting
	  this parameter is equivalent to setting it to an empty
	  string. The format of this parameter is unspecified.  This
	  envelope parameter is OPTIONAL.</c>

	  <c>curi</c>
	  <c>string</c>
	  <c>URI</c>
	  <c>The "curi" (certificates URI) envelope parameter is a URI
	  that points to X.509 public key certificates that can be
	  used to validate the signature.  This envelope parameter is
	  OPTIONAL.</c>

	  <c>ctp</c>
	  <c>string</c>
	  <c>String</c>
	  <c>The "ctp" (certificate thumbprint) envelope parameter
	  provides a base64url encoded SHA-1 thumbprint of the DER
	  encoding of a certificate that can be used to validate the
	  signature.  This envelope parameter is OPTIONAL.</c>

	</texttable>

	<t>Additional reserved envelope parameter names MAY be defined
	via the IANA JSON Web Token Envelope Parameters registry, as
	per <xref target="IANA"></xref>.  The envelope value syntaxes
	referred to above are defined in <xref
	target="SyntaxDefinitions"></xref>.</t>

      </section>

      <section title="Public Envelope Parameter Names" anchor="PublicEnvelopeParameterName">

        <t>Additional envelope parameter names can be defined by those using
        JWTs. However, in order to prevent collisions, any new envelope parameter
        name or algorithm value SHOULD either be defined in the IANA
        JSON Web Token Envelope Parameters registry or be defined as
        a URI that contains a collision resistant namespace.
        In each case, the definer of the name or value MUST take
        reasonable precautions to make sure they are in control of the part of
        the namespace they use to define the envelope parameter name.</t>

	<t>New envelope parameters should be introduced sparingly, as
	they can result in non-interoperable JWTs.  Nonetheless, some
	extensions needed for some use cases may require them, such as
	an extension to enable the inclusion of multiple
	signatures.</t>
      </section>

      <section title="Private Envelope Parameter Names" anchor="PrivateEnvelopeParameterName">

         <t>A producer and consumer of a JWT may agree to any envelope parameter
         name that is not a Reserved Name <xref target="ReservedEnvelopeParameterName"></xref>
	 or a Public Name <xref target="PublicEnvelopeParameterName"></xref>. Unlike
         Public Names, these private names are subject to collision and
         should be used with caution.</t>

	<t>New envelope parameters should be introduced sparingly, as
	they can result in non-interoperable JWTs.</t>

      </section>
    </section>

    <section title="General Rules for Creating and Validating a JWT">
      <t>To create a JWT one MUST follow these steps:
        <list style="numbers">

          <t>Create a JSON object containing the desired claims.  Note
          that white space is explicitly allowed in the representation
          and no canonicalization is performed before encoding.</t>

          <t>Translate this JSON object's Unicode code points into
          UTF-8, as defined in <xref target="RFC3629">RFC
          3629</xref>.</t>

          <t>Base64url encode the UTF-8 representation of this
          JSON object as defined in this specification (without
          padding). This encoding becomes the JWT Claim Segment.</t>

	  <t>Create a different JSON object containing the desired
	  envelope parameters.  Note that white space is explicitly
	  allowed in the representation and no canonicalization is
	  performed before encoding.</t>

          <t>Translate this JSON object's Unicode code points into
          UTF-8, as defined in <xref target="RFC3629">RFC
          3629</xref>.</t>

          <t>Base64url encode the UTF-8 representation of this JSON
          object as defined in this specification (without
          padding). This encoding becomes the JWT Envelope
          Segment.</t>

          <t>Construct the JWT Crypto Segment as defined for the
          particular algorithm being used.  The "alg" envelope
          parameter MUST be present in the JSON Envelope Segment, with
          the algorithm value accurately representing the algorithm
          used to construct the JWT Crypto Segment.</t>

          <t>Combine the JWT Envelope Segment, the JWT Claim Segment
          and then the JWT Crypto Segment in that order, separating
          each by period characters, to create the JWT.</t>

        </list></t>

      <t>When validating a JWT the following steps MUST be taken. If
      any of the listed steps fails then the token MUST be rejected
      for processing.</t>

      <t><list style="numbers">

          <t>The JWT MUST contain two period characters.</t>

          <t>The JWT MUST be split on the two period characters
          resulting in three non-empty segments.  The first segment is
          the JWT Envelope Segment; the second is the JWT Claim
          Segment; the third is the JWT Crypto Segment.</t>

          <t>The JWT Envelope Segment MUST be successfully base64url
          decoded following the restriction given in this spec that no
          padding characters may have been used.</t>

          <t>The Decoded JWT Envelope Segment MUST be completely valid
          JSON syntax.</t>

          <t>The JWT Claim Segment MUST be successfully base64url
          decoded following the restriction given in this spec that no
          padding characters may have been used.</t>

          <t>The Decoded JWT Claim Segment MUST be completely valid
          JSON syntax.</t>

          <t>The JWT Crypto Segment MUST be successfully base64url
          decoded following the restriction given in this spec that no
          padding characters may have been used.</t>

          <t>The JWT Envelope Segment MUST be validated to only
          include parameters and values whose syntax and semantics are
          both understood and supported.</t>

          <t>When used in a security-related context, the JWT Claim
          Segment MUST be validated to only include claims whose
          syntax and semantics are both understood and supported.</t>

          <t>The JWT Crypto Segment MUST be successfully validated
          against the JWT Claim Segment in the manner defined for the
          algorithm being used, which MUST be accurately represented
          by the value of the "alg" envelope parameter, which MUST be
          present.</t>

        </list></t>

      <t>Processing a JWT inevitably requires comparing known strings
      to values in the token. For example, in checking what the
      algorithm is, the Unicode string encoding "alg" will be checked
      against the member names in the Decoded JWT Envelope Segment to
      see if there is a matching envelope parameter name. A similar
      process occurs when determining if the value of the "alg"
      envelope parameter represents a supported algorithm. Comparing
      Unicode strings, however, has significant security implications,
      as per <xref target="Security"></xref>.</t>

      <t>Comparisons between JSON strings and other Unicode strings
      MUST be performed as specified below:</t>

      <t><list style="numbers">

          <t>Remove any JSON applied escaping to produce an array of
          Unicode code points.</t>

          <t><xref target="USA15">Unicode Normalization</xref> MUST
          NOT be applied at any point to either the JSON string or to
          the string it is to be compared against.</t>

          <t>Comparisons between the two strings MUST be performed as
          a Unicode code point to code point equality comparison.</t>

        </list></t>

    </section>

    <section title="Base64url encoding as used by JWTs" anchor="base64urllogic">

      <t>JWTs make use of the base64url encoding as defined in <xref
      target="RFC4648">RFC 4648</xref>. As allowed by Section 3.2 of the
      RFC, this specification mandates that base64url encoding
      when used with JWTs MUST NOT use padding. The reason for this
      restriction is that the padding character ('=') is not URL
      safe.</t>

      <t>For notes on implementing base64url encoding without padding,
      see <xref target="base64urlnotes"></xref>.</t>
    </section>

  <section title="Signing JWTs with Cryptographic Algorithms" anchor="Signing">

    <t>JWTs use specific cryptographic algorithms to sign the contents
    of the JWT Claim Segment.  The use of the following algorithms for
    producing JWTs is defined in this section.  The table below is the
    list of "alg" envelope parameter values reserved by this
    specification, each of which is explained in more detail in the
    following sections:</t>

      <texttable title="JSON Web Token Reserved Algorithm Values" anchor="AlgTable">

        <ttcol align="left">Alg Claim Value</ttcol>
        <ttcol align="left">Algorithm</ttcol>

        <c>HS256</c>
        <c>HMAC using SHA-256 hash algorithm</c>

        <c>HS384</c>
        <c>HMAC using SHA-384 hash algorithm</c>

        <c>HS512</c>
        <c>HMAC using SHA-512 hash algorithm</c>

        <c>RS256</c>
        <c>RSA using SHA-256 hash algorithm</c>

        <c>RS384</c>
        <c>RSA using SHA-384 hash algorithm</c>

        <c>RS512</c>
        <c>RSA using SHA-512 hash algorithm</c>

        <c>ES256</c>
        <c>ECDSA using P-256 curve and SHA-256 hash algorithm</c>

        <c>ES384</c>
        <c>ECDSA using P-384 curve and SHA-384 hash algorithm</c>

        <c>ES512</c>
        <c>ECDSA using P-521 curve and SHA-512 hash algorithm</c>

      </texttable>

    <t>Of these algorithms, only HMAC SHA-256 and RSA SHA-256 MUST be
    implemented.  It is RECOMMENDED that implementations also
    implement at least the ECDSA P-256 SHA-256 algorithm.</t>

    <section title="Signing a JWT with HMAC SHA-256" anchor="SigningWithHMACSHA256">

      <t>Hash based Message Authentication Codes (HMACs) enable one to
      use a secret plus a cryptographic hash function to generate a
      Message Authentication Code (MAC). This can be used to
      demonstrate that the MAC matches the hashed content, in this
      case the JWT Claim Segment, which therefore demonstrates that
      whoever generated the MAC was in possession of the
      secret.</t>

      <t>The algorithm for implementing and validating HMACs is
      provided in <xref target="RFC2104">RFC 2104</xref>. Although any
      HMAC can be used with JWTs, this section defines the use of the
      SHA-256 cryptographic hash function as defined in <xref
      target="FIPS.180-3">FIPS 180-3</xref>. The reserved "alg"
      envelope parameter value "HS256" is used in the JWT Envelope
      Segment to indicate that the JWT Crypto Segment contains a
      base64url encoded HMAC SHA-256 HMAC value.</t>

      <t>The HMAC SHA-256 MAC is generated as follows:
        <list style="numbers">
          <t>Take the bytes of the UTF-8 representation of the JWT
          Claim Segment and execute the HMAC SHA-256 algorithm on them
          using the shared key to produce an HMAC.</t>

          <t>Base64url encode the HMAC as defined in this document.</t>
        </list>
      The output is placed in the JWT Crypto Segment for that JWT.</t>

      <t>The HMAC SHA-256 MAC on a JWT is validated as follows:
        <list style="numbers">

          <t>Take the bytes of the UTF-8 representation of the JWT
          Claim Segment and calculate an HMAC SHA-256 MAC on them
          using the shared key.</t>

          <t>Base64url encode the previously generated HMAC as defined in this
          document.</t>

          <t>If the JWT Crypto Segment and the previously calculated value
          exactly match in a character by character, case sensitive
          comparison, then one has confirmation that the key was
          used to generate the HMAC on the JWT and that the contents of
          the JWT Claim Segment have not be tampered with.</t>

	  <t>If the validation fails, the token MUST be rejected.</t>

        </list></t>

      <t>Signing with the HMAC SHA-384 and HMAC SHA-512 algorithms is
      performed identically to the procedure for HMAC SHA-256 - just
      with correspondingly longer key and result values.</t>

      <t>JWT implementations MUST support the HMAC SHA-256 algorithm.
      Support for the HMAC SHA-384 and HMAC SHA-512 algorithms is
      OPTIONAL.</t>

    </section>

    <section title="Signing a JWT with RSA SHA-256" anchor="DefiningRSA">

      <t>This section defines the use of the RSASSA-PKCS1-v1_5
      signature algorithm as defined in <xref target="RFC3447">RFC
      3447</xref>, Section 8.2 (commonly known as PKCS#1), using
      SHA-256 as the hash function.  Note that the use of the
      RSASSA-PKCS1-v1_5 algorithm is permitted in <xref
      target="FIPS.186-3">FIPS 186-3</xref>, Section 5.5, as is the
      SHA-256 cryptographic hash function, which is defined in <xref
      target="FIPS.180-3">FIPS 180-3</xref>.  The reserved "alg"
      envelope parameter value "RS256" is used in the JWT Envelope
      Segment to indicate that the JWT Crypto Segment contains an RSA
      SHA-256 signature.</t>

      <t>A 2048-bit or longer key length MUST be used with this algorithm.</t>

      <t>The RSA SHA-256 signature is generated as follows:
        <list style="numbers">

          <t>Let K be the signer's RSA private key and let M be the
          bytes of the UTF-8 representation of the JWT Claim
          Segment.</t>

	  <t>Compute the octet string S = RSASSA-PKCS1-V1_5-SIGN (K, M).</t>

          <t>Base64url encode the octet string S, as defined in this document.</t>

        </list>
      The output is placed in the JWT Crypto Segment for that JWT.</t>

      <t>The RSA SHA-256 signature on a JWT is validated as follows:
        <list style="numbers">

          <t>Take the JWT Crypto Segment and base64url decode it into
          an octet string S. If decoding fails, then the token MUST be
          rejected.</t>

          <t>Let M be the bytes of the UTF-8 representation of the JWT
          Claim Segment and let (n, e) be the public key corresponding
          to the private key used by the signer.</t>

          <t>Validate the signature with RSASSA-PKCS1-V1_5-VERIFY
	  ((n, e), M, S).</t>

	  <t>If the validation fails, the token MUST be rejected.</t>

        </list>
      </t>

      <t>Signing with the RSA SHA-384 and RSA SHA-512 algorithms is
      performed identically to the procedure for RSA SHA-256 - just
      with correspondingly longer key and result values.</t>

      <t>JWT implementations MUST support the RSA SHA-256 algorithm.
      Support for the RSA SHA-384 and RSA SHA-512 algorithms is
      OPTIONAL.</t>

    </section>

    <section title="Signing a JWT with ECDSA P-256 SHA-256" anchor="DefiningECDSA">
      <t>The Elliptic Curve Digital Signature Algorithm (ECDSA) is
      defined by <xref target="FIPS.186-3">FIPS 186-3</xref>. ECDSA
      provides for the use of Elliptic Curve cryptography, which is
      able to provide equivalent security to RSA cryptography but
      using shorter key lengths and with greater processing
      speed. This means that ECDSA signatures will be substantially
      smaller in terms of length than equivalently strong RSA Digital
      Signatures.</t>

      <t>This specification defines the use of ECDSA with the P-256
      curve and the SHA-256 cryptographic hash function. The P-256
      curve is also defined in FIPS 186-3. The reserved "alg" envelope
      parameter value "ES256" is used in the JWT Envelope Segment to
      indicate that the JWT Crypto Segment contains a ECDSA P-256
      SHA-256 signature.</t>

      <t>A JWT is signed with an ECDSA P-256 SHA-256 signature as
      follows:
        <list style="numbers">
          <t>Take the bytes of the UTF-8 representation of the JWT
          Claim Segment and generate a digital signature of them using
          ECDSA P-256 SHA-256 with the desired private key. The output
          will be the EC point (R, S), where R and S are unsigned
          integers.</t>

          <t>Turn R and S into byte arrays in big endian order. Each array
          will be 32 bytes long.</t>

          <t>Concatenate the two byte arrays in the order R and then S.</t>

          <t>Base64url encode the 64 byte array as defined in this specification.</t>
        </list>
      The output becomes the JWT Crypto Segment for the JWT.</t>

      <t>The following procedure is used to validate the ECDSA
      signature of a JWT:
        <list style="numbers">
          <t>Take the JWT Crypto Segment and base64url decode it into
          a byte array. If decoding fails, the token MUST be rejected.</t>

          <t>The output of the base64url decoding MUST be a 64 byte array.</t>

          <t>Split the 64 byte array into two 32 byte arrays. The first array
          will be R and the second S. Remember that the byte arrays are
          in big endian byte order; please check the ECDSA validator in
          use to see what byte order it requires.</t>

          <t>Submit the bytes of the UTF-8 representation of the JWT
	  Claim Segment, R, S and the public key (x, y) to the ECDSA
	  P-256 SHA-256 validator.</t>

	  <t>If the validation fails, the token MUST be rejected.</t>

        </list>

      The ECDSA validator will then determine if the digital signature
      is valid, given the inputs.  Note that ECDSA digital signature
      contains a value referred to as K, which is a random number
      generated for each digital signature instance. This means that
      two ECDSA digital signatures using exactly the same input
      parameters will output different signatures because their K
      values will be different. The consequence of this is that one
      must validate an ECDSA signature by submitting the previously
      specified inputs to an ECDSA validator.</t>

      <t>Signing with the ECDSA P-384 SHA-384 and ECDSA P-521 SHA-512 algorithms is
      performed identically to the procedure for ECDSA P-256 SHA-256 - just
      with correspondingly longer key and result values.</t>

      <t>It is RECOMMENDED that JWT implementations support the ECDSA
      P-256 SHA-256 algorithm.  Support for the ECDSA P-384 SHA-384
      and ECDSA P-521 SHA-512 algorithms is OPTIONAL.</t>

    </section>

    <section title="Additional Algorithms">

      <t>Additional algorithms MAY be used to protect JWTs with
      corresponding "alg" envelope parameter values being defined to
      refer to them. Like claim names, new "alg" envelope parameter
      values SHOULD either be defined in the IANA JSON Web Token
      Algorithms registry or be a URI that contains a collision
      resistant namespace.  In particular, the use of algorithm
      identifiers defined in <xref target="RFC3275">XML DSIG</xref>
      and related specifications is permitted.</t>

    </section>
  </section>

    <section title="IANA Considerations" anchor="IANA">
      <t>This specification calls for:
        <list style="symbols">

          <t>A new IANA registry entitled "JSON Web Token Claims" for
          reserved claim names <xref
          target="ReservedClaimName"></xref> used in a Decoded JWT
          Claim Segment. Inclusion in the registry is RFC Required in
          the <xref target="RFC5226">RFC 5226</xref> sense for
          reserved JWT claim names that are intended to be
          interoperable between implementations.  The registry will
          just record the reserved claim name and a pointer to the RFC
          that defines it. This specification defines inclusion of the
          claim names defined in <xref
          target="ClaimTable"></xref>.</t>

          <t>A new IANA registry entitled "JSON Web Token Envelope
          Parameters" for reserved envelope parameter names <xref
          target="ReservedEnvelopeParameterName"></xref> used in a
          Decoded JWT Envelope Parameter Segment. Inclusion in the
          registry is RFC Required in the <xref target="RFC5226">RFC
          5226</xref> sense for reserved JWT envelope parameter names
          that are intended to be interoperable between
          implementations.  The registry will just record the reserved
          envelope parameter name and a pointer to the RFC that
          defines it. This specification defines inclusion of the
          envelope parameter names defined in <xref
          target="EnvelopeParameterTable"></xref>.</t>

          <t>A new IANA registry entitled "JSON Web Token Algorithms"
          for reserved values used with the "alg" envelope parameter
          values used in a decoded JWT Envelope Segment. Inclusion in
          the registry is RFC Required in the <xref
          target="RFC5226">RFC 5226</xref> sense. The registry will
          just record the "alg" value and a pointer to the RFC that
          defines it.  This specification defines inclusion of the
          algorithm values defined in <xref
          target="AlgTable"></xref>.</t>
        </list></t>
    </section>

    <section title="Security Considerations" anchor="Security">
      <t>TBD: Lots of work to do here. We need to remember to look
      into any issues relating to security and JSON parsing. One
      wonders just how secure most JSON parsing libraries are. Were
      they ever hardened for security scenarios? If not, what kind of
      holes does that open up? Also, we need to walk through the JSON
      standard and see what kind of issues we have especially around
      comparison of names.  For instance, comparisons of claim names
      and other parameters must occur after they are unescaped. Need
      to also put in text about: Importance of keeping secrets
      secret. Rotating keys. Strengths and weaknesses of the different
      algorithms. Case sensitivity and more generally Unicode
      comparison issues that can cause security holes, especially in
      claim names and explain why Unicode Normalization is such a
      problem.</t>

      <t>TBD: Need to put in text about why strict JSON validation is necessary.
      Basically, that if malformed JSON is received then the intent of the
      sender is impossible to reliably discern. While in non-security
      contexts it's o.k. to be generous in what one accepts, in security
      contexts this can lead to serious security holes. For example, malformed
      JSON might indicate that someone has managed to find a security hole in
      the issuer's code and is leveraging it to get the issuer to issue "bad"
      tokens whose content the attacker can control.</t>

      <section title="Unicode Comparison Security Issues">

        <t>Claim names in JWTs are Unicode strings.  For security
        reasons, the representations these names must be compared verbatim after performing
        any escape processing (as per <xref target="RFC4627">RFC
        4627</xref>, Section 2.5).  In particular, <xref
        target="USA15">Unicode Normalization</xref> or case folding
        MUST NOT be applied at any point to either the JSON string or
        to the string it is to be compared against.</t>

        <t>This means, for instance, that these JSON strings must
        compare as being equal ("JWT", "\u004aWT"), whereas these must
        all compare as being not equal to the first set or to each other
        ("jwt", "Jwt", "JW\u0074").</t>

	<t>JSON strings MAY contain characters outside the Unicode
        Basic Multilingual Plane.  For instance, the G clef character
        (U+1D11E) may be represented in a JSON string as
        "\uD834\uDD1E".  Ideally, JWT implementations SHOULD ensure
        that characters outside the Basic Multilingual Plane are
        preserved and compared correctly; alternatively, if this is
        not possible due to these characters exercising limitations
        present in the underlying JSON implementation, then input
        containing them MUST be rejected.</t>

      </section>
    </section>

    <section title="Open Issues" anchor="OpenIssues">

      <t>The following open issues have been identified during review
      of previous drafts.  Additional input on them is solicited.</t>

      <list style="symbols">

        <t>The draft currently defines no mechanism(s) for retrieving
        public keys that are not encoded as X.509 certificates.  A
        mechanism or mechanisms similar to the Magic Signatures key
        discovery process for Magic Keys could be added to future
        drafts.  Some have suggested that they keys themselves also be
        encoded as JWTs.</t>

	<t>Related to the above, it's not clear whether the "iss"
	claim should be expected to contain a location for retrieving
	non-X.509 public keys, or whether a separate issuer key
	location parameter should be defined.  Also, does this belong
	in the envelope or the claims?</t>

      </list>
    </section>

    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>The authors acknowledge that the design of JWTs was
      intentionally influenced by the design and simplicity of <xref
      target="SWT">Simple Web Tokens</xref>.  Solutions for signing
      JSON tokens were also previously explored by <xref
      target="MagicSignatures">Magic Signatures</xref>, <xref
      target="JSS">JSON Simple Sign</xref>, and <xref
      target="CanvasApp">Canvas Applications</xref>, all of which influenced this draft.</t>

    </section>

    <section title="Appendix - Non-Normative - JWT Examples" anchor="JWTExamples">

      <section title="JWT using HMAC SHA-256" anchor="HMACSHA256Example">
		  <section title="Encoding">
        <t>The Decoded JWT Claim Segment used in this example is:</t>

      <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

    <t>Note that white space is explicitly allowed in Decoded JWT Claim Segments
    and no canonicalization is performed before encoding. The
    following byte array contains the UTF-8 characters for the
    Decoded JWT Claim Segment:</t>

    <t>

[123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34,
  44, 13, 10, 32, 34, 101, 120, 112, 34, 58, 49, 51,
  48, 48, 56, 49, 57, 51, 56, 48, 44, 13, 10, 32, 34,
  104, 116, 116, 112, 58, 47, 47, 101, 120, 97, 109, 112,
  108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111,
  111, 116, 34,
58, 116, 114, 117, 101, 125]

    </t>

    <t>Base64url encoding the above yields the JWT Claim Segment value:</t>

      <artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

      <t>The following example JSON envelope object declares that the
      encoded object is a JSON Web Token (JWT) and the JWT Claim
      Segment is signed using the HMAC SHA-256 algorithm:</t>

      <artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork>

      <t> The following byte array contains the UTF-8 characters for
      the Decoded JWT Envelope Segment:</t>

    <t>

[123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34,
  44, 13, 10, 32, 34, 97, 108, 103, 34, 58, 34, 72, 83,
  50, 53, 54, 34, 125]

    </t>

      <t>Base64url encoding this UTF-8 representation yields this JWT
      Envelope Segment value:</t>

      <artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork>

    <t>HMACs are generated using keys. This example used the
    key represented by the following byte array:</t>

    <t>

[83, 159, 117, 12, 235, 169, 168, 200, 131, 152, 227,
  246, 214, 212, 188, 74, 71, 83, 244, 166, 90, 24, 239,
  251, 32, 124, 6, 201, 194, 104, 241, 62, 174, 246, 65,
  111, 49, 52, 210, 118, 212, 124, 34, 88, 167, 112, 84,
  88, 83, 65, 155, 18, 234, 250, 224, 101, 147, 221, 23,
  104, 219, 170, 146, 215]
    
    </t>

    <t>Running the HMAC SHA-256 algorithm on the JWT Claim Segment
    with this key yields the following byte array:</t>

    <t>

[223, 155, 172, 90, 63, 87, 240, 124, 6, 75, 224, 131,
  115, 29, 73, 63, 99, 102, 169, 202, 203, 193, 158, 4,
  42, 159, 44, 53, 56, 95, 221, 198]

    </t>

    <t>Base64url encoding the above HMAC output yields the JWT Crypto Segment value:</t>

    <artwork><![CDATA[35usWj9X8HwGS-CDcx1JP2NmqcrLwZ4EKp8sNThf3cY]]></artwork>

      <t>Combining these segments in the order
      Envelope.Claims.Signature with period characters between the
      segments yields this complete JWT (with line breaks for display
      purposes only):</t>

      <artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
35usWj9X8HwGS-CDcx1JP2NmqcrLwZ4EKp8sNThf3cY]]></artwork>

</section>
<section title="Decoding">

      <t>Decoding the JWT first requires removing the base64url
      encoding from the JWT Envelope Segment and the JWT Claim
      Segment. We base64url decode the segments per <xref
      target="base64urllogic"></xref> and turn them into the
      corresponding UTF-8 byte arrays, which we then translate into
      the Decoded JWT Envelope Segment and Decoded JWT Claim Segment
      strings.</t>

</section>
<section title="Validating">

      <t>Next we validate the decoded results.  Since the "alg"
      parameter in the envelope is "HS256", we validate the HMAC
      SHA-256 signature contained in the JWT Crypto Segment.  If any
      of the validation steps fail, the token MUST be rejected.</t>

      <t>First, we validate that the decoded envelope and claim
      segment strings are both legal JSON.</t>

      <t>To validate the signature, we repeat the previous process of
      using the correct key and the JWT Claim Segment as input to a
      SHA-256 HMAC function and then taking the output, base64url
      encoding it, and determining if it matches the JWT Crypto
      Segment in the JWT.  If it matches exactly, the token has been
      validated.</t>

    </section>
  </section>

  <section title="JWT using RSA SHA-256">

    <section title="Encoding">
      <t>The Decoded JWT Claim Segment used in this example is the same as in the previous example:</t>

        <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

      <t>Since the JWT Claim Segment will therefore be the same, its
      computation is not repeated here.  However, the Decoded JWT
      Envelope Segment is different in two ways: First, because a
      different algorithm is being used, the "alg" value is
      different.  Second, for illustration purposes only, the
      optional "typ" parameter is not used.  (This difference is not
      related to the signature algorithm employed.)  The Decoded JWT
      Envelope Segment used is:</t>

      <artwork><![CDATA[{"alg":"RS256"}]]></artwork>

      <t> The following byte array contains the UTF-8 characters for
      the Decoded JWT Envelope Segment:</t>

    <t>

 [123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53,
  54, 34, 125]

    </t>

      <t>Base64url encoding this UTF-8 representation yields this JWT
      Envelope Segment value:</t>

      <artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9]]></artwork>

        <t>The RSA key consists of a public part (n, e), and a
        private exponent d.  The values of the RSA key used in this
        example, presented as the byte arrays representing
        big endian integers are:</t>

        <texttable>
	  <ttcol align="left">Parameter Name</ttcol>
	  <ttcol align="left">Value</ttcol>

	  <c>n</c>
	  <c>

[210, 252, 123, 106, 10, 30, 108, 103, 16, 74, 235, 143,
136, 178, 87, 102, 155, 77, 246, 121, 221, 173, 9, 155,
92, 74, 108, 217, 168, 128, 21, 181, 161, 51, 191, 11,
133, 108, 120, 113, 182, 223, 0, 11, 85, 79, 206, 179,
194, 237, 81, 43, 182, 143, 20, 92, 110, 132, 52, 117,
47, 171, 82, 161,
207, 193, 36, 64, 143, 121, 181, 138, 69, 120, 193,
100, 40, 133, 87, 137, 247, 162, 73, 227, 132, 203, 45,
159, 174, 45, 103, 253, 150, 251, 146, 108, 25, 142, 7,
115, 153, 253, 200, 21, 192, 175, 9, 125, 222, 90, 173,
239, 244, 77, 231, 14, 130, 127, 72, 120, 67, 36, 57,
191, 238, 185, 96, 104,
208, 71, 79, 197, 13, 109, 144, 191, 58, 152, 223, 175,
16, 64, 200, 156, 2, 214, 146, 171, 59, 60, 40, 150,
96, 157, 134, 253, 115, 183, 116, 206, 7, 64, 100, 124,
238, 234, 163, 16, 189, 18, 249, 133, 168, 235, 159,
89, 253, 212, 38, 206, 165, 178, 18, 15, 79, 42, 52,
188, 171, 118, 75, 126,
108, 84, 214, 132, 2, 56, 188, 196, 5, 135, 165, 158,
102, 237, 31, 51, 137, 69, 119, 99, 92, 71, 10, 247,
92, 249, 44, 32, 209, 218, 67, 225, 191, 196, 25, 226,
34, 166, 240, 208, 187, 53, 140, 94, 56, 249, 203, 5,
10, 234, 254, 144, 72, 20, 241, 172, 26, 164, 156, 202,
158, 160, 202, 131]

	  </c>

	  <c>e</c>
	  <c>

[1, 0, 1]

	  </c>

	  <c>d</c>
	  <c>

[95, 135, 19, 181, 226, 88, 254, 9, 248, 21, 131, 236,
92, 31, 43, 117, 120, 177, 230, 252, 44, 131, 81, 75,
55, 145, 55, 17, 161, 186, 68, 154, 21, 31, 225, 203,
44, 160, 253, 51, 183, 113, 230, 138, 59, 25, 68, 100,
157, 200, 103, 173, 28, 30, 82, 64, 187, 133, 62, 95,
36, 179, 52, 89,
177, 64, 40, 210, 214, 99, 107, 239, 236, 30, 141, 169,
116, 179, 82, 252, 83, 211, 246, 18, 126, 168, 163,
194, 157, 209, 79, 57, 65, 104, 44, 86, 167, 135, 104,
22, 78, 77, 218, 143, 6, 203, 249, 199, 52, 170, 232,
0, 50, 36, 39, 142, 169, 69, 74, 33, 177, 124, 176,
109, 23, 128, 117, 134,
140, 192, 91, 61, 182, 255, 29, 253, 195, 213, 99, 120,
180, 237, 173, 237, 240, 195, 122, 76, 220, 38, 209,
212, 154, 194, 111, 111, 227, 181, 34, 10, 93, 210,
147, 150, 98, 27, 188, 104, 140, 242, 238, 226, 198,
224, 213, 77, 163, 199, 130, 1, 76, 208, 115, 157, 178,
82, 204, 81, 202, 235, 168, 211,
241, 184, 36, 186, 171, 36, 208, 104, 236, 144, 50,
100, 215, 214, 120, 171, 8, 240, 110, 201, 231, 226,
61, 150, 6, 40, 183, 68, 191, 148, 179, 105, 70, 86,
70, 60, 126, 65, 115, 153, 237, 115, 208, 118, 200,
145, 252, 244, 99, 169, 170, 156, 230, 45, 169, 205,
23, 226, 55, 220, 42, 128, 2, 241]

	  </c>
        </texttable>

	<t>The RSA private key (n, d) is then passed to the RSA
	signing function, which also takes the hash type, SHA-256, and
	the JWT Claim Segment as inputs.  The result of the signature
	is a byte array S, which represents a big endian integer.  In
	this example, S is:</t>

	<texttable>
	  <ttcol align="left">Result Name</ttcol>
	  <ttcol align="left">Value</ttcol>

	  <c>S</c>
	  <c>

[208, 141, 219, 44, 66, 129, 179, 230, 69, 120, 123,
108, 203, 96, 182, 145, 66, 179, 198, 104, 43, 187,
199, 159, 175, 5, 217, 101, 109, 236, 88, 136, 193,
133, 79, 39, 162, 131, 58, 114, 133, 202, 171, 227,
135, 157, 123, 188, 90, 111, 66, 241, 38, 238, 59, 18,
125, 146, 129, 14, 54, 183, 10, 221,
33, 105, 37, 173, 119, 239, 92, 27, 232, 175, 173, 49,
21, 28, 252, 237, 183, 107, 98, 156, 113, 116, 162,
219, 53, 96, 44, 214, 175, 154, 61, 100, 175, 90, 118,
247, 42, 196, 45, 74, 217, 145, 92, 39, 123, 224, 247,
171, 206, 203, 91, 167, 103, 57, 163, 87, 172, 67, 77,
255, 9, 218, 107, 62,
228, 71, 239, 36, 246, 23, 96, 108, 28, 19, 179, 24,
167, 196, 42, 97, 198, 80, 241, 79, 31, 0, 85, 17,
50, 6, 143, 238, 214, 131, 246, 13, 49, 111, 30, 142,
182, 145, 200, 17, 127, 76, 236, 69, 66, 133, 198, 137,
103, 45, 3, 48, 123, 203, 17, 162, 1, 105, 133, 22,
105, 25, 63, 173,
186, 231, 206, 246, 22, 243, 250, 53, 237, 209, 36,
111, 168, 11, 40, 237, 179, 83, 125, 180, 84, 231, 129,
37, 236, 172, 22, 234, 58, 198, 187, 124, 65, 145, 148,
227, 122, 177, 16, 176, 84, 28, 1, 141, 179, 57, 96,
232, 215, 51, 7, 49, 63, 195, 155, 94, 51, 22, 239,
90, 138, 207, 41, 62]

	  </c>
	</texttable>

	<t>Base64url encoding the signature produces this value for the JWT
	Crypto Segment:</t>

	<artwork><![CDATA[0I3bLEKBs-ZFeHtsy2C2kUKzxmgru8efrwXZZW3sWIjBhU8nooM6coXKq-OHnXu8Wm9C8SbuOxJ9koEONrcK3SFpJa1371wb6K-tMRUc_O23a2KccXSi2zVgLNavmj1kr1p29yrELUrZkVwne-D3q87LW6dnOaNXrENN_wnaaz7kR-8k9hdgbBwTsxinxCphxlDxTx8AVREyBo_u1oP2DTFvHo62kcgRf0zsRUKFxolnLQMwe8sRogFphRZpGT-tuufO9hbz-jXt0SRvqAso7bNTfbRU54El7KwW6jrGu3xBkZTjerEQsFQcAY2zOWDo1zMHMT_Dm14zFu9ais8pPg]]></artwork>

      <t>Combining these segments in the order
      Envelope.Claims.Signature with period characters between the
      segments yields this complete JWT (with line breaks for display
      purposes only):</t>

      <artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
0I3bLEKBs-ZFeHtsy2C2kUKzxmgru8efrwXZZW3sWIjBhU8nooM6coXKq-OHnXu8Wm9C8SbuOxJ9koEONrcK3SFpJa1371wb6K-tMRUc_O23a2KccXSi2zVgLNavmj1kr1p29yrELUrZkVwne-D3q87LW6dnOaNXrENN_wnaaz7kR-8k9hdgbBwTsxinxCphxlDxTx8AVREyBo_u1oP2DTFvHo62kcgRf0zsRUKFxolnLQMwe8sRogFphRZpGT-tuufO9hbz-jXt0SRvqAso7bNTfbRU54El7KwW6jrGu3xBkZTjerEQsFQcAY2zOWDo1zMHMT_Dm14zFu9ais8pPg]]></artwork>

    </section>
    <section title="Decoding">

      <t>Decoding the JWT from this example requires processing the
      JWT Envelope Segment and Claim Segment exactly as done in the
      first example.</t>

    </section>
    <section title="Validating">

      <t>Since the "alg" parameter in the envelope is "RS256", we
      validate the RSA SHA-256 signature contained in the JWT Crypto
      Segment.  If any of the validation steps fail, the token MUST be
      rejected.</t>

      <t>First, we validate that the decoded envelope and claim
      segment strings are both legal JSON.</t>

      <t>Validating the JWT Crypto Segment is a little different from
      the previous example. First, we base64url decode the JWT Crypto
      Segment to produce a signature S to check.  We then pass (n, e),
      S and the JWT Claim Segment to an RSA signature verifier that
      has been configured to use the SHA-256 hash function.</t>

    </section>
  </section>

  <section title="JWT using ECDSA P-256 SHA-256">
    <section title="Encoding">
      <t>The Decoded JWT Claim Segment used in this example is the same as in the previous examples:</t>

      <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

      <t>Since the JWT Claim Segment will therefore be the same, its
      computation is not repeated here.  However, the Decoded JWT
      Envelope Segment is differs from the previous example because a
      different algorithm is being used.  The Decoded JWT Envelope
      Segment used is:</t>

      <artwork><![CDATA[{"alg":"ES256"}]]></artwork>

      <t> The following byte array contains the UTF-8 characters for
      the Decoded JWT Envelope Segment:</t>

    <t>

[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53,
  54, 34, 125]

    </t>

      <t>Base64url encoding this UTF-8 representation yields this JWT
      Envelope Segment value:</t>

      <artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9]]></artwork>

      <t>The ECDSA key consists of a public part, the EC point (x, y), and a
      private part d.  The values of the ECDSA key used in this
      example, presented as the byte arrays representing
      big endian integers are:</t>

      <texttable>
	<ttcol align="left">Parameter Name</ttcol>
	<ttcol align="left">Value</ttcol>

	<c>x</c>
	<c>

[48, 160, 66, 76, 210, 28, 41, 68, 131, 138, 45, 117,
201, 43, 55, 231, 110, 162, 13, 159, 0, 137, 58, 59,
78, 238, 138, 60, 10, 175, 236, 62]

	</c>

	<c>y</c>
	<c>

[224, 75, 101, 233, 36, 86, 217, 136, 139, 82, 179, 121,
189, 251, 213, 30, 232, 105, 239, 31, 15, 198, 91, 102,
89, 105, 91, 108, 206, 8, 23, 35]

	</c>

	<c>d</c>
	<c>

[243, 189, 12, 7, 168, 31, 185, 50, 120, 30, 213, 39,
82, 246, 12, 200, 154, 107, 229, 229, 25, 52, 254, 1,
147, 141, 219, 85, 216, 247, 120, 1]

	</c>
      </texttable>

      <t>The ECDSA private part d is then passed to an ECDSA
      signing function, which also takes the curve type,
      P-256, the hash type, SHA-256, and the JWT Claim
      Segment as inputs.  The result of the signature is the
      EC point (R, S), where R and S are unsigned integers.
      In this example, the R and S values, given as
      byte arrays representing big endian integers are:</t>

      <texttable>
	<ttcol align="left">Result Name</ttcol>
	<ttcol align="left">Value</ttcol>

	<c>R</c>
	<c>

[175, 11, 115, 42, 160, 182, 181, 28, 135, 222, 52, 154,
  182, 237, 206, 137, 82, 20, 243, 7, 12, 164, 107, 72,
  236, 187, 241, 190, 26, 76, 32, 181]

	</c>

	<c>S</c>
	<c>

[120, 23, 189, 205, 202, 13, 177, 187, 23, 47, 12, 227,
  237, 250, 230, 233, 245, 216, 9, 170, 24, 185, 198,
  187, 193, 94, 158, 117, 167, 88, 153, 196]

	</c>
      </texttable>

      <t>Concatenating the S array to the end of the R array and
      base64url encoding the result produces this value for the JWT
      Crypto Segment:</t>

      <artwork><![CDATA[rwtzKqC2tRyH3jSatu3OiVIU8wcMpGtI7LvxvhpMILV4F73Nyg2xuxcvDOPt-ubp9dgJqhi5xrvBXp51p1iZxA]]></artwork>


      <t>Combining these segments in the order
      Envelope.Claims.Signature with period characters between the
      segments yields this complete JWT (with line breaks for display
      purposes only):</t>

      <artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
rwtzKqC2tRyH3jSatu3OiVIU8wcMpGtI7LvxvhpMILV4F73Nyg2xuxcvDOPt-ubp9dgJqhi5xrvBXp51p1iZxA]]></artwork>

    </section>
    <section title="Decoding">

      <t>Decoding the JWT from this example requires processing the
      JWT Envelope Segment and Claim Segment exactly as done in the
      first example.</t>

    </section>
    <section title="Validating">

      <t>Since the "alg" parameter in the envelope is "ES256", we
      validate the ECDSA P-256 SHA-256 signature contained in the JWT
      Crypto Segment.  If any of the validation steps fail, the token
      MUST be rejected.</t>

      <t>First, we validate that the decoded envelope and claim
      segment strings are both legal JSON.</t>

      <t>Validating the JWT Crypto Segment is a little different from
      the first example. First, we base64url decode the JWT Crypto
      Segment as in the previous examples but we then need to split
      the 64 member byte array that must result into two 32 byte
      arrays, the first R and the second S. We then pass (x, y), (R,
      S) and the JWT Claim Segment to an ECDSA signature verifier that
      has been configured to use the P-256 curve with the SHA-256 hash
      function.</t>

      <t>As explained in <xref target="DefiningECDSA"></xref>, the
      use of the k value in ECDSA means that we cannot validate the
      correctness of the signature in the same way we validated the
      correctness of the HMAC. Instead, implementations MUST use an
      ECDSA validator to validate the signature.</t>

    </section>
  </section>
</section>

<section title="Appendix - Non-Normative - Notes on implementing base64url encoding without padding" anchor="base64urlnotes">

  <t>This appendix describes how to implement base64url encoding
  and decoding functions without padding based upon standard
  base64 encoding and decoding functions that do use padding.</t>

  <t>To be concrete, example C# code implementing these functions
  is shown below.  Similar code could be used in other
  languages.</t>

<artwork><![CDATA[static string base64urlencode(byte [] arg)
{
  string s = Convert.ToBase64String(arg); // Standard base64 encoder
  s = s.Split('=')[0]; // Remove any trailing '='s
  s = s.Replace('+', '-'); // 62nd char of encoding
  s = s.Replace('/', '_'); // 63rd char of encoding
  return s;
}

static byte [] base64urldecode(string arg)
{
  string s = arg;
  s = s.Replace('-', '+'); // 62nd char of encoding
  s = s.Replace('_', '/'); // 63rd char of encoding
  switch (s.Length % 4) // Pad with trailing '='s
  {
    case 0: break; // No pad chars in this case
    case 2: s += "=="; break; // Two pad chars
    case 3: s += "="; break; // One pad char
    default: throw new System.Exception(
      "Illegal base64url string!");
  }
  return Convert.FromBase64String(s); // Standard base64 decoder
}]]></artwork>

  <t>As per the example code above, the number of '=' padding
  characters that needs to be added to the end of a base64url
  encoded string without padding to turn it into one with padding
  is a deterministic function of the length of the encoded string.
  Specifically,
  if the length mod 4 is 0, no padding is added;
  if the length mod 4 is 2, two '=' padding characters are added;
  if the length mod 4 is 3, one '=' padding character is added;
  if the length mod 4 is 1, the input is malformed.</t>

  <t>An example correspondence between unencoded and encoded
  values follows.  The byte sequence below encodes into the string
  below, which when decoded, reproduces the byte sequence.</t>

  <artwork>3 236 255 224 193</artwork>

  <artwork>A-z_4ME</artwork>
</section>

<section title="Appendix - Non-Normative - Relationship of JWTs to SAML Tokens">
  <t><xref target="OASIS.saml-core-2.0-os">SAML 2.0</xref>
  provides a standard for creating tokens with much greater
  expressivity and more security options than supported by
  JWTs. However, the cost of this flexibility and expressiveness
  is both size and complexity. In addition, SAML's use of <xref
  target="W3C.CR-xml11-20021015">XML</xref> and <xref
  target="RFC3275">XML DSIG</xref> only contributes to the size of
  SAML tokens.</t>

  <t>JWTs are intended to provide a simple token format
  that is small enough to fit into HTTP headers and query arguments in
  URIs. It does this by supporting a much simpler token model than
  SAML and using the <xref target="RFC4627">JSON</xref> object encoding
  syntax. It also supports securing tokens using Hash-based Message
  Authentication Codes (HMACs) and digital signatures using a smaller (and
  less flexible) format than XML DSIG.</t>

  <t>Therefore, while JWTs can do some of the things SAML tokens
  do, JWTs are not intended as a full replacement for SAML tokens, but
  rather as a compromise token format to be used when space is at a
  premium.</t>
</section>

<section title="Appendix - Non-Normative - Relationship of JWTs to Simple Web Tokens (SWTs)">

  <t>Both JWTs and Simple Web Tokens <xref
  target="SWT">SWT</xref>, at their core, enable sets of claims to
  be communicated between applications.  For SWTs, both the claim
  names and claim values are strings.  For JWTs, while
  claim names are strings, claim values can be any JSON type.
  Both token types offer cryptographic protection of their
  content: SWTs with HMAC SHA-256 and JWTs with a choice of
  algorithms, including HMAC SHA-256, RSA SHA-256, and ECDSA P-256
  SHA-256.</t>

</section>
</middle>

  <back>
    <references title="Normative References">
      &RFC2045;

      &RFC2104;

      &rfc2119;

      &RFC3339;

      &RFC3447;

      &RFC3629;

      &RFC3986;

      &RFC4627;

      &RFC4648;

      &RFC5226;

      <reference anchor="FIPS.180-3">
        <front>
          <title>Secure Hash Standard (SHS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="October" year="2008" />
        </front>
        <format target="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf" type="PDF" />
        <seriesInfo name="FIPS" value="PUB 180-3" />
      </reference>

      <reference anchor="FIPS.186-3">
        <front>
          <title>Digital Signature Standard (DSS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="June" year="2009" />
        </front>
        <format target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf" type="PDF" />
        <seriesInfo name="FIPS" value="PUB 186-3" />
      </reference>

      <reference anchor="USA15">
        <front>
          <title>Unicode Normalization Forms</title>

          <author fullname="Mark Davis" initials="M." surname="Davis">
            <address>
              <email>markdavis@google.com</email>
            </address>
          </author>

          <author fullname="Ken Whistler" initials="K." surname="Whistler">
            <address>
              <email>ken@unicode.org</email>
            </address>
          </author>

          <author fullname="Martin D&uuml;rst" initials="M."
                  surname="D&uuml;rst"></author>

          <date day="03" month="09" year="2009" />
        </front>

        <seriesInfo name="Unicode Standard Annex" value="15" />
      </reference>
    </references>

    <references title="Informative References">
      &OASIS.saml-core-2.0-os;

      &W3C.CR-xml11-20021015;

      &RFC3275;

      &RFC4122;

      <reference anchor="SWT">
        <front>
          <title>Simple Web Token (SWT)</title>

          <author fullname="Dick Hardt" initials="D." surname="Hardt"></author>

          <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland"></author>

          <date month="November" year="2009" />
        </front>
        <format target="http://oauth-wrap-wg.googlegroups.com/web/SWT-v0.9.5.1.pdf?gda=Sn4MsEMAAABFB7PFAFiVedPtjcqT8uuIImHXUksNUKMXLyrSumAs_dF2tzlQ33RhT1wW8BFYO1QytiJ-HdGYYcPi_09pl8N7FWLveOaWjzbYnpnkpmxcWg" type="PDF" />
        <seriesInfo name="Version" value="0.9.5.1" />
      </reference>

      <reference anchor="MagicSignatures">
        <front>
          <title>Magic Signatures</title>

          <author fullname="John Panzer (editor)" initials="J." surname="Panzer (editor)"></author>

          <author fullname="Ben Laurie" initials="B." surname="Laurie"></author>

          <author fullname="Dirk Balfanz" initials="D." surname="Balfanz"></author>

          <date month="August" year="2010" />
        </front>
        <format target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-experimental-00.html" type="HTML" />
      </reference>

      <reference anchor="JSS">
        <front>
          <title>JSON Simple Sign</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization>Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/jss/1.0/" type="HTML" />
      </reference>

      <reference anchor="CanvasApp">
        <front>
          <title>Canvas Applications</title>

          <author fullname="Facebook" surname="Facebook"></author>

          <date year="2010" />
        </front>
        <format target="http://developers.facebook.com/docs/authentication/canvas" type="HTML" />
      </reference>

    </references>
  </back>
</rfc>
