


Network Working Group                                    F. Templin, Ed.
Internet-Draft                              Boeing Research & Technology
Intended status: Standards Track                        October 07, 2009
Expires: April 10, 2010


        The Subnetwork Encapsulation and Adaptation Layer (SEAL)
                   draft-templin-intarea-seal-07.txt

Status of this Memo

   This Internet-Draft is submitted to IETF in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on April 10, 2010.

Copyright Notice

   Copyright (c) 2009 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents in effect on the date of
   publication of this document (http://trustee.ietf.org/license-info).
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.

Abstract

   For the purpose of this document, a subnetwork is defined as a
   virtual topology configured over a connected network routing region
   and bounded by encapsulating border nodes.  These virtual topologies



Templin                  Expires April 10, 2010                 [Page 1]

Internet-Draft                    SEAL                      October 2009


   may span multiple IP and/or sub-IP layer forwarding hops, and can
   introduce failure modes due to packet duplication and/or links with
   diverse Maximum Transmission Units (MTUs).  This document specifies a
   Subnetwork Encapsulation and Adaptation Layer (SEAL) that
   accommodates such virtual topologies over diverse underlying link
   technologies.


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  Motivation . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.2.  Approach . . . . . . . . . . . . . . . . . . . . . . . . .  6
   2.  Terminology and Requirements . . . . . . . . . . . . . . . . .  7
   3.  Applicability Statement  . . . . . . . . . . . . . . . . . . .  8
   4.  SEAL with Segmentation and Reassembly (SEAL-SR) Protocol
       Specification  . . . . . . . . . . . . . . . . . . . . . . . . 10
     4.1.  Model of Operation . . . . . . . . . . . . . . . . . . . . 10
     4.2.  SEAL-SR Header Format (Mode 1) . . . . . . . . . . . . . . 13
     4.3.  ITE Specification  . . . . . . . . . . . . . . . . . . . . 14
       4.3.1.  Tunnel Interface MTU . . . . . . . . . . . . . . . . . 14
       4.3.2.  Admitting Packets into the Tunnel Interface  . . . . . 15
       4.3.3.  Segmentation . . . . . . . . . . . . . . . . . . . . . 16
       4.3.4.  Encapsulation  . . . . . . . . . . . . . . . . . . . . 17
       4.3.5.  Probing Strategy . . . . . . . . . . . . . . . . . . . 18
       4.3.6.  Packet Identification  . . . . . . . . . . . . . . . . 18
       4.3.7.  Sending SEAL Protocol Packets  . . . . . . . . . . . . 19
       4.3.8.  Processing Raw ICMP Messages . . . . . . . . . . . . . 19
       4.3.9.  Processing SEAL Control Messages . . . . . . . . . . . 19
     4.4.  ETE Specification  . . . . . . . . . . . . . . . . . . . . 22
       4.4.1.  Reassembly Buffer Requirements . . . . . . . . . . . . 22
       4.4.2.  IP-Layer Reassembly  . . . . . . . . . . . . . . . . . 22
       4.4.3.  SEAL-Layer Reassembly  . . . . . . . . . . . . . . . . 23
       4.4.4.  Decapsulation and Delivery to Upper Layers . . . . . . 24
       4.4.5.  Sending SEAL Control Messages  . . . . . . . . . . . . 24
   5.  SEAL with Fragmentation Sensing (SEAL-FS) Protocol
       Specification  . . . . . . . . . . . . . . . . . . . . . . . . 31
     5.1.  Model of Operation . . . . . . . . . . . . . . . . . . . . 32
     5.2.  SEAL-FS Header Format (Version 0)  . . . . . . . . . . . . 32
     5.3.  ITE Specification  . . . . . . . . . . . . . . . . . . . . 32
       5.3.1.  Tunnel Interface MTU . . . . . . . . . . . . . . . . . 32
       5.3.2.  Admitting Packets into the Tunnel Interface  . . . . . 32
       5.3.3.  Segmentation . . . . . . . . . . . . . . . . . . . . . 33
       5.3.4.  Encapsulation  . . . . . . . . . . . . . . . . . . . . 33
       5.3.5.  Probing Strategy . . . . . . . . . . . . . . . . . . . 33
       5.3.6.  Packet Identification  . . . . . . . . . . . . . . . . 34
       5.3.7.  Sending SEAL Protocol Packets  . . . . . . . . . . . . 34
       5.3.8.  Processing Raw ICMP Messages . . . . . . . . . . . . . 34



Templin                  Expires April 10, 2010                 [Page 2]

Internet-Draft                    SEAL                      October 2009


       5.3.9.  Processing SEAL Control Messages . . . . . . . . . . . 34
     5.4.  ETE Specification  . . . . . . . . . . . . . . . . . . . . 34
       5.4.1.  Reassembly Buffer Requirements . . . . . . . . . . . . 34
       5.4.2.  IP-Layer Reassembly  . . . . . . . . . . . . . . . . . 34
       5.4.3.  SEAL-Layer Reassembly  . . . . . . . . . . . . . . . . 34
       5.4.4.  Decapsulation and Delivery to Upper Layers . . . . . . 34
       5.4.5.  Sending SEAL Control Messages  . . . . . . . . . . . . 34
   6.  Link Requirements  . . . . . . . . . . . . . . . . . . . . . . 35
   7.  End System Requirements  . . . . . . . . . . . . . . . . . . . 35
   8.  Router Requirements  . . . . . . . . . . . . . . . . . . . . . 35
   9.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 35
   10. Security Considerations  . . . . . . . . . . . . . . . . . . . 35
   11. Related Work . . . . . . . . . . . . . . . . . . . . . . . . . 36
   12. SEAL Advantages over Classical Methods . . . . . . . . . . . . 37
   13. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 37
   14. References . . . . . . . . . . . . . . . . . . . . . . . . . . 38
     14.1. Normative References . . . . . . . . . . . . . . . . . . . 38
     14.2. Informative References . . . . . . . . . . . . . . . . . . 38
   Appendix A.  Reliability . . . . . . . . . . . . . . . . . . . . . 41
   Appendix B.  Integrity . . . . . . . . . . . . . . . . . . . . . . 41
   Appendix C.  Transport Mode  . . . . . . . . . . . . . . . . . . . 42
   Appendix D.  Historic Evolution of PMTUD . . . . . . . . . . . . . 43
   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 44




























Templin                  Expires April 10, 2010                 [Page 3]

Internet-Draft                    SEAL                      October 2009


1.  Introduction

   As Internet technology and communication has grown and matured, many
   techniques have developed that use virtual topologies (including
   tunnels of one form or another) over an actual network that supports
   the Internet Protocol (IP) [RFC0791][RFC2460].  Those virtual
   topologies have elements that appear as one hop in the virtual
   topology, but are actually multiple IP or sub-IP layer hops.  These
   multiple hops often have quite diverse properties that are often not
   even visible to the endpoints of the virtual hop.  This introduces
   failure modes that are not dealt with well in current approaches.

   The use of IP encapsulation has long been considered as the means for
   creating such virtual topologies.  However, the insertion of an outer
   IP header reduces the effective path MTU as-seen by the IP layer.
   When IPv4 is used, this reduced MTU can be accommodated through the
   use of IPv4 fragmentation, but unmitigated in-the-network
   fragmentation has been found to be harmful through operational
   experience and studies conducted over the course of many years
   [FRAG][FOLK][RFC4963].  Additionally, classical path MTU discovery
   [RFC1191] has known operational issues that are exacerbated by in-
   the-network tunnels [RFC2923][RFC4459].  The following subsections
   present further details on the motivation and approach for addressing
   these issues.

1.1.  Motivation

   Before discussing the approach, it is necessary to first understand
   the problems.  In both the Internet and private-use networks today,
   IPv4 is ubiquitously deployed as the Layer 3 protocol.  The two
   primary functions of IPv4 are to provide for 1) addressing, and 2) a
   fragmentation and reassembly capability used to accommodate links
   with diverse MTUs.  While it is well known that the IPv4 address
   space is rapidly becoming depleted, there is a lesser-known but
   growing consensus that other IPv4 protocol limitations have already
   or may soon become problematic.

   First, the IPv4 header Identification field is only 16 bits in
   length, meaning that at most 2^16 unique packets with the same
   (source, destination, protocol)-tuple may be active in the Internet
   at a given time.  Due to the escalating deployment of high-speed
   links (e.g., 1Gbps Ethernet), however, this number may soon become
   too small by several orders of magnitude for high data rate packet
   sources such as tunnel endpoints [RFC4963].  Furthermore, there are
   many well-known limitations pertaining to IPv4 fragmentation and
   reassembly - even to the point that it has been deemed "harmful" in
   both classic and modern-day studies (cited above).  In particular,
   IPv4 fragmentation raises issues ranging from minor annoyances (e.g.,



Templin                  Expires April 10, 2010                 [Page 4]

Internet-Draft                    SEAL                      October 2009


   in-the-network router fragmentation) to the potential for major
   integrity issues (e.g., mis-association of the fragments of multiple
   IP packets during reassembly [RFC4963]).

   As a result of these perceived limitations, a fragmentation-avoiding
   technique for discovering the MTU of the forward path from a source
   to a destination node was devised through the deliberations of the
   Path MTU Discovery Working Group (PMTUDWG) during the late 1980's
   through early 1990's (see Appendix D).  In this method, the source
   node provides explicit instructions to routers in the path to discard
   the packet and return an ICMP error message if an MTU restriction is
   encountered.  However, this approach has several serious shortcomings
   that lead to an overall "brittleness" [RFC2923].

   In particular, site border routers in the Internet are being
   configured more and more to discard ICMP error messages coming from
   the outside world.  This is due in large part to the fact that
   malicious spoofing of error messages in the Internet is made simple
   since there is no way to authenticate the source of the messages
   [I-D.ietf-tcpm-icmp-attacks].  Furthermore, when a source node that
   requires ICMP error message feedback when a packet is dropped due to
   an MTU restriction does not receive the messages, a path MTU-related
   black hole occurs.  This means that the source will continue to send
   packets that are too large and never receive an indication from the
   network that they are being discarded.

   The issues with both IPv4 fragmentation and this "classical" method
   of path MTU discovery are exacerbated further when IP-in-IP tunneling
   is used [RFC4459].  For example, ingress tunnel endpoints (ITEs) may
   be required to forward encapsulated packets into the subnetwork on
   behalf of hundreds, thousands, or even more original sources in the
   end site.  If the ITE allows IPv4 fragmentation on the encapsulated
   packets, persistent fragmentation could lead to undetected data
   corruption due to Identification field wrapping.  If the ITE instead
   uses classical IPv4 path MTU discovery, it may be inconvenienced by
   excessive ICMP error messages coming from the subnetwork that may be
   either suspect or contain insufficient information for translation
   into error messages to be returned to the original sources.

   The situation is exacerbated further still by IPsec tunnels, since
   only the first IPv4 fragment of a fragmented packet contains the
   transport protocol selectors (e.g., the source and destination ports)
   required for identifying the correct security association rendering
   fragmentation useless under certain circumstances.  Even worse, there
   may be no way for a site border router that configures an IPsec
   tunnel to transcribe the encrypted packet fragment contained in an
   ICMP error message into a suitable ICMP error message to return to
   the original source.



Templin                  Expires April 10, 2010                 [Page 5]

Internet-Draft                    SEAL                      October 2009


   Although recent works have led to the development of a robust end-to-
   end MTU determination scheme [RFC4821], this approach requires
   tunnels to present a consistent MTU the same as for ordinary links on
   the end-to-end path.  Moreover, in current practice existing
   tunneling protocols mask the MTU issues by selecting a "lowest common
   denominator" MTU that may be much smaller than necessary for most
   paths and difficult to change at a later date.  Due to these many
   consideration, a new approach to accommodate tunnels over links with
   diverse MTUs is necessary.

1.2.  Approach

   For the purpose of this document, a subnetwork is defined as a
   virtual topology configured over a connected network routing region
   and bounded by encapsulating border nodes.  Examples include the
   global Internet interdomain routing core, Mobile Ad hoc Networks
   (MANETs) and enterprise networks.  Subnetwork border nodes forward
   unicast and multicast IP packets over the virtual topology across
   multiple IP and/or sub-IP layer forwarding hops that may introduce
   packet duplication and/or traverse links with diverse Maximum
   Transmission Units (MTUs).

   This document introduces a Subnetwork Encapsulation and Adaptation
   Layer (SEAL) for tunnel-mode operation of IP over subnetworks that
   connect Ingress and Egress Tunnel Endpoints (ITEs/ETEs) of border
   nodes.  It provides a standalone specification designed to be
   tailored to specific associated IP in IP tunneling protocols.  A
   transport-mode of operation is also possible, and described in
   Appendix C.  SEAL accommodates links with diverse MTUs, protects
   against off-path denial-of-service attacks, and supports efficient
   duplicate packet detection through the use of a minimal mid-layer
   encapsulation.

   SEAL specifically treats tunnels that traverse the subnetwork as
   unidirectional links that must support IP services.  As for any link,
   tunnels that use SEAL must provide suitable IP services including
   best-effort datagram delivery, integrity and consistent handling of
   packets of various sizes.  As for any link whose media cannot provide
   suitable services natively, tunnels that use SEAL employ link-level
   adaptation functions to meet the legitimate expectations of the IP
   Service.  As this is essentially a link level adaptation, SEAL is
   therefore permitted to alter packets within the subnetwork as long as
   it restores them to their original form when they exit the
   subnetwork.  The mechanisms described within this document are
   designed precisely for this purpose.

   SEAL encapsulation introduces an extended Identification field for
   packet identification and a mid-layer segmentation and reassembly



Templin                  Expires April 10, 2010                 [Page 6]

Internet-Draft                    SEAL                      October 2009


   capability that allows simplified cutting and pasting of packets.
   Moreover, SEAL senses in-the-network IPv4 fragmentation as a "noise"
   indication that packet sizing parameters are "out of tune" with
   respect to the network path.  As a result, SEAL can naturally tune
   its packet sizing parameters to eliminate the in-the-network
   fragmentation.  This approach is in contrast to existing tunneling
   protocol practices which seek to avoid MTU issues by selecting a
   "lowest common denominator" MTU that may be overly conservative for
   many tunnels and difficult to change even when larger MTUs become
   available.

   The following sections provide the SEAL normative specifications,
   while the appendices present non-normative additional considerations.


2.  Terminology and Requirements

   The following terms are defined within the scope of this document:

   subnetwork
      a virtual topology configured over a connected network routing
      region and bounded by encapsulating border nodes.

   Ingress Tunnel Endpoint (ITE)
      a virtual interface over which an encapsulating border node (host
      or router) sends encapsulated packets into the subnetwork.

   Egress Tunnel Endpoint (ETE)
      a virtual interface over which an encapsulating border node (host
      or router) receives encapsulated packets from the subnetwork.

   inner IP packet
      an unencapsulated IP packet before any mid-layer or outer
      encapsulations are added.

   mid-layer packet
      a packet resulting from adding mid-layer encapsulating headers and
      trailers to an inner IP packet.

   outer IP packet
      a packet resulting from adding outer encapsulating headers and
      trailers to a mid-layer packet.

   IP, IPvX, IPvY
      used to generically refer to either IP protocol version, i.e.,
      IPv4 or IPv6.

   The following abbreviations correspond to terms used within this



Templin                  Expires April 10, 2010                 [Page 7]

Internet-Draft                    SEAL                      October 2009


   document and elsewhere in common Internetworking nomenclature:

      PTB - an ICMPv6 "Packet Too Big" [RFC4443]or an ICMPv4
      "Fragmentation Needed" [RFC0792] message.

      DF - the IPv4 header "Don't Fragment" flag [RFC0791]

      MHLEN - the length of any mid-layer headers and trailers

      OHLEN - the length of the outer encapsulating headers and
      trailers, including the outer IP header, the SEAL header and any
      outer headers and trailers

      HLEN - the sum of MHLEN and OHLEN

      S_MRU - the SEAL Maximum Reassembly Unit

      S_MSS - the SEAL Maximum Segment Size

      SEAL_ID - a 32-bit Identification value, randomly initialized and
      monotonically incremented for each SEAL protocol packet

      SEAL_PROTO - an IPv4 protocol number used for SEAL

      SEAL_CPORT - a TCP/UDP service port number used for SEAL control
      plane messaging

      SEAL_DPORT - a TCP/UDP service port number used for SEAL data
      plane messaging

      SEAL-FS - SEAL with Fragmentation Sensing

      SEAL-SR - SEAL with Segmentation and Reassembly

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in [RFC2119].  When used
   in lower case (e.g., must, must not, etc.), these words MUST NOT be
   interpreted as described in [RFC2119], but are rather interpreted as
   they would be in common English.


3.  Applicability Statement

   SEAL was motivated by the specific case of subnetwork abstraction for
   Mobile Ad hoc Networks (MANETs); however, the domain of applicability
   also extends to subnetwork abstractions of enterprise networks, ISP
   networks, SOHO networks, the interdomain routing core, and many



Templin                  Expires April 10, 2010                 [Page 8]

Internet-Draft                    SEAL                      October 2009


   others.  In particular, SEAL is a natural complement to the
   enterprise network abstraction manifested through the VET mechanism
   [I-D.templin-intarea-vet] and the RANGER architecture
   [I-D.templin-ranger][I-D.russert-rangers].  SEAL may also be useful
   as an adjunct mechanism for other tunneling protocols such as
   LISP[I-D.ietf-lisp].

   SEAL introduces a minimal new sublayer for IPvX in IPvY encapsulation
   (e.g., as IPv4/SEAL/IPv6), and appears as a subnetwork encapsulation
   as seen by the inner IP layer.  SEAL can also be used as a sublayer
   for encapsulating inner IPvX packets within outer IPvY/UDP headers
   (e.g., as IPv4/UDP/SEAL/IPv6) such as for the Teredo domain of
   applicability [RFC4380].  When it appears immediately after the outer
   IPv4 header, the SEAL header is processed exactly as for IPv6
   extension headers, i.e., it is not part of the outer IPv4 header but
   rather allows for the creation of an arbitrarily extensible chain of
   headers in the same way that IPv6 does.

   This document specifies two modes of operation for the SEAL protocol
   known as "SEAL with Fragmentation Sensing (SEAL-FS)" and "SEAL with
   Segmentation and Reassembly (SEAL-SR)".  SEAL-FS provides a minimal
   mechanism through which the egress tunnel endpoint (ETE) acts as a
   passive observer that simply informs the ingress tunnel endpoint
   (ITE) of any fragmentation.  SEAL-FS therefore determines the tunnel
   MTU based on the MTU of the smallest link in the path.  It is useful
   for determining an appropriate MTU for tunnels between performance-
   critical routers over robust links, as well as for other uses in
   which packet segmentation and reassembly would present too great of a
   burden for the routers or end systems.

   SEAL-SR is a functional superset of SEAL-FS, and requires that the
   tunnel endpoints support segmentation and reassembly of packets that
   are too large to traverse the tunnel without fragmentation.  SEAL-SR
   determines the tunnel MTU based on the largest packet the ETE is
   capable of receiving rather than on the MTU of the smallest link in
   the path.  Therefore, SEAL-SR can transport packets that are much
   larger than the underlying links themselves can carry in a single
   piece, i.e., even if IPv6 jumbograms are used [RFC2675].

   SEAL-SR tunnels may be configured over paths that include only
   ordinary links, but they may also be configured over paths that
   include SEAL-FS tunnels or even other SEAL-SR tunnels.  An example
   application would be linking two geographically remote supercomputer
   centers with large MTU links by configuring a SEAL_TE tunnel across
   the Internet.  A second example would be support for sub-IP
   segmentation over low-end links, i.e., especially over wireless
   transmission media such as IEEE 802.15.4, broadcast radio links in
   Mobile Ad-hoc Networks (MANETs), Very High Frequency (VHF) civil



Templin                  Expires April 10, 2010                 [Page 9]

Internet-Draft                    SEAL                      October 2009


   aviation data links, etc.

   Many other use case examples for both SEAL-FS and SEAL-SR are
   anticipated, and will be identified as further experience is gained.


4.  SEAL with Segmentation and Reassembly (SEAL-SR) Protocol
    Specification

   This section specifies the fully-functioned mode of SEAL known as
   "SEAL with Segmentation and Reassembly (SEAL-SR)"; a minimal mode
   known as "SEAL with Fragmentation Sensing (SEAL-FS)" is specified in
   Section 5.  SEAL-SR is a superset of SEAL-FS, and differs only in its
   segmentation and reassembly requirements.  SEAL-SR and SEAL-FS are
   distinguished simply by a mode value in the SEAL header.  The
   following sections therefore specify SEAL-SR, but use the simple term
   "SEAL" since the same formats and mechanisms apply also to SEAL-FS.

4.1.  Model of Operation

   SEAL is an encapsulation sublayer that supports a multi-level
   segmentation and reassembly capability for the transmission of
   unicast and multicast packets across an underlying IP subnetwork with
   heterogeneous links.  First, the ITE can use IPv4 fragmentation to
   fragment inner IPv4 packets before SEAL encapsulation if necessary.
   Secondly, the SEAL layer itself provides a simple cutting-and-pasting
   capability for mid-layer packets to avoid IP fragmentation on the
   outer packet.  Finally, ordinary IP fragmentation is permitted on the
   outer packet after SEAL encapsulation and is used to detect and tune
   out any in-the-network fragmentation.

   SEAL-enabled ITEs encapsulate each inner IP packet in mid-layer
   headers and trailers, segment the resulting mid-layer packet if
   necessary, then append a SEAL header and outer encapsulating headers
   and trailers to each segment.  For example, a single-segment inner
   IPv6 packet encapsulated in any mid-layer headers and trailers, the
   SEAL header, any outer headers and trailers and an outer IPv4 header
   would appear as shown in Figure 1:













Templin                  Expires April 10, 2010                [Page 10]

Internet-Draft                    SEAL                      October 2009


   I                                   +--------------------+
   n                                   ~   outer trailers   ~
   n      +--------------------+       +--------------------+
   e      ~ mid-layer trailers ~       ~ mid-layer trailers ~
   r      +--------------------+       +--------------------+
          |                    |       |                    |
   I -->  ~    inner IPv6      ~  -->  ~    inner IPv6      ~
   P -->  ~      Packet        ~  -->  ~      Packet        ~
   v      |                    |       |                    |
   6      +--------------------+       +--------------------+
          ~  mid-layer headers ~       ~  mid-layer headers ~
   P      +--------------------+       +--------------------+
   a                                   ~    SEAL header     ~
   c         Mid-layer packet          +--------------------+
   k      after mid-layer encaps.      ~   outer headers    ~
   e                                   +--------------------+
   t                                   ~  outer IPv4 header ~
                                       +--------------------+

                                          Outer IPv4 packet
                                     after SEAL and outer encaps.

               Figure 1: SEAL Encapsulation - Single Segment

   In a second example, an inner IPv6 packet requiring three SEAL
   segments would appear as three separate outer IPv4 packets (each with
   its own SEAL header) and with the mid-layer headers only occurring in
   segment 0 and the mid-layer trailers only appearing in segment 2 as
   shown in Figure 2:






















Templin                  Expires April 10, 2010                [Page 11]

Internet-Draft                    SEAL                      October 2009


   +------------------+                          +------------------+
   ~  outer trailers  ~                          ~  outer trailers  ~
   +------------------+   +------------------+   +------------------+
   |                  |   ~  outer trailers  ~   ~ mid-layer trails ~
   ~    inner IPv6    ~   +------------------+   +------------------+
   ~      Packet      ~   |                  |   |                  |
   |    (Segment 0)   |   ~    inner IPv6    ~   ~    inner IPv6    ~
   +------------------+   ~      Packet      ~   ~      Packet      ~
   ~  mid-layer hdrs  ~   |    (Segment 1)   |   |    (Segment 2)   |
   +------------------+   +------------------+   +------------------+
   ~ SEAL hdr (SEG=0) ~   ~ SEAL hdr (SEG=1) ~   ~ SEAL hdr (SEG=2) ~
   +------------------+   +------------------+   +------------------+
   ~    outer hdrs    ~   ~    outer hdrs    ~   ~    outer hdrs    ~
   +------------------+   +------------------+   +------------------+
   ~  outer IPv4 hdr  ~   ~  outer IPv4 hdr  ~   ~  outer IPv4 hdr  ~
   +------------------+   +------------------+   +------------------+

   Segment 0 (includes    Segment 1 (no mid-     Segment 2 (includes
     mid-layer hdrs)        layer encaps)         mid-layer trails)

             Figure 2: SEAL Encapsulation - Multiple Segments

   The SEAL header itself is inserted according to the specific
   tunneling protocol.  Examples include the following:

   o  For simple IP in IP encapsulations (e.g.,
      [RFC2003][RFC2004][RFC2473][RFC4213]), the SEAL header is inserted
      between the inner IPvY and outer IPvX headers as: IPvX/SEAL/IPvY.

   o  For tunnel-mode IPsec encapsulations (e.g., [RFC4301]), the SEAL
      header is inserted between the {AH,ESP} header and outer IP
      headers as: IPvX/SEAL/{AH,ESP}/IPvY.  Here, the {AH, ESP} headers
      and trailers are seen as mid-layer encapsulations.

   o  For IP encapsulations over transports such as UDP (e.g.,
      [RFC4380]), the SEAL header is inserted immediately after the
      outer transport layer header, e.g., as IPvX/UDP/SEAL/IPvY.  Here,
      the UDP header is seen as an outer encapsulation.

   SEAL-encapsulated packets include a SEAL_ID to uniquely identify each
   packet.  Routers within the subnetwork use the SEAL_ID for duplicate
   packet detection, and {ITEs; ETEs} use the SEAL_ID for SEAL
   segmentation/reassembly and protection against off-path attacks.

   For IPv4, the SEAL_ID is formed from the concatenation of the 16-bit
   ID Extension field in the SEAL header as the most-significant bits,
   and with the 16-bit Identification value in the outer IPv4 header as
   the least-significant bits.  For IPv6, the SEAL_ID is written into



Templin                  Expires April 10, 2010                [Page 12]

Internet-Draft                    SEAL                      October 2009


   the 32-bit Identification field of the fragment header.  For tunnels
   that traverse middleboxes that might rewrite the IP ID field (e.g., a
   Network Address Translator) the SEAL_ID is instead maintained only
   within the ID field in the SEAL header.

   The following sections specify the SEAL header format and SEAL-
   related operations of the ITE and ETE, respectively.

4.2.  SEAL-SR Header Format (Mode 1)

   The SEAL mode 1 header (i.e., the SEAL-SR header) is formatted as
   follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |MOD|A|I|F|M|RSV|  NEXTHDR/SEG  |         ID Extension          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Figure 3: SEAL Mode 1 Header Format

   where the header fields are defined as:

   MOD (2)
      a 2-bit value that encodes the SEAL protocol mode.  This section
      describes Mode 1 of the SEAL protocol, i.e., the MOD field encodes
      the value 1.

   A (1)
      the "Acknowledgement Requested" bit.  Set to 1 if the ITE wishes
      to receive an explicit acknowledgement from the ETE.

   I (1)
      the "Information Request Solicit" bit.  Set to 1 if the ITE wishes
      the ETE to initiate an Information Request.

   F (1)
      the "First Segment" bit.  Set to 1 if this SEAL protocol packet
      contains the first segment (i.e., Segment #0) of a mid-layer
      packet.

   M (1)
      the "More Segments" bit.  Set to 1 if this SEAL protocol packet
      contains a non-final segment of a multi-segment mid-layer packet.







Templin                  Expires April 10, 2010                [Page 13]

Internet-Draft                    SEAL                      October 2009


   RSV (2)
      a 2-bit Reserved field.  Set to 0 for the purpose of this
      specification.

   NEXTHDR/SEG (8)  an 8-bit field.  When 'F'=1, encodes the next header
      Internet Protocol number the same as for the IPv4 protocol and
      IPv6 next header fields.  When 'F'=0, encodes a segment number of
      a multi-segment mid-layer packet.  (The segment number 0 is
      reserved.)

   ID Extension (16)
      a 16-bit Identification extension field.

4.3.  ITE Specification

4.3.1.  Tunnel Interface MTU

   The ITE configures a tunnel virtual interface over one or more
   underlying links that connect the border node to the subnetwork.  The
   tunnel interface must present a fixed MTU to the inner IP layer
   (i.e., Layer 3) as the size for admission of inner IP packets into
   the tunnel.  Since the tunnel interface may support a potentially
   large set of ETEs, however, care must be taken in setting a large-
   enough MTU for all ETEs while still upholding end system
   expectations.

   Due to the ubiquitous deployment of standard Ethernet and similar
   networking gear, the nominal Internet cell size has become 1500
   bytes; this is the de facto size that end systems have come to expect
   will either be delivered by the network without loss due to an MTU
   restriction on the path or a suitable ICMP Packet Too Big (PTB)
   message returned.  However, the network may not always deliver the
   necessary PTBs, leading to MTU-related black holes [RFC2923].  The
   ITE therefore requires a means for conveying 1500 byte (or smaller)
   packets to the ETE without loss due to MTU restrictions and without
   dependence on PTB messages from within the subnetwork.

   In common deployments, there may be many forwarding hops between the
   original source and the ITE.  Within those hops, there may be
   additional encapsulations (IPSec, L2TP, other SEAL encapsulations,
   etc.) such that a 1500 byte packet sent by the original source might
   grow to a larger size by the time it reaches the ITE for
   encapsulation as an inner IP packet.  Similarly, additional
   encapsulations on the path from the ITE to the ETE could cause the
   encapsulated packet to become larger still and trigger in-the-network
   fragmentation.  In order to preserve the end system expectations, the
   ITE therefore requires a means for conveying these larger packets to
   the ETE even though there may be links within the subnetwork that



Templin                  Expires April 10, 2010                [Page 14]

Internet-Draft                    SEAL                      October 2009


   configure a smaller MTU.

   The ITE should therefore set a tunnel virtual interface MTU of 1500
   bytes plus extra room to accommodate any additional encapsulations
   that may occur on the path from the original source (i.e., even if
   the path to the ETE does not support an MTU of this size).  The ITE
   can set larger MTU values still, but should select a value that is
   not so large as to cause excessive PTBs coming from within the tunnel
   interface (see Sections 4.3.3 and 4.3.8).  The ITE can also set
   smaller MTU values; however, care must be taken not to set so small a
   value that original sources would experience an MTU underflow.  In
   particular, IPv6 sources must see a minimum path MTU of 1280 bytes,
   and IPv4 sources should see a minimum path MTU of 576 bytes.

   The ITE can alternatively set an indefinite MTU on the tunnel virtual
   interface such that all inner IP packets are admitted into the
   interface without regard to size.  For ITEs that host applications,
   this option must be carefully coordinated with protocol stack upper
   layers, since some upper layer protocols (e.g., TCP) derive their
   packet sizing parameters from the MTU of the underlying interface and
   as such may select too large an initial size.  This is not a problem
   for upper layers that use conservative initial estimates, e.g., when
   mechanisms such as Packetization Layer Path MTU Discovery [RFC4821]
   are used.

4.3.2.  Admitting Packets into the Tunnel Interface

   The inner IP layer consults the tunnel interface MTU when admitting a
   packet into the interface.  For IPv4 packets with the IPv4 Don't
   Fragment (DF) bit set to 0, if the packet is larger than the tunnel
   interface MTU the inner IP layer uses IP fragmentation to break the
   packet into fragments no larger than the tunnel interface MTU.  The
   ITE then admits each fragment into the tunnel as an independent
   packet.

   For all other packets, the ITE admits the packet if it is no larger
   than the tunnel interface MTU; otherwise, it drops the packet and
   sends a PTB error message to the source with the MTU value set to the
   tunnel interface MTU.  The message must contain as much of the
   invoking packet as possible without the entire message exceeding the
   minimum IP MTU (i.e., 576 bytes for IPv4 and 1280 bytes for IPv6).

   Note that when the tunnel interface sets an indefinite MTU all
   packets are unconditionally admitted into the interface without
   fragmentation.






Templin                  Expires April 10, 2010                [Page 15]

Internet-Draft                    SEAL                      October 2009


4.3.3.  Segmentation

   For each ETE, the ITE maintains soft state within the tunnel
   interface (e.g., in a neighbor cache) used to support inner
   fragmentation and SEAL segmentation.  The soft state includes the
   following:

   o  a Mid-layer Header Length (MHLEN); set to the length of any mid-
      layer encapsulation headers and trailers (e.g., AH, ESP, NULL,
      etc.).

   o  an Outer Header Length (OHLEN); set to the length of the outer IP,
      SEAL and other outer encapsulation headers and trailers.

   o  a total Header Length (HLEN); set to MHLEN plus OHLEN.

   o  a SEAL Maximum Segment Size (S_MSS); initialized to a value that
      is no larger than the underlying IP interface MTU.  The ITE
      decreases or increases S_MSS based on any SEAL Reassembly Report
      messages received (see Section 4.3.9).

   o  a SEAL Maximum Reassembly Unit (S_MRU); initialized to "infinity",
      i.e., the largest-possible inner IP packet size.  The ITE
      decreases or increases S_MRU based on any SEAL Reassembly Report
      messages received (see Section 4.3.9).  When (S_MRU>(S_MSS*256)),
      the ITE uses (S_MSS*256) as the effective S_MRU value.

   Note that here as well as in the SEAL control message protocol (see
   Section 4.4.5), S_MSS and S_MRU are maintained as 32-bit values
   specifically for the purpose of supporting jumbograms.

   After an inner packet/fragment has been admitted into the tunnel
   interface the ITE uses the following algorithm to determine whether
   the packet can be accommodated and (if so) whether inner IP
   fragmentation is needed:

   o  if the inner packet is an IPv6 packet or an IPv4 packet with DF=1,
      and the packet is larger than (S_MRU - HLEN), the ITE drops the
      packet and sends a PTB message to the original source with an MTU
      value of (S_MRU - HLEN) the same as described in Section 4.3.2;
      else,

   o  if the inner packet is an IPv4 packet with DF=0, and the packet is
      larger than (MIN((S_MRU, S_MSS) - HLEN), the ITE uses inner IPv4
      fragmentation to break the packet into fragments no larger than
      (MIN(S_MRU, S_MSS) - HLEN); else,





Templin                  Expires April 10, 2010                [Page 16]

Internet-Draft                    SEAL                      October 2009


   o  the ITE processes the packet without inner fragmentation.

   (Note that in the above the ITE must also track whether the tunnel
   interface is using header compression on the inner headers.  If so,
   the ITE must include the length of the uncompressed inner headers
   when calculating the total length of the inner packet.)

   The ITE next encapsulates each inner packet/fragment in the MHLEN
   bytes of mid-layer headers and trailers.  If the length of the
   resulting mid-layer packet plus OHLEN is greater than S_MSS, the ITE
   must additionally perform SEAL segmentation.  To do so, it breaks the
   mid-layer packet into N segments (N <= 256) that are no larger than
   (S_MSS - OHLEN) bytes each.  Each segment, except the final one, MUST
   be of equal length.  The first byte of each segment MUST begin
   immediately after the final byte of the previous segment, i.e., the
   segments MUST NOT overlap.  The ITE SHOULD generate the smallest
   number of segments possible, e.g., it SHOULD NOT generate 6 smaller
   segments when the packet could be accommodated with 4 larger
   segments.

   Note that this SEAL segmentation ignores the fact that the mid-layer
   packet may be unfragmentable outside of the subnetwork.  This
   segmentation process is a mid-layer (not an IP layer) operation
   employed by the ITE to adapt the mid-layer packet to the subnetwork
   path characteristics, and the ETE will restore the packet to its
   original form during reassembly.  Therefore, the fact that the packet
   may have been segmented within the subnetwork is not observable
   outside of the subnetwork.

4.3.4.  Encapsulation

   Following SEAL segmentation, the ITE encapsulates each segment in a
   SEAL header formatted as specified in Section 4.3.2 with MOD=1 and
   RSV=0.  For the first segment, the ITE sets F=1, then sets NEXTHDR to
   the Internet Protocol number of the encapsulated packet, and finally
   sets M=1 if there are more segments or sets M=0 otherwise.  For each
   non-initial segment of an N-segment mid-layer packet (N <= 256), the
   ITE sets (F=0; M=1; SEG=1) in the SEAL header of the first non-
   initial segment, sets (F=0; M=1; SEG=2) in the next non-initial
   segment, etc., and sets (F=0; M=0; SEG=N-1) in the final segment.
   (Note that the value SEG=0 is not used.)

   The ITE next encapsulates each segment in the requisite outer IP and
   other outer headers and trailers according to the specific
   encapsulation format (e.g., [RFC2003], [RFC2473], [RFC4213],
   [RFC4380], etc.), except that it writes 'SEAL_PROTO' in the protocol
   field of the outer IP header (when simple IP encapsulation is used)
   or writes 'SEAL_DPORT' in the outer destination service port field



Templin                  Expires April 10, 2010                [Page 17]

Internet-Draft                    SEAL                      October 2009


   (e.g., when IP/UDP encapsulation is used).  The ITE finally sets the
   A bit as specified in Section 4.3.5 (if necessary), sets the packet
   identification values as specified in Section 4.3.6 and sends the
   packets as specified in Section 4.3.7.

   Note that when IPv6 is used as the outer IP encapsulation layer, the
   ITE must insert an IPv6 fragment header with an Identification value
   set as described in Section 4.3.6.

4.3.5.  Probing Strategy

   All SEAL packets sent by the ITE are considered implicit probes, and
   will elicit "Reassembly Report - IP Fragmentation Experienced"
   messages from the ETE with a new value for S_MSS if any IP
   fragmentation occurs in the path.  Thereafter, the ITE can
   periodically reset S_MSS to a larger value (e.g., the underlying IP
   interface MTU minus OHLEN bytes) to detect path MTU increases.

   The ITE should additionally send explicit probes, periodically, to
   verify that the ETE is still reachable and to manage a window of
   SEAL_IDs.  The ITE sets A=1 in the SEAL header of a segment to be
   used as an explicit probe, where the probe can be either an ordinary
   data packet or a NULL packet created by setting the 'Next Header'
   field to a value of "No Next Header" (see Section 4.7 of [RFC2460]).
   The probe will elicit a "Reassembly Report - Segment Acknowledged"
   message from the ETE as an acknowledgement.

   Finally, the ITE MAY send "expendable" outer IP probe packets (see
   Section 4.3.7) in order to generate PTB messages from routers on the
   path to the ETE.

4.3.6.  Packet Identification

   For the purpose of packet identification, the ITE maintains a SEAL_ID
   value as per-ETE soft state, e.g., in the neighbor cache.  The ITE
   randomly initializes SEAL_ID when the soft state is created, and
   monotonically increments it for each successive SEAL protocol packet
   it sends to the ETE.

   For each outer IPv4 packet, the ITE writes the least-significant 16
   bits of the SEAL_ID value into the Identification field in the outer
   IPv4 header, and writes the most-significant 16 bits in the ID
   Extension field in the SEAL header.  For each outer IPv6 packet, the
   ITE writes the entire SEAL_ID value into the Identification field in
   the IPv6 fragment header.

   For tunnels specifically designed for the traversal of Network
   Address Translators (NATs) (e.g., Teredo [RFC4380]) and other



Templin                  Expires April 10, 2010                [Page 18]

Internet-Draft                    SEAL                      October 2009


   middleboxes that might rewrite the outer IP ID field, the ITE instead
   writes the least significant bits of the SEAL_ID in the ID field of
   the SEAL header and writes a random value in the Identification field
   in the outer IP header.  Since the ID field in the SEAL header is
   only 16 bits, however, the ITE must limit the rate at which it sends
   packets to avoid wrapping the ID field.  Alternatively, the ITE and
   ETE can use SEAL-FS to obtain a larger ID field in the SEAL header
   (see Section 5.3.6).  In either case, both the ITE and ETE must be
   aware of the manner in which the SEAL_ID is inserted.

4.3.7.  Sending SEAL Protocol Packets

   Following SEAL segmentation and encapsulation, the ITE sets DF=0 for
   ordinary outer IPv4 packets to ensure that they will be delivered to
   the ETE even if they are fragmented within the subnetwork.  (The ITE
   can instead set DF=1 for "expendable" outer IPv4 packets (e.g., for
   NULL packets used as probes -- see Section 4.3.5), but these may be
   lost due to an MTU restriction).  For outer IPv6 packets, the "DF"
   bit is always implicitly set to 1, but when a fragment header is
   included a translating router on the path may still fragment the
   packet.

   The ITE sends each outer packet that encapsulates a segment of the
   same mid-layer packet into the tunnel in canonical order, i.e.,
   segment 0 first, followed by segment 1, etc., and finally segment
   N-1.

4.3.8.  Processing Raw ICMP Messages

   The ITE may receive "raw" ICMP error messages [RFC0792][RFC4443] from
   either the ETE or routers within the subnetwork that comprise an
   outer IP header, followed by an ICMP header, followed by a portion of
   the SEAL packet that generated the error (also known as the "packet-
   in-error").  The ITE can use the SEAL ID encoded in the packet-in-
   error as a nonce to confirm that the ICMP message came from either
   the ETE or an on-path router, and can use any additional information
   to determine whether to accept or discard the message.

   The ITE should specifically process raw ICMPv4 Protocol Unreachable
   messages and ICMPv6 Parameter Problem messages with Code
   "Unrecognized Next Header type encountered" as a hint that the ETE
   does not implement the SEAL protocol; specific actions that the ITE
   may take in this case are out of scope.

4.3.9.  Processing SEAL Control Messages

   In addition to any raw ICMP messages, the ITE may receive IP/UDP SEAL
   control messages from the ETE formatted as specified in Section 4.4.5



Templin                  Expires April 10, 2010                [Page 19]

Internet-Draft                    SEAL                      October 2009


   and with 'SEAL_CPORT' as the UDP destination port.  The ITE must
   therefore monitor the 'SEAL_CPORT' UDP port and process any messages
   that arrive on that port.

   For each control message, the ITE verifies the UDP checksum and
   discards the message if the checksum is incorrect.  The ITE can then
   verify that the SEAL_ID is within the current window of transmitted
   SEAL_IDs for this ETE.  If the SEAL_ID is outside of the window, the
   ITE discards the message; otherwise, it advances the window and
   processes the message.  The ITE processes SEAL control messages as
   follows:

4.3.9.1.  Reassembly Report (Type=0)

   When the ITE receives a Reassembly Report formatted as specified in
   Section 4.4.5.1, it processes the message according to the Code value
   as follows:

4.3.9.1.1.  IP Fragmentation Experienced (Code=0)

   The ITE records the value in the S_MRU field in its soft state for
   this ETE and adjusts the S_MSS value in its soft state.  If the S_MSS
   value in the Reassembly Report is greater than 576 (i.e., the nominal
   minimum MTU for IPv4 links), the ITE records this new value in its
   soft state.  If the S_MSS value in the report is less than the
   current soft state value and also less than 576, the ITE can discern
   that IP fragmentation is occurring but it cannot determine the true
   MTU of the restricting link due to a router on the path generating
   runt first-fragments.

   The ITE should therefore search for a reduced S_MSS value through an
   iterative searching strategy that parallels (Section 5 of [RFC1191]).
   This searching strategy may require multiple iterations of sending
   SEAL packets using a reduced S_MSS and receiving additional
   Reassembly Report messages, but it will soon converge to a stable
   value.  During this process, it is essential that the ITE reduce
   S_MSS based on the first Reassembly Report message received, and
   refrain from further reducing S_MSS until SEAL Reassembly Report
   messages pertaining to packets sent under the new S_MSS are received.

4.3.9.1.2.  Segment Acknowledged (Code=1)

   The ITE records the value in the S_MRU field in its soft state for
   this ETE.







Templin                  Expires April 10, 2010                [Page 20]

Internet-Draft                    SEAL                      October 2009


4.3.9.1.3.  Packet Too Big (Code=2)

   The ITE records the value in the S_MRU field in its soft state for
   this ETE.  The ITE can then translate the message into a PTB message
   to return to the original source (where the translation is based on
   the encapsulated portion of the invoking packet at the end of the
   reassembly report message).

4.3.9.1.4.  Time Exceeded (Code=3)

   The ITE MAY log the event for network management purposes.  When
   excessive Time Exceeded messages are received from this ETE, the ITE
   should also reduce its S_MRU and/or S_MSS estimates.

   Unlike other SEAL control messages, the ETE does not necessarily
   generate the Time Exceeded message in synchronous response to the
   receipt of an invoking SEAL packet.  The ITE must therefore consider
   as suspect any Time Exceeded messages that cannot be correlated with
   a recently sent SEAL packet.

4.3.9.2.  Parameter Problem (Type=1)

   When the ITE receives a Parameter Problem message formatted as
   specified in Section 4.4.5.2, it examines the encapsulated SEAL
   header in the message to determine whether the header was corrupted
   or whether the header specified features that the ETE did not
   recognize.  The ITE MAY log the event for network management
   purposes, and SHOULD adjust its SEAL header parameters in subsequent
   SEAL packets.

4.3.9.3.  Information Request Solicit (Type=2)

   When the ITE receives an Information Request Solicit message
   formatted as specified in Section 4.4.5.3 and with a SEAL_ID that
   corresponds to a SEAL packet that it sent earlier, it sends an
   Information Request as specified in Section 4.4.5.4.

4.3.9.4.  Information Request (Type=3)

   When the ITE receives an Information Request message formatted as
   specified in Section 4.4.5.4 and with a SEAL_ID that corresponds to a
   SEAL packet that it sent earlier with I=1, it sends an Information
   Reply as specified in Section 4.4.5.5.

4.3.9.5.  Information Reply (Type=4)

   When the ITE receives an Information Reply message formatted as
   specified in Section 4.4.5.5 and with a SEAL_ID that corresponds to a



Templin                  Expires April 10, 2010                [Page 21]

Internet-Draft                    SEAL                      October 2009


   SEAL packet that it sent earlier, it processes the opaque data
   included in the reply.

4.4.  ETE Specification

4.4.1.  Reassembly Buffer Requirements

   ETEs must be capable of performing IP-layer reassembly for SEAL
   protocol IP packets up to 2KB in length, and must also be capable of
   performing SEAL-layer reassembly for mid-layer packets up to (2KB -
   OHLEN).  Hence, ETEs:

   o  MUST configure a reassembly buffer size (i.e., a SEAL Maximum
      Reassembly Unit (S_MRU)) of at least 2KB

   o  MAY configure a larger S_MRU

   o  MUST be capable of discarding SEAL packets that are too large to
      reassemble

   Note that the ETE must retain the outer IP, SEAL and other outer
   headers and trailers during both IP-layer and SEAL-layer reassembly
   for the purpose of associating the fragments/segments of the same
   packet.

4.4.2.  IP-Layer Reassembly

   ETEs perform standard IP-layer reassembly for SEAL protocol IP
   fragments, and should maintain a conservative reassembly cache high-
   and low-water mark.  When the size of the reassembly cache exceeds
   this high-water mark, the ETE should actively discard incomplete
   reassemblies (e.g., using an Active Queue Management (AQM) strategy)
   until the size falls below the low-water mark.  The ETE should also
   actively discard any pending reassemblies that clearly have no
   opportunity for completion, e.g., when a considerable number of new
   fragments have been received before a fragment that completes a
   pending reassembly has arrived.

   When the ETE processes the IP first-fragment (i.e., one with MF=1 and
   Offset=0 in the IP header) of a fragmented SEAL packet, it sends a
   "Reassembly Report - IP Fragmentation Experienced" message back to
   the ITE with the S_MSS field set to the length of the first-fragment
   and with the S_MRU field set to no more than the size of the
   reassembly buffer (see Section 4.4.5).







Templin                  Expires April 10, 2010                [Page 22]

Internet-Draft                    SEAL                      October 2009


4.4.3.  SEAL-Layer Reassembly

   Following IP reassembly of a SEAL segment, the ETE adds the segment
   to a SEAL-Layer pending-reassembly queue according to the (Source,
   Destination, SEAL_ID)-tuple found in the outer IP and SEAL headers.
   The ETE performs SEAL-layer reassembly through simple in-order
   concatenation of the encapsulated segments of the same mid-layer
   packet from N consecutive SEAL packets.  SEAL-layer reassembly
   requires the ETE to maintain a cache of recently received segments
   for a hold time that would allow for nominal inter-segment delays.
   When a SEAL reassembly times out, the ETE discards the incomplete
   reassembly and returns a "Reassembly Report - Time Exceeded" message
   to the ITE (see Section 4.4.5).  As for IP-layer reassembly, the ETE
   should also maintain a conservative reassembly cache high- and low-
   water mark and should actively discard any pending reassemblies that
   clearly have no opportunity for completion, e.g., when a considerable
   number of new SEAL packets have been received before a packet that
   completes a pending reassembly has arrived.

   When the ETE receives a SEAL packet with an incorrect value in the
   SEAL header, it discards the packet and returns a "Parameter Problem"
   message (see Section 4.4.5).  If the ETE receives a SEAL packet for
   which a segment with the same (Source, Destination, SEAL_ID)-tuple is
   already in the queue, it must determine whether to accept the new
   segment and release the old, or drop the new segment.  If accepting
   the new segment would cause an inconsistency with other segments
   already in the queue (e.g., differing segment lengths), the ETE drops
   the segment that is least likely to complete the reassembly.

   After all segments are gathered, the ETE reassembles the mid-layer
   packet by discarding the outer headers and concatenating the segments
   encapsulated in the N consecutive SEAL packets beginning with the
   initial segment (i.e., SEG=0) and followed by any non-initial
   segments 1 through N-1.  That is, for an N-segment mid-layer packet,
   reassembly entails the concatenation of the SEAL-encapsulated mid-
   layer packet segments with (F=1, M=1, SEAL_ID=j) in the first SEAL
   header, followed by (F=0, M=1, SEG=1, SEAL_ID=(j+1)) in the next SEAL
   header, followed by (F=0, M=1, SEG=2, SEAL_ID=(j+2)), etc., up to
   (F=0, M=0, SEG=(N-1), SEAL_ID=(j + N-1)) in the final SEAL header.
   (Note that modulo arithmetic based on the length of the SEAL_ID field
   is used).

   When the ETE determines that a mid-layer packet is too large to
   reassemble, it releases the reassembly queue resources and sends a
   "Reassembly Report - Packet Too Big" message with the S_MRU field set
   to the maximum-sized packet it is willing to accept from this ITE
   (see Section 4.4.5).




Templin                  Expires April 10, 2010                [Page 23]

Internet-Draft                    SEAL                      October 2009


4.4.4.  Decapsulation and Delivery to Upper Layers

   Following SEAL-layer reassembly, if the reassembled mid-layer packet
   is larger than (S_MRU-OHLEN), the ETE discards the packet and sends a
   "Reassembly Report - Packet Too Big" message to the ITE (see Section
   4.4.5).  The ETE can also send the Packet Too Big if it has reason to
   believe that the current S_MRU value is too large for this ITE, but
   if so it SHOULD converge to a stable value as quickly as possible.
   Note that this would require the ETE to cache per-ITE S_MRU values.

   Next, the ETE discards the outer and mid-layer headers and trailers,
   and delivers the inner packet to the upper-layer protocol indicated
   in the SEAL Next Header field.  (If the reassembled packet if it was
   a NULL packet (see Section 4.3.4), the ETE instead silently discards
   the packet).

4.4.5.  Sending SEAL Control Messages

   An ETE sends SEAL control messages in response to certain SEAL data
   packet and control messages received from the ITE.  An ITE can also
   send SEAL control messages during an information exchange with an
   ETE.

   SEAL control messages are formatted much the same as for ICMPv4
   [RFC0792] and ICMPv6 [RFC4443] messages, and are used for very
   similar purposes.  The ETE prepares each control message as an IP/UDP
   packet with outer IP/UDP headers followed by a 32-bit control field
   followed by the message body followed by as much of the invoking
   packet as possible (beginning with the outer IP header) without the
   control message exceeding 576 bytes.  The message is formatted as
   shown in Figure 4:




















Templin                  Expires April 10, 2010                [Page 24]

Internet-Draft                    SEAL                      October 2009


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      ~              IP/UDP Headers (dport=SEAL_CPORT)                ~
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Type      |     Code      |         Reserved/Length       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      ~                          Message Body                         ~
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    As much of invoking packet                 |
      +               as possible without the SEAL Control            +
      |                   Message exceeding 576 bytes                 |

                   Figure 4: SEAL Control Message Format

   When the {ITE, ETE} prepares a control message, it sets the outer IP
   destination and source addresses of the message to the source and
   destination addresses (respectively) of the SEAL data packet or
   control message that triggered the exchange.  If the destination
   address in the packet was multicast, the {ITE, ETE} instead sets the
   outer IP source address to an address assigned to the underlying IP
   interface.  The {ITE, ETE} next sets the UDP destination port to
   'SEAL_CPORT'' and sets the UDP source port to a constant value of its
   choosing.

   As for ICPMv4 and ICMPv6 messages, the SEAL control header includes
   an 8-bit Type field in bits 0 thru 7 and an 8-bit Code field in bits
   8 thru 15.  Unlike ICMPv4 and ICMPv6 messages, however, the control
   header does not include a checksum field (since the UDP header
   already contains a checksum) but instead includes a 16-bit Reserved/
   Length field in bits 16 thru 31.  The {ITE, ETE} sets the Type, Code,
   Reserved/Length and Message body fields according to the specific
   SEAL control message type, then appends as much of the invoking
   packet as possible.

   The following types are currently defined; other values for Type will
   be recorded in the IANA registry for SEAL:

4.4.5.1.  Reassembly Report (Type=0)

   An ETE generates a Reassembly Report to inform the ITE of various
   conditions encountered during outer IP and SEAL-layer reassembly.
   The following values for Code are currently defined (other values for
   Code will be recorded in the IANA registry for SEAL):



Templin                  Expires April 10, 2010                [Page 25]

Internet-Draft                    SEAL                      October 2009


   o  Code = 0 : IP Fragmentation Experienced

   o  Code = 1 : Segment Acknowledged

   o  Code = 2 : Packet Too Big

   o  Code = 3 : Time Exceeded

   The ETE prepares the Reassembly Report according to the Code.  In
   each case, the Reassembly Report includes an S_MRU value that denotes
   the maximum-sized packet the ETE is willing to receive from the ITE
   (normally set to the ETE's reassembly buffer size - see Section
   4.4.1).  The ETE MAY advertise different S_MRU values to different
   ITEs, but it SHOULD maintain a persistent value for each ITE that
   changes only very rarely (if at all).  Reassembly Report formats for
   each Code are specified in the following sections:

4.4.5.1.1.  IP Fragmentation Experienced (Code=0)

   When an ETE receives an IP first-fragment of a SEAL data packet that
   experienced outer IP fragmentation, it uses the IP first-fragment to
   prepare a "Reassembly Report - IP Fragmentation Experienced" message
   with Type=0, Code=0, and Reserved=0.  The message is formatted as
   follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=0     |     Code=0    |           Reserved=0          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             S_MRU                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             S_MSS                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    As much of invoking packet                 |
      +               as possible without the SEAL Control            +
      |                   Message exceeding 576 bytes                 |

           Figure 5: IP Fragmentation Experienced Message Format

   The ETE writes the maximum-sized packet it is willing to receive from
   this ITE (normally its reassembly buffer size - see Section 4.4.1) in
   the S_MRU field and writes the length of the first IP fragment in the
   S_MSS field.  The ETE finally writes as much of the invoking packet
   as possible at the end of the message and sends the message to the
   ITE.





Templin                  Expires April 10, 2010                [Page 26]

Internet-Draft                    SEAL                      October 2009


4.4.5.1.2.  Segment Acknowledged (Code=1)

   When an ETE receives a SEAL data packet following IP reassembly that
   has the 'A' bit set in the SEAL header, it prepares a "Reassembly
   Report - Segment Acknowledged" message with Type=0, Code=1, and
   Reserved=0.  The message is formatted as follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=0     |     Code=1    |           Reserved=0          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             S_MRU                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    As much of invoking packet                 |
      +               as possible without the SEAL Control            +
      |                   Message exceeding 576 bytes                 |

               Figure 6: Segment Acknowledged Message Format

   The ETE writes the maximum-sized packet it is willing to receive from
   this ITE in the S_MRU field, then writes as much of the invoking
   packet as possible at the end of the message and sends the message to
   the ITE.

4.4.5.1.3.  Packet Too Big (Code=2)

   An ETE generates a "Reassembly Report - Packet Too Big" message when
   it discards a SEAL data packet that is larger than it is willing to
   receive from this ITE.  The ETE sets Type=0, Code=2, and Reserved=0.
   The message is formatted as follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=0     |     Code=2    |           Reserved=0          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             S_MRU                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    As much of invoking packet                 |
      +               as possible without the SEAL Control            +
      |                   Message exceeding 576 bytes                 |

                  Figure 7: Packet Too Big Message Format

   The ETE writes the maximum-sized packet it is willing to receive from
   this ITE in the S_MRU field, then writes as much of the invoking
   packet as possible at the end of the message and sends the message to



Templin                  Expires April 10, 2010                [Page 27]

Internet-Draft                    SEAL                      October 2009


   the ITE.

4.4.5.1.4.  Time Exceeded (Code=3)

   An ETE generates a "Reassembly Report - Time Exceeded" message when
   it discards an incomplete SEAL reassembly buffer due to a reassembly
   timeout.  The ETE sets Type=0, Code=3, and sets Reserved=0.  The
   message is formatted as follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=0     |     Code=3    |           Reserved=0          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             S_MRU                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    Time (in milliseconds)                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                  As much of most recent packet                |
      +               as possible without the SEAL Control            +
      |                   Message exceeding 576 bytes                 |

                  Figure 8: Time Exceeded Message Format

   The ETE writes the maximum-sized packet it is willing to receive from
   this ITE in the S_MRU field, then writes the Time (in milliseconds)
   from when the first SEAL segment arrived until the SEAL reassembly
   timeout expired in the Time field.  The ETE finally writes as much of
   the most recently received packet in the reassembly buffer as
   possible at the end of the message and sends the message to the ITE.

4.4.5.2.  Parameter Problem (Type=1)

   An ETE generates a "Parameter Problem" message when it receives a
   SEAL packet with an invalid value in the SEAL header.  The ETE sets
   Type=1, then sets Code=0 and Reserved=0; other values for Code will
   be recorded in the IANA registry for SEAL.  The Parameter Problem
   message is formatted as follows:













Templin                  Expires April 10, 2010                [Page 28]

Internet-Draft                    SEAL                      October 2009


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=1     |     Code=0    |   Reserved=0  |    Pointer    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    As much of invoking packet                 |
      +               as possible without the SEAL Control            +
      |                   Message exceeding 576 bytes                 |

                Figure 9: Parameter Problem Message Format

   The ETE sets an 8-bit Pointer field to the bit number of the SEAL
   header field that triggered the error (for example, when Pointer=8
   the parameter problem is specific to the NEXTHDR/SEG field).  The ETE
   finally writes as much of the invoking packet as possible at the end
   of the message and sends the message to the ITE.

4.4.5.3.  Information Request Solicit (Type=2)

   An ETE generates an "Information Request Solicit" message when it
   receives a SEAL data packet with stale information and wishes to
   inform the ITE of new information.  The ETE sets Type=2, then sets
   Code and Reserved to values that are specific to the associated
   tunneling protocol (for example, the tunneling protocol can use the
   Information Request Solicit message to initiate mapping updates).
   When the ETE sets Code=0, it also sets Reserved=0; other values for
   Code will be recorded in the IANA registry for SEAL.

   The Information Request Solicit message is formatted as follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=2     |     Code=0    |           Reserved=0          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    As much of invoking packet                 |
      +               as possible without the SEAL Control            +
      |                   Message exceeding 576 bytes                 |

           Figure 10: Information Request Solicit Message Format

   The ETE writes as much of the invoking packet as possible at the end
   of the message, then sends the Information Request Solicit message
   and listens for a corresponding Information Request (see Section
   4.4.5.4).






Templin                  Expires April 10, 2010                [Page 29]

Internet-Draft                    SEAL                      October 2009


4.4.5.4.  Information Request (Type=3)

   An ITE generates an "Information Request" message when it receives an
   Information Request Solicit control message from an ETE.  An ETE
   generates an Information Request message when it receives a SEAL data
   packet with I=1 in the SEAL header from an ITE.

   When an {ITE, ETE} generates an Information Request message, it sets
   Type=3, then sets Code and Reserved to values that are specific to
   the associated tunneling protocol (for example, the tunneling
   protocol can use the Information Request message to request mapping
   updates).  When the {ITE, ETE} sets Code=0, it also sets Reserved=0;
   other values for Code will be recorded in the IANA registry for SEAL.

   The Information Request message is formatted as follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=3     |     Code=0    |           Reserved=0          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    As much of invoking packet                 |
      +               as possible without the SEAL Control            +
      |                   Message exceeding 576 bytes                 |

               Figure 11: Information Request Message Format

   The {ITE, ETE} writes as much of the invoking packet as possible at
   the end of the message, then sends the Information Request message
   and waits to receive a corresponding Information Reply.  The {ITE,
   ETE} tries up to 'MAXTRIES' times (recommended default value 3).
   Note that while in this loop the {ITE; ETE} may receive a new
   Information Request Solicit.  In that case, it should abandon its
   attempts to satisfy the old solicitation and begin sending
   Information Requests specific to the new solicitation.

4.4.5.5.  Information Reply (Type=4)

   When an {ITE, ETE} receives an Information Request message, it
   responds by sending an "Information Reply" message.  The {ITE, ETE}
   sets Type=4, then sets Code and Reserved/Length to values that are
   specific to the associated tunneling protocol (for example, the
   tunneling protocol can use the Information Reply message to encode
   mapping updates).  When Code=0, Length encodes a value N that is the
   length of a block of Opaque Data that follows.  Other values for Code
   will be recorded in the IANA registry for SEAL.

   The information reply message is formatted as follows:



Templin                  Expires April 10, 2010                [Page 30]

Internet-Draft                    SEAL                      October 2009


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=4     |     Code=0    |           Length=N            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      ~                      Opaque Data [N bytes]                    ~
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    As much of invoking packet                 |
      +               as possible without the SEAL Control            +
      |                   Message exceeding 576 bytes                 |

                Figure 12: Information Reply Message Format

   When Code=0, the {ITE, ETE} sets Length=N and includes an N-byte
   block of Opaque Data that is specific to the associated tunneling
   protocol.  The {ITE, ETE} then writes as much of the invoking packet
   as possible and sends the Information Reply message.


5.  SEAL with Fragmentation Sensing (SEAL-FS) Protocol Specification

   This section specifies a minimal mode of SEAL known as "SEAL with
   Fragmentation Sensing (SEAL-FS)".  SEAL-FS observes the same protocol
   specifications as for "SEAL with Segmentation and Reassembly
   (SEAL-SR)" (see Section 4) except that the ETE unilaterally drops any
   SEAL-FS packets that arrive as multiple IP fragments and/or multiple
   SEAL segments.

   SEAL-FS can be considered for use by associated tunneling protocol
   specifications when there is operational assurance that "marginal"
   links are rare, e.g., when it is known that the vast majority of
   links configure MTUs that are appreciably larger than a constant
   value 'M' (e.g., 1500 bytes).  SEAL-FS can also be used in instances
   when it is acceptable for the ITE to return PTB messages for packet
   sizes smaller than 'M', however SEAL-SR should be used instead if
   excessive PTB messages would result.  Finally since the SEAL-FS
   header does not include a "Next Header" field, the associated
   tunneling protocol specification must either define its own next
   header field or ensure that the beginning of the inner IP header can
   be determined in some other way.

   With respect to Section 4, the SEAL-FS protocol corresponds to
   SEAL-SR as follows:






Templin                  Expires April 10, 2010                [Page 31]

Internet-Draft                    SEAL                      October 2009


5.1.  Model of Operation

   SEAL-FS follows the same model of operation as for SEAL-SR as
   described in Section 4.1 except as noted in the following sections.

5.2.  SEAL-FS Header Format (Version 0)

   The SEAL-FS header is formatted as follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |MOD|A|I|                    Identification                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                  Figure 13: SEAL Version 1 Header Format

   where the header fields are defined as:

   MOD (2)
      a 2-bit value that encodes the SEAL protocol mode.  This section
      describes Mode 0 of the SEAL protocol, i.e., the MOD field encodes
      the value '0'.

   A (1)
      the "Acknowledgement Requested" bit.  Set to 1 if the ITE wishes
      to receive an explicit acknowledgement from the ETE.

   I (1)
      the "Information Request Solicit" bit.  Set to 1 if the ITE wishes
      the ETE to initiate an Information Request.

   Identification (28)
      a 28-bit identification field.

5.3.  ITE Specification

5.3.1.  Tunnel Interface MTU

   SEAL-FS observes the SEAL-SR specification found in Section 4.3.1.

5.3.2.  Admitting Packets into the Tunnel Interface

   SEAL-FS observes the SEAL-SR specification found in Section 4.3.2.







Templin                  Expires April 10, 2010                [Page 32]

Internet-Draft                    SEAL                      October 2009


5.3.3.  Segmentation

   SEAL-FS observes the SEAL-SR specification found in Section 4.3.3,
   except that the inner fragmentation algorithm is adjusted to avoid
   all outer IP fragmentation and SEAL segmentation within the tunnel.
   For this purpose, the SEAL-FS ITE maintains S_MSS as a value that
   would be unlikely to incur fragmentation within the tunnel, e.g., 576
   bytes for IPv4 and 1280 bytes for IPv6.  The ITE may also set S_MSS
   to a larger value if there is assurance that the vast majority of
   links that may occur within the tunnel configure a larger MTU.  The
   ITE then uses S_MRU and S_MSS in the following algorithm to determine
   when to discard, fragment or admit the inner packets into the tunnel
   without inner fragmentation:

   o  if the inner packet is an IPv6 packet or an IPv4 packet with DF=1,
      and the packet is larger than (MIN(S_MRU, S_MSS) - HLEN), the ITE
      drops the packet and sends a PTB message to the original source
      with an MTU value of (MIN(S_MRU, S_MSS) - HLEN) the same as
      described in Section 4.3.2; else,

   o  if the inner packet is an IPv4 packet with DF=0, and the packet is
      larger than (MIN(S_MRU, S_MSS) - HLEN), the ITE uses inner IPv4
      fragmentation to break the packet into fragments no larger than
      (MIN(S_MRU - S_MSS) - HLEN); else,

   o  the ITE admits the packet without inner fragmentation.

   If the inner packet is an IPv6 packet or an IPv4 packet with DF=1,
   the ITE can instead employ a stateless strategy by simply
   encapsulating and sending the packet as specified in Section 4.3.4
   through 4.3.7.  The ITE then translates any "Reassembly Report -
   Fragmentation Needed" and "Reassembly Report - Packet Too big"
   messages into PTB messages to return to the original source (where
   the translation is based on the encapsulated portion of the invoking
   packet at the end of the reassembly report message).  In this method,
   the ITE need not retain per-ETE S_MRU and S_MSS state.

5.3.4.  Encapsulation

   SEAL-FS observes the SEAL-SR specification found in Section 4.3.4,
   except that it uses the header format defined in this section and
   with the MOD field set to '0'.  SEAL-FS uses the A and I bits the
   same as specified for SEAL-SR.

5.3.5.  Probing Strategy

   SEAL-FS observes the SEAL-SR specification found in Section 4.3.5.




Templin                  Expires April 10, 2010                [Page 33]

Internet-Draft                    SEAL                      October 2009


5.3.6.  Packet Identification

   SEAL-FS observes the SEAL-SR soft state specifications found in
   Section 4.3.6, but the SEAL_ID is treated as a 28-bit value.

5.3.7.  Sending SEAL Protocol Packets

   SEAL-FS observes the SEAL-SR specification found in Section 4.3.7.

5.3.8.  Processing Raw ICMP Messages

   SEAL-FS observes the SEAL-SR specification found in Section 4.3.8.

5.3.9.  Processing SEAL Control Messages

   SEAL-FS observes the SEAL-SR specification found in Section 4.3.9.

5.4.  ETE Specification

5.4.1.  Reassembly Buffer Requirements

   SEAL-FS does not maintain a reassembly buffer for SEAL reassembly,
   but still maintains a value for S_MRU as the largest packet size the
   ETE is willing to receive.

5.4.2.  IP-Layer Reassembly

   SEAL-FS uses SEAL-protocol IP first-fragments solely for the purpose
   of generating SEAL Reassembly Reports as specified in Section 4.4.2,
   but otherwise discards all SEAL-protocol IP fragments.

5.4.3.  SEAL-Layer Reassembly

   SEAL-FS does not observe the SEAL-SR reassembly procedures in Section
   4.4.3, since SEAL-FS headers contain no segmentation and reassembly
   information.

   As for SEAL-SR, SEAL-FS returns a Parameter Problem for SEAL packets
   with unrecognized values in the SEAL header.

5.4.4.  Decapsulation and Delivery to Upper Layers

   SEAL-FS observes the SEAL-SR specification found in Section 4.4.4.

5.4.5.  Sending SEAL Control Messages

   SEAL-FS observes the SEAL-SR specification found in Section 4.4.5.




Templin                  Expires April 10, 2010                [Page 34]

Internet-Draft                    SEAL                      October 2009


6.  Link Requirements

   Subnetwork designers are expected to follow the recommendations in
   Section 2 of [RFC3819] when configuring link MTUs.


7.  End System Requirements

   SEAL provides robust mechanisms for returning PTB messages; however,
   end systems that send unfragmentable IP packets larger than 1500
   bytes are strongly encouraged to use Packetization Layer Path MTU
   Discovery per [RFC4821].


8.  Router Requirements

   IPv4 routers within the subnetwork are strongly encouraged to
   implement IPv4 fragmentation such that the first-fragment is the
   largest and approximately the size of the underlying link MTU, i.e.,
   they should avoid generating runt first-fragments.


9.  IANA Considerations

   The IANA is instructed to allocate an IP protocol number for
   'SEAL_PROTO' in the 'protocol-numbers' registry.

   The IANA is instructed to allocate a Well-Known Port number for both
   'SEAL_CPORT' and 'SEAL_DPORT' in the 'port-numbers' registry.

   The IANA is instructed to establish a "SEAL Protocol" registry to
   record SEAL Mode values and SEAL control message Code and Type
   values.  This registry should be initialized to include the Mode
   values defined in Sections 4.2 and 5.2, and the Code and Type values
   defined in Section 4.4.5.


10.  Security Considerations

   Unlike IPv4 fragmentation, overlapping fragment attacks are not
   possible due to the requirement that SEAL segments be non-
   overlapping.  This condition is naturally enforced due to the fact
   that each consecutive SEAL segment begins at offset 0 wrt the
   previous SEAL segment.

   An amplification/reflection attack is possible when an attacker sends
   IP first-fragments with spoofed source addresses to an ETE, resulting
   in a stream of Reassembly Report messages returned to a victim ITE.



Templin                  Expires April 10, 2010                [Page 35]

Internet-Draft                    SEAL                      October 2009


   The SEAL_ID in the encapsulated segment of the spoofed IP first-
   fragment provides mitigation for the ITE to detect and discard
   spurious Reassembly Reports.

   The SEAL header is sent in-the-clear (outside of any IPsec/ESP
   encapsulations) the same as for the outer IP and other outer headers
   and trailers.  In this respect, the threat model is no different than
   for IPv6 extension headers.  As for IPv6 extension headers, the SEAL
   header is protected only by L2 integrity checks and is not covered
   under any L3 integrity checks.

   SEAL control messages carry the SEAL_ID of the packet-in-error.
   Therefore, when an ITE receives a SEAL control message it can
   unambiguously associate the message with the data packet that
   triggered the error.

   Security issues that apply to tunneling in general are discussed in
   [I-D.ietf-v6ops-tunnel-security-concerns].


11.  Related Work

   Section 3.1.7 of [RFC2764] provides a high-level sketch for
   supporting large tunnel MTUs via a tunnel-level segmentation and
   reassembly capability to avoid IP level fragmentation, which is in
   part the same approach used by tunnel-mode SEAL.  SEAL could
   therefore be considered as a fully functioned manifestation of the
   method postulated by that informational reference.

   Section 3 of [RFC4459] describes inner and outer fragmentation at the
   tunnel endpoints as alternatives for accommodating the tunnel MTU;
   however, the SEAL protocol specifies a mid-layer segmentation and
   reassembly capability that is distinct from both inner and outer
   fragmentation.

   Section 4 of [RFC2460] specifies a method for inserting and
   processing extension headers between the base IPv6 header and
   transport layer protocol data.  The SEAL header is inserted and
   processed in exactly the same manner.

   The concepts of path MTU determination through the report of
   fragmentation and extending the IP Identification field were first
   proposed in deliberations of the TCP-IP mailing list and the Path MTU
   Discovery Working Group (MTUDWG) during the late 1980's and early
   1990's.  SEAL supports a report fragmentation capability using bits
   in an extension header (the original proposal used a spare bit in the
   IP header) and supports ID extension through a 16-bit field in an
   extension header (the original proposal used a new IP option).  A



Templin                  Expires April 10, 2010                [Page 36]

Internet-Draft                    SEAL                      October 2009


   historical analysis of the evolution of these concepts, as well as
   the development of the eventual path MTU discovery mechanism for IP,
   appears in Appendix D of this document.


12.  SEAL Advantages over Classical Methods

   The SEAL approach offers a number of distinct advantages over the
   classical path MTU discovery methods [RFC1191] [RFC1981]:

   1.  Classical path MTU discovery always results in packet loss when
       an MTU restriction is encountered.  Using SEAL, IP fragmentation
       provides a short-term interim mechanism for ensuring that packets
       are delivered while SEAL adjusts its packet sizing parameters.

   2.  Classical path MTU may require several iterations of dropping
       packets and returning PTB messages until an acceptable path MTU
       value is determined.  Under normal circumstances, SEAL determines
       the correct packet sizing parameters in a single iteration.

   3.  Using SEAL, ordinary packets serve as implicit probes without
       exposing data to unnecessary loss.  SEAL also provides an
       explicit probing mode not available in the classic methods.

   4.  Using SEAL, ETEs encapsulate error messages in an outer UDP/IP
       header such that packet-filtering network middleboxes will not
       filter them the same as for "raw" ICMP messages that may be
       generated by an attacker.

   5.  Most importantly, all SEAL packets have an Identification field
       that is sufficiently long to be used for duplicate packet
       detection purposes and to match ICMP error messages with actual
       packets sent without requiring per-packet state; hence, SEAL
       avoids certain denial-of-service attack vectors open to the
       classical methods.

   In summary, the SEAL approach ensures that packets of various sizes
   are either delivered or deterministically dropped.  When end systems
   use their own end-to-end MTU determination mechanisms [RFC4821], the
   SEAL advantages are further enhanced.


13.  Acknowledgments

   The following individuals are acknowledged for helpful comments and
   suggestions: Jari Arkko, Fred Baker, Iljitsch van Beijnum, Oliver
   Bonaventure, Teco Boot, Bob Braden, Brian Carpenter, Steve Casner,
   Ian Chakeres, Noel Chiappa, Remi Denis-Courmont, Aurnaud Ebalard,



Templin                  Expires April 10, 2010                [Page 37]

Internet-Draft                    SEAL                      October 2009


   Gorry Fairhurst, Dino Farinacci, Joel Halpern, Sam Hartman, John
   Heffner, Thomas Henderson, Bob Hinden, Christian Huitema, Eliot Lear,
   Darrel Lewis, Joe Macker, Matt Mathis, Erik Nordmark, Dan Romascanu,
   Dave Thaler, Joe Touch, Margaret Wasserman, Magnus Westerlund, Robin
   Whittle, James Woodyatt, and members of the Boeing Research &
   Technology NST DC&NT group.

   Path MTU determination through the report of fragmentation was first
   proposed by Charles Lynn on the TCP-IP mailing list in 1987.
   Extending the IP identification field was first proposed by Steve
   Deering on the MTUDWG mailing list in 1989.


14.  References

14.1.  Normative References

   [RFC0791]  Postel, J., "Internet Protocol", STD 5, RFC 791,
              September 1981.

   [RFC0792]  Postel, J., "Internet Control Message Protocol", STD 5,
              RFC 792, September 1981.

   [RFC1146]  Zweig, J. and C. Partridge, "TCP alternate checksum
              options", RFC 1146, March 1990.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 2460, December 1998.

   [RFC4443]  Conta, A., Deering, S., and M. Gupta, "Internet Control
              Message Protocol (ICMPv6) for the Internet Protocol
              Version 6 (IPv6) Specification", RFC 4443, March 2006.

14.2.  Informative References

   [FOLK]     C, C., D, D., and k. k, "Beyond Folklore: Observations on
              Fragmented Traffic", December 2002.

   [FRAG]     Kent, C. and J. Mogul, "Fragmentation Considered Harmful",
              October 1987.

   [I-D.ietf-lisp]
              Farinacci, D., Fuller, V., Meyer, D., and D. Lewis,
              "Locator/ID Separation Protocol (LISP)",
              draft-ietf-lisp-05 (work in progress), September 2009.



Templin                  Expires April 10, 2010                [Page 38]

Internet-Draft                    SEAL                      October 2009


   [I-D.ietf-tcpm-icmp-attacks]
              Gont, F., "ICMP attacks against TCP",
              draft-ietf-tcpm-icmp-attacks-06 (work in progress),
              August 2009.

   [I-D.ietf-v6ops-tunnel-security-concerns]
              Hoagland, J., Krishnan, S., and D. Thaler, "Security
              Concerns With IP Tunneling",
              draft-ietf-v6ops-tunnel-security-concerns-01 (work in
              progress), October 2008.

   [I-D.russert-rangers]
              Russert, S., Fleischman, E., and F. Templin, "RANGER
              Scenarios", draft-russert-rangers-01 (work in progress),
              September 2009.

   [I-D.templin-intarea-vet]
              Templin, F., "Virtual Enterprise Traversal (VET)",
              draft-templin-intarea-vet-04 (work in progress),
              September 2009.

   [I-D.templin-ranger]
              Templin, F., "Routing and Addressing in Next-Generation
              EnteRprises (RANGER)", draft-templin-ranger-07 (work in
              progress), February 2009.

   [MTUDWG]   "IETF MTU Discovery Working Group mailing list,
              gatekeeper.dec.com/pub/DEC/WRL/mogul/mtudwg-log, November
              1989 - February 1995.".

   [RFC1063]  Mogul, J., Kent, C., Partridge, C., and K. McCloghrie, "IP
              MTU discovery options", RFC 1063, July 1988.

   [RFC1191]  Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,
              November 1990.

   [RFC1981]  McCann, J., Deering, S., and J. Mogul, "Path MTU Discovery
              for IP version 6", RFC 1981, August 1996.

   [RFC2003]  Perkins, C., "IP Encapsulation within IP", RFC 2003,
              October 1996.

   [RFC2004]  Perkins, C., "Minimal Encapsulation within IP", RFC 2004,
              October 1996.

   [RFC2473]  Conta, A. and S. Deering, "Generic Packet Tunneling in
              IPv6 Specification", RFC 2473, December 1998.




Templin                  Expires April 10, 2010                [Page 39]

Internet-Draft                    SEAL                      October 2009


   [RFC2675]  Borman, D., Deering, S., and R. Hinden, "IPv6 Jumbograms",
              RFC 2675, August 1999.

   [RFC2764]  Gleeson, B., Heinanen, J., Lin, A., Armitage, G., and A.
              Malis, "A Framework for IP Based Virtual Private
              Networks", RFC 2764, February 2000.

   [RFC2923]  Lahey, K., "TCP Problems with Path MTU Discovery",
              RFC 2923, September 2000.

   [RFC3366]  Fairhurst, G. and L. Wood, "Advice to link designers on
              link Automatic Repeat reQuest (ARQ)", BCP 62, RFC 3366,
              August 2002.

   [RFC3692]  Narten, T., "Assigning Experimental and Testing Numbers
              Considered Useful", BCP 82, RFC 3692, January 2004.

   [RFC3819]  Karn, P., Bormann, C., Fairhurst, G., Grossman, D.,
              Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L.
              Wood, "Advice for Internet Subnetwork Designers", BCP 89,
              RFC 3819, July 2004.

   [RFC4213]  Nordmark, E. and R. Gilligan, "Basic Transition Mechanisms
              for IPv6 Hosts and Routers", RFC 4213, October 2005.

   [RFC4301]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, December 2005.

   [RFC4380]  Huitema, C., "Teredo: Tunneling IPv6 over UDP through
              Network Address Translations (NATs)", RFC 4380,
              February 2006.

   [RFC4459]  Savola, P., "MTU and Fragmentation Issues with In-the-
              Network Tunneling", RFC 4459, April 2006.

   [RFC4727]  Fenner, B., "Experimental Values In IPv4, IPv6, ICMPv4,
              ICMPv6, UDP, and TCP Headers", RFC 4727, November 2006.

   [RFC4821]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", RFC 4821, March 2007.

   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler, "IPv4 Reassembly
              Errors at High Data Rates", RFC 4963, July 2007.

   [RFC5445]  Watson, M., "Basic Forward Error Correction (FEC)
              Schemes", RFC 5445, March 2009.

   [TCP-IP]   "Archive/Hypermail of Early TCP-IP Mail List,



Templin                  Expires April 10, 2010                [Page 40]

Internet-Draft                    SEAL                      October 2009


              http://www-mice.cs.ucl.ac.uk/multimedia/misc/tcp_ip/, May
              1987 - May 1990.".


Appendix A.  Reliability

   Although a SEAL-SR tunnel may span an arbitrarily-large subnetwork
   expanse, the IP layer sees the tunnel as a simple link that supports
   the IP service model.  Since SEAL-SR supports segmentation at a layer
   below IP, SEAL-SR therefore presents a case in which the link unit of
   loss (i.e., a SEAL segment) is smaller than the end-to-end
   retransmission unit (e.g., a TCP segment).

   Links with high bit error rates (BERs) (e.g., IEEE 802.11) use
   Automatic Repeat-ReQuest (ARQ) mechanisms [RFC3366] to increase
   packet delivery ratios, while links with much lower BERs typically
   omit such mechanisms.  Since SEAL-SR tunnels may traverse
   arbitrarily-long paths over links of various types that are already
   either performing or omitting ARQ as appropriate, it would therefore
   be inefficient to also require the tunnel to perform ARQ in the
   general sense.

   When the SEAL-SR ITE has knowledge that the tunnel will traverse a
   subnetwork with non-negligible loss due to, e.g., interference, link
   errors, congestion, etc., it can solicit Reassembly Reports from the
   ETE periodically to discover missing segments for retransmission
   within a single round-trip time.  However, retransmission of missing
   segments may require the ITE to maintain considerable state and may
   also result in considerable delay variance and packet reordering.

   SEAL-SR may also use alternate reliability mechanisms such as Forward
   Error Correction (FEC).  A simple FEC mechanism may merely entail
   gratuitous retransmissions of duplicate data, however more efficient
   alternatives are also possible.  Basic FEC schemes are discussed in
   [RFC5445].

   The use of ARQ and FEC mechanisms for improved reliability are for
   further study.


Appendix B.  Integrity

   Each link in the path over which a SEAL tunnel is configured is
   responsible for first-pass integrity verification for packets that
   traverse the link.  As such, when a multi-segment SEAL packet with N
   segments is reassembled, its segments will have been inspected by N
   independent link layer integrity check streams instead of a single
   stream that a single segment SEAL packet of the same size would have



Templin                  Expires April 10, 2010                [Page 41]

Internet-Draft                    SEAL                      October 2009


   received.  Intuitively, a reassembled packet subjected to N
   independent integrity check streams of shorter-length segments would
   seem to have integrity assurance that is no worse than a single-
   segment packet subjected to only a single integrity check steam,
   since the integrity check strength diminishes in inverse proportion
   with segment length.  In any case, the link-layer integrity assurance
   for a multi-segment SEAL packet is no different than for a multi-
   fragment IPv6 packet.

   Fragmentation and reassembly schemes must also consider packet-
   splicing errors, e.g., when two segments from the same packet are
   concatenated incorrectly, when a segment from packet X is reassembled
   with segments from packet Y, etc.  The primary sources of such errors
   include implementation bugs and wrapping IP ID fields.  In terms of
   implementation bugs, the SEAL segmentation and reassembly algorithm
   is much simpler than IP fragmentation resulting in simplified
   implementations.  In terms of wrapping ID fields, when IPv4 is used
   as the outer IP protocol, the 16-bit IP ID field can wrap with only
   64K packets with the same (src, dst, protocol)-tuple alive in the
   system at a given time [RFC4963] increasing the likelihood of
   reassembly mis-associations.  However, SEAL ensures that any outer
   IPv4 fragmentation and reassembly will be short-lived and tuned out
   as soon as the ITE receives a Reassembly Repot, and SEAL segmentation
   and reassembly uses a much longer ID field.  Therefore, reassembly
   mis-associations of IP fragments nor of SEAL segments should be
   prohibitively rare.


Appendix C.  Transport Mode

   SEAL can also be used in "transport-mode", e.g., when the inner layer
   includes upper-layer protocol data rather than an encapsulated IP
   packet.  For instance, TCP peers can negotiate the use of SEAL for
   the carriage of protocol data encapsulated as IPv4/SEAL/TCP.  In this
   sense, the "subnetwork" becomes the entire end-to-end path between
   the TCP peers and may potentially span the entire Internet.

   Sections 4 and 5 specify the operation of SEAL in "tunnel mode",
   i.e., when there are both an inner and outer IP layer with a SEAL
   encapsulation layer between.  However, the SEAL protocol can also be
   used in a "transport mode" of operation within a subnetwork region in
   which the inner-layer corresponds to a transport layer protocol
   (e.g., UDP, TCP, etc.) instead of an inner IP layer.

   For example, two TCP endpoints connected to the same subnetwork
   region can negotiate the use of transport-mode SEAL for a connection
   by inserting a 'SEAL_OPTION' TCP option during the connection
   establishment phase.  If both TCPs agree on the use of SEAL, their



Templin                  Expires April 10, 2010                [Page 42]

Internet-Draft                    SEAL                      October 2009


   protocol messages will be carried as TCP/SEAL/IPv4 and the connection
   will be serviced by the SEAL protocol using TCP (instead of an
   encapsulating tunnel endpoint) as the transport layer protocol.  The
   SEAL protocol for transport mode otherwise observes the same
   specifications as for Sections 4 and 5.


Appendix D.  Historic Evolution of PMTUD

   The topic of Path MTU discovery (PMTUD) saw a flurry of discussion
   and numerous proposals in the late 1980's through early 1990.  The
   initial problem was posed by Art Berggreen on May 22, 1987 in a
   message to the TCP-IP discussion group [TCP-IP].  The discussion that
   followed provided significant reference material for [FRAG].  An IETF
   Path MTU Discovery Working Group [MTUDWG] was formed in late 1989
   with charter to produce an RFC.  Several variations on a very few
   basic proposals were entertained, including:

   1.  Routers record the PMTUD estimate in ICMP-like path probe
       messages (proposed in [FRAG] and later [RFC1063])

   2.  The destination reports any fragmentation that occurs for packets
       received with the "RF" (Report Fragmentation) bit set (Steve
       Deering's 1989 adaptation of Charles Lynn's Nov. 1987 proposal)

   3.  A hybrid combination of 1) and Charles Lynn's Nov. 1987 (straw
       RFC draft by McCloughrie, Fox and Mogul on Jan 12, 1990)

   4.  Combination of the Lynn proposal with TCP (Fred Bohle, Jan 30,
       1990)

   5.  Fragmentation avoidance by setting "IP_DF" flag on all packets
       and retransmitting if ICMPv4 "fragmentation needed" messages
       occur (Geof Cooper's 1987 proposal; later adapted into [RFC1191]
       by Mogul and Deering).

   Option 1) seemed attractive to the group at the time, since it was
   believed that routers would migrate more quickly than hosts.  Option
   2) was a strong contender, but repeated attempts to secure an "RF"
   bit in the IPv4 header from the IESG failed and the proponents became
   discouraged. 3) was abandoned because it was perceived as too
   complicated, and 4) never received any apparent serious
   consideration.  Proposal 5) was a late entry into the discussion from
   Steve Deering on Feb. 24th, 1990.  The discussion group soon
   thereafter seemingly lost track of all other proposals and adopted
   5), which eventually evolved into [RFC1191] and later [RFC1981].

   In retrospect, the "RF" bit postulated in 2) is not needed if a



Templin                  Expires April 10, 2010                [Page 43]

Internet-Draft                    SEAL                      October 2009


   "contract" is first established between the peers, as in proposal 4)
   and a message to the MTUDWG mailing list from jrd@PTT.LCS.MIT.EDU on
   Feb 19. 1990.  These proposals saw little discussion or rebuttal, and
   were dismissed based on the following the assertions:

   o  routers upgrade their software faster than hosts

   o  PCs could not reassemble fragmented packets

   o  Proteon and Wellfleet routers did not reproduce the "RF" bit
      properly in fragmented packets

   o  Ethernet-FDDI bridges would need to perform fragmentation (i.e.,
      "translucent" not "transparent" bridging)

   o  the 16-bit IP_ID field could wrap around and disrupt reassembly at
      high packet arrival rates

   The first four assertions, although perhaps valid at the time, have
   been overcome by historical events.  The final assertion is addressed
   by the mechanisms specified in SEAL.


Author's Address

   Fred L. Templin (editor)
   Boeing Research & Technology
   P.O. Box 3707
   Seattle, WA  98124
   USA

   Email: fltemplin@acm.org



















Templin                  Expires April 10, 2010                [Page 44]


