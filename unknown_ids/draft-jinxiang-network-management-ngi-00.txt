


Network Working Group                                     JinXiang,Zhang
Internet-Draft                                               Jiahai,Yang
Intended status: Best Current Practice                       Jianping,Wu
Practice                     Network research center,Tsinghua University
Expires: June 28, 2008                                 December 28, 2007


 Retriving MIB Information based on NGI  
             draft-jinxiang-operations-and-management-ngi-00

Status of This Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on May 5, 2008.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   An important task of network management is to collect and analyze 
   MIB information  of various object combinations based on the
   Simple Network Management Protocol (SNMP) with proper frequency.
   The purpose of this document is to propose two algorithms to retrieve
   MIB information  for a large (up to exponential) number of managed 
   objects using SNMP in Next Generation Internet (NGI). 
   



JinXiang,Zhang, et al.   Expires June 28, 2008                  [Page 1]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007



Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Self-Adaptive Algorithm  . . . . . . . . . .  .  .  .  . . . .  4
     2.1.  Description of problems. . . . . . . . . . . . . . . . . .  4
     2.2.  Policy on fault tolerance. . . . . . . . . . . . . . . . .  4
     2.3.  Policy on self-adaptivity  . . . . . . . . . . . . . . . .  4
     2.4.  Policy on dynamical recognition status of object . . . . .  6
     2.5.  Description of SAA . . . . . . . . . . . . . . . . . . . .  6
   3.  Group-Prefetching Algorithm  . . . . . . . . . . . . . . . . .  8
     3.1.  Description of problems  . . . . . . . . . . . . . . . . .  8
     3.2.  Policy on group prefetching  . . . . . . . . . . . . . . .  8
     3.3.  Policy on extending MO of group self-adaptively  . . . . . 10
     3.4.  Policy on shrinking MO of group self-adaptively. . . . . . 11
     3.5.  Policy on dynamical recognition status of object . . . . . 11
     3.6.  Policy on fault tolerance. . . . . . . . . . . . . . . . . 11
     3.7.  Description of GPA   . . . . . . . . . . . . . . . . . . . 11
   4.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 13
   5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 13  
   6.  References   . . . . . . . . . . . . . . . . . . . . . . . . . 13





























JinXiang,Zhang, et al.   Expires June 28, 2008                  [Page 2]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007


1.  Introduction

   As the network scale expands and the resources provided by network
   become more heterogeneous, it becomes more and more difficult for 
   the traditional network management and information retrieval scheme
   to meet the needs of network users. Furthermore, according to the
   new Moore Law, the bandwidth and traffic capacity can be doubled 
   in every six months. The number of managed objects increased
   exponentially. As the network management can be fulfilled through the
   information exchange between manager and agent, the performance of 
   network management is affected by the scheme to collect MIB[1].

   The traditional method of network management information retrieval is
   SIFD(Sequence and Interval Fixed Discrete single access Algorithm).
   But there are some weaknesses with this algorithm. Firstly, If there
    are a lot of managed objects (MO) in the managed network, SIFD cannot
   recognize which of the MOs are more important, Secondly, SIFD cannot
   access many discrete MOs simultaneously, Thirdly, SIFD may poll a MO
   although its agent is down. So SIFD may use up all network bandwidth 
   and then result in network congestion. 

   To resolve these problems, three enhanced information retrieval
   algorithms were proposed used to access table objects[2]. The
   first algorithm - Serial Algorithm retrieves the table objects using
   Get-Next operation, and the second algorithm - Pipelined Algorithm
   also accesses all the objects in a table by the repetitive retrieval
   of each column each time, moreover, the algorithm uses multiple
   threads technology, in which one thread accesses multiple rows in the
   table using Get-Next operation. The third algorithm - Parallel
   Algorithm adopts a multi-threaded approach, in which each thread 
   generates its own stream of Get-Next requests and processes the
   resulting stream of responses. However, all the three algorithms are
   only used for the retrieval of table objects and needed to alter SNMP
   , so the algorithms are not suitable for any kinds of MOs.

   In this document we propose a Self-Adaptive Algorithm (SAA), that can
   be used to retrieve any kind of MOs in NGI. This algorithm can adjust
   the number of retrieved objects and the interval of retrieval 
   self-adaptively based on self-adaptivity policy, fault tolerance 
   policy and dynamical recognition status of objects etc.. It can be 
   used to reduce network resource consumption without any modification 
   of SNMP.

   The other algorithm we propose in this document is Group-Prefetching 
   algorithm (GPA). With GPA, many small managed objects are gathered 
   into one prefetching group to be accessed using group prefetching 
   schemes. As a result, it can be used to decrease the retrieval 
   frequency and network resource consumption without any modification 
   



JinXiang,Zhang, et al.   Expires June 28, 2008                  [Page 3]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007


    of SNMP.

2.  Self-Adaptive Algorithm

   Let us now consider an algorithm for management information retrieval
   with the SNMP in NGI. Self-Adaptive Algorithm can adjust the
   number of retrieving objects and interval of retrieval self-
   adaptively by using the policies of self-adaptivity, fault tolerance,
   dynamical recognition status of objects etc., and thus can use fewer
   network resources without alteration of SNMP.

2.1.  Description on problems

   The model of SAA is as follows. if there are n MOs in the charge
   of m agents, where n > m, the algorithm will adjust the interval to 
   the next polling based on the polling value, status and weights
   of current polling results of n MOs. Moreover, the greater the weight
   value is, the more possibly the MO of Gauge Counter Type overflows.

   The algorithm complies with the principles as follows. Firstly,
   Computation power of Network Management Station (NMS) consumed by
   the algorithm should be as little as possible, Secondly, the key
   transactions on managed equipment should not be affected by the Get 
   and Get-Next operations on this equipment, Thirdly, the management 
   traffic between NMS and agent must be as little as possible, Finally
   , the algorithm must be self-adaptive and robust.

2.2.  Policy on Fault tolerance

   Since such MIB value as interface status and accounting bytes changes
   dynamically, the polling interval of these MOs must be reasonable.
   For example, the maximum value of actByts in the IP-Account-Table is
   32 power of 2 sub-1, notated as Value-max= power(2,32)-1. So the 
   algorithm should retrieve the actByts value before it overflows.  
   Generally, if the baud rate of an interface is V b/s, the least 
   overflowing time can be calculated as Tflow-min= (power(2,32)-1) 
   *8/V (s). Furthermore, the real value of a MO can be recovered from  
   Error.log in case it overflows.

2.3.  Policy on Self-adaptivity

   The algorithm adjusts retrieval interval self-adaptively, and this 
   adjustment is based on the accounting MO of Gauge Counter Type since 
   the actByts MIB may overflow. The policy is specified as follows. 
   
   



JinXiang,Zhang, et al.   Expires June 28, 2008                  [Page 4]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007


   Let Value[i-1] be the (i-1)th value and Tinter[i-1] be the interval 
   between (i-2)th and (i-1)th. And the first retrieval time is defined 
   as Tflow-min. Then Tinter[i], the ith retrieval interval, can be 
   calculated as two situations.
   
   (1)Tinter[i] = max { Tflow-min, delta* Tinter[i-1]* Value-max 
   / Value[i-1]}, If actByts MIB does not overflow
                    and i >= 2
   (2)Tinter[i]  = Tflow-min, otherwise 

   where delta is a balance factor to decrease the overflowing 
   probability.
   From the above expression, we can see that the interval to next 
   polling is determined by current value value[i-1].


   Now let us illustrate how to determine the value of delta (to 
   minimize the overflowing probability) using the following example.
   Consider a 100Mb/s interface. 
   The minimum overflowing time of the MO of Gauge Counter Type is.

   Tflow-min = (power(2,32)-1)*8/(100¡Ápower(10,6))=343s¡Ö0.095h.

   To minimize the overflowing probability of the MO of Gauge Counter
   Type when deciding the optimal  value of delta, we choose the 
   sampling hits in the intervals of MOs and evaluate the performance 
   when delta is 0.52, 0.54, 0.56, 0.58, 0.6, 0.618, 0.64, 0.66, 0.68 
   respectively.

   Firstly, let delta=0.52 and Tinter[i-1] =8.8 *Tflow-min, 9 *Tflow-min
   , 9.2 *Tflow-min, 9.4* Tflow-min, 9.6 *Tflow-min, 9.8* Tflow-min, 
   10 *Tflow-min respectively, we can calculate a group of Value[i]. 
   Secondly, calculate Tinter[i] using the self-adaptivity policy. 
   Thirdly, retrieve Value[i], and calculate the average value 
   Value-avr[i]of the group. We repeat the three steps as above, and 
   calculate the average value Value-avr[i] for other groups. Then we 
   found the probabilitly that overflows in next interval decreases 
   with delta, and the sampling frequency increases with delta. 
   Contrarily, the more probable overflowing of next time is, the less 
   the sampling frequency is. And we have found that the overflowing 
   probability is minimum when delta is 0.618, the golden mean factor.

   At the same time, in order to ensure that the key data would not
   overflow, we decide whether to use self adaptivity policy according 
   to the weight value. We denote the predefined threshold as "alarm". 
   If the weight value exceeds alarm, we retrieve the MIB data 
   immediately, and the self-adaptivity policy will not be used until 
   the weight value is equal to or less than the threshold.  So the 
   second part of our self-adaptivity policy is as follows: 



JinXiang,Zhang, et al.   Expires June 28, 2008                  [Page 5]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007

   (1)Retrieve MIB data timely, if Weight>= Alarm
   (2)Retrieve MIB data self adaptively,   otherwise

   Assume that the current time of NMS is T-sys, the next retrieval time
   Taccess[i] can be calculated as Taccess[i]= T-sys + Tinter[i].

   For example, with fixed interval Tinter[i-1]= Tflow-min, SIFD needs
   to retrieve MOs 11(1/Tflow-min) times in an hour. However, if
   Tinter[i-1]= Tflow-min =0.095h, Value[i-1]=1073741800, Tinter[i]=
   delta* Tinter[i-1]* Value-max /Value[i-1] =0.618*0.095*4=0.235h,SAA
   needs to retrieve MOs 5(1/1/ Tinter[i]) times in an hour. The
   retrieving frequency of SAA is 50% less than that of SIFD. 

   In addition, if Tinter[i-1] is a random value, Our experiments shows 
   that the minimum value of Tinter[i] is Tflow-min and the
   retrieving times of SAA is always less than that of SIFD.
   If the maximum value of actByts is 64 power of 2 sub 1, notated as 
   Value-max=(power(2,64)-1), we have similar conclusions by SAA.

   
2.4.  Policy on dynamical recognition status of object
   
   We define two configuration tables. One is called Tab-equip-all and 
   it is used to store all equipment information, the other is called 
   Tab-equip-active and it is used to store active equipment information
   . The active equipment is defined as follows.

   Def. 1.  An Active Equipment is one equipment that is operating
   regularly. The active equipment table consists of all active
   equipments in the network, and the active equipment table is notated 
   as Tab-equip-active. Each entry in Tab-equip-active is a quaternion
   notated as Rg , and Rg ={O-addr£¬O-oid£¬O-weight£¬O-stus }, where
   O-addr is IP address of the agent in charge of the MO, O-oid is the
   identifier of MO, such as DN or OID, O-weight is the weight value of 
   MO,O-stus is the status of MO. Moreover, the retrieval interval can 
   also be included in the table if necessary.

   The policy on dynamical recognition status of object is as follows.
   The algorithm only retrieves the MOs in Tab-equip-active, which 
   ensures that the sleeping managed equipment cannot be polled. 
   Nevertheless, New equipments or the equipments whose status are
   changed from sleeping to active should be added into Tab-equip-active
   table by the Event process. Finally, a MO should be deleted from 
   Tab-equip-active table if the agent of the MO does respond three 
   times.

   Moreover, as the storage space of MOs must be freed in certain time
   , the clearing frequency can also be decided by the self-adaptivity 
   policy.



JinXiang,Zhang, et al.   Expires June 28, 2008                  [Page 6]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007

2.5.  Description of SAA

   We define the data structure of SAA as follows.
   
   typedef struct _ObjStruct {  
   char    *name;
   int      type;
   int      oid_length;
   ObjectID oid[MAX_SUBID_LEN];
    } ObjStruct;  /*data structure for MIB*/
   typedef struct _InfoStruct {  
   char      IpAddress[30];    /*IP address of Agent*/
   ObjStruct  *obj;
   int       CriticlValue;  /*weight value*/
   bool      Status;      
   /*attribute status, initial value is 0, ie. sleeping*/
   int       Retrievalinterval;   
   /*current interval, initial value is Tflow-min */
   int       NextRetrievaltime;  
   /* next interval, initial value is Tflow-min */
   } InfoStruct;   
   /*data struct for Tab-equip-all and Tab-equip-active */

   SAA algorithm can be described as follows.

   begin
   copy all information in Tab-equip-all to Tab-equip-active, and 
   initialize a cyclic queue 
   initialize the retrieval time according to system time T-sys
   L:sort IP addr in Tab-equip-active in ascending order of Taccess[i]
   if empty_queue(Tab-equip-active) then
    exit("all the MOs in the network cannot be accessed")
   IPhead=Head_queue(Tab-equip-active), setup a Session between NMS and
      agent whose IP is IPhead
   if fail three times then 
      set status value to 0, delete the IPhead from the Tab-equip-active
       table, goto L
   retrieve all the relevant MIB information of the equipment
   if TYPE of the MO is Gauge Counter then
    begin 
     adjust Value[i-1], Tinter[i-1]and Weight 
     if IsFlow 
       then Tinter[i]= Tflow-min	
        else Tinter[i]= max{ Tflow-min, delta* Tinter[i-1]* Value-max 
                        / Value[i-1]}
    Taccess[i]= T-sys + Tinter[i]
    end
     else if TYPE of the MO is TABLE then 
            free the store space using self-adaptivity policy 
   store the MIB information in database, goto L
   end



JinXiang,Zhang, et al.   Expires June 28, 2008                  [Page 7]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007

   In the above description, empty_queue() is a BOOL function. The 
   function returns TRUE if the cyclic queue of Tab-equip-active is 
   empty, otherwise it returns FALSE. Head_queue() is a function used to
   get the head of Tab-equip-active queue and return 
   the IP address of the first element. IsFlow is a BOOL variable, whose
   initial value is FALSE, and its value is set to be TRUE when 
   overflowing.

3.  Group-Prefetching Algorithm

   Let us now consider another algorithm for management information 
   retrieval with the SNMP in NGI.  with " Group-Prefetching Algorithm "
   , many small managed objects are gathered into one prefetching group
    to be accessed using group prefetching schemes, objects of group 
   changed self-adaptively, fault tolerance etc., and thus can decrease 
   the retrieval frequency and network resource consumption without 
   alteration of SNMP.

3.1.  Description of problems

   The model of GPA is as follows, Let us assume that there are n MOs 
   in the charge of m agents, where n > m. With this algorithm, we will
   pick r small retrieving objects and put them into one prefetching 
   group to access according to the status attribute and time attribute,
   where r<n. all objects of the same group were updated as a kind and 
   all the objects only need a kind identifier to identify time 
   attribute. Moreover, the algorithm adjusts the number of objects and
   polling interval of next time based on the polling value, status and 
   weights of current polling results of n MOs. The status attribute 
   denotes the running status of the agent in charge of the object, and 
   its value is changed by the Event process, Time attribute represents 
   the time sensitivity of objects.

   The algorithm complies with the principles as follows, Firstly, 
   the objects are classified into several Categories according to time 
   attribute relevance, and the objects with similar time attributes 
   are adjusted into one prefetching group to access, in addition, the
   polling values of the objects are cached locally to decrease the 
   number of polling. Secondly, processing resources of NMS(Network 
   Management Station) occupied by the algorithm should be as few as 
   possible, thirdly, the management traffic between NMS and agent must 
   be as little as possible, lastly, the algorithm must be self-adaptive
   and robust.

3.2.  Policy of group prefetching

   According to the time attributes of managed objects, we classify 
   managed objects into three kinds as follows[3].



JinXiang,Zhang, et al.   Expires June 28, 2008                  [Page 8]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007

   The first category is R_Data£¨Real-Time_Data£©. It requires that the 
   attributes value of such managed objects should be collected on time 
   to indicate the most recent status of them, One example in this 
   category is the attributes value of actPkts objects which are used to
   account communications traffic in one network.

   The second category is N_Data£¨Not-Real-Time_Data£©. The attributes
   value of such managed objects is valid for a period after being 
   collected once, for example, the attributes value of a router
   information table, and the time interval can be chosen as 
   TTL( Time To Live£¬).

   The third category is I_Data£¨Irrespective-Time_Data£©. The 
   attributes value of such managed objects need not be refreshed after
   being collected once, for example, the attributes value of log or 
   system description of managed objects.

   According to time attributes of managed objects, each managed object
   needs an extra attribute to explain its time attribute when we define 
   the object using ASN.1 Macro. We use coding scheme for time attribute
   to diminish the additional overhead caused by the definition of time 
   attribute and make system extended. For N kinds of time attribute 
   only Log2N bits are needed in every managed object for specifying the
   time attribute. As we only adopt three kinds of objects, two bits in 
   a byte are enough to specify time attribute. That is.

   0(00)£ºR_Data £¬1(01)£ºN_Data £¬2(10)£ºI_Data.

   The other six bits are reserved to be used in future, such as group 
   identifier.

   The managed objects of R_Data are accessed by the discrete poll on 
   time, nevertheless, The managed objects of N_Data and I_Data are 
   suitable for group prefetching.

   Let S(cur_g) denote the aggregate of current access group 
   whose time attribute is S(cur_g).Tatt . Let any_o be an object 
   belonging to the group, and its TTL is any_o.TTL. if  we specify the 
   TTL of the group as S(cur_g).TTL, we have following result.

   S(cur_g).TTL =min{ any_o.TTL, where any_o is in S(cur_g) }£»  
                          if S(cur_g).Tattr ==1.

   S(cur_g).TTL =any value£»              
                           otherwise, if  S(cur_g).Tattr ==2.
  
   Here, the S(cur_g).TTL  of  N_Data group is the minimum 
   value of all TTL of the managed objects, nevertheless, the 
   S(cur_g).TTL  of  I_Data group can be any value.





JinXiang,Zhang, et al.   Expires June 28, 2008                  [Page 9]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007


                                   
      Thereinto, each managed object of N_Data and I_Data needs another 
   attributes, Timestamp, to indicate the system time when the managed 
   objects in this group were accessed the latest time. We use 
   cur_systime to indicate the current system time, and S(cur_g)Tstamp 
   to indicate the Timestamp of the group. Then we prefetche information
   of all managed objects in this group when any MO in this group is
   requested.

   Update value in cache and timestamp of MO; 
              if (cur_systime - S(cur_g).Tstamp ) >= S(cur_g).TTL.

   return value in cache;   
              otherwise.

   By grouping managed objects to cache and storing the attributes value
   of the managed objects locally, we reduce the overhead of network 
   management.

   For example, in a 100Mb/s interface network, the overhead of network 
   management, the packets include the packets used to obtain the IP 
   address of Sub_Manager/Agent and the packets of request/ response. 
   If there are 10 MOs that meet the needs of Group-Prefetching 
   condition, the packet numbers of SIFD is 22 while GPA is 14, the rate
   is 0.64. the packet number of Policy of group prefetching of GPA is 
   fewer than that of SIFD, only 0.64 times.

3.3.  Policy on extending MO of group self-adaptively

   The algorithm can adjust the retrieval interval and the number of MO
   in the group self-adaptively by using the self-adaptivity policy.

   We use S(all_g) to denote all the MOs in a network, any_o 
   indicate any MO in the network, any_o is in S(all_g) but does belong 
   to any group. and its RTT£¨Round Trip Time£©and time attribute are 
   any_o.RTT and any_o.Tatt respectively, S(cur_g).Count indicates the 
   number of MOs in S(cur_g).

   If any_o  is not in S(cur_g) and S(cur_g).Count < Max_gsize£¬then
     S(cur_g)= S(cur_g) + { any_o }£¬S(cur_g).TTL 
             =min{ S(cur_g).TTL£¬any_o.TTL }£»
                    If any_o.RTT <Alarm_Time and 
                       any_o.Tattr==S(cur_g).Tattr
     S(cur_g)£»          otherwise

   We compare the RTT of MO with predefined threshold -Alarm_Time, If 
   the Alarm_Time is larger than the value of RTT, we add the MO in the 
   group.
    

 

JinXiang,Zhang, et al.   Expires June 28, 2008                 [Page 10]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007


   Thereinto, Max_gsize is predefined maximum value of the number of MOs
   in any group.  Max_gsize is used to prevent group from being too big.
   
3.4.  Policy on shrinking MO of group self-adaptively

   If any_o is in S(cur_g)£¬then
      S(cur_g)= S(cur_g)-{ any_o }£» if any_o.RTT >= Alarm_Time 
      S(cur_g)£»                  otherwise

   We compare the RTT of the accessed MO with the predefined threshold 
   -Alarm_Time, If the the value of RTT  is larger than Alarm_Time, we 
   delete the MO from the group and access the MO discretely. And we 
   reuse GPA to access the MO when RTT reduce.

3.5.  Policy on dynamical recognition status of object

   We define two configuration tables, One is act_t,which is used to 
   store information of active equipments. The other is cur_t, which is 
   used to store equipment information of the MOs in current group . 
   With this algorithm, We only retrieves the MOs of group in act_t, 
   which ensures that the sleeping managed equipment can not be polled.

   If any_o is in S(cur_g)£¬then 
     S(cur_g)= S(cur_g)-{ any_o }£»  if any_o.id is not in act_t
     S(cur_g)£»                   otherwise

   Thereinto, any_o.id is the id of Agent in charge of any_o , and IP 
   address of agent represents its id. Nevertheless, New equipments or 
   equipments whose status are changed from sleeping to active can be 
   added to act_t by the Event process. Finally, a MO should be deleted 
   from act_t if the agent of the MO does not respond three times.

3.6.  Policy on fault tolerance

   if the equipment or NMS of one MO in a group is down and can not 
   response, the values of MOs are not correct. There are several 
   possible solutions. We can delete the MO from the group if NMS is 
   down, otherwise,Or we can access the MO again if the packets  are 
   lost owing to protocol. These events should be recorded in error.log 
   to recover the actual value of the MOs by NMS.

3.7.  Description of GPA

   At first, we define the data structure of GPA as follows.

   typedef struct _ObjStruct  { 
    	char         *name;
   	int           type;
    	int           oid_length;
    	ObjectID      oid[MAX_SUBID_LEN];



JinXiang,Zhang, et al.   Expires June 28, 2008                 [Page 11]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007


        unsigned char  Tattr;        /*time attribute*/
        int           RTT;        /*round trip time of access*/
        int           Group_label;  /*initial value is 0*/
             } ObjStruct;   /* data structure for MIB */
        typedef struct _InfoStruct  { 
    	ObjStruct      *obj;
        bool          Status;       /*status attribute*/
              } InfoStruct; /*data structure for element in S(cur_g) */


   GPA algorithm used to access a group of MOs can be described using 
   similar language as follows.

   begin
    if (cur_systime - S(cur_g).Tstamp )< S(cur_g).TTL
     return the value in cache
    else begin
     initialize a cyclic queue with elements in S(cur_g)
     reformed a request packet using all oid in S(cur_g)
     setup a Session between Sub_Manager and Agent
     if failure three times then 
        record the error information in Error.log£¬Exit
     if S(cur_g).Tattr =1 then 
                 S(cur_g).TTL =min{ any_o.TTL |any one of any_o in
                    S(cur_g) }£»  
     else if  S(cur_g).Tattr =2 then
                 S(cur_g).TTL =any value£»                          
     if (cur_systime - S(cur_g).Tstamp ) >= S(cur_g).TTL
      Update value in cache and timestamp of MO; 
      else return value in cache;
     If any_o is not in S(cur_g) and S(cur_g).Count < Max_gsize£¬then
     begin
       If any_o.RTT <Alarm_Time and any_o.Tattr= S(cur_g).Tattr then
         S(cur_g)= S(cur_g)+ { any_o }£¬S(cur_g).TTL =min{ S(cur_g).TTL,
          any_o.TTL }£»
        else S(cur_g) = S(cur_g)£»
     end
    If any_o is in S(cur_g)£¬then
    if any_o.RTT >= Alarm_Time then 
    S(cur_g)= S(cur_g)-{ any_o }£» 
     else S(cur_g) = S(cur_g);
    If any_o is in S(cur_g) then
    if any_o.id is not in act_t then
    S(cur_g)= S(cur_g)-{ any_o }£»  
     else S(cur_g) = S(cur_g);
    end
   write the information of MOs into database
   end


   
JinXiang,Zhang, et al.   Expires June 28, 2008                 [Page 12]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007


4.  Acknowledgements

   Some of the discussion about designing for IPV6 management came from
   private discussions with Jilong Wang, Changqin An, Hui Wang
   , and ZhongHui Li.
 
5.  Security Considerations

   This document is informational and provides guidelines for
   management information retrieval.  It introduces no new
   security concerns.

6.  References


   [1] Case, J., Fedor, M., Schoffstall, M., and J. Davin, Simple
       Network Management Protocol (SNMP), RFC 1157, SNMP Research,
       Performance Systems International, Performance Systems
       International, MIT Laboratory for Computer Science, May 1990
   
   [2]  M. Rose, K. McCloghrie, and J. Davin, Bulk Table Retrieval with 
        the SNMP, RFC 1187, SNMP Research, Performance Systems 
        International, Performance Systems International, MIT Laboratory
        for Computer Science October 1990

   [3]  Jayant, R., Haritsa, M.O., Nicholas, R., et al.MANDATE: Managing
        networks using database technology. Journal on Selected Areas in 
        communications, 1993, 11(9):1361~1372.     























JinXiang,Zhang, et al.   Expires June 28, 2008                 [Page 13]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007


Author's Address

   JinXiang Zhang
   Network research Center ,Tsinghua University P.R.China
   No.1 QingHua Yuan, Haidian district Beijing
   
   Phone: +86 10 62795818 ext 6128
   Fax:
   EMail: jxzhang@cernet.edu.cn
   URI:







































JinXiang,Zhang, et al.   Expires June 28, 2008                 [Page 14]

Internet-Draft   Retrieving MIB Information based on NGI  December 2007


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Acknowledgment

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).
   
   
   

JinXiang,Zhang, et al.   Expires June 28, 2008                 [Page 15]                                                                        
