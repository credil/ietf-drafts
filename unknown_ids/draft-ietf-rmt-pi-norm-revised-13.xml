<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-ietf-rmt-pi-norm-revised-13"
     ipr="pre5378Trust200902" obsoletes="3940">
  <front>
    <title abbrev="NORM Protocol">NACK-Oriented Reliable Multicast Transport
    Protocol</title>

    <author fullname="Brian Adamson" initials="B." surname="Adamson">
      <organization>Naval Research Laboratory</organization>

      <address>
        <postal>
          <street></street>

          <city>Washington</city>

          <region>DC</region>

          <code>20375</code>

          <country>USA</country>
        </postal>

        <email>adamson@itd.nrl.navy.mil</email>
      </address>
    </author>

    <author fullname="Carsten Bormann" initials="C." surname="Bormann">
      <organization>Universitaet Bremen TZI</organization>

      <address>
        <postal>
          <street>Postfach 330440</street>

          <city>D-28334 Bremen</city>

          <country>Germany</country>
        </postal>

        <email>cabo@tzi.org</email>
      </address>
    </author>

    <author fullname="Mark Handley" initials="M." surname="Handley">
      <organization>University College London</organization>

      <address>
        <postal>
          <street>Gower Street</street>

          <city>London</city>

          <code>WC1E 6BT</code>

          <country>UK</country>
        </postal>

        <email>M.Handley@cs.ucl.ac.uk</email>
      </address>
    </author>

    <author fullname="Joe Macker" initials="J." surname="Macker">
      <organization>Naval Research Laboratory</organization>

      <address>
        <postal>
          <street></street>

          <city>Washington</city>

          <region>DC</region>

          <code>20375</code>

          <country>USA</country>
        </postal>

        <email>macker@itd.nrl.navy.mil</email>
      </address>
    </author>

    <date day="3" month="June" year="2009" />

    <abstract>
      <t>This document describes the messages and procedures of the
      Negative-ACKnowledgment (NACK) Oriented Reliable Multicast (NORM)
      Protocol. This protocol can provide end-to-end reliable transport of
      bulk data objects or streams over generic IP multicast routing and
      forwarding services. NORM uses a selective, negative acknowledgment
      mechanism for transport reliability and offers additional protocol
      mechanisms to allow for operation with minimal <spanx style="emph">a priori</spanx>
      coordination among senders and receivers. A congestion control scheme is
      specified to allow the NORM protocol to fairly share available network
      bandwidth with other transport protocols such as Transmission Control
      Protocol (TCP). It is capable of operating with both reciprocal
      multicast routing among senders and receivers and with asymmetric
      connectivity (possibly a unicast return path) between the senders and
      receivers. The protocol offers a number of features to allow different
      types of applications or possibly other higher level transport protocols
      to utilize its service in different ways. The protocol leverages the use
      of FEC-based repair and other IETF Reliable Multicast Transport (RMT)
      building blocks in its design. This document obsoletes <xref
      format="none" target="RFC3940">RFC 3940</xref>.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction and Applicability">
      <t>The Negative-acknowledgment (NACK) Oriented Reliable Multicast (NORM)
      protocol can provide reliable transport of data from one or more
      sender(s) to a group of receivers over an IP multicast network. The
      primary design goals of NORM are to provide efficient, scalable, and
      robust bulk data (e.g., computer files, transmission of persistent data)
      transfer across possibly heterogeneous IP networks and topologies. The
      NORM protocol design provides support for distributed multicast session
      participation with minimal coordination among senders and receivers.
      NORM allows senders and receivers to dynamically join and leave
      multicast sessions at will with minimal overhead for control information
      and timing synchronization among participants. To accommodate this
      capability, NORM protocol message headers contain some common
      information allowing receivers to easily synchronize to senders
      throughout the lifetime of a reliable multicast session. NORM is
      self-adapting to a wide range of dynamic network conditions with little
      or no pre-configuration. The protocol is tolerant of inaccurate timing
      estimations or lossy conditions that can occur in many networks
      including mobile and wireless. The protocol can also converge and
      maintain efficient operation even in situations of heavy packet loss and
      large queuing or transmission delays. This document obsoletes the
      Experimental <xref format="none" target="RFC3940">RFC 3940</xref>
      specification.</t>

      <t>This document is a product of the IETF RMT working group and follows
      the guidelines provided in the <xref target="RFC3269">Author Guidelines
      for Reliable Multicast Transport (RMT) Building Blocks and Protocol
      Instantiation documents</xref>.</t>

      <t><spanx style="strong">Statement of Intent</spanx></t>

      <t>This memo contains the definitions necessary to fully specify a
      Reliable Multicast Transport protocol in accordance with the criteria of
      <xref target="RFC2357">IETF Criteria for Evaluating Reliable Multicast
      Transport and Application Protocols</xref>. The NORM specification
      described in this document was previously published in the "Experimental
      Category" <xref target="RFC3940"></xref>. It was the stated intent of
      the RMT working group to re-submit this specifications as an IETF
      Proposed Standard in due course. This Proposed Standard specification is
      thus based on RFC 3940 and has been updated according to accumulated
      experience and growing protocol maturity since the publication of RFC
      3940. Said experience applies both to this specification itself and to
      congestion control strategies related to the use of this specification.
      The differences between RFC 3940 and this document are listed in <xref
      target="ProtocolChanges"></xref>.</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119">RFC 2119</xref>.</t>
      </section>

      <section title="NORM Data Delivery Service Model">
        <t>A NORM protocol instance (<spanx style="emph">NormSession</spanx>)
        is defined within the context of participants communicating
        connectionless (e.g., Internet Protocol (IP) or User Datagram Protocol
        (UDP)) packets over a network using pre-determined addresses and host
        port numbers. Generally, the participants exchange packets using an IP
        multicast group address, but unicast transport MAY also be established
        or applied as an adjunct to multicast delivery. In the case of
        multicast, the participating <spanx style="emph">NormNodes</spanx>
        will communicate using a common IP multicast group address and port
        number chosen via means outside the context of the given <spanx
        style="emph">NormSession</spanx>. Other existing IETF data format and
        protocol standards MAY be applied to describe and convey the necessary
        <spanx style="emph">a priori</spanx> information for a specific <spanx
        style="emph">NormSession</spanx> (e.g., <xref target="RFC4566">Session
        Description Protocol (SDP) </xref>, <xref target="RFC2974">Session
        Announcement Protocol (SAP)</xref>, etc.).</t>

        <t>The NORM protocol design is principally driven by the assumption of
        a single sender transmitting bulk data content to a group of
        receivers. However, the protocol MAY operate with multiple senders
        within the context of a single <spanx style="emph">NormSession</spanx>.
        In initial implementations of this protocol, it is anticipated
        multiple senders will transmit independent of one another and
        receivers will maintain state as necessary for each sender. In future
        versions of NORM, it is possible some aspects of protocol operation
        (e.g., round-trip time collection) will provide for alternate modes
        allowing more efficient performance for applications requiring
        multiple senders.</t>

        <t>NORM provides for three types of bulk data content objects (<spanx
        style="emph">NormObjects</spanx>) to be reliably transported. These
        types include:</t>

        <t><list style="numbers">
            <t>static computer memory data content (<spanx style="verb">NORM_OBJECT_DATA</spanx>
            type),</t>

            <t>computer storage files (<spanx style="verb">NORM_OBJECT_FILE</spanx>
            type), and</t>

            <t>non-finite streams of continuous data content (<spanx
            style="verb">NORM_OBJECT_STREAM</spanx> type).</t>
          </list></t>

        <t>The distinction between <spanx style="verb">NORM_OBJECT_DATA</spanx>
        and <spanx style="verb">NORM_OBJECT_FILE</spanx> is simply to provide
        a hint to receivers in <spanx style="emph">NormSessions</spanx>
        serving multiple types of content as to what type of storage to
        allocate for received content (i.e., memory or file storage). Other
        than that distinction, the two are identical, providing for reliable
        transport of finite (but potentially very large) units of content.
        These static data and file services are anticipated to be useful for
        multicast-based cache applications with the ability to reliably
        provide transmission of large quantities of static data. Other types
        of static data/file delivery services might make use of these
        transport object types, too. The use of the <spanx style="verb">NORM_OBJECT_STREAM</spanx>
        type is at the application's discretion and could be used to carry
        static data or file content also. The NORM reliable stream service
        opens up additional possibilities such as serialized reliable
        messaging or other unbounded, perhaps dynamically produced content.
        The <spanx style="verb">NORM_OBJECT_STREAM</spanx> provides for
        reliable transport analogous to that of the Transmission Control
        Protocol (TCP), although NORM receivers will be able to begin
        receiving stream content at any point in time. The applicability of
        this feature will depend upon the application.</t>

        <t>The NORM protocol also allows for a small amount of out-of-band
        data (sent as <spanx style="verb">NORM_INFO</spanx> messages) to be
        attached to the data content objects transmitted by the sender. This
        readily-available out-of-band data allows multicast receivers to
        quickly and efficiently determine the nature of the corresponding
        data, file, or stream bulk content being transmitted. This allows
        application-level control of the receiver node's participation in the
        current transport activity. This also allows the protocol to be
        flexible with minimal pre-coordination among senders and receivers.
        The <spanx style="verb">NORM_INFO</spanx> content is atomic in that
        its size MUST fit into the payload portion of a single NORM
        message.</t>

        <t>NORM does NOT provide for global or application-level
        identification of data content within in its message headers. Note the
        <spanx style="verb">NORM_INFO</spanx> out-of-band data mechanism can
        be leveraged by the application for this purpose if desired, or
        identification can alternatively be embedded within the data content.
        NORM does identify transmitted content (<spanx style="emph">NormObjects</spanx>)
        with transport identifiers that are applicable only while the sender
        is transmitting and/or repairing the given object. These transport
        data content identifiers (<spanx style="emph">NormTransportIds</spanx>)
        are assigned in a monotonically increasing fashion by each NORM sender
        during the course of a <spanx style="emph">NormSession</spanx>.
        Participants, including senders, in NORM protocol sessions are also
        identified with unique identifiers (<spanx style="emph">NormNodeId</spanx>s).
        Each sender maintains its <spanx style="emph">NormTransportId</spanx>
        assignments independently and thus individual <spanx style="emph">NormObjects</spanx>
        can be uniquely identified during transport by concatenation of the
        session-unique sender identifier (<spanx style="emph">NormNodeId</spanx>)
        and the assigned <spanx style="emph">NormTransportId</spanx>. The
        <spanx style="emph">NormTransportId</spanx>s are assigned from a
        large, but fixed, numeric space in increasing order and will be
        reassigned during long-lived sessions. The NORM protocol provides
        mechanisms so the sender application can terminate transmission of
        data content and inform the group of this in an efficient manner.
        Other similar protocol control mechanisms (e.g., session termination,
        receiver synchronization, etc.) are specified so reliable multicast
        application variants can realize different, complete bulk transfer
        communication models to meet their goals.</t>

        <t>To summarize, the NORM protocol provides reliable transport of
        different types of data content (including potentially mixed types).
        The senders enqueue and transmit bulk content in the form of static
        data or files and/or non-finite, ongoing stream types. NORM senders
        provide for repair transmission of data and/or FEC content in response
        to NACK messages received from the receiver group. Mechanisms for
        out-of-band information and other transport control mechanisms are
        specified for use by applications to form complete reliable multicast
        solutions for different purposes.</t>
      </section>

      <section title="NORM Scalability">
        <t>Group communication scalability requirements lead to adaptation of
        negative acknowledgment (NACK) based protocol schemes when feedback
        for reliability is needed <xref target="RmComparison"></xref>. NORM is
        a protocol centered around the use of selective NACKs to request
        repairs of missing data. NORM provides for the use of packet-level
        forward error correction (FEC) techniques for efficient multicast
        repair and OPTIONAL proactive transmission robustness <xref
        target="RFC3453"></xref>. FEC-based repair can be used to greatly
        reduce the quantity of reliable multicast repair requests and repair
        transmissions <xref target="MdpToolkit"></xref> in a NACK-oriented
        protocol. The principal factor in NORM scalability is the volume of
        feedback traffic generated by the receiver set to facilitate
        reliability and congestion control. NORM uses probabilistic
        suppression of redundant feedback based on exponentially distributed
        random backoff timers. The performance of this type of suppression
        relative to other techniques is described in <xref
        target="McastFeedback"></xref>. NORM dynamically measures the group's
        round-trip timing status to set its suppression and other protocol
        timers. This allows NORM to scale well while maintaining reliable data
        delivery transport with low latency relative to the network topology
        over which it is operating.</t>

        <t>Feedback messages can be either multicast to the group at large or
        sent via unicast routing to the sender. In the case of unicast
        feedback, the sender relays the feedback state to the group to
        facilitate feedback suppression. In typical Internet environments, the
        NORM protocol will readily scale to group sizes on the order of tens
        of thousands of receivers. A study of the quantity of feedback for
        this type of protocol is described in <xref
        target="NormFeedback"></xref>. NORM is able to operate with a smaller
        amount of feedback than a single TCP connection, even with relatively
        large numbers of receivers. Thus, depending upon the network topology,
        it is possible for NORM to scale to larger group sizes. With respect
        to computer resource usage, the NORM protocol does not need state to
        be kept on all receivers in the group. NORM senders maintain state
        only for receivers providing explicit congestion control feedback.
        However, NORM receivers need to maintain state for each active sender.
        This can constrain the number of simultaneous senders in some uses of
        NORM.</t>
      </section>

      <section title="Environmental Requirements and Considerations">
        <t>All of the environmental requirements and considerations that apply
        to the <xref target="RFC5401">Multicast NACK Building Block</xref>,
        <xref target="RFC5052">FEC Building Block</xref>, and <xref
        target="RFC4654">TCP-Friendly Multicast Congestion Control (TFMCC)
        Building Block</xref> also apply to the NORM protocol.</t>

        <t>The NORM protocol SHALL be capable of operating in an end-to-end
        fashion with no assistance from intermediate systems beyond basic IP
        multicast group management, routing, and forwarding services. While
        the techniques utilized in NORM are principally applicable to flat,
        end-to-end IP multicast topologies, they could also be applied in the
        sub-levels of hierarchical (e.g., tree-based) multicast distribution
        if so desired. NORM can make use of reciprocal (among senders and
        receivers) multicast communication under the Any-Source Multicast
        (ASM) model defined in <xref target="RFC1112">Host Extensions for IP
        Multicasting</xref>, but SHALL also be capable of scalable operation
        in asymmetric topologies such as <xref
        target="RFC4607">Source-Specific Multicast (SSM)</xref> where only
        unicast routing service is available from the receivers to the
        sender(s).</t>

        <t>NORM is compatible with IPv4 and IPv6. Additionally, NORM can be
        used with networks employing Network Address Translation (NAT)
        providing the NAT device supports IP multicast and/or can cache UDP
        traffic source port numbers for remapping feedback traffic from
        receivers to the sender(s).</t>
      </section>
    </section>

    <section title="Architecture Definition">
      <t>A <spanx style="emph">NormSession</spanx> is comprised of
      participants (<spanx style="emph">NormNodes</spanx>) acting as senders
      and/or receivers. NORM senders transmit data content in the form of
      <spanx style="emph">NormObjects</spanx> to the session destination
      address and the NORM receivers attempt to reliably receive the
      transmitted content using negative acknowledgments to request repair.
      Each <spanx style="emph">NormNode</spanx> within a <spanx style="emph">NormSession</spanx>
      is assumed to have a preselected unique 32-bit identifier (<spanx
      style="emph">NormNodeId</spanx>). <spanx style="emph">NormNodes</spanx>
      MUST have uniquely assigned identifiers within a single <spanx
      style="emph">NormSession</spanx> to distinguish between possible
      multiple senders and to distinguish feedback information from different
      receivers. There are two reserved <spanx style="emph">NormNodeId</spanx>
      values. A value of <spanx style="verb">0x00000000</spanx> is considered
      an invalid <spanx style="emph">NormNodeId</spanx> (<spanx style="verb">NORM_NODE_NONE</spanx>)
      and a value of <spanx style="verb">0xffffffff</spanx> is a "wild card"
      <spanx style="emph">NormNodeId</spanx> (<spanx style="verb">NORM_NODE_ANY</spanx>).
      While the protocol does not preclude multiple sender nodes concurrently
      transmitting within the context of a single NORM session (i.e., many-
      to-many operation), any type of interactive coordination among NORM
      senders is assumed to be controlled by the application or higher
      protocol layer. There are some OPTIONAL mechanisms specified in this
      document that can be leveraged for such application layer
      coordination.</t>

      <t>As previously noted, NORM allows for reliable transmission of three
      different basic types of data content. The first type is <spanx
      style="verb">NORM_OBJECT_DATA</spanx>, that is used for static,
      persistent blocks of data content maintained in the sender's application
      memory storage. The second type is <spanx style="verb">NORM_OBJECT_FILE</spanx>,
      that corresponds to data stored in the sender's non-volatile file
      system. The <spanx style="verb">NORM_OBJECT_DATA</spanx> and <spanx
      style="verb">NORM_OBJECT_FILE</spanx> types both represent <spanx
      style="emph">NormObjects</spanx> of finite but potentially very large
      size. The third type of data content is <spanx style="verb">NORM_OBJECT_STREAM</spanx>,
      that corresponds to an ongoing transmission of undefined length. This is
      analogous to the reliable stream service provide by TCP for unicast data
      transport. The format of the stream content is application-defined and
      can be "byte" or "message" oriented. The NORM protocol provides for
      "flushing" of the stream to expedite delivery or possibly enforce
      application message boundaries. NORM protocol implementations MAY offer
      either (or both) in-order delivery of the stream data to the receive
      application or out-of-order (more immediate) delivery of received
      segments of the stream to the receiver application. In either case, NORM
      sender and receiver implementations provide buffering to facilitate
      repair of the stream as it is transported.</t>

      <t>All <spanx style="emph">NormObjects</spanx> are logically segmented
      into FEC coding blocks and symbols for transmission by the sender. In
      NORM, an FEC encoding symbol directly corresponds to the payload of
      <spanx style="verb">NORM_DATA</spanx> messages or "segment". Note that
      when systematic FEC codes are used, the payload of <spanx style="verb">NORM_DATA</spanx>
      messages sent for the first portion of a FEC encoding block are source
      symbols (actual segments of original user data), while the remaining
      symbols for the block consist of parity symbols generated by FEC
      encoding. These parity symbols are generally sent in response to repair
      requests, but some number MAY be sent proactively at the end each
      encoding block to increase the robustness of transmission. When
      non-systematic FEC codes are used, all symbols sent consist of FEC
      encoding parity content. In this case, the receiver needs to receive a
      sufficient number of symbols to reconstruct (via FEC decoding) the
      original user data for the given block.</t>

      <t>Transmitted <spanx style="emph">NormObjects</spanx> are temporarily
      yet uniquely identified within the <spanx style="emph">NormSession</spanx>
      context using the given sender's <spanx style="emph">NormNodeId</spanx>,
      <spanx style="emph">NormInstanceId</spanx>, and a temporary <spanx
      style="emph">NormTransportId</spanx>. Depending upon the implementation,
      individual NORM senders can manage their <spanx style="emph">NormInstanceIds</spanx>
      independently, or a common <spanx style="emph">NormInstanceId</spanx>
      could be agreed upon for all participating nodes within a session if
      needed as a session identifier. NORM <spanx style="emph">NormTransportId</spanx>
      data content identifiers are sender-assigned and applicable and valid
      only during a <spanx style="emph">NormObject</spanx>'s actual transport
      (i.e., for as long as the sender is transmitting and providing repair of
      the indicated <spanx style="emph">NormObject</spanx>). For a long-lived
      session, the <spanx style="emph">NormTransportId</spanx> field can wrap
      and previously-used identifiers will be re-used. Note that globally
      unique identification of transported data content is not provided by
      NORM and, if necessary, is expected to be managed by the NORM
      application. The individual segments or symbols of the <spanx
      style="emph">NormObject</spanx> are further identified with FEC payload
      identifiers that include coding block and symbol identifiers. These are
      discussed in detail later in this document.</t>

      <section anchor="ProtocolOverview" title="Protocol Operation Overview">
        <t>A NORM sender primarily generates messages of type <spanx
        style="verb">NORM_DATA</spanx>. These messages carry original data
        segments or FEC symbols and repair segments/symbols for the bulk
        data/file or stream <spanx style="emph">NormObjects</spanx> being
        transferred. By default, redundant FEC symbols are sent only in
        response to receiver repair requests (NACKs) and thus normally little
        or no additional transmission overhead is imposed due to FEC encoding.
        However, the NORM implementation MAY be configured to proactively
        transmit some amount of redundant FEC symbols along with the original
        content to potentially enhance performance (e.g., improved delay) at
        the cost of additional transmission overhead. This configuration is
        sensible for certain network conditions and can allow for robust,
        asymmetric multicast (e.g., unidirectional routing, satellite, cable)
        <xref target="FecHybrid"></xref> with reduced receiver feedback, or,
        in some cases, no feedback.</t>

        <t>A sender message of type <spanx style="verb">NORM_INFO</spanx> is
        also defined and is used to carry OPTIONAL out-of-band context
        information for a given transport object. A single <spanx
        style="verb">NORM_INFO</spanx> message can be associated with a <spanx
        style="emph">NormObject</spanx>. Because of its atomic nature, missing
        <spanx style="verb">NORM_INFO</spanx> messages can be NACKed and
        repaired with a slightly lower delay process than NORM's general
        FEC-encoded data content. The <spanx style="verb">NORM_INFO</spanx>
        message can serve special purposes for some bulk transfer, reliable
        multicast applications where receivers join the group mid-stream and
        need to ascertain contextual information on the current content being
        transmitted. The NACK process for <spanx style="verb">NORM_INFO</spanx>
        will be described later. When the <spanx style="verb">NORM_INFO</spanx>
        message type is used, its transmission SHOULD precede transmission of
        any <spanx style="verb">NORM_DATA</spanx> message for the associated
        <spanx style="emph">NormObject</spanx>.</t>

        <t>The sender also generates messages of type <spanx style="verb">NORM_CMD</spanx>
        to assist in certain protocol operations such as congestion control,
        end-of-transmission flushing, group round trip time (GRTT) estimation,
        receiver synchronization, and OPTIONAL positive acknowledgment
        requests or application defined commands. The transmission of <spanx
        style="verb">NORM_CMD</spanx> messages from the sender is accomplished
        by one of three different procedures. These procedures are: single,
        best effort unreliable transmission of the command; repeated redundant
        transmissions of the command; and positively-acknowledged commands.
        The transmission technique used for a given command depends upon the
        function of the command. Several core commands are defined for basic
        protocol operation. Additionally, implementations MAY wish to consider
        providing the OPTIONAL application-defined commands that can take
        advantage of the transmission methodologies available for commands.
        This allows for application-level session management mechanisms that
        can make use of information available to the underlying NORM protocol
        engine (e.g., round-trip timing, transmission rate, etc.). A notable
        distinction between <spanx style="verb">NORM_DATA</spanx> message and
        some <spanx style="verb">NORM_CMD</spanx> message transmissions is
        that typically a receiver will need to allocate resources to manage
        reliable reception when <spanx style="verb">NORM_DATA</spanx> messages
        are received. However some <spanx style="verb">NORM_CMD</spanx>
        messages are completely atomic and no specific reliability (buffering)
        state needs to be kept. Thus, for session management or other purposes
        it is possible that even participants acting principally as data
        receivers MAY transmit <spanx style="verb">NORM_CMD</spanx> messages.
        However, it is RECOMMENDED that this is not done within the context of
        the NORM multicast session unless congestion control is addressed. For
        example, many receiver nodes transmitting <spanx style="verb">NORM_CMD</spanx>
        messages simultaneously can cause congestion for the
        destination(s).</t>

        <t>All sender transmissions are subject to rate control governed by a
        peak transmission rate set for each participant by the application.
        This can be used to limit the quantity of multicast data transmitted
        by the group. When NORM's congestion control algorithm is enabled the
        rate for senders is automatically adjusted. In some networks, it is
        desirable to establish minimum and maximum bounds for the rate
        adjustment depending upon the application even when dynamic congestion
        control is enabled. However, in the case of the general Internet,
        congestion control policy SHALL be observed that is compatible with
        coexistent TCP flows.</t>

        <t>NORM receivers generate messages of type <spanx style="verb">NORM_NACK</spanx>
        or <spanx style="verb">NORM_ACK</spanx> in response to transmissions
        of data and commands from a sender. The <spanx style="verb">NORM_NACK</spanx>
        messages are generated to request repair of detected data transmission
        losses. Receivers generally detect losses by tracking the sequence of
        transmission from a sender. Sequencing information is embedded in the
        transmitted data packets and end-of-transmission commands from the
        sender. <spanx style="verb">NORM_ACK</spanx> messages are generated in
        response to certain commands transmitted by the sender. In the general
        (and most scalable) protocol mode, <spanx style="verb">NORM_ACK</spanx>
        messages are sent only in response to congestion control commands from
        the sender. The feedback volume of these congestion control <spanx
        style="verb">NORM_ACK</spanx> messages is controlled using the same
        timer-based probabilistic suppression techniques as for <spanx
        style="verb">NORM_NACK</spanx> messages to avoid feedback implosion.
        In order to meet potential application requirements for positive
        acknowledgment from receivers, other <spanx style="verb">NORM_ACK</spanx>
        messages are defined and available for use.</t>
      </section>

      <section title="Protocol Building Blocks">
        <t>The operation of the NORM protocol is based primarily upon the
        concepts presented in the <xref target="RFC5401">Multicast NACK
        Building Block</xref> document. This includes the basic NORM
        architecture and the data transmission, repair, and feedback
        strategies discussed in that document. The reliable multicast building
        block approach, as described in <xref target="RFC3048">Reliable
        Multicast Transport Building Blocks for One-to-Many Bulk-Data
        Transfer</xref>, is applied in creating the full NORM protocol
        instantiation. NORM also makes use of the parity-based encoding
        techniques for repair messaging and added transmission robustness as
        described in <xref target="RFC3453">The Use of Forward Error
        Correction (FEC) in Reliable Multicast</xref>. NORM uses the FEC
        Payload ID as specified by the <xref target="RFC5052">FEC Building
        Block document </xref>. Additionally, for congestion control, this
        document fully specifies a baseline congestion control mechanism
        (NORM-CC) based on the TCP-Friendly Multicast Congestion Control
        (TFMCC) scheme<xref target="TfmccPaper"></xref>, <xref
        target="RFC4654"></xref>.</t>
      </section>

      <section title="Design Tradeoffs">
        <t>While the various features of NORM provide some measure of general
        purpose utility, it is important to emphasize the understanding that
        "no one size fits all" in the reliable multicast transport arena.
        There are numerous engineering trade-offs involved in reliable
        multicast transport design and this necessitates an increased
        awareness of application and network architecture considerations.
        Performance requirements affecting design can include: group size,
        heterogeneity (e.g., capacity and/or delay), asymmetric delivery, data
        ordering, delivery delay, group dynamics, mobility, congestion
        control, and transport across low capacity connections. NORM contains
        various parameters to accommodate many of these differing
        requirements. The NORM protocol and its mechanisms MAY be applied in
        multicast applications outside of bulk data transfer, but there is an
        assumed model of bulk transfer transport service that drives the
        trade-offs that determine the scalability and performance described in
        this document.</t>

        <t>The ability of NORM to provide reliable data delivery is also
        governed by any buffer constraints of the sender and receiver
        applications. NORM protocol implementations SHOULD operate with the
        greatest efficiency and robustness possible within application-defined
        buffer constraints. Buffer requirements for reliability, as always,
        are a function of the delay-bandwidth product of the network topology.
        NORM performs best when allowed more buffering resources than typical
        point-to-point transport protocols. This is because NORM feedback
        suppression is based upon randomly-delayed transmissions from the
        receiver set, rather than immediately transmitted feedback. There are
        definitive trade-offs between buffer utilization, group size
        scalability, and efficiency of performance. Large buffer sizes allow
        the NORM protocol to perform most efficiently in large delay-bandwidth
        topologies and allow for longer feedback suppression backoff timeouts.
        This yields improved group size scalability. NORM can operate with
        reduced buffering but at a cost of decreased efficiency (lower
        relative goodput) and reduced group size scalability.</t>
      </section>
    </section>

    <section title="Conformance Statement">
      <t>This RMT Protocol Instantiation document, in conjunction with the
      <xref target="RFC5401">Multicast Negative-Acknowledgment (NACK)</xref>
      and <xref target="RFC5052">Forward Error Correction (FEC)</xref>
      Building Blocks, completely specifies a working reliable multicast
      transport protocol that conforms to the requirements described in <xref
      format="none" target="RFC2357">RFC 2357</xref>.</t>

      <t>This document specifies the following message types and mechanisms
      that are REQUIRED in complying NORM protocol implementations:</t>

      <texttable align="center">
        <ttcol width="25%">Message Type</ttcol>

        <ttcol width="75%">Purpose</ttcol>

        <c><spanx style="verb">NORM_DATA</spanx></c>

        <c>Sender message for application data transmission. Implementations
        MUST support at least one of the <spanx style="verb">NORM_OBJECT_DATA</spanx>,
        <spanx style="verb">NORM_OBJECT_FILE</spanx>, or <spanx style="verb">NORM_OBJECT_STREAM</spanx>
        delivery services. The use of the NORM FEC Object Transmission
        Information header extension is OPTIONAL with <spanx style="verb">NORM_DATA</spanx>
        messages.</c>

        <c><spanx style="verb">NORM_CMD(FLUSH)</spanx></c>

        <c>Sender command to excite receivers for repair requests in lieu of
        ongoing <spanx style="verb">NORM_DATA</spanx> transmissions. Note the
        use of the <spanx style="verb">NORM_CMD(FLUSH)</spanx> for positive
        acknowledgment of data receipt is OPTIONAL.</c>

        <c><spanx style="verb">NORM_CMD(SQUELCH)</spanx></c>

        <c>Sender command to advertise its current valid repair window in
        response to invalid requests for repair.</c>

        <c><spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx></c>

        <c>Sender command to advertise current repair (and congestion control
        state) to group when unicast feedback messages are detected. Used to
        control/suppress excessive receiver feedback in asymmetric multicast
        topologies.</c>

        <c><spanx style="verb">NORM_CMD(CC)</spanx></c>

        <c>Sender command used in collection of round trip timing and
        congestion control status from group (this is OPTIONAL if alternative
        congestion control mechanism and round trip timing collection is
        used).</c>

        <c><spanx style="verb">NORM_NACK</spanx></c>

        <c>Receiver message used to request repair of missing transmitted
        content.</c>

        <c><spanx style="verb">NORM_ACK</spanx></c>

        <c>Receiver message used to proactively provide feedback for
        congestion control purposes. Also used with the OPTIONAL NORM Positive
        Acknowledgment Process.</c>
      </texttable>

      <t>This document also describes the following message types and
      associated mechanisms that are OPTIONAL for complying NORM protocol
      implementations:</t>

      <texttable align="center">
        <ttcol width="25%">Message Type</ttcol>

        <ttcol>Purpose</ttcol>

        <c><spanx style="verb">NORM_INFO</spanx></c>

        <c>Sender message for providing ancillary context information
        associated with NORM transport objects. The use of the NORM FEC Object
        Transmission Information header extension is OPTIONAL with <spanx
        style="verb">NORM_INFO</spanx> messages.</c>

        <c><spanx style="verb">NORM_CMD(EOT)</spanx></c>

        <c>Sender command to indicate it has reached end-of-transmission and
        will no longer respond to repair requests.</c>

        <c><spanx style="verb">NORM_CMD(ACK_REQ)</spanx></c>

        <c>Sender command to support application-defined, positively
        acknowledged commands sent outside of the context of the bulk data
        content being transmitted. The NORM Positive Acknowledgment Procedure
        associated with this message type is OPTIONAL.</c>

        <c><spanx style="verb">NORM_CMD(APPLICATION)</spanx></c>

        <c>Sender command containing application-defined commands sent outside
        of the context of the bulk data content being transmitted.</c>

        <c><spanx style="verb">NORM_REPORT</spanx></c>

        <c>Optional message type reserved for experimental implementations of
        the NORM protocol.</c>
      </texttable>
    </section>

    <section title="Message Formats">
      <t>There are two primary classes of NORM messages (see <xref
      target="ProtocolOverview"></xref>): sender messages and receiver
      messages. <spanx style="verb">NORM_CMD</spanx>, <spanx style="verb">NORM_INFO</spanx>,
      and <spanx style="verb">NORM_DATA</spanx> message types are generated by
      senders of data content, and <spanx style="verb">NORM_NACK</spanx> and
      <spanx style="verb">NORM_ACK</spanx> messages generated by receivers
      within a <spanx style="emph">NormSession</spanx>. Sender messages SHALL
      be governed by congestion control for Internet use. For session
      management or other purposes, receivers can also employ <spanx
      style="verb">NORM_CMD</spanx> message transmissions. The principal
      rationale for distinguishing sender and receiver messages is that
      receivers will typically need to allocate resources to support reliable
      reception from sender(s) and NORM sender messages are subject to
      congestion control. NORM receivers MAY employ the <spanx style="verb">NORM_CMD</spanx>
      message type for application-defined purposes but it is RECOMMENDED that
      congestion control and feedback implosion issues be addressed.
      Additionally, an auxiliary message type of <spanx style="verb">NORM_REPORT</spanx>
      is also provided for experimental purposes. This section describes the
      message formats used by the NORM protocol. These messages and their
      fields are referenced in the detailed functional description of the NORM
      protocol given in <xref target="ProtocolDetails"></xref>. Individual
      NORM messages are compatible with the Maximum Transmission Unit (MTU)
      limitations of encapsulating Internet protocols including IPv4, IPv6,
      and UDP. The current NORM protocol specification assumes UDP
      encapsulation and leverages the transport features of UDP. The NORM
      messages are independent of network addresses and can be used in IPv4
      and IPv6 networks.</t>

      <section anchor="CommonHeader"
               title="NORM Common Message Header and Extensions">
        <t>There are some common message fields contained in all NORM message
        types. Additionally, a header extension mechanism is defined to expand
        the functionality of the NORM protocol without revision to this
        document. All NORM protocol messages begin with a common header with
        information fields as follows:</t>

        <figure align="center" title="NORM Common Message Header Format">
          <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version|  type |    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
        </figure>

        <t>The "version" field is a 4-bit value indicating the protocol
        version number. NORM implementations SHOULD ignore received messages
        with version numbers different from their own. This number is intended
        to indicate and distinguish upgrades of the protocol that are
        non-interoperable. The NORM version number for this specification is
        1.</t>

        <t>The message "type" field is a 4-bit value indicating the NORM
        protocol message type. These types are defined as follows:</t>

        <texttable align="center">
          <ttcol width="25%">Message</ttcol>

          <ttcol align="center" width="25%">Value</ttcol>

          <c><spanx style="verb">NORM_INFO</spanx></c>

          <c>1</c>

          <c><spanx style="verb">NORM_DATA</spanx></c>

          <c>2</c>

          <c><spanx style="verb">NORM_CMD</spanx></c>

          <c>3</c>

          <c><spanx style="verb">NORM_NACK</spanx></c>

          <c>4</c>

          <c><spanx style="verb">NORM_ACK</spanx></c>

          <c>5</c>

          <c><spanx style="verb">NORM_REPORT</spanx></c>

          <c>6</c>
        </texttable>

        <t>The 8-bit "hdr_len" field indicates the number of 32-bit words that
        comprise the given message's header portion. This is used to
        facilitate addition of header extensions. The presence of header
        extensions are implied when the "hdr_len" value is greater than the
        base value for the given message "type".</t>

        <t>The "sequence" field is a 16-bit value that is set by the message
        originator. The "sequence" field serves two separate purposes,
        depending upon the message type:<list style="numbers">
            <t>NORM senders MUST set the "sequence" field of sender messages
            (<spanx style="verb">NORM_INFO</spanx>, <spanx style="verb">NORM_DATA</spanx>,
            and <spanx style="verb">NORM_CMD</spanx>) so that receivers can
            monitor the "sequence" value to maintain an estimate of packet
            loss that can be used for congestion control purposes (See <xref
            target="CongestionControl"></xref> for a detailed description of
            NORM Congestion Control operation). A monotonically-increasing
            sequence number space MUST be maintained to mark NORM sender
            messages in this way. Note that this "sequence" number is
            explicitly NOT used in NORM as part of its reliability procedures.
            The NORM object and FEC payload identifiers are used to detect
            missing content for reliable transfer purposes.</t>

            <t>NORM receivers SHOULD set the "sequence" field to support
            protection from message replay attacks of <spanx style="verb">NORM_NACK</spanx>
            or <spanx style="verb">NORM_NACK</spanx> messages. Note that,
            depending upon configuration, NORM feedback messages are sent to
            the session multicast address or the unicast address[es] of the
            active NORM sender[s]. Thus, a separate, monotonically-increasing
            sequence number space MUST be maintained for each destination
            address to which the NORM receiver is transmitting feedback
            messages.</t>
          </list></t>

        <t>Note that these two separate purposes necessitate the maintenance
        of separate sequence spaces to support the functions described here.
        And, in the case of NORM receivers, additional sequence spaces are
        needed when feedback messages are sent to the sender unicast
        address[es] instead of the session address.</t>

        <t>The "source_id" field is a 32-bit value that uniquely identifies
        the node that sent the message within the context of a single <spanx
        style="emph">NormSession</spanx>. This value is termed the NORM node
        identifier (<spanx style="emph">NormNodeId</spanx>) and unique <spanx
        style="emph">NormNodeId</spanx> identifiers MUST be assigned within a
        single <spanx style="emph">NormSession</spanx>. In some cases, use of
        the host IPv4 address or a hash of an address can suffice, but
        alternative methodologies for assignment and potential collision
        resolution of node identifiers within a multicast session SHOULD be
        considered. For example, the techniques for managing the 32-bit
        "synchronization source" (SSRC) identifiers defined in the Real-Time
        Protocol (RTP) specification <xref target="RFC3550"></xref> are
        applicable for use with NORM node identifiers. In most deployments of
        the NORM protocol to date, the <spanx style="emph">NormNodeId</spanx>
        assignments are administratively configured.</t>

        <t><spanx style="strong">NORM Header Extensions</spanx></t>

        <t>When header extensions are applied, they follow the message type's
        base header and precede any payload portion. There are two formats for
        header extensions, both of which begin with an 8-bit "het" (header
        extension type) field. One format is provided for variable-length
        extensions with "het" values in the range from 0 through 127. The
        other format is for fixed length (one 32-bit word) extensions with
        "het" values in the range from 128 through 255.</t>

        <t>For variable-length extensions, the value of the "hel" field is the
        length of the entire header extension, expressed in multiples of
        32-bit words. The "hel" field MUST be present for variable-length
        extensions ("het" between 0 and 127) and MUST NOT be present for
        fixed-length extensions ("het" between 128 and 255).</t>

        <t>The formats of the variable-length and fixed-length header
        extensions are given, respectively, here:</t>

        <figure align="center"
                title="NORM Variable Length Header Extension Format">
          <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   het <=127   |      hel      |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
|                    Header Extension Content                   |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
        </figure>

        <figure align="center"
                title="NORM Fixed Length (32-bit) Header Extension Format">
          <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   het >=128   |    reserved   |    Header Extension Content   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
        </figure>

        <t>The "Header Extension Content" portion of the header extension is
        defined for each extension type. Some header extensions are defined
        within this document for NORM baseline FEC and congestion control
        operations.</t>
      </section>

      <section title="Sender Messages">
        <t>NORM sender messages include the <spanx style="verb">NORM_DATA</spanx>
        type, the <spanx style="verb">NORM_INFO</spanx> type, and the <spanx
        style="verb">NORM_CMD</spanx> type. <spanx style="verb">NORM_DATA</spanx>
        and <spanx style="verb">NORM_INFO</spanx> messages contain application
        data content while <spanx style="verb">NORM_CMD</spanx> messages are
        used for various protocol control functions.</t>

        <section title="NORM_DATA Message">
          <t>The <spanx style="verb">NORM_DATA</spanx> message is generally
          the predominant type transmitted by NORM senders. These messages are
          used to encapsulate segmented data content for objects of type
          <spanx style="verb">NORM_OBJECT_DATA</spanx>, <spanx style="verb">NORM_OBJECT_FILE</spanx>,
          and <spanx style="verb">NORM_OBJECT_STREAM</spanx>. <spanx
          style="verb">NORM_DATA</spanx> messages contain original or
          FEC-encoded application data content.</t>

          <t>The format of <spanx style="verb">NORM_DATA</spanx> messages is
          comprised of three logical portions: 1) a fixed-format <spanx
          style="verb">NORM_DATA</spanx> header portion, 2) a FEC Payload ID
          portion with a format dependent upon the FEC encoding used, and 3) a
          payload portion containing source or encoded application data
          content. Note for objects of type <spanx style="verb">NORM_OBJECT_STREAM</spanx>,
          the payload portion contains additional fields used to appropriately
          recover stream content. NORM implementations MAY also extend the
          <spanx style="verb">NORM_DATA</spanx> header to include a FEC Object
          Transmission Information (EXT_FTI) header extension. This allows
          NORM receivers to automatically allocate resources and properly
          perform FEC decoding without the need for pre-configuration or
          out-of-band information.</t>

          <figure align="center" title="NORM_DATA Message Format">
            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=2|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     flags     |    fec_id     |     object_transport_id       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         fec_payload_id                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                header_extensions (if applicable)              |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          payload_len*         |       payload_msg_start*      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        payload_offset*                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          payload_data*                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

          <t>*IMPORTANT NOTE: The "payload_len", "payload_msg_start" and
          "payload_offset" fields are present <spanx style="emph">only</spanx>
          for objects of type <spanx style="verb">NORM_OBJECT_STREAM</spanx>.
          These fields, as with the entire payload, are subject to any FEC
          encoding used. Thus, when systematic FEC codes are used, these
          values can be directly interpreted only for packets containing
          source symbols while packets containing FEC parity content need
          decoding before these fields can be interpreted.</t>

          <t>The "version", "type", "hdr_len", "sequence", and "source_id"
          fields form the NORM Common Message Header as described in <xref
          target="CommonHeader"></xref>. The value of the <spanx style="verb">NORM_DATA</spanx>
          "type" field is 2. The <spanx style="verb">NORM_DATA</spanx> base
          "hdr_len" value is 4 (i.e. 4 32-bit words) plus the size of the
          "fec_payload_id" field. The "fec_payload_id" field size depends upon
          the FEC encoding type referenced by the "fec_id" field. For example,
          when small block, systematic codes are used, a "fec_id" value of 129
          is indicated and the size of the "fec_payload_id" is two 32-bit
          words. In this case the <spanx style="verb">NORM_DATA</spanx> base
          "hdr_len" value is 6. The cumulative size of any header extensions
          applied is added into the "hdr_len" field.</t>

          <t>The "instance_id" field contains a value generated by the sender
          to uniquely identify its current instance of participation in the
          <spanx style="emph">NormSession</spanx>. This allows receivers to
          detect when senders have perhaps left and rejoined a session in
          progress. When a sender (identified by its "source_id") is detected
          to have a new "instance_id", the NORM receivers SHOULD drop their
          previous state on the sender and begin reception anew, or at least
          treat this "instance" as a new, separate sender.</t>

          <t>The "grtt" field contains a non-linear quantized representation
          of the sender's current estimate of group round-trip time (<spanx
          style="verb">GRTT_sender</spanx>) (this is also referred to as
          <spanx style="verb">R_max</spanx> in <xref
          target="TfmccPaper"></xref>). This value is used to control timing
          of the NACK repair process and other aspects of protocol operation
          as described in this document. Normally, the advertised "grtt" value
          will correspond to what the sender has measured based on feedback
          from the group, but, at low transmission rates, the advertised
          "grtt" SHALL be set to <spanx style="verb">MAX(grttMeasured, NormSegmentSize/senderRate)</spanx>
          where the <spanx style="verb">NormSegmentSize</spanx> is sender's
          segment size in bytes and the <spanx style="verb">senderRate</spanx>
          is the sender's current transmission rate in bytes per second. The
          algorithm for encoding and decoding this field is described in the
          <xref target="RFC5401">Multicast NACK Building Block</xref>.</t>

          <t>The "backoff" field value is used by receivers to determine the
          maximum backoff timer value used in the timer-based NORM NACK
          feedback suppression. This 4-bit field supports values from 0-15
          that is multiplied by <spanx style="verb">GRTT_sender</spanx> to
          determine the maximum backoff timeout. The "backoff" field informs
          the receivers of the sender's backoff factor parameter (<spanx
          style="verb">K_sender</spanx>). Recommended values and their use are
          described in the NORM receiver NACK procedure description in <xref
          target="NackProcedure"></xref>.</t>

          <t>The "gsize" field contains a representation of the sender's
          current estimate of group size (<spanx style="verb">GSIZE_sender</spanx>).
          This 4-bit field can roughly represent values from ten to 500
          million where the most significant bit value of 0 or 1 represents a
          mantissa of 1 or 5, respectively and the three least significant
          bits incremented by one represent a base 10 exponent (order of
          magnitude). For examples, a field value of "0x0" represents 1.0e+01
          (10), a value of "0x8" represents 5.0e+01 (50), a value of "0x1"
          represents 1.0e+02 (100), and a value of "0xf" represents 5.0e+08.
          For NORM feedback suppression purposes, the group size does not need
          to be represented with a high degree of precision. The group size
          MAY even be estimated somewhat conservatively (i.e., overestimated)
          to maintain low levels of feedback traffic. A default group size
          estimate of 10,000 ("gsize" = 0x3) is RECOMMENDED for general
          purpose reliable multicast applications using the NORM protocol.</t>

          <t>The "flags" field contains a number of different binary flags
          providing information and hints for the receiver to appropriately
          handle the identified object. Defined flags in this field
          include:</t>

          <texttable align="center">
            <ttcol width="30%">Flag</ttcol>

            <ttcol align="center" width="10%">Value</ttcol>

            <ttcol width="60%">Purpose</ttcol>

            <c><spanx style="verb">NORM_FLAG_REPAIR</spanx></c>

            <c>0x01</c>

            <c>Indicates message is a repair transmission</c>

            <c><spanx style="verb">NORM_FLAG_EXPLICIT</spanx></c>

            <c>0x02</c>

            <c>Indicates a repair segment intended to meet a specific receiver
            erasure, as compared to parity segments provided by the sender for
            general purpose (with respect to an FEC coding block) erasure
            filling.</c>

            <c><spanx style="verb">NORM_FLAG_INFO</spanx></c>

            <c>0x04</c>

            <c>Indicates availability of <spanx style="verb">NORM_INFO</spanx>
            for object.</c>

            <c><spanx style="verb">NORM_FLAG_UNRELIABLE</spanx></c>

            <c>0x08</c>

            <c>Indicates that repair transmissions for the specified object
            will be unavailable (One-shot, best effort transmission).</c>

            <c><spanx style="verb">NORM_FLAG_FILE</spanx></c>

            <c>0x10</c>

            <c>Indicates object is file-based data (hint to use disk storage
            for reception).</c>

            <c><spanx style="verb">NORM_FLAG_STREAM</spanx></c>

            <c>0x20</c>

            <c>Indicates object is of type <spanx style="verb">NORM_OBJECT_STREAM</spanx>.</c>
          </texttable>

          <t><spanx style="verb">NORM_FLAG_REPAIR</spanx> is set when the
          associated message is a repair transmission. This information can be
          used by receivers to help observe a join policy where it is desired
          that newly joining receivers only begin participating in the NACK
          process upon receipt of new (non-repair) data content. <spanx
          style="verb">NORM_FLAG_EXPLICIT</spanx> is used to mark repair
          messages sent when the data sender has exhausted its ability to
          provide "fresh" (not previously transmitted) parity segments as
          repair. This flag could possibly be used by intermediate systems
          implementing functionality to control sub-casting of repair content
          to different legs of a reliable multicast topology with disparate
          repair needs. <spanx style="verb">NORM_FLAG_INFO</spanx> is set only
          when OPTIONAL <spanx style="verb">NORM_INFO</spanx> content is
          actually available for the associated object. Thus, receivers will
          NACK for retransmission of <spanx style="verb">NORM_INFO</spanx>
          only when it is available for a given object. <spanx style="verb">NORM_FLAG_UNRELIABLE</spanx>
          is set when the sender wishes to transmit an object with only "best
          effort" delivery and will not supply repair transmissions for the
          object. NORM receivers SHOULD NOT execute repair requests for
          objects marked with the <spanx style="verb">NORM_FLAG_UNRELIABLE</spanx>
          flag. There are cases where receivers can inadvertently request
          repair of such objects when all segments (or info content) for those
          objects are not received (i.e., a gap in the "object_transport_id"
          sequence is noted). In this case, the sender SHALL invoke the <spanx
          style="verb">NORM_CMD(SQUELCH)</spanx> process as described in <xref
          target="NORM_CMD"></xref>.</t>

          <t><spanx style="verb">NORM_FLAG_FILE</spanx> can be set as a hint
          from the sender that the associated object SHOULD be stored in
          non-volatile storage. <spanx style="verb">NORM_FLAG_STREAM</spanx>
          is set when the identified object is of type <spanx style="verb">NORM_OBJECT_STREAM</spanx>.
          The presence of <spanx style="verb">NORM_FLAG_STREAM</spanx>
          overrides that of <spanx style="verb">NORM_FLAG_FILE</spanx> with
          respect to interpretation of object size and the format of <spanx
          style="verb">NORM_DATA</spanx> messages.</t>

          <t>The "fec_id" field corresponds to the FEC Encoding Identifier
          described in the FEC Building Block document <xref
          target="RFC5052"></xref>. The "fec_id" value implies the format of
          the "fec_payload_id" field and, coupled with FEC Object Transmission
          Information, the procedures to decode FEC encoded content. Small
          block, systematic codes ("fec_id" = 129) are expected to be used for
          most NORM purposes and systematic FEC codes are RECOMMENDED for most
          efficient performance of <spanx style="verb">NORM_OBJECT_STREAM</spanx>
          transport.</t>

          <t>The "object_transport_id" field is a monotonically and
          incrementally increasing value assigned by the sender to <spanx
          style="emph">NormObjects</spanx> being transmitted. Transmissions
          and repair requests related to that object use the same
          "object_transport_id" value. For sessions of very long or indefinite
          duration, the "object_transport_id" field will wrap and be repeated,
          but it is presumed that the 16-bit field size provides a sufficient
          sequence space to avoid object confusion amongst receivers and
          sources (i.e., receivers SHOULD re-synchronize with a server when
          receiving object sequence identifiers sufficiently out-of-range with
          the current state kept for a given source). During the course of its
          transmission within a NORM session, an object is uniquely identified
          by the concatenation of the sender "source_id" and the given
          "object_transport_id". Note that <spanx style="verb">NORM_INFO</spanx>
          messages associated with the identified object carry the same
          "object_transport_id" value.</t>

          <t>The "fec_payload_id" identifies the attached <spanx style="verb">NORM_DATA</spanx>
          "payload" content. The size and format of the "fec_payload_id" field
          depends upon the FEC type indicated by the "fec_id" field. These
          formats are given in the descriptions of specific FEC schemes such
          as those described in the <xref target="RFC5445">FEC Basic
          Schemes</xref> specification or in other FEC Schemes. As an example,
          the format of the "fec_payload_id" format for Small Block,
          Systematic codes ("fec_id" = 129) from the<xref target="RFC5445">
          FEC Basic Schemes</xref> specification is given here:</t>

          <figure align="center"
                  title="Example: FEC Payload Id Format for 'fec_id' = 129">
            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       source_block_number                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        source_block_len       |      encoding_symbol_id       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

          <t>In this example FEC payload identifier, the
          "source_block_number", "source_block_len", and "encoding_symbol_id"
          fields correspond to the "Source Block Number", "Source Block
          Length, and "Encoding Symbol ID" fields of the FEC Payload ID format
          for Small Block Systematic FEC Schemes identified by a "fec_id"
          value of 129 as specified by the <xref target="RFC5445">FEC Basic
          Schemes</xref> specification. The "source_block_number" identifies
          the coding block's relative position with a <spanx style="emph">NormObject</spanx>.
          Note that, for <spanx style="emph">NormObjects</spanx> of type
          <spanx style="verb">NORM_OBJECT_STREAM</spanx>, the
          "source_block_number" will wrap for very long lived sessions. The
          "source_block_len" indicates the number of user data segments in the
          identified coding block. Given the "source_block_len" information of
          how many symbols of application data are contained in the block, the
          receiver can determine whether the attached segment is data or
          parity content and treat it appropriately. Applications MAY
          dynamically "shorten" code blocks when the pending information
          content is not predictable (e.g. real-time message streams). In that
          case, the "source_block_len" value given for an "encoding_symbol_id"
          that contains FEC parity content SHALL take precedence over the
          "source_block_len" value provided for any packets containing source
          symbols. Also, the "source_block_len" value given for an ordinally
          higher "encoding_symbol_id" SHALL take precedence over the
          "source_block_len" given for prior encoding symbols. The reason for
          this is that the sender will only know the maximum source block
          length at the time is transmitting source symbols, but then
          subsequently "shorten" the code and then provide that last source
          symbol and/or encoding symbols with FEC parity content. The
          "encoding_symbol_id" identifies which specific symbol (segment)
          within the coding block the attached payload conveys. Depending upon
          the value of the "encoding_symbol_id" and the associated
          "source_block_len" parameters for the block, the symbol (segment)
          referenced will be a user data or an FEC parity segment. For
          systematic codes, encoding symbols numbered less than the <spanx
          style="verb">source_block_len</spanx> contain original application
          data while segments greater than or equal to <spanx style="verb">source_block_len</spanx>
          contain parity symbols calculated for the block. The concatenation
          of <spanx style="verb">object_transport_id::fec_payload_id</spanx>
          can be viewed as a unique transport protocol data unit identifier
          for the attached segment with respect to the NORM sender's instance
          within a session.</t>

          <t>Additional FEC Object Transmission Information (FTI) (as
          described in the <xref target="RFC5052">FEC Building Block</xref>)
          is needed to properly receive and decode NORM transport objects.
          This information MAY be provided as out-of-band session information.
          In some cases, it will be useful for the sender to include this
          information "in-band" to facilitate receiver operation with minimal
          pre-configuration. For this purpose, the NORM FEC Object
          Transmission Information Header Extension (EXT_FTI) is defined. This
          header extension MAY be applied to <spanx style="verb">NORM_DATA</spanx>
          and <spanx style="verb">NORM_INFO</spanx> messages to provide this
          necessary information. The format of the EXT_FTI consists of two
          parts, a general part that contains the size of the associated
          transport object and a portion that depends upon the FEC scheme
          being used. The "fec_id" field in <spanx style="verb">NORM_DATA</spanx>
          and <spanx style="verb">NORM_INFO</spanx> messages identifies the
          FEC scheme. The format of the EXT_FTI general part is given
          here.</t>

          <figure align="center"
                  title="EXT_FTI Header Extension General Portion Format">
            <artwork align="center"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    het = 64   |    hel = 4    |       object_size (msb)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       object_size (lsb)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  FEC Scheme specific content ...              |]]></artwork>
          </figure>

          <t>The header extension type "het" field value for the EXT_FTI
          header extension is 64. The header extension length "hel" value
          depends upon the format of the FTI for encoding type identified by
          the "fec_id" field.</t>

          <t>The 48-bit "object_size" field indicates the total length of the
          object (in bytes) for the static object types of <spanx
          style="verb">NORM_OBJECT_FILE</spanx> and <spanx style="verb">NORM_OBJECT_DATA</spanx>.
          This information is used by receivers to determine storage
          requirements and/or allocate storage for the received object.
          Receivers with insufficient storage capability might wish to forego
          reliable reception (i.e., not NACK for) of the indicated object. In
          the case of objects of type <spanx style="verb">NORM_OBJECT_STREAM</spanx>,
          the "object_size" field is used by the sender to advertise the size
          of its stream buffer to the receiver group. In turn, the receivers
          SHOULD use this information to allocate a stream buffer for
          reception of corresponding size.</t>

          <t>As noted, the format of the extension depends upon the FEC code
          in use, but in general it contains any necessary details on the code
          in use (e.g., FEC Instance ID, etc.). As an example, the format of
          the EXT_FTI for small block systematic codes ("fec_id" = 129) is
          given here:</t>

          <figure align="center"
                  title="Example: EXT_FTI Header Extension Format for 'fec_id' = 129">
            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    het = 64   |    hel = 4    |       object_size (msb)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       object_size (lsb)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       fec_instance_id         |          segment_size         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       fec_max_block_len       |         fec_num_parity        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

          <t>In this example (for "fec_id" = 129), the "hel" field value is 4.
          The size of the EXT_FTI header extension will possibly be different
          for other FEC schemes.</t>

          <t>The 48-bit "object_size" serves the purpose described
          previously.</t>

          <t>The "fec_instance_id" corresponds to the "FEC Instance ID"
          described in the <xref target="RFC5052">FEC Building Block</xref>.
          In this case, the "fec_instance_id" is a value corresponding to the
          particular type of Small Block Systematic Code being used (e.g.,
          Reed-Solomon GF(2^8), Reed-Solomon GF(2^16), etc). The standardized
          assignment of FEC Instance ID values is described in <xref
          format="none" target="RFC5052">RFC 5052</xref>.</t>

          <t>The "segment_size" field indicates the sender's current setting
          for maximum message payload content (in bytes). This allows
          receivers to allocate appropriate buffering resources and to
          determine other information in order to properly process received
          data messaging. Typically, FEC parity symbol segments will be of
          this size.</t>

          <t>The "fec_max_block_len" indicates the current maximum number of
          user data segments per FEC coding block to be used by the sender
          during the session. This allows receivers to allocate appropriate
          buffer space for buffering blocks transmitted by the sender.</t>

          <t>The "fec_num_parity" corresponds to the "maximum number of
          encoding symbols that can be generated for any source block" as
          described in for FEC Object Transmission Information for Small Block
          Systematic Codes in the <xref target="RFC5052">FEC Building
          Block</xref>. For example, Reed-Solomon codes can be arbitrarily
          shortened to create different code variations for a given block
          length. In the case of Reed-Solomon (GF(2^8) and GF(2^16)) codes,
          this value indicates the maximum number of parity segments available
          from the sender for the coding blocks. This field MAY be interpreted
          differently for other systematic codes as they are defined.</t>

          <t>The payload portion of <spanx style="verb">NORM_DATA</spanx>
          messages includes source data or FEC encoded application content.
          The content of this payload depends upon the FEC scheme being
          employed, and support for streaming using the <spanx style="verb">NORM_OBJECT_STREAM</spanx>
          type, when applicable, necessitates some additional content in the
          payload.</t>

          <t>The "payload_len", "payload_msg_start", and "payload_offset"
          fields are present <spanx style="emph">only</spanx> for transport
          objects of type <spanx style="verb">NORM_OBJECT_STREAM</spanx>.
          These REQUIRED fields allow senders to arbitrarily vary the size of
          <spanx style="verb">NORM_DATA</spanx> payload segments for streams.
          This allows applications to flush transmitted streams as needed to
          meet unique streaming requirements. For objects of types <spanx
          style="verb">NORM_OBJECT_FILE</spanx> and <spanx style="verb">NORM_OBJECT_DATA</spanx>,
          these fields are unnecessary since the receiver can calculate the
          payload length and offset information from the "fec_payload_id"
          using the REQUIRED block partitioning algorithm described in the
          <xref target="RFC5052">FEC Building Block</xref>. When systematic
          FEC codes (e.g., "fec_id" = 129) are used, the "payload_len",
          "payload_msg_start", and "payload_offset" fields contain actual
          payload_data length, message start index (or stream control code),
          and byte offset values for the associated application stream data
          segment (the remainder of the "payload_data" field content) for
          those <spanx style="verb">NORM_DATA</spanx> messages containing
          source data symbols. In <spanx style="verb">NORM_DATA</spanx>
          messages that contain FEC parity content, these fields do not
          contain values that can be directly interpreted, but instead are
          values computed from FEC encoding the "payload_len",
          "payload_msg_start", and "payload_offset" fields for the source data
          segments of the corresponding coding block. The actual
          "payload_msg_start", "payload_len" and "payload_offset" values of
          missing data content can be determined upon decoding a FEC coding
          block. Note that these fields do NOT contribute to the value of the
          <spanx style="verb">NORM_DATA</spanx> "hdr_len" field. These fields
          are present only when the "flags" portion of the <spanx
          style="verb">NORM_DATA</spanx> message indicate the transport object
          is of type <spanx style="verb">NORM_OBJECT_STREAM</spanx>.</t>

          <t>The "payload_len" value, when non-zero, indicates the length (in
          bytes) of the source content contained in the associated
          "payload_data" field. However, when the "payload_len" value is equal
          to <spanx style="verb">ZERO</spanx>, this indicates that the
          "payload_msg_start" field be alternatively interpreted as a
          "stream_control_code". The only "stream_control_code" value defined
          is <spanx style="verb">NORM_STREAM_END = 0</spanx>. The <spanx
          style="verb">NORM_STREAM_END</spanx> code indicates that the sender
          is terminating transmission of stream content at the corresponding
          position in the stream and the receiver MUST NOT expect content (or
          request repair for any content) following that position in the
          stream. Additional specifications MAY extend the functionality of
          the NORM stream transport mode by defining additional stream control
          codes. These control codes are delivered to the recipient
          application reliably, in-order with respect to the streamed
          application data content.</t>

          <t>The "payload_msg_start" field serves one of two exclusive
          purposes. When the "payload_len" value is non-zero, the
          "payload_msg_start" field, when also set to a non-zero value,
          indicates that the associated "payload_data" content contains an
          application-defined message boundary (start-of-message). When such a
          message boundary is indicated, the first byte of an
          application-defined message, with respect to the "payload_data"
          field, will be found at an offset of "payload_msg_start - 1" bytes.
          Thus, if a <spanx style="verb">NORM_DATA</spanx> payload for a
          <spanx style="verb">NORM_OBJECT_STREAM</spanx> contains the start of
          an application message at the first byte of the "payload_data"
          field, the value of the "payload_msg_start" field will be '1'. NORM
          implementations SHOULD provide sender stream applications with a
          capability to mark message boundaries in this manner. Similarly, the
          NORM receiver implementation SHOULD enable the application to
          recover such message boundary information. This enables NORM
          receivers to "synchronize" reliable reception of transmitted message
          stream content in a meaningful way (i.e., meaningful to the
          application) at any time, whether joining a session already in
          progress, or departing the session and returning. Note that if the
          value of the "payload_msg_start" field is <spanx style="verb">ZERO</spanx>,
          no message boundary is present. The "payload_msg_start" value will
          always be less than or equal to the "payload_len" value except for
          the special case of "payload_len = 0", that indicates the
          "payload_msg_start" field be instead interpreted as a
          "stream_control_code"</t>

          <t>The "payload_offset" field indicates the relative byte position
          (from the sender stream transmission start) of the source content
          contained in the "payload_data" field. Note that for long-lived
          streams, the "payload_offset" field will wrap.</t>

          <t>The "payload_data" field contains the original application source
          or parity content for the symbol identified by the "fec_payload_id".
          The length of this field SHALL be limited to a maximum of the
          sender's <spanx style="emph">NormSegmentSize</spanx> bytes as given
          in the FTI for the object. Note the length of this field for
          messages containing parity content will always be of length <spanx
          style="emph">NormSegmentSize</spanx>. When encoding data segments of
          varying sizes, the FEC encoder SHALL assume <spanx style="verb">ZERO</spanx>
          value padding for data segments with length less than the <spanx
          style="emph">NormSegmentSize</spanx>. It is RECOMMENDED that a
          sender's <spanx style="emph">NormSegmentSize</spanx> generally be
          constant for the duration of a given sender's term of participation
          in the session, but can possibly vary on a per-object basis. The
          <spanx style="emph">NormSegmentSize</spanx> SHOULD be configurable
          by the sender application prior to session participation as needed
          for network topology MTU considerations. For IPv6, MTU discovery MAY
          be possibly leveraged at session startup to perform this
          configuration. The "payload_data" content MAY be delivered directly
          to the application for source symbols (when systematic FEC encoding
          is used) or upon decoding of the FEC block. For <spanx style="verb">NORM_OBJECT_FILE</spanx>
          and <spanx style="verb">NORM_OBJECT_STREAM</spanx> objects, the data
          segment length and offset can be calculated using the block
          partitioning algorithm described in the <xref target="RFC5052">FEC
          Building Block</xref>. For <spanx style="verb">NORM_OBJECT_STREAM</spanx>
          objects, the length and offset is obtained from the segment's
          corresponding embedded "payload_len" and "payload_offset"
          fields.</t>
        </section>

        <section title="NORM_INFO Message">
          <t>The <spanx style="verb">NORM_INFO</spanx> message is used to
          convey OPTIONAL, application-defined, out-of-band context
          information for transmitted <spanx style="emph">NormObjects</spanx>.
          An example <spanx style="verb">NORM_INFO</spanx> use for bulk file
          transfer is to place MIME type information for the associated file,
          data, or stream object into the <spanx style="verb">NORM_INFO</spanx>
          payload. Receivers could then use the <spanx style="verb">NORM_INFO</spanx>
          content to make a decision as whether to participate in reliable
          reception of the associated object. Each <spanx style="emph">NormObject</spanx>
          can have an independent unit of <spanx style="verb">NORM_INFO</spanx>
          associated with it. <spanx style="verb">NORM_DATA</spanx> messages
          contain a flag to indicate the availability of <spanx style="verb">NORM_INFO</spanx>
          for a given <spanx style="emph">NormObject</spanx>. NORM receivers
          will NACK for retransmission of <spanx style="verb">NORM_INFO</spanx>
          when they have not received it for a given <spanx style="emph">NormObject</spanx>.
          The size of the <spanx style="verb">NORM_INFO</spanx> content is
          limited to that of a single <spanx style="emph">NormSegmentSize</spanx>
          for the given sender. This atomic nature allows the <spanx
          style="verb">NORM_INFO</spanx> to be rapidly and efficiently
          repaired within the NORM reliable transmission process.</t>

          <t>When <spanx style="verb">NORM_INFO</spanx> content is available
          for a <spanx style="emph">NormObject</spanx>, the NORM_FLAG_INFO
          flag SHALL be set in <spanx style="verb">NORM_DATA</spanx> messages
          for the corresponding "object_transport_id" and the <spanx
          style="verb">NORM_INFO</spanx> message SHALL be transmitted as the
          first message for the <spanx style="emph">NormObject</spanx>.</t>

          <figure align="center" title="NORM_INFO Message Format">
            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=1|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     flags     |     fec_id    |     object_transport_id       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                header_extensions (if applicable)              |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         payload_data                          |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

          <t>The "version", "type", "hdr_len", "sequence", and "source_id"
          fields form the NORM Common Message Header as described in <xref
          target="CommonHeader"></xref>. The value of "hdr_len" field when no
          header extensions are present is 4.</t>

          <t>The "instance_id", "grtt", "backoff", "gsize", "flags", "fec_id",
          and "object_transport_id" fields carry the same information and
          serve the same purpose as with <spanx style="verb">NORM_DATA</spanx>
          messages. These values allow the receiver to prepare appropriate
          buffering, etc, for further transmissions from the sender when
          <spanx style="verb">NORM_INFO</spanx> is the first message
          received.</t>

          <t>As with <spanx style="verb">NORM_DATA</spanx> messages, the NORM
          FTI Header Extension (EXT_FTI) MAY be optionally applied to <spanx
          style="verb">NORM_INFO</spanx> messages. To conserve protocol
          overhead, NORM implementations MAY apply the EXT_FTI when used to
          <spanx style="verb">NORM_INFO</spanx> messages only and not to
          <spanx style="verb">NORM_DATA</spanx> messages.</t>

          <t>The <spanx style="verb">NORM_INFO</spanx> "payload_data" field
          contains sender application-defined content that can be used by
          receiver applications for various purposes as described above.</t>
        </section>

        <section anchor="NORM_CMD" title="NORM_CMD Messages">
          <t><spanx style="verb">NORM_CMD</spanx> messages are transmitted by
          senders to perform a number of different protocol functions. This
          includes functions such as round-trip timing collection, congestion
          control functions, synchronization of sender/receiver repair
          "windows", and notification of sender status. A core set of <spanx
          style="verb">NORM_CMD</spanx> messages is enumerated. Additionally,
          a range of command types remain available for potential
          application-specific use. Some <spanx style="verb">NORM_CMD</spanx>
          types can have dynamic content attached. Any attached content will
          be limited to maximum length of the sender <spanx style="emph">NormSegmentSize</spanx>
          to retain the atomic nature of commands. All <spanx style="verb">NORM_CMD</spanx>
          messages begin with a common set of fields, after the usual NORM
          message common header. The standard <spanx style="verb">NORM_CMD</spanx>
          fields are:</t>

          <figure align="center" title="NORM_CMD Standard Fields">
            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    sub-type   |                                               |
+-+-+-+-+-+-+-+-+        NORM_CMD Content                       +
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

          <t>The "version", "type", "hdr_len", "sequence", and "source_id"
          fields form the NORM Common Message Header as described in <xref
          target="CommonHeader"></xref>. The value of the "hdr_len" field for
          <spanx style="verb">NORM_CMD</spanx> messages without header
          extensions present depends upon the "sub-type" field.</t>

          <t>The "instance_id", "grtt", "backoff", and "gsize" fields provide
          the same information and serve the same purpose as with <spanx
          style="verb">NORM_DATA</spanx> and <spanx style="verb">NORM_INFO</spanx>
          messages. The "sub-type" field indicates the type of command to
          follow. The remainder of the <spanx style="verb">NORM_CMD</spanx>
          message is dependent upon the command sub-type. NORM command
          sub-types include:</t>

          <texttable>
            <ttcol width="30%">Command</ttcol>

            <ttcol align="center" width="10%">Sub-type</ttcol>

            <ttcol width="60%">Purpose</ttcol>

            <c><spanx style="verb">NORM_CMD(FLUSH)</spanx></c>

            <c>1</c>

            <c>Used to indicate sender temporary end-of-transmission. (Assists
            in robustly initiating outstanding repair requests from
            receivers). May also be optionally used to collect positive
            acknowledgment of reliable reception from subset of receivers.</c>

            <c><spanx style="verb">NORM_CMD(EOT)</spanx></c>

            <c>2</c>

            <c>Used to indicate sender permanent end-of-transmission.</c>

            <c><spanx style="verb">NORM_CMD(SQUELCH)</spanx></c>

            <c>3</c>

            <c>Used to advertise sender's current repair window in response to
            out-of-range NACKs from receivers.</c>

            <c><spanx style="verb">NORM_CMD(CC)</spanx></c>

            <c>4</c>

            <c>Used for GRTT measurement and collection of congestion control
            feedback.</c>

            <c><spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx></c>

            <c>5</c>

            <c>Used to advertise sender's aggregated repair/feedback state for
            suppression of unicast feedback from receivers.</c>

            <c><spanx style="verb">NORM_CMD(ACK_REQ)</spanx></c>

            <c>6</c>

            <c>Used to request application-defined positive acknowledgment
            from a list of receivers (OPTIONAL).</c>

            <c><spanx style="verb">NORM_CMD(APPLICATION)</spanx></c>

            <c>7</c>

            <c>Used for application-defined purposes that need to temporarily
            preempt or supplement data transmission (OPTIONAL).</c>
          </texttable>

          <section title="NORM_CMD(FLUSH) Message">
            <t>The <spanx style="verb">NORM_CMD(FLUSH)</spanx> command is sent
            when the sender reaches the end of all data content and pending
            repairs it has queued for transmission. This can indicate either a
            temporary or permanent end of data transmission, but the sender is
            still willing to respond to repair requests. This command is
            repeated once per <spanx style="verb">2*GRTT_sender</spanx> to
            excite the receiver set for any outstanding repair requests up to
            and including the transmission point indicated within the <spanx
            style="verb">NORM_CMD(FLUSH)</spanx> message. The number of
            repeats is equal to <spanx style="verb">NORM_ROBUST_FACTOR</spanx>
            unless a list of receivers from which explicit positive
            acknowledgment is expected ("acking_node_list") is given. In that
            case, the "acking_node_list" is updated as acknowledgments are
            received and the <spanx style="verb">NORM_CMD(FLUSH)</spanx> is
            repeated according to the mechanism described in <xref
            target="PositiveAcknowledgment"></xref>. The greater the <spanx
            style="verb">NORM_ROBUST_FACTOR</spanx>, the greater the
            probability that all applicable receivers will be excited for
            acknowledgment or repair requests (NACKs) AND that the
            corresponding NACKs are delivered to the sender. A default value
            of <spanx style="verb">NORM_ROBUST_FACTOR</spanx> equal to 20 is
            RECOMMENDED. If a <spanx style="verb">NORM_NACK</spanx> message
            interrupts the flush process, the sender SHALL re-initiate the
            flush process after any resulting repair transmissions are
            completed.</t>

            <t>Note that receivers also employ a timeout mechanism to
            self-initiate NACKing (if there are outstanding repair needs) when
            no messages of any type are received from a sender. This
            inactivity timeout is related to the <spanx style="verb">NORM_CMD(FLUSH)</spanx>
            and <spanx style="verb">NORM_ROBUST_FACTOR</spanx> and is
            specified in <xref target="NackProcedure"></xref>. Receivers SHALL
            self-initiate the NACK repair process when the inactivity timeout
            has expired for a specific sender and the receiver has pending
            repairs needed from that sender. With a sufficiently large <spanx
            style="verb">NORM_ROBUST_FACTOR</spanx> value, data content is
            delivered with a high assurance of reliability. The penalty of a
            large <spanx style="verb">NORM_ROBUST_FACTOR</spanx> value is the
            potential transmission of excess <spanx style="verb">NORM_CMD(FLUSH)</spanx>
            messages and a longer inactivity timeout for receivers to
            self-initiate a terminal NACK process.</t>

            <t>For finite-size transport objects such as <spanx style="verb">NORM_OBJECT_DATA</spanx>
            and <spanx style="verb">NORM_OBJECT_FILE</spanx>, the flush
            process (if there are no further pending objects) occurs at the
            end of these objects. Thus, FEC repair information is always
            available for repairs in response to repair requests elicited by
            the flush command. However, for <spanx style="verb">NORM_OBJECT_STREAM</spanx>,
            the flush can occur at any time, including in the middle of an FEC
            coding block if systematic FEC codes are employed. In this case,
            the sender will not yet be able to provide FEC parity content for
            the concurrent coding block and will be limited to explicitly
            repairing the stream with source data content for that block.
            Applications that anticipate frequent flushing of stream content
            SHOULD be judicious in the selection of the FEC coding block size
            (i.e., do not use a very large coding block size if frequent
            flushing occurs). For example, a reliable multicast application
            transmitting an on-going series of intermittent, relatively small
            messages will need to trade-off using the <spanx style="verb">NORM_OBJECT_DATA</spanx>
            paradigm versus the <spanx style="verb">NORM_OBJECT_STREAM</spanx>
            paradigm with an appropriate FEC coding block size. This is
            analogous to application trade-offs for other transport protocols
            such as the selection of different TCP modes of operation such as
            "no delay", etc.</t>

            <figure align="center" title="NORM_CMD(FLUSH) Message Format">
              <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  sub-type = 1 |    fec_id     |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         fec_payload_id                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                acking_node_list (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

            <t>The "version", "type", "hdr_len", "sequence", and "source_id"
            fields form the NORM Common Message Header as described in <xref
            target="CommonHeader"></xref>. In addition to the NORM common
            message header and standard <spanx style="verb">NORM_CMD</spanx>
            fields, the <spanx style="verb">NORM_CMD(FLUSH)</spanx> message
            contains fields to identify the current status and logical
            transmit position of the sender.</t>

            <t>The "fec_id" field indicates the FEC type used for the flushing
            "object_transport_id" and implies the size and format of the
            "fec_payload_id" field. Note the "hdr_len" value for the <spanx
            style="verb">NORM_CMD(FLUSH)</spanx> message is 4 plus the size of
            the "fec_payload_id" field when no header extensions are
            present.</t>

            <t>The "object_transport_id" and "fec_payload_id" fields indicate
            the sender's current logical "transmit position". These fields are
            interpreted in the same manner as in the <spanx style="verb">NORM_DATA</spanx>
            message type. Upon receipt of the <spanx style="verb">NORM_CMD(FLUSH)</spanx>,
            receivers are expected to check their completion state THROUGH
            (including) this transmission position. If receivers have
            outstanding repair needs in this range, they SHALL initiate the
            NORM NACK Repair Process as described in <xref
            target="NackProcedure"></xref>. If receivers have no outstanding
            repair needs, no response to the <spanx style="verb">NORM_CMD(FLUSH)</spanx>
            is generated.</t>

            <t>For <spanx style="verb">NORM_OBJECT_STREAM</spanx> objects
            using systematic FEC codes, receivers MUST request "explicit-only"
            repair of the identified "source_block_number" if the given
            "encoding_symbol_id" is less than the "source_block_len". This
            condition indicates the sender has not yet completed encoding the
            corresponding FEC block and parity content is not yet available.
            An "explicit-only" repair request consists of NACK content for the
            applicable "source_block_number" that does not include any
            requests for parity-based repair. This allows NORM sender
            applications to "flush" an ongoing stream of transmission when
            needed, even if in the middle of an FEC block. Once the sender
            resumes stream transmission and passes the end of the pending
            coding block, subsequent NACKs from receivers SHALL request
            parity-based repair as usual. Note that the use of a systematic
            FEC code is assumed here. Note that a sender has the option of
            arbitrarily shortening a given code block when such an application
            "flush" occurs. In this case, the receiver will request explicit
            repair, but the sender MAY provide FEC-based repair (parity
            segments) in response. These parity segments MUST contain the
            corrected "source_block_len" for the shortened block and that
            "source_block_len" associated with segments containing parity
            content SHALL override the previously advertised
            "source_block_len". Similarly, the "source_block_len" associated
            with the highest ordinal "encoding_symbol_id" SHALL take
            precedence over prior symbols when a difference (e.g., due to code
            shortening at the sender) occurs. Normal receiver NACK initiation
            and construction is discussed in detail in <xref
            target="NackProcedure"></xref>.</t>

            <t>The OPTIONAL "acking_node_list" field contains a list of <spanx
            style="emph">NormNodeIds</spanx> for receivers from which the
            sender is requesting explicit positive acknowledgment of reception
            up through the transmission point identified by the
            "object_transport_id" and "fec_payload_id" fields. The length of
            the list can be inferred from the length of the received <spanx
            style="verb">NORM_CMD(FLUSH)</spanx> message. When the
            "acking_node_list" is present, the lightweight positive
            acknowledgment process described in <xref
            target="PositiveAcknowledgment"></xref> SHALL be observed.</t>
          </section>

          <section title="NORM_CMD(EOT) Message">
            <t>The <spanx style="verb">NORM_CMD(EOT)</spanx> command is sent
            when the sender reaches permanent end-of-transmission with respect
            to the <spanx style="emph">NormSession</spanx> and will not
            respond to further repair requests. This allows receivers to
            gracefully reach closure of operation with this sender (without
            requiring any timeout) and free any resources that are no longer
            needed. The <spanx style="verb">NORM_CMD(EOT)</spanx> command
            SHOULD be sent with the same robust mechanism as used for <spanx
            style="verb">NORM_CMD(FLUSH)</spanx> commands to provide a high
            assurance of reception by the receiver set.</t>

            <figure align="center" title="NORM_CMD(EOT) Message Format">
              <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  sub-type = 2 |                    reserved                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

            <t>The value of the "hdr_len" field for <spanx style="verb">NORM_CMD(EOT)</spanx>
            messages without header extensions present is 4. The "reserved"
            field is reserved for future use and MUST be set to an all <spanx
            style="verb">ZERO</spanx> value. Receivers MUST ignore the
            "reserved" field.</t>
          </section>

          <section title="NORM_CMD(SQUELCH) Message">
            <t>The <spanx style="verb">NORM_CMD(SQUELCH)</spanx> command is
            transmitted in response to outdated or invalid <spanx
            style="verb">NORM_NACK</spanx> content received by the sender.
            Invalid <spanx style="verb">NORM_NACK</spanx> content consists of
            repair requests for <spanx style="emph">NormObjects</spanx> for
            which the sender is unable or unwilling to provide repair. This
            includes repair requests for outdated objects, aborted objects, or
            those objects that the sender previously transmitted marked with
            the <spanx style="verb">NORM_FLAG_UNRELIABLE</spanx> flag. This
            command indicates to receivers what content is available for
            repair, thus serving as a description of the sender's current
            "repair window". Receivers SHALL NOT generate repair requests for
            content identified as invalid by a <spanx style="verb">NORM_CMD(SQUELCH)</spanx>.</t>

            <t>The <spanx style="verb">NORM_CMD(SQUELCH)</spanx> command is
            sent once per <spanx style="verb">2*GRTT_sender</spanx> at the
            most. The <spanx style="verb">NORM_CMD(SQUELCH)</spanx> advertises
            the current "repair window" of the sender by identifying the
            earliest (lowest) transmission point for which it will provide
            repair, along with an encoded list of objects from that point
            forward that are no longer valid for repair. This mechanism allows
            the sender application to cancel or abort transmission and/or
            repair of specific previously enqueued objects. The list also
            contains the identifiers for any objects within the repair window
            that were sent with the <spanx style="verb">NORM_FLAG_UNRELIABLE</spanx>
            flag set. In normal conditions, the <spanx style="verb">NORM_CMD(SQUELCH)</spanx>
            will be needed infrequently, and generally only to provide a
            reference repair window for receivers who have fallen
            "out-of-sync" with the sender due to extremely poor network
            conditions.</t>

            <t>The starting point of the invalid <spanx style="emph">NormObject</spanx>
            list begins with the lowest invalid <spanx style="emph">NormTransportId</spanx>
            greater than the current "repair window" start from the invalid
            NACK(s) that prompted the generation of the squelch. The length of
            the list is limited by the sender's <spanx style="emph">NormSegmentSize</spanx>.
            This allows the receivers to learn the status of the sender's
            applicable object repair window with minimal transmission of
            <spanx style="verb">NORM_CMD(SQUELCH)</spanx> commands. The format
            of the <spanx style="verb">NORM_CMD(SQUELCH)</spanx> message
            is:</t>

            <figure align="center" title="NORM_CMD(SQUELCH) Message Format">
              <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| sub-type = 3  |     fec_id    |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         fec_payload_id                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        invalid_object_list                    |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

            <t>In addition to the NORM common message header and standard
            <spanx style="verb">NORM_CMD</spanx> fields, the <spanx
            style="verb">NORM_CMD(SQUELCH)</spanx> message contains fields to
            identify the earliest logical transmit position of the sender's
            current repair window and an "invalid_object_list" beginning with
            the index of the logically earliest invalid repair request from
            the offending NACK message that initiated the <spanx style="verb">NORM_CMD(SQUELCH)</spanx>
            transmission. The value of the "hdr_len" field when no extensions
            are present is 4 plus the size of the "fec_payload_id" field that
            is dependent upon the FEC scheme identified by the "fec_id"
            field.</t>

            <t>The "object_transport_id" and "fec_payload_id" fields are
            concatenated to indicate the beginning of the sender's current
            repair window (i.e., the logically earliest point in its
            transmission history for which the sender can provide repair). The
            "fec_id" field implies the size and format of the "fec_payload_id"
            field. This serves as an advertisement of a "synchronization"
            point for receivers to request repair. Note, that while an
            "encoding_symbol_id" MAY be included in the "fec_payload_id"
            field, the sender's repair window SHOULD be aligned on FEC coding
            block boundaries and thus the "encoding_symbol_id" SHOULD be
            zero.</t>

            <t>The "invalid_object_list" is a list of 16-bit <spanx
            style="emph">NormTransportIds</spanx> that, although they are
            within the range of the sender's current repair window, are no
            longer available for repair from the sender. For example, a sender
            application MAY dequeue an out-of-date object even though it is
            still within the repair window. The total size of the
            "invalid_object_list" content is can be determined from the
            packet's payload length and is limited to a maximum of the <spanx
            style="emph">NormSegmentSize</spanx> of the sender. Thus, for very
            large repair windows, it is possible that a single <spanx
            style="verb">NORM_CMD(SQUELCH)</spanx> message cannot include the
            entire set of invalid objects in the repair window. In this case,
            the sender SHALL ensure that the list begins with a <spanx
            style="emph">NormObjectId</spanx> that is greater than or equal to
            the lowest ordinal invalid <spanx style="emph">NormObjectId</spanx>
            from the NACK message(s) that prompted the <spanx style="verb">NORM_CMD(SQUELCH)</spanx>
            generation. The <spanx style="emph">NormObjectIds</spanx> in the
            "invalid_object_list" MUST be ordinally greater than the
            "object_transport_id" marking the beginning of the sender's repair
            window. This insures convergence of the squelch process, even if
            multiple invalid NACK/ squelch iterations are required. This
            explicit description of invalid content within the sender's
            current window allows the sender application (most notably for
            discrete object transport) to arbitrarily invalidate (i.e.,
            dequeue) portions of enqueued content (e.g., certain objects) for
            which it no longer wishes to provide reliable transport.</t>
          </section>

          <section title="NORM_CMD(CC) Message">
            <t>The <spanx style="verb">NORM_CMD(CC)</spanx> messages contains
            fields to enable sender-to-group GRTT measurement and to excite
            the group for congestion control feedback. A baseline NORM
            congestion control scheme (NORM-CC), based on the TCP-Friendly
            Multicast Congestion Control (TFMCC) scheme of <xref format="none"
            target="RFC4654">RFC 4654</xref> is fully specified in <xref
            target="CongestionControl"></xref> of this document. The <spanx
            style="verb">NORM_CMD(CC)</spanx> message is usually transmitted
            as part of NORM-CC congestion control operation. A NORM header
            extension is defined below to be used with the <spanx
            style="verb">NORM_CMD(CC)</spanx> message to support NORM-CC
            operation. Different header extensions MAY be defined for the
            <spanx style="verb">NORM_CMD(CC)</spanx> (and/or other NORM
            messages as needed) to support alternative congestion control
            schemes in the future. If NORM is operated in a network where
            resources are explicitly dedicated to the NORM session and
            therefore congestion control operation is disabled, the <spanx
            style="verb">NORM_CMD(CC)</spanx> message is then used solely for
            GRTT measurement and MAY be sent less frequently than with
            congestion control operation.</t>

            <figure align="center" title="NORM_CMD(CC) Message Format">
              <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |            sequence           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  sub-type = 4 |    reserved   |          cc_sequence          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         send_time_sec                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        send_time_usec                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  cc_node_list (if applicable)                 |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

            <t>The NORM common message header and standard <spanx
            style="verb">NORM_CMD</spanx> fields serve their usual purposes.
            The value of the "hdr_len" field when no header extensions are
            present is 6.</t>

            <t>The "reserved" field is for potential future use and MUST be
            set to <spanx style="verb">ZERO</spanx> in this version of the
            NORM protocol and its baseline NORM-CC congestion control scheme.
            It is possible for alternative congestion control schemes to use
            the <spanx style="verb">NORM_CMD(CC)</spanx> message defined here
            and leverage the "reserved" field for scheme-specific
            purposes.</t>

            <t>The "cc_sequence" field is a sequence number applied by the
            sender. For NORM-CC operation, it is used to provide functionality
            equivalent to the "feedback round number" (<spanx style="verb">fb_nr</spanx>)
            described in <xref format="none" target="RFC4654">RFC 4654</xref>.
            The most recently received "cc_sequence" value is recorded by
            receivers and can be fed back to the sender in congestion control
            feedback generated by the receivers for that sender. The
            "cc_sequence" number can also be used in NORM implementations to
            assess how recently a receiver has received <spanx style="verb">NORM_CMD(CC)</spanx>
            probes from the sender. This can be useful instrumentation for
            complex or experimental multicast routing environments.</t>

            <t>The "send_time" field is a timestamp indicating the time that
            the <spanx style="verb">NORM_CMD(CC)</spanx> message was
            transmitted. This consists of a 64-bit field containing 32-bits
            with the time in seconds ("send_time_sec") and 32-bits with the
            time in microseconds ("send_time_usec") since some reference time
            the source maintains (usually 00:00:00, 1 January 1970). The byte
            ordering of the fields is "Big Endian" network order. Receivers
            use this timestamp adjusted by the amount of delay from the time
            they received the <spanx style="verb">NORM_CMD(CC)</spanx> message
            to the time of their response as the "grtt_response" portion of
            <spanx style="verb">NORM_ACK</spanx> and <spanx style="verb">NORM_NACK</spanx>
            messages generated. This allows the sender to evaluate round-trip
            times to different receivers for congestion control and other
            (e.g., GRTT determination) purposes.</t>

            <t>To facilitate the baseline NORM-CC scheme described in <xref
            target="CongestionControl"></xref>, a NORM-CC Rate header
            extension (EXT_RATE) is defined to inform the group of the
            sender's current transmission rate. This is used along with the
            loss detection "sequence" field of all NORM sender messages and
            the <spanx style="verb">NORM_CMD(CC)</spanx> GRTT collection
            process to support NORM-CC congestion control operation. The
            format of this header extension is as follows:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    het = 128  |    reserved   |           send_rate           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

            <t>The "send_rate" field indicates the sender's current
            transmission rate in bytes per second. The 16-bit "send_rate"
            field consists of 12 bits of mantissa in the most significant
            portion and 4 bits of base 10 integer exponent (E) information in
            the least significant portion. The 12-bit mantissa portion of the
            field is scaled such that a base 10 mantissa (M) floating point
            value of 0.0 corresponds to 0 and a value of 10.0 corresponds to
            4096 in the upper 12 bits of the 16-bit "send_rate" field.
            Thus:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[
send_rate = (((int)(M * 4096.0 / 10.0 + 0.5)) << 4) | E;]]></artwork>
            </figure>

            <t>For example, to represent a transmission rate of 256kbps
            (3.2e+04 bytes per second), the lower 4 bits of the 16-bit field
            contain a value of 0x04 to represent the exponent (E) while the
            upper 12 bits contain a value of 0x51f (M) as determined from the
            equation given above:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[send_rate = (((int)((3.2 * 4096.0 / 10.0) + 0.5)) << 4) | 4;
          = (0x51f << 4) | 0x4
          = 0x51f4]]></artwork>
            </figure>

            <t>To decode the "send_rate" field, the following equation can be
            used:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[value = (send_rate >> 4) * (10/4096) * power(10, (send_rate & x000f))]]></artwork>
            </figure>

            <t>Note the maximum transmission rate that can be represented by
            this scheme is approximately 9.99e+15 bytes per second.</t>

            <t>When this extension is present, a "cc_node_list" might be
            attached as the payload of the <spanx style="verb">NORM_CMD(CC)</spanx>
            message. The presence of this header extension also implies that
            NORM receivers MUST respond according to the procedures described
            in <xref target="CongestionControl"></xref>.</t>

            <t>The "cc_node_list" consists of a list of <spanx style="emph">NormNodeIds</spanx>
            and their associated congestion control status. This includes the
            current limiting receiver (CLR) node, any potential limiting
            receiver (PLR) nodes that have been identified, and some number of
            receivers for which congestion control status is being provided,
            most notably including the receivers' current RTT measurement. The
            maximum length of the "cc_node_list" provides for at least the CLR
            and one other receiver, but can be increased for more timely
            feedback to the group. The list length can be inferred from the
            length of the <spanx style="verb">NORM_CMD(CC)</spanx>
            message.</t>

            <t>Each item in the "cc_node_list" is in the following format:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          cc_node_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    cc_flags   |     cc_rtt    |            cc_rate            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

            <t>The "cc_node_id" is the <spanx style="emph">NormNodeId</spanx>
            of the receiver the item represents.</t>

            <t>The "cc_flags" field contains flags indicating the congestion
            control status of the indicated receiver. The following flags are
            defined:</t>

            <texttable>
              <ttcol width="30%">Flag</ttcol>

              <ttcol align="center" width="10%">Value</ttcol>

              <ttcol width="60%">Purpose</ttcol>

              <c><spanx style="verb">NORM_FLAG_CC_CLR</spanx></c>

              <c>0x01</c>

              <c>Receiver is the current limiting receiver (CLR).</c>

              <c><spanx style="verb">NORM_FLAG_CC_PLR</spanx></c>

              <c>0x02</c>

              <c>Receiver is a potential limiting receiver (PLR).</c>

              <c><spanx style="verb">NORM_FLAG_CC_RTT</spanx></c>

              <c>0x04</c>

              <c>Receiver has measured RTT with respect to sender.</c>

              <c><spanx style="verb">NORM_FLAG_CC_START</spanx></c>

              <c>0x08</c>

              <c>Sender/receiver is in "slow start" phase of congestion
              control operation (i.e., The receiver has not yet detected any
              packet loss and the "cc_rate" field is the receiver's actual
              measured receive rate).</c>

              <c><spanx style="verb">NORM_FLAG_CC_LEAVE</spanx></c>

              <c>0x10</c>

              <c>Receiver is imminently leaving the session and its feedback
              SHOULD not be considered in congestion control operation.</c>
            </texttable>

            <t>The "cc_rtt" contains a quantized representation of the RTT as
            measured by the sender with respect to the indicated receiver.
            This field is valid only if the <spanx style="verb">NORM_FLAG_CC_RTT</spanx>
            flag is set in the "cc_flags" field. This one byte field is a
            quantized representation of the RTT using the algorithm described
            in the <xref target="RFC5401">Multicast NACK Building
            Block</xref>.</t>

            <t>The "cc_rate" field contains a representation of the receiver's
            current calculated (during steady-state congestion control
            operation) or twice its measured (during the <spanx style="emph">slow start</spanx>
            phase) congestion control rate. This field is encoded and decoded
            using the same technique as described for the <spanx style="verb">NORM_CMD(CC)</spanx>
            "send_rate" field.</t>
          </section>

          <section title="NORM_CMD(REPAIR_ADV) Message">
            <t>The <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx> message is
            used by the sender to "advertise" its aggregated repair state from
            <spanx style="verb">NORM_NACK</spanx> messages accumulated during
            a repair cycle and/or congestion control feedback received. This
            message is sent only when the sender has received <spanx
            style="verb">NORM_NACK</spanx> and/or <spanx style="verb">NORM_ACK(CC)</spanx>
            (when congestion control is enabled) messages via unicast
            transmission instead of multicast. By relaying this information to
            the receiver set, suppression of feedback can be achieved even
            when receivers are unicasting that feedback instead of
            multicasting it among the group <xref
            target="NormFeedback"></xref>.</t>

            <figure align="center" title="NORM_CMD(REPAIR_ADV) Message Format">
              <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| sub-type = 5  |     flags     |            reserved           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       repair_adv_payload                      |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

            <t>The "instance_id", "grtt", "backoff", "gsize", and "sub-type"
            fields serve the same purpose as in other <spanx style="verb">NORM_CMD</spanx>
            messages. The value of the "hdr_len" field when no extensions are
            present is 4.</t>

            <t>The "flags" field provide information on the <spanx
            style="verb">NORM_CMD(REPAIR_ADV)</spanx> content. There is
            currently one <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx>
            flag defined:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[NORM_REPAIR_ADV_FLAG_LIMIT = 0x01]]></artwork>
            </figure>

            <t>This flag is set by the sender when it is unable to fit its
            full current repair state into a single <spanx style="emph">NormSegmentSize</spanx>.
            If this flag is set, receivers SHALL limit their NACK response to
            generating NACK content only up through the maximum ordinal
            transmission position <spanx style="emph">(objectId::fecPayloadId)</spanx>
            included in the "repair_adv_content".</t>

            <t>When congestion control operation is enabled, a header
            extension SHOULD be applied to the <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx>
            representing the most limiting (in terms of congestion control
            feedback suppression) congestion control response. This allows the
            <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx> message to
            suppress receiver congestion control responses as well as NACK
            feedback messages. The field is defined as a header extension so
            that alternative congestion control schemes can be used for NORM
            without revision to this document. A NORM-CC Feedback Header
            Extension (EXT_CC) is defined to encapsulate congestion control
            feedback within <spanx style="verb">NORM_NACK</spanx>, <spanx
            style="verb">NORM_ACK</spanx>, and <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx>
            messages. If another congestion control technique (e.g., Pragmatic
            General Multicast Congestion Control (PGMCC) <xref
            target="PgmccPaper"></xref>) is used within a NORM implementation,
            an additional header extension MAY need to be defined encapsulate
            any required feedback content. The NORM-CC Feedback Header
            Extension format is:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     het = 3   |    hel = 3    |          cc_sequence          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    cc_flags   |     cc_rtt    |            cc_loss            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            cc_rate            |          cc_reserved          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

            <t>The "cc_sequence" field contains the current greatest
            "cc_sequence" value receivers have received in <spanx
            style="verb">NORM_CMD(CC)</spanx> messages from the sender. This
            information assists the sender in congestion control operation by
            providing an indicator of how current ("fresh") the receiver's
            round-trip measurement reference time is and whether the receiver
            has been successfully receiving recent congestion control probes.
            For example, if it is apparent the receiver has not been receiving
            recent congestion control probes (and thus possibly other messages
            from the sender), the sender SHOULD choose to take congestion
            avoidance measures. For <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx>
            messages, the sender SHALL set the "cc_sequence" field value to
            the value set in the last <spanx style="verb">NORM_CMD(CC)</spanx>
            message sent.</t>

            <t>The "cc_flags" field contains bits representing the receiver's
            state with respect to congestion control operation. The possible
            values for the "cc_flags" field are those specified for the <spanx
            style="verb">NORM_CMD(CC)</spanx> message node list item flags.
            These fields are used by receivers in controlling (suppressing as
            necessary) their congestion control feedback. For <spanx
            style="verb">NORM_CMD(REPAIR_ADV)</spanx> messages, the <spanx
            style="verb">NORM_FLAG_CC_RTT</spanx> SHALL be set <spanx
            style="emph">only</spanx> when <spanx style="emph">all</spanx>
            feedback messages received by the sender have the flag set.
            Similarly, the <spanx style="verb">NORM_FLAG_CC_CLR</spanx> or
            <spanx style="verb">NORM_FLAG_CC_PLR</spanx> SHALL be set only
            when <spanx style="emph">no</spanx> feedback has been received
            from non-CLR or non-PLR receivers. And the <spanx style="verb">NORM_FLAG_CC_LEAVE</spanx>
            SHALL be set only when all feedback messages the sender has
            received have this flag set. These heuristics for setting the
            flags in <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx> ensure
            the most effective suppression of receivers providing unicast
            feedback messages.</t>

            <t>The "cc_rtt" field SHALL be set to a default maximum value and
            the <spanx style="verb">NORM_FLAG_CC_RTT</spanx> flag SHALL be
            cleared when no receiver has yet received RTT measurement
            information. When a receiver has received RTT measurement
            information, it SHALL set the "cc_rtt" value accordingly and set
            the <spanx style="verb">NORM_FLAG_CC_RTT</spanx> flag in the
            "cc_flags" field. For <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx>
            messages, the sender SHALL set the "cc_rtt" field value to the
            largest non-CLR/non-PLR RTT it has measured from receivers for the
            current feedback round.</t>

            <t>The "cc_loss" field represents the receiver's current packet
            loss fraction estimate for the indicated source. The loss fraction
            is a value from 0.0 to 1.0 corresponding to a range of zero to 100
            percent packet loss. The 16-bit "cc_loss" value is calculated by
            the following formula:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[
"cc_loss" = floor(decimal_loss_fraction * 65535.0)]]></artwork>
            </figure>

            <t>For <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx> messages,
            the sender SHALL set the "cc_loss" field value to the largest
            non-CLR/non-PLR loss estimate it has received from receivers for
            the current feedback round.</t>

            <t>The "cc_rate" field represents the receivers current local
            congestion control rate. During "slow start", when the receiver
            has detected no loss, this value is set to twice the actual rate
            it has measured from the corresponding sender and the <spanx
            style="verb">NORM_FLAG_CC_START</spanx> is set in the "cc_flags'
            field. Otherwise, the receiver calculates a congestion control
            rate based on its loss measurement and RTT measurement information
            (even if default) for the "cc_rate" field. For <spanx
            style="verb">NORM_CMD(REPAIR_ADV)</spanx> messages, the sender
            SHALL set the "cc_loss" field value to the lowest non-CLR/non-PLR
            "cc_rate" report it has received from receivers for the current
            feedback round.</t>

            <t>The "cc_reserved" field is reserved for future NORM protocol
            use. Currently, senders SHALL set this field to <spanx
            style="verb">ZERO</spanx>, and receivers SHALL ignore the content
            of this field.</t>

            <t>The "repair_adv_payload" is in exactly the same form as the
            "nack_content" of <spanx style="verb">NORM_NACK</spanx> messages
            and can be processed by receivers for suppression purposes in the
            same manner, with the exception of the condition when the <spanx
            style="verb">NORM_REPAIR_ADV_FLAG_LIMIT</spanx> is set.</t>
          </section>

          <section title="NORM_CMD(ACK_REQ) Message">
            <t>The <spanx style="verb">NORM_CMD(ACK_REQ)</spanx> message is
            used by the sender to request acknowledgment from a specified list
            of receivers. This message is used in providing a lightweight
            positive acknowledgment mechanism that is OPTIONAL for use by the
            reliable multicast application. A range of acknowledgment request
            types is provided for use at the application's discretion.
            Provision for application-defined, positively-acknowledged
            commands allows the application to automatically take advantage of
            transmission and round-trip timing information available to the
            NORM protocol. The details of the NORM positive acknowledgment
            process including transmission of the <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>
            messages and the receiver response (<spanx style="verb">NORM_ACK</spanx>)
            are described in <xref target="PositiveAcknowledgment"></xref>.
            The format of the <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>
            message is:</t>

            <figure align="center" title="NORM_CMD(ACK_REQ) Message Format">
              <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| sub-type = 6  |    reserved   |    ack_type   |    ack_id     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       acking_node_list                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

            <t>The NORM common message header and standard <spanx
            style="verb">NORM_CMD</spanx> fields serve their usual purposes.
            The value of the "hdr_len" field for <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>
            messages with no header extension present is 4.</t>

            <t>The "ack_type" field indicates the type of acknowledgment being
            requested and thus implies rules for how the receiver will treat
            this request. The following "ack_type" values are defined and are
            also used in <spanx style="verb">NORM_ACK</spanx> messages
            described later:</t>

            <texttable>
              <ttcol width="30%">ACK Type</ttcol>

              <ttcol width="20%">Value</ttcol>

              <ttcol width="50%">Purpose</ttcol>

              <c><spanx style="verb">NORM_ACK_CC</spanx></c>

              <c>1</c>

              <c>Used to identify <spanx style="verb">NORM_ACK</spanx>
              messages sent in response to <spanx style="verb">NORM_CMD(CC)</spanx>
              messages.</c>

              <c><spanx style="verb">NORM_ACK_FLUSH</spanx></c>

              <c>2</c>

              <c>Used to identify <spanx style="verb">NORM_ACK</spanx>
              messages sent in response to <spanx style="verb">NORM_CMD(FLUSH)</spanx>
              messages.</c>

              <c><spanx style="verb">NORM_ACK_RESERVED</spanx></c>

              <c>3-15</c>

              <c>Reserved for possible future NORM protocol use.</c>

              <c><spanx style="verb">NORM_ACK_APPLICATION</spanx></c>

              <c>16-255</c>

              <c>Used at application's discretion.</c>
            </texttable>

            <t>The <spanx style="verb">NORM_ACK_CC</spanx> value is provided
            for use only in <spanx style="verb">NORM_ACKs</spanx> generated in
            response to the <spanx style="verb">NORM_CMD(CC)</spanx> messages
            used in congestion control operation. Similarly, the <spanx
            style="verb">NORM_ACK_FLUSH</spanx> is provided for use only in
            <spanx style="verb">NORM_ACKs</spanx> generated in response to
            applicable <spanx style="verb">NORM_CMD(FLUSH)</spanx> messages.
            <spanx style="verb">NORM_CMD</spanx>(ACK_REQ) messages with
            "ack_type" of <spanx style="verb">NORM_ACK_CC</spanx> or <spanx
            style="verb">NORM_ACK_FLUSH</spanx> SHALL NOT be generated by the
            sender.</t>

            <t>The <spanx style="verb">NORM_ACK_RESERVED</spanx> range of
            "ack_type" values is provided for possible future NORM protocol
            use.</t>

            <t>The <spanx style="verb">NORM_ACK_APPLICATION</spanx> range of
            "ack_type" values is provided so that NORM applications can
            implement application-defined, positively-acknowledged commands
            that are able to leverage internal transmission and round-trip
            timing information available to the NORM protocol
            implementation.</t>

            <t>The "ack_id" provides a sequenced identifier for the given
            <spanx style="verb">NORM_CMD(ACK_REQ)</spanx> message. This
            "ack_id" is returned in <spanx style="verb">NORM_ACK</spanx>
            messages generated by the receivers so that the sender can
            associate the response with its corresponding request.</t>

            <t>The "reserved" field is reserved for possible future protocol
            use and SHALL be set to <spanx style="verb">ZERO</spanx> by
            senders and ignored by receivers.</t>

            <t>The "acking_node_list" field contains the <spanx style="emph">NormNodeIds</spanx>
            of the current NORM receivers that are desired to provide positive
            acknowledge (<spanx style="verb">NORM_ACK</spanx>) to this
            request. The packet payload length implies the length of the
            "acking_node_list" and its length is limited to the sender <spanx
            style="emph">NormSegmentSize</spanx>. The individual <spanx
            style="emph">NormNodeId</spanx> items are listed in network (Big
            Endian) byte order. If a receiver's <spanx style="emph">NormNodeId</spanx>
            is included in the "acking_node_list", it SHALL schedule
            transmission of a <spanx style="verb">NORM_ACK</spanx> message as
            described in <xref target="PositiveAcknowledgment"></xref>.</t>
          </section>

          <section title="NORM_CMD(APPLICATION) Message">
            <t>This command allows the NORM application to robustly transmit
            application-defined commands. The command message preempts any
            ongoing data transmission and is repeated up to <spanx
            style="verb">NORM_ROBUST_FACTOR</spanx> times at a rate of once
            per <spanx style="verb">2*GRTT_sender</spanx>. This rate of
            repetition allows the application to observe any response (if that
            is the application's purpose for the command) before it is
            repeated. Possible responses can include initiation of data
            transmission, other <spanx style="verb">NORM_CMD(APPLICATION)</spanx>
            messages, or even application-defined, positively-acknowledge
            commands from other <spanx style="emph">NormSession</spanx>
            participants. The transmission of these commands will preempt data
            transmission when they are scheduled and can be multiplexed with
            ongoing data transmission. This type of robustly transmitted
            command allows NORM applications to define a complete set of
            session control mechanisms with less state than the transfer of
            FEC encoded reliable content needs while taking advantage of NORM
            transmission and round-trip timing information.</t>

            <figure align="center"
                    title="NORM_CMD(APPLICATION) Message Format">
              <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| sub-type = 7  |                    reserved                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Application-Defined Content                 |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
            </figure>

            <t>The NORM common message header and <spanx style="verb">NORM_CMD</spanx>
            fields are interpreted as previously described. The value of the
            <spanx style="verb">NORM_CMD(APPLICATION)</spanx> "hdr_len" field
            when no header extensions are present is 4.</t>

            <t>The "Application-Defined Content" area contains information in
            a format at the discretion of the application. The size of this
            payload SHALL be limited to a maximum of the sender's <spanx
            style="emph">NormSegmentSize</spanx> setting. Upon reception, the
            NORM protocol implementation SHALL deliver the content to the
            receiver application. Note that any detection of duplicate
            reception of a <spanx style="verb">NORM_CMD(APPLICATION)</spanx>
            message is the responsibility of the application.</t>
          </section>
        </section>
      </section>

      <section title="Receiver Messages">
        <t>The NORM message types generated by participating receivers consist
        of the <spanx style="verb">NORM_NACK</spanx> and <spanx style="verb">NORM_ACK</spanx>
        message types. <spanx style="verb">NORM_NACK</spanx> messages are sent
        to request repair of missing data content from sender transmission and
        <spanx style="verb">NORM_ACK</spanx> messages are generated in
        response to certain sender commands including <spanx style="verb">NORM_CMD(CC)</spanx>
        and <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>.</t>

        <section title="NORM_NACK Message">
          <t>The principal purpose of <spanx style="verb">NORM_NACK</spanx>
          messages is for receivers to request repair of sender content via
          selective, negative acknowledgment upon detection of incomplete
          data. <spanx style="verb">NORM_NACK</spanx> messages will be
          transmitted according to the rules of <spanx style="verb">NORM_NACK</spanx>
          generation and suppression described in <xref
          target="NackProcedure"></xref>. <spanx style="verb">NORM_NACK</spanx>
          messages also contain additional fields to provide feedback to the
          sender(s) for purposes of round-trip timing collection and
          congestion control.</t>

          <t>The payload of <spanx style="verb">NORM_NACK</spanx> messages
          contains one or more repair requests for different objects or
          portions of those objects. The <spanx style="verb">NORM_NACK</spanx>
          message format is as follows:</t>

          <figure align="center" title="NORM_NACK Message Format">
            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=4|    hdr_len    |            sequence           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           server_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           instance_id         |            reserved           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_sec                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_usec                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          nack_payload                         |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

          <t>The NORM common message header fields serve their usual purposes.
          The value of the "hdr_len" field for <spanx style="verb">NORM_NACK</spanx>
          messages without header extensions present is 6.</t>

          <t>The "server_id" field identifies the NORM sender to which the
          <spanx style="verb">NORM_NACK</spanx> message is destined.</t>

          <t>The "instance_id" field contains the current session identifier
          given by the sender identified by the "server_id" field in its
          sender messages. The sender SHOULD ignore feedback messages
          containing an invalid "instance_id" value.</t>

          <t>The "grtt_response" fields contain an adjusted version of the
          timestamp from the most recently received <spanx style="verb">NORM_CMD(CC)</spanx>
          message for the indicated NORM sender. The format of the
          "grtt_response" is the same as the "send_time" field of the <spanx
          style="verb">NORM_CMD(CC)</spanx>. The "grtt_response" value is
          relative to the "send_time" the source provided with a corresponding
          <spanx style="verb">NORM_CMD(CC)</spanx> command. The receiver
          adjusts the source's <spanx style="verb">NORM_CMD(CC)</spanx>
          "send_time" timestamp by adding the time delta from when the
          receiver received the <spanx style="verb">NORM_CMD(CC)</spanx> to
          when the <spanx style="verb">NORM_NACK</spanx> is transmitted in
          response to calculate the value in the "grtt_response" field. This
          is the "receive_to_response_delta" value used in the following
          formula:</t>

          <figure align="center">
            <artwork align="center"><![CDATA[grtt_response = NORM_CMD(CC) send_time + receive_to_response_delta]]></artwork>
          </figure>

          <t>The receiver SHALL set the "grtt_response" to a <spanx
          style="verb">ZERO</spanx> value, to indicate it has not yet received
          a <spanx style="verb">NORM_CMD(CC)</spanx> message from the
          indicated sender and the sender MUST ignore the "grtt_response" in
          this message.</t>

          <t>For NORM-CC operation, the NORM-CC Feedback Header Extension, as
          described in the <spanx style="verb">NORM_CMD(REPAIR_ADV}</spanx>
          message description, is added to <spanx style="verb">NORM_NACK</spanx>
          messages to provide feedback on the receivers current state with
          respect to congestion control operation. Alternative header
          extensions for congestion control feedback MAY be defined for
          alternative congestion control schemes for NORM use in the
          future.</t>

          <t>The "reserved" field is for potential future NORM use and SHALL
          be set to <spanx style="verb">ZERO</spanx> for this version of the
          protocol.</t>

          <t>The "nack_payload" of the <spanx style="verb">NORM_NACK</spanx>
          message specifies the repair needs of the receiver with respect to
          the NORM sender indicated by the "server_id" field. The receiver
          constructs repair requests based on the <spanx style="verb">NORM_DATA</spanx>
          and/or <spanx style="verb">NORM_INFO</spanx> segments it needs from
          the sender to complete reliable reception up to the sender's
          transmission position at the moment the receiver initiates the NACK
          Procedure as described in <xref target="NackProcedure"></xref>. A
          single NORM Repair Request consists of a list of items, ranges,
          and/or FEC coding block erasure counts for needed <spanx
          style="verb">NORM_DATA</spanx> and/or <spanx style="verb">NORM_INFO</spanx>
          content. Multiple repair requests can be concatenated within the
          "nack_payload" field of a <spanx style="verb">NORM_NACK</spanx>
          message. A single NORM Repair Request can possibly include multiple
          "items", "ranges", or "erasure_counts". In turn, the "nack_payload"
          field MAY contain multiple repair requests. A single NORM Repair
          Request has the following format:</t>

          <figure align="center" title="NORM Repair Request Format">
            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      form     |     flags     |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      repair_request_items                     |
|                             ...                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure>

          <t>The "form" field indicates the type of repair request items given
          in the "repair_request_items" list. Possible values for the "form"
          field include:</t>

          <texttable align="center">
            <ttcol>Form</ttcol>

            <ttcol align="center">Value</ttcol>

            <c><spanx style="verb">NORM_NACK_ITEMS</spanx></c>

            <c>1</c>

            <c><spanx style="verb">NORM_NACK_RANGES</spanx></c>

            <c>2</c>

            <c><spanx style="verb">NORM_NACK_ERASURES</spanx></c>

            <c>3</c>
          </texttable>

          <t>A "form" value of <spanx style="verb">NORM_NACK_ITEMS</spanx>
          indicates each repair request item in the "repair_request_items"
          list is to be treated as an individual request. A value of <spanx
          style="verb">NORM_NACK_RANGES</spanx> indicates the
          "repair_request_items" list consists of <spanx style="emph">pairs</spanx>
          of repair request items corresponding to the inclusive ranges of
          repair needs. And the <spanx style="verb">NORM_NACK_ERASURES</spanx>
          "form" indicates the repair request items are to be treated
          individually and the "encoding_symbol_id" portion of the
          "fec_payload_id" field of the repair request item (see below) is to
          be interpreted as an erasure count for the FEC coding block
          identified by the repair request item's "source_block_number".</t>

          <t>The "flags" field is currently used to indicate the level of data
          content for which the repair request items apply (i.e., an
          individual segment, entire FEC coding block, or entire transport
          object). Possible flag values include:</t>

          <texttable>
            <ttcol width="30%">Flag</ttcol>

            <ttcol align="center" width="10%">Value</ttcol>

            <ttcol width="60%">Purpose</ttcol>

            <c><spanx style="verb">NORM_NACK_SEGMENT</spanx></c>

            <c>0x01</c>

            <c>Indicates the listed segment(s) or range of segments needed as
            repair.</c>

            <c><spanx style="verb">NORM_NACK_BLOCK</spanx></c>

            <c>0x02</c>

            <c>Indicates the listed block(s) or range of blocks in entirety
            are needed as repair.</c>

            <c><spanx style="verb">NORM_NACK_INFO</spanx></c>

            <c>0x04</c>

            <c>Indicates <spanx style="verb">NORM_INFO</spanx> is needed as
            repair for the listed object(s).</c>

            <c><spanx style="verb">NORM_NACK_OBJECT</spanx></c>

            <c>0x08</c>

            <c>Indicates the listed object(s) or range of objects in entirety
            are needed as repair.</c>
          </texttable>

          <t>When the <spanx style="verb">NORM_NACK_SEGMENT</spanx> flag is
          set, the "object_transport_id" and "fec_payload_id" fields are used
          to determine which sets or ranges of individual <spanx style="verb">NORM_DATA</spanx>
          segments are needed to repair content at the receiver. When the
          <spanx style="verb">NORM_NACK_BLOCK</spanx> flag is set, this
          indicates the receiver is completely missing the indicated coding
          block(s) and transmissions sufficient to repair the indicated
          block(s) in their entirety are needed. When the <spanx style="verb">NORM_NACK_INFO</spanx>
          flag is set, this indicates the receiver is missing the <spanx
          style="verb">NORM_INFO</spanx> segment for the indicated
          "object_transport_id". Note the <spanx style="verb">NORM_NACK_INFO</spanx>
          can be set in combination with the <spanx style="verb">NORM_NACK_BLOCK</spanx>
          or <spanx style="verb">NORM_NACK_SEGMENT</spanx> flags, or can be
          set alone. When the <spanx style="verb">NORM_NACK_OBJECT</spanx>
          flag is set, this indicates the receiver is missing the entire
          <spanx style="emph">NormTransportObject</spanx> referenced by the
          "object_transport_id". This also implicitly requests any available
          <spanx style="verb">NORM_INFO</spanx> for the <spanx style="emph">NormObject</spanx>,
          if applicable. The "fec_payload_id" field is ignored when the flag
          <spanx style="verb">NORM_NACK_OBJECT</spanx> is set.</t>

          <t>The "length" field value is the length in bytes of the
          "repair_request_items" field.</t>

          <t>The "repair_request_items" field consists of a list of individual
          or range pairs of transport data unit identifiers in the following
          format.</t>

          <figure align="center" title="NORM Repair Request Item Format">
            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     fec_id    |   reserved    |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        fec_payload_id                         |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

          <t>The "fec_id" indicates the FEC type and can be used to determine
          the format of the "fec_payload_id" field. The "reserved" field is
          kept for possible future use and SHALL be set to a <spanx
          style="verb">ZERO</spanx> value and ignored by NORM nodes processing
          NACK content.</t>

          <t>The "object_transport_id" corresponds to the <spanx style="emph">NormObject</spanx>
          for which repair is being requested and the "fec_payload_id"
          identifies the specific FEC coding block and/or segment being
          requested. When the <spanx style="verb">NORM_NACK_OBJECT</spanx>
          flag is set, the value of the "fec_payload_id" field is ignored.
          When the <spanx style="verb">NORM_NACK_BLOCK</spanx> flag is set,
          only the FEC code block identifier portion of the "fec_payload_id"
          is to be interpreted.</t>

          <t>The format of the "fec_payload_id" field depends upon the
          "fec_id" field value.</t>

          <t>When the receiver's repair needs dictate that different forms
          (mixed ranges and/or individual items) or types (mixed specific
          segments and/or blocks or objects in entirety) are needed to
          complete reliable transmission, multiple NORM Repair Requests with
          different "form" and or "flags" values can be concatenated within a
          single <spanx style="verb">NORM_NACK</spanx> message. Additionally,
          NORM receivers SHALL construct <spanx style="verb">NORM_NACK</spanx>
          messages with their repair requests in ordinal order with respect to
          "object_transport_id" and "fec_payload_id" values. The
          "nack_payload" size SHALL NOT exceed the <spanx style="emph">NormSegmentSize</spanx>
          for the sender to which the <spanx style="verb">NORM_NACK</spanx> is
          destined.</t>

          <t><spanx style="strong">NORM_NACK Content Examples:</spanx></t>

          <t>In these examples, a small block, systematic FEC code ("fec_id" =
          129) is assumed with a user data block length of 32 segments. In
          Example 1, a list of individual <spanx style="verb">NORM_NACK_ITEMS</spanx>
          repair requests is given. In Example 2, a list of <spanx
          style="verb">NORM_NACK_RANGES</spanx> requests AND a single <spanx
          style="verb">NORM_NACK_ITEMS</spanx> request are concatenated to
          illustrate the possible content of a <spanx style="verb">NORM_NACK</spanx>
          message. Note that FEC coding block erasure counts could also be
          provided in each case. However, the erasure counts are not really
          necessary since the sender can easily determine the erasure count
          while processing the NACK content. However, the erasure count option
          can be useful for operation with other FEC codes or for intermediate
          system purposes.</t>

          <figure align="center">
            <preamble>Example 1: <spanx style="verb">NORM_NACK</spanx>
            "nack_payload" for: Object 12, Coding Block 3, Segments 2,5,and
            8</preamble>

            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   form = 1    | flags = 0x01  |       length  = 36            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 12   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 3                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 2     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 12   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 3                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 5     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 12   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 3                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 8     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

          <figure align="center">
            <preamble>Example 2: <spanx style="verb">NORM_NACK</spanx>
            "nack_payload" for: Object 18, Coding Block 6, Segments 5, 6, 7,
            8, 9, 10; and Object 19 <spanx style="verb">NORM_INFO</spanx> and
            Coding Block 1, segment 3</preamble>

            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   form = 2    | flags = 0x01  |       length  = 24            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 18   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 6                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 5     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 18   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 6                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 10    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   form = 1    | flags = 0x05  |       length  = 12            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 19   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 1                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 3     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>
        </section>

        <section title="NORM_ACK Message">
          <t>The <spanx style="verb">NORM_ACK</spanx> message is intended to
          be used primarily as part of NORM congestion control operation and
          round-trip timing measurement. The acknowledgment type <spanx
          style="verb">NORM_ACK_CC</spanx> is provided for this purpose as
          described in the <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>
          message description. The generation of <spanx style="verb">NORM_ACK(CC)</spanx>
          messages for round-trip timing estimation and congestion-control
          operation is described in <xref target="GrttCollection"></xref> and
          <xref target="CongestionControl"></xref>, respectively. However,
          some multicast applications can benefit from some limited form of
          positive acknowledgment for certain functions. A simple, scalable
          positive acknowledgment scheme is defined in <xref
          target="PositiveAcknowledgment"></xref> that can be leveraged by
          protocol implementations when appropriate. The <spanx style="verb">NORM_CMD(FLUSH)</spanx>
          can also be used for OPTIONAL collection of positive acknowledgment
          of reliable reception to a certain "watermark" transmission point
          from specific receivers using this mechanism. The <spanx
          style="verb">NORM_ACK</spanx> type <spanx style="verb">NORM_ACK_FLUSH</spanx>
          is provided for this purpose and the format of the "nack_payload"
          for this acknowledgment type is given below. Beyond that, a range of
          application-defined "ack_type" values is provided for use at the
          NORM application's discretion. Implementations making use of
          application-defined positive acknowledgments MAY also make use the
          "nack_payload" as needed, observing the constraint that the
          "nack_payload" field size be limited to a maximum of the <spanx
          style="emph">NormSegmentSize</spanx> for the sender to which the
          <spanx style="verb">NORM_ACK</spanx> is destined.</t>

          <figure align="center" title="NORM_ACK Message Format">
            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=5|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           server_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           instance_id         |    ack_type  |     ack_id     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_sec                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_usec                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   ack_payload (if applicable)                 |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

          <t>The NORM common message header fields serve their usual purposes.
          The value of the "hdr_len" field when no header extensions are
          present is 6.</t>

          <t>The "server_id", "instance_id", and "grtt_response" fields serve
          the same purpose as the corresponding fields in <spanx style="verb">NORM_NACK</spanx>
          messages. And header extensions can be applied to support congestion
          control feedback or other functions in the same manner.</t>

          <t>The "ack_type" field indicates the nature of the <spanx
          style="verb">NORM_ACK</spanx> message. This directly corresponds to
          the "ack_type" field of the <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>
          message to which this acknowledgment applies.</t>

          <t>The "ack_id" field serves as a sequence number so the sender can
          verify a received <spanx style="verb">NORM_ACK</spanx> message
          actually applies to a current acknowledgment request. The "ack_id"
          field is not used in the case of the <spanx style="verb">NORM_ACK_CC</spanx>
          and <spanx style="verb">NORM_ACK_FLUSH</spanx> acknowledgment
          types.</t>

          <t>The "ack_payload" format is a function of the "ack_type". The
          <spanx style="verb">NORM_ACK_CC</spanx> message has no attached
          content. Only the <spanx style="verb">NORM_ACK</spanx> header
          applies. In the case of <spanx style="verb">NORM_ACK_FLUSH</spanx>,
          a specific "ack_payload" format is defined:</t>

          <figure align="center">
            <artwork align="center"><![CDATA[ 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     fec_id    |   reserved    |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        fec_payload_id                         |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
          </figure>

          <t>The "object_transport_id" and "fec_payload_id" are used by the
          receiver to acknowledge applicable <spanx style="verb">NORM_CMD(FLUSH)</spanx>
          messages transmitted by the sender identified by the "server_id"
          field.</t>

          <t>The "ack_payload" of <spanx style="verb">NORM_ACK</spanx>
          messages for application-defined "ack_type" values is specific to
          the application but is limited in size to a maximum the <spanx
          style="emph">NormSegmentSize</spanx> of the sender referenced by the
          "server_id".</t>
        </section>
      </section>

      <section title="General Purpose Messages">
        <t>Some additional message formats are defined for general purpose in
        NORM multicast sessions whether the participant is acting as a sender
        and/or receiver within the group.</t>

        <section title="NORM_REPORT Message">
          <t>This is an OPTIONAL message generated by NORM participants. This
          message can be used for periodic performance reports from receivers
          in experimental NORM implementations. The format of this message is
          currently undefined. Experimental NORM implementations MAY define
          <spanx style="verb">NORM_REPORT</spanx> formats as needed for test
          purposes. These report messages SHOULD be disabled for
          interoperability testing between different compliant NORM
          implementations.</t>
        </section>
      </section>
    </section>

    <section anchor="ProtocolDetails" title="Detailed Protocol Operation">
      <t>This section describes the detailed interactions of senders and
      receivers participating in a NORM session. A simple synopsis of protocol
      operation is given here:</t>

      <t><list style="numbers">
          <t>The sender periodically transmits <spanx style="verb">NORM_CMD(CC)</spanx>
          messages as needed to initialize and collect round-trip timing and
          congestion control feedback from the receiver set.</t>

          <t>The sender transmits an ordinal set of <spanx style="emph">NormObjects</spanx>
          segmented in the form of <spanx style="verb">NORM_DATA</spanx>
          messages labeled with <spanx style="emph">NormTransportIds</spanx>
          and logically identified with FEC encoding block numbers and symbol
          identifiers. <spanx style="verb">When applicable, NORM_INFO</spanx>
          messages MAY optionally precede the transmission of data content for
          NORM transport objects.</t>

          <t>As receivers detect missing content from the sender, they
          initiate repair requests with <spanx style="verb">NORM_NACK</spanx>
          messages. The receivers track the sender's most recent <spanx
          style="emph">objectId::fecPayloadId</spanx> transmit position and
          NACK only for content that is ordinally prior to that current
          transmit position. The receivers schedule random backoff timeouts
          before generating <spanx style="verb">NORM_NACK</spanx> messages and
          wait an appropriate amount of time before repeating the <spanx
          style="verb">NORM_NACK</spanx> if their repair request is not
          satisfied.</t>

          <t>The sender aggregates repair requests from the receivers and
          logically "rewinds" its transmit position to send appropriate repair
          messages. The sender sends repairs for the earliest ordinal transmit
          position first and maintains this ordinal repair transmission
          sequence. FEC parity content not previously transmitted for the
          applicable FEC coding block is used for repair transmissions to the
          greatest extent possible. If the sender exhausts its available FEC
          parity content on multiple repair cycles for the same coding block,
          it resorts to an explicit repair strategy (possibly using parity
          content) to complete repairs. (The use of explicit repair is an
          exception in general protocol operation, but the possibility does
          exist for extreme conditions). The sender immediately assumes
          transmission of new content once it has sent pending repairs.</t>

          <t>The sender transmits <spanx style="verb">NORM_CMD(FLUSH)</spanx>
          messages when it reaches the end of enqueued transmit content and
          pending repairs. Receivers respond to the <spanx style="verb">NORM_CMD(FLUSH)</spanx>
          messages with <spanx style="verb">NORM_NACK</spanx> transmissions
          (following the same suppression backoff timeout strategy as for
          data) if they need further repair.</t>

          <t>The sender transmissions are subject to rate control limits
          determined by congestion control mechanisms. In the baseline NORM-CC
          operation, each sender in a <spanx style="emph">NormSession</spanx>
          maintains its own independent congestion control state. Receivers
          provide congestion control feedback in <spanx style="verb">NORM_NACK</spanx>
          and <spanx style="verb">NORM_ACK</spanx> messages. <spanx
          style="verb">NORM_ACK</spanx> feedback for congestion control
          purposes is governed using a suppression mechanism similar to that
          for <spanx style="verb">NORM_NACK</spanx> messages.</t>
        </list></t>

      <t>While this overall concept is relatively simple, there are details to
      each of these aspects that need to be addressed for successful,
      efficient, robust, and scalable NORM protocol operation.</t>

      <section title="Sender Initialization and Transmission">
        <t>Upon startup, the NORM sender immediately begins sending <spanx
        style="verb">NORM_CMD(CC)</spanx> messages to collect round trip
        timing and other information from the potential group. If NORM-CC
        congestion control operation is enabled, the NORM-CC Rate header
        extension MUST be included in these messages. Congestion control
        operation SHALL be observed at all times when not operating using
        dedicated resources, like in the general Internet. Even if congestion
        control operation is disabled at the sender, it can be desirable to
        use the <spanx style="verb">NORM_CMD(CC)</spanx> messaging to collect
        feedback from the group using the baseline NORM-CC feedback
        mechanisms. This proactive feedback collection can be used to
        establish a GRTT estimate prior to data transmission and potential
        NACK operation.</t>

        <t>In some cases, applications might need the sender to also proceed
        with data transmission immediately. In other cases, the sender might
        wish to defer data transmission until it has received some feedback or
        request from the receiver set indicating receivers are indeed present.
        Note, in some applications (e.g., web push), this indication MAY come
        out-of-band with respect to the multicast session via other means. As
        noted, the periodic transmission of <spanx style="verb">NORM_CMD(CC)</spanx>
        messages MAY precede actual data transmission in order to have an
        initial GRTT estimate.</t>

        <t>With inclusion of the OPTIONAL NORM FEC Object Transmission
        Information Header Extension (EXT_FTI), the NORM protocol sender
        message headers can contain all information necessary to prepare
        receivers for subsequent reliable reception. This includes FEC coding
        parameters, the sender <spanx style="emph">NormSegmentSize</spanx>,
        and other information. If this header extension is not used, it is
        presumed receivers have received the FEC Object Transmission
        Information via other means. Additionally, applications MAY leverage
        the use of <spanx style="verb">NORM_INFO</spanx> messages associated
        with the session data objects in the session to provide
        application-specific context information for the session and data
        being transmitted. These mechanisms allow for operation with minimal
        pre-coordination among the senders and receivers.</t>

        <t>The NORM sender begins segmenting application-enqueued data into
        <spanx style="verb">NORM_DATA</spanx> segments and transmitting it to
        the group. For objects of type <spanx style="verb">NORM_OBJECT_DATA</spanx>
        and <spanx style="verb">NORM_OBJECT_FILE</spanx>, the segmentation
        algorithm described in <xref target="RFC5052">FEC Building
        Block</xref> is RECOMMENDED. For objects of type <spanx style="verb">NORM_OBJECT_STREAM</spanx>,
        segmentation will typically be into uniform FEC coding block sizes,
        with individual segment sizes controlled by the application. In most
        cases, the application and NORM implementation SHOULD strive to
        produce full-sized (<spanx style="verb">NormSegmentSize</spanx>)
        segments when possible. The rate of transmission is controlled via
        congestion control mechanisms or is a fixed rate if desired for closed
        network operations. The receivers participating in the multicast group
        provide feedback to the sender as needed. When the sender reaches the
        end of data it has enqueued for transmission or any pending repairs,
        it transmits a series of <spanx style="verb">NORM_CMD(FLUSH)</spanx>
        messages at a rate of one per <spanx style="verb">2*GRTT_sender</spanx>.
        Similar to end of each transmitted FEC coding block during
        transmission, receivers SHALL respond to these <spanx style="verb">NORM_CMD(FLUSH)</spanx>
        messages with additional repair requests as needed. A protocol
        parameter "<spanx style="verb">NORM_ROBUST_FACTOR</spanx>" determines
        the number of flush messages sent. If receivers request repair, the
        repair is provided and flushing occurs again at the end of repair
        transmission. The sender MAY attach an OPTIONAL "acking_node_list" to
        <spanx style="verb">NORM_CMD(FLUSH)</spanx> containing the <spanx
        style="emph">NormNodeIds</spanx> for receivers from which it expects
        explicit positive acknowledgment of reception. The <spanx
        style="verb">NORM_CMD(FLUSH)</spanx> message MAY be also used for this
        OPTIONAL purpose any time prior to the end of data enqueued for
        transmission with the <spanx style="verb">NORM_CMD(FLUSH)</spanx>
        messages multiplexed with ongoing data transmissions. The OPTIONAL
        NORM positive acknowledgment procedure is described in <xref
        target="PositiveAcknowledgment"></xref>.</t>

        <section anchor="SegmentationAlgorithm"
                 title="Object Segmentation Algorithm">
          <t>NORM senders and receivers MUST use a common algorithm for
          logically segmenting transport data into FEC encoding blocks and
          symbols so appropriate NACKs can be constructed to request repair of
          missing data. NORM FEC coding blocks are comprised of multi-byte
          symbols (segments) transmitted in the payload of <spanx
          style="verb">NORM_DATA</spanx> messages. Each <spanx style="verb">NORM_DATA</spanx>
          message will contain one or more source or encoding symbol(s)
          identified by the "fec_payload_id" field and the <spanx
          style="emph">NormSegmentSize</spanx> sender parameter defines the
          maximum size (in bytes) of the "payload_data" field containing the
          content (a "segment"). The FEC encoding type and associated
          parameters govern the source block size (number of source symbols
          per coding block, etc.). NORM senders and receivers use these FEC
          parameters, along with the <spanx style="emph">NormSegmentSize</spanx>
          and transport object size to compute the source block structure for
          transport objects. These parameters are provided in the FEC Object
          Transmission Information for each object. The block partitioning
          algorithm described in the <xref target="RFC5052">FEC Building
          Block</xref> is RECOMMENDED for use to compute a source block
          structure such that all source blocks are as close to being equal
          length as possible. This helps avoid the performance disadvantages
          of "short" FEC blocks. Note this algorithm applies only to the
          statically-sized <spanx style="verb">NORM_OBJECT_DATA</spanx> and
          <spanx style="verb">NORM_OBJECT_FILE</spanx> transport object types
          where the object size is fixed and predetermined. For <spanx
          style="verb">NORM_OBJECT_STREAM</spanx> objects, the object is
          segmented according to the maximum source block length given in the
          FEC Transmission Information, unless the FEC Payload ID indicates an
          alternative size for a given block.</t>
        </section>
      </section>

      <section anchor="ReceiverInitialization"
               title="Receiver Initialization and Reception">
        <t>For typical operation, NORM receivers will join a specified
        multicast group and listen on an specific port number for sender
        transmissions. As the NORM receiver receives <spanx style="verb">NORM_DATA</spanx>
        messages it will establish buffering state and provide content to its
        application as appropriate for the given data type. The NORM protocol
        allows receivers to join and leave the group at will although some
        applications might need receivers to be members of the group prior to
        start of data transmission. Thus, different NORM applications MAY use
        different policies to constrain the impact of new receivers joining
        the group in the middle of a session. For example, a useful
        implementation policy is for new receivers joining the group to limit
        or avoid repair requests for transport objects already in progress.
        The NORM sender implementation MAY impose additional constraints to
        limit the ability of receivers to disrupt reliable multicast
        performance by joining, leaving, and rejoining the group often.
        Different receiver "join policies" might be appropriate for different
        applications and/or scenarios. For general purpose operation, a
        default policy where receivers are allowed to request repair only for
        coding blocks with a <spanx style="emph">NormTransportId</spanx> and
        FEC coding block number greater than or equal to the first non-repair
        <spanx style="verb">NORM_DATA</spanx> or <spanx style="verb">NORM_INFO</spanx>
        message received upon joining the group is RECOMMENDED. For objects of
        type <spanx style="verb">NORM_OBJECT_STREAM</spanx> it is RECOMMENDED
        the join policy constrain receivers to start reliable reception at the
        current FEC coding block for which non-repair content is received.</t>

        <t>In some deployments, different multicast receivers might have
        differing quality of network connectivity. Some receivers may suffer
        significantly poorer performance with very limited goodput due to low
        connection rate or substantial packet loss. Similar to the "join
        policies" described above, a NORM sender implementation MAY choose to
        enforce different "service policies" to perhaps exclude exceptionally
        poor-performing (or otherwise badly-behaving) receivers from the
        group. The sender implementation could choose to ignore NACKs from
        such receivers and/or force advancement of its logical "repair window"
        (i.e. enforcing a minimal level of service) and use the <spanx
        style="verb">NORM_CMD(SQUELCH)</spanx> message to advise those poor
        performers of its advance. Note in some cases, the application may
        need to support the "weakest member" regardless of the time needed to
        achieve reliable delivery. When implemented, the protocol
        instantiation SHOULD expose controls to the set of "join" and/or
        "service" policies available to support the needs of different
        applications.</t>
      </section>

      <section anchor="NackProcedure" title="Receiver NACK Procedure">
        <t>When the receiver detects it is missing data from a sender's NORM
        transmissions, it initiates its NACKing procedure. The NACKing
        procedure SHALL be initiated <spanx style="emph">only</spanx> at FEC
        coding block boundaries, <spanx style="emph">NormObject</spanx>
        boundaries, upon receipt of a <spanx style="verb">NORM_CMD(FLUSH)</spanx>
        message, or upon an "inactivity" timeout when <spanx style="verb">NORM_DATA</spanx>
        or <spanx style="verb">NORM_INFO</spanx> transmissions are no longer
        received from a previously active sender. The RECOMMENDED value of
        such an inactivity timeout is:</t>

        <figure align="center">
          <artwork align="center"><![CDATA[T_inactivity = NORM_ROBUST_FACTOR * 2 * GRTT_sender]]></artwork>
        </figure>

        <t>where the "<spanx style="verb">GRTT_sender</spanx>" value
        corresponds to the GRTT estimate advertised in the "grtt" field of
        NORM sender messages. A minimum "<spanx style="verb">T_inactivity</spanx>"
        value of 1 second is RECOMMENDED. The NORM receiver SHOULD reset this
        inactivity timer and repeat NACK initiation upon timeout for up to
        <spanx style="verb">NORM_ROBUST_FACTOR</spanx> times or more depending
        upon the application's need for persistence by its receivers. It is
        also important receivers rescale the "<spanx style="verb">T_inactivity</spanx>"
        timeout as the sender's advertised GRTT changes.</t>

        <t>The NACKing procedure begins with a random backoff timeout. The
        duration of the backoff timeout is chosen using the "RandomBackoff"
        algorithm described in the <xref target="RFC5401">Multicast NACK
        Building Block</xref> using (<spanx style="verb">K_sender*GRTT_sender</spanx>)
        for the <spanx style="verb">maxTime</spanx> parameter and the sender
        advertised group size (<spanx style="verb">GSIZEsender</spanx>) as the
        <spanx style="verb">groupSize</spanx> parameter. NORM senders provide
        values for <spanx style="verb">GRTT_sender</spanx>, <spanx
        style="verb">K_sender</spanx> and <spanx style="verb">GSIZE_sender</spanx>
        via the "grtt", "backoff", and "gsize" fields of transmitted messages.
        The <spanx style="verb">GRTT_sender</spanx> value is determined by the
        sender based on feedback it has received from the group while the
        <spanx style="verb">K_sender</spanx> and <spanx style="verb">GSIZE_sender</spanx>
        values can be determined by application requirements and expectations
        or ancillary information. The backoff factor "<spanx style="verb">K_sender</spanx>"
        MUST be greater than <spanx style="verb">one</spanx> to provide for
        effective feedback suppression. A value of <spanx style="verb">K_sender = 4</spanx>
        is RECOMMENDED for the Any Source Multicast (ASM) model while a value
        of <spanx style="verb">K_sender = 6</spanx> is RECOMMENDED for Single
        Source Multicast (SSM) operation.</t>

        <t>Thus:</t>

        <figure align="center">
          <artwork align="center"><![CDATA[T_backoff = RandomBackoff(K_sender*GRTT_sender, GSIZE_sender)]]></artwork>
        </figure>

        <t>To avoid the possibility of NACK implosion in the case of sender or
        network failure during SSM operation, the receiver SHALL automatically
        suppress its NACK and immediately enter the "holdoff" period described
        below when <spanx style="verb">T_backoff</spanx> is greater than
        <spanx style="verb">(K_sender-1)*GRTT_sender</spanx>. Otherwise, the
        backoff period is entered and the receiver MUST accumulate external
        pending repair state from <spanx style="verb">NORM_NACK</spanx>
        messages and <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx> messages
        received. At the end of the backoff time, the receiver SHALL generate
        a <spanx style="verb">NORM_NACK</spanx> message only if the following
        conditions are met:</t>

        <t><list style="numbers">
            <t>The sender's current transmit position (in terms of <spanx
            style="emph">objectId::fecPayloadId</spanx>) exceeds the earliest
            repair position of the receiver.</t>

            <t>The repair state accumulated from <spanx style="verb">NORM_NACK</spanx>
            and <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx> messages do
            not equal or supersede the receiver's repair needs up to the
            sender transmission position at the time the NACK procedure
            (backoff timeout) was initiated.</t>
          </list></t>

        <t>If these conditions are met, the receiver immediately generates a
        <spanx style="verb">NORM_NACK</spanx> message when the backoff timeout
        expires. Otherwise, the receiver's NACK is considered to be
        "suppressed" and the message is not sent. At this time, the receiver
        begins a "holdoff" period during which it constrains itself to not
        re-initiate the NACKing process. The purpose of this timeout is to
        allow the sender worst-case time to respond to the repair needs before
        the receiver requests repair again. The value of this "holdoff"
        timeout (<spanx style="verb">T_rcvrHoldoff</spanx>) as described in
        <xref target="RFC5401"></xref> is:</t>

        <figure align="center">
          <artwork align="center"><![CDATA[T_rcvrHoldoff =(K_sender+2)*GRTT_sender]]></artwork>
        </figure>

        <t>The <spanx style="verb">NORM_NACK</spanx> message contains repair
        request content beginning with lowest ordinal repair position of the
        receiver up through the coding block prior to the most recently heard
        ordinal transmission position for the sender. If the size of the
        <spanx style="verb">NORM_NACK</spanx> content exceeds the sender's
        <spanx style="emph">NormSegmentSize</spanx>, the NACK content is
        truncated so the receiver only generates a single <spanx style="verb">NORM_NACK</spanx>
        message per NACK cycle for a given sender. In summary, a single NACK
        message is generated containing the receiver's lowest ordinal repair
        needs.</t>

        <t>For each partially-received FEC coding block requiring repair, the
        receiver SHALL, on its FIRST repair attempt for the block, request the
        parity portion of the FEC coding block beginning with the lowest
        ordinal parity "encoding_symbol_id" (i.e., "encoding_symbol_id" =
        "source_block_len") and request the number of FEC symbols
        corresponding to its data segment erasure count for the block. On
        subsequent repair cycles for the same coding block, the receiver SHALL
        request only those repair symbols from the first set it has not yet
        received up to the remaining erasure count for that applicable coding
        block. Note the sender might have transmitted other different,
        additional parity segments for other receivers that could also be used
        to satisfy the local receiver's erasure-filling needs. In the case
        where the erasure count for a partially-received FEC coding block
        exceeds the maximum number of parity symbols available from the sender
        for the block (as indicated by the <spanx style="verb">NORM_DATA</spanx>
        "fec_num_parity" field), the receiver SHALL request all available
        parity segments plus the ordinally highest missing data segments
        needed to satisfy its total erasure needs for the block. The goal of
        this strategy is for the overall receiver set to request a lowest
        common denominator set of repair symbols for a given FEC coding block.
        This allows the sender to construct the most efficient repair
        transmission segment set and enables effective NACK suppression among
        the receivers even with uncorrelated packet loss. This approach also
        does not demand synchronization among the receiver set in their repair
        requests for the sender.</t>

        <t>For FEC coding blocks or <spanx style="emph">NormObjects</spanx>
        missed in their entirety, the NORM receiver constructs repair requests
        with <spanx style="verb">NORM_NACK_BLOCK</spanx> or <spanx
        style="verb">NORM_NACK_OBJECT</spanx> flags set as appropriate. The
        request for retransmission of <spanx style="verb">NORM_INFO</spanx> is
        accomplished by setting the <spanx style="verb">NORM_NACK_INFO</spanx>
        flag in a corresponding repair request.</t>
      </section>

      <section title="Sender NACK Processing and Response">
        <t>The principle goal of the sender is to make forward progress in the
        transmission of data its application has enqueued. However, the sender
        will need to occasionally "rewind" its logical transmission point to
        satisfy the repair needs of receivers who have NACKed. Aggregation of
        multiple NACKs is used to determine an optimal repair strategy when a
        NACK event occurs. Since receivers initiate the NACK process on coding
        block or object boundaries, there is some loose degree of
        synchronization of the repair process even when receivers experience
        uncorrelated data loss.</t>

        <section title="Sender Repair State Aggregation">
          <t>When a sender is in its normal state of transmitting new data and
          receives a NACK, it begins a procedure to accumulate NACK repair
          state from <spanx style="verb">NORM_NACK</spanx> messages before
          beginning repair transmissions. Note this period of aggregating
          repair state does NOT interfere with its ongoing transmission of new
          data.</t>

          <t>As described in <xref target="RFC5401"></xref>, the period of
          time during which the sender aggregates <spanx style="verb">NORM_NACK</spanx>
          messages is equal to:</t>

          <figure align="center">
            <artwork align="center"><![CDATA[T_sndrAggregate = (K_sender + 1) * GRTT_sender]]></artwork>
          </figure>

          <t>where "<spanx style="verb">K_sender</spanx>" is the backoff
          scaling value advertised to the receivers, and <spanx style="verb">GRTT_sender</spanx>
          is the sender's current estimate of the group's greatest round-trip
          time. Note, for NORM unicast sessions, the "<spanx style="verb">T_sndrAggregate</spanx>"
          time can be set to <spanx style="verb">ZERO</spanx> since there is
          only one receiver. Similarly, the "<spanx style="verb">K_sender</spanx>"
          value SHOULD be set to <spanx style="verb">ZERO</spanx> for NORM
          unicast sessions to minimize repair latency.</t>

          <t>When this period ends, the sender "rewinds" by incorporating the
          accumulated repair state into its pending transmission state and
          begins transmitting repair messages. After pending repair
          transmissions are completed, the sender continues with new
          transmissions of any enqueued data. Also, at this point in time, the
          sender begins a "holdoff" timeout during which time the sender
          constrains itself from initiating a new repair aggregation cycle,
          even if <spanx style="verb">NORM_NACK</spanx> messages arrive. As
          described in <xref target="RFC5401"></xref>, the value of this
          sender "holdoff" period is:</t>

          <figure align="center">
            <artwork align="center"><![CDATA[T_sndrHoldoff = (1 * GRTT_sender)]]></artwork>
          </figure>

          <t>If additional <spanx style="verb">NORM_NACK</spanx> messages are
          received during this sender "holdoff" period, the sender will
          immediately incorporate these late-arriving messages into its
          pending transmission state if, and <spanx style="emph">only</spanx>
          if, the NACK content is ordinally greater than the sender's current
          transmission position. This "holdoff" time allows worst case time
          for the sender to propagate its current transmission sequence
          position to the group, thus avoiding redundant repair transmissions.
          After the holdoff timeout expires, a new NACK accumulation period
          can be begun (upon arrival of a NACK) in concert with the pending
          repair and new data transmission. Recall receivers are not to
          initiate the NACK repair process until the sender's logical
          transmission position exceeds the lowest ordinal position of their
          repair needs. With the new NACK aggregation period, the sender
          repeats the same process of incorporating accumulated repair state
          into its transmission plan and subsequently "rewinding" to transmit
          the lowest ordinal repair data when the aggregation period expires.
          Again, this is conducted in concert with ongoing new data and/or
          pending repair transmissions.</t>
        </section>

        <section title="Sender FEC Repair Transmission Strategy">
          <t>The NORM sender SHOULD leverage transmission of FEC parity
          content for repair to the greatest extent possible. Recall that
          receivers use a strategy to request a lowest common denominator of
          explicit repair (including parity content) in the formation of their
          <spanx style="verb">NORM_NACK</spanx> messages. Before falling back
          to explicitly satisfying different receivers' repair needs, the
          sender can make use of the general erasure-filling capability of
          FEC-generated parity segments. The sender can determine the maximum
          erasure filling needs for individual FEC coding blocks from the
          <spanx style="verb">NORM_NACK</spanx> messages received during the
          repair aggregation period. Then, if the sender has a sufficient
          number (less than or equal to the maximum erasure count) of
          previously unsent parity segments available for the applicable
          coding blocks, the sender can transmit these in lieu of the specific
          packets the receiver set has requested. The sender SHOULD NOT resort
          to explicit transmission of the receiver set's repair needs until
          after exhausting its supply of "fresh" (unsent) parity segments for
          a given coding block. In general, if a sufficiently powerful FEC
          code is used, the need for explicit repair will be an exception, and
          the fulfillment of reliable multicast can be accomplished quite
          efficiently. However, the ability to resort to explicit repair
          allows the protocol to be continue to operate under even very
          extreme circumstances.</t>

          <t><spanx style="verb">NORM_DATA</spanx> messages sent as repair
          transmissions SHALL be flagged with the <spanx style="verb">NORM_FLAG_REPAIR</spanx>
          flag. This allows receivers to obey any policies limiting new
          receivers from joining the reliable transmission when only repair
          transmissions have been received. Additionally, the sender SHOULD
          additionally flag <spanx style="verb">NORM_DATA</spanx>
          transmissions sent as explicit repair with the <spanx style="verb">NORM_FLAG_EXPLICIT</spanx>
          flag.</t>

          <t>Although NORM end system receivers do not make use of the <spanx
          style="verb">NORM_FLAG_EXPLICIT</spanx> flag, this message
          transmission status could be leveraged by intermediate systems
          wishing to "assist" NORM protocol performance. If such systems are
          properly positioned with respect to reciprocal reverse-path
          multicast routing, they need to sub-cast only a sufficient count of
          non-explicit parity repairs to satisfy a multicast routing
          sub-tree's erasure filling needs for a given FEC coding block. When
          the sender has resorted to explicit repair, then the intermediate
          systems SHOULD sub-cast all of the explicit repair packets to those
          portions of the routing tree still requiring repair for a given
          coding block. Note the intermediate systems will need to conduct
          repair state accumulation for sub-routes in a manner similar to the
          sender's repair state accumulation in order to have sufficient
          information to perform the sub-casting. Additionally, the
          intermediate systems could perform additional <spanx style="verb">NORM_NACK</spanx>
          suppression/aggregation as it conducts this repair state
          accumulation for NORM repair cycles. The detail of this type of
          operation are beyond the scope of this document, but this
          information is provided for possible future consideration.</t>
        </section>

        <section title="Sender NORM_CMD(SQUELCH) Generation">
          <t>If the sender receives a <spanx style="verb">NORM_NACK</spanx>
          message for repair of data it is no longer supporting, the sender
          generates a <spanx style="verb">NORM_CMD(SQUELCH)</spanx> message to
          advertise its repair window and squelch any receivers from
          additional NACKing of invalid data. The transmission rate of <spanx
          style="verb">NORM_CMD(SQUELCH)</spanx> messages is limited to once
          per <spanx style="verb">2*GRTT_sender</spanx>. The
          "invalid_object_list" (if applicable) of the <spanx style="verb">NORM_CMD(SQUELCH)</spanx>
          message SHALL begin with the lowest "object_transport_id" from the
          invalid <spanx style="verb">NORM_NACK</spanx> messages received
          since the last <spanx style="verb">NORM_CMD(SQUELCH)</spanx>
          transmission. The list includes as many lower ordinal invalid
          "object_transport_ids" that can fit for the <spanx style="verb">NORM_CMD(SQUELCH)</spanx>
          payload size to less than or equal to the sender's <spanx
          style="emph">NormSegmentSize</spanx> parameter.</t>
        </section>

        <section title="Sender NORM_CMD(REPAIR_ADV) Generation">
          <t>When a NORM sender receives <spanx style="verb">NORM_NACK</spanx>
          messages from receivers via unicast transmission, it uses <spanx
          style="verb">NORM_CMD(REPAIR_ADV)</spanx> messages to advertise its
          accumulated repair state to the receiver set since the receiver set
          is not directly sharing their repair needs via multicast
          communication. A NORM sender implementation MAY use a separate port
          number from the <spanx style="emph">NormSession</spanx> port number
          as the source port for its transmissions. Thus NORM receivers can
          direct any unicast feedback messages to this separate sender port
          number, distinct from the NORM session (or destination) port number.
          Then, the NORM sender implementation can discriminate unicast
          feedback messages from multicast feedback messages when there is a
          mix of multicast and unicast feedback receivers. The <spanx
          style="verb">NORM_CMD(REPAIR_ADV)</spanx> message is multicast to
          the receiver set by the sender. The payload portion of this message
          has content in the same format as the <spanx style="verb">NORM_NACK</spanx>
          receiver message payload. Receivers are then able to perform
          feedback suppression in the same manner as with <spanx style="verb">NORM_NACK</spanx>
          messages directly received from other receivers. Note the sender
          does not merely retransmit NACK content it receives, but instead
          transmits a representation of its aggregated repair state. The
          transmission of <spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx>
          messages are subject to the sender transmit rate limit and <spanx
          style="emph">NormSegmentSize</spanx> limitation. When the <spanx
          style="verb">NORM_CMD(REPAIR_ADV)</spanx> message is of maximum
          size, receivers SHALL consider the maximum ordinal transmission
          position value embedded in the message as the senders current
          transmission position and implicitly suppress requests for ordinally
          higher repair. For congestion control operation, the sender will
          also need to provide any information needed so dynamic congestion
          control feedback can be suppressed among receivers. This document
          specifies the NORM-CC Feedback Header Extension that is applied for
          baseline NORM-CC operation. If other congestion control mechanisms
          are used within a NORM implementation, other header extensions MAY
          be defined. Whatever content format is used for this purpose SHOULD
          ensure that maximum possible suppression state is conveyed to the
          receiver set.</t>
        </section>
      </section>

      <section title="Additional Protocol Mechanisms">
        <t>In addition to the principal function of data content transmission
        and repair, there are some other protocol mechanisms to help NORM to
        adapt to network conditions and play fairly with other coexistent
        protocols.</t>

        <section anchor="GrttCollection"
                 title="Group Round-trip Time (GRTT) Collection">
          <t>For NORM receivers to appropriately scale backoff timeouts and
          the senders to use proper corresponding timeouts, the participants
          need to use a common timeout basis. Each NORM sender monitors the
          round-trip time of active receivers and determines the greatest
          group round-trip time. The sender advertises this GRTT estimate in
          every message it transmits so receivers have this value available
          for scaling their timers. To measure the current GRTT, the sender
          periodically sends <spanx style="verb">NORM_CMD(CC)</spanx> messages
          containing a locally generated timestamp. Receivers are expected to
          record this timestamp along with the time the <spanx style="verb">NORM_CMD(CC)</spanx>
          message is received. Then, when the receivers generate feedback
          messages to the sender, an adjusted version of the sender timestamp
          is embedded in the feedback message (<spanx style="verb">NORM_NACK</spanx>
          or <spanx style="verb">NORM_ACK</spanx>). The adjustment adds the
          amount of time the receiver held the timestamp before generating its
          response. Upon receipt of this adjusted timestamp, the sender is
          able to calculate the round-trip time to that receiver.</t>

          <t>The round-trip time for each receiver is fed into an algorithm
          that weights and smoothes the values for a conservative estimate of
          the GRTT. The algorithm and methodology are described in the <xref
          target="RFC5401">Multicast NACK Building Block</xref> in the section
          entitled "One-to-Many Sender GRTT Measurement". A conservative
          estimate helps guarantee feedback suppression at a small cost in
          overall protocol repair delay. The sender's current estimate of GRTT
          is advertised in the "grtt" field found in all NORM sender messages.
          The advertised GRTT is also limited to a minimum of the nominal
          inter-packet transmission time given the sender's current
          transmission rate and system clock granularity. The reason for this
          additional limit is to keep the receiver somewhat event-driven by
          making sure the sender has had adequate time to generate any
          response to repair requests from receivers given transmit rate
          limitations due to congestion control or configuration.</t>

          <t>When the NORM-CC Rate header extension is present in <spanx
          style="verb">NORM_CMD(CC)</spanx> messages, the receivers respond to
          <spanx style="verb">NORM_CMD(CC)</spanx> messages as described in
          <xref target="CongestionControl"></xref>, "NORM Congestion Control
          Operation". The <spanx style="verb">NORM_CMD(CC)</spanx> messages
          are periodically generated by the sender as described for congestion
          control operation. This provides for proactive, but controlled,
          feedback from the group in the form of <spanx style="verb">NORM_ACK</spanx>
          messages. This provides for GRTT feedback even if no <spanx
          style="verb">NORM_NACK</spanx> messages are being sent. If operating
          without congestion control in a closed network, the <spanx
          style="verb">NORM_CMD(CC)</spanx> messages MAY be sent periodically
          without the NORM-CC Rate header extension. In this case, receivers
          will only provide GRTT measurement feedback when <spanx
          style="verb">NORM_NACK</spanx> messages are generated since no
          <spanx style="verb">NORM_ACK</spanx> messages are generated. In this
          case, the <spanx style="verb">NORM_CMD(CC)</spanx> messages MAY be
          sent less frequently, perhaps as little as once per minute, to
          conserve network capacity. Note the NORM-CC Rate header extension
          MAY also be used to proactively solicit RTT feedback from the
          receiver group per congestion control operation even when the sender
          is not conducting congestion control rate adjustment. NORM operation
          without congestion control SHOULD be considered only in closed
          networks.</t>
        </section>

        <section anchor="CongestionControl"
                 title="NORM Congestion Control Operation">
          <t>This section describes baseline congestion control operation for
          the NORM protocol (NORM-CC). The supporting NORM message formats and
          approach described here are an adaptation of the equation-based
          TCP-Friendly Multicast Congestion Control (TFMCC) approach<xref
          target="RFC4654"></xref>. This congestion control scheme is REQUIRED
          for operation within the general Internet unless the NORM
          implementation is adapted to use another IETF-sanctioned reliable
          multicast congestion control mechanism. With this TFMCC-based
          approach, the transmissions of NORM senders are controlled in a
          rate-based manner as opposed to window-based congestion control
          algorithms as in TCP. However, it is possible the NORM protocol
          message set MAY alternatively be used to support a window-based
          multicast congestion control scheme such as PGMCC. The details of
          such an alternative MAY be described separately or in a future
          revision of this document. In either case (rate-based TFMCC or
          window-based PGMCC), successful control of sender transmission
          depends upon collection of sender-to-receiver packet loss estimates
          and RTTs to identify the congestion control bottleneck path(s)
          within the multicast topology and adjust the sender rate
          accordingly. The receiver with loss and RTT estimates corresponding
          to the lowest resulting calculated transmission rate is identified
          as the "current limiting receiver" (CLR). In the case of a tie
          (where candidate CLRs are within 10% of the same calculated rate),
          the receiver with the largest RTT value SHOULD be designated as the
          CLR.</t>

          <t>As described in <xref target="TcpModel"></xref>, a steady-state
          sender transmission rate, to be "friendly" with competing TCP flows
          can be calculated as:</t>

          <figure align="center">
            <artwork align="center"><![CDATA[                                 S            
Rsender = ----------------------------------------------------------
        T_rtt*(sqrt((2/3)*p) + 12*sqrt((3/8)*p) * p * (1 + 32*(p^2)))]]></artwork>
          </figure>

          <t>where</t>

          <t><spanx style="verb">S</spanx> = nominal transmitted packet size.
          (In NORM, the "nominal" packet size can be determined by the sender
          as an exponentially weighted moving average (EWMA) of transmitted
          packet sizes to account for variable message sizes).</t>

          <t><spanx style="verb">T_rtt</spanx> = RTT estimate of the current
          "current limiting receiver" (CLR).</t>

          <t><spanx style="verb">p</spanx> = loss event fraction of the
          CLR.</t>

          <t>To support congestion control feedback collection and operation,
          the NORM sender periodically transmits <spanx style="verb">NORM_CMD(CC)</spanx>
          command messages. <spanx style="verb">NORM_CMD(CC)</spanx> messages
          are multiplexed with NORM data and repair transmissions and serve
          several purposes:</t>

          <t><list style="numbers">
              <t>Stimulate explicit feedback from the general receiver set to
              collect congestion control information.</t>

              <t>Communicate state to the receiver set on the sender's current
              congestion control status including details of the CLR.</t>

              <t>Initiate rapid (immediate) feedback from the CLR in order to
              closely track the dynamics of congestion control for the current
              worst path in the group multicast topology.</t>
            </list></t>

          <t>The format of the <spanx style="verb">NORM_CMD(CC)</spanx>
          message is described in <xref target="NORM_CMD"></xref> of this
          document. The <spanx style="verb">NORM_CMD(CC)</spanx> message
          contains information to allow measurement of RTTs, to inform the
          group of the congestion control CLR, and to provide feedback of
          individual RTT measurements to the receivers in the group. The
          <spanx style="verb">NORM_CMD(CC)</spanx> also provides for exciting
          feedback from OPTIONAL "potential limiting receiver" (PLR) nodes
          that might be determined administratively or possibly
          algorithmically based upon congestion control feedback. PLR nodes
          are receivers that have been identified to have potential for
          (perhaps soon) becoming the CLR and thus immediate, up-to-date
          feedback is beneficial for congestion control performance. The PLR
          list MAY be populated with a small number of receivers the sender
          identifies as approaching the CLR loss and delay conditions based on
          feedback from the group.</t>

          <section title="NORM_CMD(CC) Transmission">
            <t>The <spanx style="verb">NORM_CMD(CC)</spanx> message is
            transmitted periodically by the sender along with its normal data
            transmission. Note the repeated transmission of <spanx
            style="verb">NORM_CMD(CC)</spanx> messages MAY be initiated some
            time before transmission of user data content at session startup.
            This can be done to collect some estimation of the current state
            of the multicast topology with respect to group and individual RTT
            and congestion control state.</t>

            <t>A <spanx style="verb">NORM_CMD(CC)</spanx> message is
            immediately transmitted at sender startup. The interval of
            subsequent <spanx style="verb">NORM_CMD(CC)</spanx> message
            transmission is determined as follows:</t>

            <t><list style="numbers">
                <t>By default, the interval is set according to the current
                sender GRTT estimate. A startup initial value of <spanx
                style="verb">GRTT_sender  = 0.5</spanx> seconds is RECOMMENDED
                when no feedback has yet been received from the group.</t>

                <t>Until a CLR has been identified (based on previous receiver
                feedback) or when no data transmission is pending, the <spanx
                style="verb">NORM_CMD(CC)</spanx> interval is doubled up from
                its current interval to a maximum of once per 30 seconds. This
                results in a low duty cycle for <spanx style="verb">NORM_CMD(CC)</spanx>
                probing when no CLR is identified or there is no pending data
                to transmit.</t>

                <t>When a CLR has been identified (based on receiver feedback)
                and data transmission is pending, the probing interval is set
                to the RTT between the sender and the CLR (<spanx
                style="verb">RTT_clr</spanx>).</t>

                <t>Additionally, when the data transmission rate is low with
                respect to the <spanx style="verb">RTT_clr</spanx> interval
                used for probing, the implementation SHOULD ensure no more
                than one <spanx style="verb">NORM_CMD(CC)</spanx> message is
                sent per <spanx style="verb">NORM_DATA</spanx> message when
                there is data pending transmission. This ensures the
                transmission of this control message is not done to the
                exclusion of user data transmission.</t>
              </list></t>

            <t>The <spanx style="verb">NORM_CMD(CC)</spanx> "cc_sequence"
            field is incremented with each transmission of a <spanx
            style="verb">NORM_CMD(CC)</spanx> command. The greatest
            "cc_sequence" recently received by receivers is included in their
            feedback to the sender. This allows the sender to determine the
            age of feedback to assist in congestion avoidance.</t>

            <t>The NORM-CC Rate Header Extension is applied to the <spanx
            style="verb">NORM_CMD(CC)</spanx> message and the sender
            advertises its current transmission rate in the "send_rate" field.
            The rate information is used by receivers to initialize loss
            estimation during congestion control startup or restart.</t>

            <t>The "cc_node_list" contains a list of entries identifying
            receivers and their current congestion control state (status
            "flags", "rtt" and "loss" estimates). The list will be empty if
            the sender has not yet received any feedback from the group. If
            the sender has received feedback, the list will minimally contain
            an entry identifying the CLR. A <spanx style="verb">NORM_FLAG_CC_CLR</spanx>
            flag value is provided for the "cc_flags" field to identify the
            CLR entry. It is RECOMMENDED the CLR entry be the first in the
            list for implementation efficiency. Additional entries in the list
            are used to provide sender-measured individual RTT estimates to
            receivers in the group. The number of additional entries in this
            list is dependent upon the percentage of control traffic the
            sender application is willing to send with respect to user data
            message transmissions. More entries in the list will allow the
            sender to be more responsive to congestion control dynamics. The
            length of the list can be dynamically determined according to the
            current transmission rate and scheduling of <spanx style="verb">NORM_CMD(CC)</spanx>
            messages. The maximum length of the list corresponds to the
            sender's <spanx style="emph">NormSegmentSize</spanx> parameter for
            the session. The inclusion of additional entries in the list based
            on receiver feedback are prioritized with following rules:</t>

            <t><list style="numbers">
                <t>Receivers that have not yet been provided a RTT measurement
                get first priority. Of these, those with the greatest loss
                fraction receive precedence for list inclusion.</t>

                <t>Secondly, receivers that have previously been provided a
                RTT measurement are included with receivers yielding the
                lowest calculated congestion rate getting precedence.</t>
              </list></t>

            <t>There are "cc_flag" values in addition to <spanx style="verb">NORM_FLAG_CC_CLR</spanx>
            used for other congestion control functions. The <spanx
            style="verb">NORM_FLAG_CC_PLR</spanx> flag value is used to mark
            additional receivers from which the sender would like to have
            immediate, non-suppressed feedback. These can be receivers the
            sender algorithmically identified as potential future CLRs or have
            been pre-configured as potential congestion control points in the
            network. The <spanx style="verb">NORM_FLAG_CC_RTT</spanx>
            indicates the validity of the "cc_rtt" field for the associated
            receiver node. Normally, this flag will be set since the receivers
            in the list will typically be receivers from which the sender has
            received feedback. However, in the case the NORM sender has been
            pre-configured with a set of PLR nodes, feedback from those
            receivers might not have yet been collected and thus the "cc_rtt"
            field does not contain a valid value when this flag is not set.
            Similarly, a value of <spanx style="verb">ZERO</spanx> for the
            "cc_rate" field here MUST be treated as an invalid value and be
            ignored for the purposes of feedback suppression, etc.</t>
          </section>

          <section title="NORM_CMD(CC) Feedback Response">
            <t>Receivers explicitly respond to <spanx style="verb">NORM_CMD(CC)</spanx>
            messages in the form of a <spanx style="verb">NORM_ACK(RTT)</spanx>
            message. The goal of the congestion control feedback is to
            determine the receivers with the lowest congestion control rates.
            Receivers marked as CLR or PLR nodes in the <spanx style="verb">NORM_CMD(CC)</spanx>
            "cc_node_list" immediately provide feedback in the form of a
            <spanx style="verb">NORM_ACK</spanx> to this message. When a
            <spanx style="verb">NORM_CMD(CC)</spanx> is received, non-CLR or
            non-PLR nodes initiate random feedback backoff timeouts similar to
            that used when the receiver initiates a repair cycle (see <xref
            target="NackProcedure"></xref>) in response to detection of data
            loss. The backoff timeout for the congestion control response is
            generated as follows:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[T_backoff = RandomBackoff(K_backoff * GRTT_sender, GSIZE_sender)]]></artwork>
            </figure>

            <t>The "<spanx style="verb">RandomBackoff()</spanx>" algorithm
            provides a truncated exponentially distributed random number and
            is described in the <xref target="RFC5401">Multicast NACK Building
            Block</xref>. The same backoff factor, <spanx style="verb">K_backoff = K_sender</spanx>,
            as used with <spanx style="verb"> NORM_NACK</spanx> suppression is
            generally RECOMMENDED. However, in cases where the application
            purposefully specifies a very small <spanx style="verb">K_sender</spanx>
            backoff factor to minimize the NACK repair process latency
            (trading off group size scalability), it is RECOMMENDED a larger
            backoff factor for congestion control feedback be maintained,
            since there can be a larger volume of congestion control feedback
            than NACKs in many cases and some congestion control feedback
            latency might be tolerable where reliable delivery latency is not.
            As previously noted, a backoff factor value of <spanx
            style="verb">K_sender = 4</spanx> is generally RECOMMENDED for ASM
            operation and <spanx style="verb">K_sender = 6</spanx> for SSM
            operation. A receiver SHALL cancel the backoff timeout and thus
            its pending transmission of a <spanx style="verb">NORM_ACK(RTT)</spanx>
            message under the following conditions:</t>

            <t><list style="numbers">
                <t>The receiver generates another feedback message (<spanx
                style="verb">NORM_NACK</spanx> or other <spanx style="verb">NORM_ACK</spanx>)
                before the congestion control feedback timeout expires (these
                messages will convey the current congestion control feedback
                information),</t>

                <t>A <spanx style="verb">NORM_CMD(CC)</spanx> or other
                receiver feedback with an ordinally greater "cc_sequence"
                field value is received before the congestion control feedback
                timeout expires (this is similar to the TFMCC feedback round
                number),</t>

                <t>When the <spanx style="verb">T_backoff</spanx> is greater
                than <spanx style="verb">1*GRTT_sender</spanx>. This prevents
                NACK implosion in the event of sender or network failure,</t>

                <t>"Suppressing" congestion control feedback is heard from
                another receiver (in a <spanx style="verb">NORM_ACK</spanx> or
                <spanx style="verb">NORM_NACK</spanx>) or via a <spanx
                style="verb">NORM_CMD(REPAIR_ADV)</spanx> message from the
                sender. The local receiver's feedback is "suppressed" if the
                rate of the competing feedback (<spanx style="verb">Rfb</spanx>)
                is sufficiently close to or less than the local receiver's
                calculated rate (<spanx style="verb">Rcalc</spanx>). The local
                receiver's feedback is canceled when <spanx style="verb">Rcalc &gt; (0.9 * Rfb)</spanx>.
                Also note receivers that have not yet received an RTT
                measurement from the sender are suppressed only by other
                receivers that have not yet measured RTT. Additionally,
                receivers whose RTT estimate has aged considerably (i.e., they
                haven't been included in the <spanx style="verb">NORM_CMD(CC)</spanx>
                "cc_node_list" in a long time) might wish to compete as a
                receiver with no prior RTT measurement after some long term
                expiration period.</t>
              </list></t>

            <t>When the backoff timer expires, the receiver SHALL generate a
            <spanx style="verb">NORM_ACK(RTT)</spanx> message to provide
            feedback to the sender and group. This message MAY be multicast to
            the group for most effective suppression in ASM topologies or
            unicast to the sender depending upon how the NORM protocol is
            deployed and configured.</t>

            <t>Whenever any feedback is generated (including this <spanx
            style="verb">NORM_ACK(RTT)</spanx> message), receivers include an
            adjusted version of the sender timestamp from the most recently
            received <spanx style="verb">NORM_CMD(CC)</spanx> message and its
            "cc_sequence" value in the corresponding <spanx style="verb">NORM_ACK</spanx>
            or <spanx style="verb">NORM_NACK</spanx> message fields. For
            NORM-CC operation, any generated feedback message SHALL also
            contain the NORM-CC Feedback header extension. The receiver
            provides its current "cc_rate" estimate, "cc_loss" estimate,
            "cc_rtt" if known, and any applicable "cc_flags" via this header
            extension.</t>

            <t>During <spanx style="emph">slow start</spanx> (when the
            receiver has not yet detected loss from the sender), the receiver
            uses a value equal to two times its measured rate from the sender
            in the "cc_rate" field. For steady-state congestion control
            operation, the receiver "cc_rate" value is from the equation-based
            value using its current loss event estimate and
            sender&lt;-&gt;receiver RTT information. (The <spanx style="verb">GRTT_sender</spanx>
            is used when the receiver has not yet measured its individual
            RTT).</t>

            <t>The "cc_loss" field value reflects the receiver's current loss
            event estimate with respect to the sender in question.</t>

            <t>When the receiver has a valid individual RTT measurement, it
            SHALL include this value in the "cc_rtt" field. The <spanx
            style="verb">NORM_FLAG_CC_RTT</spanx> MUST be set when the
            "cc_rtt" field is valid.</t>

            <t>After a congestion control feedback message is generated or
            when the feedback is suppressed, a non-CLR receiver begins a
            "holdoff" timeout period during which it will restrain itself from
            providing congestion control feedback, even if <spanx
            style="verb">NORM_CMD(CC)</spanx> messages are received from the
            sender (unless the receive becomes marked as a CLR or PLR node).
            The value of this holdoff timeout (<spanx style="verb">T_ccHoldoff</spanx>)
            period is:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[T_ccHoldoff = (K_sender * GRTT_sender)]]></artwork>
            </figure>

            <t>Thus, non-CLR receivers are constrained to providing explicit
            congestion control feedback once per <spanx style="verb">K_sender*GRTT_sender</spanx>
            intervals. However, as the session progresses, different receivers
            will be responding to different <spanx style="verb">NORM_CMD(CC)</spanx>
            messages and there will be relatively continuous feedback of
            congestion control information while the sender is active.</t>
          </section>

          <section title="Congestion Control Rate Adjustment">
            <t>During steady-state operation, the sender will directly adjust
            its transmission rate to the rate indicated by the feedback from
            its currently selected CLR. As noted in <xref
            target="TfmccPaper"></xref>, the estimation of parameters (loss
            and RTT) for the CLR will generally constrain the rate changes
            possible within acceptable bounds. For rate increases, the sender
            SHALL observe a maximum rate of increase of one packet per RTT at
            all times during steady-state operation.</t>

            <t>The sender processes congestion control feedback from the
            receivers and selects the CLR based on the lowest rate receiver.
            Receiver rates are either determined directly from the <spanx
            style="emph">slow start</spanx> "cc_rate" provided by the receiver
            in the NORM-CC Feedback header extension or by performing the
            equation-based calculation using individual RTT and loss estimates
            ("cc_loss") as feedback is received.</t>

            <t>The sender can calculate a current RTT for a receiver (<spanx
            style="verb">RTT_rcvrNew</spanx>) using the "grtt_response"
            timestamp included in feedback messages. When the "cc_rtt" value
            in a response is not valid, the sender simply uses this <spanx
            style="verb">RTT_rcvrNew</spanx> value as the receiver's current
            RTT (<spanx style="verb">RTT_rcvr</spanx>). For non-CLR and
            non-PLR receivers, the sender can use the "cc_rtt" value provided
            in the NORM-CC Feedback header extension as the receiver's
            previous RTT measurement (<spanx style="verb">RTT_rcvrPrev</spanx>)
            to smooth according to:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[RTT_rcvr = 0.5 * RTT_rcvrPrev + 0.5 * RTT_rcvrNew]]></artwork>
            </figure>

            <t>For CLR receivers where feedback is received more regularly,
            the sender SHOULD maintain a more smoothed RTT estimate upon new
            feedback from the CLR where:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[RTT_clr = 0.9 * RTT_clr + 0.1 * RTT_clrNew]]></artwork>
            </figure>

            <t>"<spanx style="verb">RTT_clrNew</spanx>" is the new RTT
            calculated from the timestamp in the feedback message received
            from the CLR. The <spanx style="verb">RTT_clr</spanx> is
            initialized to <spanx style="verb">RTT_clrNew</spanx> on the first
            feedback message received. Note the same procedure is observed by
            the sender for PLR receivers, and if a PLR is "promoted" to CLR
            status, the smoothed estimate can be continued.</t>

            <t>There are some additional periods besides steady-state
            operation to be considered in NORM-CC operation. These periods
            are:</t>

            <t><list style="numbers">
                <t>during session startup,</t>

                <t>when no feedback is received from the CLR, and</t>

                <t>when the sender has a break in data transmission.</t>
              </list></t>

            <t>During session startup, the congestion control operation SHALL
            observe a "slow start" procedure to quickly approach its fair
            bandwidth share. An initial sender startup rate is assumed
            where:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[Rinit = MIN(NormSegmentSize/GRTT_sender, NormSegmentSize) bytes/sec]]></artwork>
            </figure>

            <t>The rate is increased only when feedback is received from the
            receiver set. The "slow start" phase proceeds until any receiver
            provides feedback indicating loss has occurred. Rate increase
            during <spanx style="emph">slow start</spanx> is applied as:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[Rnew = Rrecv_min]]></artwork>
            </figure>

            <t>where <spanx style="verb">Rrecv_min</spanx> is the minimum
            reported receiver rate in the "cc_rate" field of congestion
            control feedback messages received from the group. Note during
            <spanx style="emph">slow start</spanx>, receivers use two times
            their measured rate from the sender in the "cc_rate" field of
            their feedback. Rate increase adjustment is limited to once per
            GRTT during slow start.</t>

            <t>If the CLR or any receiver intends to leave the group, it will
            set the <spanx style="verb">NORM_FLAG_CC_LEAVE</spanx> in its
            congestion control feedback message as an indication the sender
            SHOULD NOT select it as the CLR. When the CLR changes to a lower
            rate receiver, the sender SHOULD immediately adjust to the new
            lower rate. The sender is limited to increasing its rate at one
            additional packet per RTT towards any new, higher CLR rate.</t>

            <t>The sender SHOULD also track the age of the feedback it has
            received from the CLR by comparing its current "cc_sequence" value
            (<spanx style="verb">Seq_sender</spanx>) to the last "cc_sequence"
            value received from the CLR (<spanx style="verb">Seq_clr</spanx>).
            As the age of the CLR feedback increases with no new feedback, the
            sender SHALL begin reducing its rate once per <spanx style="verb">RTT_clr</spanx>
            as a congestion avoidance measure. The following algorithm is used
            to determine the decrease in sender rate (Rsender bytes/sec) as
            the CLR feedback, unexpectedly, excessively ages:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[Age = Seq_sender - Seq_clr;
if (Age > 4) Rsender = Rsender * 0.5;]]></artwork>
            </figure>

            <t>This rate reduction is limited to the lower bound on NORM
            transmission rate. After <spanx style="verb">NORM_ROBUST_FACTOR</spanx>
            consecutive <spanx style="verb">NORM_CMD(CC)</spanx> rounds
            without any feedback from the CLR, the sender SHOULD assume the
            CLR has left the group and pick the receiver with the next lowest
            rate as the new CLR. Note this assumes the sender does not have
            explicit knowledge the CLR intentionally left the group. If no
            receiver feedback is received, the sender MAY wish to withhold
            further transmissions of <spanx style="verb">NORM_DATA</spanx>
            segments and maintain <spanx style="verb">NORM_CMD(CC)</spanx>
            transmissions only until feedback is detected. After such a CLR
            timeout, the sender will be transmitting with a minimal rate and
            SHOULD return to slow start as described here for a break in data
            transmission.</t>

            <t>When the sender has a break in its data transmission, it can
            continue to probe the group with <spanx style="verb">NORM_CMD(CC)</spanx>
            messages to maintain RTT collection from the group. This will
            enable the sender to quickly determine an appropriate CLR upon
            data transmission restart. However, the sender SHOULD
            exponentially reduce its target rate to be used for transmission
            restart as time since the break elapses. The target rate SHOULD be
            recalculated once per <spanx style="verb">RTT_clr</spanx> as:</t>

            <figure align="center">
              <artwork align="center"><![CDATA[Rsender = Rsender * 0.5;]]></artwork>
            </figure>

            <t>If the minimum NORM rate is reached, the sender SHOULD set the
            <spanx style="verb">NORM_FLAG_START</spanx> flag in its <spanx
            style="verb">NORM_CMD(CC)</spanx> messages upon restart and the
            group SHOULD observe <spanx style="emph">slow start</spanx>
            congestion control procedures until any receiver experiences a new
            loss event.</t>
          </section>
        </section>

        <section anchor="PositiveAcknowledgment"
                 title="NORM Positive Acknowledgment Procedure">
          <t>NORM provides options for the source application to request
          positive acknowledgment (ACK) of <spanx style="verb">NORM_CMD(FLUSH)</spanx>
          and <spanx style="verb">NORM_CMD(ACK_REQ)</spanx> messages from
          members of the group. There are some specific acknowledgment
          requests defined for the NORM protocol and a range of acknowledgment
          request types left to be defined by the application. One predefined
          acknowledgment type is the <spanx style="verb">NORM_ACK_FLUSH</spanx>
          type. This acknowledgment is used to determine if receivers have
          achieved completion of reliable reception up through a specific
          logical transmission point with respect to the sender's sequence of
          transmission. The <spanx style="verb">NORM_ACK_FLUSH</spanx>
          acknowledgment MAY be used to assist in application flow control
          when the sender has information on a portion of the receiver set.
          Another predefined acknowledgment type is <spanx style="verb">NORM_ACK(CC)</spanx>
          used to explicitly provide congestion control feedback in response
          to <spanx style="verb">NORM_CMD(CC)</spanx> messages transmitted by
          the sender for NORM-CC operation. Note the <spanx style="verb">NORM_ACK(CC)</spanx>
          response does NOT follow the positive acknowledgment procedure
          described here. The <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>
          and <spanx style="verb">NORM_ACK</spanx> messages contain an
          "ack_type" field to identify the type of acknowledgment requested
          and provided. A range of "ack_type" values is provided for
          application-defined use. While the application is responsible for
          initiating the acknowledgment request and interprets
          application-defined "ack_type" values, the acknowledgment procedure
          SHOULD be conducted within the protocol implementation to take
          advantage of timing and transmission scheduling information
          available to the NORM transport.</t>

          <t>The NORM positive acknowledgment procedure uses polling by the
          sender to query the receiver group for response. Note this polling
          procedure is not intended to scale to very large receiver groups,
          but could be used in large group setting to query a critical subset
          of the group. Either the <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>,
          or when applicable, the <spanx style="verb">NORM_CMD(FLUSH)</spanx>
          message is used for polling and contains a list of <spanx
          style="emph">NormNodeIds</spanx> of the receivers expected to
          respond to the command. The list of receivers providing
          acknowledgment is determined by the source application with <spanx
          style="emph">a priori</spanx> knowledge of participating nodes or
          via some other application-level mechanism.</t>

          <t>The ACK process is initiated by the sender generating <spanx
          style="verb">NORM_CMD(FLUSH)</spanx> or <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>
          messages in periodic rounds. For <spanx style="verb">NORM_ACK_FLUSH</spanx>
          requests, the <spanx style="verb">NORM_CMD(FLUSH)</spanx> contain a
          "object_transport_id" and "fec_payload_id" denoting the watermark
          transmission point for which acknowledgment is requested. This
          watermark transmission point is echoed in the corresponding fields
          of the <spanx style="verb">NORM_ACK(FLUSH)</spanx> message sent by
          the receiver in response. <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>
          messages contain an "ack_id" field that is similarly echoed in
          response so the sender can match the response to the appropriate
          request.</t>

          <t>In response to the <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>,
          the listed receivers randomly, with a uniform distribution, transmit
          <spanx style="verb">NORM_ACK</spanx> messages over a time window of
          (<spanx style="verb">1*GRTT_sender</spanx>). These <spanx
          style="verb">NORM_ACK</spanx> messages are typically unicast to the
          sender. (Note <spanx style="verb">NORM_ACK(CC)</spanx> messages
          SHALL be multicast or unicast in the same manner as <spanx
          style="verb">NORM_NACK</spanx> messages).</t>

          <t>The ACK process is self-limiting and avoids ACK implosion
          because:</t>

          <t><list style="numbers">
              <t>Only a single <spanx style="verb">NORM_CMD(ACK_REQ)</spanx>
              message is generated once per (<spanx style="verb">2*GRTT_sender</spanx>),
              and,</t>

              <t>The size of the "acking_node_list" of <spanx style="emph">NormNodeIds</spanx>
              from which acknowledgment is requested is limited to a maximum
              of the sender <spanx style="emph">NormSegmentSize</spanx>
              setting per round of the positive acknowledgment process.</t>
            </list></t>

          <t>Because the size of the included list is limited to the sender's
          <spanx style="emph">NormSegmentSize</spanx> setting, multiple <spanx
          style="verb">NORM_CMD(ACK_REQ)</spanx> rounds will sometimes be
          necessary to achieve responses from all receivers specified. The
          content of the attached <spanx style="emph">NormNodeId</spanx> list
          will be dynamically updated as this process progresses and <spanx
          style="verb">NORM_ACK</spanx> responses are received from the
          specified receiver set. As the sender receives valid responses
          (i.e., matching watermark point or "ack_id") from receivers, it
          SHALL eliminate those receivers from the subsequent <spanx
          style="verb">NORM_CMD(ACK_REQ)</spanx> message "acking_node_list"
          and add in any pending receiver <spanx style="emph">NormNodeIds</spanx>
          while keeping within the <spanx style="emph">NormSegmentSize</spanx>
          limitation of the list size. Each receiver is queried a maximum
          number of times (<spanx style="verb">NORM_ROBUST_FACTOR</spanx>, by
          default). Receivers not responding within this number of repeated
          requests are removed from the payload list to make room for other
          potential receivers pending acknowledgment. The transmission of the
          <spanx style="verb">NORM_CMD(ACK_REQ)</spanx> is repeated until no
          further responses are needed or until the repeat threshold is
          exceeded for all pending receivers. The transmission of <spanx
          style="verb">NORM_CMD(ACK_REQ)</spanx> or <spanx style="verb">NORM_CMD(FLUSH)</spanx>
          messages to conduct the positive acknowledgment process is
          multiplexed with ongoing sender data transmissions. However, the
          <spanx style="verb">NORM_CMD(FLUSH)</spanx> positive acknowledgment
          process MAY be interrupted in response to negative acknowledgment
          repair requests (NACKs) received from receivers during the
          acknowledgment period. The <spanx style="verb">NORM_CMD(FLUSH)</spanx>
          positive acknowledgment process is restarted for receivers pending
          acknowledgment once any the repairs have been transmitted.</t>

          <t>In the case of <spanx style="verb">NORM_CMD(FLUSH)</spanx>
          commands with an attached "acking_node_list", receivers will not ACK
          until they have received complete transmission of all data up to and
          including the given watermark transmission point. All receivers
          SHALL interpret the watermark point provided in the request NACK for
          repairs if needed as for <spanx style="verb">NORM_CMD(FLUSH)</spanx>
          commands with no attached "acking_node_list".</t>
        </section>

        <section title="Group Size Estimate">
          <t>NORM sender messages contain a "gsize" field that is a
          representation of the group size and is used in scaling random
          backoff timer ranges. The use of the group size estimate within the
          NORM protocol does not demand a precise estimation and works
          reasonably well if the estimate is within an order of magnitude of
          the actual group size. By default, the NORM sender group size
          estimate MAY be administratively configured. Also, given the
          expected scalability of the NORM protocol for general use, a default
          value of 10,000 is RECOMMENDED for use as the group size estimate.
          It is also possible the group size MAY be algorithmically
          approximated from the volume of congestion control feedback messages
          based on the exponentially weighted random backoff. However, the
          specification of such an algorithm is currently beyond the scope of
          this document.</t>
        </section>
      </section>
    </section>

    <section title="Configurable Elements">
      <t>The NORM protocol supports a modest number of configurable parameters
      that control operation. Most of these need only be set at NORM sender(s)
      and the configuration information is communicated to the receiver set in
      NORM header and/or header extension fields. A notable exception to this
      is the <spanx style="verb">NORM_ROBUST_FACTOR</spanx> that is presumed
      to be a common value preset among senders and receivers for a given NORM
      session. The following table summarizes these configurable elements:</t>

      <texttable>
        <ttcol width="25%">Configurable Element</ttcol>

        <ttcol width="75%">Purpose</ttcol>

        <c>Sender Initial GRTT Estimate (<spanx style="verb">GRTT_sender</spanx>)</c>

        <c>Sender's Initial estimate of greatest group round trip time.
        Affects timing of feedback suppression and sender command
        transmissions at sender startup.</c>

        <c>Backoff Factor (<spanx style="verb">K_sender</spanx>)</c>

        <c>Sender's scaling factor used for timer-based feedback
        suppression.</c>

        <c>Group Size Estimate (<spanx style="verb">GSIZE_sender</spanx>)</c>

        <c>Sender's rough estimate of receiver group size used in generation
        of random feedback backoff timeout.</c>

        <c><spanx style="verb">NORM_ROBUST_FACTOR</spanx></c>

        <c>Integer factor determining how persistently (i.e. robust) senders
        transmit repeated control messages and receivers self-initiate
        timeout-based NACKing in absence of sender activity.</c>

        <c>FEC Type ("fec_id")</c>

        <c>Sender FEC encoding type.</c>

        <c>Sender segment size (<spanx style="verb">NormSegmentSize</spanx>)</c>

        <c>Maximum size (in bytes) of the payload portion of <spanx
        style="verb">NORM_DATA</spanx> and other messages.</c>

        <c><spanx style="emph">NormNodeId</spanx></c>

        <c>Unique identifiers pre-assigned to all NORM session
        participants.</c>
      </texttable>

      <t>The sender-controlled GRTT estimate (referred to as <spanx
      style="verb">GRTT_sender</spanx> in this document) is used to set and
      scale various timers associated with NORM protocol operation. During
      steady-state operation, the sender probes the receiver set, adapts to
      the group round trip timing state, and advertises its estimate to the
      receiver set in "grtt" field of relevant NORM protocol messages.
      However, an initial value must be assumed at sender startup. A large
      initial estimate is conservative and safer with regards to preventing
      feedback implosion and starting up congestion control operation, but
      requires the sender and receivers to allocate more buffering resources
      for a given transmission rate (i.e. larger effective delay*bandwidth
      product) to maintain efficient operation. A default initial value of
      <spanx style="verb">GRTT_sender = 0.5</spanx> seconds is
      RECOMMENDED.</t>

      <t>The sender-controlled Backoff Factor (referred to a <spanx
      style="verb">K_sender</spanx> in this document) is used to scale
      protocol timers and contributes to the generation of the random backoff
      timeout value that facilitates timer-based feedback suppression. The
      sender advertises its configured Backoff Factor to the receiver set in
      the "backoff" field of applicable NORM messages and thus no receiver
      configuration is necessary. For ASM operation a default value of <spanx
      style="verb">K_sender = 4</spanx> is RECOMMENDED while for SSM operation
      a default value of <spanx style="verb">K_sender = 6</spanx> is
      RECOMMENDED. </t>

      <t>The sender estimate of session Group Size (referred to as <spanx
      style="verb">GSIZE_sender</spanx> in this document) also plays a role in
      the random selection of feedback suppression timeout values. The sender
      advertises its configured Group Size estimate to the receiver set in the
      "gsize" field of applicable NORM messages and thus no receiver
      configuration is necessary. Only a rough estimate (i.e.
      "order-of-magnitude") is needed for effective feedback suppression and a
      default value of <spanx style="verb">GSIZE_sender = 10,000</spanx> is
      RECOMMENDED as a conservative estimate for most uses. </t>

      <t>The <spanx style="verb">NORM_ROBUST_FACTOR</spanx> is an integer
      parameter that determines how persistently NORM senders transmit control
      message (<spanx style="verb">NORM_CMD</spanx> messages) such as
      end-of-transmission flushing, OPTIONAL positive acknowledgement
      requests, etc. Additionally, the receivers use their knowledge of <spanx
      style="verb">NORM_ROBUST_FACTOR</spanx> to determine when to consider a
      NORM sender inactive and MAY use the factor in determining how
      persistently to self-initiate repeated NACK repair requests upon such
      timeouts. This parameter is NOT communication in NORM protocol message
      headers and is presumed to be preset to a consistent value among sender
      and receivers for a given NORM session. A default value of <spanx
      style="verb">NORM_ROBUST_FACTOR = 20</spanx> is RECOMMENDED.</t>

      <t>Another NORM sender configuration element is the FEC Type used to
      encode <spanx style="verb">NORM_DATA</spanx> message content. The FEC
      type is communicated from the sender to the receiver set in the "fec_id"
      field of relevant NORM message headers. The "fec_id" value corresponds
      to an IANA-assigned value identifying the FEC encoding type as described
      in the <xref target="RFC5052">FEC Building Block</xref>. Typically, a
      sender SHOULD use a consistent FEC encoding for its participation in a
      session to simply receiver state allocation and maintenance, but it
      implementations MAY vary the FEC encoding type on a per-object basis if
      necessary.</t>

      <t>The sender <spanx style="emph">NormSegmentSize</spanx> setting
      determines the maximum size of the payload portion of <spanx
      style="verb">NORM_DATA</spanx> and other messages that the sender
      transmits. Additionally the payload size of feedback messages from
      receivers to a given sender is limited to that sender's <spanx
      style="emph">NormSegmentSize</spanx>. The <spanx style="emph">NormSegmentSize</spanx>
      SHOULD be configured to be compatible with expected network MTU
      limitations, given the added overhead of NORM, UDP, and IP protocol
      message headers. Additionally, MTU Discovery MAY be employed by the
      sender to determine an appropriate <spanx style="emph">NormSegmentSize</spanx>.
      The <spanx style="emph">NormSegmentSize</spanx> for a given sender can
      be determined by receivers from the FEC Object Transmission Information
      (FTI) provided either in applied EXT_FTI header extensions or
      pre-configured session information.</t>

      <t>Although it is not technically a configurable element, the receivers
      MUST have FEC Object Transmission Information for transmitted <spanx
      style="emph">NormObjects</spanx> to properly buffer, decode, and
      reassemble the original content. For loosely organized NORM protocol
      sessions, the sender MAY apply the <spanx style="verb">EXT_FTI</spanx>
      Header Extension to <spanx style="verb">NORM_DATA</spanx> and <spanx
      style="verb">NORM_INFO</spanx> (if applicable) messages so that
      receivers can get this information without prior coordination. An
      implementation MAY also apply the <spanx style="verb">EXT_FTI</spanx>
      only to <spanx style="verb">NORM_INFO</spanx> messages for reduced
      overhead. Or, finally, applications MAY also provide the FTI out-of-band
      prior to sender transmission.</t>

      <t>Each participant in a NORM protocol session MUST be configured with a
      unique <spanx style="emph">NormNodeId</spanx> value. The <spanx
      style="emph">NormNodeId</spanx> value is used by receivers to identify
      the sender to which their NACK or other feedback messages are addressed
      and senders use the <spanx style="emph">NormNodeId</spanx> to
      differentiate receivers for purposes of congestion control and OPTIONAL
      positive acknowledgement collection. Assignment of unique <spanx
      style="emph">NormNodeId</spanx> values can be done via <spanx
      style="emph">a priori</spanx> coordination and/or use of a deconfliction
      mechanism external to the NORM protocol itself. The values of <spanx
      style="verb">NORM_NODE_NONE = 0x00000000</spanx> and <spanx
      style="verb">NORM_NODE_ANY = 0xffffffff</spanx> are reserved and MUST
      NOT be assigned to NORM participants.</t>
    </section>

    <section title="Security Considerations">
      <t>The same security considerations that apply to the <xref
      target="RFC5401">Multicast NACK</xref>, <xref
      target="RFC4654">TFMCC</xref>, and <xref target="RFC5052">FEC</xref>
      Building Blocks also apply to the NORM protocol. In addition to the
      vulnerabilities to which any IP and IP multicast protocol implementation
      are subject, malicious hosts might engage in excessive NACKing in an
      attempt to prevent the NORM sender(s) from making forward progress in
      reliable transmission. Receiver "join" and "service" policy enforcement
      as described in <xref target="ReceiverInitialization"></xref> can be
      applied if such activity is detected. The use of cryptographic
      authentication and/or confidentiality measures can be used to provide a
      more effective degree of protection from objectionable transmissions
      from unauthorized hosts. But in some cases, even with authentication,
      the NACK-based feedback of NORM can be exploited by replay attacks
      forcing the NORM sender to unnecessarily transmit repair information.
      This MAY be addressed in part with network layer IP security
      implementations that guard against this potential security exploitation
      or alternatively with a security mechanism using the <spanx
      style="verb">EXT_AUTH</spanx> header extension for similar purposes.
      Such security mechanisms SHOULD be deployed and used when available.</t>

      <t>The NORM protocol is compatible with the use of <xref
      target="RFC4301">IP security (IPsec)</xref> and the IPsec Encapsulating
      Security Payload (ESP) protocol or Authentication Header (AF) extension
      can be used to secure IP packets transmitted by NORM participants. A
      baseline approach to secure NORM operation using IPsec is described
      below. Compliant implementations of this specification are REQUIRED to
      be compatible with IPsec usage as described in <xref
      target="NormIPsec"></xref>.</t>

      <t>Additionally, the <spanx style="verb">EXT_AUTH</spanx> header
      extension (HET = 1) is reserved for use by security mechanisms to
      provide an alternative form of authentication and/or encryption of NORM
      messages. The format of this header extension and its processing is
      outside the scope of this document and is to be communicated out-of-band
      as part of the session description. It is possible an <spanx
      style="verb">EXT_AUTH</spanx> implementation of MAY also provide for
      encryption of NORM message payloads as well as authentication. The use
      of this approach as compared to IPsec can allow for header compression
      techniques to be applied jointly to IP and NORM protocol headers. In
      cases where security analysis deems encryption of NORM protocol header
      content is beneficial or necessary, the aforementioned use of IPsec ESP
      might be more appropriate. If <spanx style="verb">EXT_AUTH</spanx> is
      present, whatever packet authentication checks that can be performed
      immediately upon reception of the packet MUST be performed before
      accepting the packet and performing any congestion control-related
      action on it. Some packet authentication schemes impose a delay of
      several seconds between when a packet is received and when the packet
      can be fully authenticated. Any appropriate congestion control related
      action MUST NOT be postponed by any such full packet authentication
      (i.e. authentication mechanisms MUST NOT result in poor congestion
      control behavior).</t>

      <t>Consideration MUST also be given to the potential for replay-attacks
      that would transplant authenticated packets from one NORM session to
      another to disrupt service. To avoid this potential, unique keys SHOULD
      be assigned on a per-session basis or NORM sender nodes SHOULD be
      configured to use unique "instance_id" identifiers managed as part of
      the security association for the sessions.</t>

      <t>Note NORM implementations can use the "sequence" field from the NORM
      Common Message Header to detect replay attacks. This can be accomplished
      if the NORM sender maintains state on actively NACKing receivers. A
      cache of such receiver state can be used to provide protection against
      NACK replay attacks. NORM receivers MUST also maintain similar state for
      protection against possible replay of other receiver messages in ASM
      operation as well. For example, a receiver could be suppressed from
      providing NACK or congestion control feedback by replay of certain
      receiver messages. For these reasons, authentication of NORM messages
      (e.g., via IPsec) SHOULD be applied for protection against similar
      attacks that use fabricated messages. Also, encryption of messages to
      provide confidentiality of application data and protect privacy of users
      MAY also be applied using IPsec or similar mechanisms.</t>

      <t>When applicable security measures are used, automated key management
      mechanisms such as those described in the <xref target="RFC3547">Group
      Domain of Interpretation (GDOI)</xref>, <xref
      target="RFC3830">Multimedia Internet KEYing (MIKEY) </xref> or <xref
      target="RFC4535">Group Secure Association Key Management Protocol
      (GSAKMP)</xref> specifications SHOULD be applied.</t>

      <t>While NORM does leverage FEC-based repair for scalability, this alone
      does not guarantee integrity of received data. Application-level
      integrity-checking of received data content is highly RECOMMENDED.</t>

      <section anchor="NormIPsec" title="Baseline Secure NORM Operation">
        <t>This section describes a baseline mode of secure NORM protocol
        operation based on application of the IPsec security protocol. This
        approach is documented here to provide a reference, interoperable
        secure mode of operation. Additional approaches to NORM security,
        including other forms of IPsec application, MAY be specified in the
        future. For example, the use of the EXT_AUTH header extension could
        enable NORM-specific authentication or security encapsulation headers
        similar to those of IPsec to be specified and inserted into the NORM
        protocol message headers. This would allow header compression
        techniques to be applied to IP and NORM protocol headers when needed
        in a similar fashion to <xref target="RFC3550">RTP</xref> and as
        preserved in the specification for <xref target="RFC3711">Secure Real
        Time Protocol (SRTP)</xref>.</t>

        <t>The baseline approach described is applicable to NORM operation
        configured for SSM (or SSM-like) operation where there is a single
        sender and the receivers are providing unicast feedback. This form of
        NORM operation allows for IPsec to be used with a manageable number of
        security associations (SA).</t>

        <section title="IPsec Approach">
          <t>For NORM one-to-many SSM operation with unicast feedback from
          receivers, each node SHALL be configured with two transport mode
          IPsec security associations and corresponding Security Policy
          Database (SPD) entries. One entry will be used for sender-to-group
          multicast packet authentication and optionally encryption while the
          other entry will be used to provide security for the unicast
          feedback messaging from the receiver(s) to the sender.</t>

          <t>The NORM sender SHALL use an IPsec SA configured for <xref
          target="RFC4303">ESP protocol</xref> operation with the option for
          data origination authentication enabled. It is also RECOMMENDED this
          IPsec ESP SA be also configured to provide confidentiality
          protection for IP packets containing NORM protocol messages. This is
          suggested to make the realization of complex replay attacks much
          more difficult. The encryption key for this SA SHALL be preplaced at
          the sender and receiver(s) prior to NORM protocol operation. Use of
          automated key management is RECOMMENDED as a rekey SHALL be REQUIRED
          prior to expiration of the sequence space for the SA. This is
          necessary so receivers can use the built-in IPsec replay attack
          protection possible for an IPsec SA with a single source (the NORM
          sender). Thus the receivers SHALL enable replay attack protection
          for this SA used to secure NORM sender traffic. An IPsec SPD entry
          MUST be configured to process outbound packets to the session
          (destination) address and UDP port number of the applicable (<spanx
          style="emph">NormSession</spanx>).</t>

          <t>The NORM receiver(s) MUST be configured with the SA and SPD entry
          to properly process the IPsec-secured packets from the sender. The
          NORM receiver(s) SHALL also use a common, second IPsec SA (common
          Security Parameter Index (SPI) and encryption key) configured for
          ESP operation with the option for data origination authentication
          enabled. Similar to the NORM sender, is RECOMMENDED this IPsec ESP
          SA be also configured to provide confidentiality protection for IP
          packets containing NORM protocol messages. The receivers MUST have
          an IPsec SPD entry configured to process outbound NORM/UDP packets
          directed to the NORM sender source address and port number using
          this second SA. To support NORM unicast feedback, the sender's
          transmission port number SHOULD be selected to be distinct from the
          multicast session port number to allow discrimination between
          unicast and multicast feedback messages when access to the IP
          destination address is not possible (e.g., a user-space NORM
          implementation). For processing of packets from receivers, the NORM
          sender SHALL be configured with this common, second SA (and the
          corresponding SPD entry needed) in order to properly process
          messages from the receiver.</t>

          <t>Multiple receivers using a common IPsec SA for traffic directed
          to the NORM sender (i.e., many-to-one) typically prevents the use of
          built-in IPsec replay attack protection by the NORM sender with
          current IPsec implementations. Thus the built-in IPsec replay attack
          protection for this second SA at the sender MUST be disabled unless
          the particular IPsec implementation manages its replay protection on
          a per-source basis. So, to support a fully secure mode of operation,
          the NORM sender implementation MUST provide replay attack protection
          based upon the "sequence" field of NORM protocol messages from
          receivers. This can be accomplished with high assurance of security,
          even with the limited size (16-bits) of this field, because</t>

          <t><list style="numbers">
              <t>NORM receiver NACK and non-CLR ACK feedback messages are
              sparse.</t>

              <t>The more frequent <spanx style="verb">NORM_ACK</spanx>
              feedback from CLR or PLR nodes are only a small set of receivers
              for which the sender needs to keep more persistent replay attack
              state.</t>

              <t><spanx style="verb">NORM_NACK</spanx> feedback messages
              preceding the sender's current repair window do not
              significantly impact protocol operation (generation of <spanx
              style="verb">NORM_CMD(SQUELCH)</spanx> is limited) and could be
              in fact ignored. This means the sender can prune any replay
              attack state that precedes the current repair window.</t>

              <t><spanx style="verb">NORM_ACK</spanx> messages correspond to
              either a specific sender "ack_id", the sender "cc_sequence" for
              ACKs sent in response to <spanx style="verb">NORM_CMD(CC)</spanx>,
              or the sender's current repair window in the case of ACKs sent
              in response to <spanx style="verb">NORM_CMD(FLUSH)</spanx>.
              Thus, the sender can prune any replay attack state for receivers
              that precede the current applicable sequence or repair window
              space.</t>
            </list></t>

          <t>The use of ESP confidentiality for secure NORM protocol operation
          makes it more difficult for adversaries to conduct any form of
          replay attacks. Additionally, a NORM sender implementation with
          access to the full ESP protocol header could also use the ESP
          sequence information to make replay attack protection even more
          robust by maintaining per-source sequence state. The design of this
          baseline security approach for NORM intentionally places any more
          complex processing state or processing (e.g. replay attack
          protection given multiple receivers) at the NORM sender since NORM
          receiver implementations might often need to be less complex.</t>

          <t>This baseline approach can be used for NORM protocol sessions
          with multiple senders if the SA pairs described are established for
          each sender. For small-sized groups, it is even possible
          many-to-many (ASM) IPsec configuration could be achieved where each
          participant uses a unique SA (with a unique SPI). This does not
          scale to larger group sizes given the complex set of SA and SPD
          entries each participant would need to maintain.</t>

          <t>It is anticipated in early deployments of this baseline approach
          to NORM security that key management will be conducted out-of-band
          with respect to NORM protocol operation. In the case of one-to-many
          NORM operation, it is possible receivers will retrieve keying
          information from a central server as needed or otherwise conduct
          group key updates with a similar centralized approach.
          Alternatively, it is possible with some key management schemes for
          rekey messages to be transmitted to the group as a message or
          transport object within the NORM reliable transfer session.
          Similarly, for group-wise communication sessions it is possible for
          potential group participants to request keying and/or rekeying as
          part of NORM communications. Additional specification is necessary
          to define an in-band key management scheme for NORM sessions perhaps
          using the mechanisms of the automated group key management
          specifications cited in this document.</t>
        </section>

        <section title="IPsec Requirements">
          <t>In order to implement this secure mode of NORM protocol
          operation, the following IPsec capabilities are REQUIRED.</t>

          <section title="Selectors">
            <t>The implementation MUST be able to use the source address,
            destination address, protocol (UDP), and UDP port numbers as
            selectors in the SPD.</t>
          </section>

          <section title="Mode">
            <t>IPsec in transport mode MUST be supported. The use of <xref
            target="RFC4301">IPsec</xref> processing for secure NORM traffic
            MUST be configured such that unauthenticated packets are not
            received by the NORM protocol implementation.</t>
          </section>

          <section title="Key Management">
            <t>An automated key management scheme for group key distribution
            and rekeying such as <xref target="RFC3547">GDOI</xref>, <xref
            target="RFC4535">GSAKMP</xref>, or <xref
            target="RFC3830">MIKEY</xref> is RECOMMENDED for use. Relatively
            short-lived NORM sessions MAY be able to use Manual Keying with a
            single, preplaced key, particularly if <xref
            target="RFC4303">Extended Sequence Numbering (ESN)</xref> is
            available in the IPsec implementation used. Note it is possible
            for key update messages (e.g., the GDOI GROUPKEY-PUSH message) to
            be included as part of the NORM application reliable data
            transmission if appropriate interfaces are available between the
            NORM application and the key management daemon.</t>
          </section>

          <section title="Security Policy">
            <t>Receivers MUST accept protocol messages only from the
            designated, authorized sender(s). Appropriate key management will
            provide encryption keys only to receivers authorized to
            participate in a designated session. The approach outlined here
            allows receiver sets to be controlled on a per-sender basis.</t>
          </section>

          <section title="Authentication and Encryption">
            <t>Large NORM group sizes will necessitate some form of key
            management that does rely upon shared secrets. The GDOI and GSAKMP
            protocols mentioned here allow for certificate-based
            authentication. It is RECOMMENDED these certificates use IP
            addresses for authentication.</t>
          </section>

          <section title="Availability">
            <t>The IPsec requirements profile outlined here is commonly
            available on many potential NORM hosts. Configuration and
            operation of IPsec typically requires privileged user
            authorization. Automated key management implementations are
            typically configured with the privileges necessary to effect
            system IPsec configuration needed.</t>
          </section>
        </section>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>Values of NORM Header Extension Types, Stream Control Codes, and
      <spanx style="verb">NORM_CMD</spanx> message sub-types are subject to
      IANA registration. They are in the registry named "Reliable Multicast
      Transport (RMT) NORM Protocol Parameters" located at time of publication
      at:</t>

      <t><eref
      target="http://www.iana.org/assignments/norm-parameters">http://www.iana.org/assignments/norm-parameters</eref></t>

      <t>Note the reliable multicast building block components used by this
      specification also have their respective IANA considerations and those
      documents SHOULD be consulted accordingly. In particular, the FEC
      Building Block used by NORM does REQUIRE IANA registration of the FEC
      codecs used. The registration instructions for FEC codecs are provided
      in <xref format="none" target="RFC5052">RFC 5052</xref>. It is possible
      additional extensions of the NORM protocol might be specified in the
      future (e.g., additional NORM message types) and additional registries
      be established at that time with appropriate IETF standards action.</t>

      <section title="Explicit IANA Assignment Guidelines">
        <t>This document introduces three registries for the NORM Header
        Extension Types, Stream Control Codes and <spanx style="verb">NORM_CMD</spanx>
        Message sub-types. This section describes explicit IANA assignment
        guidelines for each of these.</t>

        <section title="NORM Header Extension Types">
          <t>This document defines a registry for NORM Header Extensions named
          "NORM Header Extension Types".</t>

          <t>The NORM Header Extension Type field is an 8-bit value. The
          values of this field identify extended header content allowing the
          protocol functionality to be expanded to include additional features
          and operating modes. The values that can be assigned within the
          "NORM Header Extensions" registry are numeric indexes in the range
          {0, 255}, boundaries included. Values in the range {0,127} indicate
          variable length extended header fields while values in the range
          {128,255} indicate extensions of a fixed 4-byte length. This
          specification registers the following NORM Header Extension
          Types:</t>

          <texttable>
            <ttcol>Value</ttcol>

            <ttcol>Name</ttcol>

            <ttcol>Reference</ttcol>

            <c>1</c>

            <c><spanx style="verb">EXT_AUTH</spanx></c>

            <c>This specification</c>

            <c>3</c>

            <c><spanx style="verb">EXT_CC</spanx></c>

            <c>This specification</c>

            <c>64</c>

            <c><spanx style="verb">EXT_FTI</spanx></c>

            <c>This specification</c>

            <c>128</c>

            <c><spanx style="verb">EXT_RATE</spanx></c>

            <c>This specification</c>
          </texttable>

          <t>Requests for assignment of additional NORM Header Extension Type
          values are granted on a "Specification Required" basis as defined by
          <xref target="RFC5226">IANA Guidelines</xref>. Any such header
          extension specifications MUST include a description of protocol
          actions to be taken when the extension type is encountered by a
          protocol implementation not supporting that specific option. For
          example, it is often possible for protocol implementations to ignore
          unknown header extensions.</t>
        </section>

        <section title="NORM Stream Control Codes">
          <t>This document defines a registry for NORM Stream Control Codes
          named "NORM Stream Control Codes".</t>

          <t>NORM Stream Control Codes are 16-bit values that can be inserted
          within a <spanx style="verb">NORM_OBJECT_STREAM</spanx> delivery
          object to convey sequenced, out-of-band (with respect to the stream
          data) control signaling applicable to the referenced stream object.
          These control codes are to be delivered to the application or
          protocol implementation with reliable delivery, in-order with
          respect to the their inserted position within the stream. This
          specification registers the following NORM Stream Control Code:</t>

          <texttable align="center">
            <ttcol>Value</ttcol>

            <ttcol>Name</ttcol>

            <ttcol>Reference</ttcol>

            <c>0</c>

            <c><spanx style="verb">NORM_STREAM_END</spanx></c>

            <c>This specification</c>
          </texttable>

          <t>Additional NORM Stream Control Code value assignment requests are
          granted on a "Specification Required" basis as defined by <xref
          target="RFC5226">IANA Guidelines</xref>. The full 16-bit space
          outside of the value assigned in this specification are available
          for future assignment. In addition to describing the control code's
          expected interpretation, such specifications MUST include a
          description of protocol actions to be taken when the control code is
          encountered by a protocol implementation not supporting that
          specific option.</t>
        </section>

        <section title="NORM_CMD Message Sub-types">
          <t>This document defines a registry for <spanx style="verb">NORM_CMD</spanx>
          message sub-types named "NORM Command Message Sub-types".</t>

          <t>The <spanx style="verb">NORM_CMD</spanx> message "sub-type" field
          is an 8-bit value with valid values in the range of 1-255. Note the
          value 0 is reserved to indicate an invalid <spanx style="verb">NORM_CMD</spanx>
          message sub-type. The current specification defines a number of
          <spanx style="verb">NORM_CMD</spanx> message sub-types senders can
          use to signal the receivers in various aspects of NORM protocol
          operation. This specification registers the following <spanx
          style="verb">NORM_CMD</spanx> Message Sub-types:</t>

          <texttable>
            <ttcol>Value</ttcol>

            <ttcol>Name</ttcol>

            <ttcol>Reference</ttcol>

            <c>0</c>

            <c>reserved</c>

            <c>This specification</c>

            <c>1</c>

            <c><spanx style="verb">NORM_CMD(FLUSH)</spanx></c>

            <c>This specification</c>

            <c>2</c>

            <c><spanx style="verb">NORM_CMD(EOT)</spanx></c>

            <c>This specification</c>

            <c>3</c>

            <c><spanx style="verb">NORM_CMD(SQUELCH)</spanx></c>

            <c>This specification</c>

            <c>4</c>

            <c><spanx style="verb">NORM_CMD(CC)</spanx></c>

            <c>This specification</c>

            <c>5</c>

            <c><spanx style="verb">NORM_CMD(REPAIR_ADV)</spanx></c>

            <c>This specification</c>

            <c>6</c>

            <c><spanx style="verb">NORM_CMD(ACK_REQ)</spanx></c>

            <c>This specification</c>

            <c>7</c>

            <c><spanx style="verb">NORM_CMD(APPLICATION)</spanx></c>

            <c>This specification</c>
          </texttable>

          <t>Future specifications extending NORM MAY define additional <spanx
          style="verb">NORM_CMD</spanx> messages to enhance protocol
          functionality. <spanx style="verb">NORM_CMD</spanx> message sub-type
          value assignment requests are granted on a "Specification Required"
          basis as defined by <xref target="RFC5226">IANA Guidelines</xref>.
          In addition to describing the command sub-type's expected
          interpretation, specifications MUST include a description of
          protocol actions to be taken when the command is encountered by a
          protocol implementation not supporting that specific option.</t>

          <t>This specification already defines an "application-defined"
          <spanx style="verb">NORM_CMD</spanx> message sub-type for use at the
          discretion of individual applications using NORM for transport.
          These "application-defined" commands are suitable for many
          application-specific purposes and do not involve standards action.
          In any case, such additional messages SHALL be subject to the same
          congestion control constraints as the existing NORM sender message
          set.</t>
        </section>
      </section>
    </section>

    <section title="Suggested Use">
      <t>The present NORM protocol is seen as useful tool for the reliable
      data transfer over generic IP multicast services. It is not the
      intention of the authors to suggest it is suitable for supporting all
      envisioned multicast reliability requirements. NORM provides a simple
      and flexible framework for multicast applications with a degree of
      concern for network traffic implosion and protocol overhead efficiency.
      NORM-like protocols have been successfully demonstrated within the MBone
      for bulk data dissemination applications, including weather satellite
      compressed imagery updates servicing a large group of receivers and a
      generic web content reliable "push" application.</t>

      <t>In addition, this framework approach has some design features making
      it attractive for bulk transfer in asymmetric and wireless internetwork
      applications. NORM is capable of successfully operating independent of
      network structure and in environments with high packet loss, delay, and
      out-of-order delivery. Hybrid proactive/reactive FEC-based repairing
      improve protocol performance in some multicast scenarios. A sender-only
      repair approach often makes additional engineering sense in asymmetric
      networks. NORM's unicast feedback capability is suitable for use in
      asymmetric networks or in networks where only unidirectional multicast
      routing/delivery service exists. Asymmetric architectures supporting
      multicast delivery are likely to make up an important portion of the
      future Internet structure (e.g., direct broadcast satellite (DBS) or
      cable and public-switched telephone network (PSTN) hybrids, etc) and
      efficient, reliable bulk data transfer will be an important capability
      for servicing large groups of subscribed receivers.</t>
    </section>

    <section anchor="ProtocolChanges" title="Changes from RFC3940">
      <t>This section lists the changes between the Experimental version of
      this specification, <xref format="none" target="RFC3940">RFC
      3940</xref>, and this version:</t>

      <t><list style="numbers">
          <t>Removal of the <spanx style="verb">NORM_FLAG_MSG_START</spanx>
          for <spanx style="verb">NORM_OBJECT_STREAM</spanx>, replacing it
          with the "payload_msg_start" field in the FEC-encoded preamble of
          the <spanx style="verb">NORM_OBJECT_STREAM NORM_DATA</spanx>
          payload,</t>

          <t>Definition of IANA registry for header extension and other
          assignments,</t>

          <t>Removal of file blocking scheme description now specified in the
          <xref target="RFC5052">FEC Building Block document</xref>,</t>

          <t>Removal of restriction of NORM receiver feedback message rate to
          local NORM sender rate (This caused congestion control failures in
          high speed operation. The extremely low feedback rate of the NORM
          protocol as compared to TCP avoids any resultant impact to the
          network as shown in <xref target="Mdpcc"></xref>),</t>

          <t>Correction of errors in some message format descriptions, and</t>

          <t>Correction of inconsistency in specification of the inactivity
          timeout.</t>

          <t>Addition of IPsec secure mode description with IPsec
          requirements.</t>

          <t>Addition of the EXT_AUTH header extension definition.</t>

          <t>Clarification of interpretation of "Source Block Length" when FEC
          codes are arbitrarily shortened by the sender.</t>
        </list></t>
    </section>

    <section title="Acknowledgments">
      <t>(and these are not Negative)</t>

      <t>The authors would like to thank Rick Jones, Vincent Roca, Rod Walsh,
      Toni Paila, Michael Luby, and Joerg Widmer for their valuable input and
      comments on this document. The authors would also like to thank the RMT
      working group chairs, Roger Kermode and Lorenzo Vicisano, for their
      support in development of this specification, and Sally Floyd for her
      early input into this document.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.1112"?>

      <?rfc include="reference.RFC.5401"?>

      <?rfc include="reference.RFC.5052"?>

      <?rfc include="reference.RFC.4607"?>

      <?rfc include="reference.RFC.2119"?>

      <?rfc include="reference.RFC.4303"?>

      <?rfc include="reference.RFC.5226"?>

      <?rfc include="reference.RFC.4301"?>

      <?rfc include="reference.RFC.4654"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.3269"?>

      <?rfc include="reference.RFC.3940"?>

      <?rfc include="reference.RFC.4566"?>

      <?rfc include="reference.RFC.2974"?>

      <?rfc include="reference.RFC.5445"?>

      <reference anchor="RmComparison">
        <front>
          <title>A Comparison of Sender-Initiated and Receiver-Initiated
          Reliable Multicast Protocols</title>

          <author fullname="S. Pingali" initials="S." surname="Pingali">
            <organization></organization>
          </author>

          <author fullname="Don Towsley" initials="D." surname="Towsley">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author fullname="Jim Kurose" initials="J." surname="Kurose">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="October" year="1993" />
        </front>

        <seriesInfo name="Proc. INFOCOMM," value="San Francisco CA" />
      </reference>

      <?rfc include="reference.RFC.3453"?>

      <reference anchor="MdpToolkit">
        <front>
          <title>The Multicast Dissemination Protocol (MDP) Toolkit</title>

          <author fullname="Joseph Macker" initials=" J." surname="Macker">
            <organization></organization>
          </author>

          <author fullname="Brian Adamson" initials="B." surname="Adamson">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="October" year="1999" />
        </front>

        <seriesInfo name="Proc. IEEE MILCOM" value="" />
      </reference>

      <reference anchor="McastFeedback">
        <front>
          <title>Optimal Multicast Feedback</title>

          <author fullname="J. Nonnenmacher" initials="J."
                  surname="Nonnenmacher">
            <organization></organization>
          </author>

          <author fullname="E. Biersack" initials="E." surname="Biersack">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="March/April" year="1998" />
        </front>

        <seriesInfo name="IEEE INFOCOM, " value="p. 964" />
      </reference>

      <reference anchor="NormFeedback">
        <front>
          <title>Quantitative Prediction of NACK-Oriented Reliable Multicast
          (NORM) Feedback</title>

          <author fullname="Brian Adamson" initials="B." surname="Adamson">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author fullname="Joseph Macker" initials=" J." surname="Macker">
            <organization></organization>
          </author>

          <date month="October" year="2002" />
        </front>

        <seriesInfo name="IEEE MILCOM" value="" />
      </reference>

      <reference anchor="FecHybrid">
        <front>
          <title>Reliable Multicast and Integrated Parity Retransmission with
          Channel Estimation</title>

          <author fullname="Don Gossink" initials="D." surname="Gossink">
            <organization></organization>
          </author>

          <author fullname="Joseph Macker" initials="J." surname="Macker">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="" year="1998" />
        </front>

        <seriesInfo name="IEEE Globecomm " value="" />
      </reference>

      <?rfc include="reference.RFC.3048"?>

      <?rfc include="reference.RFC.3550"?>

      <?rfc include="reference.RFC.2357"?>

      <?rfc include="reference.RFC.3711"?>

      <reference anchor="TfmccPaper">
        <front>
          <title>Extending Equation-Based Congestion Control to Multicast
          Applications</title>

          <author fullname="Joerg Widmer" initials="J." surname="Widmer">
            <organization>Joerg</organization>
          </author>

          <author fullname="Mark Handley" initials="M." surname="Handley">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="August" year="2001" />
        </front>

        <seriesInfo name="ACM SIGCOMM" value="" />
      </reference>

      <reference anchor="PgmccPaper">
        <front>
          <title>pgmcc: A TCP-Friendly Single-Rate Multicast Congestion
          Control Scheme</title>

          <author fullname="Luigi Rizzo" initials="L." surname="Rizzo">
            <organization></organization>
          </author>

          <date month="August" year="2000" />
        </front>

        <seriesInfo name="ACM SIGCOMM" value="" />
      </reference>

      <reference anchor="TcpModel">
        <front>
          <title>Modeling TCP Throughput: A Simple Model and its Empirical
          Validation</title>

          <author fullname="J. Padhye" initials=" J." surname="Padhye">
            <organization></organization>
          </author>

          <author fullname="V. Firoiu" initials="V." surname="Firoiu">
            <organization>Firoiu</organization>
          </author>

          <author fullname="D. Towsley" initials="D." surname="Towsley">
            <organization></organization>
          </author>

          <author fullname="J. Kurose" initials="J." surname="Kurose">
            <organization></organization>
          </author>

          <date year="1998" />
        </front>

        <seriesInfo name="ACM SIGCOMM" value="" />
      </reference>

      <?rfc include="reference.RFC.3547"?>

      <?rfc include="reference.RFC.3830"?>

      <?rfc include="reference.RFC.4535"?>

      <reference anchor="Mdpcc">
        <front>
          <title>A TCP-Friendly, Rate-based Mechanism for NACK-Oriented
          Reliable Multicast Congestion Control</title>

          <author fullname="Brian Adamson" initials=" B." surname="Adamson">
            <organization></organization>
          </author>

          <author fullname="Joseph Macker" initials="J." surname="Macker">
            <organization>J</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="November" year="2001" />
        </front>

        <seriesInfo name="Proc. IEEE GLOBECOMM" value="" />
      </reference>
    </references>
  </back>
</rfc>
