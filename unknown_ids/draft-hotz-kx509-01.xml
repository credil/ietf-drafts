<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2782 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2782.xml">
<!ENTITY RFC3447 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY RFC5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY RFC4120 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml">
<!ENTITY RFC4556 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4556.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc symrefs="yes"?>
<rfc category="info" docName="draft-hotz-kx509-01.txt" ipr="trust200902">
  <front>
    <title abbrev="KX509">KX509 Kerberized Certificate Issuance
    Protocol</title>

    <author fullname="Henry B. Hotz" initials="H. B." surname="Hotz">
      <organization>Jet Propulsion Laboratory, California Institute of
      Technology</organization>

      <address>
        <postal>
          <street>4800 Oak Grove Dr.</street>

          <!-- Reorder these if your country does things differently -->

          <city>Pasadena</city>

          <region>CA</region>

          <code>91109</code>

          <country>US</country>
        </postal>

        <phone>+01 818 354-4880</phone>

        <email>hotz@jpl.nasa.gov</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <date year="2010" />

    <area>General</area>

    <workgroup>Kerberos Working Group</workgroup>

    <!---->

    <keyword>protocol</keyword>

    <abstract>
      <t>This rfc describes a protocol, called kx509, for using Kerberos
      tickets to acquire X.509 certificates.</t>

      <t>While not (previously) standardized, this protocol is already in use
      at several large organizations, and certificates issued with this
      protocol are recognized by TAGPMA (The Americas Grid Policy Management
      Authority).</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The two primary ways of providing cryptographically secure
      identification on the Internet are Kerberos tickets <xref
      target="RFC4120"></xref>, and X.509 <xref target="RFC5280"></xref> and
      <xref target="X.509"></xref> certificates.</t>

      <t>In practical IT infrastructure where both are in use, it's highly
      desirable to deploy their support in a way which guarantees they both
      authoritatively refer to the same entities. There is already a
      widely-adopted standard for using X.509 certificates to acquire
      corresponding Kerberos tickets called PKINIT <xref
      target="RFC4556"></xref>. This rfc describes the kx509 protocol for
      supporting the symmetric operation of acquiring X.509 certificates using
      Kerberos tickets.</t>

      <t>In normal operation kx509 can be used after a Kerberos
      ticket-granting-ticket (TGT) is acquired, which is most likely during
      user login. First, the client generates a RSA public/private key-pair.
      Next, using the Kerberos ticket-granting-ticket, it acquires a Kerberos
      service ticket for the KCA (Kerberized Certificate Authority), and uses
      this to send the public half of its key-pair. The KCA will decrypt the
      service ticket, verify the integrity of the incoming packet, determine
      the identity of the user, and use the session key to send back a
      corresponding X.509 certificate.</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119">RFC 2119</xref>.</t>
      </section>
    </section>

    <section title="Protocol Data">
      <t>The protocol consists of a single request/reply exchange using
      UDP.</t>

      <t>Both the request and the reply packet begin with four bytes of
      version ID information, followed by a DER encoded ASN.1 message. The
      first two bytes of the version ID are reserved. They MUST be set to zero
      when sent, and SHOULD be ignored when received. The third and fourth
      bytes are the major and minor version numbers. The version of the
      protocol described in this document is designated 2.0, so the first four
      bytes of the packet are 0, 0, 2, 0.</t>

      <t>Incompatible variations of this protocol MUST use a different major
      version number.</t>

      <section title="Request Packet">
        <t>The request consists of a version ID, a Kerberos AP_REQ, integrity
        check data on the request, and a public key generated by the client.
        The ASN.1 encoding is:</t>

        <t></t>

        <figure>
          <artwork type="ASN.1"><![CDATA[KX509Request ::= SEQUENCE {
        ap-req OCTET STRING,
        pk-hash OCTET STRING,
        pk-key OCTET STRING
}]]></artwork>
        </figure>

        <t>The ap-req is as described in <xref target="RFC4120"></xref>
        Section 5.5.1.</t>

        <t>The pk-hash is HMAC using SHA-1 as the underlying hash. All 160
        bits are sent. The key used is the Kerberos session key. The data is
        the 4-byte version ID and the octet string for pk-key.</t>

        <t>The pk-key contains a public key. This key and its corresponding
        private key are generated by the client before contacting the server.
        Implementations of this protocol MUST support RSA keys, in which case
        the key is a DER encoded RSAPublicKey as defined in <xref
        target="RFC3447"></xref>, section A.1.1, and then stored in this octet
        string in the request. Use of other public-key types is not
        defined.</t>
      </section>

      <section title="Reply Packet">
        <t>The reply consists of a version ID, an error code, and an optional
        authentication hash, optional certificate, and optional error text.
        The service SHOULD return replies of the same version as the request
        where possible.</t>

        <t></t>

        <figure>
          <artwork type="ASN.1"><![CDATA[KX509Response ::= SEQUENCE {
        error-code[0] INTEGER DEFAULT 0,
        hash[1] OCTET STRING OPTIONAL,
        certificate[2] OCTET STRING OPTIONAL,
        e-text[3] VisibleString OPTIONAL
}]]></artwork>
        </figure>

        <t>Although the format of the reply contains independently optional
        objects, the server MUST only generate replies with one of the
        following allowed combinations.</t>

        <texttable>
          <ttcol></ttcol>

          <ttcol></ttcol>

          <ttcol></ttcol>

          <c>certificate</c>

          <c></c>

          <c>hash</c>

          <c>error-code</c>

          <c>e-text</c>

          <c>hash</c>

          <c>error-code</c>

          <c>e-text</c>

          <c></c>
        </texttable>

        <t>The first case is returned when the server successfully generates a
        certificate for the user. The certificate is a DER encoded Certificate
        as defined in <xref target="RFC5280"></xref> Section A, page 116.</t>

        <t>The second case is returned when the server successfully
        authenticates the user and their key, but is unable for some other
        reason to generate a certificate.</t>

        <t>The third case MAY be returned if the server is unable to
        successfully authenticate the user and intends to return some
        unauthenticated information to the client.</t>

        <t>The hash on a response is computed using SHA-1 HMAC as for the
        request. The data that is hashed is the concatenation of the 4-byte
        version ID at the beginning of the packet, the error-code (if
        present), and all other optional fields which are present except the
        hash itself. In other words, the hash is computed on the fields which
        are present exclusive of the overall ASN.1 wrapping. The e-text MAY be
        translated into other character sets for display purposes, but the
        hash is computed on the e-text in its VisibleString
        representation.</t>

        <t>If the e-text contains NUL characters, the client MAY ignore any
        part of the error message after the first NUL character for display
        purposes.</t>

        <t>As implied by the above table, if the reply does not contain a
        certificate it MUST contain an error message and a non-zero error
        code. Conversely, if a certificate is returned then the error code
        MUST be zero. The server SHOULD NOT send a zero error-code. The client
        MUST treat a missing error-code as if it were zero.</t>

        <texttable>
          <ttcol>error-code</ttcol>

          <ttcol>Condition</ttcol>

          <ttcol>Example</ttcol>

          <c>1</c>

          <c>Permanent problem with client request</c>

          <c>Incompatible version</c>

          <c>2</c>

          <c>Solvable problem with client request</c>

          <c>Expired Kerberos credentials</c>

          <c>3</c>

          <c>Temporary problem with client request</c>

          <c>Packet loss</c>

          <c>4</c>

          <c>Permanent problem with the server</c>

          <c>Internal misconfiguration</c>

          <c>5</c>

          <c>Temporary problem with the server</c>

          <c>Server overloaded</c>
        </texttable>

        <t>If error-code 1 or 2 is returned, the client SHOULD NOT retry the
        request unless some remedial action is first taken. If error-code 3 is
        returned, the client MAY retry with any or all known servers before
        giving up.</t>

        <t>If a server error is returned, it is RECOMMENDED that the client
        retry the request with a different server if one is known. If all
        known servers have returned server errors, the client MAY retry with
        servers that returned an error-code of 5 before giving up.</t>

        <t>Since all KCAs serving a Kerberos realm are intended to be
        equivalent, in accordance with <xref target="RFC5280"></xref> Section
        4.1.2.2, the certificates returned from different KCAs serving the
        same Kerberos realm MUST NOT contain duplicate serial numbers.</t>

        <t>The returned certificate SHOULD identify the Kerberos client
        principal from the ap-req in the original KX509Request in the subject
        of the cert, or in a subjectAltName extension. It is RECOMMENDED that
        the extension be of type id-pkinit-san as described in <xref
        target="RFC4556"></xref> Section 3.2.2. Note that the id-pkinit-san is
        simply a standard representation of a Kerberos principal, and has no
        other implications with respect to PKINIT.</t>

        <t>Other extensions MAY be added according to local policy. For
        example a subjectAltName othername extension of type kcaAuthRealm (OID
        value 1.3.6.1.4.1.250.42.1) is frequently used to include the
        client&rsquo;s realm as an ASN.1 octet string, and the Microsoft
        userPrincipalName has sometimes been used for the same purpose as the
        id-pkinit-san.</t>
      </section>
    </section>

    <section title="Protocol Operation">
      <t>Absent errors, the protocol consists of a single request, sent via
      UDP, and a single reply, also sent via UDP.</t>

      <t>There is no provision for requests or replies which exceed the
      allowable size of a UDP packet. Furthermore, if the request or reply
      exceeds the MTU size of a UDP packet for the infrastructure in use, then
      the reliability of the exchange will decrease significantly. For
      &ldquo;normal&rdquo; Kerberos ap-req structures, and
      &ldquo;normal&rdquo; X.509 certificates, this is unlikely unless the
      Kerberos service ticket contains large amounts of authorization data.
      For this reason, it is RECOMMENDED that service tickets for the KCA be
      issued without authorization data, and that the KCA perform
      authorization by other means.</t>

      <t>Before constructing the request, the client must know the canonical
      name(s) and port(s) of the server(s) to contact. It MAY determine them
      by looking up the service's SRV record as described in<xref
      target="RFC2782"></xref>. The entry to be used is _kca._udp.<spanx
      style="emph">realm</spanx>, where <spanx style="emph">realm</spanx> is
      the Kerberos realm, used as part of the DNS name.</t>

      <t>The client must then acquire a service ticket in order to construct
      the ap-req for the service. The Kerberos service principal name to use
      for this service has a first component of "kca_service". The second
      component and the realm of the principal follow normal Kerberos
      conventions.</t>

      <t>When the server receives a request, it MUST make sanity checks
      including at least the following:</t>

      <t><list style="symbols">
          <t>The AP-REQ can be decoded and is not expired.</t>

          <t>If the request uses cross-realm authentication, then it satisfies
          the requirements of local policy and <xref target="RFC4120"></xref>
          Sections 1.2 and 2.7.</t>

          <t>The request's hash is valid.</t>
        </list>The server SHOULD make other sanity checks, such as a minimum
      public key length, to the extent feasible.</t>

      <t>The server MAY decline to respond to an erroneous request. If it does
      not receive a response a client MAY retry its request, but the client
      SHOULD wait at least one second before doing so.</t>

      <t>The client MUST verify any hash in the reply, and MUST NOT use any
      certificate in a reply whose hash does not verify. The client MAY
      display the e-text if the hash is absent or does not verify, but SHOULD
      indicate the message is not authenticated.</t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The original version of kx509 was implemented using Kerberos 4 at the
      University of Michigan, and was nicely documented in <xref
      target="KX509"></xref>. Many thanks to them for their original work.</t>

      <t>While developing this document I received important corrections and
      comments from Jeffrey Altman, and Love Hornquist Astrand. I also
      received many helpful comments and corrections from Doug Engert, Jeffrey
      Hutzelman, Sam Hartman, and Timothy J. Miller. Example network traffic
      was provided by Doug Engert, Marcus Watts, and Matt Crawford from their
      deployments, and was extremely useful to verify the reality of this
      specification.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This service is conventionally run on UDP port 9878, but this memo
      includes no request to IANA.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>The only encrypted information in the protocol is that used by
      Kerberos itself. The considerations for any Kerberized service apply
      here.</t>

      <t>The public key in the request is sent in the clear, and without any
      guarantees that the requestor actually possesses the corresponding
      private key. Therefore the only appropriate uses of the returned
      certificate are those where the subsequent use independently guarantees
      that the user possesses the private key. In particular digitalSignature
      MUST NOT be an allowed key usage.</t>

      <t>Some information, such as the public key and certificate, is
      transmitted in the clear but (as the name implies) were designed to be
      publicly available. However their visibility could still raise privacy
      concerns. The hash is used to protect their integrity.</t>

      <t>The policies for issuing Kerberos tickets and X.509 certificates are
      usually expressed very differently. An implementation of this protocol
      should not provide a mechanism for bypassing ticket or certificate
      policies.</t>

      <t>In particular, if the issued certificate can be used with PKINIT,
      this authentication loop should not bypass policy limits for either
      X.509 certificates or Kerberos tickets. Since a PKINIT request must be
      signed and digitalSignature is not an allowed usage for the issued
      certificate, this loop should not occur.</t>

      <t>X.509 certificates are usually issued with considerably longer
      validity times than Kerberos tickets. Care should be taken that the
      issued certificate is not valid for longer than the intended policy
      should allow. Note that<xref target="RFC4556"></xref> Section 3.2.3.1
      REQUIRES that the lifetime of an issued ticket not exceed the lifetime
      of the predecessor certificate. By analogy it is RECOMMENDED that the
      lifetime of an issued certificate not exceed the lifetime of the
      predecessor Kerberos ticket.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &RFC2119;

      &RFC2782;

      &RFC3447;

      &RFC4120;

      &RFC4556;

      &RFC5280;
    </references>

    <references title="Informative References">
      <reference anchor="X.509">
        <front>
          <title>Recommendation X.509: The Directory: Public-key and attribute
          certificate framework</title>

          <author>
            <organization>International Telecommunications
            Union</organization>
          </author>

          <date month="November" year="2008" />
        </front>

        <format type="TXT" />
      </reference>

      <reference anchor="KX509"
                 target="http://www.citi.umich.edu/techreports/reports/citi-tr-01-2.pdf">
        <front>
          <title>The KX509 Protocol</title>

          <author fullname="William Doster" initials="W." surname="Doster">
            <organization abbrev="UMICH">University of Michigan</organization>
          </author>

          <author fullname="Marcus Watts" initials="M." surname="Watts">
            <organization abbrev="UMICH">University of Michigan</organization>
          </author>

          <author fullname="Dan Hyde" initials="D." surname="Hyde">
            <organization abbrev="UMICH">University of Michigan</organization>
          </author>

          <date month="September" year="2001" />
        </front>

        <format type="TXT" />
      </reference>
    </references>

    <section anchor="app-additional"
             title="Certificate Cacheing and Deployment Considerations">
      <t>As noted in the Security Considerations section, the functional
      lifetime of the acquired X.509 certificate should match the lifetime of
      its predecessor Kerberos ticket. Therefore, it is likely that X.509
      certificates issued with this protocol should be deleted when the
      supporting Kerberos tickets are deleted. That makes the Kerberos ticket
      cache a reasonable location to store the certificate (and its private
      key).</t>

      <t>On the other hand applications, such as web browsers, probably expect
      certificates in different stores.</t>

      <t>A widely used solution to this dichotomy is to implement a PKCS11
      library which supports the KX509-acquired credentials.</t>
    </section>

    <section title="Known Issues with This Draft">
      <t></t>

      <t><list style="numbers">
          <t>This draft only describes the existing in-the-wild protocol,
          which has some warts. We need an updated, standards-track
          protocol.</t>

          <t>Should IANA registration of a service port be requested?</t>

          <t>Is there anything that should be added to clarify how Windows
          might interact with this service? (e.g. more detail on SRV records
          in section 3?)</t>

          <t>Should timeouts be more fully specified? Should retry behavior be
          less specified? Any other issues with error-handling?</t>

          <t>Several people suggested more information be given on UDP size
          restrictions and their effect on reliability. Is the text in section
          3 sufficient?</t>

          <t>The original code has provisions for DSA private keys in addition
          to RSA. Nobody seems to use DSA. Everyone seems to use RSA. Should
          we specify DSA as an allowed alternative?</t>
        </list></t>
    </section>
  </back>
</rfc>
