<?xml version="1.0" encoding="US-ASCII"?>
<!-- this file is based off the xml2rfc template from http://xml.resource.org/               -->
<!-- 678901234567890123456789012345678901234567890123456789012345678901*34567890123456789012 -->
<!-- the following CSS stylesheet makes oxygen author mode happy                             -->
<?xml-stylesheet type="text/css" href="XML/rfc2629.css"?>

<!-- this stylesheet is used for xml -> xhtml translation                                    -->
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<!-- note this doctype uses entities from bibxml. ack! we need to get a reasonable local     -->
<!-- catalog working.                                                                        -->
<!DOCTYPE rfc SYSTEM "XML/rfc2629/rfc2629.dtd" [
  <!ENTITY RFC2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
  <!ENTITY RFC4288 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4288.xml">
  <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
  <!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
  <!ENTITY RFC2817 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2817.xml">
  <!ENTITY RFC3339 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
  <!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
  <!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
  <!ENTITY RFC4122 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4122.xml">
  <!ENTITY RFC4627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
  <!ENTITY RFC4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
  <!ENTITY RFC5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
  <!ENTITY RFC5234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml">
]>

<!-- For a complete list and description of processing instructions (PIs), please see        -->
<!-- http://xml.resource.org/authoring/README.html.                                          -->

<!-- give errors regarding ID-nits and DTD validation                                        -->
<?rfc strict="yes" ?>

<!-- generate a ToC                                                                          -->
<?rfc toc="yes"?>

<!-- the number of levels of subsections in ToC. default: 3                                  -->
<?rfc tocdepth="4"?>

<!-- use symbolic references tags, i.e, [RFC2119] instead of [1]                             -->
<?rfc symrefs="yes"?>

<!-- sort the reference entries alphabetically                                               -->
<?rfc sortrefs="yes" ?>

<!-- control vertical white space (the followign options are recommended by the RFC Editor.) -->
<!-- do not start each main section on a new page                                            -->
<?rfc compact="yes" ?>

<!-- keep one blank line between list items                                                  -->
<?rfc subcompact="no" ?>

<!-- category values incude: std, bcp, info, exp, and historic                               -->
<!-- ipr values include: full3667, noModification3667, noDerivatives3667                     -->
<!-- you can add the attributes updates="NNNN" and obsoletes="NNNN". they will automatically -->
<!-- be output with "(if approved)"                                                          -->
<rfc category="std" docName="draft-hamrick-vwrap-type-system-00" ipr="trust200902">
  
  <front>
    
    <!-- The abbreviated title is used in the page header - it is only necessary if the full -->
    <!-- title is longer than 39 characters                                                  -->
    <title abbrev="VWRAP Abstract Type System">VWRAP : Abstract Type System for the Transmission of Dynamic Structured Data</title>
    
    <!-- add 'role="editor"' below for the editors if appropriate                            -->
    <author fullname="Aaron Brashears" initials="A." surname="Brashears">
      <organization>Linden Research, Inc.</organization>
			<address>
				<postal>
					<street>945 Battery St.</street>
					<city>San Francisco</city>
					<region>CA</region>
					<code>94111</code>
					<country>US</country>
				</postal>
				<phone>+1 415 243 9000</phone>
				<email>aaronb@lindenlab.com</email>
			</address>
    </author>
    
    <author fullname="Meadhbh Siobhan Hamrick" initials="M. S." surname="Hamrick" role="editor">
			<organization>Linden Research, Inc.</organization>
			<address>
				<postal>
					<street>945 Battery St.</street>
					<city>San Francisco</city>
					<region>CA</region>
					<code>94111</code>
					<country>US</country>
				</postal>
			  <phone>+1 817 213 6479</phone>
				<email>infinity@lindenlab.com</email>
			</address>
    </author>
    
    <author fullname="Mark Lentczner" initials="M." surname="Lentczner">
			<organization>Linden Research, Inc.</organization>
			<address>
				<postal>
					<street>945 Battery St.</street>
					<city>San Francisco</city>
					<region>CA</region>
					<code>94111</code> 
					<country>US</country>
				</postal>
				<phone>+1 415 243 9000</phone>
				<email>zero@lindenlab.com</email>
			</address>
    </author>
    
    <!-- If the month and year are both specified and are the current ones, xml2rfc will     -->
    <!-- fill in the current day for you. If only the current year is specified, xml2rfc     -->
    <!-- will fill in the current day and month for you. If the year is not the current one, -->
    <!-- it is necessary to specify at least a month (xml2rfc assumes day="1" if not         -->
    <!-- specified for the purpose of calculating the expiry date).  With drafts it is       -->
    <!-- normally sufficient to specify just the year.                                       -->  
    <date month="February" year="2010"/>
    
    <area>Applications</area>
    
    <!-- WG name at the upperleft corner of the doc, IETF is fine for individual             -->
    <!-- submissions. If this element is not present, the default is "Network Working        -->
    <!-- Group", which is used by the RFC Editor as a nod to the history of the IETF.        -->
    <workgroup>Virtual World Region Agent Protocol</workgroup>
    
    <!-- Keywords will be incorporated into HTML output files in a meta tag but they have no -->
    <!-- effect on text or nroff output. If you submit your draft to the RFC Editor, the     -->
    <!-- keywords will be used for the search engine.                                        -->
    <keyword>llsd</keyword>
    <keyword>llidl</keyword>
    <keyword>virtual world</keyword>
    <keyword>abstract type system</keyword>
    <keyword>interface definition language</keyword>
    
		<abstract>
			<t>This document describes the LLIDL interface description language, the related LLSD
			  abstract type system and three serialization formats for LLIDL messages.
			  LLIDL (pronounced "little") is a language-neutral facility for describing transport
			  independent message flows for RESTful resource access. LLIDL itself is an abstract
			  meta-grammar for producing and recognizing valid request / response messages affecting
			  state change in application layer objects by way of RESTful resource access.
			  It may be used by protocol developers and system deployers to describe the composition
			  of application layer protocol exchanges without adopting transport specific message
			  semantics or programming language specific type semantics.  The type
			  behavior of individual message elements is described by the LLSD abstract type system.
			  Abstract LLIDL messages are concretized using one of three defined LLSD serialization
			  schemes. Serialization / deserialization rules are provided in this document for XML,
			  JSON and Binary schemes. This abstract messaging and type system is intended to be
			  used by other specifications to describe application layer protocol exchanges,
			  independent of implementation language or message transport protocol.</t>
		</abstract>
  </front>
  
	<middle>
		<section title="Introduction">  
		  <t>
		    It is characteristic of modern network services that they are deployed across multiple
		    network hosts. For performance, fault tolerance, ease of deployment or organizational
		    reasons, software and systems implementing network services must now work well in a
		    distributed environment. It is generally believed that such distributed services may be
		    made more robust by making their components "loosely coupled."<xref target="Kaye2003"/>
		    This document describes an interface description language and a related abstract type
		    system used to define interfaces to loosely coupled network services in a programming
		    language, network transport and message serialization independent manner.
		  </t>
		  <t>
		    The LLIDL interface description language may be used to define protocol exchanges for
		    accessing resources exhibiting characteristics of the
		    Representational State Transfer (REST) architecture style. <xref target="Fielding2000"/>
		    LLIDL describes abstract interfaces intended to be reified over HTTP <xref target="RFC2616"/>
		    or HTTPS <xref target="RFC2817"/>. LLIDL resource definitions describe the structure of data
		    provided in an access request, the structure of the data in the access' response and the
		    HTTP verbs which may be used to access the resource.
		  </t>
		  <t>
		    The LLSD abstract type system defines nine simple types (Undefined, Boolean, Integer, Real,
		    String, UUID, Date, URI and Binary) and two composite types (Array and Map.) This system
		    provides a programming language independent framework for describing type semantics of
		    elements in LLIDL messages. Three serialization schemes are defined by this document: XML,
		    JSON and Binary. These schemes are used to concretize LLSD data into octet streams
		    for transmission over a data network. Each serialization scheme has a related
		    MIME content type definition, allowing compliant applications to identify the specific
		    serialization scheme used.
		  </t>
		  <t>
		    LLIDL and LLSD form an abstract system for reasoning about application layer 
		    exchanges without having to repeatedly reference the details of the transport used to
		    deliver messages. Other specifications use LLIDL and LLSD to describe the content
		    of RESTful resource access. This document describes how resource accesses are reified
		    as HTTP(S) protocol exchanges. LLIDL is intended to separate the semantics of application
		    messages from the details of the protocol that carries them. It gives system deployers
		    a tool for succinctly defining application layer exchanges.
		  </t>
		  <t>The LLSD serialization schemes describe how simple and composite
		    types are converted into an octet stream and provides guidelines for transmission across a 
		    network. It does not describe the concretization of abstract LLSD messages into programming
		    language constructs.
		  </t>
		  
			<section title="Requirements Language">
				<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
					"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
					interpreted as described in <xref target="RFC2119">RFC 2119</xref>.</t>
			</section>
		</section>
	  
	  <section anchor="LLSD_TYPES" title="The LLSD Abstract Type System">
			<t>The LLSD abstract type system describes the semantics of  data passed between two
				network hosts. These types characterize the data when serialized for transport, when
				stored in memory, and when accessed by applications.</t>
			<t>The types are designed to be common enough that native types in existing
				serializations and programming languages will be usable directly. It is anticipated
				that LLSD data may be serialized in systems with fewer types or stored in native
				programming language structures with less precise types, and still interoperate in a
				predictable, reliable manner. To support this, conversions are defined to govern how
				data received or stored as one type may be read as another.</t>
			<t>For example, if an application expects to read an LLSD value as an Integer, but the
				serialization used to transport the value only supported Reals, then a conversion
				governs how the application will see the transported value. Another case would be
				where an application wants to read an LLSD value as a URL, but the programing
				language only supports String as a data type. Again, there is a defined conversion
				for this case.</t>
			<t>The intention is that applications will interact with LLSD data via interfaces in
				terms of these types, even if the underlying language or transports do not directly
				support them, while retaining as much direct compatibility with those native types
				as possible.</t>
			<t>An LLSD value is either a simple datum or a composite structure. A simple data value
				can have one of nine simple types: Undefined, Boolean, Integer, Real, String, UUID,
				Date, URI or Binary. Composite structures can be either of the types Array or Map.</t>

		  <section anchor="SIMPLE_TYPES" title="Simple Types">
				<t>For each type, conversions are defined to that type. That is, if a process is
					accessing a particular LLSD value, and treating it as a particular type, but the
					underlying type (as transmitted, or stored in memory) is different, then the
					indicated conversion, if defined, is applied. If a conversion is not specified
					from a particular type, then if a value of that type is accessed, the result is
					the default value for the expected type. For example: When reading a value as an
					integer, if the underlying value is binary, then the value read is zero.</t>
				
		    <section anchor="UNDEFINED" title="Undefined">
					<t>Data of type Undefined has only one value, called undef. The default value is
						undef. There are no defined conversions to Undefined.</t>
					<t>The Undefined type is a placeholder for a value.</t>
				</section>
				
		    <section anchor="BOOLEAN" title="Boolean">
					<t>Data of type Boolean can have one of only two values: true or false. The
						default value is false.</t>
					<t>Conversions: <list hangIndent="4" style="hanging">
							<t hangText="Integer">A zero value (0) is converted to false. All other
								values are converted to true.</t>
							<t hangText="Real">A zero value (0.0) and invalid floating point values
								(NaNs) are converted to false. All other values are converted to
								true.</t>
							<t hangText="String">An empty String is converted to false. Anything
								else is converted to true.</t>
						</list></t>
				</section>
				
		    <section anchor="INTEGER" title="Integer">
					<t>Data of type Integer can have the values of natural numbers between
						-2147483648 and 2147483647 inclusive. The default value for Integer is zero
						(0). </t>
					<t>Conversions: <list hangIndent="4" style="hanging">
							<t hangText="Boolean">The value true is converted to the Integer 1. The
								value false is converted to the Integer 0.</t>
							<t hangText="Real">Real are rounded to the nearest representable
								Integer, with ties being rounded to the nearest even number. Invalid
								floating point values (NaNs) are converted to the Integer 0.
								<!-- TODO: reference IEEE 754 here instead? in addition? --></t>
							<t hangText="String">The string is first converted to type Real, see
									<xref target="REAL_STRING_CONVERSION"/>. Then the resulting Real
								is converted to Integer as specified above.</t>
						</list></t>
				</section>
				
		    <section anchor="REAL" title="Real">
					<t>Data of type contain signed floating precision numeric values from the range
						available with IEEE 754-1985 64-bit double precision values, as well as the
						special non-numeric values (NaNs and Infs) available with that format. The
						default value for Real is zero (0.0).</t>
					<t>Conversions: <list hangIndent="4" style="hanging">
							<t hangText="Boolean">The value true is converted to the floating point
								value 1.0. The value false is converted to the floating point value
								0.0.</t>
							<t hangText="Integer">Integers promoted to floating point values are
								converted to the nearest representable number.</t>
							<t hangText="String">See <xref target="REAL_STRING_CONVERSION"/>.</t>
						</list></t>
				</section>
				
		    <section anchor="STRING" title="String">
					<t>Data of type String contain a sequence of zero or more Unicode code points.
						The default value for String is a sequence of zero code points, the empty
						string ("").</t>
					<t>The characters are restricted to the following code points: <list
							style="empty">
							<t>U+0009, U+000A, U+000D</t>
							<t>U+0020 through U+D7FF</t>
							<t>U+E000 through U+FFFD</t>
							<t>U+10000 through U+10FFFF</t>
						</list><!--Should we include a rationale for this restriction?--></t>
					<t>Strings may be normalized during transport, storage or processing. When an
						implementation does normalize, it should use Normalization Form C (NFC)
						described in <xref target="TR15">Unicode Standard Annex #15</xref>. Line
						endings may be normalized to U+000A.</t>
					<t>Conversions: <list hangIndent="4" style="hanging">
							<t hangText="Boolean">The value true is represented as the string
								"true". The value false is represented as the empty string ("").</t>
							<t hangText="Integer">Integers converted to Strings are represented as
								signed decimal representation.</t>
							<t hangText="Real">See <xref target="REAL_STRING_CONVERSION"/>.</t>
							<t hangText="UUID">UUIDs converted to Strings are represented in the 36
								character, 8-4-4-4-12 format defined in <xref target="RFC4122">RFC
									4122</xref>.</t>
							<t hangText="Date">See <xref target="DATE_STRING_CONVERSION"/>.</t>
							<t hangText="URI">URIs converted to Strings are simply Unicode
								representations of the URI.</t>
						</list></t>
				</section>
				
		    <section anchor="UUID" title="UUID (Universally Unique ID)">
					<t>UUIDs represent a universally unique identifier. Data of type UUID is a 128
						bit identifier with a structure defined in <xref target="RFC4122">RFC
						4122</xref>. The default UUID value is the null UUID,
						(00000000-0000-0000-0000-000000000000).</t>
					<t>Conversions: <list hangIndent="4" style="hanging">
							<t hangText="String">A valid 8-4-4-4-12 string representation of a UUID
								is converted to the UUID it represents. All other values are
								converted to the null UUID
							(00000000-0000-0000-0000-000000000000).</t>
						</list></t>
				</section>
				
		    <section anchor="Date" title="Date">
					<t>Dates represent a moment in time. Data of type Date may have the value of any
						time in the from January 1, 1970 though at least January 1, 2038, to at
						least second accuracy. The default date is defined as the beginning of the
						Unix(tm) epoch, midnight, January 1, 1970 in the UTC time
						zone.<!--we are going to need a better definition of date here--></t>
					<t>Conversions: <list hangIndent="4" style="hanging">
							<t hangText="String">See <xref target="DATE_STRING_CONVERSION"/>.</t>
						</list></t>
				</section>
				
		    <section anchor="URI" title="URI (Uniform Resource Identifier)">
					<t>Data of type URI has the value of a Uniform Resource Identifier as defined in
							<xref target="RFC3986">RFC 3986</xref>. The default URI is an empty URI
						<!--Is empty URI defined by the spec?--></t>
					<t>Conversions: <list hangIndent="4" style="hanging">
							<t hangText="String">The characters of the String data are interpreted
								as a URI, if legal. Other Strings results in the default URI.</t>
						</list></t>
				</section>
				
		    <section anchor="BINARY" title="Binary">
					<t>Data of type Binary contains a sequence of zero or more octets. The default
						Binary is a sequence of zero octets.</t>
					<t>There are no defined conversions for Binary. </t>
				</section>
			</section>
			
		  <section anchor="COMPOSITE_TYPES" title="Composite Types">
				<!-- todo: clean up these descriptions and add examples -->
				<t>LLSD values can be composed of other LLSD values in two ways: Arrays or Maps. In
					either case, the values with the composite can be any heterogeneous mix of other
					LLSD types, both simple and composite.</t>

		    <section anchor="ARRAY" title="Array">
					<t>An Array is an ordered collection of zero or more values. The values are
						considered consecutive, with no gaps. The value undef (of type Undefined)
						may be used to indicate, within an Array, an intentionally left out value.</t>
					<t>Arrays are considered to have a definite length, including any leading or
						trailing undef values in the sequence. This length can be viewed by an
						application. Accessing beyond the end of an array acts as if the value undef
						were stored at the accessed location. Nonetheless, systems that transmit or
						store Arrays SHOULD NOT add or remove undef values at the end of an Array
						value, so as to make a best effort to retain the definite length as
						originally created.</t>
				</section>
				
		    <section anchor="MAP" title="Map">
					<t>A Map is an unordered collection of associations between keys and values.
						Within a given Map value, each key must be unique, each with one value. Keys
						are String values. The associated values can be of any LLSD type.</t>
					<t>Maps are considered to have a definite set of keys, including keys whose
						associated value is undef. The number of such keys, and set of keys can be
						accessed by an application. Accessing a value for a key that is not in a Map
						value's key set acts as if the value under were stored at that key.
						Nonetheless, systems that transmit or store Maps SHOULD NOT add or remove
						keys associated with undef to a Map value, so as to make a best effort to
						retain the key set as originally created.</t>
					<t>Note on key equality: Two keys are considered equal if they contain the same
						number and sequence of Unicode codepoints. Since keys are String values, and
						String values may be normalized on transport or storage, it follows that
						only String values that are already normalized as allowed by the String type
						are reliable as Map keys. Since the Maps are intended to be primarily used
						with keys set forth in protocol descriptions, this not a particular problem.
						However, if arbitrary user supplied data is to be used as key values in some
						application, then the possibility of normalization and perhaps key collision
						during transport must be considered.</t>
				</section>
			</section>
			
		  <section anchor="REAL_STRING_CONVERSION" title="Converting Between Real and String Types">
				<t>Real values are represented using the ABNF provided in <xref target="REAL_ABNF"/>
				</t>
				<!-- todo: clean up this description and add examples -->
			</section>
			
		  <section anchor="DATE_STRING_CONVERSION" title="Converting Between Date and String Types">
				<t>The textual representation of Date values is based on
				  <xref target="ISO8601">ISO 8601</xref>, and further specified in
				  <xref target="RFC3339">RFC 3339</xref>. When Date values are converted to or from
				  String values, the character sequence of the string must conform to the following
				  production based on the ABNF in <xref target="RFC3339">RFC 3339</xref>:
				  
				  <figure>
						<artwork>full-date "T" partial-time "Z"</artwork>
				  </figure>
				  
				  When converting from String values, if the sequence of characters does
					not exactly match this production, then the result is the default Date value.</t>
				<!-- todo: clean up this description and add examples -->
			</section>
		</section>
	  
	  <section title="The LLIDL Interface Description Language">
	    <section title="Interfaces and Resources">
	      <t>A LLIDL "Interface" is comprised conceptually of collection of zero or more related
	        resources and named type definitions. The LLIDL grammar defines an "Interface Definition"
	        as being zero or more comments, named type definitions or resource definitions.</t>
	      <t>A LLIDL "Resource" represents information or state maintained by a remote system, accessed
	        via HTTP(S). A "Resource Definition" is the grammatical construction used to represent a
	        resource. Resources are partitioned into "method access classes" based on the HTTP verbs
	        used to access them. Method access classes include: "GET", "GET/PUT", "GET/PUT/DELETE" and
	        "POST". Method access classes are notated in the LLIDL grammar using "Method Access
	        Delimeters": "&lt;&lt;" for GET, "&lt;&gt;" for GET/PUT, "&lt;x&gt;" for GET/PUT/DELETE and
	        POST is notated with the pair of strings "-&gt;" and "&lt;-".
	      </t>
	      <t>Resource definitions also include a message body defining the structure of requests and
	        responses. GET, GET/PUT and GET/PUT/DELETE resources define a single message
	        body following the method access delimiter. POST resources define two message bodies.
	        The first follows the "-&gt;" delimiter and represents the request.
	        The second follows the "&lt;-" delimiter and represents the response.</t>
	      
	      <t>A single simple type definition or "flat" map may be defined in conjunction with the
	        resource that describes the contents of arguments to be placed in the query string of the
	        request. A flat map is a map containing only simple types (i.e. - it does not contain
	        arrays or maps.)
	      </t>
	      
	      <t>A resource definition has the format:</t>
	      
	      <figure>
	        <artwork><![CDATA[
  '%%' <resource-name> [ '??' <query-body> ]
     <resource-delimeter> <message-body> [ <- <message-body> ]
	          ]]></artwork>
	      </figure>
	      
	      <t>The resource-name identifies the resource (not the URL at which it is located.) Resource-names
	        are strings that may contain alphabetic characters, numbers, the slash character ('/') and the
	        underbar character ('_').</t>
	    </section>
	    <section title="Simple Types">
	      <t>LLIDL uses the nine simple types from LLSD to define the type behavior of scalar elements in a resource.
	        These types are undefined, boolean, integer, real, string, UUID, URI, date and binary. They are
	        declared in LLIDL with different identifiers that are (respectively): undef, bool, int, real,
	        string, uuid, uri, date and binary. Note that the undefined, boolean and integer types are
	        declared using a more compact textual description of the type.</t>
	    </section>
	    <section title="Composite Types">
	      <t>Composite Types are resource elements that contain more than one value. LLIDL uses the two composite
	        types from LLSD: array and map.
	      </t>
	      <section title="Arrays">
	        <t>Arrays represent a sequence of simple types. Each element in an array is accessed by an
	          ordinal value. An array declaration begins with the open bracket character ('[') and ends with
	          the close bracket character (']'). Within the definition of an array, comma delimited type
	          declarations describing the type of each element are given.
	        </t>
	        <t>The format for an array declaration is:</t>
	        <figure>
	          <artwork><![CDATA[
  '[' <type> [ ',' <type> ] ... ']'
	            ]]></artwork>
	        </figure>
	        <t>The following example declares a five element array whose elements' types are three integers,
	          a string and a URI:</t>
	        <figure>
	          <artwork><![CDATA[
  [ int , int , int , string , uri ]
	            ]]></artwork>
	        </figure>
	        
	        <t>LLIDL arrays may also be of indeterminate length. The ellipsis trigraph ("...") appended to
	          the end of a sequence of types in an array declaration indicates the previously defined sequence
	          of types is repeated indefinitely.</t>
	        <t>The following examples describe (first) an arbitrary lengthed array comprising of strings and
	          (second) an arbitrary lengthed array comprising of three real values followed by a string:</t>
	        
	        <figure>
	          <artwork><![CDATA[
  [ string , ... ]
  
  [ real , real , real , string , ... ]
	            ]]></artwork>
	        </figure>
	        
	        <t>Note that the ellipsis trigraph indicates that the entire sequence is repeated, not only the
	          last element.</t>
	        
	        <t>It is acceptable for an array to contain composite types like arrays or maps. The following
	          example describes an array whose elements are an array of three real values and a string:</t>
	        
	        <figure>
	          <artwork><![CDATA[
  [ [ real , real , real ] , string, ... ]
	            ]]></artwork>
	        </figure>
	        
	      </section>
	      <section title="Maps">
	        <t>Maps are collections of simple types whose elements are accessed via alphanumeric strings.
	          Maps declarations begin with the open brace character ('{') and end with the close brace
	          character ('}'). Within the map declaration are a sequence of comma delimited map entries. Map
	          entries are comprised of a map entry name and a map entry type, separated by a colon character
	          (':'). Map entry names are alphanumeric strings intended to be indicative of their function in
	          the resource definition.</t>
	        <t>The format of a map definition is:</t>
	        <figure>
	          <artwork><![CDATA[
  '{' <map-entry-name> ':' <map-entry-type>
      [ ',' <map-entry-name> ':' <map-entry-type> ]  ... '}'
	            ]]></artwork>
	        </figure>
	        <t>The following example describes a map with three elements named: name, position and
	          current_balance. The name entry is declared as a string, the position entry is declared
	          as an array with a string and three real values, and the current_balance entry is
	          declared as an integer.</t>
	        <figure>
	          <artwork><![CDATA[
  {
    name : string,
    position : [ string , real , real , real ],
    current_balance : int
  }
	            ]]></artwork>
	        </figure>
	        
	        <t>As implied by the previous example, it is perfectly acceptable for a map to contain entries whose
	          types are maps and arrays.</t>
	        <t>It is also possible to define a map in which map entry names that are explicitly unknown
	          at the time a resource is defined. For example, a service may wish to produce or consume
	          a map whose keys come from user data such as stock ticker symbols, avatar names or the
	          names of regions in a virtual world. It is impractical to attempt to define the complete
	          set of possibilities in these cases, so LLIDL allows the resource developer to specify
	          that map names may come from data known only at the time the resource is accessed.</t>
	          
	        <t>The dollar character ('$') is used to specify a map whose entries' names are determined
	          after the resource is defined and deployed. A map with "deferred entry names" is one in
	          which this situation occurs. Such maps are defined with a single entry whose name is the
	          dollar character and a single type.</t>
	        <t>The following example shows a map with "deferred entry names" whose map entry types are
	          all URIs.</t>
	        <figure>
	          <artwork><![CDATA[
 { $ : uri }
	            ]]></artwork>
	        </figure>
	        <t>At most one deferred entry name specifier (i.e. - one dollar sign) is allowed in a map.
	        A map defined with a deferred entry name specifier may contain no other defined entries.</t>
	        <t>Deferred entry names do not signify that a later specification will complete the
	        definition of the resource, but that the map's entries' names cannot be determined before
	        the resource is accessed.</t>
	      </section>
	    </section>
	    <section title="Named Types">
	      <t>LLIDL defines a named type feature. This feature allows a resource developer to
	        define a single alphanumeric symbol that represents a complete type definition. The ampersand ('&amp;')
	        character is used in both the definition and reference of a named type. To define a named type,
	        the following format is used:
	      </t>
	      
	      <figure>
	        <artwork><![CDATA[
'&' <named-type-symbol> '=' <named-type-value>
	          ]]></artwork>
	      </figure>
	      
	      <t>The named type symbol must be a valid alphanumeric symbol consisting of upper and lower case
	        letters, numbers, the slash character ('/') or the underbar ('_'). The named type value must be
	        a valid type definition.</t>
	      
	      <t>The following examples are all valid named type definitions:</t>
	      
	      <figure>
	        <artwork><![CDATA[
  &example  = string
  
  &info     = { name : string, id : uuid }
  
  &position = [ real, real, real ]
	          ]]></artwork>
	      </figure>
	      
	      <t>Named types are referenced using only the ampersand and a symbol. The following example
	        describes two resources whose response bodies are defined using a named type:
	      </t>
	      
	      <figure>
	        <artwork><![CDATA[
  &error = { errno : int, desc : string, more : uri }
  
  %% session/search -> string <- &error
  
  %% session/continue  -> uuid   <- &error
	          ]]></artwork>
	      </figure>
	    </section>
	    
	    <section title="Variant Type Definitions">
	      <t>It may be advantageous for a resource to accept more than one form. In this case, a variant
	        type definition may be used. Variant type definitions are defined using the named type
	        feature to define a named type using the same named type symbol for multiple named type definitions.</t>
	      <t>For example, the following resource defines a response with two forms. The first describes a success condition
	      while the second an error.</t>
	      <figure>
	        <artwork><![CDATA[
  &request = {
       name   : string,
       secret : binary
  }
  
  &response = {
    success    : true,
    session_id : uuid
  }
  
  &response = {
    success    : false,
    error      : int,
    next       : uri
  }
  
  %% session/establish -> &request <- &response
	          ]]></artwork>
	      </figure>
	      
	      <t>In this example, the first named type (whose named type symbol is 'request') is a simple named type.
	        It is later used in a resource definition to represent the contents of a request
	        to the resource. The second and third named types define a variant. That is, the named type symbol
	        is used more than once. The 'response' variant defined in this
	        example indicates that the response from the resource access will be one of the two 'response'
	        forms.</t>
	      
	      <t>A "selector" may be used to help determine which variant should be used. A selector is a literal
	        value included in a map entry that appears in each variant. In the example above, the map entry
	        named 'success' has two literal values in the two variants in which it is defined. It is possible
	        to have multiple selectors in a map variant, and the same literal value may be reused.</t>
	     
	    </section>
	  </section>
	  
		<section anchor="SERIALIZATION" title="Serialization">
			<t>When used as part of a protocol, LLSD is serialized into a common form. Three
				serialization schemes are currently defined: XML, JSON and Binary. </t>

		  <section anchor="XML_SERIALIZATION" title="XML Serialization">
				<t>XML serialization of LLSD data is in common use in protocols implementing virtual
					worlds. When used to communicate protocol data with a transport that requires
					the use of a Type, the type 'application/llsd+xml' is used.</t>
				<t>When serializing an instance of LLSD structured data into an XML document, the
					DTD given in <xref target="XML_SERIALIZATION_DTD"/> is used. This DTD defines
					elements for each of the defined LLSD types. Immediately subordinate to the root
					LLSD element, XML documents representing LLSD serialized data include either a
					single instance of an simple type (Undefined, Boolean, Integer, Real, UUID,
					String, Date, URI or Binary) or a single composite type (Array or Map). 
				</t>

        <t>When encoding binary data using <xref target="RFC4648">RFC 4648</xref>, characters
        outside the base alphabet are explicitly allowable and should be ignored.</t>
		    
		    <section anchor="SIMPLE_XML_SERIALIZATION" title="Serializing Simple Types"
						><t>Most simple
						types are serialized by placing the string representation of the data
						between beginning and ending tags associated with the value's type. This is
						true for undefined, boolean, integer, real, UUID, string, date and URI typed
						values. Values of type binary are serialized by placing the BASE64 encoding
						(defined in <xref target="RFC4648">RFC 4648</xref> ) of the binary data
						within beginning and ending 'binary' tags. It is expected that future
						versions of this specification may allow encodings other than BASE64, so the
						mandatory attribute 'encoding' is used to identify the method used to encode
						the binary data. </t>
					<figure>
						<preamble>The following example shows an XML document representing the
							serialization of the integer -559038737.</preamble>
						<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<llsd>
  <integer>-559038737</integer>
</llsd>
]]></artwork>
					</figure>
					<figure>
						<preamble>While this example shows the serialization of a binary array of
							octets containing the values 222, 173, 190 and 239.</preamble>
						<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<llsd>
  <binary encoding="base64">3q2+7w==</binary>
</llsd>
]]></artwork>
					</figure>
				</section>
				<section anchor="COMPOSITE_XML_SERIALIZATION" title="Serializing Composite Types">
					<t>Composite types in the XML serialization scheme are represented with 'array'
						and 'map' elements. Both of these elements may contain elements enclosing
						simple types or other composite types. Array elements, which represent a
						collection of values indexed by position, contain a simple list of typed
						values. Map elements represent a collection of values indexed by a string
						identifier. They contain a list of key-value pairs where the 'key' element
						describes the indexing identifier while the value (which follows the 'key'
						element) is its XML representation. </t>
					<t> Note that elements of an array may be of differing types. Also note that
						composite types may contain other composite types; it is not an error for an
						array or map to contain another array, map or simple type. </t>
				</section>
				<section anchor="XML_EXAMPLE" title="Example of XML LLSD Serialization">
					<figure>
						<preamble> This example shows the XML serialization of an array which
							contains an integer, a UUID and a map. </preamble>
						<artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<llsd>
 <array>
  <integer>42</integer>
  <uuid>6bad258e-06f0-4a87-a659-493117c9c162</uuid>
  <map>
   <key>hot</key>
   <string>cold</string>
   <key>higgs_boson_rest_mass</key>
   <undef/>
   <key>info_page</key>
   <uri>https://example.org/r/6bad258e-06f0-4a87-a659-493117c9c162</uri>
   <key>status_report_due_by</key>
   <date>2008-10-13T19:00.00Z</date>
  </map>
 </array>
</llsd>
]]></artwork>
					</figure>
				</section>
			</section>
			<section anchor="JSON_SERIALIZATION" title="JSON Serialization">
				<t>LLSD may also be serialized using the <xref target="ECMA262r5">JSON</xref> subset
					of the JavaScript programming language. When serializing LLSD data using JSON,
					the 'application/llsd+json' media type is used. The grammar of LLSD objects serialized
					using the JSON serialization MUST conform to the JSONText production.
				</t>
				<t>The following table lists type conversions between LLSD and JSON: <list
						hangIndent="4" style="hanging">
						<t hangText="Undefined">LLSD 'Undefined' values are represented by the JSON
							non-terminal 'JSONNullLiteral'.</t>
						<t hangText="Boolean">LLSD 'Boolean' values are represented by the JSON
							non-terminal 'JSONBooleanLiteral'.</t>
						<t hangText="Integer">LLSD 'Integer' values are represented by the JSON
							non-terminal 'JSONNumberLiteral'.</t>
						<t hangText="Real">LLSD 'Real' values are represented by the JSON
							non-terminal 'JSONNumberLiteral'.</t>
						<t hangText="String">LLSD 'String' values are represented by the JSON
							'JSONString' non-terminal. Note that this specification inherits JSON's
							behavior of requiring control characters, reverse solidus and quotation
							mark characters to be escaped.</t>
						<t hangText="UUID">LLSD 'UUID' values are represented by a JSON string, and
							are rendered in the common 8-4-4-4-12 format defined by the 'UUID'
							non-terminal in <xref target="RFC4122">RFC 4122</xref>.</t>
						<t hangText="Date">LLSD 'Date' values are represented by the JSON 'string'
							non-terminal, the contents of which is a valid ISO 8601 value with
							years, months, days, hours, seconds and time zone indicator.</t>
						<t hangText="URI">LLSD 'URI' values are represented by the JSON 'string'
							non-terminal, the contents of which is a valid URI as defined by <xref
								target="RFC3986">RFC 3986</xref>.</t>
						<t hangText="Binary">LLSD 'Binary' values are represented as a JSON 'JSONArray'.
						  That is, they follow the <xref target="ECMA262r5">ECMA-262</xref> 'JSONArray'
							non-terminal whose members are integer numbers representing each octet
							of the binary array.</t>
						<t hangText="Array">LLSD 'Array' values are represented by the JSON 'JSONArray'
							non-terminal.</t>
						<t hangText="Map">LLSD 'Map' values are represented by the JSON 'JSONObject'
							non-terminal. Each key-value pair of the map is represented by the JSON
							'JSONMember' non-terminal where the LLSD map key is the 'JSONString' prior to
							the name separator terminal (':') and the LLSD map value is the 'JSONValue'
							after the name separator.</t>
					</list></t>
				<t>LLSD defines additional types over those defined by JSON. The LLSD types UUID,
					Date and URI are serialized as JSON strings whose contents are generated using
					the &lt;Type&gt; to String conversion defined in Abstract Type System section
					above.</t>
				<section anchor="SIMPLE_JSON_EXAMPLE" title="Examples of JSON LLSD Serialization">
					<figure>
						<preamble>Example 1. The following example shows the JSON encoding of the
							integer 42.</preamble>
						<artwork><![CDATA[
42
]]></artwork>
					</figure>
					<figure>
						<preamble>Example 2. The following example shows the JSON encoding of the
							example given in the <xref target="COMPOSITE_XML_SERIALIZATION">section
								above on XML serialization</xref>. </preamble>
						<artwork><![CDATA[
[
 42,
 "6bad258e-06f0-4a87-a659-493117c9c162",
 {
  "hot": "cold",
  "higgs_boson_rest_mass": null,
  "info_page": 
    "https://example.org/r/6bad258e-06f0-4a87-a659-493117c9c162",
  "status_report_due_by": "2008-10-13T19:00.00Z"
 }
]
]]></artwork>
					</figure>
				</section>
			</section>
			<section anchor="BINARY_SERIALIZATION" title="Binary Serialization">
				<t>The LLSD Binary Serialization is an encoding syntax appropriate for situations
					where high message entropy is required or limiting processing power for parsing
					messages is available. </t>
				<t>Encoding LLSD structured data using the binary serialization scheme involves
					generating tag, (optional) size values, and serialization of simple values.
					Composite types are serialized by iterating across all members of the
					collection, serializing each simple or composite member in turn, and adding
					a closing tag. For each
					element in an LLSD structured data object, the following process is used to
					generate a binary output stream of serialized data: <list style="symbols">
						<t>A one octet type tag is emitted to the output stream. See the table below
							for tag octets.</t>
						<t>If the size of the element being serialized is variable (as it will be
							for strings, URIs, arrays and maps), the size or length of the element
							is output to the stream as a network-order 32 bit value. Elements of
							types with fixed lengths such as undefined values, booleans, integers,
							reals, UUIDs and dates will not include size information in the output
							stream.</t>
						<t>Finally, the binary representation of the element is appended to the
							output stream.</t>
					</list></t>
				<t>
					<list hangIndent="4" style="hanging">
						<t hangText="Undefined">Undefined values are serialized with a single
							exclamation point character ('!'). Undefined values append neither size
							information or data to the output stream.</t>
						<t hangText="Boolean">True values are serialized with a single '1'
							character. False values are serialized with a single '0' character.
							Booleans append neither size information or data to the output stream.</t>
						<t hangText="Integer">Integer values are serialized by emitting the 'i'
							character to the output stream followed by the four octets representing
							the integer's 32 bits in network order.</t>
						<t hangText="Real">Real values are serialized by emitting the 'r' character
							to the output stream followed by the eight octets representing the real
							value's 64 bits in network order.</t>
						<t hangText="String">String values are serialized by emitting the 's'
							character to the output stream followed by the string's length in octets
							represented as a network-order 32 bit integer, followed by the string's
							UTF-8 encoding.</t>
						<t hangText="UUID">UUID values are serialized by emitting the 'u' character
							to the output stream followed by the sixteen octets representing the
							UUID's 128 bits, with the most significant byte coming first.</t>
						<t hangText="Date">Date values are serialized by emitting the 'd' character
							to the output stream followed by the number of seconds since the start
							of the epoch, represented as a 64-bit real value.</t>
						<t hangText="URI">URI values are serialized by emitting the 'l' character to
							the output stream followed by the URI's length in octets represented as
							a network-order 32 bit integer, followed by the binary representation of
							the URI.</t>
						<t hangText="Binary">Binary values are serialized by emitting the 'b'
							character to the output stream followed by the binary array's length in
							octets represented as a network-order 32 bit integer, followed by the
							octets of the binary array.</t>
						<t hangText="Array">Arrays are serialized by emitting the left square
							bracket ('[') character, followed by the count of objects in the array
							represented as a network-order 32 bit integer, followed by each array
							element in order. Note that compliant implementations MUST preserve the
							order of array elements. Following the elements in the array, a single
						  octet closing tag is appended to the enclosing. The closing tag for
						  arrays is a single right square bracket (']').</t>
						<t hangText="Map">Maps are serialized by emitting the left curly brace ('{')
							character, followed by the count of objects in the map represented as a
							network-order 32 bit integer, followed by each key-value element. Map
							keys are represented as strings except that they use the character 'k'
							instead of the character 's' as a tag. Note that preserving the order of
							maps is not REQUIRED. Following the elements in the map, a single
							octet closing tag is appended to the enclosing. The closing tag for
							arrays is a single right curly brace ('}').</t>
					</list>
				</t>
			  <section anchor="BINARY_EXAMPLE" title="Example of BINARY LLSD Serialization">
					<figure>
						<preamble>The LLSD object given as an example in the <xref
								target="COMPOSITE_XML_SERIALIZATION">section above on XML
								serialization</xref> would look as follows would it have been
							serialized using the binary scheme. The following example encodes octets
							as hexadecimal values. </preamble>
						<artwork><![CDATA[
 Offset   Hex Data                  Char Data
-------- ------------------------- -----------
00000000  5B                       '['
00000001  00 00 00 03              '....'
00000005  69                       'i'
00000006  00 00 00 2A              '...*'
0000000A  75                       'u'
0000000B  6B AD 25 8E 06 F0 4A 87  'k.%...J.'
00000013  A6 59 49 31 17 C9 C1 62  '.YI1...b'
0000001B  7B                       '{'
0000001C  00 00 00 04              '....'
00000020  6B                       'k'
00000021  00 00 00 03              '....'
00000025  68 6F 74                 'hot'
00000028  73                       's'
00000029  00 00 00 04              '....'
0000002D  63 6F 6C 64              'cold'
00000031  6B                       'k'
00000032  00 00 00 13              '....'
00000036  68 69 67 67 73 5F 62 6F  'higgs_bo'
0000003E  73 6F 6E 5F 72 65 73 74  'son_rest'
00000046  5f 6d 61 73 73           '_mass'
0000004B  21                       '!'
0000004C  68                       'k'
0000004D  00 00 00 09              '....'
00000051  69 6E 66 6F 5F 70 61 67  'info_pag'
00000059  65                       'e'
0000005A  6C                       'l'
0000005B  00 00 00 3A              '...:'
0000005F  68 74 74 70 73 3A 2f 2F  'https://'
00000067  65 78 61 6D 70 6C 65 2E  'example.'
0000006F  6F 72 67 2F 72 2F 36 62  'org/r/6b'
00000077  61 64 32 35 38 65 2D 30  'ad258e-0'
0000007F  36 66 30 2D 34 61 38 37  '6f0-4a87'
00000087  2D 61 36 35 39 2D 34 39  '-a659-49'
0000008F  33 31 31 37 63 39 63 31  '3117c9c1'
00000097  36 32                    '62'
00000099  68                       'k'
0000009A  00 00 00 14              '....'
0000009E  73 74 61 74 75 73 5F 72  'status_r'
000000A7  65 70 6F 72 74 5F 64 75  'eport_du'
000000AF  65 5F 62 79              'e_by'
000000B3  00 00 00 08              '....'
000000B7  64                       'd'
000000B8  41 D2 3C E6 AC 00 00 00  'A.<.....'
]]></artwork>
					</figure>
				</section>
			</section>
		</section>

		<section anchor="IANA" title="IANA Considerations">
			<t>In accordance with <xref target="RFC5226"/>, this
				document registers the following mime types:</t>
			<t>
				<list hangIndent="4" style="empty">
				  <t>application/llidl</t>
					<t>application/llsd+xml</t>
					<t>application/llsd+json</t>
					<t>application/llsd+binary</t>
				</list>
			</t>
			<t>See the <xref target="MIME_Type_Reg">MIME Type Registrations section</xref> below for
				detailed information on MIME Type registrations.</t>
		</section>
	  <section anchor="MIME_Type_Reg" title="MIME Type Registrations">
	    <t>This section provides media-type registration applications (as per <xref
	      target="RFC4288">RFC 4288</xref>.)</t>
	    <section title="MIME Type Registration for application/llidl">
	      <t>
	        <list hangIndent="4" style="hanging">
	          <t hangText="To: ietf-types@iana.org"/>
	          <t hangText="Subject: Registration of media type application/llidl"/>
	          <t hangText="Type name: application"/>
	          <t hangText="Subtype name: llidl"/>
	          <t hangText="Required Parameters: none"/>
	          <t hangText="Optional Parameters: none"/>
	          <t hangText="Encoding Considerations:">LLIDL may be used with any
	            character set that encodes character points identical to ASCII for the
	            first 127 characters. Compliant systems SHOULD use UTF-8 and if no character
	            set is indicated, UTF-8 MUST be assumed.</t>
	          <t hangText="Security Considerations:">LLIDL interface descriptions contain
	            "plain" text and generally poses no immediate risk to system security of
	            either the sender or the receiver. Still, it is possible for a malicious
	            adversary to include arbitrary binary data in an attempt to exploit
	            specific vulnerabilities (if they exist.) It is the obligation of the
	            receiver to ensure such vulnerabilities are mitigated in a timely fashion
	            <vspace blankLines="1"/>In the unlikely event that sensitive information is
	            to be expressed as an LLIDL interface, it is
	            the responsibility of the transport, network or link layers to ensure
	            the confidentiality, message integrity and origin integrity of the
	            message.</t>
	          <t hangText="Interoperability Considerations:">While it is possible for
	            compliant implementations to specify the use of character sets other
	            than UTF-8, such systems MUST accept UTF-8 input and SHOULD generate
	            UTF-8 output. </t>
	          <t hangText="Published specification:">The grammar of LLIDL is
	            defined in the internet draft <xref target="I-D.hamrick-llsd"
	              >draft-ietf-vwrap-llsd-00</xref>. </t>
	          <t hangText="Applications that use this media type:">Virtual world,
	            tele-presence and content management systems related to "virtual
	            reality" systems.</t>
	          <t hangText="Additional Information:">
	            <list hangIndent="4" style="hanging">
	              <t hangText="Magic Number(s): none"/>
	              <t hangText="File Extension: llidl"/>
	              <t hangText="Macintosh File Type Code(s): TEXT"/>
	            </list>
	          </t>
	          <t hangText="Person &amp; email address to contact for further information:"
	            >Meadhbh Hamrick &lt;infinity@lindenlab.com&gt;</t>
	          <t hangText="Intended Usage: COMMON"/>
	          <t hangText="Author: IESG"/>
	          <t hangText="Change Controller: IESG"/>
	        </list>
	      </t>
	    </section>
			<section title="MIME Type Registration for application/llsd+xml">
				<t>
					<list hangIndent="4" style="hanging">
						<t hangText="To: ietf-types@iana.org"/>
						<t hangText="Subject: Registration of media type application/llsd+xml"/>
						<t hangText="Type name: application"/>
						<t hangText="Subtype name: llsd+xml"/>
						<t hangText="Required Parameters: none"/>
						<t hangText="Optional Parameters: none"/>
						<t hangText="Encoding Considerations:">The Extensible Markup Language (XML)
							specification allows for the use of multiple character sets. The
							character set used to encode the body of the message is defined as part
							of the XML header. If no character set is indicated in the XML header,
							compliant systems MUST assume UTF-8. </t>
						<t hangText="Security Considerations:">LLSD XML serialized data contains
							"plain" text and generally poses no immediate risk to system security of
							either the sender or the receiver. Still, it is possible for a malicious
							adversary to include arbitrary binary data in an attempt to exploit
							specific vulnerabilities (if they exist.) It is the obligation of the
							receiver of LLSD XML serialized messages to ensure such vulnerabilities
							are mitigated in a timely fashion.<vspace blankLines="1"/> If sensitive
							information is to be encoded into a LLSD XML serialized message, it is
							the responsibility of the transport, network or link layers to ensure
							the confidentiality, message integrity and origin integrity of the
							message. </t>
						<t hangText="Interoperability Considerations:">While it is possible for
							compliant implementations to specify the use of character sets other
							than UTF-8, such systems MUST accept UTF-8 input and SHOULD generate
							UTF-8 output. </t>
						<t hangText="Published specification:">The LLSD XML Serialization is
							defined in the internet draft <xref target="I-D.hamrick-llsd"
								>draft-ietf-vwrap-llsd-00</xref>. </t>
						<t hangText="Applications that use this media type:">Virtual world,
							tele-presence and content management systems related to "virtual
							reality" systems. </t>
						<t hangText="Additional Information:">
							<list hangIndent="4" style="hanging">
								<t hangText="Magic Number(s): none"/>
								<t hangText="File Extension: lsdx"/>
								<t hangText="Macintosh File Type Code(s): TEXT"/>
							</list>
						</t>
						<t hangText="Person &amp; email address to contact for further information:"
							>Meadhbh Hamrick &lt;infinity@lindenlab.com&gt;</t>
						<t hangText="Intended Usage: COMMON"/>
						<t hangText="Author: IESG"/>
						<t hangText="Change Controller: IESG"/>
					</list>
				</t>
			</section>
			<section title="MIME Type Registration for application/llsd+json">
				<t>
					<list hangIndent="4" style="hanging">
						<t hangText="To: ietf-types@iana.org"/>
						<t hangText="Subject: Registration of media type application/llsd+json"/>
						<t hangText="Type name: application"/>
						<t hangText="Subtype name: llsd+json"/>
						<t hangText="Required Parameters: none"/>
						<t hangText="Optional Parameters: none"/>
						<t hangText="Encoding Considerations:">
							This specification requires that LLSD objects encoded using the JSON serialization
							scheme encode their data using Unicode. It is assumed that the transport will
						  carry meta-data describing the character encoding used (UTF-8, UTF-16, UTF-32, etc.)
						  The UTF-8 character encoding is assumed if a character encoding is not specified.
						</t>
						<t hangText="Security Considerations:">The contents of
							messages identified with this media type are expected to be passed into
							ECMAScript's 'parse()' function. <xref target="RFC4627">RFC 4627</xref> provides a regular expression
							to ensure that only "safe" characters (i.e. - characters used to
							describe JSON tokens) are included outside string literal definitions.
							Users of the application/llsd+json media type are strongly encouraged to
							use this (or similar) tests to ensure message safety.<vspace
								blankLines="1"/> If sensitive information is to be encoded into a
							LLSD JSON serialized message, it is the responsibility of the transport,
							network or link layers to ensure the confidentiality, message integrity
							and origin integrity of the message. </t>
						<t hangText="Interoperability Considerations:">none</t>
						<t hangText="Published specification: This specification."/>
						<t hangText="Applications that use this media type:">Virtual world,
							tele-presence and content management systems related to "virtual
							reality" systems. </t>
						<t hangText="Additional Information:">
							<list hangIndent="4" style="hanging">
								<t hangText="Magic Number(s): none"/>
								<t hangText="File Extension: lsdj"/>
								<t hangText="Macintosh File Type Code(s): TEXT"/>
							</list>
						</t>
						<t hangText="Person &amp; email address to contact for further information:"
							>Meadhbh Hamrick &lt;infinity@lindenlab.com&gt;</t>
						<t hangText="Intended Usage: COMMON"/>
						<t hangText="Author: IESG"/>
						<t hangText="Change Controller: IESG"/>
					</list>
				</t>
			</section>
			<section title="MIME Type Registration for application/llsd+binary">
				<t>
					<list hangIndent="4" style="hanging">
						<t hangText="To: ietf-types@iana.org"/>
						<t
							hangText="Subject: Registration of media type application/llsd+binary"/>
						<t hangText="Type name: application"/>
						<t hangText="Subtype name: llsd+binary"/>
						<t hangText="Required Parameters: none"/>
						<t hangText="Optional Parameters: none"/>
						<t
							hangText="Encoding Considerations: LLSD Binary Serialization REQUIRES the use of binary content-transfer-encoding"
							>Section 5 of <xref target="RFC2045">RFC 2045</xref> describes the
							binary Content-Transfer-Encoding header field. This specification
							REQUIRES the use of this header to alert intermediary systems that
							information being included in the message should be interpreted as
							binary data with no end-of-line semantics which could be considerably
							longer than allowed in an RFC 821 transport. </t>
						<t hangText="Security Considerations:">This serialization format defines the
							use of tagged binary fields with embedded length information. In the
							past, similar binary encoding systems have fallen prey to exploits when
							parsing implementations fail to check for nonsensical lengths.
							Implementers are therefore strongly encouraged to consider all failure
							modes of such a system.<vspace blankLines="1"/> If sensitive information
							is to be encoded into a LLSD JSON serialized message, it is the
							responsibility of the transport, network or link layers to ensure the
							confidentiality, message integrity and origin integrity of the message. </t>
						<t hangText="Interoperability Considerations: none"/>
						<t hangText="Published specification:">The LLSD binary serialization is
							defined in the internet draft <xref target="I-D.hamrick-llsd"
								>draft-hamrick-llsd-01</xref>. </t>
						<t hangText="Applications that use this media type:">Virtual world,
							tele-presence and content management systems related to "virtual
							reality" systems. </t>
						<t hangText="Additional Information:">
							<list hangIndent="4" style="hanging">
								<t hangText="Magic Number(s): none"/>
								<t hangText="File Extension: lsdb"/>
								<t hangText="Macintosh File Type Code(s): LSDB"/>
							</list>
						</t>
						<t hangText="Person &amp; email address to contact for further information:"
							>Meadhbh Hamrick &lt;infinity@lindenlab.com&gt;</t>
						<t hangText="Intended Usage: COMMON"/>
						<t hangText="Author: IESG"/>
						<t hangText="Change Controller: IESG"/>
					</list>
				</t>
			</section>
		</section>
		<section anchor="Security" title="Security Considerations">
			<t>Security considerations for this specification are, fortunately, either simple or
				beyond the scope of this document. <xref target="RFC3552">RFC 3552</xref> describes
				several aspects to use when evaluating the security of a specification or
				implementation. We believe most common security concerns users of this specification
				will encounter are more appropriately considered as transport, network or link layer
				issues. Or, as higher level "application security" issues. </t>
			<t>This document specifies the content, media type identifiers and content encoding
				requirements for LLSD. It does not specify mechanisms to transmit LLSD messages
				between network peers. We believe that many communication security considerations
				such as confidentiality, data integrity and peer entity authentication are more
				appropriately the domain of message, transport, network or link layer protocols.
				Users of this protocol should seriously consider the use Secure MIME, Transport
				Layer Security (TLS), IPSec or related technologies. </t>
		</section>
	</middle>
	<!--  *****BACK MATTER ***** -->
	<back>
		<!-- References split into informative and normative -->
		<!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->
		<references title="Normative References">
		  <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml"?-->
			&RFC2045;
		  <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml"?-->
		  &RFC2616;
		  <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2817.xml"?-->
		  &RFC2817;
		  <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4288.xml"?-->
			&RFC4288;
			<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
			&RFC2119;
			<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml"?-->
			&RFC3339;
			<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml"?-->
			&RFC3986;
			<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4122.xml"?-->
			&RFC4122;
			<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml"?-->
			&RFC4648;
			<!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml"?-->
			&RFC5234;
			<reference anchor="XML2006">
				<front>
					<title>Extensible Markup Language (XML) 1.0 (Fourth Edition)</title>
					<author initials="T." surname="Bray">
						<organization>Textuality and Netscape</organization>
					</author>
					<author initials="J." surname="Paoli">
						<organization>Microsoft</organization>
					</author>
					<author initials="C. M." surname="Sperberg-McQueen">
						<organization>W3C</organization>
					</author>
					<author initials="E." surname="Maler">
						<organization>Sun Microsystems, Inc.</organization>
					</author>
					<author initials="F." surname="Yergeau">
						<organization/>
					</author>
					<date year="2006"/>
				</front>
			</reference>
			<reference anchor="TR15" target="http://unicode.org/reports/tr15/">
				<front>
					<title>Unicode Standard Annex #15 : UNICODE NORMALIZATION FORMS</title>
					<author initials="M." surname="Davis">
						<organization/>
					</author>
					<author initials="M." surname="Durst">
						<organization/>
					</author>
					<date year="2008"/>
				</front>
			</reference>
		  <reference anchor="ECMA262r5" target="http://www.ecma-international.org/publications/standards/Ecma-262.htm">
		    <front>
		      <title>Standard ECMA-262, 5th Edition : ECMAScript Language Specification</title>
		      <author>
		        <organization>ECMA International</organization>
		      </author>
		      <date year="2009" month="December"/>
		    </front>
		  </reference>
		  
		</references>
		<references title="Informative References"
			><!-- Here we use entities that we defined at the beginning. --> &RFC3552;
			&RFC5226;
			<reference anchor="I-D.hamrick-llsd">
				<front>
					<title>VWRAP : Abstract Type System for the Transmission of Dynamic Structured Data</title>
					<author initials="A." surname="Brashears">
						<organization>Linden Research, Inc.</organization>
					</author>
					<author initials="M." surname="Hamrick">
						<organization>Linden Research, Inc.</organization>
					</author>
					<author initials="M." surname="Lentczner">
						<organization>Linden Research, Inc.</organization>
					</author>
					<date year="2009"/>
				</front>
			</reference>
		  <reference anchor="Fielding2000">
		    <front>
		      <title>Architectural Styles and the Design of Network-based Software Architectures</title>
		      <author fullname="Roy Thomas Fielding">
		        <organization>University of California, Irvine</organization>
		      </author>
		      <date year="2000"/>
		    </front>
		  </reference>
		  
		  <reference anchor="ISO8601">
				<front>
					<title>ISO 8601 - Date and Time Formats</title>
					<author>
						<organization/>
					</author>
					<date/>
				</front>
			</reference>
		  <reference anchor="Kaye2003">
		    <front>
		      <title>Loosely Coupled : The Missing Pieces of Web Services</title>
		      <author fullname="Doug Kaye">
		        <organization>The Conversations Network</organization>
		      </author>
		      <date year="2003"/>
		    </front>
		  </reference>
		  <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml"?-->
		  &RFC4627;
		</references>
		<section anchor="REAL_ABNF" title="ABNF of Real Values">
			<figure>
				<preamble>The following is the Augmented Backus-Naur Form (ABNF) of valid Real
					values for the purposes of converting strings into real values. ABNF is
					described in <xref target="RFC5234">RFC 5234</xref>.
					<!--Doesn't IEEE 754 describe this?--></preamble>
				<artwork>real              =  zero
real              =/ negative-infinity
real              =/ negative-zero
real              =/ positive-zero
real              =/ positive-infinity
real              =/ signaling-nan
real              =/ quiet-nan
real              =/ realnumber

negative-infinity =  %x2D.49.6E.66.69,6E.69.74.79   ; "-Infinity"
negative-zero     =  %x2D.5A.65.72.6F               ; "-Zero"
zero              =  %x30.2E.30                     ; "0.0"
positive-zero     =  %x2B.5A.65.72.6F               ; "+Zero"
positive-infinity =  %x2B.49.6E.66.69,6E.69.74.79   ; "+Infinity"
signaling-nan	    =  %4E.61.4E.53                   ; "NaNS"
quiet-nan         =  %4E.61.4E.51                   ; "NaNQ"

realnumber        =  mantissa exponent

mantissa          =  ( positive-number [ "." *decimal-digit ])
mantissa          =/ ( "0." *("0") positive-number )
  				
exponent          =  "E" ( "0" / ( [ "-" ] positive-number ) )
  				
positive-number	  =  non-zero-digit *decimal-digit
  				
decimal-digit	    =  %x30-39
non-zero-digit    =  %x31-39</artwork>
			</figure>
		</section>
		<section anchor="XML_SERIALIZATION_DTD" title="XML Serialization DTD">
			<figure>
				<preamble>The following Document Type Definition (DTD) describes the format of LLSD
					XML Serialization. DTDs are described in the <xref target="XML2006">Extensible
						Markup Language (XML) 1.0 (Fourth Edition)</xref> specification. </preamble>
				<artwork><![CDATA[
  <!ELEMENT llsd 
    (undef|boolean|integer|real|string|uuid|date|uri|binary|array|map)*>
  <!ELEMENT undef EMPTY>
  <!ELEMENT boolean (#PCDATA)>
  <!ELEMENT integer (#PCDATA)>
  <!ELEMENT real (#PCDATA)>
  <!ELEMENT string (#PCDATA)>
  <!ELEMENT uuid (#PCDATA)>
  <!ELEMENT date (#PCDATA)>
  <!ELEMENT uri (#PCDATA)>
  <!ELEMENT binary (#PCDATA)>
  <!ELEMENT array
    (undef|boolean|integer|real|string|uuid|date|uri|binary|array|map)*>
  <!ELEMENT map
    (key,(undef|boolean|integer|real|string|uuid|date|uri|binary|array
    |map))*>
  <!ELEMENT key (#PCDATA)>

  <!ATTLIST string xml:space (default|preserve) 'preserve'>
  <!ATTLIST binary encoding CDATA "base64">

]]></artwork>
			</figure>
		</section>
		<section anchor="abnf-llidl" title="ABNF of LLIDL">
			<figure>
				<preamble>The following is the Augmented Backus-Naur Form (ABNF) of the LLIDL
					Interface Description Language. ABNF is described in <xref
						target="RFC5234">RFC 5234</xref>. </preamble>
				<artwork><![CDATA[
llidl           = *( s  / resource-def / variant-def )

resource-def    = res-name s res-transaction
res-name        = "%%" s name
res-transaction = res-get / res-getput / res-getputdel / res-post
res-get         = "<<" s value
res-getput      = "<>" s value
res-getputdel   = "<x>" s value
res-post        = res-request s res-response
res-request     = "->" s value
res-response    = "<-" s value

variant-def     = "&" name s "=" s value


value           =  type / array / map / selector / variant

type            =  %x75.6E.64.65.66     ; "undef"
type            =/ %x73.74.72.69.6E.67  ; "string"
type            =/ %x62.6F.6F.6C        ; "bool"
type            =/ %x69.6E.74           ; "int"
type            =/ %x72.65.61.6C        ; "real"
type            =/ %x64.61.74.65        ; "date"
type            =/ %x75.72.69           ; "uri"
type            =/ %x75.75.69.64        ; "uuid"
type            =/ %x62.69.6E.61.72.79  ; "binary"

array           =  "[" s value-list s "]"
array           =/ "[" s value-list s "..." s "]"

map             =  "{" s member-list s "}"
map             =/ "{" s "$" s ":" s value s "}"

value-list      = value [ s "," [ s value-list ] ]

member-list     = member [ s "," [ s member-list ] ]
member          = name s ":" s value

selector        =  quote name quote
selector        =/ %x74.72.75.65        ; "true"
selector        =/ %x66.61.6C.73.65     ; "false"
selector        =/ 1*digit

variant         = "&" name


s               = *( tab / newline / sp / comment )
comment         = ";" *char newline
newline         = lf / cr / (cr lf)

tab             = %x0009
lf              = %x000A
cr              = %x000D
sp              = %x0020
quote           = %x0022
digit           = %x0030-0039
char            = %x09 / %x20-D7FF / %xE000-FFFD / %x10000-10FFFF

name            = name_start *name_continue
name_start      = id_start    / "_"
name_continue   = id_continue / "_" / "/"
id_start        = %x0041-005A / %x0061-007A ; ALPHA
id_continue     = id_start / %x0030-0039    ; DIGIT
]]></artwork>
			</figure>
		</section>
	  <section title="Glossary">
	    <t>
	    <list hangIndent="4" style="hanging">
	      <t hangText="Access">See Resource Access.</t>
	      <t hangText="Array">An array is a collection in which elements are accessed by numeric index.
	        By default arrays are fixed length, but a trailing ellipsis in an array definition denotes an
	        array of indeterminate length.</t>
	      <t hangText="Array Definition">An array definition is a feature of the LLIDL grammar used to denote
	        arrays of fixed or indeterminate size. An array definition is a comma delimited sequence of type
	        definitions describing the type of each array element.</t>
	      <t hangText="Composite Type">A composite type in LLIDL and LLSD is an abstract representation of
	      an array or a map.</t>
	      <t hangText="Deferred Entry Name">A map defined with a single "Deferred Entry Name Specifier"
	      (i.e. - the dollar sign), signifies that the map entry's names will be determined at the time
	      the resource is accessed, not when the resource is defined.</t>
	      <t hangText="Defined Type">A defined type is a feature of the LLIDL grammar used to represent one
	        of the eleven (11) predefined types. Defined types are in contrast to literals and map variants.
	        The eleven predefined types are: undefined, boolean, integer, real, date, uuid, uri, string, binary,
	        array and map.</t>
	      <t hangText="GET (Method Access)">The GET method access, denoted in LLIDL with the double less-than
	      digraph ("&lt;&lt;") indicates a given resource should be accessed via the HTTP GET verb. In LLIDL,
	      a single message body definition comes after the double less-than digraph and indicates the composition
	      of the message the client should expect from the server.</t>
	      <t hangText="GET/PUT (Method Access)">The GET/PUT method access, denoted in LLIDL with the less-than
	        / greater-than digraph ("&lt;&gt;") indicates a given resource should be accessed via either the HTTP
	        GET or HTTP PUT verbs. In LLIDL, a single message body definition comes after the less-than /
	        greater-than digraph and indicates the composition of the message the client should expect from the
	        server (if the GET HTTP verb is used) or the composition of the message the server should expect from
	        the client (if the PUT HTTP verb is used.)</t>
	      <t hangText="GET/PUT/DELETE (Method Access)">The GET/PUT/DELETE method access, denoted in LLIDL
	        with the less-than / x / greater-than trigraph ("&lt;x&gt;") indicates a given resource should be
	        accessed via either the HTTP GET, HTTP PUT or HTTP DELETE verbs. In LLIDL, a single message body
	        definition comes after the less-than / x / greater-than trigraph and indicates the composition of
	        the message the client should expect from the server (if the GET HTTP verb is used) or the
	        composition of the message the server should expect from the client (if the PUT HTTP verb is used.)</t>
	      <t hangText="Interface">An LLIDL Interface is a collection of zero or more resources and any variant
	      record definitions they reference.</t>
	      <t hangText="Literal">Values in LLIDL resource definitions usually represent types. A literal value
	        may be used when an element in a message body is to be fixed to a particular value. Literals are
	        in contrast to defined types or map variants.</t>
	      <t hangText="LLIDL">LLIDL is an interface description language for describing RESTful resources
	        accessed via HTTP or HTTPS.</t>
	      <t hangText="LLSD">LLSD is an abstract type system used to describe the structure of data in LLIDL
	      Resource Definitions.</t>
	      <t hangText="Map">A map is a collection in which elements are accessed by a string key.</t>
	      <t hangText="Map Definition">A map definition is a feature of the LLIDL grammar used to denote maps. Map
	        definitions are comprised of zero or more comma delimited map entries.</t>
	      <t hangText="Map Entry">A map entry is a component of a map definition and is composed of a key name
	        and a type definition separated by a colon.</t>
	      <t hangText="Map Variant">See Variant Map.</t>
	      <t hangText="Method Access">A method access is a feature of the LLIDL grammar used to describe
	        which set HTTP verbs a client should use to access a resource. Method access classes include 'GET',
	        'GET/PUT', 'GET/PUT/DELETE' and 'POST'.</t>
	      <t hangText="Message Body">A message body is a feature of the LLIDL grammar that describes the contents
	        of a message flowing between a client and a server. A message body is the type definition that
	        describes completely the structure of a message flowing between systems.</t>
	      <t hangText="Named Type">A named type is a developer declared name for a type, array or map definition.</t>
	      <t hangText="POST (Method Access)">The POST method access, denoted in LLIDL with the hyphen / 
	        greater-than ("-&gt;") and less-than / hyphen ("&lt;-") digraphs, indicates a given resource should
	        be accessed via the HTTP POST verb. In LLIDL, a message body definition comes after both digraphs.
	        The message body definition following the first digraph indicates the composition of the message the
	        client should POST to the resource's URL while the second message body definition describes the
	        response the client should expect from the server.</t>
	      <t hangText="Resource">A Resource is an abstract representation of information or state maintained
	        by a remote process, potentially on a remote host. LLIDL may be used to describe the structure
	        of a resource and resources may be accessed by sending and receiving messages serialized using one
	        of the three serialization schemes via HTTP(S).</t>
	      <t hangText="Resource Access">The act of accessing a RESTful resource.</t>
	      <t hangText="Resource Definition">An LLIDL Resource Definition is a statement in the LLIDL language
	        describing a single RESTful resource exported by a remote service. Resource definitions include a
	        resource class, optional query parameters, a method access indicating which HTTP verbs are
	        acceptable to the service, the structure of the resource access' request and/or the structure
	        of the resource access' response. Resource definitions may be used along with a serialization scheme
	        to format or parse a resource request or response.</t>
	      <t hangText="Resource Class">A Resource Class is the textual identifier associated with a resource. It
	        is used to uniquely identify a resource in an interface.</t>
	      <t hangText="Selector">See Variant Selector.</t>
	      <t hangText="Selector Literal">A literal used to identify which variant in a map variant should be
	        expected is a "selector literal."</t>
	      <t hangText="Serialization Scheme">A serialization scheme defines rules used to convert a data
	        structure into an octet stream suitable for transmission across a network. Three schemes are
	        defined in this document: XML, JSON and Binary.</t>
	      <t hangText="Simple Type">In LLSD and LLIDL, a "simple type" is a defined type that is not a
	        collection. It is one of: undefined, boolean, integer, real, date, uuid, uri, string or binary.</t>
	      <t hangText="Type Definition">A type definition is a feature of the LLIDL grammar used to declare
	        the type of a data element in a message body. It may be a literal, a defined type or a variant map.</t>
	      <t hangText="Variant Definition">A map used as one of several options in a variant map.</t>
	      <t hangText="Variant Map">A variant type definition in which a map is used for one of the variants.
	        Variant maps may include a selector to assist in matching the most appropriate variant.</t>
	      <t hangText="Variant Selector">A map entry whose value is set as a literal. Used to determine which
	      variant definition of a variant map is to be used.</t>
	      <t hangText="Variant Type Definition">A type definition comprised of more than one definition. Variant
	        type definitions are defined using the named type feature of LLIDL.</t>
	    </list></t>
	  </section>
	  <section title="Acknowledgements">
	    <t>The authors gratefully acknowledge the contributions of:
	    Lora Baines,
	    Alan Bradley,
      Suzy Deffeyes,
      <!-- &lt;morgaine.dinova@googlemail.com&gt;, -->
	    Morgaine Dinova,
	    Kevin Flynn,
	    Valentyn Gatsuk,
	    Walter Gibbs,
	    John Hurliman,
	    Dave Huseby,
	    Charles Krinke,
	    Jennifer Leech,
      David Levine,
	    Steven Lisberger,
	    Dan Olivares,
	    Catherine Pfeffer,
	    Jon Watte and
	    Ryan Williams.
	    </t>
	  </section>
	</back>
</rfc>
