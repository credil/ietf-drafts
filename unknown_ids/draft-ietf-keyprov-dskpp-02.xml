<?xml version="1.0" encoding="US-ASCII"?>
<!-- $Id: ct-kip-two-pass.xml,v 1.7 2006/10/14 18:52:48 mnystrom Exp $ -->
<!-- Copyright 2006 RSA Security Inc. All rights reserved. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="yes" ?>
<rfc category="std" docName="draft-ietf-keyprov-dskpp-02.txt" ipr="full3978">
  <front>
    <title abbrev="DSKPP">Dynamic Symmetric Key Provisioning Protocol
    (DSKPP)</title>

    <author fullname="Andrea Doherty" initials="A." surname="Doherty">
      <organization>RSA, The Security Division of EMC</organization>

      <address>
        <postal>
          <street>174 Middlesex Tpk.</street>

          <city>Bedford</city>

          <region>MA</region>

          <code>01730</code>

          <country>USA</country>
        </postal>

        <email>adoherty@rsa.com</email>
      </address>
    </author>

    <author fullname="Mingliang Pei" initials="M." surname="Pei">
      <organization>Verisign, Inc.</organization>

      <address>
        <postal>
          <street>487 E. Middlefield Road</street>

          <city>Mountain View</city>

          <region>CA</region>

          <code>94043</code>

          <country>USA</country>
        </postal>

        <email>mpei@verisign.com</email>
      </address>
    </author>

    <author fullname="Salah Machani" initials="S." surname="Machani">
      <organization>Diversinet Corp.</organization>

      <address>
        <postal>
          <street>2225 Sheppard Avenue East, Suite 1801</street>

          <city>Toronto</city>

          <region>Ontario</region>

          <code>M2J 5C2</code>

          <country>Canada</country>
        </postal>

        <email>smachani@diversinet.com</email>
      </address>
    </author>

    <author fullname="Magnus Nystrom" initials="M." surname="Nystrom">
      <organization>RSA, The Security Division of EMC</organization>

      <address>
        <postal>
          <street>Arenavagen 29</street>

          <city>Stockholm</city>

          <region>Stockholm Ln</region>

          <code>121 29</code>

          <country>SE</country>
        </postal>

        <email>mnystrom@rsa.com</email>
      </address>
    </author>

    <date day="25" month="January" year="2008" />

    <area>Security Area</area>

    <workgroup>KEYPROV Working Group</workgroup>

    <abstract>
      <t>DSKPP is a client-server protocol for initialization (and
      configuration) of symmetric keys to locally and remotely accessible
      cryptographic modules. The protocol can be run with or without
      private-key capabilities in the cryptographic modules, and with or
      without an established public-key infrastructure.</t>

      <t>Two variations of the protocol support multiple usage scenarios. The
      four-pass (i.e., two round-trip) variant enables key generation in near
      real-time. With the four-pass variant, keys are mutually generated by
      the provisioning server and cryptographic module; provisioned keys are
      not transferred over-the-wire or over-the-air. The two-pass variant
      enables secure and efficient download and installation of symmetric keys
      to a cryptographic module in environments where near real-time
      communication may not be possible.</t>

      <t>This document builds on information contained in <xref
      target="RFC4758"></xref>, adding specific enhancements in response to
      implementation experience and liaison requests. It is intended that this
      document or a successor version thereto will become the basis for
      subsequent progression of a symmetric key provisioning protocol
      specification on the standards track.</t>
    </abstract>
  </front>

  <middle>
    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-Introduction" title="Introduction">
      <t>A symmetric key cryptographic module provides data authentication and
      encryption services to software (or firmware) applications hosted on
      hardware devices, such as personal computers, handheld mobile phones,
      one-time password tokens, USB flash drives, tape drives, etc. Until
      recently, provisioning symmetric keys to these modules has been labor
      intensive, involving manual operations that are device-specific, and
      inherently error-prone.</t>

      <t>Fortunately, an increasing number of hardware devices enable
      programmatic initialization of their applications. For example, a
      U3-ready thumb drive lets users load and configure applications locally
      through a USB port on their PC. Other hardware devices, such as Personal
      Digital Assistant (PDA) phones, allow users to load and configure
      applications over-the-air. Likewise, programmable cryptographic modules
      enable issuers to provision symmetric keys via the Internet, whether
      over-the-wire or over-the-air.</t>

      <t>This document describes the Dynamic Symmetric Key Provisioning
      Protocol (DSKPP), which leverages these recent technological
      developments. DSKPP provides an open and interoperable mechanism for
      initializing and configuring symmetric keys to cryptographic modules
      that are accessible over the Internet. The description is based on the
      information contained in RFC4758, and contains specific enhancements,
      such as User Authentication and support for the <xref
      target="PSKC"></xref> format for transmission of key material.</t>

      <t>DSKPP is a client-server protocol with two variations. One variation
      establishes a symmetric key by mutually authenticated key agreement. The
      other variation relies on key distribution. In the former case, key
      agreement enables two parties (a cryptographic module and key
      provisioning server) to establish a symmetric cryptographic key using an
      exchange of four messages, such that the key is not transported over the
      Internet. In the latter case, key distribution enables a key
      provisioning server to transport a symmetric key to a cryptographic
      module over the Internet using an exchange of two messages. In either
      case, DSKPP is flexible enough to be run with or without private-key
      capability in the cryptographic module, and with or without an
      established public-key infrastructure.</t>

      <t>All DSKPP communications consist of pairs of messages: a request and
      a response. Each pair is called an &ldquo;exchange&rdquo;, and each
      message sent in an exchange is called a &ldquo;pass&rdquo;. Thus, an
      implementation of DSKPP that relies on mutually authenticated key
      agreement is called the &ldquo;four-pass protocol&rdquo;; an
      implementation of DSKPP that relies on key distribution is called the
      &ldquo;two-pass protocol&rdquo;.</t>

      <t>DSKPP message flow always consists of a request followed by a
      response. It is the responsibility of the client to ensure reliability.
      If the response is not received with a timeout interval, the client
      needs to retransmit the request (or abandon the connection). Number of
      retries and lengths of timeouts are not covered in this document because
      they do not affect interoperability.</t>

      <section title="Usage Scenarios">
        <t>DSKPP is expected to be used to provision symmetric keys to
        cryptographic modules in a number of different scenarios, each with
        its own special requirements.</t>

        <section anchor="UC1" title="Single Key Request">
          <t>The usual scenario is that a cryptographic module makes a request
          for a symmetric key from a provisioning server that is located on
          the local network or somewhere on the Internet. Depending upon the
          deployment scenario, the provisioning server may generate a new key
          on-the-fly or use a pre-generated key, e.g., one provided by a
          legacy back-end issuance server. The provisioning server assigns a
          unique key ID to the symmetric key and provisions it to the
          cryptographic module.</t>
        </section>

        <section title="Multiple Key Requests">
          <t>A cryptographic module makes multiple requests for symmetric keys
          from the same provisioning server. The symmetric keys need not be of
          the same type, i.e., the keys may be used with different symmetric
          key cryptographic algorithms, including one-time password
          authentication algorithms, and AES encryption algorithm.</t>
        </section>

        <section title="Session Time-Out Policy">
          <t>Once a cryptographic module initiates a symmetric key request,
          the provisioning server may require that any subsequent actions to
          complete the provisioning cycle occur within a certain time window.
          For example, an issuer may provide a time-limited authentication
          code to a user during registration, which the user will input into
          the cryptographic module to authenticate themselves with the
          provisioning server. If the user inputs a valid authentication code
          within the fixed time period established by the issuer, the server
          will allow a key to be provisioned to the cryptographic module
          hosted by the user's device.</t>
        </section>

        <section title="Outsourced Provisioning">
          <t>A symmetric key issuer outsources its key provisioning to a
          third-party key provisioning server provider. The issuer is
          responsible for authenticating and granting rights to users to
          acquire keys while acting as a proxy to the cryptographic module to
          acquire symmetric keys from the provisioning server; the
          cryptographic module communicates with the issuer proxy server,
          which forwards provisioning requests to the provisioning server.</t>
        </section>

        <section title="Key Renewal">
          <t>A cryptographic module requests renewal of a symmetric key using
          the same key ID already associated with the key. Such a need may
          occur in the case when a user wants to upgrade her device that
          houses the cryptographic module or when a key has expired. When a
          user uses the same cryptographic module to, for example, perform
          strong authentication at multiple Web login sites, keeping the same
          key ID removes the need for the user to register a new key ID at
          each site.</t>
        </section>

        <section title="Pre-Loaded Key Replacement">
          <t>This scenario represents a special case of symmetric key renewal
          in which a local administrator can authenticate the user
          procedurally before initiating the provisioning process. It also
          allows for an issuer to pre-load a key onto a cryptographic module
          with a restriction that the key is replaced with a new key prior to
          use of the cryptographic module. Another variation of this scenario
          is the issuer who recycles devices. In this case, an issuer would
          provision a new symmetric key to a cryptographic module hosted on a
          device that was previously owned by another user.</t>

          <t>Note that this usage scenario is essentially the same as the last
          scenario wherein the same key ID is used for renewal.</t>
        </section>

        <section title="Pre-Shared Transport Key">
          <t>A cryptographic module is loaded onto a smart card after the card
          is issued to a user. The symmetric key for the cryptographic module
          will then be provisioned using a secure channel mechanism present in
          many smart card platforms. This allows a direct secure channel to be
          established between the smart card chip and the provisioning server.
          For example, the card commands (i.e., Application Protocol Data
          Units, or APDUs) are encrypted with a pre-shared transport key and
          sent directly to the smart card chip, allowing secure post-issuance
          in-the-field provisioning. This secure flow can pass Transport Layer
          Security (TLS) and other transport security boundaries.</t>

          <t>Note that two pre-conditions for this usage scenario are for the
          protocol to be tunneled and the provisioning server to know the
          correct pre-established transport key.</t>
        </section>

        <section title="End-to-End Protection of Key Material">
          <t>In this scenario, transport layer security does not provide
          end-to-end protection of key material transported from the
          provisioning server to the cryptographic module. For example, TLS
          may terminate at an application hosted on a PC rather than at the
          cryptographic module (i.e., the endpoint) located on a data storage
          device. Mutually authenticated key agreement provides end-to-end
          protection, which TLS cannot provide.</t>
        </section>
      </section>

      <section title="Protocol Entities">
        <t>In principle, the protocol involves a DSKPP client and a DSKPP
        server. The DSKPP client manages communication between the
        cryptographic module and the provisioning server. In this document,
        the DSKPP server represents the provisioning server.</t>

        <t>A high-level object model that describes the client-side entities
        and how they relate to each other is shown in <xref
        target="Objects"></xref>. Conceptually, each entity is represented by
        the definitions found in <xref
        target="Subsection-Definitions"></xref>.</t>

        <figure anchor="Objects" title="Object Model">
          <artwork><![CDATA[-----------          -------------
| User    |          | Device    | 
|---------|*  owns  *|-----------|
| UserID  |--------->| DeviceID  |
| ...     |          | ...       |
-----------          -------------
                          | 1
                          |
                          | contains
                          | 
                          | *
                          V  
              --------------------------
              |Cryptographic Module    |
              |------------------------|
              |Crypto Module ID        |
              |Security Attribute List |
              |...                     |
              --------------------------
                         | 1
                         |
                         | contains
                         |
                         | *
                         V  
                -----------------------
                |Key Container        |
                |---------------------|
                |Key ID               |
                |Key Type             |
                |...                  |
                -----------------------  
 ]]></artwork>
        </figure>

        <t>It is assumed that a device will host an application layered above
        the cryptographic module, and this application will manage
        communication between the DSKPP client and cryptographic module. The
        manner in which the communicating application will transfer DSKPP
        protocol elements to and from the cryptographic module is transparent
        to the DSKPP server. One method for this transfer is described in
        <xref target="CT-KIP-P11"></xref>.</t>
      </section>

      <section title="Initiating DSKPP">
        <t>To initiate DSKPP:<vspace blankLines="1" /><list hangIndent="4"
            style="format %d.">
            <t>A server may first send a DSKPP trigger message to a client
            application (e.g., in response to a user browsing to a Web site
            that requires a symmetric key for authentication), although this
            step is optional.</t>

            <t>A client application calls on the DSKPP client to send a
            symmetric key request to a DSKPP server, thus beginning a DSKPP
            protocol run.</t>
          </list></t>

        <t>One of the following actions may be used to contact a DSKPP
        server:<vspace blankLines="1" /><list hangIndent="4"
            style="format %d.">
            <t>A user may indicate how the DSKPP client is to contact a
            certain DSKPP server during a browsing session.</t>

            <t>A DSKPP client may be pre-configured to contact a certain DSKPP
            server.</t>

            <t>A user may be informed out-of-band about the location of the
            DSKPP server.<vspace blankLines="1" /></t>
          </list>Once the location of the DSKPP server is known, the DSKPP
        client and the DSKPP server engage in a 4-pass or 2-pass protocol.</t>
      </section>

      <section title="Determining Which Protocol Variant to Use">
        <t>The four-pass and two-pass protocols are appropriate in different
        deployment scenarios, as described in the sub-sections below.</t>

        <section title="Criteria for Using the Four-Pass Protocol">
          <t>The four-pass protocol is needed under one or more of the
          following conditions:<vspace blankLines="1" /><list style="symbols">
              <t>The cryptographic module is not pre-populated with a
              transport key, nor hosted on a pre-keyed device (e.g., a SIM
              card), nor has a keypad that can be used for entering a
              passphrase (such as present on a mobile phone).</t>

              <t>The hardware device will be used within multiple security
              domains, which means that each domain will need to provision its
              own symmetric key. However, the cryptographic module does not
              have a transport key, or other type of key that can be used with
              multiple provisioning servers.</t>

              <t>A cryptographic module does not have private-key
              capabilities.</t>

              <t>When the system provides a single point for exposing key
              material. This risk can be mitigated by ensuring that both
              parties contribute entropy to the key, such as with key
              agreement.</t>

              <t>A consumer of the protocol requires algorithm agility, esp.
              the ability to negotiate which encryption mechanisms and key
              types are used during a protocol run.</t>
            </list></t>
        </section>

        <section title="Criteria for Using the Two-Pass Protocol">
          <t>The two-pass protocol is needed under one or more of the
          following conditions:<vspace blankLines="1" /><list style="symbols">
              <t>A device is not able to support near real-time
              communications.</t>

              <t>Pre-existing (i.e., legacy) keys must be provisioned to the
              cryptographic module.</t>

              <t>The cryptographic module has a transport key and is capable
              of performing private-key operations.</t>

              <t>The cryptographic module has a pre-shared key (e.g., a mobile
              phone with a SIM card).\</t>

              <t>The cryptographic module has a keypad in which a user may
              enter a passphrase, useful for deriving a key-wrapping key for
              distribution of key material.</t>

              <t>A consumer of the protocol requires algorithm agility, esp.
              the ability to negotiate which encryption mechanisms and key
              types are used during a protocol run.</t>

              <t>Workflow dictates that an approval process is required as
              part of the protocol run (e.g., for user authorization).</t>

              <t>Near real-time communication between the client and server is
              not possible.</t>
            </list></t>
        </section>
      </section>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="terms" title="Terminology">
      <section title="Key Words">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119"></xref>.</t>
      </section>

      <section anchor="Subsection-Definitions" title="Definitions">
        <t><list hangIndent="4" style="hanging">
            <t hangText="Authentication Code (AC):">Client Authentication Code
            comprised of a string of numeric characters known to the device
            and the server and containing an identifier and a password<vspace
            blankLines="1" /></t>

            <t hangText="Authentication Data (AD):">Client Authentication Data
            that may be derived from the Authentication Code (AC)<vspace
            blankLines="1" /></t>

            <t hangText="Cryptographic Module:">A component of an application,
            which enables symmetric key cryptographic functionality<vspace
            blankLines="1" /></t>

            <t hangText="CryptoModule ID:">A unique identifier for an instance
            of the cryptographic module<vspace blankLines="1" /></t>

            <t hangText="Device:">A physical piece of hardware or software
            framework that hosts symmetric key cryptographic modules<vspace
            blankLines="1" /></t>

            <t hangText="Device ID (DeviceID):">A unique identifier for the
            device<vspace blankLines="1" /></t>

            <t hangText="DSKPP Client:">Manages communication between the
            symmetric key cryptographic module and the DSKPP server<vspace
            blankLines="1" /></t>

            <t hangText="DSKPP Server:">The symmetric key provisioning server
            that participates in the DSKPP protocol run<vspace
            blankLines="1" /></t>

            <t hangText="DSKPP Server ID (ServerID):">The unique identifier of
            a DSKPP server<vspace blankLines="1" /></t>

            <t hangText="Key Container (KC):">An object that encapsulates a
            symmetric key and its configuration data<vspace
            blankLines="1" /></t>

            <t hangText="Key Container Header (KCH):">Information about the
            Key Container, useful for two-pass DSKPP, e.g., the ServerID and
            KPM<vspace blankLines="1" /></t>

            <t hangText="Key ID (KeyID):">A unique identifier for the
            symmetric key<vspace blankLines="1" /></t>

            <t hangText="Key Protection Method (KPM):">The key protection
            profile used during two-pass DSKPP<vspace blankLines="1" /></t>

            <t hangText="Key Protection Method List (KPML):">The list of key
            protection methods supported by a cryptographic module<vspace
            blankLines="1" /></t>

            <t hangText="Key Type:">The type of symmetric key cryptographic
            methods for which the key will be used (e.g., OATH HOTP or RSA
            SecurID authentication, AES encryption, etc.)<vspace
            blankLines="1" /></t>

            <t hangText="Security Attribute List (SAL):">A payload that
            contains the DSKPP version, DSKPP variation (four- or two-pass),
            key container formats, key types, and cryptographic algorithms
            that the cryptographic module is capable of supporting<vspace
            blankLines="1" /></t>

            <t hangText="Security Context (SC):">A payload that contains the
            DSKPP version, DSKPP variation (four- or two-pass), key container
            format, key type, and cryptographic algorithms relevant to the
            current protocol run<vspace blankLines="1" /></t>

            <t hangText="User:">The person or client to whom devices are
            issued<vspace blankLines="1" /></t>

            <t hangText="User ID:">A unique identifier for the user or
            client<vspace blankLines="1" /></t>
          </list></t>
      </section>

      <section title="Notation">
        <t><list hangIndent="18" style="hanging">
            <t hangText="||">String concatenation<vspace blankLines="1" /></t>

            <t hangText="[x]">Optional element x<vspace blankLines="1" /></t>

            <t hangText="A ^ B">Exclusive-OR operation on strings A and B
            (where A and B are of equal length)<vspace blankLines="1" /></t>

            <t hangText="&lt;XMLElement&gt;">A typographical convention used
            in the body of the text<vspace blankLines="1" /></t>

            <t hangText="DSKPP-PRF(k,x,l)">A keyed psuedo-random function (see
            <xref target="DSKPP-PRF"></xref>)<vspace blankLines="1" /></t>

            <t hangText="E(k,m)">Encryption of m with the key k<vspace
            blankLines="1" /></t>

            <t hangText="K">Key used to encrypt R_C (either K_SERVER, K_SHARED
            or K_DERIVED), or in MAC or DSKPP_PRF computations<vspace
            blankLines="1" /></t>

            <t hangText="K_AC">Secret key that is derived from the
            Authentication Code and used for user authentication
            purposes<vspace blankLines="1" /></t>

            <t hangText="K_CLIENT">Public key of the DSKPP client<vspace
            blankLines="1" /></t>

            <t hangText="K_DERIVED">Secret key derived from a passphrase that
            is known to both the DSKPP client or user and the DSKPP
            server<vspace blankLines="1" /></t>

            <t hangText="K_MAC">Secret key used for key confirmation and
            server authentication purposes, and generated in DSKPP<vspace
            blankLines="1" /></t>

            <t hangText="K_MAC'">A second secret key used for server
            authentication purposes in 2-pass DSKPP<vspace
            blankLines="1" /></t>

            <t hangText="K_SERVER">Public key of the DSKPP server<vspace
            blankLines="1" /></t>

            <t hangText="K_SHARED">Secret key shared between the DSKPP client
            and the DSKPP server<vspace blankLines="1" /></t>

            <t hangText="K_TOKEN">Secret key used for cryptographic module
            computations, and generated in DSKPP<vspace blankLines="1" /></t>

            <t hangText="R">Pseudorandom value chosen by the DSKPP client and
            used for MAC computations<vspace blankLines="1" /></t>

            <t hangText="R_C">Pseudorandom value chosen by the DSKPP client
            and used as input to the generation of K_TOKEN<vspace
            blankLines="1" /></t>

            <t hangText="R_S">Pseudorandom value chosen by the DSKPP server
            and used as input to the generation of K_TOKEN<vspace
            blankLines="1" /></t>

            <t hangText="R_TRIGGER">Pseudorandom value chosen by the DSKPP
            server and used as input in a trigger message.</t>

            <t hangText="URL_S">Server address as a URL<vspace
            blankLines="1" /></t>
          </list></t>
      </section>

      <section title="Abbreviations">
        <t><list hangIndent="8" style="hanging">
            <t hangText="AC">Authentication Code</t>

            <t hangText="AD">Authentication Data</t>

            <t hangText="DSKPP">Dynamic Symmetric Key Provisioning
            Protocol</t>

            <t hangText="HTTP">Hypertext Transfer Protocol</t>

            <t hangText="KC">Key Container</t>

            <t hangText="KCH">Key Container Header</t>

            <t hangText="KPM">Key Protection Method</t>

            <t hangText="KPML">Key Protection Method List</t>

            <t hangText="MAC">Message Authentication Code</t>

            <t hangText="PC">Personal Computer</t>

            <t hangText="PDU">Protocol Data Unit</t>

            <t hangText="PKCS">Public-Key Cryptography Standards</t>

            <t hangText="PRF">Pseudo-Random Function</t>

            <t hangText="PSKC">Portable Symmetric Key Container</t>

            <t hangText="SAL">Security Attribute List (see <xref
            target="Subsection-Definitions"></xref>)</t>

            <t hangText="SC">Security Context (see <xref
            target="Subsection-Definitions"></xref>)</t>

            <t hangText="TLS">Transport Layer Security</t>

            <t hangText="URL">Uniform Resource Locator</t>

            <t hangText="USB">Universal Serial Bus</t>

            <t hangText="XML">eXtensible Markup Language</t>
          </list></t>
      </section>
    </section>

    <!---->

    <section anchor="Section-Protocol" title="DSKPP Protocol Details">
      <t>DSKPP enables symmetric key provisioning between a DSKPP server and
      DSKPP client. The DSKPP protocol supports the request and response
      messages shown in <xref target="Figure-Overview"></xref>. These messages
      are described below.</t>

      <figure anchor="Figure-Overview"
              title="The DSKPP protocol (with OPTIONAL preceding trigger)">
        <artwork><![CDATA[+---------------+                            +---------------+
|               |                            |               |
|  DSKPP Client |                            |  DSKPP Server |
|               |                            |               |
+---------------+                            +---------------+
        |                                            |
        | [ <--------- <KeyProvTrigger> --------- ]  |
        |                                            |
        |   ------- <KeyProvClientHello> ------->    |
        |        (Applicable to 4- and 2-pass)       |
        |                                            |
        |   <------ <KeyProvServerHello> --------    |
        |        (Applicable to 4-pass only)         |
        |                                            |
        |   ------- <KeyProvClientNonce> ------->    |
        |        (Applicable to 4-pass only)         |
        |                                            |
        |   <---- <KeyProvServerFinished> -------    |
        |       (Applicable to 4- and 2-pass)        |
        |                                            |
              ]]></artwork>
      </figure>

      <t><list hangIndent="4" style="hanging">
          <t hangText="[&lt;KeyProvTrigger&gt;]:">A DSKPP server may initiate
          the DSKPP protocol by sending a &lt;KeyProvTrigger&gt; message. For
          example, this message may be sent in response to a user requesting a
          symmetric key in a browsing session. The trigger message always
          contains a nonce to allow the server to couple the trigger with a
          later &lt;KeyProvClientHello&gt; request.<vspace
          blankLines="1" /></t>

          <t hangText="&lt;KeyProvClientHello&gt;:">With this request, a DSKPP
          client initiates contact with the DSKPP server, indicating which
          protocol versions and variations (four-pass or two-pass), key types,
          encryption and MAC algorithms that it supports. In addition, the
          request may include client authentication data that the DSKPP server
          uses to verify proof-of-possession of the device. <vspace
          blankLines="1" /></t>

          <t hangText="&lt;KeyProvServerHello&gt;:">Upon receiving a
          &lt;KeyProvClientHello&gt; request, the DSKPP server uses the
          &lt;KeyProvServerHello&gt; response to specify which protocol
          version and variation, key type, encryption algorithm, and MAC
          algorithm that will be used by the DSKPP server and DSKPP client
          during the protocol run. The decision of which variation, key type,
          and cryptographic algorithms to pick is policy- and
          implementation-dependent and therefore outside the scope of this
          document.<vspace blankLines="1" />The &lt;KeyProvServerHello&gt;
          response includes the DSKPP server's random nonce, R_S. The response
          also consists of information about either a shared secret key, or
          its own public key, that the DSKPP client uses when sending its
          protected random nonce, R_C, in the &lt;KeyProvClientNonce&gt;
          request (see below).<vspace blankLines="1" />Optionally, the DSKPP
          server may provide a MAC that the DSKPP client may use for server
          authentication.<vspace blankLines="1" /></t>

          <t hangText="&lt;KeyProvClientNonce&gt;:">With this request, a DSKPP
          client and DSKPP server securely exchange protected data, e.g., the
          protected random nonce R_C. In addition, the request may include
          client authentication data that the DSKPP server uses to verify
          proof-of-possession of the device.<vspace blankLines="1" /></t>

          <t hangText="&lt;KeyProvServerFinished&gt;:">The
          &lt;KeyProvServerFinished&gt; response is a confirmation message
          that includes a key container that holds configuration data, and may
          also contain protected key material (this depends on the protocol
          variation, as discussed below).<vspace blankLines="1" />Optionally,
          the DSKPP server may provide a MAC that the DSKPP client may use for
          server authentication.</t>
        </list></t>

      <section anchor="Subsection-FourPassUsage"
               title="Four-Pass Protocol Usage">
        <t>This section describes the message flow and methods that comprise
        the four-pass protocol variant.</t>

        <section anchor="Subsection-4PassFlow" title="Message Flow">
          <t>The four-pass protocol flow consists of two message
          exchanges:</t>

          <t><list style="format %d:">
              <t>Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 =
              &lt;KeyProvServerHello&gt;</t>

              <t>Pass 3 = &lt;KeyProvClientNonce&gt;, Pass 4 =
              &lt;KeyProvServerFinished&gt;</t>
            </list></t>

          <t>The first pair of messages negotiate cryptographic algorithms and
          exchange nonces. The second pair of messages establishes a symmetric
          key using mutually authenticated key agreement.</t>

          <t>The DSKPP server MUST ensure that a generated key is associated
          with the correct cryptographic module, and if applicable, the
          correct user. To do this, the DSKPP server MAY couple an initial
          user authentication to the DSKPP execution using one of the
          mechanisms described in <xref
          target="Section-ClientAuthN"></xref>.</t>

          <t>The purpose and content of each message are described below,
          including the optional &lt;KeyProvTrigger&gt;.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
                             [<---] R_TRIGGER, [DeviceID], 
                                         [KeyID], [URL_S]
]]></artwork>
          </figure>

          <t>The DSKPP server optionally sends a &lt;KeyProvTrigger&gt;
          message to the DSKPP client. The trigger message MUST contain a
          nonce, R_TRIGGER, to allow the server to couple the trigger with a
          later &lt;KeyProvClientHello&gt; request. &lt;KeyProvTrigger&gt; MAY
          include DeviceID to allow the client to select the device with which
          it will communicate. The DeviceID MAY also be used later to
          authenticate the client (see <xref
          target="Subsection-DeviceID"></xref>). In the case of key renewal,
          &lt;KeyProvTrigger&gt; MAY include the identifier for the key,
          KeyID, that is being replaced. Finally, the trigger MAY contain a
          URL for the DSKP client to use when contacting the DSKPP server.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
        SAL, [R_TRIGGER], 
        [DeviceID], [KeyID]     --->    
                                                ]]></artwork>
          </figure>

          <t>The DSKPP client sends a &lt;KeyProvClientHello&gt; message to
          the DSKPP server. This message MUST contain a Security Attribute
          List (SAL), identifying which DSKPP versions, protocol variations
          (in this case "four-pass"), key container formats, key types,
          encryption and MAC algorithms that the client supports. In addition,
          if a trigger message preceded &lt;KeyProvClientHello&gt;, then it
          passes the parameters received in &lt;KeyProvTrigger&gt; back to the
          DSKPP Server. In particular, it MUST include R_TRIGGER so that the
          DSKPP server can associate the client with the trigger message, and
          SHOULD include DeviceID and KeyID.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
                                <---  SC, R_S, [K], [MAC]
]]></artwork>
          </figure>

          <t>The DSKPP server responds to the DSKPP client with a
          &lt;KeyProvServerHello&gt; message, whose content MUST include a
          Security Context (SC). The client will use the SC to select the
          DSKPP version and variation (e.g., four-pass), type of key to
          generate, and cryptographic algorithms that it will use for the
          remainder of the protocol run. &lt;KeyProvServerHello&gt; MUST also
          include the server's random nonce, R_S, whose length may depend on
          the selected key type. In addition, the &lt;KeyProvServerHello&gt;
          message MAY provide K, which represents its own public key
          (K_SERVER) or information about a shared secret key (K_SHARED) to
          use for encrypting the cryptographic module's random nonce (see
          description of &lt;KeyProvClientNonce&gt; below). Optionally,
          &lt;KeyProvServerHello&gt; MAY include a MAC that the DSKPP client
          can use for server authentication in the case of key renewal (<xref
          target="Subsection-4passAuthZ"></xref> describes how to calculate
          the MAC).</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
        E(K,R_C), [AD]          --->                    
]]></artwork>
          </figure>

          <t>Based on the Security Context (SC) provided in the
          &lt;KeyProvServerHello&gt; message, the cryptographic module
          generates a random nonce, R_C. The length of the nonce R_C will
          depend on the selected key type. The cryptographic module encrypts
          R_C using the selected encryption algorithm and with a key, K, that
          is either the DSKPP server's public key, K_SERVER, or a shared
          secret key, K_SHARED, as indicated by the DSKPP server.</t>

          <t>Note: If K is equivalent to K_SERVER, then the cryptographic
          module SHOULD verify the server's certificate before using it to
          encrypt R_C in accordance with <xref target="RFC3280"></xref>.</t>

          <t>Note: If successful execution of the protocol will result in the
          replacement of an existing key with a newly generated one, the DSKPP
          client MUST verify the MAC provided in the &lt;KeyProvServer&gt;
          message. The DSKPP client MUST terminate the DSKPP session if the
          MAC does not verify, and MUST delete any nonces, keys, and/or
          secrets associated with the failed run.</t>

          <t>The DSKPP client MUST send the encrypted random nonce to the
          DSKPP server in a &lt;KeyProvClientNonce&gt; message, and MAY
          include client Authentication Data (AD), such as a MAC derived from
          an authentication code and R_C (refer to <xref
          target="Section-AuthCode"></xref>). Finally, the cryptographic
          module calculates and stores a symmetric key, K_TOKEN, of the key
          type specified in the SC received in &lt;KeyProvServerHello&gt;
          (refer to <xref
          target="Subsection-KeyGen"></xref>.&lt;KeyProvServerFinished&gt; for
          a description of how K_TOKEN is generated).</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
                                 <---             KC, MAC
]]></artwork>
          </figure>

          <t>If Authentication Data (AD) was received in the
          &lt;KeyProvClientNonce&gt; message, then the DSKPP server MUST
          authenticate the user in accordance with <xref
          target="Section-AuthCode"></xref>. If authentication fails, then
          DSKPP server MUST abort. Otherwise, the DSKPP server decrypts R_C,
          calculates K_TOKEN from the combination of the two random nonces R_S
          and R_C, the encryption key K, and possibly some other data, using
          the DSKPP-PRF function defined in <xref target="DSKPP-PRF"></xref>.
          The server then associates K_TOKEN with the cryptographic module in
          a server-side data store. The intent is that the data store later on
          will be used by some service that needs to verify or decrypt data
          produced by the cryptographic module and the key.</t>

          <t>Once the association has been made, the DSKPP server sends a
          confirmation message to the DSKPP client called
          &lt;KeyProvServerFinished&gt;. The confirmation message MUST include
          a Key Container (KC) that holds an identifier for the generated key
          (but not the key itself) and additional configuration information,
          e.g., the identity of the DSKPP server. The default symmetric key
          container format is based on the Portable Symmetric Key Container
          (PSKC) defined in <xref target="PSKC"></xref>. Alternative formats
          MAY include PKCS#12 <xref target="PKCS-12"></xref> or PKCS#5 XML
          <xref target="PKCS-5-XML"></xref> format. In addition to a Key
          Container, &lt;KeyProvServerFinished&gt; MUST also include a MAC
          that the DSKPP client will use to authenticate the message before
          commiting K_TOKEN.</t>

          <t>After receiving a &lt;KeyProvServerFinished&gt; message with
          Status = "Success", the DSKPP client MUST verify the MAC. The DSKPP
          client MUST terminate the DSKPP session if the MAC does not verify,
          and MUST, in this case, also delete any nonces, keys, and/or secrets
          associated with the failed run of the protocol. If
          &lt;KeyProvServerFinished&gt; has Status = "Success" and the MAC was
          verified, then the DSKPP client MUST associate the provided key
          container with the generated key K_TOKEN, and store this data
          permanently. After this operation, it MUST NOT be possible to
          overwrite the key unless knowledge of an authorizing key is proven
          through a MAC on a later &lt;KeyProvServerHello&gt; (and
          &lt;KeyProvServerFinished&gt;) message.</t>
        </section>

        <section title="Generation of Symmetric Keys for Cryptographic Modules">
          <t>With 4-pass DSKPP, the symmetric key that is the target of
          provisioning, is generated on-the-fly without being transferred
          between the DSKPP client and DSKPP server. A sample data flow
          depicting how this works followed by computational information are
          provided in the subsections below.</t>

          <section title="Data Flow">
            <t>A sample data flow showing key generation during the 4-pass
            protocol is shown in <xref target="keygen"></xref>.</t>

            <figure anchor="keygen"
                    title="Principal data flow for DSKPP key generation             - using public server key">
              <artwork><![CDATA[+----------------------+    +-------+     +----------------------+
|    +------------+    |    |       |     |                      |
|    | Server key |    |    |       |     |                      |
| +<-|  Public    |------>------------->-------------+---------+ |
| |  |  Private   |    |    |       |     |          |         | |
| |  +------------+    |    |       |     |          |         | |
| |        |           |    |       |     |          |         | |
| V        V           |    |       |     |          V         V |
| |   +---------+      |    |       |     |        +---------+ | |     
| |   | Decrypt |<-------<-------------<-----------| Encrypt | | |
| |   +---------+      |    |       |     |        +---------+ | |
| |      |  +--------+ |    |       |     |            ^       | |
| |      |  | Server | |    |       |     |            |       | |
| |      |  | Random |--->------------->------+  +----------+  | |
| |      |  +--------+ |    |       |     |   |  | Client   |  | |
| |      |      |      |    |       |     |   |  | Random   |  | |
| |      |      |      |    |       |     |   |  +----------+  | |
| |      |      |      |    |       |     |   |        |       | |
| |      V      V      |    |       |     |   V        V       | |
| |   +------------+   |    |       |     | +------------+     | |
| +-->|  DSKPP PRF |   |    |       |     | |  DSKPP PRF |<----+ |
|     +------------+   |    |       |     | +------------+       |
|           |          |    |       |     |       |              |
|           V          |    |       |     |       V              |
|       +-------+      |    |       |     |   +-------+          |
|       |  Key  |      |    |       |     |   |  Key  |          |
|       +-------+      |    |       |     |   +-------+          |
|       +-------+      |    |       |     |   +-------+          |
|       |Key Id |-------->------------->------|Key Id |          |
|       +-------+      |    |       |     |   +-------+          |
+----------------------+    +-------+     +----------------------+
      DSKPP Server         DSKPP Client         DSKPP Client
                            (PC Host)      (cryptographic module)
              ]]></artwork>
            </figure>

            <t>Note: Conceptually, although R_C is one pseudorandom string, it
            may be viewed as consisting of two components, R_C1 and R_C2,
            where R_C1 is generated during the protocol run, and R_C2 can be
            pre-generated and loaded on the cryptographic module before the
            device is issued to the user. In that case, the latter string,
            R_C2, SHOULD be unique for each cryptographic module.</t>

            <t>The inclusion of the two random nonces R_S and R_C in the key
            generation provides assurance to both sides (the cryptographic
            module and the DSKPP server) that they have contributed to the
            key's randomness and that the key is unique. The inclusion of the
            encryption key K ensures that no man-in-the-middle may be present,
            or else the cryptographic module will end up with a key different
            from the one stored by the legitimate DSKPP server.</t>

            <t>Note: A man-in-the-middle (in the form of corrupt client
            software or a mistakenly contacted server) may present his own
            public key to the cryptographic module. This will enable the
            attacker to learn the client's version of K_TOKEN. However, the
            attacker is not able to persuade the legitimate server to derive
            the same value for K_TOKEN, since K_TOKEN is a function of the
            public key involved, and the attacker's public key must be
            different than the correct server's (or else the attacker would
            not be able to decrypt the information received from the client).
            Therefore, once the attacker is no longer "in the middle," the
            client and server will detect that they are "out of sync" when
            they try to use their keys. In the case of encrypting R_C with
            K_SERVER, it is therefore important to verify that K_SERVER really
            is the legitimate server's key. One way to do this is to
            independently validate a newly generated K_TOKEN against some
            validation service at the server (e.g. by using a connection
            independent from the one used for the key generation).</t>
          </section>

          <section anchor="Subsection-KeyGen"
                   title="Computing the Symmetric Key">
            <t>In DSKPP, keys are generated using the DSKPP-PRF function
            defined in <xref target="DSKPP-PRF"></xref>, a secret random value
            R_C chosen by the DSKPP client, a random value R_S chosen by the
            DSKPP server, and the key K used to encrypt R_C. The input
            parameter s of DSKPP-PRF is set to the concatenation of the
            (ASCII) string "Key generation", K, and R_S, and the input
            parameter dsLen is set to the desired length of the key, K_TOKEN
            (the length of K_TOKEN is given by the key's type):</t>

            <t>dsLen = (desired length of K_TOKEN)</t>

            <t>K_TOKEN = DSKPP-PRF (R_C, "Key generation" || K || R_S,
            dsLen)</t>

            <t>When computing K_TOKEN above, the output of DSKPP-PRF MAY be
            subject to an algorithm-dependent transform before being adopted
            as a key of the selected type. One example of this is the need for
            parity in DES keys.<vspace blankLines="1" /></t>
          </section>
        </section>

        <section title="MAC Calculations">
          <section anchor="Subsection-4passAuthZ"
                   title="Server Authorization in the Case of Key Renewal">
            <t>A MAC MUST be present in the &lt;KeyProvServerHello&gt; message
            if the DSKPP run will result in the replacement of an existing key
            with a new one as proof that the DSKPP server is authorized to
            perform the action. When the MAC value is used for server
            authentication, the value MAY be computed by using the DSKPP-PRF
            function of <xref target="DSKPP-PRF"></xref>, in which case the
            input parameter s MUST be set to the concatenation of the (ASCII)
            string "MAC 1 computation", R (if sent by the client), and R_S,
            and K MUST be set to the existing MAC key K_MAC' . The input
            parameter dsLen MUST be set to the length of R_S:</t>

            <t>dsLen = len(R_S)</t>

            <t>MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || [R ||] R_S,
            dsLen)</t>
          </section>

          <section title="Key Confirmation">
            <t>To avoid a false "Commit" message causing the cryptographic
            module to end up in an initialized state in which the server does
            not recognize the stored key, &lt;ServerFinished&gt; messages MUST
            be authenticated with a MAC. The MAC MUST be calculated using the
            already established MAC algorithm and MUST be computed on the
            (ASCII) string "MAC 2 computation" and R_C using the existing the
            MAC key K_MAC' (i.e., the MAC key that existed before this
            protocol run). If DSKPP-PRFof <xref target="DSKPP-PRF"></xref> is
            used as the MAC algorithm, then the input parameter s MUST consist
            of the concatenation of the (ASCII) string "MAC 2 computation",
            R_C, and dsLen as follows:</t>

            <t>dsLen = len(R_C)</t>

            <t>MAC = DSKPP-PRF (K_MAC, "MAC 2 computation" || R_C, dsLen)</t>
          </section>
        </section>
      </section>

      <section anchor="Subsecton-TwoPass" title="Two-Pass Protocol Usage">
        <t>Two-pass DSKPP is essentially a transport of key material from the
        DSKPP server to the DSKPP client. Two-pass DSKPP supports multiple key
        protection methods that ensure K_TOKEN is not exposed to any other
        entity than the DSKPP server and the cryptographic module itself.
        Currently, three such key protection methods are defined (refer to
        <xref target="Section-Profiles"></xref>), each supporting a different
        usage of 2-pass DSKPP:</t>

        <t><list hangIndent="28" style="hanging">
            <t hangText="Key Transport">This profile is intended for
            PKI-capable devices. Key transport is carried out using a public
            key, K_CLIENT, whose private key part resides in the cryptographic
            module as the transport key.</t>

            <t hangText="Key Wrap">This profile is ideal for pre-keyed
            devices, e.g., SIM cards. Key wrap is carried out using a
            symmetric key-wrapping key, K_SHARED, which is known in advance by
            both the cryptographic module and the DSKPP server.</t>

            <t hangText="Passphrase-Based Key Wrap">This profile is a
            variation of the Key Wrap Profile. It is applicable to constrained
            devices with keypads, e.g., mobile phones. Key wrap is carried out
            using a passphrase-derived key-wrapping key, K_DERIVED, which is
            known in advance by both the cryptographic module and DSKPP
            server.</t>
          </list>This section describes the message flow and methods that
        comprise the two-pass protocol variant.</t>

        <section anchor="Subsection-2PassFlow" title="Message Flow">
          <t>The two-pass protocol flow consists of one exchange:</t>

          <t><list style="format %d:">
              <t>Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 =
              &lt;KeyProvServerFinished&gt;</t>
            </list></t>

          <t>The client's initial &lt;KeyProvClientHello&gt; message is
          directly followed by a &lt;KeyProvServerFinished&gt; message (unlike
          the four-pass variant, there is no exchange of the
          &lt;KeyProvServerHello&gt; and &lt;KeyProvClientNonce&gt; messages).
          However, as the two-pass variation of DSKPP consists of one round
          trip to the server, the client is still able to include its random
          nonce, R_C, algorithm preferences and supported key types in the
          &lt;KeyProvClientHello&gt; message. Note that by including R_C in
          &lt;KeyProvClientHello&gt;, the DSKPP client is able to ensure the
          server is alive before "committing" the key.</t>

          <t>To ensure that a generated key K_TOKEN ends up associated with
          the correct cryptographic module and user, the DSKPP server MAY
          couple an initial user authentication to the DSKPP execution using
          one of the mechanisms described in <xref
          target="Section-ClientAuthN"></xref>. Whatever the mechanism, the
          DSKPP server MUST ensure that a generated key is associated with the
          correct cryptographic module, and if applicable, the correct
          user.</t>

          <t>The purpose and content of each message are described below,
          including the optional &lt;KeyProvTrigger&gt;.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
                             [<---] R_TRIGGER, [DeviceID], 
                                         [KeyID], [URL_S]
]]></artwork>
          </figure>

          <t>The DSKPP server optionally sends a &lt;KeyProvTrigger&gt;
          message to the DSKPP client. The trigger message MUST contain a
          nonce, R_TRIGGER, to allow the server to couple the trigger with a
          later &lt;KeyProvClientHello&gt; request. &lt;KeyProvTrigger&gt; MAY
          include DeviceID to allow the client to select the device with which
          it will communicate. In the case of key renewal,
          &lt;KeyProvTrigger&gt; SHOULD include the identifier for the key,
          KeyID, that is being replaced. Finally, the trigger MAY contain a
          URL for the DSKP client to use when contacting the DSKPP server.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
        R_C, SAL, KPML, [AD],
        [R_TRIGGER], 
        [DeviceID], [KeyID]     --->    
                                               ]]></artwork>
          </figure>

          <t>The DSKPP client sends a &lt;KeyProvClientHello&gt; message to
          the DSKPP server. &lt;KeyProvClientHello&gt; MUST include client
          nonce, R_C, and a Security Attribute List (SAL), identifying which
          DSKPP versions, protocol variations (in this case "two-pass"), key
          container formats, key types, encryption and MAC algorithms that the
          client supports. Unlike 4-pass DSKPP, the 2-pass DSKPP client uses
          the &lt;KeyProvClientHello&gt; message to declare the list of Key
          Protection Methods (KPML) it supports, providing required payload
          information in accordance with <xref
          target="Section-Profiles"></xref>. Optionally, the message MAY
          include client Authentication Data (AD), such as a MAC derived from
          an authentication code and R_C (refer to <xref
          target="Section-AuthCode"></xref>). In addition, if a trigger
          message preceded &lt;KeyProvClientHello&gt;, then it passes the
          parameters received in &lt;KeyProvTrigger&gt; back to the DSKPP
          Server. In particular, it MUST include R_TRIGGER so that the DSKPP
          server can associate the client with the trigger message, and SHOULD
          include DeviceID and KeyID.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[        DSKPP Client                         DSKPP Server
        ------------                         ------------
                               <---  KCH, KC, E(K,K_PROV), 
                                                  MAC, AD
]]></artwork>
          </figure>

          <t>If Authentication Data (AD) was received, then the DSKPP server
          MUST authenticate the user in accordance with <xref
          target="Section-AuthCode"></xref>. If authentication fails, then
          DSKPP server MUST abort. Otherwise, the DSKPP server generates a key
          K_PROV from which two keys, K_TOKEN and K_MAC, are derived.
          (Alternatively, the key K_PROV may have been pre-generated as
          described in <xref target="UC1"></xref>. The DSKPP server selects a
          Key Protection Method (KPM) and applies it to K_PROV in accordance
          with <xref target="Section-Profiles"></xref>. The server then
          associates K_TOKEN with the cryptographic module in a server-side
          data store. The intent is that the data store later will be used by
          some service that needs to verify or decrypt data produced by the
          cryptographic module and the key.</t>

          <t>Once the association has been made, the DSKPP server sends a
          confirmation message to the DSKPP client called
          &lt;KeyProvServerFinished&gt;. For two-pass DSKPP, the confirmation
          message MUST include a Key Container Header (KCH) that contains the
          DSKPP Server's ID and KPM. The ServerID is used for authentication
          purposes, and the KPM informs the DSKPP client of the security
          context in which it will operate. In addition to the KCH, the
          confirmation message MUST include the Key Container (KC) that holds
          the KeyID, K_PROV from which K_TOKEN and K_MAC are derived, and
          additional configuration information. The default symmetric key
          container format is based on the Portable Symmetric Key Container
          (PSKC) defined in <xref target="PSKC"></xref>. Alternative formats
          MAY include PKCS#12 <xref target="PKCS-12"></xref> or PKCS#5 XML
          <xref target="PKCS-5-XML"></xref>. Finally, &lt;ServerFinished&gt;
          MUST include two MACs (MAC and AD) whose values are calculated with
          contribution from the client nonce, R_C, provided in the
          &lt;ClientHello&gt; message. The MAC values will allow the
          cryptographic module to perform key confirmation and server
          authentication before "commiting" the key (see <xref
          target="Subsection-MAC"></xref> for more information).</t>

          <t>After receiving a &lt;KeyProvServerFinished&gt; message with
          Status = "Success", the DSKPP client MUST verify both MAC values
          (MAC and AD). The DSKPP client MUST terminate the DSKPP session if
          either MAC does not verify, and MUST, in this case, also delete any
          nonces, keys, and/or secrets associated with the failed run of the
          protocol. If &lt;KeyProvServerFinished&gt; has Status = "Success"
          and the MACs were verified, then the DSKPP client MUST extract the
          key data from the provided key container, and store data locally.
          After this operation, it MUST NOT be possible to overwrite the key
          unless knowledge of an authorizing key is proven through a MAC on a
          later &lt;KeyProvServerFinished&gt; message.</t>
        </section>

        <section anchor="Section-Profiles" title="Key Protection Profiles">
          <t>This section introduces three profiles of two-pass DSKPP for key
          protection. Further profiles MAY be defined by external entities or
          through the IETF process.</t>

          <section title="Key Transport Profile">
            <t>This profile initializes the cryptographic module with a
            symmetric key, K_TOKEN, through key transport and key derivation.
            The key transport is carried out using a public key, K_CLIENT,
            whose private key part resides in the cryptographic module as the
            transport key. A key K_PROV from which two keys, K_TOKEN and K_MAC
            are derived MUST be transported.</t>

            <t>This profile MUST be identified with the following URN:
            urn:ietf:params:xml:schema:keyprov:protocol#transport</t>

            <t>In the two-pass version of DSKPP, the client MUST send a
            payload associated with this key protection method. The payload
            MUST be of type ds:KeyInfoType (<xref target="XMLDSIG"></xref>),
            and only those choices of the ds:KeyInfoType that identify a
            public key are allowed. The ds:X509Certificate option of the
            ds:X509Data alternative is RECOMMENDED when the public key
            corresponding to the private key on the cryptographic module has
            been certified.</t>

            <t>The server payload associated with this key protection method
            MUST be of type xenc:EncryptedKeyType (<xref
            target="XMLENC"></xref>), and only those encryption methods
            utilizing a public key that are supported by the DSKPP client (as
            indicated in the &lt;SupportedEncryptionAlgorithms&gt; element of
            the &lt;KeyProvClientHello&gt; message in the case of 2-pass
            DSKPP) are allowed as values for the &lt;xenc:EncryptionMethod&gt;
            element. Further, in the case of 2-pass DSKPP, the
            &lt;ds:KeyInfo&gt; element MUST contain the same value (i.e.
            identify the same public key) as the &lt;Payload&gt; of the
            corresponding supported key protection method in the
            &lt;KeyProvClientHello&gt; message that triggered the response.
            The &lt;CarriedKeyName&gt; element MAY be present, but MUST, when
            present, contain the same value as the &lt;KeyID&gt; element of
            the &lt;KeyProvServerFinished&gt; message. The Type attribute of
            the xenc:EncryptedKeyType MUST be present and MUST identify the
            type of the wrapped key. The type MUST be one of the types
            supported by the DSKPP client (as reported in the
            &lt;SupportedKeyTypes&gt; of the preceding
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The transported key MUST consist of two parts of equal length. The
            first half constitutes K_MAC and the second half constitutes
            K_TOKEN. The length of K_TOKEN (and hence also the length of
            K_MAC) is determined by the type of K_TOKEN.</t>

            <t>DSKPP servers and cryptographic modules supporting this profile
            MUST support the http://www.w3.org/2001/04/xmlenc#rsa-1_5
            key-wrapping mechanism defined in <xref
            target="XMLENC"></xref>.</t>

            <t>When this profile is used, the MacAlgorithm attribute of the
            &lt;Mac&gt; element of the &lt;KeyProvServerFinished&gt; message
            MUST be present and MUST identify the selected MAC algorithm. The
            selected MAC algorithm MUST be one of the MAC algorithms supported
            by the DSKPP client (as indicated in the
            &lt;SupportedMacAlgorithms&gt; element of the
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The MAC MUST be calculated as described in <xref
            target="Subsecton-TwoPass"></xref> for Two-Pass DSKPP.</t>

            <t>In addition, DSKPP servers MUST include the
            AuthenticationDataType element in their
            &lt;KeyProvServerFinished&gt; messages whenever a successful
            protocol run will result in an existing K_TOKEN being
            replaced.</t>
          </section>

          <section title="Key Wrap Profile">
            <t>This profile initializes the cryptographic module with a
            symmetric key, K_TOKEN, through key wrap and key derivation. The
            key wrap MUST be carried out using a (symmetric) key-wrapping key,
            K_SHARED, known in advance by both the cryptographic module and
            the DSKPP server. A key K_PROV from which two keys, K_TOKEN and
            K_MAC are derived MUST be wrapped.</t>

            <t>This profile MUST be identified with the following URI:
            urn:ietf:params:xml:schema:keyprov:protocol#wrap</t>

            <t>In the 2-pass version of DSKPP, the client MUST send a payload
            associated with this key protection method. The payload MUST be of
            type ds:KeyInfoType (<xref target="XMLDSIG"></xref>), and only
            those choices of the ds:KeyInfoType that identify a symmetric key
            are allowed. The ds:KeyName alternative is RECOMMENDED.</t>

            <t>The server payload associated with this key protection method
            MUST be of type xenc:EncryptedKeyType (<xref
            target="XMLENC"></xref>), and only those encryption methods
            utilizing a symmetric key that are supported by the DSKPP client
            (as indicated in the &lt;SupportedEncryptionAlgorithms&gt; element
            of the &lt;KeyProvClientHello&gt; message in the case of 2-pass
            DSKPP) are allowed as values for the &lt;xenc:EncryptionMethod&gt;
            element. Further, in the case of 2-pass DSKPP, the
            &lt;ds:KeyInfo&gt; element MUST contain the same value (i.e.
            identify the same symmetric key) as the &lt;Payload&gt; of the
            corresponding supported key protection method in the
            &lt;KeyProvClientHello&gt; message that triggered the response.
            The &lt;CarriedKeyName&gt; element MAY be present, and MUST, when
            present, contain the same value as the &lt;KeyID&gt; element of
            the &lt;KeyProvServerFinished&gt; message. The Type attribute of
            the xenc:EncryptedKeyType MUST be present and MUST identify the
            type of the wrapped key. The type MUST be one of the types
            supported by the DSKPP client (as reported in the
            &lt;SupportedKeyTypes&gt; of the preceding
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The wrapped key MUST consist of two parts of equal length. The
            first half constitutes K_MAC and the second half constitutes
            K_TOKEN. The length of K_TOKEN (and hence also the length of
            K_MAC) is determined by the type of K_TOKEN.</t>

            <t>DSKPP servers and cryptographic modules supporting this profile
            MUST support the http://www.w3.org/2001/04/xmlenc#kw-aes128
            key-wrapping mechanism defined in <xref
            target="XMLENC"></xref>.</t>

            <t>When this profile is used, the MacAlgorithm attribute of the
            &lt;Mac&gt; element of the &lt;KeyProvServerFinished&gt; message
            MUST be present and MUST identify the selected MAC algorithm. The
            selected MAC algorithm MUST be one of the MAC algorithms supported
            by the DSKPP client (as indicated in the
            &lt;SupportedMacAlgorithms&gt; element of the
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The MAC MUST be calculated as described in <xref
            target="Subsecton-TwoPass"></xref>.</t>

            <t>In addition, DSKPP servers MUST include the
            AuthenticationDataType element in their
            &lt;KeyProvServerFinished&gt; messages whenever a successful
            protocol run will result in an existing K_TOKEN being
            replaced.</t>
          </section>

          <section title="Passphrase-Based Key Wrap Profile">
            <t>This profile is a variation of the key wrap profile. It
            initializes the cryptographic module with a symmetric key,
            K_TOKEN, through key wrap and key derivation, using a
            passphrase-derived key-wrapping key, K_DERIVED. The passphrase is
            known in advance by both the device user and the DSKPP server. To
            preserve the property of not exposing K_TOKEN to any other entity
            than the DSKPP server and the cryptographic module itself, the
            method SHOULD be employed only when the device contains facilities
            (e.g. a keypad) for direct entry of the passphrase. A key K_PROV
            from which two keys, K_TOKEN and K_MAC are derived MUST be
            wrapped.</t>

            <t>This profile MUST be identified with the following URI:
            urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap</t>

            <t>In the 2-pass version of DSKPP, the client MUST send a payload
            associated with this key protection method. The payload MUST be of
            type ds:KeyInfoType (<xref target="XMLDSIG"></xref>). The
            ds:KeyName option MUST be used and the key name MUST identify the
            passphrase that will be used by the server to generate the
            key-wrapping key. As an example, the identifier could be a user
            identifier or a registration identifier issued by the server to
            the user during a session preceding the DSKPP protocol run.</t>

            <t>The server payload associated with this key protection method
            MUST be of type xenc:EncryptedKeyType (<xref
            target="XMLENC"></xref>), and only those encryption methods
            utilizing a passphrase to derive the key-wrapping key that are
            supported by the DSKPP client (as indicated in the
            &lt;SupportedEncryptionAlgorithms&gt; element of the
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP)
            are allowed as values for the &lt;xenc:EncryptionMethod&gt;
            element. Further, in the case of 2-pass DSKPP, the
            &lt;ds:KeyInfo&gt; element MUST contain the same value (i.e.
            identify the same passphrase) as the &lt;Payload&gt; of the
            corresponding supported key protection method in the
            &lt;KeyProvClientHello&gt; message that triggered the response.
            The &lt;CarriedKeyName&gt; element MAY be present, and MUST, when
            present, contain the same value as the &lt;KeyID&gt; element of
            the &lt;KeyProvServerFinished&gt; message. The Type attribute of
            the xenc:EncryptedKeyType MUST be present and MUST identify the
            type of the wrapped key. The type MUST be one of the types
            supported by the DSKPP client (as reported in the
            &lt;SupportedKeyTypes&gt; of the preceding
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The wrapped key MUST consist of two parts of equal length. The
            first half constitutes K_MAC and the second half constitutes
            K_TOKEN. The length of K_TOKEN (and hence also the length of
            K_MAC) is determined by the type of K_TOKEN.</t>

            <t>DSKPP servers and cryptographic modules supporting this profile
            MUST support the PBES2 password based encryption scheme defined in
            <xref target="PKCS-5"></xref> (and identified as
            http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2 in
            <xref target="PKCS-5-XML"></xref>), the PBKDF2 passphrase-based
            key derivation function also defined in <xref
            target="PKCS-5"></xref> (and identified as
            http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2 in
            <xref target="PKCS-5-XML"></xref>), and the
            http://www.w3.org/2001/04/xmlenc#kw-aes128 key-wrapping mechanism
            defined in <xref target="XMLENC"></xref>.</t>

            <t>When this profile is used, the MacAlgorithm attribute of the
            &lt;Mac&gt; element of the &lt;KeyProvServerFinished&gt; message
            MUST be present and MUST identify the selected MAC algorithm. The
            selected MAC algorithm MUST be one of the MAC algorithms supported
            by the DSKPP client (as indicated in the
            &lt;SupportedMacAlgorithms&gt; element of the
            &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP).
            The MAC MUST be calculated as described in <xref
            target="Subsecton-TwoPass"></xref>.</t>

            <t>In addition, DSKPP servers MUST include the
            AuthenticationDataType element in their
            &lt;KeyProvServerFinished&gt; messages whenever a successful
            protocol run will result in an existing K_TOKEN being
            replaced.</t>
          </section>
        </section>

        <section anchor="Subsection-MAC" title="MAC Calculations">
          <section title="Key Confirmation">
            <t>In two-pass DSKPP, the client MUST include a nonce R in the
            &lt;KeyProvClientHello&gt; message. Further, the DSKPP server MUST
            include its identifier, ServerID, in the
            &lt;KeyProvServerFinished&gt; message (via the Key Container). The
            MAC value in the &lt;KeyProvServerFinished&gt; message MUST be
            computed on the (ASCII) string "MAC 1 computation", the server
            identifier ServerID, and R using a MAC key K_MAC. This key MUST be
            provided together with K_TOKEN to the cryptographic module.</t>

            <t>If DSKPP-PRF is used as the MAC algorithm, then the input
            parameter s MUST consist of the concatenation of the (ASCII)
            string "MAC 1 computation" and R, and the parameter dsLen MUST be
            set to the length of R:</t>

            <t>dsLen = len(R)</t>

            <t>MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || ServerID || R,
            dsLen)</t>
          </section>

          <section anchor="Subsecton-TwoPass-ServerAuth"
                   title="Server Authorization">
            <t>A MAC MUST be present in the &lt;KeyProvServerFinished&gt;
            message as proof that the DSKPP server is authorized to provide a
            new key to the cryptographic module. In 2-pass DSKPP, servers
            include this MAC value in the AuthenticationDataType element of
            &lt;KeyProvServerFinished&gt;. The MAC value in the
            AuthenticationDataType element MUST be computed on the (ASCII)
            string "MAC 1 computation", the server identifier ServerID, and R,
            using the existing MAC key K_MAC' (the MAC key that existed before
            this protocol run). The MAC algorithm MUST be the same as the
            algorithm used for key confirmation purposes.</t>

            <t>If DSKPP-PRF is used as the MAC algorithm, then the input
            parameter s MUST consist of the concatenation of the (ASCII)
            string "MAC 1 computation" ServerID, and R. The parameter dsLen
            MUST be set to at least 16 (i.e. the length of the MAC MUST be at
            least 16 octets):</t>

            <t>dsLen &gt;= 16</t>

            <t>MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || ServerID || R,
            dsLen)</t>
          </section>
        </section>
      </section>

      <section anchor="Section-ClientAuthN" title="User Authentication">
        <t>The DSKPP server MUST ensure that a generated key is associated
        with the correct cryptographic module, and if applicable, the correct
        user. If the user has not been authenticated by some out-of-band
        means, then the user SHOULD be authenticated within the DSKPP. For a
        further discussion of this, and threats related to man-in-the-middle
        attacks in this context, see <xref
        target="Section-Security"></xref>.</t>

        <t>When relying on DSKPP for user authentication, the DSKPP server
        SHOULD explicitly:</t>

        <t><list style="symbols">
            <t>Bind the user to the device (see <xref
            target="Subsection-DeviceID"></xref>, below)<vspace
            blankLines="1" /></t>

            <t>Rely on client-provided Authentication Data (AD) to verify that
            a legitimate user is behind the wheel (see <xref
            target="Section-AuthCode"></xref>, below)</t>
          </list></t>

        <t>NOTE: Device authentication can be handled implicitly by either
        relying on the device certificate for wrapping the key in the two-pass
        DSKPP Key Wrap Profile (see<xref target="Section-Profiles"></xref>),
        or by coupling the device certificate with the Authentication Code
        (see below).</t>

        <section anchor="Subsection-DeviceID" title="Device Identifier">
          <t>The DSKPP server MAY be pre-configured with a unique device
          identifier corresponding to a particular cryptographic module. The
          DSKPP server MAY then include this identifier in the DSKPP
          initialization trigger, in which case the DSKPP client MUST include
          it in its message(s) to the DSKPP server for authentication. Note
          that it is also legitimate for a DSKPP client to initiate the DSKPP
          protocol run without having received an initialization message from
          a server, but in this case any provided device identifier MUST NOT
          be accepted by the DSKPP server unless the server has access to a
          unique key for the identified device and that key will be used in
          the protocol.</t>
        </section>

        <section anchor="Section-AuthCode" title="Authentication Data">
          <t>As described in the message flows above (see <xref
          target="Subsection-4PassFlow"></xref> and <xref
          target="Subsection-2PassFlow"></xref>), the DSKPP client MAY include
          Authentication Data (AD) in its request(s). Note that AD MAY be
          omitted if client certificate authentication has been provided by
          the transport channel such as TLS. Nonetheless, when AD is provided,
          the DSKPP server MUST verify the data before continuing with the
          protocol run. The DSKPP client generates AD through derivation of an
          Authentication Code (AC) as follows (see <xref
          target="Subsection-ADMAC"></xref> for details):</t>

          <t>AD = HMAC(AC, K)</t>

          <t>AC is a one-time use value that is a special form of a shared
          secret between a user and the DSKPP server. This secret MUST be made
          available to the client before or during DSKPP initiation. Two ways
          in which this MAY be done are:</t>

          <t><list hangIndent="" style="format %c.">
              <t>A key issuer may deliver an AC to the user or device in
              response to a key request, which the user enters into an
              application hosted on their device. For example, a user runs an
              application that is resident on their device, e.g., a mobile
              phone. The application cannot proceed without a new symmetric
              key. The user is redirected to an issuer's Web site from where
              the user requests a key. The issuer's Web application processes
              the request, and returns an AC, which then appears on the user's
              display. The user then invokes a symmetric key-based application
              hosted on the device, which asks the user to input the AC using
              a keypad. The application invokes the DSKPP client, providing it
              with the AC. <vspace blankLines="1" /></t>

              <t>The provisioning server may send a trigger message,
              &lt;KeyProvTrigger&gt;, to the DSKPP client, which and set the
              value of the trigger nonce, R_TRIGGER, to AC. When this method
              is used, a transport providing privacy and integrity MUST be
              used to deliver the DSKPP initialization trigger from the DSKPP
              server to the DSKPP client, e.g. HTTPS.<vspace
              blankLines="1" /></t>
            </list>Note that when an issuer delegates symmetric key
          provisioning to a third party provisioning service provider, both
          client authentication and issuer authentication are required by the
          provisioning server. Client authentication to the issuer MAY be
          in-band or out-of-band as described above. The issuer acts as a
          proxy for the provisioning server. The issuer authenticates to the
          provisioning service provider either using a certificate or a
          pre-established secret key.</t>

          <t>A description of the AC and how it is used to derive AD is
          contained in the sub-sections below.</t>

          <section title="Authentication Code Format">
            <t>At a minimum, the AC MUST contain the following parameters:</t>

            <t><list hangIndent="4" style="hanging">
                <t hangText="identifier:">A globally unique identifier that
                represents the user&rsquo;s key request. The MAY be generated
                as a sequence number.<vspace blankLines="1" /></t>

                <t hangText="password:">A unique value that SHOULD be
                generated by the system as a random number to make AC more
                difficult to guess.<vspace blankLines="1" /></t>

                <t hangText="checksum:">The checksum SHOULD be calculated from
                the remaining digits in the AC.</t>
              </list></t>

            <t>The Issuer MUST rely on a Tag-Length-Value (TLV) format to
            represent the AC, such as:<vspace blankLines="1" /><list>
                <t>Tag = 0x01 = password</t>

                <t>Tag = 0x02 = identifier</t>

                <t>Tag = 0x03 = checksum<vspace blankLines="1" /></t>
              </list>where one (or two) byte(s) MAY be used to indicate the
            L(ength) of the V(alue) field.</t>
          </section>

          <section anchor="Subsection-ADMAC" title="MAC Calculation">
            <t>The Authentication Data is a MAC that is derived from AC as
            follows (refer to <xref target="DSKPP-PRF"></xref> for a
            description of DSKPP-PRF in general and <xref
            target="Section-PRFRealizations"></xref> for a description of
            DSKPP-PRF-AES):</t>

            <t>MAC = DSKPP-PRF-AES(K_AC, AC-&gt;Identifier||URL_S||R_C||[R_S],
            16)</t>

            <t>In four-pass DSKPP, the cryptographic module uses R_C, R_S, and
            URL_S, to calculate the MAC. In two-pass DSKPP, the cryptographic
            module does not have access to R_S, therefore only R_C is used in
            combination with URL_S to produce the MAC. In either case, K_AC
            MAY be derived from AC&gt;password as follows <xref
            target="PKCS-5"></xref>:</t>

            <t>K_AC = PBKDF2(AC-&gt;password, R_C || [K], c, 16)</t>

            <t>K MAY be one of the following:<vspace blankLines="1" /><list>
                <t>K_CLIENT: The device public key when a device certificate
                is available and used for key transport in 2-pass<vspace
                blankLines="1" /></t>

                <t>K_SHARED: The shared key between the client and the server
                when it is used for key wrap in two-pass or for R_C protection
                in four-pass<vspace blankLines="1" /></t>

                <t>K_DERIVED: When a passphrase-derived key is used for key
                wrap in two-pass DSKPP.<vspace blankLines="1" /></t>
              </list>Finally, c is iteration count between 10 and 1000.</t>
          </section>
        </section>
      </section>

      <section anchor="DSKPP-PRF"
               title="The DSKPP One-Way Pseudorandom Function, DSKPP-PRF">
        <section title="Introduction">
          <t>All of the protocol variations depend on DSKPP-PRF. The general
          requirements on DSKPP-PRF are the same as on keyed hash functions:
          It MUST take an arbitrary length input, and be one-way and
          collision-free (for a definition of these terms, see, e.g., <xref
          target="FAQ"></xref>). Further, the DSKPP-PRF function MUST be
          capable of generating a variable-length output, and its output MUST
          be unpredictable even if other outputs for the same key are
          known.</t>

          <t>It is assumed that any realization of DSKPP-PRF takes three input
          parameters: A secret key k, some combination of variable data, and
          the desired length of the output. The combination of variable data
          can, without loss of generalization, be considered as a salt value
          (see PKCS#5 Version 2.0 <xref target="PKCS-5"></xref>, Section 4),
          and this characterization of DSKPP-PRF SHOULD fit all actual PRF
          algorithms implemented by cryptographic modules. From the point of
          view of this specification, DSKPP-PRF is a "black-box" function
          that, given the inputs, generates a pseudorandom value.</t>

          <t>Separate specifications MAY define the implementation of
          DSKPP-PRF for various types of cryptographic modules. <xref
          target="Section-PRFRealizations"></xref> contains two example
          realizations of DSKPP-PRF.</t>
        </section>

        <section title="Declaration">
          <t>DSKPP-PRF (k, s, dsLen)</t>

          <t>Input:</t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="k">secret key in octet string format</t>

              <t hangText="s">octet string of varying length consisting of
              variable data distinguishing the particular string being
              derived</t>

              <t hangText="dsLen">desired length of the output</t>
            </list></t>

          <t>Output:</t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="DS">pseudorandom string, dsLen-octets long</t>
            </list>For the purposes of this document, the secret key k MUST be
          at least 16 octets long.</t>
        </section>
      </section>

      <section anchor="Subsection-Enc"
               title="Encryption of Pseudorandom Nonces Sent from the DSKPP Client">
        <t>DSKPP client random nonce(s) are either encrypted with the public
        key provided by the DSKPP server or by a shared secret key. For
        example, in the case of a public RSA key, an RSA encryption scheme
        from PKCS #1 <xref target="PKCS-1"></xref> MAY be used.</t>

        <t>In the case of a shared secret key, to avoid dependence on other
        algorithms, the DSKPP client MAY use the DSKPP-PRF function described
        herein with the shared secret key K_SHARED as input parameter K (in
        this case, K_SHARED SHOULD be used solely for this purpose), the
        concatenation of the (ASCII) string "Encryption" and the server's
        nonce R_S as input parameter s, and dsLen set to the length of
        R_C:</t>

        <t>dsLen = len(R_C)</t>

        <t>DS = DSKPP-PRF(K_SHARED, "Encryption" || R_S, dsLen)</t>

        <t>This will produce a pseudorandom string DS of length equal to R_C.
        Encryption of R_C MAY then be achieved by XOR-ing DS with R_C:</t>

        <t>E(DS, R_C) = DS ^ R_C</t>

        <t>The DSKPP server will then perform the reverse operation to extract
        R_C from E(DS, R_C).</t>
      </section>
    </section>

    <section title="DSKPP Message Formats">
      <t>The message formats from the DSKPP XML schema, found in <xref
      target="Section-Schema"></xref>, are explained in this section. Examples
      can be found in <xref target="Section-Examples"></xref>. The XML format
      for DSKPP messages have been designed to be extensible. However, it is
      possible that the use of extensions will harm interoperability;
      therefore, any use of extensions SHOULD be carefully considered. For
      example, if a particular implementation relies on the presence of a
      proprietary extension, then it may not be able to interoperate with
      independent implementations that have no knowledge of this
      extension.</t>

      <section title="General XML Schema Requirements">
        <t>Some DSKPP elements rely on the parties being able to compare
        received values with stored values. Unless otherwise noted, all
        elements in this document that have the XML Schema "xs:string" type,
        or a type derived from it, MUST be compared using an exact binary
        comparison. In particular, DSKPP implementations MUST NOT depend on
        case-insensitive string comparisons, normalization or trimming of
        white space, or conversion of locale-specific formats such as
        numbers.</t>

        <t>Implementations that compare values that are represented using
        different character encodings MUST use a comparison method that
        returns the same result as converting both values to the Unicode
        character encoding, Normalization Form C <xref
        target="UNICODE"></xref>, and then performing an exact binary
        comparison.</t>

        <t>No collation or sorting order for attributes or element values is
        defined. Therefore, DSKPP implementations MUST NOT depend on specific
        sorting orders for values.</t>
      </section>

      <section anchor="Section-Trigger"
               title="Components of the &lt;KeyProvTrigger&gt; Message">
        <t>The DSKPP server MAY initialize the DSKPP protocol by sending a
        &lt;KeyProvTrigger&gt; message. This message MAY, e.g., be sent in
        response to a user requesting key initialization in a browsing
        session.</t>

        <figure>
          <preamble></preamble>

          <artwork><![CDATA[<xs:element name="KeyProvTrigger" type="dskpp:KeyProvTriggerType">
</xs:element>
<xs:complexType name="KeyProvTriggerType">
  <xs:sequence>
    <xs:choice>
      <xs:element name="InitializationTrigger" 
        type="dskpp:InitializationTriggerType" />
      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>
  </xs:sequence>
  <xs:attribute name="Version" type="dskpp:VersionType" />
</xs:complexType>

<xs:complexType name="InitializationTriggerType">
  <xs:sequence>
    <xs:element minOccurs="0" name="DeviceIdentifierData" 
      type="dskpp:DeviceIdentifierDataType" />
    <xs:element minOccurs="0" name="KeyID" type="xs:base64Binary" />
    <xs:element minOccurs="0" name="TokenPlatformInfo" 
      type="dskpp:TokenPlatformInfoType" />
    <xs:element name="TriggerNonce" type="dskpp:NonceType" />
    <xs:element minOccurs="0" name="ServerUrl" type="xs:anyURI" />
    <xs:any minOccurs="0" namespace="##other" 
      processContents="strict" />
  </xs:sequence>
</xs:complexType>
]]></artwork>

          <postamble></postamble>
        </figure>

        <t>The &lt;KeyProvTrigger&gt; element is intended for the DSKPP client
        and MAY inform the DSKPP client about the identifier for the device
        that houses the cryptographic module to be initialized, and optionally
        of the identifier for the key on that module. The latter would apply
        to key renewal. The trigger always contains a nonce to allow the DSKPP
        server to couple the trigger with a later DSKPP
        &lt;KeyProvClientHello&gt; request. Finally, the trigger MAY contain a
        URL to use when contacting the DSKPP server. The &lt;xs:any&gt;
        elements are for future extensibility. Any provided
        &lt;DeviceIdentifierData&gt; or &lt;KeyID&gt; values MUST be used by
        the DSKPP client in the subsequent &lt;KeyProvClientHello&gt; request.
        The OPTIONAL &lt;TokenPlatformInfo&gt; element informs the DSKPP
        client about the characteristics of the intended cryptographic module
        platform, and applies in the public-key variant of DSKPP in situations
        when the client potentially needs to decide which one of several
        modules to initialize.</t>
      </section>

      <section title="Components of the &lt;KeyProvClientHello&gt; Request">
        <t>This message is the initial message sent from the DSKPP client to
        the DSKPP server in both variants of the DSKPP.</t>

        <figure>
          <preamble></preamble>

          <artwork><![CDATA[<xs:element name="KeyProvClientHello" 
  type="dskpp:KeyProvClientHelloPDU">
</xs:element>

<xs:complexType name="KeyProvClientHelloPDU">
  <xs:complexContent mixed="false">
    <xs:extension base="dskpp:AbstractRequestType">
      <xs:sequence>
        <xs:element minOccurs="0" name="DeviceIdentifierData" 
          type="dskpp:DeviceIdentifierDataType" />
        <xs:element minOccurs="0" name="KeyID" 
          type="xs:base64Binary" />
        <xs:element minOccurs="0" name="ClientNonce" 
          type="dskpp:NonceType" />
        <xs:element minOccurs="0" name="TriggerNonce" 
          type="dskpp:NonceType" />
        <xs:element name="SupportedKeyTypes" 
          type="dskpp:AlgorithmsType" />
        <xs:element name="SupportedEncryptionAlgorithms" 
          type="dskpp:AlgorithmsType" />
        <xs:element name="SupportedMacAlgorithms" 
          type="dskpp:AlgorithmsType" />
        <xs:element minOccurs="0" name="SupportedProtocolVariants" 
          type="dskpp:ProtocolVariantsType" />
        <xs:element minOccurs="0" name="SupportedKeyContainers" 
          type="dskpp:KeyContainersFormatType" />
        <xs:element minOccurs="0" name="AuthenticationData" 
          type="dskpp:AuthenticationDataType" />
        <xs:element minOccurs="0" name="Extensions" 
          type="dskpp:ExtensionsType" />
      </xs:sequence>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>
]]></artwork>

          <postamble></postamble>
        </figure>

        <t>The components of this message have the following meaning:</t>

        <t><list style="symbols">
            <t>Version: (attribute inherited from the AbstractRequestType
            type) The highest version of this protocol the client supports.
            Only version one ("1.0") is currently specified.</t>

            <t>&lt;DeviceIdentifierData&gt;: An identifier for the
            cryptographic module as defined in <xref
            target="Section-ClientAuthN"></xref> above. The identifier MUST
            only be present if such shared secrets exist or if the identifier
            was provided by the server in a &lt;KeyProvTrigger&gt; element
            (see <xref target="Section-InitDSKPP"></xref>). In the latter
            case, it MUST have the same value as the identifier provided in
            that element.</t>

            <t>&lt;KeyID&gt;: An identifier for the key that will be
            overwritten if the protocol run is successful. The identifier MUST
            only be present if the key exists or if the identifier was
            provided by the server in a &lt;KeyProvTrigger&gt; element, in
            which case, it MUST have the same value as the identifier provided
            in that element (see <xref target="Section-Trigger">a</xref> and
            <xref target="Section-InitDSKPP"></xref>).</t>

            <t>&lt;ClientNonce&gt;: This is the nonce R, which, when present,
            MUST be used by the server when calculating MAC values (see
            below). It is RECOMMENDED that clients include this element
            whenever the &lt;KeyID&gt; element is present.</t>

            <t>&lt;TriggerNonce&gt;: This OPTIONAL element MUST be present if
            and only if the DSKPP run was initialized with a
            &lt;KeyProvTrigger&gt; message (see <xref
            target="Section-InitDSKPP"></xref>), and MUST, in that case, have
            the same value as the &lt;TriggerNonce&gt; child of that message.
            A server using nonces in this way MUST verify that the nonce is
            valid and that any device or key identifier values provided in the
            &lt;KeyProvTrigger&gt; message match the corresponding identifier
            values in the &lt;KeyProvClientHello&gt; message.</t>

            <t>&lt;SupportedKeyTypes&gt;: A sequence of URLs indicating the
            key types for which the cryptographic module is willing to
            generate keys through DSKPP.</t>

            <t>&lt;SupportedEncryptionAlgorithms&gt;: A sequence of URLs
            indicating the encryption algorithms supported by the
            cryptographic module for the purposes of DSKPP. The DSKPP client
            MAY indicate the same algorithm both as a supported key type and
            as an encryption algorithm.</t>

            <t>&lt;SupportedMacAlgorithms&gt;: A sequence of URLs indicating
            the MAC algorithms supported by the cryptographic module for the
            purposes of DSKPP. The DSKPP client MAY indicate the same
            algorithm both as an encryption algorithm and as a MAC algorithm
            (e.g., http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes, which is
            defined in <xref target="Section-PRFRealizations"></xref>).</t>

            <t>&lt;SupportedProtocolVariants&gt;: This OPTIONAL element is
            used by the DSKPP client to indicate support for four-pass or
            two-pass DSKPP. If two-pass support is specified, then
            &lt;KeyProvClientNonce&gt; MUST be set to nonce R in the
            &lt;KeyProvClientHello&gt; message unless &lt;TriggerNonce&gt; is
            already present.</t>

            <t>&lt;SupportedKeyContainers&gt;: This OPTIONAL element is a
            sequence of URLs indicating the key container formats supported by
            the DSKPP client. If this element is not provided, then the DSKPP
            server MUST proceed with
            "http://www.ietf.org/keyprov/pskc#KeyContainer" (see <xref
            target="PSKC"></xref>).</t>

            <t>&lt;AuthenticationData&gt;: This OPTIONAL element contains data
            that the DSKPP client uses to authenticate the user or device to
            the DSKPP server. The element is set as specified in <xref
            target="Section-ClientAuthN"></xref>.</t>

            <t>&lt;Extensions&gt;: A sequence of extensions. One extension is
            defined for this mesolsage in this version of DSKPP: the
            ClientInfoType (see <xref
            target="Section-ProtocolExts"></xref>).</t>
          </list></t>

        <t>Some of the core elements of the message are described below.</t>

        <section title="The DeviceIdentifierDataType Type">
          <t>The DeviceIdentifierDataType type is used to uniquely identify
          the device that houses the cryptographic module, e.g., a mobile
          phone. The device identifier allows the DSKPP server to find, e.g.,
          a pre-shared transport key for 2-pass DSKPP and/or the correct
          shared secret for MAC'ing purposes. The default
          DeviceIdentifierDataType is defined in <xref
          target="PSKC"></xref>.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[<xs:complexType name="DeviceIdentifierDataType">
  <xs:choice>
    <xs:element name="DeviceId" type="pskc:DeviceIdType" />
    <xs:any namespace="##other" processContents="strict" />
  </xs:choice>
</xs:complexType>
]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="The ProtocolVariantsType Type">
          <t>The ProtocolVariantsType type is OPTIONAL for a DSKPP client, who
          MAY use it to indicate the number of passes of the DSKPP protocol
          that it supports. The ProtocolVariantsType MAY be used to indicate
          support for 4-pass or 2-pass DSKPP. If the ProtocolVariantsType is
          not used, then the DSKPP server will proceed with ordinary 4-pass
          DSKPP. However, if it does not support 4-pass DSKPP, then the server
          MUST find a suitable two-pass variation or else the protocol run
          will fail.</t>

          <t>Selecting the "TwoPass" element signals client support for the
          2-pass version of DSKPP, informs the server of supported two-pass
          key protection methods, and provides OPTIONAL payload data to the
          DSKPP server. The payload is sent in an opportunistic fashion, and
          MAY be discarded by the DSKPP server if the server does not support
          thekey protection method with which the payload is associated.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[   <xs:complexType name="ProtocolVariantsType">
     <xs:sequence>
       <xs:element minOccurs="0" name="FourPass" />
       <xs:element minOccurs="0" name="TwoPass"           
         type="dskpp:KeyProtectionDataType"/>      
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="KeyProtectionDataType">      
   <xs:complexContent mixed="false">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="SupportedKeyProtectionMethod" type="xs:anyURI"/>
       <xs:element name="Payload" type="dskpp:PayloadType"
     </xs:sequence>
     </xs:complexContent>
   </xs:complexType>
]]></artwork>

            <postamble></postamble>
          </figure>

          <t>The elements of this type have the following meaning:</t>

          <t><list style="symbols">
              <t>&lt;SupportedKeyProtectionMethod&gt;: A two-pass key
              protection method supported by the DSKPP client. Multiple
              supported methods MAY be present, in which case they MUST be
              listed in order of precedence.</t>

              <t>&lt;Payload&gt;: An OPTIONAL payload associated with each
              supported key protection method.</t>
            </list></t>

          <t>A DSKPP client that indicates support for two-pass DSKPP MUST
          also include the nonce R in its &lt;KeyProvClientHello&gt; message
          (this will enable the client to verify that the DSKPP server it is
          communicating with is alive).</t>
        </section>

        <section title="The KeyContainersFormatType Type">
          <t>The OPTIONAL KeyContainersFormatType type is a list of type-value
          pairs that a DSKPP client or server MAY use to define key container
          formats it supports. Key container formats are identified through
          URLs, e.g., the PSKC KeyContainer URL
          "http://www.ietf.org/keyprov/pskc#KeyContainer" (see <xref
          target="PSKC"></xref>).</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[<xs:complexType name="KeyContainersFormatType">
  <xs:sequence maxOccurs="unbounded">
    <xs:element name="KeyContainerFormat" 
    type="dskpp:KeyContainerFormatType"/>
  </xs:sequence>

</xs:complexType>
<xs:simpleType name="KeyContainerFormatType">
  <xs:restriction base="xs:anyURI" />
</xs:simpleType>
]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section anchor="Section-AuthNData"
                 title="The AuthenticationDataType Type">
          <t>The OPTIONAL AuthenticationDataType type is used by DSKPP clients
          and server to carry authentication values in DSKPP messages. The
          element MAY contain a MAC derived from an authentication code as
          follows:</t>

          <t><list style="format %c.">
              <t>A DSKPP client MAY include a one-time use AuthenticationCode
              that was given by the issuer to the user for acquiring a
              symmetric key. An AuthenticationCode MAY contain alphanumeric
              characters in addition to numeric digits depending on the device
              type and policy of the issuer. For example, if the device is a
              mobile phone, a code that the user enters on the keypad would
              typically be restricted to numeric digits for ease of use. An
              authentication code MAY be sent to the DSKPP server as MAC data
              calculated according to section <xref
              target="Section-AuthCode"></xref>.</t>

              <t>A DSKPP server MAY use the AuthenticationDataType element
              AuthenticationCodeMac to carry a MAC for authenticating itself
              to the client. For example, when a successful 2-pass DSKPP
              protocol run will result in an existing key being replaced, then
              the DSKPP server MUST include a MAC proving to the DSKPP client
              that the server knows the value of the key it is about to
              replace.</t>
            </list></t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[<xs:complexType name="AuthenticationDataType">
  <xs:sequence>
    <xs:element minOccurs="0" name="ClientID" 
      type="dskpp:IdentifierType" />
    <xs:element name="AuthenticationCodeMac" 
      type="dskpp:AuthenticationCodeMacType" />
  </xs:sequence>
</xs:complexType>
<xs:complexType name="AuthenticationCodeMacType">
  <xs:sequence>
    <xs:element minOccurs="0" name="Nonce" type="dskpp:NonceType" />
    <xs:element minOccurs="0" name="IterationCount" type="xs:int" />
    <xs:element name="Mac" type="dskpp:MacType" />
  </xs:sequence>
</xs:complexType>
]]></artwork>

            <postamble></postamble>
          </figure>

          <t>The elements of the AuthenticationDataType type have the
          following meaning:</t>

          <t><list style="symbols">
              <t>&lt;ClientID&gt;: A requester's identifier. The value MAY be
              a user ID, a device ID, or a keyID associated with the
              requester's authentication value. Ifa &lt;KeyProvTrigger&gt;
              message was provided by the server to initiate the DSKPP
              protocol run, &lt;ClientID&gt; can be omitted, as the DeviceID,
              KeyID, and/or nonce provided in the
              &lt;InitializationTriggerType&gt; element ought to be sufficient
              to identify the requester.</t>

              <t>&lt;AuthenticationCodeMac&gt;: An authentication MAC and
              additional information (e.g., MAC algorithm). This MAC MAY be
              derived as follows:<list style="symbols">
                  <t>User Authentication: A DSKPP client MAY include a
                  one-time use AuthenticationCode that was given by the issuer
                  to the user for acquiring a symmetric key. An
                  AuthenticationCode MAY contain alphanumeric characters in
                  addition to numeric digits depending on the device type and
                  policy of the issuer. For example, if the device is a mobile
                  phone, a code that the user enters on the keypad would
                  typically be restricted to numeric digits for ease of use.
                  An authentication code MAY be sent to the DSKPP server as
                  MAC data calculated as described in section <xref
                  target="Section-AuthCode"></xref>.</t>

                  <t>Server Authorization (two-pass DSKPP only): A DSKPP
                  server MUST include a MAC in its
                  &lt;KeyProvServerFinished&gt; message as proof that the
                  DSKPP server is authorized to provide a new key to the
                  cryptographic module. For example, when a successful 2-pass
                  DSKPP protocol run will result in an existing key being
                  replaced, then the DSKPP server MUST include the
                  AuthenticationDataType element's AuthenticationCodeMac in
                  its &lt;KeyProvServerFinished&gt; message. For more
                  information, refer to <xref
                  target="Subsecton-TwoPass-ServerAuth"></xref>.</t>
                </list></t>
            </list></t>
        </section>
      </section>

      <section title="Components of the &lt;KeyProvServerHello&gt; Response (Used Only in Four-Pass DSKPP)">
        <t>In a four-pass exchange, this message is the first message sent
        from the DSKPP server to the DSKPP client (assuming a trigger message
        has not been sent to initiate the protocol, in which case, this
        message is the second message sent from the DSKPP server to the DSKPP
        client). It is sent upon reception of a &lt;KeyProvClientHello&gt;
        message.</t>

        <figure>
          <preamble></preamble>

          <artwork><![CDATA[<xs:element name="KeyProvServerHello" 
  type="dskpp:KeyProvServerHelloPDU">
</xs:element>
<xs:complexType name="KeyProvServerHelloPDU">
  <xs:complexContent mixed="false">
    <xs:extension base="dskpp:AbstractResponseType">
      <xs:sequence minOccurs="0">
        <xs:element name="KeyType" type="dskpp:AlgorithmType" />
        <xs:element name="EncryptionAlgorithm" 
          type="dskpp:AlgorithmType" />
        <xs:element name="MacAlgorithm" type="dskpp:AlgorithmType" />
        <xs:element name="EncryptionKey" type="ds:KeyInfoType" />
        <xs:element name="KeyContainerFormat" 
          type="dskpp:KeyContainerFormatType" />
        <xs:element name="Payload" type="dskpp:PayloadType" />
        <xs:element minOccurs="0" name="Extensions" 
          type="dskpp:ExtensionsType" />
        <xs:element minOccurs="0" name="Mac" type="dskpp:MacType" />
      </xs:sequence>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>
]]></artwork>

          <postamble></postamble>
        </figure>

        <t>The components of this message have the following meaning:</t>

        <t><list style="symbols">
            <t>Version: (attribute inherited from the AbstractResponseType
            type) The version selected by the DSKPP server. MAY be lower than
            the version indicated by the DSKPP client, in which case, local
            policy at the client MUST determine whether or not to continue the
            session.</t>

            <t>SessionID: (attribute inherited from the AbstractResponseType
            type) An identifier for this session.</t>

            <t>Status: (attribute inherited from the AbstractResponseType
            type) Return code for the &lt;KeyProvClientHello&gt;. If Status is
            not "Continue", only the Status and Version attributes will be
            present; otherwise, all the other element MUST be present as
            well.</t>

            <t>&lt;KeyType&gt;: The type of the key to be generated.</t>

            <t>&lt;EncryptionAlgorithm&gt;: The encryption algorithm to use
            when protecting R_C.</t>

            <t>&lt;MacAlgorithm&gt;: The MAC algorithm to be used by the DSKPP
            server.</t>

            <t>&lt;EncryptionKey&gt;: Information about the key to use when
            encrypting R_C. It will either be the server's public key (the
            &lt;ds:KeyValue&gt; alternative of ds:KeyInfoType) or an
            identifier for a shared secret key (the &lt;ds:KeyName&gt;
            alternative of ds:KeyInfoType).</t>

            <t>&lt;KeyContainerFormat&gt;: The key container format type to be
            used by the DSKPP server. The default setting relies on the
            KeyContainerType element defined in
            "urn:ietf:params:xml:schema:keyprov:container" <xref
            target="PSKC"></xref>.</t>

            <t>&lt;Payload&gt;: The actual payload. For this version of the
            protocol, only one payload is defined: the pseudorandom string
            R_S.</t>

            <t>&lt;Extensions&gt;: A list of server extensions. Two extensions
            are defined for this message in this version of DSKPP: the
            ClientInfoType and the ServerInfoType (see <xref
            target="Section-ProtocolExts"></xref>).</t>

            <t>&lt;Mac&gt;: The MAC MUST be present if the DSKPP run will
            result in the replacement of an existing symmetric key with a new
            one (i.e., if the &lt;KeyID&gt; element was present in the
            &lt;ClientHello message). In this case, the DSKPP server MUST
            prove to the cryptographic module that it is authorized to replace
            it.</t>
          </list></t>
      </section>

      <section title="Components of a &lt;KeyProvClientNonce&gt; Request (Used Only in Four-Pass DSKPP)">
        <t>In a four-pass DSKPP exchange, this message contains the nonce R_C
        that was chosen by the cryptographic module, and encrypted by the
        negotiated encryption key and encryption algorith</t>

        <figure>
          <preamble></preamble>

          <artwork><![CDATA[<xs:element name="KeyProvClientNonce" 
  type="dskpp:KeyProvClientNoncePDU">
</xs:element>
<xs:complexType name="KeyProvClientNoncePDU">
  <xs:complexContent mixed="false">
    <xs:extension base="dskpp:AbstractRequestType">
      <xs:sequence>
        <xs:element name="EncryptedNonce" type="xs:base64Binary" />
        <xs:element minOccurs="0" name="AuthenticationData" 
          type="dskpp:AuthenticationDataType" />
        <xs:element minOccurs="0" name="Extensions" 
          type="dskpp:ExtensionsType" />
      </xs:sequence>
      <xs:attribute name="SessionID" type="dskpp:IdentifierType" 
        use="required" />
    </xs:extension>
  </xs:complexContent>
</xs:complexType>
]]></artwork>

          <postamble></postamble>
        </figure>

        <t>The components of this message have the following meaning:</t>

        <t><list style="symbols">
            <t>Version: (inherited from the AbstractRequestType type) MUST be
            the same version as in the &lt;KeyProvServerHello&gt; message.</t>

            <t>&lt;SessionID&gt;: (attribute inherited from the
            AbstractResponseType type) MUST have the same value as the
            SessionID attribute in the received &lt;KeyProvServerHello&gt;
            message.</t>

            <t>&lt;EncryptedNonce&gt;: The nonce generated and encrypted by
            the cryptographic module. The encryption MUST be made using the
            selected encryption algorithm and identified key, and as specified
            in <xref target="DSKPP-PRF"></xref>.</t>

            <t>&lt;AuthenticationData&gt;: The authentication data value MUST
            be set as specified in <xref target="Section-ClientAuthN"></xref>
            and <xref target="Section-AuthNData"></xref>.</t>

            <t>&lt;Extensions&gt;: A list of extensions. Two extensions are
            defined for this message in this version of DSKPP: the
            ClientInfoType and the ServerInfoType (see <xref
            target="Section-ProtocolExts"></xref>)</t>
          </list></t>
      </section>

      <section title="Components of a &lt;KeyProvServerFinished&gt; Response">
        <t>This message is the last message of the DSKPP protocol run. In a
        4-pass exchange, the DSKPP server sends this message in response to a
        &lt;KeyProvClientNonce&gt; message, whereas in a 2-pass exchange, the
        DSKPP server sends this message in response to a
        &lt;KeyProvClientHello&gt; message.</t>

        <figure>
          <preamble></preamble>

          <artwork><![CDATA[<xs:element name="KeyProvServerFinished" 
  type="dskpp:KeyProvServerFinishedPDU">
</xs:element>
<xs:complexType name="KeyProvServerFinishedPDU">
  <xs:complexContent mixed="false">
    <xs:extension base="dskpp:AbstractResponseType">
      <xs:sequence minOccurs="0">
        <xs:element name="KeyContainer" 
          type="dskpp:KeyContainerType" />
        <xs:element minOccurs="0" name="Extensions" 
          type="dskpp:ExtensionsType" />
        <xs:element name="Mac" type="dskpp:MacType" />
        <xs:element minOccurs="0" name="AuthenticationData" 
          type="dskpp:AuthenticationDataType" />
      </xs:sequence>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>
]]></artwork>

          <postamble></postamble>
        </figure>

        <t>The components of this message have the following meaning:</t>

        <t><list style="symbols">
            <t>Version: (inherited from the AbstractResponseType type) The
            DSKPP version used in this session.</t>

            <t>SessionID: (inherited from the AbstractResponseType type) The
            previously established identifier for this session.</t>

            <t>Status: (inherited from the AbstractResponseType type) Return
            code for the &lt;KeyProvServerFinished&gt; message. If Status is
            not "Success", only the Status, SessionID, and Version attributes
            will be present (the presence of the SessionID attribute is
            dependent on the type of reported error); otherwise, all the other
            elements MUST be present as well. In this latter case, the
            &lt;KeyProvServerFinished&gt; message can be seen as a "Commit"
            message, instructing the cryptographic module to store the
            generated key and associate the given key identifier with this
            key.</t>

            <t>&lt;KeyContainer&gt;: The key container containing symmetric
            key values (in the case of a 2-pass exchange) and configuration
            data. The default container format is based on the
            KeyContainerType type from PSKC, as defined in <xref
            target="PSKC"></xref>.</t>

            <t>&lt;Extensions&gt;: A list of extensions chosen by the DSKPP
            server. For this message, this version of DSKPP defines one
            extension, the ClientInfoType (see <xref
            target="Section-ProtocolExts"></xref>).</t>

            <t>&lt;Mac&gt;: To avoid a false "Commit" message causing the
            cryptographic module to end up in an initialized state for which
            the server does not know the stored key,
            &lt;KeyProvServerFinished&gt; messages MUST always be
            authenticated with a MAC. The MAC MUST be made using the already
            established MAC algorithm.</t>
          </list></t>
      </section>

      <section title="The StatusCode Type">
        <t>The StatusCode type enumerates all possible return codes:</t>

        <figure>
          <preamble></preamble>

          <artwork><![CDATA[ <xs:simpleType name="StatusCode">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Continue" />
      <xs:enumeration value="Success" />
      <xs:enumeration value="Abort" />
      <xs:enumeration value="AccessDenied" />
      <xs:enumeration value="MalformedRequest" />
      <xs:enumeration value="UnknownRequest" />
      <xs:enumeration value="UnknownCriticalExtension" />
      <xs:enumeration value="UnsupportedVersion" />
      <xs:enumeration value="NoSupportedKeyTypes" />
      <xs:enumeration value="NoSupportedEncryptionAlgorithms" />
      <xs:enumeration value="NoSupportedMacAlgorithms" />
      <xs:enumeration value="NoProtocolVariants" />
      <xs:enumeration value="NoSupportedKeyContainers" />
      <xs:enumeration value="AuthenticationDataMissing" />
      <xs:enumeration value="AuthenticationDataInvalid" />
      <xs:enumeration value="InitializationFailed" />
    </xs:restriction>
  </xs:simpleType>
]]></artwork>

          <postamble></postamble>
        </figure>

        <t>Upon transmission or receipt of a message for which the Status
        attribute's value is not "Success" or "Continue", the default
        behavior, unless explicitly stated otherwise below, is that both the
        DSKPP server and the DSKPP client MUST immediately terminate the DSKPP
        session. DSKPP servers and DSKPP clients MUST delete any secret values
        generated as a result of failed runs of the DSKPP protocol. Session
        identifiers MAY be retained from successful or failed protocol runs
        for replay detection purposes, but such retained identifiers MUST NOT
        be reused for subsequent runs of the protocol.</t>

        <t>When possible, the DSKPP client SHOULD present an appropriate error
        message to the user.</t>

        <t>These status codes are valid in all DSKPP Response messages unless
        explicitly stated otherwise:</t>

        <t><list style="symbols">
            <t>"Continue" indicates that the DSKPP server is ready for a
            subsequent request from the DSKPP client. It cannot be sent in the
            server's final message.</t>

            <t>"Success" indicates successful completion of the DSKPP session.
            It can only be sent in the server's final message.</t>

            <t>"Abort" indicates that the DSKPP server rejected the DSKPP
            client's request for unspecified reasons.</t>

            <t>"AccessDenied" indicates that the DSKPP client is not
            authorized to contact this DSKPP server.</t>

            <t>"MalformedRequest" indicates that the DSKPP server failed to
            parse the DSKPP client's request.</t>

            <t>"UnknownRequest" indicates that the DSKPP client made a request
            that is unknown to the DSKPP server.</t>

            <t>"UnknownCriticalExtension" indicates that a critical DSKPP
            extension (see below) used by the DSKPP client was not supported
            or recognized by the DSKPP server.</t>

            <t>"UnsupportedVersion" indicates that the DSKPP client used a
            DSKPP protocol version not supported by the DSKPP server. This
            error is only valid in the DSKPP server's first response
            message.</t>

            <t>"NoSupportedKeyTypes" indicates that the DSKPP client only
            suggested key types that are not supported by the DSKPP server.
            This error is only valid in the DSKPP server's first response
            message.</t>

            <t>"NoSupportedEncryptionAlgorithms" indicates that the DSKPP
            client only suggested encryption algorithms that are not supported
            by the DSKPP server. This error is only valid in the DSKPP
            server's first response message.</t>

            <t>"NoSupportedMacAlgorithms" indicates that the DSKPP client only
            suggested MAC algorithms that are not supported by the DSKPP
            server. This error is only valid in the DSKPP server's first
            response message.</t>

            <t>"NoProtocolVariants" indicates that the DSKPP client only
            suggested a protocol variation (either 2-pass or 4-pass) that is
            not supported by the DSKPP server. This error is only valid in the
            DSKPP server's first response message.</t>

            <t>"NoSupportedKeyContainers" indicates that the DSKPP client only
            suggested key container formats that are not supported by the
            DSKPP server. This error is only valid in the DSKPP server's first
            response message.</t>

            <t>"AuthenticationDataMissing" indicates that the DSKPP client
            didn't provide authentication data that the DSKPP server
            required.</t>

            <t>"AuthenticationDataInvalid" indicates that the DSKPP client
            supplied user authentication data that the DSKPP server failed to
            validate.</t>

            <t>"InitializationFailed" indicates that the DSKPP server could
            not generate a valid key given the provided data. When this status
            code is received, the DSKPP client SHOULD try to restart DSKPP, as
            it is possible that a new run will succeed.</t>

            <t>"ProvisioningPeriodExpired" indicates that the provisioning
            period set by the DSKPP server has expired. When the status code
            is received, the DSKPP client SHOULD report the reason for key
            initialization failure to the user and the user MUST register with
            the DSKPP server to initialize a new key.</t>
          </list></t>
      </section>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-ProtocolExts" title="Extensibility">
      <section title="The ClientInfoType Type">
        <t>Present in a &lt;KeyProvClientHello&gt; or a
        &lt;KeyProvClientNonce&gt; message, the OPTIONAL ClientInfoType
        extension contains DSKPP client-specific information. DSKPP servers
        MUST support this extension. DSKPP servers MUST NOT attempt to
        interpret the data it carries and, if received, MUST include it
        unmodified in the current protocol run's next server response. Servers
        need not retain the ClientInfoType's data after that response has been
        generated.</t>
      </section>

      <section title="The ServerInfoType Type">
        <t>When present, the OPTIONAL ServerInfoType extension contains DSKPP
        server-specific information. This extension is only valid in
        &lt;KeyProvServerHello&gt; messages for which Status = "Continue".
        DSKPP clients MUST support this extension. DSKPP clients MUST NOT
        attempt to interpret the data it carries and, if received, MUST
        include it unmodified in the current protocol run's next client
        request (i.e., the &lt;KeyProvClientNonce&gt; message). DSKPP clients
        need not retain the ServerInfoType's data after that request has been
        generated. This extension MAY be used, e.g., for state management in
        the DSKPP server.</t>
      </section>
    </section>

    <section anchor="Section-Bindings" title="Protocol Bindings">
      <section title="General Requirements">
        <t>DSKPP assumes a reliable transport.</t>
      </section>

      <section title="HTTP/1.1 Binding for DSKPP">
        <section title="Introduction">
          <t>This section presents a binding of the previous messages to
          HTTP/1.1 <xref target="RFC2616"></xref>. Note that the HTTP client
          normally will be different from the DSKPP client, i.e., the HTTP
          client will only exist to "proxy" DSKPP messages from the DSKPP
          client to the DSKPP server. Likewise, on the HTTP server side, the
          DSKPP server MAY receive DSKPP PDUs from a "front-end" HTTP
          server.</t>
        </section>

        <section anchor="Subsection-ContentType"
                 title="Identification of DSKPP Messages">
          <t>The MIME-type for all DSKPP messages MUST be</t>

          <t>application/vnd.ietf.keyprov.dskpp+xml</t>
        </section>

        <section title="HTTP Headers">
          <t>HTTP proxies MUST NOT cache responses carrying DSKPP messages.
          For this reason, the following holds:<list style="symbols">
              <t>When using HTTP/1.1, requesters SHOULD:<list>
                  <t>Include a Cache-Control header field set to "no-cache,
                  no-store".</t>

                  <t>Include a Pragma header field set to "no-cache".</t>
                </list></t>

              <t>When using HTTP/1.1, responders SHOULD:<list>
                  <t>Include a Cache-Control header field set to "no-cache,
                  no-must-revalidate, private".</t>

                  <t>Include a Pragma header field set to "no-cache".</t>

                  <t>NOT include a Validator, such as a Last-Modified or ETag
                  header.</t>
                </list></t>
            </list>There are no other restrictions on HTTP headers, besides
          the requirement to set the Content-Type header value according to
          <xref target="Subsection-ContentType"></xref>.</t>
        </section>

        <section title="HTTP Operations">
          <t>Persistent connections as defined in HTTP/1.1 are assumed but not
          required. DSKPP requests are mapped to HTTP POST operations. DSKPP
          responses are mapped to HTTP responses.</t>
        </section>

        <section title="HTTP Status Codes">
          <t>A DSKPP HTTP responder that refuses to perform a message exchange
          with a DSKPP HTTP requester SHOULD return a 403 (Forbidden)
          response. In this case, the content of the HTTP body is not
          significant. In the case of an HTTP error while processing a DSKPP
          request, the HTTP server MUST return a 500 (Internal Server Error)
          response. This type of error SHOULD be returned for HTTP-related
          errors detected before control is passed to the DSKPP processor, or
          when the DSKPP processor reports an internal error (for example, the
          DSKPP XML namespace is incorrect, or the DSKPP schema cannot be
          located). If the type of a DSKPP request cannot be determined, the
          DSKPP responder MUST return a 400 (Bad request) response.</t>

          <t>In these cases (i.e., when the HTTP response code is 4xx or 5xx),
          the content of the HTTP body is not significant.</t>

          <t>Redirection status codes (3xx) apply as usual.</t>

          <t>Whenever the HTTP POST is successfully invoked, the DSKPP HTTP
          responder MUST use the 200 status code and provide a suitable DSKPP
          message (possibly with DSKPP error information included) in the HTTP
          body.</t>
        </section>

        <section title="HTTP Authentication">
          <t>No support for HTTP/1.1 authentication is assumed.</t>
        </section>

        <section anchor="Section-InitDSKPP" title="Initialization of DSKPP">
          <t>The DSKPP server MAY initialize the DSKPP protocol by sending an
          HTTP response with Content-Type set according to <xref
          target="Subsection-ContentType"></xref> and response code set to 200
          (OK). This message MAY, e.g., be sent in response to a user
          requesting key initialization in a browsing session. The
          initialization message MAY carry data in its body. If this is the
          case, the data MUST be a valid instance of a &lt;KeyProvTrigger&gt;
          element.</t>
        </section>

        <section title="Example Messages">
          <t hangText=""><list counter="Examples" hangIndent="0"
              style="format %c.">
              <t>Initialization from DSKPP server:</t>
            </list><list hangIndent="4" style="empty">
              <t hangText="">HTTP/1.1 200 OK<vspace
              blankLines="1" />Cache-Control: no-store<vspace
              blankLines="0" />Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<vspace
              blankLines="0" />Content-Length: &lt;some value&gt;<vspace
              blankLines="1" />DSKPP initialization data in XML form...</t>
            </list></t>

          <t><list counter="Examples" hangIndent="0" style="format %c.">
              <t>Initial request from DSKPP client:</t>
            </list><list hangIndent="4" style="empty">
              <t>POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1<vspace
              blankLines="0" />Cache-Control: no-store<vspace
              blankLines="0" />Pragma: no-cache<vspace blankLines="0" />Host:
              example.com<vspace blankLines="0" />Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<vspace
              blankLines="0" />Content-Length: &lt;some value&gt;<vspace
              blankLines="1" />DSKPP data in XML form (supported version,
              supported algorithms...)</t>
            </list></t>

          <t hangText=""><list counter="Examples" hangIndent="0"
              style="format %c.">
              <t>Initial response from DSKPP server:</t>
            </list><list hangIndent="4" style="empty">
              <t hangText="">HTTP/1.1 200 OK<vspace
              blankLines="1" />Cache-Control: no-store<vspace
              blankLines="0" />Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<vspace
              blankLines="0" />Content-Length: &lt;some value&gt;<vspace
              blankLines="1" />DSKPP data in XML form (server random nonce,
              server public key, ...)</t>
            </list></t>
        </section>
      </section>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-Schema" title="DSKPP Schema">
      <figure>
        <artwork><![CDATA[
<?xml version="1.0" encoding="utf-8"?>
<xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0" 
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0" 
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
  elementFormDefault="qualified" attributeFormDefault="unqualified"
  targetNamespace="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  version="1.0">

  <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
    schemaLocation="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/
    xmldsig-core-schema.xsd"/>

  <xs:import namespace="urn:ietf:params:xml:ns:keyprov:container:1.0" 
    schemaLocation="keyprov-pskc-1.0.xsd"/>

  <xs:complexType name="AbstractRequestType" abstract="true">
    <xs:annotation>
      <xs:documentation> Basic types </xs:documentation>
    </xs:annotation>
    <xs:attribute name="Version" type="dskpp:VersionType" 
      use="required"/>
  </xs:complexType>

  <xs:complexType name="AbstractResponseType" abstract="true">
    <xs:annotation>
      <xs:documentation> Basic types </xs:documentation>
    </xs:annotation>
    <xs:attribute name="Version" type="dskpp:VersionType" 
      use="required"/>
    <xs:attribute name="SessionID" type="dskpp:IdentifierType" />
    <xs:attribute name="Status" type="dskpp:StatusCode" use="required"/>
  </xs:complexType>

  <xs:simpleType name="VersionType">
    <xs:restriction base="xs:string">
      <xs:pattern value="\d{1,2}\.\d{1,3}" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="IdentifierType">
    <xs:restriction base="xs:string">
      <xs:maxLength value="128" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="StatusCode">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Continue" />
      <xs:enumeration value="Success" />
      <xs:enumeration value="Abort" />
      <xs:enumeration value="AccessDenied" />
      <xs:enumeration value="MalformedRequest" />
      <xs:enumeration value="UnknownRequest" />
      <xs:enumeration value="UnknownCriticalExtension" />
      <xs:enumeration value="UnsupportedVersion" />
      <xs:enumeration value="NoSupportedKeyTypes" />
      <xs:enumeration value="NoSupportedEncryptionAlgorithms" />
      <xs:enumeration value="NoSupportedMacAlgorithms" />
      <xs:enumeration value="NoProtocolVariants" />
      <xs:enumeration value="NoSupportedKeyContainers" />
      <xs:enumeration value="AuthenticationDataMissing" />
      <xs:enumeration value="AuthenticationDataInvalid" />
      <xs:enumeration value="InitializationFailed" />
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="DeviceIdentifierDataType">
    <xs:choice>
      <xs:element name="DeviceId" type="pskc:DeviceIdType" />
      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>
  </xs:complexType>

  <xs:simpleType name="PlatformType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Hardware" />
      <xs:enumeration value="Software" />
      <xs:enumeration value="Unspecified" />
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="TokenPlatformInfoType">
    <xs:attribute name="KeyLocation" type="dskpp:PlatformType"/>
    <xs:attribute name="AlgorithmLocation" type="dskpp:PlatformType"/>
  </xs:complexType>

  <xs:simpleType name="NonceType">
    <xs:restriction base="xs:base64Binary">
      <xs:minLength value="16" />
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="AlgorithmsType">
    <xs:sequence maxOccurs="unbounded">
      <xs:element name="Algorithm" type="dskpp:AlgorithmType" />
    </xs:sequence>
  </xs:complexType>

  <xs:simpleType name="AlgorithmType">
    <xs:restriction base="xs:anyURI" />
  </xs:simpleType>

  <xs:complexType name="ProtocolVariantsType">
    <xs:sequence>
      <xs:element minOccurs="0" name="FourPass" />
      <xs:element minOccurs="0" name="TwoPass" 
        type="dskpp:KeyProtectionDataType"/>      
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="KeyProtectionDataType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
         This element is only valid for two-pass DSKPP.
       </xs:documentation>
    </xs:annotation>
    <xs:complexContent mixed="false">
        <xs:sequence maxOccurs="unbounded">
          <xs:element name="SupportedKeyProtectionMethod" type="xs:anyURI"/>
          <xs:element name="Payload" type="dskpp:PayloadType" />
        </xs:sequence>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="PayloadType">
    <xs:choice>
      <xs:element name="Nonce" type="dskpp:NonceType" />
      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="KeyContainersFormatType">
    <xs:sequence maxOccurs="unbounded">
      <xs:element name="KeyContainerFormat" 
      type="dskpp:KeyContainerFormatType"/>
    </xs:sequence>
  </xs:complexType>

  <xs:simpleType name="KeyContainerFormatType">
    <xs:restriction base="xs:anyURI" />
  </xs:simpleType>
  <xs:complexType name="AuthenticationDataType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
         Authentication data contains a MAC.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="ClientID" 
        type="dskpp:IdentifierType" />
      <xs:element name="AuthenticationCodeMac" 
        type="dskpp:AuthenticationCodeMacType" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="AuthenticationCodeMacType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
         An authentication MAC calculated from an authentication code and
         optionally server information as well as nonce value if they are
         available.
       </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="Nonce" type="dskpp:NonceType" />
      <xs:element minOccurs="0" name="IterationCount" type="xs:int" />
      <xs:element name="Mac" type="dskpp:MacType" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="MacType">
    <xs:simpleContent>
      <xs:extension base="xs:base64Binary">
        <xs:attribute name="MacAlgorithm" type="xs:anyURI" />
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="KeyContainerType">
    <xs:sequence>
      <xs:element minOccurs="0" name="ServerID" type="xs:anyURI" />
      <xs:element minOccurs="0" name="KeyProtectionMethod" type="xs:anyURI" />
      <xs:choice>
        <xs:element name="KeyContainer" type="pskc:KeyContainerType" />
        <xs:any namespace="##other" processContents="strict" />
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="InitializationTriggerType">
    <xs:sequence>
      <xs:element minOccurs="0" name="DeviceIdentifierData" 
        type="dskpp:DeviceIdentifierDataType" />
      <xs:element minOccurs="0" name="KeyID" type="xs:base64Binary" />
      <xs:element minOccurs="0" name="TokenPlatformInfo" 
        type="dskpp:TokenPlatformInfoType" />
      <xs:element name="TriggerNonce" type="dskpp:NonceType" />
      <xs:element minOccurs="0" name="ServerUrl" type="xs:anyURI" />
      <xs:any minOccurs="0" namespace="##other" 
        processContents="strict" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="ExtensionsType">
    <xs:annotation>
      <xs:documentation> Extension types </xs:documentation>
    </xs:annotation>
    <xs:sequence maxOccurs="unbounded">
      <xs:element name="Extension" type="dskpp:AbstractExtensionType" />
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AbstractExtensionType" abstract="true">
    <xs:attribute name="Critical" type="xs:boolean" />
  </xs:complexType>

  <xs:complexType name="ClientInfoType">
    <xs:complexContent mixed="false">
      <xs:extension base="dskpp:AbstractExtensionType">
        <xs:sequence>
          <xs:element name="Data" type="xs:base64Binary" />
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ServerInfoType">
    <xs:complexContent mixed="false">
      <xs:extension base="dskpp:AbstractExtensionType">
        <xs:sequence>
          <xs:element name="Data" type="xs:base64Binary" />
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="KeyProvTrigger" type="dskpp:KeyProvTriggerType">
    <xs:annotation>
      <xs:documentation> DSKPP PDUs </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="KeyProvTriggerType">
    <xs:annotation>
      <xs:documentation xml:lang="en">
         Message used to trigger the device to initiate a
         DSKPP protocol run.
       </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="InitializationTrigger" 
          type="dskpp:InitializationTriggerType" />
        <xs:any namespace="##other" processContents="strict" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="Version" type="dskpp:VersionType" />
  </xs:complexType>

  <xs:element name="KeyProvClientHello" 
    type="dskpp:KeyProvClientHelloPDU">
    <xs:annotation>
      <xs:documentation> KeyProvClientHello PDU </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="KeyProvClientHelloPDU">
    <xs:annotation>
      <xs:documentation xml:lang="en">
         Message sent from DSKPP client to DSKPP server to initiate a
         DSKPP session.
       </xs:documentation>
    </xs:annotation>
    <xs:complexContent mixed="false">
      <xs:extension base="dskpp:AbstractRequestType">
        <xs:sequence>
          <xs:element minOccurs="0" name="DeviceIdentifierData" 
            type="dskpp:DeviceIdentifierDataType" />
          <xs:element minOccurs="0" name="KeyID" 
            type="xs:base64Binary" />
          <xs:element minOccurs="0" name="ClientNonce" 
            type="dskpp:NonceType" />
          <xs:element minOccurs="0" name="TriggerNonce" 
            type="dskpp:NonceType" />
          <xs:element name="SupportedKeyTypes" 
            type="dskpp:AlgorithmsType" />
          <xs:element name="SupportedEncryptionAlgorithms" 
            type="dskpp:AlgorithmsType" />
          <xs:element name="SupportedMacAlgorithms" 
            type="dskpp:AlgorithmsType" />
          <xs:element minOccurs="0" name="SupportedProtocolVariants" 
            type="dskpp:ProtocolVariantsType" />
          <xs:element minOccurs="0" name="SupportedKeyContainers" 
            type="dskpp:KeyContainersFormatType" />
          <xs:element minOccurs="0" name="AuthenticationData" 
            type="dskpp:AuthenticationDataType" />
          <xs:element minOccurs="0" name="Extensions" 
            type="dskpp:ExtensionsType" />
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="KeyProvServerHello" 
    type="dskpp:KeyProvServerHelloPDU">
    <xs:annotation>
      <xs:documentation> KeyProvServerHello PDU </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="KeyProvServerHelloPDU">
    <xs:annotation>
      <xs:documentation xml:lang="en">
         Response message sent from DSKPP server to DSKPP client
         in four-pass DSKPP.
       </xs:documentation>
    </xs:annotation>
    <xs:complexContent mixed="false">
      <xs:extension base="dskpp:AbstractResponseType">
        <xs:sequence minOccurs="0">
          <xs:element name="KeyType" type="dskpp:AlgorithmType" />
          <xs:element name="EncryptionAlgorithm" 
            type="dskpp:AlgorithmType" />
          <xs:element name="MacAlgorithm" type="dskpp:AlgorithmType" />
          <xs:element name="EncryptionKey" type="ds:KeyInfoType" />
          <xs:element name="KeyContainerFormat" 
            type="dskpp:KeyContainerFormatType" />
          <xs:element name="Payload" type="dskpp:PayloadType" />
          <xs:element minOccurs="0" name="Extensions" 
            type="dskpp:ExtensionsType" />
          <xs:element minOccurs="0" name="Mac" type="dskpp:MacType" />
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="KeyProvClientNonce" 
    type="dskpp:KeyProvClientNoncePDU">
    <xs:annotation>
      <xs:documentation> KeyProvClientNonce PDU </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="KeyProvClientNoncePDU">
    <xs:annotation>
      <xs:documentation xml:lang="en">
         Response message sent from DSKPP client to
         DSKPP server in a four-pass DSKPP session.
       </xs:documentation>
    </xs:annotation>
    <xs:complexContent mixed="false">
      <xs:extension base="dskpp:AbstractRequestType">
        <xs:sequence>
          <xs:element name="EncryptedNonce" type="xs:base64Binary" />
          <xs:element minOccurs="0" name="AuthenticationData" 
            type="dskpp:AuthenticationDataType" />
          <xs:element minOccurs="0" name="Extensions" 
            type="dskpp:ExtensionsType" />
        </xs:sequence>
        <xs:attribute name="SessionID" type="dskpp:IdentifierType" 
          use="required" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="KeyProvServerFinished" 
    type="dskpp:KeyProvServerFinishedPDU">
    <xs:annotation>
      <xs:documentation> KeyProvServerFinished PDU </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name="KeyProvServerFinishedPDU">
    <xs:annotation>
      <xs:documentation xml:lang="en">
         Final message sent from DSKPP server to DSKPP client in a DSKPP 
         session. A MAC value serves for key confirmation, and optional
         AuthenticationData serves for server authentication.
       </xs:documentation>
    </xs:annotation>
    <xs:complexContent mixed="false">
      <xs:extension base="dskpp:AbstractResponseType">
        <xs:sequence minOccurs="0">
          <xs:element name="KeyContainer" 
            type="dskpp:KeyContainerType" />
          <xs:element minOccurs="0" name="Extensions" 
            type="dskpp:ExtensionsType" />
          <xs:element name="Mac" type="dskpp:MacType" />
          <xs:element minOccurs="0" name="AuthenticationData" 
            type="dskpp:AuthenticationDataType" />
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:schema>
]]></artwork>

        <postamble></postamble>
      </figure>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Conformance Requirements">
      <t>In order to assure that all implementations of DSKPP can
      interoperate, there are the following "MUST support" requirements"</t>

      <t>The conformance requirements for the DSKPP server consist of the
      following:</t>

      <t><list style="format %c.">
          <t>MUST implement the four-pass variant of the protocol (<xref
          target="Subsection-FourPassUsage"></xref>)</t>

          <t>MUST implement the two-pass variant of the protocol (<xref
          target="Subsecton-TwoPass"></xref>)</t>

          <t>MUST support user authentication (<xref
          target="Section-ClientAuthN"></xref>)</t>

          <t>MUST support the Key Transport, Key Wrap, and Passphrase-Based
          Key Wrap Protection Profiles (<xref
          target="Section-Profiles"></xref>)</t>

          <t>MUST support the DSKPP-PRF-AES DSKPP-PRF realization (<xref
          target="Section-PRFRealizations"></xref>)</t>

          <t>MUST support the DSKPP-PRF-SHA256 DSKPP-PRF realization (<xref
          target="Section-PRFRealizations"></xref>)</t>

          <t>MAY support the RSA Encryption Scheme (<xref
          target="PKCS-1"></xref>)</t>

          <t>MAY support DSKPP-PRF with XOR (<xref
          target="Subsection-Enc"></xref>)</t>

          <t>SHOULD support integration with PKCS #11 in four-pass DSKPP
          (<xref target="Section-Integration"></xref>)</t>
        </list></t>

      <t>The conformance requirements for the DSKPP client consist of the
      following:</t>

      <t><list style="format %c.">
          <t>MUST implement the four-pass variant of the protocol (<xref
          target="Subsection-FourPassUsage"></xref>)</t>

          <t>MUST implement the two-pass variant of the protocol (<xref
          target="Subsecton-TwoPass"></xref>)</t>

          <t>MUST support user authentication (<xref
          target="Section-ClientAuthN"></xref>)</t>

          <t>MUST support the Key Transport, Key Wrap, and Passphrase-Based
          Key Wrap Protection Profiles (<xref
          target="Section-Profiles"></xref>)</t>

          <t>MUST support the DSKPP-PRF-AES DSKPP-PRF realization (<xref
          target="Section-PRFRealizations"></xref>)</t>

          <t>MUST support the DSKPP-PRF-SHA256 DSKPP-PRF realization (<xref
          target="Section-PRFRealizations"></xref>)</t>

          <t>MAY support the RSA Encryption Scheme (<xref
          target="PKCS-1"></xref>)</t>

          <t>MAY support DSKPP-PRF with XOR (<xref
          target="Subsection-Enc"></xref>)</t>

          <t>SHOULD support integration with PKCS #11 in four-pass DSKPP
          (<xref target="Section-Integration"></xref>)</t>
        </list></t>

      <t>Of course, DSKPP is a security protocol, and one of its major
      functions is to allow only authorized parties to successfully initialize
      a cryptographic module with a new symmetric key. Therefore, a particular
      implementation may be configured with any of a number of restrictions
      concerning algorithms and trusted authorities that will prevent
      universal interoperability.</t>
    </section>

    <section anchor="Section-Security" title="Security Considerations">
      <section title="General">
        <t>DSKPP is designed to protect generated key material from exposure.
        No other entities than the DSKPP server and the cryptographic module
        will have access to a generated K_TOKEN if the cryptographic
        algorithms used are of sufficient strength and, on the DSKPP client
        side, generation and encryption of R_C and generation of K_TOKEN take
        place as specified in the cryptographic module. This applies even if
        malicious software is present in the DSKPP client. However, as
        discussed in the following, DSKPP does not protect against certain
        other threats resulting from man-in-the-middle attacks and other forms
        of attacks. DSKPP SHOULD, therefore, be run over a transport providing
        privacy and integrity, such as HTTP over Transport Layer Security
        (TLS) with a suitable ciphersuite, when such threats are a concern.
        Note that TLS ciphersuites with anonymous key exchanges are not
        suitable in those situations.</t>
      </section>

      <section title="Active Attacks">
        <section title="Introduction">
          <t>An active attacker MAY attempt to modify, delete, insert, replay,
          or reorder messages for a variety of purposes including service
          denial and compromise of generated key material. <xref
          target="Subsection-Messages"></xref> through <xref
          target="Subsection-MITM"></xref>.</t>
        </section>

        <section anchor="Subsection-Messages" title="Message Modifications">
          <t>Modifications to a &lt;DSKPPTrigger&gt; message will either cause
          denial-of-service (modifications of any of the identifiers or the
          nonce) or will cause the DSKPP client to contact the wrong DSKPP
          server. The latter is in effect a man-in-the-middle attack and is
          discussed further in <xref target="Subsection-MITM"></xref>.</t>

          <t>An attacker may modify a &lt;KeyProvClientHello&gt; message. This
          means that the attacker could indicate a different key or device
          than the one intended by the DSKPP client, and could also suggest
          other cryptographic algorithms than the ones preferred by the DSKPP
          client, e.g., cryptographically weaker ones. The attacker could also
          suggest earlier versions of the DSKPP protocol, in case these
          versions have been shown to have vulnerabilities. These
          modifications could lead to an attacker succeeding in initializing
          or modifying another cryptographic module than the one intended
          (i.e., the server assigning the generated key to the wrong module),
          or gaining access to a generated key through the use of weak
          cryptographic algorithms or protocol versions. DSKPP implementations
          MAY protect against the latter by having strict policies about what
          versions and algorithms they support and accept. The former threat
          (assignment of a generated key to the wrong module) is not possible
          when the shared-key variant of DSKPP is employed (assuming existing
          shared keys are unique per cryptographic module), but is possible in
          the public-key variation. Therefore, DSKPP servers MUST NOT accept
          unilaterally provided device identifiers in the public-key
          variation. This is also indicated in the protocol description. In
          the shared-key variation, however, an attacker may be able to
          provide the wrong identifier (possibly also leading to the incorrect
          user being associated with the generated key) if the attacker has
          real-time access to the cryptographic module with the identified
          key. In other words, the generated key is associated with the
          correct cryptographic module but the module is associated with the
          incorrect user. See further <xref
          target="Subsection-Interactions"></xref> for a discussion of this
          threat and possible countermeasures.</t>

          <t>An attacker may also modify a &lt;KeyProvServerHello&gt; message.
          This means that the attacker could indicate different key types,
          algorithms, or protocol versions than the legitimate server would,
          e.g., cryptographically weaker ones. The attacker may also provide a
          different nonce than the one sent by the legitimate server. Clients
          MAY protect against the former through strict adherence to policies
          regarding permissible algorithms and protocol versions. The latter
          (wrong nonce) will not constitute a security problem, as a generated
          key will not match the key generated on the legitimate server. Also,
          whenever the DSKPP run would result in the replacement of an
          existing key, the &lt;Mac&gt; element protects against modifications
          of R_S.</t>

          <t>Modifications of &lt;KeyProvClientNonce&gt; messages are also
          possible. If an attacker modifies the SessionID attribute, then, in
          effect, a switch to another session will occur at the server,
          assuming the new SessionID is valid at that time on the server. It
          still will not allow the attacker to learn a generated K_TOKEN since
          R_C has been wrapped for the legitimate server. Modifications of the
          &lt;EncryptedNonce&gt; element, e.g., replacing it with a value for
          which the attacker knows an underlying R'C, will not result in the
          client changing its pre-DSKPP state, since the server will be unable
          to provide a valid MAC in its final message to the client. The
          server MAY, however, end up storing K'TOKEN rather than K_TOKEN. If
          the cryptographic module has been associated with a particular user,
          then this could constitute a security problem. For a further
          discussion about this threat, and a possible countermeasure, see
          <xref target="Subsection-Interactions"></xref> below. Note that use
          of TLS does not protect against this attack if the attacker has
          access to the DSKPP client (e.g., through malicious software,
          "trojans").</t>

          <t>Finally, attackers may also modify the
          &lt;KeyProvServerFinished&gt; message. Replacing the &lt;Mac&gt;
          element will only result in denial-of-service. Replacement of any
          other element may cause the DSKPP client to associate, e.g., the
          wrong service with the generated key. DSKPP SHOULD be run over a
          transport providing privacy and integrity when this is a
          concern.</t>
        </section>

        <section title="Message Deletion">
          <t>Message deletion will not cause any other harm than
          denial-of-service, since a cryptographic module MUST NOT change its
          state (i.e., "commit" to a generated key) until it receives the
          final message from the DSKPP server and successfully has processed
          that message, including validation of its MAC. A deleted
          &lt;KeyProvServerFinished&gt; message will not cause the server to
          end up in an inconsistent state vis-a-vis the cryptographic module
          if the server implements the suggestions in <xref
          target="Subsection-Interactions"></xref>.</t>
        </section>

        <section title="Message Insertion">
          <t>An active attacker may initiate a DSKPP run at any time, and
          suggest any device identifier. DSKPP server implementations MAY
          receive some protection against inadvertently initializing a key or
          inadvertently replacing an existing key or assigning a key to a
          cryptographic module by initializing the DSKPP run by use of the
          &lt;KeyProvTrigger&gt;. The &lt;TriggerNonce&gt; element allows the
          server to associate a DSKPP protocol run with, e.g., an earlier
          user-authenticated session. The security of this method, therefore,
          depends on the ability to protect the &lt;TriggerNonce&gt; element
          in the DSKPP initialization message. If an eavesdropper is able to
          capture this message, he may race the legitimate user for a key
          initialization. DSKPP over a transport providing privacy and
          integrity, coupled with the recommendations in <xref
          target="Subsection-Interactions"></xref>, is RECOMMENDED when this
          is a concern.</t>

          <t>Insertion of other messages into an existing protocol run is seen
          as equivalent to modification of legitimately sent messages.</t>
        </section>

        <section title="Message Replay">
          <t>During 4-pass DSKPP, attempts to replay a previously recorded
          DSKPP message will be detected, as the use of nonces ensures that
          both parties are live. For example, a DSKPP client knows that a
          server it is communicating with is "live" since the server MUST
          create a MAC on information sent by the client.</t>

          <t>The same is true for 2-pass DSKPP thanks to the requirement that
          the client sends R in the &lt;KeyProvClientHello&gt; message and
          that the server includes R in the MAC computation.</t>
        </section>

        <section title="Message Reordering">
          <t>An attacker may attempt to re-order 4-pass DSKPP messages but
          this will be detected, as each message is of a unique type. Note:
          Message re-ordering attacks cannot occur in 2-pass DSKPP since each
          party sends at most one message each.</t>
        </section>

        <section anchor="Subsection-MITM" title="Man-in-the-Middle">
          <t>In addition to other active attacks, an attacker posing as a man
          in the middle may be able to provide his own public key to the DSKPP
          client. This threat and countermeasures to it are discussed in <xref
          target="Subsection-FourPassUsage"></xref>. An attacker posing as a
          man-in-the-middle may also be acting as a proxy and, hence, may not
          interfere with DSKPP runs but still learn valuable information; see
          <xref target="Subsection-Passive"></xref>.</t>
        </section>
      </section>

      <section anchor="Subsection-Passive" title="Passive Attacks">
        <t>Passive attackers may eavesdrop on DSKPP runs to learn information
        that later on may be used to impersonate users, mount active attacks,
        etc.</t>

        <t>If DSKPP is not run over a transport providing privacy, a passive
        attacker may learn:<list hangIndent="0" style="symbols">
            <t>What cryptographic modules a particular user is in possession
            of;</t>

            <t>The identifiers of keys on those cryptographic modules and
            other attributes pertaining to those keys, e.g., the lifetime of
            the keys; and</t>

            <t>DSKPP versions and cryptographic algorithms supported by a
            particular DSKPP client or server.</t>
          </list>Whenever the above is a concern, DSKPP SHOULD be run over a
        transport providing privacy. If man-in-the-middle attacks for the
        purposes described above are a concern, the transport SHOULD also
        offer server-side authentication.</t>
      </section>

      <section title="Cryptographic Attacks">
        <t>An attacker with unlimited access to an initialized cryptographic
        module may use the module as an "oracle" to pre-compute values that
        later on may be used to impersonate the DSKPP server. <xref
        target="Subsection-Enc"></xref> and <xref
        target="Section-Protocol"></xref> contain discussions of this threat
        and steps RECOMMENDED to protect against it.</t>
      </section>

      <section anchor="Subsection-Interactions"
               title="Attacks on the Interaction between DSKPP and User Authentication">
        <t>If keys generated in DSKPP will be associated with a particular
        user at the DSKPP server (or a server trusted by, and communicating
        with the DSKPP server), then in order to protect against threats where
        an attacker replaces a client-provided encrypted R_C with his own R'C
        (regardless of whether the public-key variation or the shared-secret
        variation of DSKPP is employed to encrypt the client nonce), the
        server SHOULD not commit to associate a generated K_TOKEN with the
        given cryptographic module until the user simultaneously has proven
        both possession of the device that hosts the cryptographic module
        containing K_TOKEN and some out-of-band provided authenticating
        information (e.g., a temporary password). For example, if the
        cryptographic module is a one-time password token, the user could be
        required to authenticate with both a one-time password generated by
        the cryptographic module and an out-of-band provided temporary PIN in
        order to have the server "commit" to the generated OTP value for the
        given user. Preferably, the user SHOULD perform this operation from
        another host than the one used to initialize keys on the cryptographic
        module, in order to minimize the risk of malicious software on the
        client interfering with the process.</t>

        <t>Note: This scenario, wherein the attacker replaces a
        client-provided R_C with his own R'C, does not apply to 2-pass DSKPP
        as the client does not provide any entropy to K_TOKEN. The attack as
        such (and its countermeasures) still applies to 2-pass DSKPP, however,
        as it essentially is a man-in-the-middle attack.</t>

        <t>Another threat arises when an attacker is able to trick a user to
        authenticate to the attacker rather than to the legitimate service
        before the DSKPP protocol run. If successful, the attacker will then
        be able to impersonate the user towards the legitimate service, and
        subsequently receive a valid DSKPP trigger. If the public-key variant
        of DSKPP is used, this may result in the attacker being able to (after
        a successful DSKPP protocol run) impersonate the user. Ordinary
        precautions MUST, therefore, be in place to ensure that users
        authenticate only to legitimate services.</t>
      </section>

      <section title="Additional Considerations">
        <section title="Client Contributions to K_TOKEN Entropy">
          <t>In 4-pass DSKPP, both the client and the server provide
          randomizing material to K_TOKEN , in a manner that allows both
          parties to verify that they did contribute to the resulting key. In
          the 2-pass DSKPP version defined herein, only the server contributes
          to the entropy of K_TOKEN. This means that a broken or compromised
          (pseudo-)random number generator in the server may cause more damage
          than it would in the 4-pass variation. Server implementations SHOULD
          therefore take extreme care to ensure that this situation does not
          occur.</t>
        </section>

        <section title="Key Confirmation">
          <t>4-pass DSKPP servers provide key confirmation through the MAC on
          R_C in the &lt;KeyProvServerFinished&gt; message. In the 2-pass
          DSKPP variation described herein, key confirmation is provided by
          the MAC including R, using K_MAC.</t>
        </section>

        <section anchor="Subsection-ServerAuth" title="Server Authentication">
          <t>DSKPP servers MUST authenticate themselves whenever a successful
          DSKPP 2-pass protocol run would result in an existing K_TOKEN being
          replaced by a K_TOKEN', or else a denial-of-service attack where an
          unauthorized DSKPP server replaces a K_TOKEN with another key would
          be possible. In 2-pass DSKPP, servers authenticate by including the
          AuthenticationDataType extension containing a MAC as described in
          <xref target="Subsecton-TwoPass"></xref> for Two-Pass DSKPP.</t>
        </section>

        <section title="User Authentication">
          <t>A DSKPP server MUST authenticate a client to ensure that K_TOKEN
          is delivered to the intended device. The following measures SHOULD
          be considered:<list style="symbols">
              <t>When an Authentication Code is used for client
              authentication, a password dictionary attack on the
              authentication data is possible.</t>

              <t>The length of the Authentication Code when used over a
              non-secure channel SHOULD be longer than what is used over a
              secure channel. When a device, e.g., some mobile phones with
              small screens, cannot handle a long Authentication Code in a
              user-friendly manner, DSKPP SHOULD rely on a secure channel for
              communication.</t>

              <t>In the case that a non-secure channel has to be used, the
              Authentication Code SHOULD be sent to the server MAC'd as
              specified in <xref target="Section-ClientAuthN"></xref>. The
              Authentication Code and nonce value MUST be strong enough to
              prevent offline brute-force recovery of the Authentication Code
              from the HMAC data. Given that the nonce value is sent in
              plaintext format over a non-secure transport, the cryptographic
              strength of the AuthenticationData depends more on the quality
              of the AuthenticationCode.</t>

              <t>When the AuthenticationCode is sent from the DSKPP server to
              the device in a DSKPP initialization trigger message, an
              eavesdropper may be able to capture this message and race the
              legitimate user for a key initialization. To prevent this, the
              transport layer used to send the DSKPP trigger MUST provide
              privacy and integrity e.g. secure browser session.</t>
            </list></t>
        </section>

        <section title="Key Protection in the Two-Pass Passphrase Profile">
          <t>The passphrase-based key wrap profile uses the PBKDF2 function
          from <xref target="PKCS-5"></xref> to generate an encryption key
          from a passphrase and salt string. The derived key, K_DERIVED is
          used by the server to encrypt K_TOKEN and by the cryptographic
          module to decrypt the newly delivered K_TOKEN. It is important to
          note that passphrase-based encryption is generally limited in the
          security that it provides despite the use of salt and iteration
          count in PBKDF2 to increase the complexity of attack.
          Implementations SHOULD therefore take additional measures to
          strengthen the security of the passphrase-based key wrap profile.
          The following measures SHOULD be considered where applicable:</t>

          <t><list style="symbols">
              <t>The passphrase SHOULD be selected well, and usage guidelines
              such as the ones in <xref target="NIST-PWD"></xref> SHOULD be
              taken into account.</t>

              <t>A different passphrase SHOULD be used for every key
              initialization wherever possible (the use of a global passphrase
              for a batch of cryptographic modules SHOULD be avoided, for
              example). One way to achieve this is to use randomly-generated
              passphrases.</t>

              <t>The passphrase SHOULD be protected well if stored on the
              server and/or on the cryptographic module and SHOULD be
              delivered to the device's user using secure methods.</t>

              <t>User pre-authentication SHOULD be implemented to ensure that
              K_TOKEN is not delivered to a rogue recipient.</t>

              <t>The iteration count in PBKDF2 SHOULD be high to impose more
              work for an attacker using brute-force methods (see <xref
              target="PKCS-5"></xref> for recommendations). However, it MUST
              be noted that the higher the count, the more work is required on
              the legitimate cryptographic module to decrypt the newly
              delivered K_TOKEN. Servers MAY use relatively low iteration
              counts to accommodate devices with limited processing power such
              as some PDA and cell phones when other security measures are
              implemented and the security of the passphrase-based key wrap
              method is not weakened.</t>

              <t>Transport level security (e.g. TLS) SHOULD be used where
              possible to protect a 2-pass protocol run. Transport level
              security provides a second layer of protection for the newly
              generated K_TOKEN.</t>
            </list></t>
        </section>
      </section>
    </section>

    <section title="Internationalization Considerations">
      <t>The DSKPP protocol is mostly meant for machine-to-machine
      communications; as such, most of its elements are tokens not meant for
      direct human consumption. If these tokens are presented to the end user,
      some localization may need to occur. DSKPP exchanges information using
      XML. All XML processors are required to understand UTF-8 and UTF-16
      encoding, and therefore all DSKPP clients and servers MUST understand
      UTF-8 and UTF-16 encoded XML. Additionally, DSKPP servers and clients
      MUST NOT encode XML with encodings other than UTF-8 or UTF-16.</t>
    </section>

    <section title="IANA Considerations">
      <t>This document calls for registration of new URNs within the IETF
      sub-namespace per RFC3553 <xref target="RFC3553"></xref>. The following
      URNs are RECOMMENDED:<list style="symbols">
          <t>DSKPP XML schema:
          "urn:ietf:params:xml:schema:keyprov:protocol"</t>

          <t>DSKPP XML namespace:
          "urn:ietf:params:xml:ns:keyprov:protocol"</t>
        </list></t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-IPR" title="Intellectual Property Considerations">
      <t>RSA and RSA Security are registered trademarks or trademarks of RSA
      Security Inc. in the United States and/or other countries. The names of
      other products and services mentioned may be the trademarks of their
      respective owners.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Contributors">
      <t>This work is based on information contained in <xref
      target="RFC4758"></xref>, authored by Magnus Nystrom, with enhancements
      (esp. Client Authentication, and support for multiple key container
      formats) from an individual Internet-Draft co-authored by Mingliang Pei
      and Salah Machani.</t>

      <t>We would like to thank Shuh Chang for contributing the DSKPP object
      model, and Philip Hoyer for his work in aligning DSKPP and PSKC
      schemas.</t>

      <t>We would also like to thank Hannes Tschofenig for his draft reviews,
      feedback, and text contributions.</t>
    </section>

    <section anchor="Section-Acknowledgements" title="Acknowledgements">
      <t>We would like to thank the following for review of previous DSKPP
      document versions:<vspace blankLines="1" /><list style="symbols">
          <t>Lakshminath Dondeti (Review December 2007)<vspace
          blankLines="1" /></t>

          <t>Dr. Ulrike Meyer (Review June 2007)<vspace blankLines="1" /></t>

          <t>Niklas Neumann (Review June 2007)<vspace blankLines="1" /></t>

          <t>Shuh Chang (Review June 2007)<vspace blankLines="1" /></t>

          <t>Hannes Tschofenig (Review June 2007 and again in August
          2007)<vspace blankLines="1" /></t>

          <t>Sean Turner (Review August 2007)<vspace blankLines="1" /></t>

          <t>John Linn (Review August 2007)<vspace blankLines="1" /></t>

          <t>Philip Hoyer (Review September 2007)</t>
        </list></t>

      <t>We would also like to thank the following for their input to selected
      design aspects of the DSKPP protocol:<vspace blankLines="1" /><list
          style="symbols">
          <t>Anders Rundgren (Key Container Format and Client Authentication
          Data)<vspace blankLines="1" /></t>

          <t>Hannes Tschofenig (HTTP Binding)<vspace blankLines="1" /></t>

          <t>Phillip Hallam-Baker (Registry for Algorithms)</t>
        </list></t>

      <t>Finally, we would like to thank Robert Griffin for opening
      communication channels for us with the IEEE P1619.3 Key Management
      Group, and facilitating our groups in staying informed of potential
      areas (esp. key provisioning and global key identifiers of
      collaboration) of collaboration.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->
  </middle>

  <back>
    <references title="Normative references">
      <reference anchor="UNICODE"
                 target="http://www.unicode.org/unicode/reports/tr15/tr15-21.html">
        <front>
          <title>Unicode Normalization Forms</title>

          <author initials="M." surname="Davis">
            <organization>UNICODE Consortium</organization>
          </author>

          <author initials="M." surname="Duerst">
            <organization>UNICODE Consortium</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="March" year="2001" />
        </front>
      </reference>

      <reference anchor="XMLENC"
                 target="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">
        <front>
          <title>XML Encryption Syntax and Processing</title>

          <author>
            <organization>W3C</organization>
          </author>

          <date month="December" year="2002" />
        </front>

        <seriesInfo name="W3C" value="Recommendation" />
      </reference>

      <reference anchor="XMLDSIG"
                 target="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">
        <front>
          <title>XML Signature Syntax and Processing</title>

          <author>
            <organization>W3C</organization>
          </author>

          <date month="February" year="2002" />
        </front>

        <seriesInfo name="W3C" value="Recommendation" />
      </reference>
    </references>

    <references title="Informative references">
      <reference anchor="CT-KIP-P11"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>PKCS #11 Mechanisms for the Cryptographic Token Key
          Initialization Protocol</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="December" year="2005" />
        </front>

        <seriesInfo name="PKCS" value="#11 Version 2.20 Amd.2" />
      </reference>

      <reference anchor="FAQ">
        <front>
          <title>Frequently Asked Questions About Today's Cryptography</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="" year="2000" />
        </front>

        <seriesInfo name="" value="Version 4.1" />
      </reference>

      <reference anchor="FIPS180-SHA"
                 target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">
        <front>
          <title>Secure Hash Standard</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="February" year="2004" />
        </front>

        <seriesInfo name="FIPS" value="180-2" />
      </reference>

      <reference anchor="FIPS197-AES"
                 target="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">
        <front>
          <title>Specification for the Advanced Encryption Standard
          (AES)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="November" year="2001" />
        </front>

        <seriesInfo name="FIPS" value="197" />
      </reference>

      <reference anchor="FSE2003"
                 target="http://crypt.cis.ibaraki.ac.jp/omac/docs/omac.pdf">
        <front>
          <title>OMAC: One-Key CBC MAC. In Fast Software Encryption</title>

          <author initials="T." surname="Iwata">
            <organization></organization>
          </author>

          <author initials="K." surname="Kurosawa">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date year="2003" />
        </front>

        <seriesInfo name="FSE" value="2003" />

        <seriesInfo name="Springer-Verlag" value="" />
      </reference>

      <reference anchor="NIST-PWD"
                 target="http://www.itl.nist.gov/fipspubs/fip112.htm">
        <front>
          <title>Password Usage</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="May" year="1985" />
        </front>

        <seriesInfo name="FIPS" value="112" />
      </reference>

      <reference anchor="PSKC"
                 target="http://www.ietf.org/internet-drafts/draft-hoyer-keyprov-portable-symmetric-key-container-00.txt">
        <front>
          <title>Portable Symmetric Key Container</title>

          <author fullname="">
            <organization></organization>
          </author>

          <date year="2005" />
        </front>
      </reference>

      <reference anchor="PKCS-1"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>RSA Cryptography Standard</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="June" year="2002" />
        </front>

        <seriesInfo name="PKCS" value="#1 Version 2.1" />
      </reference>

      <reference anchor="PKCS-5"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>Password-Based Cryptography Standard</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="March" year="1999" />
        </front>

        <seriesInfo name="PKCS" value="#5 Version 2.0" />
      </reference>

      <reference anchor="PKCS-5-XML"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>XML Schema for PKCS #5 Version 2.0</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="October" year="2006" />
        </front>

        <seriesInfo name="PKCS" value="#5 Version 2.0 Amd.1 (FINAL DRAFT)" />
      </reference>

      <reference anchor="PKCS-11"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>Cryptographic Token Interface Standard</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="June" year="2004" />
        </front>

        <seriesInfo name="PKCS" value="#11 Version 2.20" />
      </reference>

      <reference anchor="PKCS-12"
                 target="ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12v1.pdf">
        <front>
          <title>Personal Information Exchange Syntax Standard</title>

          <author fullname="">
            <organization></organization>
          </author>

          <date year="2005" />
        </front>

        <seriesInfo name="PKCS" value="#12 Version 1.0" />
      </reference>

      <reference anchor="RFC2104">
        <front>
          <title>HMAC: Keyed-Hashing for Message Authentication</title>

          <author initials="H." surname="Krawzcyk">
            <organization></organization>
          </author>

          <author initials="M." surname="Bellare">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="R." surname="Canetti">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="February" year="1997" />
        </front>

        <seriesInfo name="RFC" value="2104" />
      </reference>

      <reference anchor="RFC2119" target="http://www.ietf.org/rfc/rfc2119.txt">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement
          Levels</title>

          <author fullname="">
            <organization></organization>
          </author>

          <date month="March" year="1997" />
        </front>

        <seriesInfo name="BCP" value="14" />

        <seriesInfo name="RFC" value="2119" />
      </reference>

      <reference anchor="RFC2616" target="http://www.ietf.org/rfc/rfc2616.txt">
        <front>
          <title>Hypertext Transfer Protocol -- HTTP/1.1</title>

          <author initials="R." surname="Fielding">
            <organization></organization>
          </author>

          <author initials="J." surname="Gettys">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="J." surname="Mogul">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="H." surname="Frystyk">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="L." surname="Masinter">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="P." surname="Leach">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="T." surname="Berners-Lee">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="June" year="1999" />
        </front>

        <seriesInfo name="RFC" value="2616" />
      </reference>

      <reference anchor="RFC3280">
        <front>
          <title>Internet X.509 Public Key Infrastructure Certificate and
          Certificate Revocation List (CRL) Profile</title>

          <author initials="R." surname="Housley">
            <organization>VeriSign</organization>
          </author>

          <author initials="W." surname="Polk">
            <organization>Adobe Systems</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="W." surname="Ford">
            <organization>Qualcomm</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="D." surname="Solo">
            <organization>Nine by Nine</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="April" year="2002" />
        </front>

        <seriesInfo name="RFC" value="3280" />
      </reference>

      <reference anchor="RFC3553">
        <front>
          <title>An IETF URN Sub-namespace for Registered Protocol
          Parameters</title>

          <author initials="M." surname="Mealling">
            <organization>VeriSign</organization>
          </author>

          <author initials="L." surname="Masinter">
            <organization>Adobe Systems</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="T." surname="Hardie">
            <organization>Qualcomm</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="G." surname="Klyne">
            <organization>Nine by Nine</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="June" year="2003" />
        </front>

        <seriesInfo name="RFC" value="3553" />

        <seriesInfo name="BCP" value="73" />
      </reference>

      <reference anchor="RFC4758" target="http://www.ietf.org/rfc/rfc4758.txt">
        <front>
          <title>Cryptographic Token Key Initialization Protocol
          (CT-KIP)</title>

          <author fullname="Magnus Nystrom">
            <organization>RSA, The Security Division of EMC</organization>
          </author>

          <date month="November" year="2006" />
        </front>
      </reference>
    </references>

    <section anchor="Section-Examples" title="Examples">
      <t>This appendix contains example messages that illustrate parameters,
      encoding, and semantics in four-and two- pass DSKPP exchanges. The
      examples are written using XML, and are syntactically correct. MAC and
      cipher values are fictitious however.</t>

      <section title="Trigger Message">
        <t></t>

        <figure>
          <preamble></preamble>

          <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvTrigger Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0" 
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0 
    keyprov-dskpp-1.0.xsd">
  <dskpp:InitializationTrigger>
    <dskpp:DeviceIdentifierData>
      <dskpp:DeviceId>
        <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
        <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
        <pskc:Model>U2</pskc:Model>
      </dskpp:DeviceId>
    </dskpp:DeviceIdentifierData>
    <dskpp:KeyID>SE9UUDAwMDAwMDAx</dskpp:KeyID>
    <dskpp:TokenPlatformInfo KeyLocation="Hardware" 
      AlgorithmLocation="Software"/>
    <dskpp:TriggerNonce>112dsdfwf312asder394jw==</dskpp:TriggerNonce>
    <dskpp:ServerUrl>https://www.somekeyprovservice.com/
      </dskpp:ServerUrl>
  </dskpp:InitializationTrigger>
</dskpp:KeyProvTrigger>]]></artwork>

          <postamble></postamble>
        </figure>
      </section>

      <section title="Four-Pass Protocol">
        <t></t>

        <section title="&lt;KeyProvClientHello&gt; Without a Preceding Trigger">
          <t></t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0
   keyprov-dskpp-1.0.xsd">  
  <dskpp:DeviceIdentifierData>
    <dskpp:DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </dskpp:DeviceId>
  </dskpp:DeviceIdentifierData>
  <dskpp:SupportedKeyTypes>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/pskc#hotp
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.rsa.com/rsalabs/otps/schemas/2005/09/
      otps-wst#SecurID-AES</dskpp:Algorithm>    
  </dskpp:SupportedKeyTypes>  
  <dskpp:SupportedEncryptionAlgorithms>
    <dskpp:Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
      </dskpp:Algorithm>
  </dskpp:SupportedEncryptionAlgorithms>
  <dskpp:SupportedMacAlgorithms>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
      </dskpp:Algorithm>
  </dskpp:SupportedMacAlgorithms>  
  <dskpp:SupportedProtocolVariants><dskpp:FourPass/>
    </dskpp:SupportedProtocolVariants>
  <dskpp:SupportedKeyContainers>
    <dskpp:KeyContainerFormat>
      http://www.ietf.org/keyprov/pskc#KeyContainer
    </dskpp:KeyContainerFormat>
  </dskpp:SupportedKeyContainers>
</dskpp:KeyProvClientHello>
]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="&lt;KeyProvClientHello&gt; Assuming a Preceding Trigger">
          <t></t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0
    keyprov-dskpp-1.0.xsd">  
  <dskpp:DeviceIdentifierData>
    <dskpp:DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </dskpp:DeviceId>
  </dskpp:DeviceIdentifierData>
  <dskpp:KeyID>SE9UUDAwMDAwMDAx</dskpp:KeyID>
  <dskpp:TriggerNonce>112dsdfwf312asder394jw==</dskpp:TriggerNonce>
  <dskpp:SupportedKeyTypes>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/pskc#hotp</dskpp:Algorithm>
    <dskpp:Algorithm>http://www.rsa.com/rsalabs/otps/schemas/2005/09/
      otps-wst#SecurID-AES</dskpp:Algorithm>    
  </dskpp:SupportedKeyTypes>  
  <dskpp:SupportedEncryptionAlgorithms>
    <dskpp:Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
      </dskpp:Algorithm>
  </dskpp:SupportedEncryptionAlgorithms>
  <dskpp:SupportedMacAlgorithms>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
      </dskpp:Algorithm>
  </dskpp:SupportedMacAlgorithms>  
  <dskpp:SupportedProtocolVariants><dskpp:FourPass/>
    </dskpp:SupportedProtocolVariants>
  <dskpp:SupportedKeyContainers>
    <dskpp:KeyContainerFormat>
      http://www.ietf.org/keyprov/pskc#KeyContainer
    </dskpp:KeyContainerFormat>
  </dskpp:SupportedKeyContainers>
</dskpp:KeyProvClientHello>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="&lt;KeyProvServerHello&gt; Without a Preceding Trigger">
          <t></t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerHello Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0" 
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0 
    keyprov-dskpp-1.0.xsd">
  <dskpp:KeyType>
    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
  </dskpp:KeyType>
  <dskpp:EncryptionAlgorithm>
    http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
  </dskpp:EncryptionAlgorithm>
  <dskpp:MacAlgorithm>
    http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
  </dskpp:MacAlgorithm>
  <dskpp:EncryptionKey>
    <ds:KeyName>KEY-1</ds:KeyName>
  </dskpp:EncryptionKey>
  <dskpp:KeyContainerFormat>
    http://www.ietf.org/keyprov/pskc#KeyContainer
  </dskpp:KeyContainerFormat>
  <dskpp:Payload>
    <dskpp:Nonce>qw2ewasde312asder394jw==</dskpp:Nonce>
  </dskpp:Payload>
</dskpp:KeyProvServerHello>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="&lt;KeyProvServerHello&gt; Assuming a Preceding Trigger">
          <t></t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerHello Version="1.0" SessionID="4114" 
  Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0" 
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0 
    keyprov-dskpp-1.0.xsd">
  <dskpp:KeyType>
    urn:ietf:params:xml:schema:keyprov:otpalg#SecurID-AES
  </dskpp:KeyType>
  <dskpp:EncryptionAlgorithm>
    http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
  </dskpp:EncryptionAlgorithm>
  <dskpp:MacAlgorithm>
    http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
  </dskpp:MacAlgorithm>
  <dskpp:EncryptionKey>
    <ds:KeyName>KEY-1</ds:KeyName>
  </dskpp:EncryptionKey>
  <dskpp:KeyContainerFormat>
    http://www.ietf.org/keyprov/pskc#KeyContainer
  </dskpp:KeyContainerFormat>
  <dskpp:Payload>
    <dskpp:Nonce>qw2ewasde312asder394jw==</dskpp:Nonce>
  </dskpp:Payload>
  <dskpp:Mac 
    MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes">
    cXcycmFuZG9tMzEyYXNkZXIzOTRqdw==
  </dskpp:Mac>
</dskpp:KeyProvServerHello>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="&lt;KeyProvClientNonce&gt; Using Default Encryption">
          <t>This message contains the nonce chosen by the cryptographic
          module, R_C, encrypted by the specified encryption key and
          encryption algorithm.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientNonce Version="1.0" SessionID="4114"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0
    keyprov-dskpp-1.0.xsd">
  <dskpp:EncryptedNonce>VXENc+Um/9/NvmYKiHDLaErK0gk=
    </dskpp:EncryptedNonce>
  <dskpp:AuthenticationData>
    <dskpp:ClientID>31300257</dskpp:ClientID>
    <dskpp:AuthenticationCodeMac>
      <dskpp:IterationCount>512</dskpp:IterationCount>
      <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
    </dskpp:AuthenticationCodeMac>
  </dskpp:AuthenticationData>	
</dskpp:KeyProvClientNonce>]]></artwork>
          </figure>
        </section>

        <section title="&lt;KeyProvServerFinished&gt; Using Default Encryption">
          <t></t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0 
    keyprov-dskpp-1.0.xsd">  
  <dskpp:KeyContainer>
    <dskpp:KeyContainer Version="1.0">
      <pskc:DigestMethod 
        Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <pskc:Device>
        <pskc:Key 
          KeyAlgorithm="http://www.rsa.com/rsalabs/otps/schemas/2005/09/
            otps-wst#SecurID-AES"
          KeyId="XL0000000001234">
          <pskc:Issuer>CredentialIssuer</pskc:Issuer>
          <pskc:Usage OTP="true">
            <pskc:ResponseFormat Format="DECIMAL" Length="6"/>
          </pskc:Usage>
          <pskc:FriendlyName>MyFirstToken</pskc:FriendlyName>
          <pskc:Data Name="TIME">
            <pskc:Value>AAAAADuaygA=</pskc:Value>
          </pskc:Data>
          <pskc:Expiry>10/30/2012</pskc:Expiry>
        </pskc:Key>
      </pskc:Device>     
    </dskpp:KeyContainer>        
  </dskpp:KeyContainer>
  <dskpp:Mac 
    MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes">
    miidfasde312asder394jw==
  </dskpp:Mac>
</dskpp:KeyProvServerFinished>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>
      </section>

      <section title="Two-Pass Protocol">
        <t></t>

        <section anchor="Example-TwoPass-1"
                 title="Example Using the Key Transport Profile">
          <t>The client indicates support all the Key Transport, Key Wrap, and
          Passphrase-Based Key Wrap profiles (see <xref
          target="Section-Profiles"></xref>):</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0 
  keyprov-dskpp-1.0.xsd">
  <dskpp:DeviceIdentifierData>
    <dskpp:DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </dskpp:DeviceId>
  </dskpp:DeviceIdentifierData>
  <dskpp:ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</dskpp:ClientNonce>
  <dskpp:SupportedKeyTypes>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/pskc#hotp
      </dskpp:Algorithm>
    <dskpp:Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </dskpp:Algorithm>    
  </dskpp:SupportedKeyTypes>  
  <dskpp:SupportedEncryptionAlgorithms>
    <dskpp:Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
      </dskpp:Algorithm>
  </dskpp:SupportedEncryptionAlgorithms>
  <dskpp:SupportedMacAlgorithms>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
      </dskpp:Algorithm>
  </dskpp:SupportedMacAlgorithms>  
  <dskpp:SupportedProtocolVariants>
    <dskpp:TwoPass>
      <dskpp:SupportedKeyProtectionMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#wrap
      </dskpp:SupportedKeyProtectionMethod>
      <dskpp:Payload xsi:type="ds:KeyInfoType">
        <ds:KeyName>Key_001</ds:KeyName>
      </dskpp:Payload>
      <dskpp:SupportedKeyProtectionMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#transport
      </dskpp:SupportedKeyProtectionMethod>
      <dskpp:SupportedKeyProtectionMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap
      </dskpp:SupportedKeyProtectionMethod>
      <dskpp:Payload xsi:type="ds:KeyInfoType">
        <ds:X509Data>
          <ds:X509Certificate>miib</ds:X509Certificate>
        </ds:X509Data>
      </dskpp:Payload>
    </dskpp:TwoPass>
  </dskpp:SupportedProtocolVariants>
  <dskpp:SupportedKeyContainers>
    <dskpp:KeyContainerFormat>
      http://www.ietf.org/keyprov/pskc#KeyContainer
    </dskpp:KeyContainerFormat>
  </dskpp:SupportedKeyContainers>
  <dskpp:AuthenticationData>
    <dskpp:ClientID>31300257</dskpp:ClientID>
    <dskpp:AuthenticationCodeMac>
      <dskpp:IterationCount>512</dskpp:IterationCount>
      <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
    </dskpp:AuthenticationCodeMac>
  </dskpp:AuthenticationData>
</dskpp:KeyProvClientHello>]]></artwork>

            <postamble></postamble>
          </figure>

          <t>In this example, the server responds to the previous request
          using the key transport profile.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" 
  Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0 
    keyprov-dskpp-1.0.xsd">
  <dskpp:KeyContainer>
    <dskpp:KeyContainer Version="1.0">
    <dskpp:ServerID>https://www.somedskppservice.com/</dskpp:ServerID>
    <dskpp:KeyProtectionMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#transport
    </dskpp:KeyProtectionMethod>
      <pskc:EncryptionMethod 
        Algorithm="http://www.w3.org/2001/05/xmlenc#rsa_1_5">
        <pskc:KeyInfo>
          <ds:X509Data>
            <ds:X509Certificate>miib</ds:X509Certificate>
          </ds:X509Data>
        </pskc:KeyInfo>
      </pskc:EncryptionMethod>
      <pskc:DigestMethod 
        Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <pskc:Device>
        <pskc:Key KeyAlgorithm="http://www.ietf.org/keyprov/pskc#hotp" 
          KeyId="SDU312345678">
          <pskc:Issuer>CredentialIssuer</pskc:Issuer>
          <pskc:Usage OTP="true">
            <pskc:ResponseFormat Format="DECIMAL" Length="6"/>
          </pskc:Usage>
          <pskc:FriendlyName>MyFirstToken</pskc:FriendlyName>
          <pskc:Data Name="SECRET">
            <pskc:Value>
              7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
            </pskc:Value>
            <pskc:ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </pskc:ValueDigest>
          </pskc:Data>
          <pskc:Data Name="COUNTER">
            <pskc:Value>AAAAAAAAAAA=</pskc:Value>
          </pskc:Data>
          <pskc:Expiry>10/30/2012</pskc:Expiry>
        </pskc:Key>
      </pskc:Device>
    </dskpp:KeyContainer>
  </dskpp:KeyContainer>
  <dskpp:Mac 
    MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes">
    miidfasde312asder394jw==
  </dskpp:Mac>
  <dskpp:AuthenticationData>
    <dskpp:AuthenticationCodeMac>
      <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
    </dskpp:AuthenticationCodeMac>
  </dskpp:AuthenticationData>  
</dskpp:KeyProvServerFinished>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="Example Using the Key Wrap Profile">
          <t>The client sends a request that specifies a shared key to protect
          the K_TOKEN, and the server responds using the Key Wrap Profile.
          Authentication data in this example is basing on an authentication
          code rather than a device certificate.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:pkcs-5=
    "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0 
  keyprov-dskpp-1.0.xsd">
  <dskpp:DeviceIdentifierData>
    <dskpp:DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </dskpp:DeviceId>
  </dskpp:DeviceIdentifierData>
  <dskpp:ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</dskpp:ClientNonce>
  <dskpp:SupportedKeyTypes>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/pskc#hotp
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.rsa.com/rsalabs/otps/schemas/2005/09/
      otps-wst#SecurID-AES</dskpp:Algorithm>    
  </dskpp:SupportedKeyTypes>  
  <dskpp:SupportedEncryptionAlgorithms>
    <dskpp:Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.rsasecurity.com/rsalabs/pkcs/schemas/
      pkcs-5#pbes2</dskpp:Algorithm>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
      </dskpp:Algorithm>
  </dskpp:SupportedEncryptionAlgorithms>
  <dskpp:SupportedMacAlgorithms>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
      </dskpp:Algorithm>
  </dskpp:SupportedMacAlgorithms>  
  <dskpp:SupportedProtocolVariants>
    <dskpp:TwoPass>
      <dskpp:SupportedKeyProtectionMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#wrap
      </dskpp:SupportedKeyProtectionMethod>
      <dskpp:Payload xsi:type="ds:KeyInfoType">
        <ds:KeyName>Key_001</ds:KeyName>
      </dskpp:Payload>
    </dskpp:TwoPass>
  </dskpp:SupportedProtocolVariants>
  <dskpp:SupportedKeyContainers>
    <dskpp:KeyContainerFormat>
      http://www.ietf.org/keyprov/pskc#KeyContainer
    </dskpp:KeyContainerFormat>
  </dskpp:SupportedKeyContainers>
  <dskpp:AuthenticationData>
    <dskpp:ClientID>31300257</dskpp:ClientID>
    <dskpp:AuthenticationCodeMac>
      <dskpp:IterationCount>512</dskpp:IterationCount>
      <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
    </dskpp:AuthenticationCodeMac>
  </dskpp:AuthenticationData>	
</dskpp:KeyProvClientHello>]]></artwork>

            <postamble></postamble>
          </figure>

          <t>In this example, the server responds to the previous request
          using the key wrap profile.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0 
  keyprov-dskpp-1.0.xsd">
  <dskpp:KeyContainer>
    <dskpp:KeyContainer Version="1.0">
    <dskpp:ServerID>https://www.somedskppservice.com/</dskpp:ServerID>
    <dskpp:KeyProtectionMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#wrap
    </dskpp:KeyProtectionMethod>
      <pskc:EncryptionMethod 
        Algorithm="http://www.w3.org/2001/04/xmlenc#kw-aes128">
        <pskc:KeyInfo>
           <ds:KeyName>Key-001</ds:KeyName>
         </pskc:KeyInfo>
      </pskc:EncryptionMethod>
      <pskc:DigestMethod 
        Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <pskc:Device>
        <pskc:Key KeyAlgorithm="http://www.ietf.org/keyprov/pskc#hotp" 
          KeyId="SDU312345678">
          <pskc:Issuer>CredentialIssuer</pskc:Issuer>
          <pskc:Usage OTP="true">
            <pskc:ResponseFormat Format="DECIMAL" Length="6"/>
          </pskc:Usage>
          <pskc:FriendlyName>MyFirstToken</pskc:FriendlyName>
          <pskc:Data Name="SECRET">
            <pskc:Value>
              JSPUyp3azOkqJENSsh6b2hdXz1WBYypzJxEr+ikQAa22M6V/BgZhRg==
            </pskc:Value>
            <pskc:ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </pskc:ValueDigest>
          </pskc:Data>
          <pskc:Data Name="COUNTER">
            <pskc:Value>AAAAAAAAAAA=</pskc:Value>
          </pskc:Data>
          <pskc:Expiry>10/30/2012</pskc:Expiry>
        </pskc:Key>
      </pskc:Device>
    </dskpp:KeyContainer>
  </dskpp:KeyContainer>
  <dskpp:Mac 
    MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes">
    miidfasde312asder394jw==
  </dskpp:Mac>
  <dskpp:AuthenticationData>
    <dskpp:AuthenticationCodeMac>
      <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
    </dskpp:AuthenticationCodeMac>
  </dskpp:AuthenticationData>	    
</dskpp:KeyProvServerFinished>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="Example Using the Passphrase-Based Key Wrap Profile">
          <t>The client sends a request similar to that in <xref
          target="Example-TwoPass-1"></xref> with authentication data basing
          on an authentication code, and the server responds using the
          Passphrase-Based Key Wrap Profile. The authentication data is set in
          clear text when it is sent over a secure transport channel such as
          TLS.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:pkcs-5=
    "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0 
    keyprov-dskpp-1.0.xsd">
  <dskpp:DeviceIdentifierData>
    <dskpp:DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </dskpp:DeviceId>
  </dskpp:DeviceIdentifierData>
  <dskpp:ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</dskpp:ClientNonce>
  <dskpp:SupportedKeyTypes>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/pskc#hotp
      </dskpp:Algorithm>
    <dskpp:Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </dskpp:Algorithm>    
  </dskpp:SupportedKeyTypes>  
  <dskpp:SupportedEncryptionAlgorithms>
    <dskpp:Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128
      </dskpp:Algorithm>
    <dskpp:Algorithm>
      http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2
    </dskpp:Algorithm>
    <dskpp:Algorithm>
      http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
    </dskpp:Algorithm>
  </dskpp:SupportedEncryptionAlgorithms>
  <dskpp:SupportedMacAlgorithms>
    <dskpp:Algorithm>
      http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes
    </dskpp:Algorithm>
  </dskpp:SupportedMacAlgorithms>  
  <dskpp:SupportedProtocolVariants>
    <dskpp:TwoPass>
      <dskpp:SupportedKeyProtectionMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#wrap
      </dskpp:SupportedKeyProtectionMethod>
      <dskpp:Payload xsi:type="ds:KeyInfoType">
        <ds:KeyName>Key_001</ds:KeyName>
      </dskpp:Payload>
      <dskpp:SupportedKeyProtectionMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap
      </dskpp:SupportedKeyProtectionMethod>
    </dskpp:TwoPass>
  </dskpp:SupportedProtocolVariants>
  <dskpp:SupportedKeyContainers>
    <dskpp:KeyContainerFormat>
      http://www.ietf.org/keyprov/pskc#KeyContainer
    </dskpp:KeyContainerFormat>
  </dskpp:SupportedKeyContainers>
  <dskpp:AuthenticationData>
    <dskpp:ClientID>31300257</dskpp:ClientID>
    <dskpp:AuthenticationCodeMac>
      <dskpp:IterationCount>512</dskpp:IterationCount>
      <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
    </dskpp:AuthenticationCodeMac>
  </dskpp:AuthenticationData>	
</dskpp:KeyProvClientHello>]]></artwork>

            <postamble></postamble>
          </figure>

          <t>In this example, the server responds to the previous request
          using the Passphrase-Based Key Wrap Profile.</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" 
  SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container:1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:protocol:1.0 
    keyprov-dskpp-1.0.xsd">
  <dskpp:KeyContainer>
    <dskpp:KeyContainer Version="1.0">
    <dskpp:ServerID>https://www.somedskppservice.com/</dskpp:ServerID>
    <dskpp:KeyProtectionMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap
    </dskpp:KeyProtectionMethod>
      <pskc:EncryptionMethod 
        Algorithm="http://www.rsasecurity.com/rsalabs/pkcs/schemas/
          pkcs-5#pbes2">         
          <pskc:PBEEncryptionParam 
             EncryptionAlgorithm=
               "http://www.w3.org/2001/04/xmlenc#kw-aes128-cbc">
            <pskc:PBESalt>y6TzckeLRQw=</pskc:PBESalt>
            <pskc:PBEIterationCount>1024</pskc:PBEIterationCount>            
          </pskc:PBEEncryptionParam>
          <pskc:IV>c2FtcGxlaXY=</pskc:IV>
        </pskc:EncryptionMethod> 
      <pskc:DigestMethod 
        Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <pskc:Device>
        <pskc:Key KeyAlgorithm="http://www.ietf.org/keyprov/pskc#hotp" 
          KeyId="SDU312345678">
          <pskc:Issuer>CredentialIssuer</pskc:Issuer>
          <pskc:Usage OTP="true">
            <pskc:ResponseFormat Format="DECIMAL" Length="6"/>
          </pskc:Usage>
          <pskc:FriendlyName>MyFirstToken</pskc:FriendlyName>
          <pskc:Data Name="SECRET">
            <pskc:Value>
              JSPUyp3azOkqJENSsh6b2hdXz1WBYypzJxEr+ikQAa22M6V/BgZhRg==
            </pskc:Value>
            <pskc:ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </pskc:ValueDigest>
          </pskc:Data>
          <pskc:Data Name="COUNTER">
            <pskc:Value>AAAAAAAAAAA=</pskc:Value>
          </pskc:Data>
          <pskc:Expiry>10/30/2012</pskc:Expiry>
        </pskc:Key>
      </pskc:Device>
    </dskpp:KeyContainer>
  </dskpp:KeyContainer>
  <dskpp:Mac 
    MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes">
    miidfasde312asder394jw==
  </dskpp:Mac>
  <dskpp:AuthenticationData>
    <dskpp:AuthenticationCodeMac>
      <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
    </dskpp:AuthenticationCodeMac>
  </dskpp:AuthenticationData>	      
</dskpp:KeyProvServerFinished>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>
      </section>
    </section>

    <section anchor="Section-Integration" title="Integration with PKCS #11">
      <t>A DSKPP client that needs to communicate with a connected
      cryptographic module to perform a DSKPP exchange MAY use PKCS #11 <xref
      target="PKCS-11"></xref>as a programming interface.</t>

      <section title="The 4-pass Variant">
        <t>When performing 4-pass DSKPP with a cryptographic module using the
        PKCS #11 programming interface, the procedure described in <xref
        target="CT-KIP-P11"></xref>, Appendix B, is RECOMMENDED.</t>
      </section>

      <section title="The 2-pass Variant">
        <t>A suggested procedure to perform 2-pass DSKPP with a cryptographic
        module through the PKCS #11 interface using the mechanisms defined in
        <xref target="CT-KIP-P11"></xref> is as follows:</t>

        <t><list counter="2-pass" style="format %c.">
            <t>On the client side, <list counter="1st" style="format %d.">
                <t>The client selects a suitable slot and token (e.g. through
                use of the &lt;DeviceIdentifier&gt; or the
                &lt;PlatformInfo&gt; element of the DSKPP trigger
                message).</t>

                <t>A nonce R is generated, e.g. by calling C_SeedRandom and
                C_GenerateRandom.</t>

                <t>The client sends its first message to the server, including
                the nonce R.</t>
              </list></t>

            <t>On the server side, <list counter="2nd" style="format %d.">
                <t>A generic key K_PROV = K_TOKEN | K_MAC (where '|' denotes
                concatenation) is generated, e.g. by calling C_GenerateKey
                (using key type CKK_GENERIC_SECRET). The template for K_PROV
                MUST allow it to be exported (but only in wrapped form, i.e.
                CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
                also be set to CK_TRUE), and also to be used for further key
                derivation. From K, a token key K_TOKEN of suitable type is
                derived by calling C_DeriveKey using the PKCS #11 mechanism
                CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
                the first bit of the generic secret key (i.e. set to 0).
                Likewise, a MAC key K_MAC is derived from K_PROV by calling
                C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism, this
                time setting CK_EXTRACT_PARAMS to the length of K_PROV (in
                bits) divided by two.</t>

                <t>The server wraps K_PROV with either the token's public key
                K_CLIENT, the shared secret key K_SHARED, or the derived
                shared secret key K_DERIVED by using C_WrapKey. If use of the
                DSKPP key wrap algorithm has been negotiated then the
                CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
                C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure MUST
                be set to NULL_PTR. The pSeed parameter in the CK_KIP_PARAMS
                structure MUST point to the nonce R provided by the DSKPP
                client, and the ulSeedLen parameter MUST indicate the length
                of R. The hWrappingKey parameter in the call to C_WrapKey MUST
                be set to refer to the wrapping key.</t>

                <t>Next, the server needs to calculate a MAC using K_MAC. If
                use of the DSKPP MAC algorithm has been negotiated, then the
                MAC is calculated by calling C_SignInit with the CKM_KIP_MAC
                mechanism followed by a call to C_Sign. In the call to
                C_SignInit, K_MAC MUST be the signature key, the hKey
                parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure
                MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be
                set to zero. In the call to C_Sign, the pData parameter MUST
                be set to the concatenation of the string ServerID and the
                nonce R, and the ulDataLen parameter MUST be set to the length
                of the concatenated string. The desired length of the MAC MUST
                be specified through the pulSignatureLen parameter and MUST be
                set to the length of R.</t>

                <t>If the server also needs to authenticate its message (due
                to an existing K_TOKEN being replaced), the server MUST
                calculate a second MAC. Again, if use of the DSKPP MAC
                algorithm has been negotiated, then the MAC is calculated by
                calling C_SignInit with the CKM_KIP_MAC mechanism followed by
                a call to C_Sign. In this call to C_SignInit, the K_MAC
                existing before this DSKPP protocol run MUST be the signature
                key, the hKey parameter in the CK_KIP_PARAMS structure MUST be
                set to NULL, the pSeed parameter of the CT_KIP_PARAMS
                structure MUST be set to NULL_PTR, and the ulSeeidLen
                parameter MUST be set to zero. In the call to C_Sign, the
                pData parameter MUST be set to the concatenation of the string
                ServerID and the nonce R, and the ulDataLen parameter MUST be
                set to the length of concatenated string. The desired length
                of the MAC MUST be specified through the pulSignatureLen
                parameter and MUST be set to the length of R.</t>

                <t>The server sends its message to the client, including the
                wrapped key K, the MAC and possibly also the authenticating
                MAC.</t>
              </list></t>

            <t>On the client side, <list counter="3rd" style="format %d.">
                <t>The client calls C_UnwrapKey to receive a handle to K.
                After this, the client calls C_DeriveKey twice: Once to derive
                K_TOKEN and once to derive K_MAC. The client MUST use the same
                mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same mechanism
                parameters as used by the server above. When calling
                C_UnwrapKey and C_DeriveKey, the pTemplate parameter MUST be
                used to set additional key attributes in accordance with local
                policy and as negotiated and expressed in the protocol. In
                particular, the value of the &lt;KeyID&gt; element in the
                server's response message MAY be used as CKA_ID for K_TOKEN.
                The key K_PROV MUST be destroyed after deriving K_TOKEN and
                K_MAC.</t>

                <t>The MAC is verified in a reciprocal fashion as it was
                generated by the server. If use of the CKM_KIP_MAC mechanism
                has been negotiated, then in the call to C_VerifyInit, the
                hKey parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
                ulSeedLen MUST be set to 0. The hKey parameter of C_VerifyInit
                MUST refer to K_MAC. In the call to C_Verify, pData MUST be
                set to the concatenation of the string ServerID and the nonce
                R, and the ulDataLen parameter MUST be set to the length of
                the concatenated string, pSignature to the MAC value received
                from the server, and ulSignatureLen to the length of the MAC.
                If the MAC does not verify the protocol session ends with a
                failure. The token MUST be constructed to not "commit" to the
                new K_TOKEN or the new K_MAC unless the MAC verifies.</t>

                <t>If an authenticating MAC was received (REQUIRED if the new
                K_TOKEN will replace an existing key on the token), then it is
                verified in a similar vein but using the K_MAC associated with
                this server and existing before the protocol run. Again, if
                the MAC does not verify the protocol session ends with a
                failure, and the token MUST be constructed no to "commit" to
                the new K_TOKEN or the new K_MAC unless the MAC verifies.</t>
              </list></t>
          </list></t>
      </section>
    </section>

    <section anchor="Section-PRFRealizations"
             title="Example of DSKPP-PRF Realizations">
      <section title="Introduction">
        <t>This example appendix defines DSKPP-PRF in terms of AES <xref
        target="FIPS197-AES"></xref> and HMAC <xref
        target="RFC2104"></xref>.</t>
      </section>

      <section title="DSKPP-PRF-AES">
        <section title="Identification">
          <t>For cryptographic modules supporting this realization of
          DSKPP-PRF, the following URL MAY be used to identify this algorithm
          in DSKPP:</t>

          <t>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes</t>

          <t>When this URL is used to identify the encryption algorithm to
          use, the method for encryption of R_C values described in <xref
          target="Subsection-Enc"></xref> MUST be used.</t>
        </section>

        <section title="Definition">
          <t>DSKPP-PRF-AES (k, s, dsLen)</t>

          <t>Input:<list hangIndent="10" style="hanging">
              <t hangText="k">Encryption key to use</t>

              <t hangText="s">Octet string consisting of randomizing material.
              The length of the string s is sLen.</t>

              <t hangText="dsLen">Desired length of the output</t>
            </list></t>

          <t>Output:</t>

          <t><list hangIndent="10" style="hanging">
              <t hangText="DS">A pseudorandom string, dsLen-octets long</t>
            </list></t>

          <t>Steps:</t>

          <t><list hangIndent="0" style="format %d.">
              <t>Let bLen be the output block size of AES in octets:<vspace
              blankLines="1" />bLen = (AES output block length in
              octets)<vspace blankLines="0" />(normally, bLen = 16)</t>

              <t>If dsLen &gt; (2**32 - 1) * bLen, output "derived data too
              long" and stop</t>

              <t>Let n be the number of bLen-octet blocks in the output data,
              rounding up, and let j be the number of octets in the last
              block:<vspace blankLines="1" />n = ROUND( dsLen / bLen)<vspace
              blankLines="0" />j = dsLen - (n - 1) * bLen</t>

              <t>For each block of the pseudorandom string DS, apply the
              function F defined below to the key k, the string s and the
              block index to compute the block:<vspace blankLines="1" />B1 = F
              (k, s, 1) ,<vspace blankLines="0" />B2 = F (k, s, 2) ,<vspace
              blankLines="0" />...<vspace blankLines="0" />Bn = F (k, s,
              n)</t>
            </list>The function F is defined in terms of the OMAC1
          construction from <xref target="FSE2003"></xref>, using AES as the
          block cipher:<vspace blankLines="1" />F (k, s, i) = OMAC1-AES (k,
          INT (i) || s)<vspace blankLines="1" />where INT (i) is a four-octet
          encoding of the integer i, most significant octet first, and the
          output length of OMAC1 is set to bLen.<vspace
          blankLines="1" />Concatenate the blocks and extract the first dsLen
          octets to product the desired data string DS:<vspace
          blankLines="1" />DS = B1 || B2 || ... || Bn&lt;0..j-1&gt;<vspace
          blankLines="1" />Output the derived data DS.</t>
        </section>

        <section title="Example">
          <t>If we assume that dsLen = 16, then:</t>

          <t>n = 16 / 16 = 1</t>

          <t>j = 16 - (1 - 1) * 16 = 16</t>

          <t>DS = B1 = F (k, s, 1) = OMAC1-AES (k, INT (1) || s)</t>
        </section>
      </section>

      <section title="DSKPP-PRF-SHA256">
        <section title="Identification">
          <t>For cryptographic modules supporting this realization of
          DSKPP-PRF, the following URL MAY be used to identify this algorithm
          in DSKPP:</t>

          <t>http://www.ietf.org/keyprov/dskpp#dskpp-prf-sha256</t>

          <t>When this URL is used to identify the encryption algorithm to
          use, the method for encryption of R_C values described in <xref
          target="Subsection-Enc"></xref> MUST be used.</t>
        </section>

        <section title="Definition">
          <t>DSKPP-PRF-SHA256 (k, s, dsLen)</t>

          <t>Input:<list hangIndent="10" style="hanging">
              <t hangText="k">Encryption key to use</t>

              <t hangText="s">Octet string consisting of randomizing material.
              The length of the string s is sLen.</t>

              <t hangText="dsLen">Desired length of the output</t>
            </list></t>

          <t>Output:</t>

          <t><list hangIndent="10" style="hanging">
              <t hangText="DS">A pseudorandom string, dsLen-octets long</t>
            </list></t>

          <t>Steps:</t>

          <t><list hangIndent="0" style="format %d.">
              <t>Let bLen be the output size of SHA-256 in octets of <xref
              target="FIPS180-SHA"></xref> (no truncation is done on the HMAC
              output):<vspace blankLines="1" />bLen = 32<vspace
              blankLines="0" />(normally, bLen = 16)</t>

              <t>If dsLen &gt; (2**32 - 1) * bLen, output "derived data too
              long" and stop</t>

              <t>Let n be the number of bLen-octet blocks in the output data,
              rounding up, and let j be the number of octets in the last
              block:<vspace blankLines="1" />n = ROUND( dsLen / bLen)<vspace
              blankLines="0" />j = dsLen - (n - 1) * bLen</t>

              <t>For each block of the pseudorandom string DS, apply the
              function F defined below to the key k, the string s and the
              block index to compute the block:<vspace blankLines="1" />B1 = F
              (k, s, 1) ,<vspace blankLines="0" />B2 = F (k, s, 2) ,<vspace
              blankLines="0" />...<vspace blankLines="0" />Bn = F (k, s,
              n)</t>
            </list>The function F is defined in terms of the HMAC construction
          from <xref target="RFC2104"></xref>, using SHA-256 as the digest
          algorithm:<vspace blankLines="1" />F (k, s, i) = HMAC-SHA256 (k, INT
          (i) || s)<vspace blankLines="1" />where INT (i) is a four-octet
          encoding of the integer i, most significant octet first, and the
          output length of HMAC is set to bLen.<vspace
          blankLines="1" />Concatenate the blocks and extract the first dsLen
          octets to product the desired data string DS:<vspace
          blankLines="1" />DS = B1 || B2 || ... || Bn&lt;0..j-1&gt;<vspace
          blankLines="1" />Output the derived data DS.</t>
        </section>

        <section title="Example">
          <t>If we assume that sLen = 256 (two 128-octet long values) and
          dsLen = 16, then:</t>

          <t>n = ROUND ( 16 / 32 ) = 1</t>

          <t>j = 16 - (1 - 1) * 32 = 16</t>

          <t>B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)</t>

          <t>DS = B1&lt;0 ... 15&gt;</t>

          <t>That is, the result will be the first 16 octets of the HMAC
          output.</t>
        </section>
      </section>
    </section>
  </back>
</rfc>