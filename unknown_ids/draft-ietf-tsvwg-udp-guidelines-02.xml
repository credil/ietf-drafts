<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc strict="yes"?>
<?rfc tocompact="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc comments="yes" ?>
<!--<?rfc rfcedstyle="yes"?>-->
<?rfc sortrefs="yes" ?>

<!-- noModification3978 -->
<rfc category="bcp" ipr="full3978" docName="draft-ietf-tsvwg-udp-guidelines-02">
<front>
<title abbrev="UDP Usage Guidelines">
	UDP Usage Guidelines for Application Designers
</title>

<author initials="L." surname="Eggert" fullname="Lars Eggert">
	<organization abbrev="Nokia">
		Nokia Research Center
	</organization>
	<address>
		<postal>
			<street>P.O. Box 407</street>
			<code>00045</code> <city>Nokia Group</city>
			<country>Finland</country>
		</postal>
		<phone>+358 50 48 24461</phone>
		<email>lars.eggert@nokia.com</email>
		<uri>
			http://research.nokia.com/people/lars_eggert/
		</uri>
	</address>
</author>

<author initials="G." surname="Fairhurst" fullname="Godred Fairhurst">
       <organization>University of Aberdeen</organization>
       <address>
		<postal>
		<street>Department of Engineering</street>
		<street>Fraser Noble Building</street>
		<city>Aberdeen</city>
		<code>AB24 3UE</code>
		<country>Scotland</country>
		</postal>
		<email>gorry@erg.abdn.ac.uk</email>
		<uri>http://www.erg.abdn.ac.uk/</uri>
	</address>
</author>

<date year="2007"/>
<area>Transport Area</area>
<workgroup>Transport Area Working Group</workgroup>
<keyword>UDP</keyword>
<keyword>guidelines</keyword>

<abstract>
	<t>
The User Datagram Protocol (UDP) provides a minimal, message-passing transport that has no inherent congestion control mechanisms. Because congestion control is critical to the stable operation of the Internet, applications and upper-layer protocols that choose to use UDP as an Internet transport must employ mechanisms to prevent congestion collapse and establish some degree of fairness with concurrent traffic. This document provides guidelines on the use of UDP for the designers of such applications and upper-layer protocols that cover congestion-control and other topics, including message sizes, reliability, checksums and middlebox traversal. 
	</t>
</abstract>
</front>

<middle>
<section title="Introduction" anchor="intro">
	<t>
The User Datagram Protocol (UDP) <xref target="RFC0768"/> provides a minimal, unreliable, best-effort, message-passing transport to applications and upper-layer protocols (both simply called "applications" in the remainder of this document). Compared to other transport protocols, UDP and its UDP-Lite variant <xref target="RFC3828"/> are unique in that they do not establish end-to-end connections between communicating end systems. UDP communication consequently does not incur connection establishment and teardown overheads and there is no associated end system state. Because of these characteristics, UDP can offer a very efficient communication transport to some applications.
	</t>
	<t>
A second unique characteristic of UDP is that it provides no inherent congestion control mechanisms. <xref target="RFC2914"/> describes the best current practice for congestion control in the Internet. It identifies two major reasons why congestion control mechanisms are critical for the stable operation of the Internet:

	<list style="numbers">
		<t>
The prevention of congestion collapse, i.e., a state where an increase in network load results in a decrease in useful work done by the network. 
		</t>
		<t>
The establishment of a degree of fairness, i.e., allowing multiple flows to share the capacity of a path reasonably equitably. 
		</t>
	</list>
	</t>
	<t>
Because UDP itself provides no congestion control mechanisms, it is up to the applications that use UDP for Internet communication to employ suitable mechanisms to prevent congestion collapse and establish a degree of fairness. <xref target="RFC2309"/> discusses the dangers of congestion-unresponsive flows and states that "all UDP-based streaming applications should incorporate effective congestion avoidance mechanisms." This is an important requirement, even for applications that do not use UDP for streaming. For example, an application that generates five 1500-byte UDP packets in one second can already exceed the capacity of a 56 Kb/s path. For applications that can operate at higher, potentially unbounded data rates, congestion control becomes vital to prevent congestion collapse and establish some degree of fairness. <xref target="udpguide"/> describes a number of simple guidelines for the designers of such applications.
	</t>
	<t>
A UDP message is carried in a single IP packet and is hence limited to a maximum payload of 65,487 bytes. The transmission of large IP packets frequently requires IP fragmentation, which decreases communication reliability and efficiency and should be avoided. One reason for this decrease in reliability is because many NATs and firewalls do not forward IP fragments; other reasons are documented in <xref target="I-D.heffner-frag-harmful"/>. Some of the guidelines in <xref target="udpguide"/> describe how applications should determine appropriate message sizes.
	</t>
	<t>
This document provides guidelines to designers of applications that use UDP for unicast transmission. A special class of applications uses UDP for IP multicast transmissions. Congestion control, flow control or reliability for multicast transmissions is more difficult to establish than for unicast transmissions, because a single sender may transmit to multiple receivers across potentially very heterogeneous paths at the same time. Designing multicast applications requires expertise that goes beyond the simple guidelines given in this document. The IETF has defined a reliable multicast framework <xref target="RFC3048"/> and several building blocks to aid the designers of multicast applications, such as <xref target="RFC3738"/> or <xref target="RFC4654"/>. 
	</t>
</section>

<section title="Terminology" anchor="term">
	<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14, RFC 2119 <xref target="RFC2119"/>.
	</t>
</section>

<section title="UDP Usage Guidelines" anchor="udpguide">
	<t>
The RECOMMENDED alternative to the UDP usage guidelines described in this section is the use of a transport protocol that is congestion-controlled, such as TCP <xref target="RFC0793"/>, SCTP <xref target="RFC2960"/> or DCCP <xref target="RFC4340"/> with its different congestion control types <xref target="RFC4341"/><xref target="RFC4342"/><xref target="I-D.floyd-dccp-ccid4"/>. Congestion control mechanisms are difficult to implement correctly, and for most applications, the use of one of the existing, congestion-controlled protocols is the simplest method of satisfying <xref target="RFC2914"/>. The same is true for message size determination and reliability mechanisms.
	</t>
	<t>
If used correctly, congestion-controlled transport protocols are not as "heavyweight" as often claimed. For example, TCP with SYN cookies <xref target="I-D.ietf-tcpm-syn-flood"/>, which are available on many platforms, does not require a server to maintain per-connection state until the connection is established. TCP also requires the end that closes a connection to maintain the TIME-WAIT state that prevents delayed segments from one connection instance to interfere with a later one. Applications that are aware of this behavior can shift maintenance of the TIME-WAIT state to conserve resources. Finally, TCP's built-in capacity-probing and awareness of the maximum transmission unit supported by the path (PMTU) results in efficient data transmission that quickly compensates for the initial connection setup delay, for transfers that exchange more than a few packets. 
	</t>

	<section title="Congestion Control Guidelines" anchor="ccguide">
		<t>
If an application or upper-layer protocol chooses not to use a congestion-controlled transport protocol, it SHOULD control the rate at which it sends UDP messages to a destination host. It is important to stress that an application SHOULD perform congestion control over all UDP traffic it sends to a destination, independent of how it generates this traffic. For example, an application that forks multiple worker processes or otherwise uses multiple sockets to generate UDP messages SHOULD perform congestion control over the aggregate traffic. The remainder of this section discusses several approaches for this purpose.
		</t>
		<t>
It is important to note that congestion control should not be viewed as an add-on to a finished application. Many of the mechanisms discussed in the guidelines below require application support to operate correctly. Application designers need to consider congestion control throughout the design of their application, similar to how they consider security aspects throughout the design process.
		</t>

	<section title="Bulk Transfer Applications" anchor="btguide">
		<t>
Applications that perform bulk transmission of data to a peer over UDP SHOULD implement TCP-Friendly Rate Control (TFRC) <xref target="RFC3448"/>, window-based, TCP-like congestion control, or otherwise ensure that the application complies with the congestion control principles.
		</t>
		<t>
TFRC has been designed to provide both congestion control and fairness in a way that is compatible with the IETF's other transport protocols. TFRC is currently being updated <xref target="I-D.ietf-dccp-rfc3448bis"/>, and application designers SHOULD always evaluate whether the latest published specification fits their needs. If an application implements TFRC, it need not follow the remaining guidelines in <xref target="ccguide"/>, because TFRC already addresses them, but SHOULD still follow the remaining guidelines in the subsequent subsections of <xref target="udpguide"/>. 
		</t>
		<t>
Bulk transfer applications that choose not to implement TFRC or TCP-like windowing SHOULD implement a congestion control scheme that results in bandwidth use that competes fairly with TCP within an order of magnitude. <xref target="RFC3551"/> suggests that applications SHOULD monitor the packet loss rate to ensure that it is within acceptable parameters. Packet loss is considered acceptable if a TCP flow across the same network path under the same network conditions would achieve an average throughput, measured on a reasonable timescale, that is not less than that of the UDP flow. The comparison to TCP cannot be specified exactly, but is intended as an "order-of-magnitude" comparison in timescale and throughput. 
		</t>
		<t>
Finally, some bulk transfer applications chose not to implement any congestion control mechanism and instead rely on transmitting across reserved path capacity. This might be an acceptable choice for a subset of restricted networking environments, but is by no means a safe practice for operation in the Internet. When the UDP traffic of such applications leaks out on unprovisioned paths, results are detrimental.
		</t>
	</section>
	
	<section title="Low Data-Volume Applications">
		<t>
When applications that exchange only a small number of messages with a destination at any time implement TFRC or one of the other congestion control schemes in <xref target="btguide"/>, the network sees little benefit, because those mechanisms perform congestion control in a way that is only effective for longer transmissions.
		</t>
		<t>
Applications that exchange only a small number of messages with a destination at any time applications SHOULD still control their transmission behavior by not sending more than one UDP message per round-trip time (RTT) to a destination. Similar to the recommendation in <xref target="RFC1536"/>, an application SHOULD maintain an estimate of the RTT for any destination it communicates with. Applications SHOULD implement the algorithm specified in <xref target="RFC2988"/> to compute a smoothed RTT (SRTT) estimate. A lost response from the peer SHOULD be treated as a very large RTT sample, instead of being ignored, in order to cause a sufficiently large (exponential) back-off. When implementing this scheme, applications need to choose a sensible initial value for the RTT. This value SHOULD generally be as conservative as possible for the given application. TCP uses an initial value of 3 seconds <xref target="RFC2988"/>, which is also RECOMMENDED as an initial value for UDP applications. SIP <xref target="RFC3261"/> and GIST <xref target="I-D.ietf-nsis-ntlp"/> use an initial value of 500 ms, and initial timeouts that are shorter than this are likely problematic in many cases. It is also important to note that the initial timeout is not the maximum possible timeout - the RECOMMENDED algorithm in <xref target="RFC2988"/> yields timeout values after a series of losses that are much longer than the initial value.
		</t>
		<t>
Some applications cannot maintain a reliable RTT estimate for a destination. The first case is applications that exchange too few messages with a peer to establish a statistically accurate RTT estimate. Such applications MAY use a fixed transmission interval that is exponentially backed-off during loss. TCP uses an initial value of 3 seconds <xref target="RFC2988"/>, which is also RECOMMENDED as an initial value for UDP applications. SIP <xref target="RFC3261"/> and GIST <xref target="I-D.ietf-nsis-ntlp"/> use an interval of 500 ms, and shorter values are likely problematic in many cases. As in the previous case, note that the initial timeout is not the maximum possible timeout.		
		</t>
		<t>
A second class of applications cannot maintain an RTT estimate for a destination, because the destination does not send return traffic. Such applications SHOULD NOT send more than one UDP message every 3 seconds, and SHOULD consider if they can use an even less aggressive rate when possible. The 3-second interval was chosen based on TCP's retransmission timeout when the RTT is unknown <xref target="RFC2988"/>, and shorter values are likely problematic in many cases. Note that the initial timeout interval must be more conservative than in the two previous cases, because the lack of return traffic prevents the detection of packet loss, i.e., congestion events, and the application therefore cannot perform exponential back-off to reduce load.
		</t>
		<t>
Applications that communicate bidirectionally SHOULD employ congestion control for both directions of the communication. For example, for a client-server, request-response-style application, clients SHOULD congestion control their request transmission to a server, and the server SHOULD congestion control its responses to the clients. Congestion in the forward and reverse direction is uncorrelated and an application SHOULD independently detect and respond to congestion along both directions.
		</t>	
	</section>
	</section>

	<section title="Message Size Guidelines" anchor="msguide">
		<t>
Because IP fragmentation lowers the efficiency and reliability of Internet communication <xref target="I-D.heffner-frag-harmful"/>, an application SHOULD NOT send UDP messages that result in IP packets that exceed the MTU of the path to the destination. Consequently, an application SHOULD either use the path MTU information provided by the IP layer or implement path MTU discovery itself <xref target="RFC1191"/><xref target="RFC1981"/><xref target="RFC4821"/> to determine whether the path to a destination will support its desired message size without fragmentation.
		</t>
		<t>
Applications that choose not adapt the packet size SHOULD NOT send UDP messages that exceed the minimum PMTU. The minimum PMTU depends on the IP version used for transmission, and is the lesser of 576 bytes and the first-hop MTU for IPv4 <xref target="RFC1122"/> and 1280 bytes for IPv6 <xref target="RFC2460"/>. To determine an appropriate UDP payload size, applications must subtract IP header and option lengths as well as the length of the UDP header from the PMTU size. Transmission of minimum-sized messages is inefficient over paths that support a larger PMTU, which is a second reason to implement PMTU discovery.
		</t>
		<t>
Applications that do not send messages that exceed the minimum PMTU of IPv4 or IPv6 need not implement any of the above mechanisms.
		</t>
	</section>

	<section title="Reliability Guidelines" anchor="reguide">
		<t>
Application designers are generally aware that UDP does not provide any reliability. Often, this is a main reason to consider UDP as a transport. Applications that do require reliable message delivery SHOULD implement an appropriate mechanism themselves. 
		</t>
		<t>
UDP also does not protect against message duplication, i.e., an application may receive multiple copies of the same message. Application designers SHOULD consider whether their application handles message duplication gracefully, and may need to implement mechanisms to detect duplicates. Even if message reception triggers idempotent operations, applications may want to suppress duplicate messages to reduce load.
		</t>
		<t>
Finally, UDP messages may be reordered in the network and arrive at the receiver in an order different from the transmission order. Applications that require ordered delivery SHOULD reestablish message ordering themselves.
		</t>
	</section>

	<section title="Checksum Guidelines" anchor="chkguide">
		<t>
The UDP header includes an optional, 16-bit ones' complement checksum that provides an integrity check. The UDP checksum provides assurance that the payload was not corrupted in transit. It also verifies that the datagram was delivered to the intended end point, because it covers the IP addresses, port numbers and protocol number, and it verifies that the datagram is not truncated or padded, because it covers the size field. It therefore protects an application against receiving corrupted payload data in place of, or in addition to, the data that was sent.
		</t>
		<t>
Applications SHOULD enable UDP checksums, although <xref target="RFC0793"/> permits the option to disable their use. Applications that choose to disable UDP checksums when transmitting over IPv4 therefore MUST NOT make assumptions regarding the correctness of received data and MUST behave correctly when a packet is received that was originally sent to a different end point or is otherwise corrupted. The use of the UDP checksum is MANDATORY when applications transmit UDP over IPv6 <xref target="RFC2460"/> and applications consequently MUST NOT disable their use. (The IPv6 header does not have a separate checksum field to protect the IP addressing information.)
		</t>
		<t>
The UDP checksum provides relatively weak protection from a coding point of view <xref target="RFC3819"/> and, where data integrity is important, application developers SHOULD provide additional checks, e.g., through a CRC included with the data to verify the integrity of an entire object/file sent over UDP service.
		</t>

		<section title="UDP-Lite" anchor="udplite">
		<t>
A special class of applications derive benefit from having partially damaged payloads delivered rather than discarded when using paths that include error-prone links. Such applications can tolerate payload corruption and MAY choose to use the Lightweight User Datagram Protocol (UDP-Lite) <xref target="RFC3828"/> variant of UDP instead of basic UDP. Applications that choose to use UDP-Lite instead of UDP MUST still follow the congestion control and other guidelines described for use with UDP in <xref target="ccguide"/>. 
		</t>
		<t>
UDP-Lite changes the semantics of the UDP "payload length" field to that of a "checksum coverage length" field. Otherwise, UDP-Lite is semantically identical to UDP. The interface of UDP-Lite differs from that of UDP by the addition of a single (socket) option that communicates a checksum coverage length value: at the sender, this specifies the intended datagram checksum coverage, with the remaining unprotected part of the payload called the "error insensitive part". If required, an application may dynamically modify this length value, e.g., to offer greater protection to some packets. UDP-Lite always verifies that a datagram was delivered to the intended end point, i.e., always verifies the header fields. Errors in the insensitive part will not cause a packet to be discarded by the receiving end host. Applications using UDP-Lite therefore MUST NOT make assumptions regarding the correctness of the data received in the insensitive part of the UDP-Lite payload.
		</t>
		<t>
The sending application SHOULD select the minimum checksum coverage to
include all sensitive protocol headers (e.g., the RTP header), and, where
appropriate, MUST also introduce their own appropriate validity checks for
protocol information carried in the insensitive part of the UDP-Lite payload
(e.g., internal CRCs).
		</t>
		<t>
The receiver MUST set a minimum coverage threshold for incoming datagrams
that is not smaller than the smallest coverage used by the sender.  This may
be a fixed value, or may be negotiated by an application. UDP-Lite does not
provide mechanisms to negotiate the checksum coverage between the sender and
receiver. 
		</t>
		<t>
Applications may still experience packet loss, rather than corruption, when
using UDP-Lite. The enhancements offered by UDP-Lite rely upon a link being
able to intercept the UDP-Lite header to correctly identify the
partial-coverage required. When tunnels and/or encryption are used, this can
result in UDP-Lite packets being treated the same as UDP packets, i.e., result in packet loss. Use of IP fragmentation can also prevent special treatment for
UDP-Lite packets, and is another reason why applications SHOULD avoid IP fragmentation <xref target="msguide"/>. 

		</t>
		</section>
		
	</section>

	<section title="Middlebox Traversal Guidelines" anchor="natguide">
	<t>
Network address translators (NATs) and firewalls are examples of intermediary devices ("middleboxes") that can exist along an end-to-end path. A middlebox typically performs a function that requires it to maintain per-flow state. For connection-oriented protocols, such as TCP, middleboxes snoop and parse the connection-management traffic and create and destroy per-flow state accordingly. For a connectionless protocol such as UDP, this approach is not possible. Consequently, middleboxes may create per-flow state when they see a packet that indicates a new flow, and destroy the state after some period of time during which no packets belonging to the same flow have arrived.
	</t>
	<t>
Depending on the specific function that the middlebox performs, this behavior can introduce a time-dependency that restricts the kinds of UDP traffic exchanges that will be successful across it. For example, NATs and firewalls typically define the partial path on one side of them to be interior to the domain they control, whereas the partial path on their other side is defined to be exterior to that domain. Per-flow state is typically created when the first packet crosses from the interior to the exterior, and while the state is present, NATs and firewalls will forward return traffic. Return traffic arriving after the per-flow state has timed out is dropped, as is other traffic arriving from the exterior.
	</t>
	<t>
Many applications use UDP for communication operate across middleboxes without needing to employ additional mechanisms. One example is the DNS, which has a strict request-response communication pattern that typically completes within seconds.
	</t>
	<t>
Other applications may experience communication failures when middleboxes destroy the per-flow state associated with an application session during periods when the application does not exchange any UDP traffic. Applications SHOULD be able to gracefully handle such communication failures and implement mechanisms to re-establish their UDP sessions.
	</t>
	<t>
Applications MAY in addition send periodic keep-alive messages to attempt to refresh middlebox state. Unfortunately, no common timeout has been specified for per-flow UDP state for arbitrary middleboxes. For NATs, <xref target="RFC4787"/> requires a state timeout of 2 minutes or longer, and it is likely that other types of middleboxes use timeouts of similar timescales. Consequently, if applications choose to send periodic keep-alives, they SHOULD NOT send them more frequently than once every two minutes. (Not that some deployed middleboxes use a shorter timeout value than 2 minutes, violating <xref target="RFC4787"/>.)
	</t>
	<t>
It is important to note that sending keep-alives is not a substitute for implementing a robust connection handling. Like all UDP messages, keep-alives can be delayed or dropped, causing middlebox state to time out. In addition, the congestion control guidelines in <xref target="ccguide"/> cover all UDP transmissions by an application, including the transmission of middlebox keep-alives. Congestion control may thus lead to delays or temporary suspension of keep-alive transmission.
	</t>
	</section>

</section>

<section title="Security Considerations" anchor="seccons">
	<t>
<xref target="RFC2309"/> and <xref target="RFC2914"/> discuss the dangers of congestion-unresponsive flows to the Internet. This document provides guidelines to designers of UDP-based applications to congestion-control their transmissions. As such, it does not raise any additional security concerns.
	</t>
</section>

<section title="IANA Considerations" anchor="ianacons">
	<t>
This document raises no IANA considerations.
	</t>
</section>

<section title="Acknowledgments" anchor="ack">
	<t>
Thanks to Mark Allman, Sally Floyd, Philip Matthews, Joerg Ott, Colin Perkins, Pasi Sarolahti and Magnus Westerlund for their comments on this document.
	</t>
	<t>
The middlebox traversal guidelines in <xref target="natguide"/> incorporate ideas from Section 5 of <xref target="I-D.ford-behave-app"/> by Bryan Ford, Pyda Srisuresh and Dan Kegel.
	</t>
</section>
</middle>

<back>
<references title='Normative References'>
	<?rfc include="reference.RFC.0768" ?>
	<?rfc include="reference.RFC.2119" ?>
	<?rfc include="reference.RFC.2914" ?>
	<?rfc include="reference.RFC.0793" ?>
	<?rfc include="reference.RFC.2960" ?>
	<?rfc include="reference.RFC.4340" ?>
	<?rfc include="reference.RFC.3448" ?>
	<?rfc include="reference.RFC.1191" ?>	
	<?rfc include="reference.RFC.1981" ?>	
	<?rfc include="reference.RFC.2988" ?>	
	<?rfc include="reference.RFC.3819" ?>	
	<?rfc include="reference.RFC.3828" ?>	
	<?rfc include="reference.RFC.4821" ?>	
</references>
<references title='Informative References'>
	<?rfc include="reference.RFC.1122" ?>
	<?rfc include="reference.RFC.1536" ?>
	<?rfc include="reference.RFC.2309" ?>	
	<?rfc include="reference.RFC.2460" ?>
	<?rfc include="reference.RFC.3048" ?>
	<?rfc include="reference.RFC.3261" ?>
	<?rfc include="reference.RFC.3551" ?>
	<?rfc include="reference.RFC.3738" ?>
	<?rfc include="reference.RFC.4654" ?>
	<?rfc include="reference.RFC.4341" ?>
	<?rfc include="reference.RFC.4342" ?>
	<?rfc include="reference.RFC.4787" ?>
	<?rfc include="reference.I-D.floyd-dccp-ccid4" ?>
	<?rfc include="reference.I-D.heffner-frag-harmful" ?>
	<?rfc include="reference.I-D.ietf-nsis-ntlp" ?>
	<?rfc include="reference.I-D.ietf-dccp-rfc3448bis" ?>
	<?rfc include="reference.I-D.ietf-tcpm-syn-flood" ?>
	<?rfc include="reference.I-D.ford-behave-app" ?>
</references>
</back>
</rfc>
