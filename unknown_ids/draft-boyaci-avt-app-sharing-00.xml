<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc category="std" ipr="full3978" 
	
    docName="draft-boyaci-avt-app-sharing-00">
	
    <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
    <?rfc toc="yes" ?>
    <?rfc symrefs="yes" ?>
    <?rfc sortrefs="yes"?>
    <?rfc iprnotified="no" ?>
    <?rfc strict="yes" ?>
	
    <!-- document starts here -->
    
    <front>
		
		<title abbrev="RTP Payload Format for App Sharing">
			RTP Payload format for Application and Desktop Sharing
			</title>
		
		<author 
			initials="O.B." surname="Boyaci" 
			fullname="Omer Boyaci">
			<organization abbrev="Columbia U.">
				Columbia University
				</organization>
            <address>
                <postal>
                    <street>Dept. of Computer Science</street>
                    <street>1214 Amsterdam Avenue</street>
                    <city>New York</city> <region>NY</region>
                    <code>10027</code>
                    <country>US</country>
					</postal>
                <email>boyaci@cs.columbia.edu</email>
				</address>
			</author>
		
		<author 
			initials="H." surname="Schulzrinne" 
			fullname="Henning Schulzrinne">
			<organization abbrev="Columbia U.">
				Columbia University
				</organization>
            <address>
                <postal>
                    <street>Dept. of Computer Science</street>
                    <street>1214 Amsterdam Avenue</street>
                    <city>New York</city> <region>NY</region>
                    <code>10027</code>
                    <country>US</country>
					</postal>
                <email>schulzrinne@cs.columbia.edu</email>
				</address>
			</author>
		
		
		<date/>
		
		<abstract>
			<t>
				This document defines a protocol to support accessing general
				graphical user interface (GUI) desktops and applications remotely,
				either by a single remote user or embedded into a multiparty
				conference.  The protocol is designed to allow sharing of, and
				access to general windowing system applications that have not been expressly written to be accessed remotely.
				
				</t>
			</abstract>
		</front>
    
    <middle>
		
		<section title="Definitions">
			<t>
				<list style="hanging">
					<t hangText="Application Host (AH):">
						An application host (AH) is the computer which runs the shared application, distributes the screen updates to
						the participants, and regenerates human interface events received from participants. 					
						</t>
					<t hangText="Participant:"> Participant is the computer which receives screen updates from AH and sends
						human interface events back to the AH. 
						Participants do not need to store or run the shared application.
						More than one participant may connect to a single AH.  
						</t>
						<t hangText="Remoting Protocol:"> Remoting protocol messages allows the AH to distribute windowing information
						and screen updates to participants.
						</t>
						<t hangText="Human Interface Protocol (HIP):">  Human Interface Protocol (HIP) 
						allows participants to send human interface device (HID) events to AH. HIDs generates mouse or keyboard 
						events such as a key press, key release, mouse move, and mouse click. </t>
						
					
					</list>
				</t>
			</section>
		
		<section title="Introduction">
			<!--
			 <t>
			 The Session Initiation Protocol (SIP) 
			 <xref target="RFC3261"/>,
			 an
			 
			 
			 TODO: mention GRUU:
			 - a Globally Routable User Agent URI (GRUU)
			 - (<xref target="I-D.ietf-sip-gruu"/>).
			 
			 <xref target="I-D.cheshire-dnsext-dns-sd"/>
			 -->
			<t>
				
				Application and desktop sharing allows sharing of any
				software application with one or more participants over the Internet. 
				The application host (AH) is the computer which runs the shared application.
				The participants receive the screen-view of the shared application
				from the AH. They do not need to run or store the shared application. 
				Their mouse and keyboard events are delivered and regenerated at the AH.
				An Application and desktop sharing system adheres to a client-server architecture
				[<xref target="figureOverallArch"/>].
										
					<figure anchor="figureOverallArch" title="Application sharing system architecture">
						<artwork>
                                   +-------------+
                                   |             |
                                   | participant |
                                   |             |
                                   +-------------+
                                       ^   |
                                       |   |
                       Screen updates  |   | HIP 
                                       |   | 
                                       |   |
                                       |   v
   +-------------+  Screen updates  +---------+ 
   |             |&lt;-----------------|         |
   | participant |                  |   AH    |      
   |             |-----------------&gt;|         |
   +-------------+        HIP       +---------+  
                                     
							</artwork>
						</figure>
</t>
				<t>
				Application and desktop sharing enables collaborative work, software tutoring,
				and e-learning over the Internet. While two-party and multi-party
				conferencing using standards-based
				protocols is now common and well-developed, protocols for sharing
				applications are largely proprietary or based on the aging T.120  
				<xref target="T120"/> suite of protocols. In this document, we 
				define an RTP payload format for application and desktop sharing.
				</t>
			<t>
				Application sharing differs from desktop sharing. In
				desktop sharing, a computer distributes all screen updates. In
				application sharing, the AH distributes screen updates if
				and only if they belong to the shared applicationâ€™s windows.
				Applications often consist of a changing set of related windows 
				which serve the same task and are usually 
				associated with the same process on the AH. Considering 
				only the boundary of the shared windows is not enough.
				Other non-shared windows may cover the shared window or shared 
				application may open new child windows such as those for 
				selecting options or fonts. A true application sharing system 
				must blank all the nonshared windows and must transfer all 
				the child windows of the shared application. 				
				</t>
			
			<t>
				We note that remote access to an
				application ("remote desktop") and multiple users sharing an
				application within a collaboration setting such as a multimedia call
				or multiparty conference are very similar. The protocols defined in this document
				therefore support both.
				</t>
			<t>
				Remote access differs from video transmission of the sort for which
				most video encodings have been designed.  In particular, screen
				encoding may need to be lossless and typically operates on artificial
				rather than natural (photographic) video input.  The video input is
				characterized by large areas of the screen that remain unchanged for
				long periods of time, while others change rapidly.  (However,
				rendering the output of a modern computer-generated animation
				application such as video games blurs the distinction between
				traditional motion video output and screen sharing.)
				</t>
			<t>
				Application
				sharing can be integrated into the existing IETF session model,
				encompassing session descriptions using the Session Description
				Protocol (SDP)  <xref target="RFC2327"/> or successors 
				and the Session Initiation Protocol (SIP) <xref target="RFC3261"/>.  
				Application sharing needs many of the same control
				functions as other multimedia sessions, such as address binding,
				session feature and media negotiation. The
				session model is also beneficial for the remote desktop case, as it
				allows to re-use many of the well-developed session components and
				easily supports hybrid multimedia models, such as the delivery of desktop audio
				to the remote user.
				</t>
			<t>
				Remote access to graphical applications and desktops, as defined in
				this document, has two important characteristics.  First, the access
				protocol is unaware of any semantic characteristics of the
				applications being shared; it only transmits the visual
				characteristics of the windows.  This is different, therefore, from
				shared-drawing or shared-editing tools that allow distributed
				modification of documents.  Secondly, the protocol is designed to
				work with applications which were not written to be used remotely, by
				intercepting or simulating their connections to their native window
				systems.  That distinguishes it from systems such as the X
				Window System <xref target="X"/> which allow natively-written applications to be
				displayed on remote viewers.
				</t>
			<t>
				We distinguish between the AH user and participants. The AH user interacts with the application using normal operating system mechanisms. 
				Participants interact via the delivery protocols described here.
				</t>
			<t>
				The application sharing problem can be divided into four components:
				(1) setting up a session to the AH, 
				(2) transporting human interface events from the participants to the AH, 
				(3) delivering screen output from the AH to the participants, 
				(4) moderating access to shared human interface devices such as pointing devices
				(e.g., mouse, joystick, trackball) and text input (keyboard).  We
				refer to component (2) as the "human interface protocol (HIP)" and 
				component (3) as the "remoting protocol". Remote user input access is moderated by 
				the Binary Floor Control Protocol (BFCP) <xref target="RFC4582"/>. 
				</t>
			<t>
				Session negotiation and description can be provided by existing
				session setup protocols. Thus, they are beyond the scope of this document. 
				</t>
			
			<t>
				The rest of this document is laid out as follows.  Section 3 defines
				the common terminology for normative references.  Section 4 gives an
				overview of the protocol's architecture and components.  The remoting 
				protocol and HIP are described in Section 5 and 6, respectively.
				Section 8 gives implementation notes, and Section 9 discusses
				security considerations.  
				</t>
			</section>
		
		<section title="Requirements Notation">
			<t> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
				"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",
				"MAY", and "OPTIONAL" in this document are to be
				interpreted as described in <xref target="RFC2119"/>.
				</t>
			</section>
		
		<section anchor="overview" title="Overview">
			<section anchor="coordinate" title="Coordinate System">
				<t>
					The origin (0,0) of the coordinate system is the upper left corner.
					All coordinates carried in the protocol messages are absolute and measured in pixels. 
				<figure anchor="coorFigure1" title="An AH shares three windows">
<artwork>
0,0                  &lt;- x axis -&gt;
 +---------------------------------------------------+
 |                                                   |   
 |    220,150                                        |      
 |       +------  A -------+                         |    
 |       |                 |        850,320          |    
 |       |                 |           +--  C ---+   |    
 |       |      450,400    |           |         |   |     
 |       |         +---------  B ----+ |         |   |    
 |       |         |                 | +---------+   |   
 |       |         |                 |               |    
 |       +---------|                 |               |    
 |                 |                 |               |                                           
 |                 +-----------------+               |    
 |                                800,700            | 
 |                                                   | 
 |                                                   |  
 +---------------------------------------------------+    
                          AH                     1280,1024
</artwork>
</figure>
<figure anchor="coorFigure2" title="Participant 1 displays the shared windows in their original coordinates">
<artwork>
0,0
 +------------------------------------------------+
 |                                                |  
 |    220,150                                     |      
 |       +------  A -------+                      |    
 |       |                 |        850,320       |    
 |       |                 |           +--  C ---+|    
 |       |      450,400    |           |         ||     
 |       |         +---------  B ----+ |         ||    
 |       |         |                 | +---------+| 
 |       |         |                 |            |    
 |       +---------|                 |            |    
 |                 |                 |            |                                            
 |                 +-----------------+            |    
 |                                800,700         |     
 +------------------------------------------------+    
                    Participant-1             1024,768
</artwork>
</figure>
<figure anchor="coorFigure3" title="Participant 2 displays the shared windows in shifted coordinates">
<artwork>
0,0                        
 +------  A -------+---------------------------------+    
 |                 |        630,170                  |    
 |                 |           +--  C ---+           |    
 |      230,250    |           |         |           |        
 |         +---------  B ----+ |         |           |    
 |         |                 | +---------+           |    
 |         |                 |                       |    
 +---------|                 |                       |    
 |         |                 |                       |                                           
 |         +-----------------+                       |    
 |                         580,550                   |
 |                                                   | 
 |                                                   | 
 |                                                   | 
 |                                                   |   
 +---------------------------------------------------+    
                  Participant-2                 1280,1024
</artwork>
</figure>
<figure anchor="coorFigure4" title="Participant 3 displays the shared windows in completely different coordinates">
<artwork>
0,0                        
 +------  A -------+----------+    
 |                 |          |    
 |  60,180      +--  C ---+   |    
 |    +---------  B ----+ |   |  
 |    |                 | |   |    
 |    |                 |-+   |    
 |    |                 |     |                                           
 +----|                 |     |    
 +----+-----------------+-----+    
          Participant-3    640,480
							</artwork>
						</figure>
					<xref target="coorFigure1"/> shows an example scenario where three windows are shared. 
					All coordinates are absolute.
				      A participant can display the windows in their original coordinates or it can
					display them in different coordinates. In <xref target="coorFigure2"/>, participant 1 displays
					the windows in their original coordinates. 
					Participant 2 shifts all the windows 220 pixels left and 150 pixels up <xref target="coorFigure3"/>.
					Participant 2 preserves the relations between windows, 
					while participant 3 combines all the windows in order to fit them to its small screen <xref target="coorFigure4"/>.
					In this example scenario, all participants preserve the z-order of windows.
					The AH informs the participants about windows' positions and sizes, z-order, and their groupings.
					The AH MAY assign same group identifier to the windows which belongs to the same process. 
					Grouping information MAY be used by the participant while relocating the windows or enforcing the z-order. 			 	
					A participant MAY allow changing the z-order (i.e., stacking order) of windows locally, without changing the z-order in the AH.
					Several remoting/HIP message types carries left, top, width and height fields. 
					The units of these fields are in pixels and they are unsigned. 
								    
					</t>
					<t>	
					The AH MUST only accept legitimate HIP events by checking whether 
					the requested coordinates are inside the shared windows. 
					</t>
				</section>

			<section anchor="overviewarch" title="Operation">
				<t>
					Detecting a change in the GUI of the shared
					application, the AH prepares an RTP <xref target="RFC3550"/>
					packet containing an encoded image of the updated region. RTP allows
					the participants to re-order the packets, recognize missing packets
					and synchronize application sharing with other media
					types like audio and video. The screen updates can be encoded
					with PNG <xref target="I-D.boyaci-avt-png"/>, 
					JPEG <xref target="RFC2435"/>, JPEG 2000 <xref target="RFC5371"/>, Theora <xref target="theora"/> or other 
					media types like H.264 <xref target="RFC3984"/>, according to their characteristics. 
					PNG is an open image format which uses a lossless compression algorithm 
					and more suitable for computer generated images. 
					JPEG is lossy, but more suitable for photographic images. 
					JPEG 2000 supports both lossless and lossy compression, therefore suitable for both computer generated images and movies. 
					Theora is an open source video codec comparable to H.264 and suitable for movie encoding. 
					</t>
				
					<t>
					Although multiple users could receive the screen updates
					simultaneously, clearly only one of them can manipulate the
					application via keyboard and mouse events. The
					Binary Floor Control Protocol (BFCP) <xref target="RFC4582"/>
					MAY be used to restrict the control of the application to a single user. 
					BFCP receives floor request and floor release messages from participants; and
					then it grants the floor to the appropriate participant for a period
					of time while keeping the requests from other participants
					in a FIFO queue. The details of utilizing BFCP in the context of application
					and desktop sharing are given in <xref target="appendix"/>.
					</t>
					
				<t>
					The protocol supports two different mouse pointer models. Mouse pointer images
					can be transmitted as RegionUpdate messages or they may be transmitted seperately
					as MousePointerInfo messages. The AH decides which mouse model to use. 
					The participants MUST support both mouse models.  
					</t>
				
				<t> 
					HIP supports both UTF-8 encoded unicode characters and other keyboard keys which are 
					not defined in unicode such as function and control keys. For keyboard events
					publicly available Java virtual key codes <xref target="keycodes"/> are used. 
					</t>
				
				<t>
					The application and desktop sharing models defined in this document
					can be integrated into the IETF conferencing model. The
					Session Initiation Protocol (SIP) [9] can be used to intiate and control
					remote access. This allows the use of existing SIP mechanisms for
					confidentiality, authentication and authorization, user location,
					conferencing.
					</t>
				
					<t>
					Additional, optional mechanisms can enhance application and desktop sharing.  
					Audio streams can be associated with a desktop or application; participant-side
					scaling can be used to optimize transmission of data to
					participants with a small screen; and it is often useful to allow
					copy-and-paste between applications running on a participant and those
					running on an AH.  This document does not define any
					such extensions.
					</t>
					<t>
					The AH can support both multicast and unicast transmissions.
					For unicast connections, either UDP or TCP can be
					used. The AH can share an application to TCP participants,
					UDP participants, and several multicast addresses in the same
					sharing session.
					</t>
			</section>
			<section anchor="overviewudparch" title="Participants using UDP">
					<t>
					The AH controls the transmission rate for participants using UDP, 
					because UDP itself does not provide flow and congestion
					control. Several simultaneous multicast sessions with
					different transmission rates can be created at the AH.
					</t>
					<t>
					Participants can join a sharing session anytime, and they
					need the shared windows' information and full screen buffer before receiving partial updates.
					Therefore, participants using UDP send an RCTP-based feedback message, 
					Picture Loss Indication (PLI) <xref target="RFC4585"/>, after joining the session. 
					The AH prepares and transmits the windows' state information and image of the whole
					shared region after receiving a PLI message.
					</t>
					
					</section>
			<section anchor="overviewtcparch" title="Participants using TCP">
					<t>
					Since TCP provides reliable communication and flow
					control, it is more suitable for unicast sessions. TCP participants
					may have different bandwidths, so an algorithm which sends 
					the updates at the link speed of each participant is needed.
					</t>
					<t>
					Neither TCP nor RTP declares the length of an RTP packet. Therefore,
					RTP framing <xref target="RFC4571"/> is used to split RTP packets within
					the TCP byte stream. 
					</t>
					<t>
					The AH prepares and transmits the windows' state information and image of the whole
					shared region to the new participant, right after the TCP connection
					establishment. 
				</t>
				
				
				</section>
				<section anchor="protoOverview" title="Protocol Overview">
				<t>
					Application and desktop sharing protocol consists of two subprotocols: 
					remoting and human interface protocol (HIP). 
					Remoting messages transmit screen updates from AH to participants.
					HIP messages transmit mouse and keyboard events from the participant to the AH.
				</t>
				<t>
					Remoting and HIP messages are RTP messages. 
					They consist of an RTP header, common remoting/HIP header,
					message-type specific header, and message payload [<xref target="figuremsgstructure"/>]. 
					The HIP messages have a different payload type than the remoting messages.
					 
					<figure anchor="figuremsgstructure" title="Application sharing protocol message structure">
					<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.                                                               .
.                          RTP header                           .
.                                                               .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Common remoting/HIP header                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.                                                               .
.                  Message-type specific header                 .
.                                                               .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.                                                               .
.                                                               .
.                    Message Specific Payload                   .
.                                               +-+-+-+-+-+-+-+-+
.                                               |                
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     		
						</artwork>
					</figure>
					</t>
				<section anchor="remotingOverview" title="Remoting Protocol Overview">
					<t> 
						The remoting protocol consists of four messages from the AH to the participant 
						and two control messages from participant to AH. The AH-to-participant
						messages are WindowStateInfo, RegionUpdate, 
						MoveRectangle, and MousePointerInfo. The RTCP messages from
						UDP-based participant to AH are "Picture loss indication (PLI)" and "NACK request".
						Participants MUST implement all protocol messages described in this document.
						</t>
					<t>
						The WindowManagerInfo message informs the participants about the windowIDs of the windows, 
						their positions and sizes, z-order, and their groupings.
						All remoting messages carry the windowID to identify the target of message. 
						For TCP participants, the AH transmits WindowManagerInfo message right after 
						establishing a connection. UDP participants send a "Picture loss indication (PLI)"
						to the AH as soon as they join the session. Receiving this PLI message,
						the AH transmits WindowManagerInfo message. 
						The AH transmits RegionUpdate messages for updated regions.
						Whenever the shared window resizes or relocates, the AH sends a WindowManagerInfo message. 
						Similarly, if the z-order of windows changes, the AH send a WindowManagerInfo message.
						MoveRectangle instructs the participant to move a region from one place to another, which
						is efficient for some drawing operations like scrolls.
						The MousePointerInfo message transmits the position and icon of the mouse pointer.
						Some AHs may transmit pointer images inside the RegionUpdate
						messages, so they may not need MousePointerInfo message. 
												</t>
					<t>
						"Picture loss indication (PLI)" and "NACK request" are control messages and they 
						are transmitted as RTCP messages. The "NACK request" is used only by UDP participants to request
						retransmission of missing packets from the AH. AHs MAY support retransmissions.
						PLI can be used by both UDP and TCP participants to request a full screen refresh. 
						</t>
					
						
						
					</section>
				<section anchor="kmOverview" title="Human Interface Protocol (HIP) Overview">
					<t>
						HIP consist of seven messages: namely,
						Mouse Pressed, Mouse Released, Mouse Moved, Mouse Wheel Moved,
						Key Pressed, Key Released and Key Typed.  
						These messages are all from AH to participant and carried as RTP messages. 
						However, these HIP messages have different payload type 
						than the remoting messages. 
						</t>	
					</section>
				
				</section>
			
			</section>
		
		
		
		<section anchor="remotingProto" title="Remoting Protocol">
			<section anchor="remotingProtoFormat" title="Payload Format">
				<section anchor="remotingProtoRTPHeader" title="RTP Header Usage">
					<t>
						<list style="hanging">
							<t hangText="Marker bit:">
								The marker bit indicates the last packet of a multi-packet RegionUpdate (<xref target="regionupdate"/>
								message. The marker bit allows the receiver to finish decoding the picture, without
								waiting for the next packet with a new timestamp. Unless defined otherwise, all other
								message types MUST set this bit to zero
								</t>
							<t hangText="Timestamp:">The RTP timestamp indicates the time instance the remoting message 
								has been created at the AH. The RTP timestamp is based on a 90-kHz clock. 
								If a RegionUpdate message occupies
								more than one packet, the timestamp SHALL be the same for all of
								those packets.  Furthermore, the initial value of the timestamp MUST be
								random (unpredictable) to make known-plaintext attacks more
								difficult <xref target="RFC3550"/>.
								</t>
							
							
							</list>
						
						The remaining RTP header fields are used as specified in RFC 3550.
					</t>
					</section>
				<section anchor="remotingProtoHeader" title="Common remoting/HIP header">
					<t>
						All remoting protocol messages carry a common remoting/HIP header
						[<xref target="figureremotingProtoHeader"/>] which follows the RTP header.
						Message type and parameter fields are 8 bit identifiers, 
						whereas the windowID is a 16-bit identifier. The 
						windowID field is unsigned and has a range of 0-65535. 
						 
						
						<figure anchor="figureremotingProtoHeader" title="Common remoting/HIP header">
							<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Msg Type     |    Parameter  |          WindowID             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
								</artwork>
							</figure>	
						</t>
						<t>
						<xref target="table_remotingmessagetypes"/> enumerates the message types defined in this document. Participants MUST
						implement all of them. <xref target="iana"/> describes how additional message types can be registered with IANA. 
						Participants MAY ignore such additional message types.
						</t>
						<texttable anchor="table_remotingmessagetypes" title="Remoting protocol message types">
						<ttcol align="center">Value</ttcol>
						<ttcol align="left">Message Type</ttcol>
						<c>1</c><c>WindowManagerInfo</c>
						<c>2</c><c>RegionUpdate</c>
						<c>3</c><c>MoveRectangle</c>
						<c>4</c><c>MousePointerInfo</c>
						</texttable>
					
						
					</section>
				     
				</section>

<section anchor="AHtoparticipantmsg" title="AH-to-participant messages">
						<!--
						<section anchor="newwindow" title="OpenNewWindow">
							<t>
								The OpenNewWindow message instructs the participant to open a new window. The "WindowID" field
								identifies the newly created window. The AH
								will then draw to this window with RegionUpdate messages. This message does not
								carry any message specific payload. The participant should keep this window open 
								until a CloseWindow message for this window arrives from the AH. 
							</t>
							</section>
						<section anchor="closewindow" title="CloseWindow">
							<t>
								The CloseWindow message instructs the participant to close an existing window identified by the 
								windowID. This message does not carry any message specific payload.  
							</t>
							</section>
						<section anchor="windowsize" title="WindowSizeUpdate">
							<t>
								The WindowSizeUpdate message instructs the participant to change the size of 
								an existing window identified by the windowID. This message 
								carries a message specific payload. The "Width" and "Height" fields 
								carries the new width and the height of the window, respectively. The units
								are in pixels and they are unsigned. 
								<figure anchor="figuresizeheader" title="Message specific payload for window size update">
									<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Width                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Heigth                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
										</artwork>
									</figure>	  
							</t>
							</section>
							-->
							<section anchor="windowmanagerinfo" title="WindowManagerInfo">
							<t>
								The WindowManagerInfo message informs the participants about windows, 
								their positions and sizes, z-order, and their groupings.
								This message transfers the complete window manager state to the participants.
								Each shared window resize and relocation in any coordinate triggers a
								WindowmangerInfo message. 
								Parameter and WindowID fields of common remoting/HIP header MUST be ignored. 
								This message carries a message specific payload. 
								One or more window records [<xref target="figurewindowrecord"/>] follow the common
								remoting/HIP header. 
								<figure anchor="figurewindowrecord" title="A Window Record">
									<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            WindowID           |   GroupID     |   Reserved    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Left                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Top                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Width                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Height                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
										</artwork>
									</figure>	
								Each window record is 20-bytes. The z-order information is given implicitly to the participants. 
								The first record describes the window at the bottom of the stacking order, the last
								record the one on top. The "left" and "Top" fields carries the upper-left coordinate of the window.
								The "Width" and "Height" fields carries the width and the height of the window, respectively. 
								Each window is assigned a WindowID.
								The participant MUST create a window for each new WindowID and MUST close this window
								after receiving a WindowManagerInfo message which does not contain this WindowID. 
								GroupID fields informs the participant about grouping of windows. 
								The AH MAY assign same GroupID to the windows which belongs to the same process. 
								Grouping information MAY be used by the participant while relocating the windows or enforcing the z-order.
								The value of "0" for GroupID field is reserved and represents no grouping for given window.  
								</t>
								<t>
								<xref target="figurewindowmanager"/> is an example WindowManagerInfo message
								for the three shared windows in <xref target="coorFigure1"/>. The participant MUST keep the 
								existing window image after a resize and relocation.  
  <figure anchor="figurewindowmanager" title="An example WindowManagerInfo message with three Window Records">
									<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Msg Type = 1  | Parameter = 0 |          WindowID = 0         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          WindowID = 1         |  GroupID = 1  |  Reserved = 0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Left = 220                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Top = 150                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Width = 350                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Height = 450                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         WindowID = 2          |  GroupID = 2  |  Reserved = 0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Left = 850                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Top = 320                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Width = 160                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Height = 150                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         WindowID = 3          |  GroupID = 1  |  Reserved = 0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Left = 450                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Top = 400                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Width = 350                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Height = 300                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
										</artwork>
									</figure>	
							</t>
							</section>
						<section anchor="regionupdate" title="RegionUpdate">
							<t>
								The RegionUpdate message instructs the participant to update the specified region of 
								a window with new content. This message carries a message-type specific header and payload. 
								This protocol supports all media types which have an RTP payload specification. It is possible that
								AH or participant may support only some media types. Therefore, they should negotiate supported
								media types during the session establishment. 
								The 8 bit "parameter" field of the common remoting/HIP header will carry both the FirstPacket bit
								and the actual payload type of the content. 
								The 7 bit PT field carries the actual payload type of the content which
 								can be PNG, JPEG, Theora, or any other media type which has an RTP payload specification.  
								All AH and participant software implementations MUST support PNG images <xref target="I-D.boyaci-avt-png"/>. 
								The message-type specific header follows common remoting/HIP header. Message-type specific 
								header consists of two 32 bit parameters, left and top. These two parameters informs the participants
								about the left-top coordinate of the RegionUpdate. The width and height of the RegionUpdate is not
								transmitted explicitly by this protocol.  
								<figure anchor="figureregionupdateHeader" title="Common remoting/HIP header for RegionUpdate messages">
										<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| RegionUpdate  |F|      PT     |          WindowID             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
											</artwork>
										</figure>																							
								If the content of the update does not fit into a single
								RTP message, it will be carried in several RTP payloads. 
								All the payloads will carry the 32 bit common remoting/HIP header, while left and top
								fields are carried only in the first RTP payload.
								The marker bit and FirstPacket bit informs the particapants about the fragmentation.
								</t>
								<texttable anchor="table_fragmentation" title="Marker and FirstPacket bits carry fragmentation info">
						<ttcol align="center">Marker bit</ttcol>
						<ttcol align="center">FirstPacket bit</ttcol>
						<ttcol align="left">Fragment Type</ttcol>
						<c>1</c><c>1</c><c>Not Fragmented</c>
						<c>0</c><c>1</c><c>Start Fragment</c>
						<c>0</c><c>0</c><c>Continuation Fragment</c>
						<c>1</c><c>0</c><c>End Fragment</c>
						</texttable>
								<t>
								<xref target="regionupdateheader"/> displays an example RegionUpdate message. The RTP header is omitted
								in <xref target="regionupdateheader"/>. The RegionUpdate
								is non fragmented, therefore both the marker bit in the RTP header and FirstPacket bit in the payload
								header is set to 1. 
								<figure anchor="regionupdateheader" title="An example non fragmented RegionUpdate message">
									<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Msg Type = 2 |1|      PT     |          WindowID = 1         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Left                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Top                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.                                                               .
.                                                               .
.                            Payload                            .
.                                               +-+-+-+-+-+-+-+-+
.                                               |                
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   
										</artwork>
									</figure>	  
									
								
								</t>
								
							</section>
						<section anchor="moverect" title="MoveRectangle">
							<t>
								The MoveRectangle message instructs the participant to move the specified region of 
								a window to a new position. This message carries a message-type specific header. 
								The AH informs the participants about the source rectangle via source left, source top, width and height 
								parameters. Participants learns the destination coordinates from destination left and destination top
								parameters. Source and destination rectangles may overlap.    
								 
								<figure anchor="moverectheader" title="Message specific payload for move rectangle">
									<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Source Left                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Source Top                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Width                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Heigth                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Destination Left                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Destination Top                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
										</artwork>
									</figure>	  
								</t>
							</section>
						<section anchor="mouusepointer" title="MousePointerInfo">
							<t>
								Some AHs MAY include the mouse pointer image inside the RegionUpdate messages. 
								However, some AHs MAY choose to inform the participant about the mouse position and icon explicitly.
								If the RegionUpdate messages contain the mouse pointer icon, then
								the MousePointerInfo message is unnecessary.
								When receiving this message, the participant should draw the mouse pointer to the given position.
								This message carries a message specific payload. 
								The format of this message is same as RegionUpdate message <xref target="regionupdate"/> 
								except they have different message types.
								The payload of MousePointerInfo message can be only the left and top coordinates.
								In this case, the participant MUST move the existing pointer image to the given coordinates.
								Payload MAY carry both the left and top coordinates and the new image of the mouse pointer.  
								The participant MUST store and use this image until a new image arrives from the AH.
								If the AH uses MousePointerInfo messages, it MUST inform the late joiners about the current
								position and image of mouse pointer.    
								</t>
							</section>
						</section>
					<section anchor="participanttoAHmsg" title="Participant-to-AH Messages">
							<t>	
								Participants using UDP can send two RTCP messages to the AH. Late-joiners MAY inform the
								AH using the "Picture loss indication (PLI)" message in order to receive a full screen update.
								For the missing
								packets, UDP participants MAY send a "NACK Request".
								</t>
							<section anchor="pli" title="Picture Loss Indication (PLI)">
								<t>
									"Picture Loss Indication (PLI)" message instructs the AH to generate a full screen update
									of the shared region. Before the full screen update, the AH will send a WindowManagerInfo message to
									inform the new participant about windows. Both TCP and UDP participants MAY transmit this message.
									The message format conforms to the "Picture Loss Indication (PLI)"
									section 6.3.1 of <xref target="RFC4585"/>.       
									</t>
								</section>
							<section anchor="nack" title="NACK Request">
								<t>
									"NACK Request" message informs the AH about missing RTP packets. The message format 
									conforms to the "Generic NACK" section 6.2.1 of <xref target="RFC4585"/>. Multicast participants and AHs
									MAY take necessary precautions to prevent NACK storms such as waiting random amount of time before
									sending a "NACK Request" message.       
									
									
									</t>
								</section>
							
						
						
						</section>
			</section>
		
	
	
	
	
  
		
	
	
		<!--
		<section anchor="bfcpProto" title="Floor Control Protocol">
			<t>
				Application and desktop sharing protocol utilizes 
				three BFCP messages from AH to participant [<xref target="bfcpAHtoparticipant2"/>] and two
				BFCP messages from participant to AH [<xref target="bfcpparticipanttoAH2"/>]. 
				</t>
			<texttable anchor="bfcpAHtoparticipant2"> 
				<ttcol align="left">BFCP messages from AH to participants</ttcol> 
				<c>Floor Granted</c> 
				<c>Floor Released</c> 
				<c>Floor Request Queued</c> 
				</texttable>
			
			<texttable anchor="bfcpparticipanttoAH2"> 
				<ttcol align="left">BFCP messages from participants to AH</ttcol> 
				<c>Floor Request</c> 
				<c>Floor Release</c>
				</texttable>
			<t>
				According to the RFC 4582 <xref target="RFC4582"/>, BFCP packets consist 
				of a 12-octet common header followed by attributes.  All the protocol values MUST be sent in network byte
				order. The following is the format of the common header.
				<figure anchor="bfcpheader" title="COMMON-HEADER format for BFCP messages">
					<artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Ver |Reserved |  Primitive    |        Payload Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Conference ID                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Transaction ID        |            User ID            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						</artwork>
					</figure>
				<list style="hanging" hangIndent="15"> 
					<t hangText="Ver   :">The 3-bit version field MUST be set to 1 to indicate this
						version of BFCP.
						</t>
					<t hangText="Reserved   :">At this point, the 5 bits in the reserved field SHOULD be
						set to zero by the sender of the message and MUST be ignored by the
						receiver.
						</t>
					<t hangText="Primitive   :">This 8-bit field identifies the main purpose of the
						message. Although 13 primitives are defined in RFC 4582 <xref target="RFC4582"/>, three of them are used 
						in this document. 
						<figure anchor="bfcpprimitive" title="BFCP primitives">
							<artwork><![CDATA[
									
             +-------+--------------------+------------------+
             | Value | Primitive          | Direction        |
             +-------+--------------------+------------------+
             |   1   | FloorRequest       | P -> S           |
             |   2   | FloorRelease       | P -> S           |
             |   4   | FloorRequestStatus | P <- S           |
             +-------+--------------------+------------------+
                         S:  Floor Control AH
                         P:  Floor Participant
								]]></artwork>
							</figure>
						</t>
					<t hangText="Payload Length:">This 16-bit field contains the length of the message
						in 4-octet units, excluding the common header.
						</t>
					
					<t hangText="Conference ID:">This 32-bit field identifies the conference the
						message belongs to. This field MUST be set to 0.
						</t>
					<t hangText="Transaction ID:">This field contains a 16-bit value that allows users
						to match a given message with its response.  The value of the
						Transaction ID in AH-initiated transactions is 0 (see Section 8 of <xref target="RFC4582"/>).
						</t>
					<t hangText="User ID:">This field contains a 16-bit value that uniquely identifies
						a participant within a conference.
						</t><t>
							The identity used by a participant in BFCP, which is carried in
							the User ID field, is generally mapped to the identity used by the
							same participant in the session establishment protocol (e.g., in
							SIP).  The way this mapping is performed is outside the scope of
							this specification.
							</t>
					</list>
				The common header is followed by a number of attributes. BFCP attributes 
				are encoded in TLV (Type-Length-Value) format. Attributes are 32-bit aligned.
				<figure anchor="bfcpattributes" title="Attribute format">
					<artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type     |M|    Length     |      Attribute Contents       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						</artwork>
					</figure>
				
					<list style="hanging" hangIndent="15">
					<t hangText="Type              :">This 7-bit field contains the type of the attribute.</t>
					<t hangText="M                 :">The "M" bit SHOULD be set to zero.</t>
				    <t hangText="Length            :">This 8-bit field MUST be set to 4.</t>
					<t hangText="Attribute Contents:"> The contents of the different attributes are
					defined in the following sections.</t>
					</list>
				</t>
			
			<section anchor="bfcpparticipanttoAHmsg" title="participant to AH BFCP messages">
				<t>
					participants send "Floor Request" and "Floor Release" messages to the AH. Both of these messages include a single
					attribute after the common header. 
					</t>
				<section anchor="bfcpRequest" title="Floor Request">
					<t>
						participant sends this message to request the control of AH"s keyboard and mouse. 
						The values of different common header fields are given below. All the other fields MUST be set 
						according to <xref target="bfcpheader"/>.
						<list style="hanging" hangIndent="15"> 
							<t hangText="Primitive   :">MUST be set to 1 for FloorRequest primitive.</t>
							<t hangText="Payload Length:">1</t>
							</list>
						"Floor Request" message carries a single attribute, FLOOR-ID. The values of the attribute are given below.
						<list style="hanging" hangIndent="15">
							<t hangText="Type              :">MUST be set to 2 for FLOOR-ID attribute.</t>
							<t hangText="Attribute Contents:">MUST be set to 0.</t>
							</list>
						
						</t>
					</section>
				<section anchor="bfcprelease" title="Floor Release">
					<t>
						The AH grants the control of keyboard and mouse via "Floor Granted" message which will be discussed shortly. 
						participant sends "Floor Release" message to release the control of AH"s keyboard and mouse. 
						The values of different common header fields are given below. All the other fields MUST be set 
						according to <xref target="bfcpheader"/>.
						<list style="hanging" hangIndent="15"> 
							<t hangText="Primitive   :">MUST be set to 2 for FloorRelease primitive.</t>
							<t hangText="Payload Length:">1</t>
							</list>
						"Floor Request" message carries a single attribute, FLOOR-REQUEST-ID. The values of the attribute are given below.
						<list style="hanging" hangIndent="15">
							<t hangText="Type              :">MUST be set to 3 for FLOOR-REQUEST-ID attribute.</t>
							<t hangText="Attribute Contents:">MUST be set to FLOOR-REQUEST-ID assigned by the AH in the "Floor Granted" message.</t>
							</list>
						</t>
					</section>
				</section>
			
			<section anchor="bfcpAHtoparticipantmsg" title="AH to participant BFCP messages">
				<t>
				BFCP AH sends three different messages to the participants. All messages carry the same primitive, FloorRequestStatus. 
				However, their attribute values are different. 
				</t>
				<section anchor="bfcpok" title="Floor Granted">
					<t>
					The AH sends this message to grant the keyboard and mouse control to a participant. The AH SHOULD utilize a 
					FIFO queue to store "Floor Request" messages. After receiving a "Floor Release" message from the current holder of floor,
					the AH SHOULD grant the floor to the next participant of the FIFO queue. The AH MAY implement different policies for
					floor holding. For example, it may grant the floor for some period of time or it may grant the floor to the next participant after
					a period of inactivity from the current holder. The values of different common header fields are given below.
					All the other fields MUST be set according to <xref target="bfcpheader"/>. 
						<list style="hanging" hangIndent="15"> 
							<t hangText="Primitive   :">MUST be set to 4 for FloorRequestStatus primitive.</t>
							<t hangText="Payload Length:">4</t>
							</list>
						The common header is followed by four attributes. Each of these attributes is 4 octet length; 
						therefore, length fields MUST be set to 4. 
						<list style="hanging" hangIndent="15"> 
							<t hangText="FLOOR-REQUEST-INFORMATION-HEADER:">Floor Request ID is assigned by the AH. 
							participant SHOULD use this value in the "Floor Release" message.
							</t>
							<t hangText="FLOOR-REQUEST-STATUS-HEADER     :">Floor ID field of FLOOR-REQUEST-STATUS-HEADER 
							MUST be set to 0.
							</t>
							<t hangText="REQUEST-STATUS                  :">REQUEST-STATUS has two 8-bits fields
						"Request Status" and "Queue Position". "Request Status" MUST be set to 3 for "Granted" status.
						The "Queue Position" MUST be set to 0 for this message.
						</t>
							<t hangText="STATUS-INFO                     :">STATUS-INFO informs the participant
						about the status of keyboard and mouse. The AH may temporarily block the keybard or 
						mouse actions without revoking the floor control.
						The AH periodically checks whether the shared application has the focus, for keybard and mouse, or not. 
						Whenever the shared application loses the focus, the AH temporarily blocks remote events.
						K&amp;M Status values are defined as:</t>
						</list>
						
						
						</t>
					<texttable anchor="table_example" title="K&amp;M Status Values">
						<ttcol align="center">Value</ttcol>
						<ttcol align="left">Status</ttcol>
						<c>0</c><c>STATE_NOT_ALLOWED</c>
						<c>1</c><c>STATE_KEYBOARD_ALLOWED</c>
						<c>2</c><c>STATE_MOUSE_ALLOWED</c>
						<c>3</c><c>STATE_ALL_ALLOWED</c>
						</texttable>
					<t>
							The packet format of the attributes are given below. The AH SHOULD assign a "Floor Request ID" and 
							SHOULD inform the participant about the current "KM Status". The participant MAY receive several "Floor Granted"
							messages with different "K&amp;M Status" values. participant application SHOULD inform the user about "K&amp;M Status".
							<figure anchor="figurebfcpok" title="Attribute format">
							<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 1 1 1 1|M|0 0 0 0 0 1 0 0|       Floor Request ID        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 1 0 0 0 1|M|0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 0 1 0 1|M|0 0 0 0 0 1 0 0|0 0 0 0 0 0 1 1|0 0 0 0 0 0 0 0|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 1 0 0 1|M|0 0 0 0 0 1 0 0|           KM Status           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
								</artwork>
								</figure>
						</t>
					</section>
					
					
				<section anchor="bfcpqueued" title="Floor Request Queued">
					<t>
						The AH sends this message to inform the participant that it"s "Floor request" message is queued.
						The participant MAY receive several "Floor Request Queued" messages with different "Queue Position" values.
						The participant application MAY inform the user about the queue position.
						The values of different common header fields are given below.
						All the other fields MUST be set according to <xref target="bfcpheader"/>. 
						<list style="hanging" hangIndent="15"> 
							<t hangText="Primitive   :">MUST be set to 4 for FloorRequestStatus primitive.</t>
							<t hangText="Payload Length:">3</t>
							</list>
						The common header is followed by three attributes. Each of these attributes is 4 octet length; 
						therefore, length fields MUST be set to 4. 
						<list style="hanging" hangIndent="15"> 
							<t hangText="FLOOR-REQUEST-INFORMATION-HEADER:">Floor Request ID is assigned by the AH.
								</t>
							<t hangText="FLOOR-REQUEST-STATUS-HEADER     :">Floor ID field of FLOOR-REQUEST-STATUS-HEADER 
								MUST be set to 0.
								</t>
							<t hangText="REQUEST-STATUS                  :">REQUEST-STATUS has two 8-bits fields
								"Request Status" and "Queue Position". "Request Status" SHOULD be set to 2 for "Accepted" status.
								The AH SHOULD set the "Queue Position" to the queue position of this request. 
								</t>
							
							</list>
						
							The packet format of the attributes are given below. The AH SHOULD assign a "Floor Request ID".
							<figure anchor="figurebfcpqueued" title="Attribute format">
								<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 1 1 1 1|M|0 0 0 0 0 1 0 0|       Floor Request ID        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 1 0 0 0 1|M|0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 0 1 0 1|M|0 0 0 0 0 1 0 0|0 0 0 0 0 0 1 0|Queue Position |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
									</artwork>
								</figure>
							</t>
						</section>
				
				
					<section anchor="bfcpreleased" title="Floor Released">
						<t>
							The AH sends this message to revoke the keyboard and mouse control from a participant. 
							The participant MAY voluntarily release the floor by sending a "Floor Release" message. 
							The AH MAY revoke the floor anytime according to its policies. For example, it may
							revoke the floor from current holder after a period of inactivity.  
							The values of different common header fields are given below.
							All the other fields MUST be set according to <xref target="bfcpheader"/>. 
							<list style="hanging" hangIndent="15"> 
								<t hangText="Primitive   :">MUST be set to 4 for FloorRequestStatus primitive.</t>
								<t hangText="Payload Length:">3</t>
								</list>
							The common header is followed by three attributes. Each of these attributes is 4 octet length; 
							therefore, length fields MUST be set to 4. 
							<list style="hanging" hangIndent="15"> 
								<t hangText="FLOOR-REQUEST-INFORMATION-HEADER:">Floor Request ID is assigned by the AH.
									</t>
								<t hangText="FLOOR-REQUEST-STATUS-HEADER     :">Floor ID field of FLOOR-REQUEST-STATUS-HEADER 
									MUST be set to 0.
									</t>
								<t hangText="REQUEST-STATUS                  :">REQUEST-STATUS has two 8-bits fields
									"Request Status" and "Queue Position". "Request Status" SHOULD be set to 6 for "Released" status.
									The AH MAY set "Request Status" to 7 for "Revoked". participant SHOULD be able to understand both 
									"Released" and "Revoked" messages. The "Queue Position" MUST be set to 0 for this message.
									</t>
								
								</list>
							
								The packet format of the attributes are given below.
								<figure anchor="figurebfcpreleased" title="Attribute format">
									<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 1 1 1 1|M|0 0 0 0 0 1 0 0|       Floor Request ID        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 1 0 0 0 1|M|0 0 0 0 0 1 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 0 1 0 1|M|0 0 0 0 0 1 0 0|0 0 0 0 0 1 1 0|0 0 0 0 0 0 0 0|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
										</artwork>
									</figure>
								</t>
							</section>
						</section>
					</section>
		-->				
	
	<section anchor="kmProto" title="Human Interface Protocol (HIP)">
	<t>
					Participants MAY send human interface events to the AH in order to interact with the shared application.
					</t>

	<section anchor="kmProtoFormat" title="Payload Format">
				<section anchor="kmProtoRTPHeader" title="RTP Header Usage">
					<t>
						<list style="hanging">
							<t hangText="Marker Bit:">
								The marker bit MUST be set to zero by the participant and ignored by the AH.
								</t>
							<t hangText="Timestamp:">The RTP timestamp indicates when the 
							 keyboard or mouse event occurred at the participant. 
							 The RTP timestamp of HIP messages is based on a 90-kHz clock. 
							 The initial value of the timestamp MUST be
							 random (unpredictable) to make known-plaintext attacks on encryption more
							 difficult; see RTP <xref target="RFC3550"/>.
 
								</t>
							</list>
						
						The remaining RTP header fields are used as specified in RFC 3550.
					</t>
					</section>
				<section anchor="kmProtoHeader" title="Common remoting/HIP header">
					<t>

						All HIP messages carry the same common remoting/HIP header
						shown in <xref target="figureremotingProtoHeader"/> and discussed in 
						<xref target="remotingProtoHeader"/>. The WindowID parameter indicates the window where 
						the keyboard or mouse event took place, i.e., the window that had keyboard or mouse focus.
						</t>
						<t>
						The following HIP message types are defined:
						</t>
						<texttable anchor="table_hipmessagetypes" title="HIP Message Types">
						<ttcol align="center">Value</ttcol>
						<ttcol align="left">Message Type</ttcol>
						<c>121</c><c>MousePressed</c>
						<c>122</c><c>MouseReleased</c>
						<c>123</c><c>MouseMoved</c>
						<c>124</c><c>MouseWheelMoved</c>
						<c>125</c><c>KeyPressed</c>
						<c>126</c><c>KeyReleased</c>
						<c>127</c><c>KeyTyped</c>
						</texttable>
					</section>
				</section>
				
<section anchor="mousepressed" title="MousePressed">
					<t>
						The MousePressed message instructs the AH to generate a mouse pressed event
						at the given coordinates of the screen. This message carries a message-type specific header.
						The "parameter" field of the common remoting/HIP header carries the mouse button information. 
						The values of 1, 2 and 3 are defined for left, right, and middle button, respectively. 
						The AH and participant MAY negotiate additional values for other mouse buttons.
						The AH MAY ignore unrecognized values.  
						<figure anchor="mousepressedheader" title="Message specific payload for mouse pressed">
					<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Left                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Top                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						</artwork>
					</figure>	  
							
						</t>
					</section>
					<section anchor="mousereleased" title="MouseReleased">
					<t>
						The MouseReleased message instructs the AH to generate a mouse released event
						at the given coordinates of the screen. This message carries a message-type specific header.
						The "parameter" field of the common remoting/HIP header carries the mouse button information. 
						The values of 1, 2 and 3 are defined for left, right, and 
						middle button, respectively. Other values MAY be defined for other mouse buttons. The AH MAY
						ignore unrecognized values.   
						<figure anchor="mousereleasedheader" title="Message specific payload for mouse released">
					<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Left                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Top                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						</artwork>
					</figure>	  
												</t>
					</section>
					<section anchor="mousemoved" title="MouseMoved">
					<t>
						The MouseMoved message instructs the AH to move the mouse pointer to the
						coordinates provided. This message carries a message-type specific header.
						<figure anchor="mousemovedheader" title="Message specific payload for mouse moved">
					<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Left                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Top                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						</artwork>
					</figure>	  
						
						</t>
					</section>
					<section anchor="mousewheelmoved" title="MouseWheelMoved">
					<t>
						The MouseWheelMoved message instructs the AH to generate a mouse wheel moved event
						at given coordinates of the screen. This message carries a message-type specific header.
						The "distance" field carries the wheel rotation amount as "120 * (number of notches)". 
						A mouse wheel has discrete, evenly spaced notches. When user rotates the wheel, a wheel message
						is sent to OS as each notch is encountered.
						The "distance" field does not carry number of notches in order to support a smooth-scrolling wheel. 
						Instead, "distance" field carries each notch as 120. Some mice MAY only send multiples of 120, while
						a smooth-scrolling mouse MAY send any values. A positive value indicates that the wheel was rotated forward, 
						away from the user; a negative value indicates that the wheel was rotated backward, toward the user.
						The negative values are transmitted using 2's complement method.
						<figure anchor="mousewheelmovedheader" title="Message specific payload for mouse wheel moved">
					<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Left                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Top                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Distance                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						</artwork>
					</figure>	  
						
						</t>
					</section>
					<section anchor="keypressed" title="KeyPressed">
					<t>
						The KeyPressed message instructs the AH to generate a "key pressed" event. 
						This message carries a message-type specific header which consists of a 32 bit KeyCode. 
						Java virtual keycodes are used and they are publicly available on the openJDK website <xref target="keycodes"/>.
						The actual values are inside the KeyEvent.java file. For example, F1 key is defined as 
						"int VK_F1 = 0x70;" in KeyEvent.java. 
						<figure anchor="keypressedheader" title="Message specific payload for key pressed">
					<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          KeyCode                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						</artwork>
					</figure>	  
						</t>
					</section>
					<section anchor="keyreleased" title="KeyReleased">
						<t>
							The KeyReleased message instructs the AH to generate a "key released" event. 
							This message carries a message-type specific header which consists of a 32 bit KeyCode. 
						 	Java keycodes are used and they are publicly available at openJDK website <xref target="keycodes"/>.
							The actual values are inside the KeyEvent.java file. For example, F1 key is defined as 
						    "int VK_F1 = 0x70;" in KeyEvent.java. A KeyReleased event for a key without a prior KeyPressed
							event for this key is acceptable. 
							  
							<figure anchor="keyreleasedheader" title="Message specific payload for key released">
								<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          KeyCode                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
									</artwork>
								</figure>	  
							
							</t>
						</section>
						<section anchor="keytyped" title="KeyTyped">
						<t>
							KeyTyped message instructs the AH to inject some number of UTF-8 encoded 
							characters into the operating systems input queue. This message carries a message specific payload. 
							There is no padding for the UTF-8 string. The participant MUST send more than one KeyTyped 
							message if the string does not fit into a single KeyTyped packet. 
							<figure anchor="keytypedheader" title="Message specific payload for key released">
								<artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.                                                               .
.                                                               .
.                         UTF-8 String                          .
.                                               +-+-+-+-+-+-+-+-+
.                                               |                
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   
									</artwork>
								</figure>	  
							
							</t>
						</section>
		</section>
	
	
	
	<section anchor="implementation" title="Implementation Notes">
		<t>
			Application hosts shouldn't blindly send every screen update they
			observed to the participants.  Instead, they should monitor the state
			of their TCP transmission buffers (through mechanisms such as the
			select() command) and only send the most recent screen data when
			there is no backlog. This will prevent screen latency for
			rapidly-changing images, when a viewer usually only needs to see the
			final state of the image.
			</t>
		
		</section>
		
		
		
		
		<section anchor="security" title="Security Considerations">
			<t>
				RTP packets using the payload format defined in this specification
				are subject to the security considerations discussed in the RTP
				specification <xref target="RFC3550"/>.
				</t>
			<t>
				Application sharing inherently exposes the shared applications to
				risks by malicious participants.  They may, for example, access
				resources beyond the application itself, e.g., by installing or
				running scripts.  It may be difficult to constrain access to specific
				user data, e.g., a specific set of slides, unless the user
				application can be sandboxed or run in some kind of "jail", with the
				sandbox control outside the view of the remoting protocol.
				</t>
			</section>
		
		<section anchor="iana" title="IANA Considerations">
			<t>The IANA has created a new registry for Application and Desktop Sharing Parameters called
   "Application and Desktop Sharing parameters".  This new registry
   has a number of subregistries which are described in the following
   sections.
</t>
			<section anchor="RemotingMessageTypeSubregistry" title="Remoting Message Types Subregistry">
				<t>This section establishes the Remoting Message Types subregistry under 
				    the Application and Desktop Sharing Parameters registry. 
					As per the terminology in RFC 2434 <xref target="RFC2434"/>, the
					registration policy for Remoting Message Types shall be "Specification
					Required".  For the purposes of this subregistry, the Remoting Message Types
					for which IANA registration is requested MUST be defined by a
					standards-track RFC.  Such an RFC MUST specify the Remoting Message Type's value,
					name, format, and semantics.</t>
				<t>
					For each Remoting Message Type, the IANA registers its value, its name, and
					the reference to the RFC where the Remoting Message Type is defined.  The
					following table contains the initial values of this subregistry.
					</t>
					<texttable anchor="table_remotingmessagetypes2" 
					title="Initial values of the Remoting Message Type subregistry">
						<ttcol align="center">Value</ttcol>
						<ttcol align="left">Message Type</ttcol>
						<ttcol align="left">Reference</ttcol>
						<c>1</c><c>WindowManagerInfo</c><c>[RFC nnnn]</c>
						<c>2</c><c>RegionUpdate</c><c>[RFC nnnn]</c>
						<c>3</c><c>MoveRectangle</c><c>[RFC nnnn]</c>
						<c>4</c><c>MousePointerInfo</c><c>[RFC nnnn]</c>
						</texttable>
				</section>
				
				<section anchor="HIPMessageTypeSubregistry" title="HIP Message Types Subregistry">
				<t>This section establishes the HIP Message Types subregistry under 
				    the Application and Desktop Sharing Parameters registry. 
					As per the terminology in RFC 2434 <xref target="RFC2434"/>, the
					registration policy for HIP Message Types shall be "Specification
					Required".  For the purposes of this subregistry, the HIP Message Types
					for which IANA registration is requested MUST be defined by a
					standards-track RFC.  Such an RFC MUST specify the HIP Message Type's value,
					name, format, and semantics.</t>
				<t>
					For each HIP Message Type, the IANA registers its value, its name, and
					the reference to the RFC where the HIP Message Type is defined.  The
					following table contains the initial values of this subregistry.
					</t>
					<texttable anchor="table_hipmessagetypes2"
					title="Initial values of the HIP Message Type subregistry">
						<ttcol align="center">Value</ttcol>
						<ttcol align="left">Message Type</ttcol>
						<ttcol align="left">Reference</ttcol>
						<c>121</c><c>MousePressed</c><c>[RFC nnnn]</c>
						<c>122</c><c>MouseReleased</c><c>[RFC nnnn]</c>
						<c>123</c><c>MouseMoved</c><c>[RFC nnnn]</c>
						<c>124</c><c>MouseWheelMoved</c><c>[RFC nnnn]</c>
						<c>125</c><c>KeyPressed</c><c>[RFC nnnn]</c>
						<c>126</c><c>KeyReleased</c><c>[RFC nnnn]</c>
						<c>127</c><c>KeyTyped</c><c>[RFC nnnn]</c>
						</texttable>
				</section>
			
			<section anchor="mediatype" title="Media Type Registrations">
				<t>Following the guidelines in RFC 4855 <xref target="RFC4855"/>
					and RFC 4288 <xref target="RFC4288"/>, this
					section registers new 'application' media subtypes for remoting and hip.
					</t>
				
				<section anchor="mediatyperemoting" title="Registrations of Media Type application/remoting">
					<t>
						
						<list style="hanging">
							<t hangText="Type name:">application
								</t>
							<t hangText="Subtype name:">remoting 
								</t>
							<t hangText="Required parameters:">
								<list style="hanging">
									<t hangText="rate:">RTP timestamp clock rate, which is equal to the sampling
										rate.  The typical rate is 90000; other rates may be specified.
										</t>
										<t hangText="retransmissions:">Informs the participants whether the AH supports
										UDP retransmissions. The possible values are yes and no.
										</t>
									</list>
								
								</t>
							<t hangText="Optional parameters:">none 
								</t>
							<t hangText="Encoding considerations:">This media type is framed binary data (see RFC 4288, Section
								4.8). 
								</t>
							<t hangText="Security considerations:">See Section <xref target="security"/> of RFC nnnn						
								</t>
							<t hangText="Interoperability considerations:">none						
								</t>
							<t hangText="Published specification:">RFC nnnn						
								</t>
							<t hangText="Additional information:">none						
								</t>
							<t hangText="Person & email address to contact for further information:">
								Omer Boyaci &lt;boyaci@cs.columbia.edu&gt; and Henning Schulzrinne &lt;hgs@cs.columbia.edu&gt;
								</t>
							<t hangText="Intended usage:">COMMON					
								</t>
							<t hangText="Restrictions on usage:">This media type depends on RTP framing, and hence is only
								defined for transfer via RTP (RFC 3550).  Transfer within
								other framing protocols is not defined at this time.						
								</t>
							<t hangText="Applications that use this media type:">Application and Desktop sharing tools. Remote tutoring tools.						
								</t>
							
							<t hangText="Author:">Omer Boyaci and Henning Schulzrinne 						
								
								</t>
							<t hangText="Change controller:">IETF Audio/Video Transport working group delegated from the
								IESG.						
								</t>
							</list>
								</t>
							
							</section>
						
						<section anchor="mediatypehip" title="Registrations of Media Type application/hip">
							<t>
							<list style="hanging">
							<t hangText="Type name:">application
								</t>
							<t hangText="Subtype name:">hip 
								</t>
							<t hangText="Required parameters:">
								<list style="hanging">
									<t hangText="rate:">RTP timestamp clock rate, which is equal to the sampling
										rate.  The typical rate is 90000; other rates may be specified.
										</t>
									</list>
								
								</t>
							<t hangText="Optional parameters:">none 
								</t>
							<t hangText="Encoding considerations:">This media type is framed binary data (see RFC 4288, Section
								4.8). 
								</t>
							<t hangText="Security considerations:">See Section <xref target="security"/> of RFC nnnn						
								</t>
							
							<t hangText="Interoperability considerations:">none						
								</t>
							<t hangText="Published specification:">RFC nnnn						
								</t>
							<t hangText="Additional information:">none						
								</t>
							<t hangText="Person & email address to contact for further information:">
								Omer Boyaci &lt;boyaci@cs.columbia.edu&gt; and Henning Schulzrinne &lt;hgs@cs.columbia.edu&gt;
								</t>
							<t hangText="Intended usage:">COMMON					
								</t>
							<t hangText="Restrictions on usage:">This media type depends on RTP framing, and hence is only
								defined for transfer via RTP (RFC 3550).  Transfer within
								other framing protocols is not defined at this time.						
								</t>
							<t hangText="Applications that use this media type:">Application and Desktop sharing tools.						
								</t>
							
							<t hangText="Author:">Omer Boyaci and Henning Schulzrinne 						
								
								</t>
							<t hangText="Change controller:">IETF Audio/Video Transport working group delegated from the
								IESG.						
								</t>
							</list>

							
							</t>
							
							</section>
						
						
						</section>
					
					
					</section>
				
		<section anchor="sdp" title="Mapping to the Session Description Protocol (SDP)">
			<t>
				The information carried in this payload format has a
				specific mapping to fields in the Session Description Protocol (SDP)
				[RFC4566], which is commonly used to describe RTP sessions.  When SDP
				is used to specify sessions, the mappings are as follows:
				
				</t>
			<section anchor="sdpremoting" title="Mapping remoting Media Type Parameters into SDP">
				<t>
					
					<list>
						<t>The media type ("application") is carried in the SDP m= attribuate as the media name.
							</t>
						<t>The media subtype ("remoting") is carried in the SDP
							a=rtpmap as the encoding name.
							</t>
						<t>
							The parameter "rate" is carried in the SDP a=rtpmap attribuate as the clock rate.
							</t>
							<t>
							The mandated parameter "retransmissions" MUST be included in the
							SDP a=fmtp attribute.
							</t>
							
						</list>
					
					</t>			
				</section>
			<section anchor="sdphip" title="Mapping hip Media Type Parameters into SDP">
				<t>
					<list>
						
							<t>The media type ("application") is carried in the SDP m= attribuate as the media name.
								</t>
							<t>The media subtype ("hip") is carried in the SDP
								a=rtpmap attribuate as the encoding name.
								</t>
							<t>
								The parameter "rate" is carried in the SDP a=rtpmap attribuate as the clock rate.
								</t>
							
						
						</list>
					
					</t>			
				</section>
				<section anchor="sdpexample" title="SDP Example">
				<t>
				The following example shows an example SDP usage.
				This SDP message is from AH to participant.
				The HIP stream and BFCP session are associated with each other via "label" and
				"m-stream" attributes according to SDP Format for BFCP Streams <xref target="RFC4583"/>.
				This SDP message informs the participant that AH supports both TCP and UDP for remoting.
				The AH supports UDP retransmissions, so participants MAY send NACK requests for missing packets.
				The port numbers MUST be same if AH is remoting the same content over both TCP and UDP. 
				In this example, AH is sending the same content from port 6000. It is possible that AH may have
				more than one remoting session, in this case each session MUST use different port numbers.
					<figure>
		    <artwork>
       m=application 50000 TCP/BFCP *
       a=floorid:0 m-stream:10
       m=application 6000 RTP/AVP 99
       a=rtpmap:99 remoting/90000
       a=fmtp: retransmissions=yes
       m=application 6000 TCP/RTP/AVP 99
       a=rtpmap:99 remoting/90000
       m=application 6006 TCP/RTP/AVP 100
       a=rtpmap:99 hip/90000
       a=label:10
		    </artwork>
		</figure>
					
					</t>			
				</section>	
					
							
			</section>	
		
		<appendix anchor="appendix" title="Using BFCP for Application and Desktop Sharing">
			<t>
				Application and desktop sharing tools MAY utilize Binary Floor
				Control Protocol (BFCP) [RFC4582] for managing the ownership of
				AH's human interface devices (HID). 
				</t>
			<t>	
				BFCP defines several messages, but only five of them is a MUST for 
				Application and Desktop Sharing, namely "Floor Request", "Floor Release", "Floor Granted", 
				"Floor Released" and "Floor Request Queued". 
				</t>
			<t>
				In Application and Desktop Sharing context, the floor is the AH's HIDs.
				In this context, it is possible that the AH MAY temporarily block HID events
				without revoking the floor control. For example, the AH MAY temporarily block HID events
				if the shared application loses the focus or is covered by a non-shared application.
				The AH informs the current floor holder about the status of HIDs via
				STATUS-INFO attribute of "Floor Granted" messages. The participant MAY receive several
				"Floor Granted" messages with different "HID Status" values. Participant applications 
				MAY inform the user about current "HID Status".
				HID Status values are 16-bit unisgned values and are defined as:
				<figure anchor="hid" title="HID Status Values">
					<artwork>
                    +-------+------------------------+
                    | Value | Status                 |
                    +-------+------------------------+
                    |   0   | STATE_NOT_ALLOWED      |
                    |   1   | STATE_KEYBOARD_ALLOWED |
                    |   2   | STATE_MOUSE_ALLOWED    |
                    |   3   | STATE_ALL_ALLOWED      |
                    +-------+------------------------+
						</artwork>
					</figure>	
				
		</t>
</appendix> 
		
		
		</middle>
	
    <back>
		<references title="Normative References">
			<?rfc include="bibxml/reference.RFC.2327.xml"?>
			<?rfc include="bibxml/reference.RFC.4582.xml"?>
			<?rfc include="bibxml/reference.RFC.3261.xml"?>
			<?rfc include="bibxml/reference.RFC.2119.xml"?>
			<?rfc include="bibxml/reference.RFC.3550.xml"?>
			<?rfc include="bibxml/reference.RFC.4585.xml"?>
			<?rfc include="bibxml/reference.RFC.4571.xml"?>
			<?rfc include="bibxml/reference.RFC.4583.xml"?>
			<?rfc include="bibxml/reference.RFC.3984.xml"?>
			<?rfc include="bibxml/reference.RFC.2435.xml"?>
			<?rfc include="bibxml/reference.RFC.5371.xml"?>
			<?rfc include="bibxml3/reference.I-D.boyaci-avt-png.xml"?>
		</references>	
			<references title="Informative References">
			<?rfc include="bibxml/reference.RFC.2434.xml"?>
			<?rfc include="bibxml/reference.RFC.4855.xml"?>
			<?rfc include="bibxml/reference.RFC.4288.xml"?>
			<!--
			<?rfc include="bibxml4/reference.W3C.REC-PNG-20031110.xml"?>
			<?rfc include="bibxml2/reference.ITU.T81.1992.xml"?>
			-->	
			<reference anchor="X"> 
				<front> 
					<title>X Window System Protocol</title> 
					<author initials="R." surname="Scheifler" fullname="Scheifler R">
						<organization abbrev="X">X</organization>
						</author> 
					
					<date month="November" year="2004" /> 
					</front> 
				<seriesInfo name="X" value="Consortium Standard X Version 11"/> 
				</reference>
			
			<reference anchor="T120"> 
				<front> 
					<title>Data Protocols for Multimedia Conferencing</title> 
					<author>
						<organization abbrev="ITU">International Telecommunication Union</organization>
						</author> 
					
					
					</front> 
				<seriesInfo name="X" value="ITU-T Recommendation T.120"/> 
				</reference>
			
			<reference anchor="theora"> 
				<front> 
					<title>Theora</title> 
					<author>
						<organization abbrev="Xiph.org">Xiph.org Foundation</organization>
						</author> 
					
					
					</front> 
				</reference>
				
			
			<reference anchor="keycodes" target="http://hg.openjdk.java.net/jdk7/awt-gate/jdk/archive/tip.zip"> 
				<front> 
				<title>Java key-codes</title> 
				<author>
				<organization abbrev="OpenJDK">OpenJDK Community</organization>
				</author> 
				
				
				</front> 
				
				</reference>  
				
				
				
				
				</references>
				</back>
				</rfc>
