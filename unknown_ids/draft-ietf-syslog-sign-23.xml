<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<rfc category="std" ipr="full3978" docName="draft-ietf-syslog-sign-23.txt">
	<front>
		<title>Signed syslog Messages</title>

		<author initials="J" surname="Kelsey" fullname="John Kelsey">
			<organization>NIST</organization>
			<address>
				<email>john.kelsey@nist.gov</email>
			</address>
		</author>

		<author initials="J" surname="Callas" fullname="Jon Callas">
			<organization>PGP Corporation</organization>
			<address>
				<email>jon@callas.org</email>
			</address>
		</author>

		<author initials="A" surname="Clemm" fullname="Alexander Clemm">
			<organization>Cisco Systems</organization>
			<address>
				<email>alex@cisco.com</email>
			</address>
		</author>

		<date day="28" month="September" year="2007" />

		<area>Security</area>
		<workgroup>syslog Working Group</workgroup>
		<keyword>syslog</keyword>
		<keyword>syslog-sign</keyword>

		<abstract>
			<t>
			This document describes a mechanism to add origin authentication, message integrity, 
			replay resistance, message sequencing, and detection of missing messages to the transmitted 
			syslog messages.  This specification is intended to be used in conjunction with the work 
			defined in RFC xxxx, "The syslog Protocol".  
			</t>
		</abstract>
	</front>

	<middle>
		<section anchor="intro" title="Introduction">
			<t>
			This document describes a mechanism, called syslog-sign in this document,
			that adds origin
			authentication, message integrity, replay resistance, message
			sequencing, and detection of missing messages to syslog.  Essentially,
			this is accomplished by sending a special syslog message.  
			The contents of this syslog message is called a Signature Block.  
			Each Signature Block contains, in effect, a detached signature on
			some number of previously sent messages.  It is cryptographically signed and contains 
			the hashes of previously sent syslog messages.  
			</t>
			<t>
			While most implementations
			of syslog involve only a single originator
			and a single collector of each message,
			provisions need to be made to cover situations in which messages are 
			sent to multiple collectors.  
			This concerns, in particular, situations in which different messages 
			are sent to different collectors, which means that some messages are sent 
			to some collectors but not to others.  
			The required differentiation of messages is generally performed 
			based on the Priority value of the individual messages.  
			For example, messages from any Facility
			with a Severity value of 3, 2, 1, or 0 may be sent to one collector
			while all messages of Facilities 4, 10, 13, and 14 may be sent to
			another collector.  Appropriate syslog-sign messages must be kept
			with their proper syslog messages.  To address this, syslog-sign
			uses a Signature Group.  A Signature Group identifies a group of
			messages that are all kept together for signing purposes by the
			originator.  A Signature Block always belongs to exactly one signature
			group and always signs messages belonging only to that signature
			group.
			</t>
			<t>
			Additionally, a originator sends a Certificate Block to provide key
			management information between the originator and the collector.  This
			Certificate Block has a field to denote the type of key material
			which may be such things as a PKIX certificate, an OpenPGP certificate,
			or even an indication that a key had been predistributed.  
			In the cases of certificates being sent, the
			certificates may have to be split across multiple packets.
			</t>
			<t>
			The collector of the previous messages may verify that the hash of 
			each received message matches the signed hash contained
			in the Signature Block.  A collector may process these Signature
			Blocks as they arrive, building an authenticated log file.
			Alternatively, it may store all the log messages in the order they
			were received.  This allows a network operator to authenticate the
			log file at the time the logs are reviewed.
			</t>
			<t>
			The mechanism described in this specification is intended to be used in
			conjunction with  
			the syslog protocol as defined in <xref target="syslog-protocol">
			RFC xxxx</xref> as its message delivery mechanism and uses the concept of 
			STRUCTURED-DATA elements defined
			in that document.  In fact, this specification mandates implementation of 
			syslog protocol.  Nevertheless, it is conceivable that the concepts 
			underlying this mechanism could 
			also be used in conjunction with other message delivery mechanisms.  
			Designers of other efforts to define event notification mechanisms are 
			therefore encouraged to consider this specification in their designs.
			</t>
			<t>
			NOTE to RFC editor:  
			replace xxxx with the actual RFC number assigned to <xref target="syslog-protocol" />, 
			replace zzzz with the actual RFC number assigned to <xref target="syslog-transport-udp" />,
			replace wwww with the actual RFC number assigned to <xref target="syslog-transport-tls" />,
			replace yyyy with the actual RFC number assigned to this document, and remove this note.  
			</t>
		</section>

		<section anchor="conventions" title="Conventions Used in this Document">
			<t>
			The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
			"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
			document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
			</t>
		</section>

		<section anchor="format" title="syslog Message Format">
			<t>
			This specification is intended to be used in conjunction with the syslog 
			protocol as defined in
			<xref target="syslog-protocol">RFC xxxx</xref>.  The syslog protocol therefore 
			MUST be supported by implementations of this specification.   
			</t>
			<t>
			Because the originator generating the 
			Signature Block message signs each message in its entirety, 
			the messages MUST NOT be changed in transit.  By the same token, 
			the syslog-sign messages MUST NOT be changed in transit.  Specifically,
			a relay as described in <xref target="syslog-protocol">RFC xxxx</xref>  
			MAY make changes to a syslog packet.  If this occurs, the mechanism 
			described in this document is rendered useless.  
			Likewise, any truncation of messages
			that occurs between sending and receiving renders the mechanism useless.  
			For this reason, syslog originator and collector implementations implementing this 
			specification MUST support messages of up to and including 2048 octets in length, 
			in order to minimize the chance of truncation.   
			While syslog originator and collector implementations MAY support messages with a 
			length larger than 2048 octets, implementors need to be aware that any message
			truncations that occur render the mechanism useless.  
			</t>
			<t>
			This specification uses the syslog message format
			described in <xref target="syslog-protocol">RFC xxxx</xref>.  
			Along with other fields, that document describes the concept of Structured Data (SD).  
			Structured Data is defined in terms of SD ELEMENTS (SDEs).  
			An SDE consists of a name and a set of parameter name - value pairs.  
			The SDE name is referred to as SD-ID.  
			The name-value pairs are referred to as SD-PARAM, or SD Parameters,
			with the name constituting the SD-PARAM-NAME, and the value constituting the SD-PARAM-VALUE.  
			</t>
			<t>
			The syslog messages defined in this document carry the signature and certificate data
			as Structured Data.  The special syslog messages defined in this document 
			include for this purpose definitions 
			of SDEs to convey parameters that relate to the signing of syslog messages.  
			The MSG part of the syslog messages defined in this document SHOULD 
			simply be empty -- 
			the content of the messages is not intended for interpretation by humans but by applications
			that use those messages to build an authenticated log.    
			</t>
			<t> 
			Because the syslog messages defined in this document adhere to the format 
			described in <xref target="syslog-protocol">RFC xxxx</xref>, they identify the machine that 
			originates the syslog message in the HOSTNAME field.  Therefore, the signature and certificate 
			data do not need to include an additional parameter to identify the machine that orginates the 
			message.   
			</t>
		</section>

		<section anchor="sigBlock" title="Signature Blocks">
			<t>
			This section describes the format of the Signature Block and the fields used
			within the Signature Block, as well as the syslog messages used to carry the 
			Signature Block.  
			</t>

			<section anchor="sigBlkPkts" title="syslog Messages Containing a Signature Block">
				<t>
				There is a need to distinguish the Signature Block itself from the syslog message
				that is used to carry a Signature Block.  
				Signature Blocks MUST be encompassed within completely formed 
				syslog messages.  Syslog messages that contain a Signature Block are also referred to as 
				Signature Block messages.  
				</t>
				<t>
				A Signature Block message 
				is identified by the presence of an
				SD ELEMENT with an SD-ID with the value "ssign".  
				In addition, a Signature Block message 
				MUST contain valid APP-NAME, PROCID, and MSGID fields to be compliant with 
				<xref target="syslog-protocol">RFC xxxx</xref>.   
				This specification does not mandate particular values for these fields; however, 
				for consistency, originators SHOULD use the 
				same values for APP-NAME, PROCID, and MSGID fields for 
				every Signature Block message that is sent, whichever values are chosen.  
				It is RECOMMENDED (but not required) to use 110 as value 
				for the PRI field, corresponding to facility 13 and severity 6 (informational).  
				The Signature Block is 
				carried as Structured Data within the Signature Block message, per the definitions 
				that follow in the next section.  
				A Signature Block 
				message SHOULD NOT carry other Structured Data besides the Structured Data of the 
				Signature Block itself.  
				</t>
				<t>
				The syslog messages defined as part of syslog-sign themselves 
				(Signature Block messages and Certificate Block messages) do not need to be
				signed by a Signature Block.  Collectors that 
				implement syslog-sign know to distinguish syslog messages that are associated with syslog-sign 
				from those that are subjected to signing and 
				process them differently.  
				</t>

			</section>
			<section anchor="sigBlockFormat" title="Signature Block Format and Fields">

				<t>
				The content of a Signature Block message is the Signature Block.  
				The Signature Block MUST
				be encoded as an SD ELEMENT, as defined in 
				<xref target="syslog-protocol">RFC xxxx</xref>.  
				</t>
				<t>
				The SD-ID MUST have the value of "ssign".  
				</t>
				<t>
				The SDE contains the fields of the Signature Block encoded as 
				SD Parameters, as specified in the following.    
				The Signature Block is composed of the following fields. The value of each field
				MUST be printable ASCII, and any binary values MUST be 
				base 64 encoded, as defined in <xref target="RFC4648">RFC 4648</xref>.  
				</t>

				<figure>
					<artwork>
    Field                     SD-PARAM-NAME        Size in octets
    -----                     -------------        ---- -- ------

    Version                          VER                 4

    Reboot Session ID               RSID                1-10

    Signature Group                   SG                 1

    Signature Priority              SPRI                1-3

    Global Block Counter             GBC                1-10

    First Message Number             FMN                1-10

    Count                            CNT                1-2

    Hash Block                        HB      variable, size of hash
                                            times the number of hashes
                                             (base 64 encoded binary)

    Signature                       SIGN             variable
                                             (base 64 encoded binary)
					</artwork>
				</figure>

				<t>
				A Signature Block is accordingly encoded as follows, where xxx denotes a placeholder for the 
				particular values: 
				</t>
				<t>
				[ssign VER="xxx" RSID="xxx" SG="xxx" SPRI="xxx" GBC="xxx" 
				FMN="xxx" CNT="xxx" HB="xxx" SIGN="xxx"]  
				</t>
				<t>
				Values of the fields constitute SD parameter values and are hence enclosed in quotes, 
				per <xref target="syslog-protocol">RFC xxxx</xref>.  
				The fields are separated by single spaces and are described below.  
				</t>

				<section anchor="Version" title="Version">
					<t>
					The Signature Block Version field is a decimal value 
					that has a length of 4 octets, which may include leading zeroes.  
					Each octet contains a 
					decimal character in the range of "0" to "9".  
					The value in this field specifies
					the version of the syslog-sign protocol. This is extensible to allow
					for different hash algorithms and signature schemes to be used in
					the future. The value of this field is the grouping of the protocol
					version (2 octets), the hash algorithm (1 octet) and the signature
					scheme (1 octet).  

					<list style="empty">
						<t>
						Protocol Version - 2 octets, with "01" as the value for 
                                    the protocol version that is described in this document.  
						</t>

						<t>
						Hash Algorithm - 1 octet, where, in conjunction 
						with Protocol Version 01, a value of "1" denotes SHA1 and  
						a value of "2" denotes SHA256, as defined in
						<xref target="FIPS.180-2.2002">FIPS-180-2.2002</xref>.
						</t>
	
						<t>
						Signature Scheme - 1 octet, where, in conjunction
						with Protocol Version 01, a value of "1" denotes
						OpenPGP DSA, defined in <xref target="RFC2440">RFC 2440</xref> and 
						<xref target="FIPS.186-2.2000">FIPS.186-2.2000</xref>.
						</t>
					</list>

					The version, hash algorithm and signature scheme defined in
					this document would accordingly be represented as "0111" (if SHA1 is used as Hash Algorithm) 
					and "0121" (if SHA256 is used as Hash Algorithm), respectively 
					(without the quotation marks).  
					</t>
					<t>
					The values of the Hash Algorithm and Signature Scheme are 
					defined relative to the Protocol Version.  If the single-octet representation of the values 
					for Hash Algorithm and Signature Scheme were to ever represent a limitation, 
					this limitation could be overcome by defining a new Protocol Version with additional
					Hash Algorithms and/or Signature Schemes, and having implementations support both 
					Protocol Versions concurrently.  
 					</t>
		

				</section>

				<section anchor="rebootid" title="Reboot Session ID">
					<t>
					The Reboot Session ID is a decimal value that has a length between 1 and 10 octets.  
					The acceptable values for
					this are between 0 and 9999999999.  Leading zeroes MUST be omitted.  
					A Reboot Session ID is expected to increase whenever an originator reboots in order to allow 
					collectors to distinguish messages and message signatures across reboots.  
					Hence, an originator needs to retain the previous Reboot Session ID across reboots.  
					In cases where an originator does not support this capability, 
					the Reboot Session ID MUST always be set to a value of 0, which indicates 
					that this capability is not supported.  
					Otherwise, it MUST increase whenever an originator reboots, starting with a value of 1.  
					If the value reaches 9999999999, then manual intervention may be required 
					to subsequently reset it to 1.  Implementors MAY wish to consider using the snmpEngineBoots
					value as a source for this counter as defined in 
					<xref target="RFC3414">RFC 3414</xref>.
					</t>
				</section>

				<section anchor="siggrp" title="Signature Group and Signature Priority">
					<t>
					The SG parameter may take any value from
					0-3 inclusive.  The SPRI parameter may take any value from 0-191 inclusive.  
                              These fields
					taken together allow network administrators to associate
					groupings of syslog messages with appropriate Signature Blocks and
					Certificate Blocks.  
					Groupings of syslog messages that are signed together are also 
					called Signature Groups.  A Signature Block contains only hashes 
					of those syslog messages that are part of the same Signature Group.  
					</t>
					<t>
					For example, in some cases, network
					administrators might have originators send syslog messages of Facilities 0 through 15
					to one collector and those with Facilities 16
					through 23 to another.  In such cases, associated Signature Blocks should 
					likely be sent to the corresponding collectors as well, signing the syslog 
					messages that are intended for each collector separately.  This way, each
					collector receives Signature Blocks for all syslog messages
					that it receives, and only for those.  
					The ability to associate different categories of syslog messages with different 
					Signature Groups, signed in separate Signature Blocks, 
					provides administrators with flexibility in this regard.  
					</t>
					<t>
					Syslog-sign provides four options for handling Signature Groups,
					linking them with PRI values so they may be routed to the
					destination commensurate with the corresponding syslog messages. In
					all cases, no more than 192 distinct Signature Groups (0-191) are permitted.  
					</t>
					<t>
					The Signature Group to which a Signature Block pertains is indicated by 
					the Signature Priority (SPRI) field.  
					The Signature Group (SG) field indicates how to interpret the Signature 
					Priority field.  (Note that the SG field does not indicate the Signature Group itself, 
					as its name might suggest.)  The SG field can have one of the following values:  

					<list style="letters">
						<t>
						"0" -- There is only one Signature Group.  
						In this case, the administrators want all Signature
						Blocks to be sent to a single destination; in all likelihood,
						all of the syslog messages will also be going to that same
						destination.  Signature Blocks sign
						all messages regardless of their PRI value.  
						This means that, in effect,
						the Signature Block's SPRI value can be ignored.  
						However, it is RECOMMENDED that a single SPRI value be used for all
						Signature Blocks.    
						Furthermore, it is RECOMMENDED to set that value 
						to the same value as the 
						PRI field of the Signature Block message.  This way, the PRI of the Signature
						Block message matches the SPRI of the Signature Block that it contains.
						</t>

						<t>
						"1" -- Each PRI value is associated with its own Signature Group. Signature
						Blocks for a given Signature Group have SPRI = PRI for that
						Signature Group.  In other words, the SPRI of the Signature Block matches 
						the PRI value of the syslog messages that are part of the Signature Group
						and hence signed by the Signature Block.  
						An SG value of 1 can, for example, be used when the administrator of an originator
						does not know where any of the syslog messages will ultimately
						go but anticipates that messages with different PRI values will be collected and 
						processed separately.  Having a Signature Group per PRI value provides 
						administrators with 
						a large degree of flexibility with regard to how to divide 
						up the processing of syslog messages and their signatures after they 
						are received, at the same time allowing 
						Signature Blocks to follow the corresponding syslog messages to their
						eventual destination.    
						</t>

						<t>
						"2" -- Each Signature Group contains a range of PRI values.
						Signature Groups are assigned sequentially. A Signature Block for
						a given Signature Group has its own SPRI value denoting the
						highest PRI value of syslog messages in that Signature Group.  
						The lowest PRI value of syslog messages in that Signature Group will
						be one larger than the SPRI value of the previous Signature Group or "0" 
						in case there is no other Signature Group with a lower SPRI value.  
						The specific Signature Groups and ranges they are associated with 
						are subject to configuration by a system administrator.  
						</t>

						<t>
						"3" -- Signature Groups are not assigned with any of the above 
						relationships to PRI values of the syslog messages they 
						sign. Instead, another scheme is used, which is outside the scope of 
						this specification.  There has to be some predefined
						arrangement between the originator and the intended collectors as to which 
						syslog messages are to be included in which Signature Group, requiring 
						configuration by a system administrator.  This provides administrators also 
						with the flexibility to group syslog messages into Signature Groups according to 
						criteria that are not tied to the PRI value.  
						</t>
					</list>

					One reasonable way to configure some installations is to have only
					one Signature Group, indicated with SG=0, and have the originator send a copy of 
					each Signature Block to each collector.   In that case, collectors that are not 
					configured to receive every syslog message will still receive signatures for
					every message, even ones they are not supposed to receive.   
					While the collector will not be able to detect gaps in the
					messages (because the presence of a signature of a message that is missing 
					does not tell the collector whether
					or not the corresponding message would be of the collector's concern), 
					it does allow all messages that do arrive at each collector
					to be put into the right order and to be verified.  It also
					allows each collector to detect duplicates.  
					Likewise, configuring only one Signature Group can be a reasonable way to 
					configure installations that involve relay chains, 
					where one or more interim relays may or may not relay all messages to the 
					same destination.  
					</t>
				</section>

				<section anchor="globBlk" title="Global Block Counter">
					<t>
					The Global Block Counter is a decimal value representing the number of
					Signature Blocks sent by syslog-sign before the current one, in this
					reboot session. This takes at least 1 octet and at most 10 octets
					displayed as a decimal counter. The acceptable values for this
					are between 0 and 9999999999, starting with 0.  Leading zeroes MUST be omitted.  
					If the value of the Global Block Counter 
					has reached 9999999999 and the Reboot Session ID has a value other than 0
					(indicating the fact that persistence of the Reboot Session ID is supported),
					then the Reboot Session ID MUST be incremented by 1 and the
					Global Block Counter resumes at 0.  When 
					the Reboot Session ID is 0 (i.e., persistent 
					Reboot Session IDs are not supported) and the Global Block Counter
					reaches its maximum value, then the Global Block Counter is reset to 0 
					and the Reboot Session ID MUST remain at 0.   
					</t>
					<t>
					Note that the Global Block Counter
					crosses Signature Groups; it allows one to roughly synchronize when
					two messages were sent, even though they went to different
					collectors and are part of different Signature Groups.  
					</t>
					<t>
					Because a reboot results in the start of a new reboot session, the originator MUST 
					reset the Global Block Counter to 0 after a reboot occurs.  
					Applications need to take into account the possibility that a 
					reboot occurred when authenticating 
					a log, and situations in which reboots occur frequently may result 
					in losing the ability to verify the proper sequence in which messages were
					sent, hence jeopardizing the integrity of the log.  
					</t>
				</section>

				<section anchor="firstmsg" title="First Message Number">
					<t>
					This is a decimal value between 1 and 10 octets, with leading zeroes omitted.  
					It contains the unique
					message number within this Signature Group of the first message
					whose hash appears in this block.  The very first message of the
					reboot session is numbered "1".  This implies that when the Reboot Session ID 
					increases, the message number is reset to 1.  
					</t>
					<t>
					For example, if this Signature Group has processed 1000 messages so
					far and message number 1001 is the first message whose hash appears
					in this Signature Block, then this field contains 1001.  The 
					message number is relative to the Signature Group to which it belongs; 
					hence, a message number does not identify a message beyond its Signature Group.    
					</t>
					<t>
					Should the message number reach 9999999999 within the same reboot session and 
					Signature Group, the message number subsequently restarts at 1.   
					In such event, the Global Block Counter will be vastly different 
					between two occurrences of the same message number.     
					</t>
				</section>

				<section anchor="count" title="Count">
					<t>
					The count is a 1 or 2 octet field that indicates the number of message
					hashes to follow.  The valid values for this field are 1 through
					99.  The number of hashes included in the Signature
					Block MUST be chosen such that the length of the 
					resulting syslog message does not exceed the maximum permissible syslog 
					message length.  
					</t>
				</section>

				<section anchor="hash" title="Hash Block">
					<t>
					The hash block is a block of hashes, each separately encoded in
					base 64. Each hash in the hash block is the hash of the entire
					syslog message represented by the hash, independent of the underlying
					transport.  Hashes are ordered from left to right in the order of occurrence 
					of the syslog messages that they represent.   
					</t>
					<t>
					The "entire syslog message" refers to what is described as the syslog 
					message excluding 
					transport parts that are described in 
					<xref target="syslog-transport-udp">RFC zzzz</xref> and 
					<xref target="syslog-transport-tls">RFC wwww</xref>, 
					and excluding other parts that may be defined 
					in future transports.  The hash value 
					will be the result of the hashing algorithm run across the syslog message, 
					starting with the "&lt;" of the PRI portion of the header part of the 
					message.  The hash algorithm used
					and indicated by the Version field determines the size of
					each hash, but the size MUST NOT be shorter than 160 bits without the use of 
					padding. It is
					base 64 encoded as per <xref target="RFC4648">RFC 4648</xref>.
					</t>
					<t>
					The number of hashes in a hash block SHOULD be chosen such that the resulting 
					Signature Block message does not exceed a length of 2048 octets in order to 
					avoid the possibility that truncation occurs.  When more
					hashes need to be sent than fit inside a Signature Block message, it is
					advisable to start a new Signature Block.  
					</t>
				</section>

				<section anchor="sig" title="Signature">
					<t>
					This is a digital signature, encoded in base 64 
					per <xref target="RFC4648">RFC 4648</xref>. The signature is calculated over the
					completely formatted syslog-message, including all of the PRI, HEADER, and hashes in the
					hash block, excluding spaces between fields, and
					also excluding the signature field 
					(SD Parameter Name "SIGN", "=", and corresponding value).  
					</t>
				</section>
			</section>
		</section>

		<section anchor="payncert" title="Payload and Certificate Blocks">
			<t>
			Certificate Blocks and Payload Blocks provide key management for
			syslog-sign.  Their purpose is to support key management that uses
			public key cryptosystems. 
			</t>

			<section anchor="prelims" title="Preliminaries: Key Management and Distribution Issues">
				<t>
				A Payload Block contains public key certificate information that is to be conveyed to the
				collector.  A Payload Block is sent at the 
				beginning of a new reboot session, carrying public key 
				information in effect for the reboot session.  
				However, a Payload Block is not sent directly, but in (one or more) fragments.  
				Those fragments are termed Certificate Blocks.  Therefore, originators send at 
				least one Certificate Block at the beginning of a new reboot session.  
				</t>

				<t>
				There are three key points to understand about Certificate Blocks:

				<list style="letters">
					<t>
					They handle a variable-sized payload, fragmenting it if
					necessary and transmitting the fragments as legal syslog
					messages. This payload is built (as described below) at the
					beginning of a reboot session and is transmitted in pieces with
					each Certificate Block carrying a piece. There is
					exactly one Payload Block per reboot session.
					</t>

					<t>
					The Certificate Blocks are digitally signed. The originator does not
					sign the Payload Block, but the signatures on the Certificate
					Blocks ensure its authenticity. Note that it may not even be
					possible to verify the signature on the Certificate Blocks
					without the information in the Payload Block; in this case the
					Payload Block is reconstructed, the key is extracted, and then
					the Certificate Blocks are verified. (This is necessary even
					when the Payload Block carries a certificate, because some other
					fields of the Payload Block are not otherwise verified.)  In
					practice, most installations keep the same public key over
					long periods of time, so that most of the time, it is easy to
					verify the signatures on the Certificate Blocks, and use the
					Payload Block to provide other useful per-session information.
					</t>

					<t>
					The kind of Payload Block that is expected is determined by what
					kind of key material is on the collector that receives it. The
					originator and collector (or offline log viewer) both have some key
					material (such as a root public key or predistributed public
					key) and an acceptable value for the Key Blob Type in the
					Payload Block, below. The collector or offline log viewer MUST
					NOT accept a Payload Block of the wrong type.
					</t>
				</list>
				</t>
			</section>

			<section anchor="build" title="Payload Block">
				<t>
				The Payload Block is built when a new reboot session is started.
				There is a one-to-one correspondence between reboot sessions and Payload
				Blocks. 
				An originator creates a new Payload Block after each reboot.  The Payload 
				Block is used until the next reboot.  
				A Payload Block MUST have the following fields:  

				<list style="letters">

					<t>
					Full local time stamp for the originator at the time the reboot session started.  This 
					must be in the time stamp format specified in 
					<xref target="syslog-protocol">RFC xxxx</xref>
					(essentially, time stamp format per 
					<xref target="RFC3339">RFC 3339</xref> with some further restrictions).
					</t>

					<t>
					Key Blob Type, a one-octet field containing one of five values:

					<list style="numbers">
						<t>
						'C' -- a PKIX certificate.
						</t>

						<t>
						'P' -- an OpenPGP certificate.
						</t>

						<t>
						'K' -- the public key whose corresponding private key is
						being used to sign these messages.
						</t>

						<t>
						'N' -- no key information sent; key is predistributed.
						</t>

						<t>
						'U' -- installation-specific key exchange information
						</t>
					</list>
					</t>
					<t>
					The key blob, if any, base 64
					encoded per <xref target="RFC4648">RFC 4648</xref> and
					consisting of the raw key data.  
					</t>
				</list>
				</t>
				<t>
				The fields are separated by single space characters.  
				Because a Payload Block is not carried in a 
				syslog message directly, only the corresponding Certificate Blocks, it does not
				need to be encoded as an SD ELEMENT.    
				The Payload Block does not contain a field that identifies the reboot 
				session; instead, the reboot session can be inferred from the 
				Reboot Session ID parameter of the Certificate Blocks that are used to 
				carry the Payload Block.  
				</t>
			</section>

			<section anchor="buildcert" title="Certificate Block">
				<t>
				This section describes the format of the Certificate Block and the fields used
				within the Certificate Block, as well as the syslog messages used to carry
				Certificate Blocks.  
				</t>

				<section anchor="certmsg" title="syslog Messages Containing a Certificate Block">
					<t>
					Certificate Blocks are used to get the Payload Block to the collector.
					As with a Signature Block, each Certificate Block is carried in its 
					own syslog message, 
					called Certificate Block message.  
					</t>
					<t>
					Because certificates can legitimately be much longer than 2048 octets,
					the Payload Block can be split up into several pieces, with 
					each Certificate Block carrying a piece of the Payload Block.  
					Note
					that the originator MAY make the Certificate Blocks of any legal length
					(that is, any length that keeps the entire Certificate Block message 
					within 2048 octets) that holds all the
					required fields. Software that processes Certificate Blocks MUST
					deal correctly with blocks of any legal length.
					The length of the fragment of the Payload Block that a Certificate Block
					carries MUST be at least 1 octet.  The length SHOULD be chosen 
					such that the length of the Certificate
					Block message does not exceed 2048 octets.  
					</t>
					<t>
					A Certificate Block message 
					is identified by the presence of an
					SD ELEMENT 
					with an SD-ID with the value "ssign-cert".  
					In addition, a Certificate Block message 
					MUST contain valid APP-NAME, PROCID, and MSGID fields to be compliant with 
					syslog protocol.    
					Syslog-sign does not mandate particular values for these fields; however, 
					for consistency, implementations SHOULD use the 
					same value for APP-NAME, PROCID, and MSGID fields for 
					every Certificate Block message, whichever values are chosen.  
					It is RECOMMENDED to use 110 as value 
					for the PRI field, corresponding to facility 13 and severity 6 (informational).  
					The Certificate Block is 
					carried as Structured Data within the Certificate Block message.   
					A Certificate Block 
					message SHOULD NOT carry other Structured Data besides the Structured Data of the 
					Certificate Block itself.  The MSG part of a Certificate Block message SHOULD be empty.  
					</t>
				</section>

				<section anchor="certblock" title="Certificate Block Format and Fields">

					<t>
					The contents of a Certificate Block message is the Certificate Block itself.  
					Like a Signature Block, the Certificate Block is encoded as an SD ELEMENT.   
					The SD-ID of the Certificate Block is "ssign-cert".  
					The Certificate Block is composed of the following fields, each of which is 
					encoded as an SD Parameter with parameter name as indicated. Each field
					must be printable ASCII, and any binary values are base 64 encoded per 
					<xref target="RFC4648">RFC 4648</xref>.
					</t>

					<figure>
						<artwork>
    Field                       SD-PARAM-NAME      Size in octets
    -----                       -------------      ---- -- ------

    Version                          VER                 4

    Reboot Session ID               RSID                1-10

    Signature Group                   SG                 1

    Signature Priority              SPRI                1-3

    Total Payload Block Length      TPBL                1-8

    Index into Payload Block       INDEX                1-8

    Fragment Length                 FLEN                1-4

    Payload Block Fragment          FRAG              variable
                                             (base 64 encoded binary)

    Signature                       SIGN             variable
                                             (base 64 encoded binary)
						</artwork>
					</figure>
				
					<t>
					A Certificate Block is accordingly encoded as follows, where xxx denotes a 
					placeholder for the particular values: 
					</t>
					<t>
					[ssign-cert VER="xxx" RSID="xxx" SG="xxx" SPRI="xxx" TBPL="xxx" 
					INDEX="xxx" FLEN="xxx" FRAG="xxx" SIGN="xxx"]  
					</t>
					<t>
					Values of the fields constitute SD parameter values and are hence enclosed in quotes, 
					per <xref target="syslog-protocol">RFC xxxx</xref>.  
					The fields are separated by single spaces and are described below.
					</t>

					<section anchor="VersionCER" title="Version">
						<t>
						The Signature Group version field is 4 octets in length. 
						This field is identical in format and meaning to the
						Version field described in <xref target="Version" />.
						</t>
					</section>

					<section anchor="rebootidCER" title="Reboot Session ID">
						<t>
						The Reboot Session ID is identical in format and meaning to the 
						RSID field described in
						<xref target="rebootid" />.
						</t>
					</section>

					<section anchor="siggrpCER" title="Signature Group and Signature Priority">
						<t>
						The SIG field is identical in format and meaning to the SIG field described in
						<xref target="siggrp" />.  
						The SPRI field is identical in format and meaning to the SPRI field described there.
						</t>
					</section>

					<section anchor="tpbl" title="Total Payload Block Length">
						<t>
						The Total Payload Block Length is a value representing the total length
						of the Payload Block in octets, expressed as a decimal with one to eight octets.
						</t>
					</section>

					<section anchor="index" title="Index into Payload Block">
						<t>
						This is a decimal value between 1 and 8 octets, 
						with leading zeroes omitted.  
						It contains the number of octets
						into the Payload Block at which this fragment starts.  The first octet of
						the first fragment is numbered "1".
						</t>
					</section>

					<section anchor="fraglen" title="Fragment Length">
						<t>
						The total length of this fragment expressed as a decimal integer
						with one to four octets.  The fragment length must be at least 1.  
						</t>
					</section>

					<section anchor="pbfragment" title="Payload Block Fragment">
						<t>
						The Payload Block Fragment contains a fragment of the payload block, 
						encoded in base 64, as per <xref target="RFC4648">RFC 4648</xref>.  
						Its length must match the indicated fragment length.    
						</t>
					</section>

					<section anchor="sigCER" title="Signature">
						<t>
						This is a digital signature, encoded in base 64, as per 
						<xref target="RFC4648">RFC 4648</xref>. The Version field effectively specifies the
						original encoding of the signature. The signature is 
						calculated over the completely formatted syslog message, including
						all of the PRI, HEADER, and certificate block, 
						excluding spaces between fields, and also excluding the 
						signature field itself (SD Parameter Name "SIGN", "=", and corresponding value).  
						</t>
					</section>
				</section>
			</section>
		</section>
		<section anchor="redunnflex" title="Redundancy and Flexibility">
			<t>
			There is a general rule that determines how redundancy works and
			what level of flexibility the originator and collector have in message
			formats: in general, the originator is allowed to send Signature and
			Certificate Blocks multiple times, to send Signature and Certificate
			Blocks of any legal length, to include fewer hashes in hash blocks,
			etc.
			</t>

			<section anchor="redun" title="Redundancy">
				<t>
				Syslog messages are in general sent over unreliable transport, which means that
				they can be lost in transit. However, if a collector does not receive
				Signature and Certificate Blocks, many messages may not be able to
				be verified. Sending Signature and Certificate Blocks multiple times
				provides redundancy; because the collector MUST ignore
				Signature/Certificate Blocks it has already received and
				authenticated, the originator can in principle change its redundancy
				level for any reason, without communicating this fact to the
				collector.
				</t>

				<t>
				Although the transport sender is not constrained in how it decides to send
				redundant Signature and Certificate Blocks, or even in whether it
				decides to send along multiple copies of normal syslog messages,
				we define some redundancy parameters below which may be useful
				in controlling redundant transmission from the transport sender to the
				transport receiver, and which may be useful for administrators to configure.  
				</t>

				<section anchor="redunCertblk" title="Configuration Parameters for Certificate Blocks">
					<t>
					certInitialRepeat = number of times each Certificate Block should be
					sent before the first message is sent.
					</t>

					<t>
					certResendDelay  = maximum time delay in seconds to delay before
					next redundant sending.
					</t>

					<t>
					certResendCount  = maximum number of sent messages to delay before
					next redundant sending.
					</t>
				</section>

				<section anchor="redunSigblk" title="Configuration Parameters for Signature Blocks">
					<t>
					sigNumberResends = number of times a Signature Block is resent.
					</t>

					<t>
					sigResendDelay   = maximum time delay in seconds from original
					sending to next redundant sending.
					</t>

					<t>
					sigResendCount   = maximum number of sent messages to delay before
					next redundant sending.
					</t>
				</section>
			</section>

			<section anchor="flex" title="Flexibility">
				<t>
				An originator may change many things about the makeup of Signature and
				Certificate Blocks in a given reboot session. The things it cannot
				change are:

				<list style="empty">
					<t>
					* The version
					</t>

					<t>
					* The number or arrangements of Signature Groups
					</t>
				</list>

				It is legitimate for an originator to send short Signature Blocks
				to allow the collector to verify messages quickly. 
   				</t>
			</section>
		</section>

		<section anchor="verify" title="Efficient Verification of Logs">
			<t>
			The logs secured with syslog-sign may be reviewed either online or
			offline. Online review is somewhat more complicated and
			computationally expensive, but not prohibitively so.
			</t>

			<section anchor="offline" title="Offline Review of Logs">
				<t>
				When the collector stores logs to be reviewed later, they can be
				authenticated offline just before they are reviewed. Reviewing these
				logs offline is simple and relatively inexpensive in terms of resources
				used, so long as there is enough space available on the reviewing
				machine. Here, we presume that the stored log files have
				already been separated by originator, Reboot Session ID, and Signature
				Group. This can be done easily with a script file. We then do
				the following:

				<list style="letters">
					<t>
					First, we go through the raw log file and split its contents
					into three files. Each message in the raw log file is classified
					as a normal message, a Signature Block message, or a Certificate Block message.
					Signature Blocks and Certificate Blocks are then stored in their own
					files. Normal messages are stored in a keyed file, indexed on
					their hash values.
					</t>
					
					<t>
					We sort the Certificate Block file by INDEX value, and check to
					see whether we have a set of Certificate Blocks that can reconstruct
					the Payload Block. If so, we reconstruct the Payload Block,
					verify any key-identifying information, and then use this to
					verify the signatures on the Certificate Blocks we have received.
					When this is done, we have verified the reboot session and key
					used for the rest of the process.
					</t>
					
					<t>
					We sort the Signature Block file by First Message Number. We now
					create an authenticated log file, which consists of some
					header information and then a sequence of message number,
					message text pairs. We next go through the Signature Block file.
					For each Signature Block in the file, we do the following:
					
					<list style="numbers">
						<t>
						Verify the signature on the Block.
						</t>

						<t>
						For each hashed message in the Block:

						<list style="letters">
							<t>
							Look up the hash value in the keyed message file.
							</t>
							
							<t>
							If the message is found, write (message number, message
							text) to the authenticated log file.
							</t>
						</list>
						
						Skip all other Signature Blocks with the same
						First Message Number.
						</t>
					</list>
					
					The resulting authenticated log file contains all messages
					that have been authenticated.  In addition, it implicitly indicates 
					all gaps in the authenticated messages (specifically 
					in the case when all messages of the same Signature Group 
					are sent to the same collector), because their 
					message numbers are missing. 
					</t>
				</list>
				
				One can see that, assuming sufficient space for building
				the keyed file, this whole process is linear in the number of
				messages (generally two seeks, one to write and the other to read,
				per normal message received), and O(N lg N) in the number of
				Signature Blocks. This estimate comes with two caveats: first, the
				Signature Blocks arrive very nearly in sorted order, and so can
				probably be sorted more cheaply on average than O(N lg N) steps.
				Second, the signature verification on each Signature Block
				almost certainly is more expensive than the sorting step in
				practice. We have not discussed error-recovery, which may be
				necessary for the Certificate Blocks. In practice, a simple
				error-recovery strategy is probably enough: if the Payload
				Block is not valid, then we can just try alternate
				instances of each Certificate Block, if such are available, until we
				get the Payload Block right.
				</t>
				
				<t>
				It is easy for an attacker to flood us with plausible-looking
				messages, Signature Blocks, and Certificate Blocks.
				</t>
			</section>
			
			<section anchor="online" title="Online Review of Logs">
				<t>
				Some collector implementations may need to monitor log
				messages in close to real-time. This can be done with
				syslog-sign, though it is somewhat more complex than offline
				verification. This is done as follows:
				
				<list style="letters">
					<t>
					We have an authenticated message file, into which we write (message number,
					message text) pairs which have been authenticated. Again, we will
					assume that we are handling only one Signature Group and only one
					Reboot Session ID at any given time.
					</t>
					
					<t>
					We have three data structures: A queue in which (message
					number, hash of message) pairs are kept in sorted order, a queue
					in which (arrival sequence, hash of message) pairs are kept in sorted
					order, and a hash table that stores (message text, count) pairs
					indexed by hash value. In the hash table, count may be any number
					greater than zero; when count is zero, the entry in the hash
					table is cleared.
					</t>
					
					<t>
					We must receive all the Certificate Blocks before any other
					processing can really be done. (This is why they are sent first.)
					Once that is done, any Certificate Block message that arrives is
					discarded.
					</t>
					
					<t>
					Whenever a normal message arrives, we add (arrival sequence,
					hash of message) to our message queue. If our hash table has an
					entry for the message's hash value, we increment its count by
					one; otherwise, we create a new entry with count = 1. If the
					message queue is full, we roll the oldest messages off the queue
					by taking the oldest entry in the queue, and using it to index the
					hash table. If that entry has count 1, we delete the entry from
					the hash table; otherwise, we decrement its count.  We then
					delete the oldest entry in the queue.
					</t>
					
					<t>
					Whenever a Signature Block message arrives, we first check to see whether the
					First Message Number value is too old to still be of interest, 
					or if another Signature
					Block with that First Message Number has already been received. If
					so, we discard the Signature Block. Otherwise, we check
					its signature and discard it if the signature is not valid. A
					Signature Block contains a sequence of (message number, message
					hash) pairs. For each pair, we first check to see whether the message
					hash is in the hash table. If so, we write the (message
					number, message text) into the authenticated message queue.
					Otherwise, we write the (message number, message hash) to the
					message number queue. This generally involves rolling the oldest
					entry out of this queue: before this is done, that entry's hash
					value is again looked up in the hash table. If a matching
					entry is found, the (message number, message text) pair is
					written to the authenticated message file. In either case,
					the oldest entry is then discarded.
					</t>
					
					<t>
					The result of this is a sequence of messages in the
					authenticated message file, each of which has been
					authenticated, and which are labeled with numbers showing their
					order of original transmission.
					</t>
				</list>
				
				One can see that this whole process is roughly linear
				in the number of messages, and also in the number of Signature
				Blocks received. The process is susceptible to flooding attacks; an
				attacker can send enough normal messages that the messages roll off
				their queue before their Signature Blocks can be processed.
				</t>
			</section>
		</section>

		<section anchor="security" title="Security Considerations">
			<t>
			Normal syslog event messages are unsigned and have most of the security attributes
			described in Section 8 
			of <xref target="syslog-protocol">RFC xxxx</xref>.  This document also describes Certificate Blocks
			and Signature Blocks, which are signed syslog messages.  The Signature Blocks contain
			signature information for previously sent syslog event messages.  All of this 
			information can be used to authenticate syslog messages and to minimize or obviate
			many of the security concerns described in <xref target="syslog-protocol">RFC xxxx</xref>.  
			</t>

			<section anchor="SecCrypto" title="Cryptographic Constraints">
				<t>
				As with any technology involving cryptography, it is advisable to check
				the current literature to determine whether any algorithms used here
				have been found to be vulnerable to attack.
				</t>
			
				<t>
				This specification uses Public Key Cryptography
				technologies. The proper party or parties have to control
				the private key portion of a public-private key pair.
				Any party that controls a private key can sign anything
				it pleases.
				</t>

				<t>
				Certain operations in this specification involve the use of
				random numbers. An appropriate entropy source SHOULD be used to
				generate these numbers. See <xref target="RFC4086">RFC 4086</xref>
				and <xref target="NIST800.90">NIST SP 800-90</xref>.
				</t>
			</section>

			<section anchor="SecPacket" title="Packet Parameters">
				<t>
				As an originator, it is advisable to avoid message lengths exceeding 2048 octets.  
				Various problems might result
				if an originator were to send messages with a length greater than 2048
				octets, because relays MAY truncate messages with lengths 
				greater than 2048 octets which would make it impossible for collectors to 				
				validate a hash of the packet.  To increase
				the chance of interoperability, it tends to be  
				best to be conservative with what
				you send but liberal in what you are able to receive.  
				</t>

				<t>
				Originators need to rigidly enforce the correctness of message bodies.
				Problems may 
				arise if the collector does not fully accept the syslog packets sent from an
				originator, or if it has problems with the format of the Certificate Block or
				Signature Block messages.
				</t>

				<t>
				Collectors are not to malfunction in case they receive malformed syslog messages or 
				messages containing characters other than those specified in this document.  In other 
				words, they are to ignore such messages and continue working.
				</t>
			</section>

			<section anchor="SecAuth" title="Message Authenticity">
				<t>
				Syslog does not strongly associate the message
				with the message originator.  That association is established by the collector upon verification
				of the Signature Block.  Before a Signature Block is used to
				ascertain the authenticity of an event message, it might be received, stored, and
				reviewed by a person or automated parser.  It is advisable not to assume a message is 
				authentic until after a message has been
				validated by checking the contents of the Signature Block.
				</t>

				<t>
				With the Signature Block checking, an attacker may only forge messages if it
				can compromise the private key of the true originator.  
				</t>
			</section>

			<section anchor="SeqReplay" title="Replaying">
				<t>
				Event messages might be recorded and replayed by an
				attacker.  Using the information contained in the
				Signature Blocks, a reviewer can determine whether the received messages are the ones
				originally sent by an originator.  The reviewer can also identify messages that have 
				been replayed.  
				</t>
			</section>
			
			<section anchor="SecRelDel" title="Reliable Delivery">
				<t>
				<xref target="syslog-transport-tls">RFC wwww</xref> can be used for the reliable delivery of
				syslog messages.  Event messages sent over UDP might be lost in transit.
				A reviewer can pinpoint any messages sent by the originator but not 
				received by the collector by reviewing the Signature Block information.  
				In addition, the information in
				subsequent Signature Blocks allows a
				reviewer to determine whether any Signature Block messages
				were lost in transit.
				</t>
			</section>

			<section anchor="SecSeq" title="Sequenced Delivery">
				<t>
				Syslog messages delivered over UDP might not only be lost, but
				also arrive out of sequence.  
				A reviewer can determine the original order of syslog messages and identify 
				which messages were delivered out of order by examining the information 
				in the Signature Block 
				along with any timestamp information in the message.
				</t>
			</section>

			<section anchor="SecInt" title="Message Integrity">
				<t>
				Syslog messages might be damaged in transit.  A review of
				the information in the Signature Block determines whether
				the received message was the intended message sent by
				the originator. A damaged Signature Block or Certificate
				Block is evident because the collector will not be
				able to validate that it was signed by the originator.
				</t>
			</section>

			<section anchor="SecObs" title="Message Observation">
				<t>
				Event messages, Certificate Blocks, and Signature Blocks are all sent in plaintext.  
				This allows network administrators to read the
				message when sniffing the wire.  However, this also allows an attacker to see the
				contents of event messages and perhaps to use that information for malicious purposes.
				</t>
			</section>

			<section anchor="SecMITM" title="Man In The Middle Attacks">
				<t>
				It is conceivable that an attacker might intercept Certificate Block messages and insert its
				own Certificate information.  In that case, the attacker would be able to receive
				event messages from the actual originator and then relay modified messages, insert new
				messages, or delete messages.  It would then be able to construct a Signature Block
				and sign it with its own private key.  Network administrators need to verify
				that the key contained in the Payload Block is indeed the key being used on the
				actual originator.  If that is the case, then this MITM attack will not succeed.
				</t>
			</section>

			<section anchor="SecDen" title="Denial of Service">
				<t>

				An attacker might send invalid Signature Block messages to overwhelm the collector's 
				processing capability and consume all available resources.
				For this reason, it can be appropriate to simply 
				receive the Signature Block messages and process them only as time permits.
				</t>
				<t>
				An attacker might also just overwhelm a collector by sending more
				messages to it than it can handle.   
				Implementors are advised to consider features that minimize this threat,  
				such as only accepting syslog messages from known IP addresses.
				</t>
			</section>

			<section anchor="SecCov" title="Covert Channels">
				<t>
				Nothing in this protocol attempts to eliminate covert
				channels.  In fact, just about every aspect of
				syslog messages lends itself to the conveyance of covert
				signals.  For example, a collusionist could send odd and
				even PRI values to indicate Morse Code dashes and dots.
				</t>
			</section>

		</section>

		<section anchor="iana" title="IANA Considerations">
			<section anchor="ianaSyslog" title="Structured Data and syslog messages">
				<t>
				With regard to  <xref target="syslog-protocol">RFC xxxx</xref>,
				IANA is requested to add the following values to the registry entitled "syslog 
				Structured Data id values":    

				<figure title="">
					<artwork>
       SD-ID         PARAM_NAME       
       -----         ----------
       ssign
                     VER
                     RSID
                     SG
                     SPRI
                     GBC
                     FMN
                     CNT
                     HB
                     SIGN

       ssign-cert 
                     VER
                     RSID
                     SG
                     SPRI
                     TBPL
                     INDEX
                     FLEN
                     FRAG
                     SIGN
					</artwork>
				</figure>
				
				In addition, several fields need to be controlled by the IANA in both 
				the Signature Block and the Certificate Block, as outlined in the following
				sections.
				</t>
			</section>
			<section anchor="ianaVer" title="Version Field">
				<t>
				IANA is requested to create three registries, each associated with a different subfield
				of the Version field of Signature Blocks and Certificate Blocks, described in 
				<xref target="Version" /> and <xref target="VersionCER" />, respectively.  
				</t>
				<t>
				The first registry that IANA is requested to create 
				is entitled "syslog-sign protocol version values".   
				It is for the values of the Protocol Version subfield.  The Protocol Version subfield constitutes
				the first 2 octets in the Version field.  
				New values shall be assigned by the IANA using the "IETF Consensus" policy
				defined in <xref target="RFC2434">RFC 2434</xref>.  
				Assigned numbers are to be increased by 1, up to a maximum value of "50".  
				Protocol Version numbers of "51" through "99" are vendor-specific;
				values in this range are not to be assigned by the IANA.  
				</t>
				<t>
				IANA is requested to register the Protocol Version values shown below.  

				<figure title="">
					<artwork>
      VALUE                    PROTOCOL VERSION 
      -----                    ----------------
      00                       Reserved 
      01                       Defined in RFC yyyy
 					</artwork>
				</figure>

				The second registry that IANA is requested to create 
				is entitled "syslog-sign hash algorithm values". 
				It is for the values of the Hash Algorithm subfield.  The Hash Algorithm subfield constitutes 
				the third octet in the Version field Signature Blocks and Certificate Blocks.  
				New values shall be assigned by the IANA using the "IETF Consensus" policy
				defined in <xref target="RFC2434">RFC 2434</xref>.  Assigned values are to 
				be increased by 1, up to a maximum value of "9".  
				The values are registered relative to the Protocol Version.  This means that the same 
				Hash Algorithm value can be reserved for different Protocol Versions, possibly referring
				to a different hash algorithm each time.  This makes it possible to 
				deal with future scenarios in which the single octet representation becomes a limitation, 
				as more Hash Algorithms can be supported by defining additional Protocol Versions that 
				implementations might support concurrently.  
				</t>
				<t>
				IANA is requested to register the Hash Algorithm values shown below.  

				<figure title="">
					<artwork>
      VALUE     PROTOCOL VERSION     HASH ALGORITHM
      -----     ----------------     --------------
      0         01                   Reserved 
      1         01                   SHA1 
      2         01                   SHA256 
 					</artwork>
				</figure>

				The third registry that IANA is requested to create 
				is entitled "syslog-sign signature scheme values". 
				It is for the values of the Signature Scheme subfield.  The Signature Scheme subfield 
				constitutes the fourth octet in the Version field of Signature Blocks and Certificate Blocks.  
				New values shall be assigned by the IANA using the "IETF Consensus" policy
				defined in <xref target="RFC2434">RFC 2434</xref>.  Assigned values are to 
				be increased by 1, up to a maximum value of "9".  This means that the same 
				Signature Scheme value can be reserved for different Protocol Versions, possibly in each 
				case referring to a different Signature Scheme each time.  This makes it possible to 
				deal with future scenarios in which the single octet representation becomes a limitation, 
				as more Signature Schemes can be supported by defining additional Protocol Versions that 
				implementations might support concurrently.  
				</t>
				<t>
				IANA is requested to register the Signature Scheme values shown below.  

				<figure title="">
					<artwork>
      VALUE     PROTOCOL VERSION    SIGNATURE SCHEME
      -----     ----------------    ----------------
      0         01                  Reserved 
      1         01                  OpenPGP DSA 
 					</artwork>
				</figure>
				</t>
			</section>

			<section anchor="ianaSIG" title="SG Field">
				<t>
				IANA is requested to create a registry entitled "syslog-sign sg field values".  
				It is for values of the SG Field as defined in <xref target="siggrp" />.
				New values shall be assigned by 
				the IANA using the "IETF Consensus" policy defined in 
				<xref target="RFC2434">RFC 2434</xref>.  Assigned values are to be incremented by 1, 
				up to a maximum value of "7".  
				Values "8" and "9" shall be left as vendor specific and shall not be assigned by the IANA.
				</t>
				<t>
				IANA is requested to register the SG Field values shown below.

				<figure title="">
					<artwork>
      VALUE     MEANING
      -----     -------
      0         per RFC yyyy
      1         per RFC yyyy
      2         per RFC yyyy
      3         per RFC yyyy 
 					</artwork>
				</figure>
				</t>

			</section>
			
			<section anchor="ianabuild" title="Key Blob Type">
				<t>
				IANA is requested to create a registry entitled "syslog-sign key blob type values".   
				It is to register one-character identifiers for the key blob type, per
				<xref target="build" />.  New values shall be assigned by 
				the IANA using the "IETF Consensus" policy defined in 
				<xref target="RFC2434">RFC 2434</xref>.  Uppercase letters may be assigned as values.  
				Lowercase letters are left as vendor specific and shall not be assigned by the IANA.	
				</t>
				<t>
				IANA is requested to register the key blob type values shown below.

				<figure title="">
					<artwork>
      VALUE     KEY BLOB TYPE
      -----     ------------
      'C'       a PKIX certificate
      'P'       an OpenPGP certificate
      'K'       the public key whose corresponding private key is used to sign the messages
      'N'       no key information sent, key is predistributed
      'U'       installation-specific key exchange information
 					</artwork>
				</figure>
				</t>
			</section>
		</section>

		<section anchor="authors" title="Working Group">

			<t>
			The working group can be contacted via the mailing list:

				<figure><artwork>
      syslog@ietf.org
				</artwork></figure>
			</t>

			<t>
			The current Chairs of the Working Group can be contacted at:
				<figure><artwork>
      Chris Lonvick
      Cisco Systems
      Email: clonvick@cisco.com

      David Harrington
      Huawei Technologies (USA)
      Email: ietfdbh@comcast.net
             dharrington@huawei.com
      Tel: +1-603-436-8634
				</artwork></figure>
			</t>

		</section>

		<section anchor="acks" title="Acknowledgements">
			<t>
			The authors wish to thank Alex Brown, Chris Calabrese, Steve Chang, Carson
			Gaspar, Drew Gross, David Harrington, Chris Lonvick, Darrin New, Marshall Rose, 
			Holt Sorenson, Rodney Thayer, Andrew Ross, Rainer Gerhards, Albert Mietus, 
			and the many Counterpane Internet Security engineering and 
			operations people who commented on various versions of this proposal.
			</t>
		</section>
	</middle>
	<back>
		<references title="Normative References">
			<reference anchor="FIPS.186-2.2000" target="http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf">
				<front>
				<title>Digital Signature Standard</title>
				<author>
				<organization>National Institute of Standards and Technology</organization>
				</author>
				<date month="January" year="2000" />
				</front>

				<seriesInfo name="FIPS" value="PUB 186-2" />
			</reference>
			


			<reference anchor="FIPS.180-2.2002" target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">
				<front>
				<title>Secure Hash Standard</title>
				<author>
				<organization>National Institute of Standards and Technology</organization>
				</author>
				<date month="August" year="2002" />
				</front>

				<seriesInfo name="FIPS" value="PUB 180-2" />
			</reference>

			<reference anchor="NIST800.90" target="http://csrc.nist.gov/publications/nistpubs/800-90/SP800-90_DRBG-June2006-final.pdf">
				<front>
				<title>NIST Special Publication 800-90: Recommendation for Random Number Generation using Deterministic Random Bit Generators</title>
				<author>
				<organization>National Institute of Standards and Technology</organization>
				</author>
				<date month="June" year="2006" />
				</front>
			</reference>
			
	            <reference anchor='RFC2434'>

				<front>
				<title abbrev='Guidelines for IANA Considerations'>Guidelines for Writing an IANA Considerations Section in RFCs</title>
				<author initials='T.' surname='Narten' fullname='Thomas Narten'>
				<organization>IBM Corporation</organization>
				<address>
				<postal>
				<street>3039 Cornwallis Ave.</street>
				<street>PO Box 12195 - BRQA/502</street>

				<street>Research Triangle Park</street>
				<street>NC 27709-2195</street></postal>
				<phone>919-254-7798</phone>
				<email>narten@raleigh.ibm.com</email></address></author>
				<author initials='H.T.' surname='Alvestrand' fullname='Harald Tveit Alvestrand'>
				<organization>Maxware</organization>
				<address>
				<postal>
				<street>Pirsenteret</street>
				<street>N-7005 Trondheim</street>

				<country>Norway</country></postal>
				<phone>+47 73 54 57 97</phone>
				<email>Harald@Alvestrand.no</email></address></author>
				<date month='October' year='1998' />
				<area>General</area>
				<keyword>Internet Assigned Numbers Authority</keyword>
				<keyword>IANA</keyword>
				<abstract>
				<t>
				Many protocols make use of identifiers consisting of constants and
				other well-known values. Even after a protocol has been defined and
				deployment has begun, new values may need to be assigned (e.g., for a
				new option type in DHCP, or a new encryption or authentication
				algorithm for IPSec).  To insure that such quantities have consistent
				values and interpretations in different implementations, their
				assignment must be administered by a central authority. For IETF
				protocols, that role is provided by the Internet Assigned Numbers
				Authority (IANA).
				</t>
				<t>
				In order for the IANA to manage a given name space prudently, it
				needs guidelines describing the conditions under which new values can
				be assigned. If the IANA is expected to play a role in the management
				of a name space, the IANA must be given clear and concise
				instructions describing that role.  This document discusses issues
				that should be considered in formulating a policy for assigning
				values to a name space and provides guidelines to document authors on
				the specific text that must be included in documents that place
				demands on the IANA.
				</t>
				</abstract>
				</front>

				<seriesInfo name='BCP' value='26' />
				<seriesInfo name='RFC' value='2434' />
				<format type='TXT' octets='25092' target='ftp://ftp.isi.edu/in-notes/rfc2434.txt' />
				<format type='HTML' octets='39811' target='http://xml.resource.org/public/rfc/html/rfc2434.html' />
				<format type='XML' octets='26924' target='http://xml.resource.org/public/rfc/xml/rfc2434.xml' />
			</reference>

			<reference anchor='RFC2440'>

				<front>
				<title>OpenPGP Message Format</title>
				<author initials='J.' surname='Callas' fullname='Jon Callas'>
				<organization>Network Associates, Inc.</organization>
				<address>
				<postal>
				<street>3965 Freedom Circle</street>
				<street>Santa Clara</street>

				<street>CA 95054</street>
				<country>USA</country></postal>
				<phone>+1 408-346-5860</phone>
				<email>jon@pgp.com</email></address></author>
				<author initials='L.' surname='Donnerhacke' fullname='Lutz Donnerhacke'>
				<organization>IKS GmbH</organization>
				<address>
				<postal>
				<street>Wildenbruchstr. 15</street>
				<street>07745 Jena</street>

				<country>Germany</country></postal>
				<phone>+49-3641-675642</phone>
				<email>lutz@iks-jena.de</email></address></author>
				<author initials='H.' surname='Finney' fullname='Hal Finney'>
				<organization>Network Associates, Inc.</organization>
				<address>
				<postal>
				<street>3965 Freedom Circle</street>
				<street>Santa Clara</street>
				<street>CA 95054</street>

				<country>USA</country></postal>
				<email>hal@pgp.com</email></address></author>
				<author initials='R.' surname='Thayer' fullname='Rodney Thayer'>
				<organization>EIS Corporation</organization>
				<address>
				<postal>
				<street>Clearwater</street>
				<street>FL 33767</street>
				<country>USA</country></postal>
				<email>rodney@unitran.com</email></address></author>

				<date month='November' year='1998' />
				<area>Security</area>
				<keyword>pretty good privacy</keyword>
				<keyword>PGP</keyword>
				<keyword>security</keyword>
				<abstract>
				<t>
				This document defines many tag values, yet it doesn&apos;t describe a
				mechanism for adding new tags (for new features).  Traditionally the
				Internet Assigned Numbers Authority (IANA) handles the allocation of
				new values for future expansion and RFCs usually define the procedure
				to be used by the IANA.  However, there are subtle (and not so
				subtle) interactions that may occur in this protocol between new
				features and existing features which result in a significant
				reduction in over all security.  Therefore, this document does not
				define an extension procedure.  Instead requests to define new tag
				values (say for new encryption algorithms for example) should be
				forwarded to the IESG Security Area Directors for consideration or
				forwarding to the appropriate IETF Working Group for consideration.
				</t>
				<t>
				This document is maintained in order to publish all necessary
				information needed to develop interoperable applications based on the
				OpenPGP format. It is not a step-by-step cookbook for writing an
				application. It describes only the format and methods needed to read,
				check, generate, and write conforming packets crossing any network.
				It does not deal with storage and implementation questions.  It does,
				however, discuss implementation issues necessary to avoid security
				flaws.

				</t>
				<t>
				Open-PGP software uses a combination of strong public-key and
				symmetric cryptography to provide security services for electronic
				communications and data storage.  These services include
				confidentiality, key management, authentication, and digital
				signatures. This document specifies the message formats used in
				OpenPGP.
				</t></abstract>
				<note title='IESG Note'>
				<t>
				This document defines many tag values, yet it doesn&apos;t describe a
				mechanism for adding new tags (for new features).  Traditionally the
				Internet Assigned Numbers Authority (IANA) handles the allocation of
				new values for future expansion and RFCs usually define the procedure
				to be used by the IANA.  However, there are subtle (and not so
				subtle) interactions that may occur in this protocol between new
				features and existing features which result in a significant
				reduction in over all security.  Therefore, this document does not
				define an extension procedure.  Instead requests to define new tag
				values (say for new encryption algorithms for example) should be
				forwarded to the IESG Security Area Directors for consideration or
				forwarding to the appropriate IETF Working Group for consideration.
				</t></note></front>

				<seriesInfo name='RFC' value='2440' />
				<format type='TXT' octets='141371' target='ftp://ftp.isi.edu/in-notes/rfc2440.txt' />
				<format type='HTML' octets='162142' target='http://xml.resource.org/public/rfc/html/rfc2440.html' />
				<format type='XML' octets='137186' target='http://xml.resource.org/public/rfc/xml/rfc2440.xml' />
			</reference>

			<reference anchor='RFC3414'>
				<front>
				<title abbrev='USM for SNMPv3'>User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3)</title>
				<author initials='U.' surname='Blumenthal' fullname='Uri Blumenthal'>
										<organization />
				</author>
				<author initials='B.' surname='Wijnen' fullname='Bert Wijnen'>
										<organization />
				</author>
				<date month='December' year='2002' />
				</front>
				<seriesInfo name='RFC' value='3414' />
				<format type='TXT' octets='193558' target='ftp://ftp.isi.edu/in-notes/rfc3414.txt' />
			</reference>

			<reference anchor='RFC4648'>
				<front>
					<title>The Base16, Base32, and Base64 Data Encodings</title>
					<author initials='S.' surname='Josefsson' fullname='S. Josefsson'>
						<organization />
					</author>

					<date month='October' year='2006' />
				</front>

					<seriesInfo name='RFC' value='4648' />
					<format type='TXT' octets='26363' target='ftp://ftp.isi.edu/in-notes/rfc4648.txt' />
			</reference>

			<reference anchor="syslog-protocol">
				<front>
					<title>The syslog Protocol, draft-ietf-syslog-protocol-23.txt (work in progress) </title>
					<author initials='R.' surname='Gerhards' fullname='R. Gerhards'>
						<organization />
					</author>

					<date month='September' year='2007' />
				</front>

			</reference>

			<reference anchor="syslog-transport-udp">
				<front>
					<title>Transmission of syslog Messages over UDP, 
						draft-ietf-syslog-transport-udp-12.txt (work in progress) </title>
					<author initials='A.' surname='Okmianski' fullname='A. Okmianski'>
						<organization />
					</author>

					<date month='September' year='2007' />
				</front>

			</reference>

			<reference anchor="syslog-transport-tls">
				<front>
					<title>TLS Transport Mapping for syslog, draft-ietf-syslog-transport-tls-10.txt (work in progress) </title>
					<author initials='F.' surname='Miao' fullname='F. Miao'>
						<organization />
					</author>
					<author initials='M.' surname='Yuzhi' fullname='M. Yuzhi'>
						<organization />
					</author>
					<date month='May' year='2007' />
				</front>

			</reference>

		</references>

		<references title="Informative References">

			<reference anchor='RFC2119'>

				<front>
				<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
				<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
				<organization>Harvard University</organization>
				<address>
				<postal>
				<street>1350 Mass. Ave.</street>
				<street>Cambridge</street>

				<street>MA 02138</street></postal>
				<phone>- +1 617 495 3864</phone>
				<email>-</email></address></author>
				<date month='March' year='1997' />
				<area>General</area>
				<keyword>keyword</keyword>
				<abstract>
				<t>
				In many standards track documents several words are used to signify
				the requirements in the specification.  These words are often
				capitalized.  This document defines these words as they should be
				interpreted in IETF documents.  Authors who follow these guidelines
				should incorporate this phrase near the beginning of their document:
				<list>
				<t>
				The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL
				NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and
				&quot;OPTIONAL&quot; in this document are to be interpreted as described in
				RFC 2119.
				</t>
				</list>
				</t>
				<t>
				The force of these words is modified by the requirement
				level of the document in which they are used.
				</t>
				</abstract>
				</front>

				<seriesInfo name='BCP' value='14' />
				<seriesInfo name='RFC' value='2119' />
				<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
				<format type='HTML' octets='15902' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
				<format type='XML' octets='5647' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
			</reference>
			

			<reference anchor='RFC3339'>
				<front>
					<title>Date and Time on the Internet: Timestamps</title>
					<author initials='G.' surname='Klyne' fullname='G. Klyne'>
						<organization />
					</author>
					<author initials='C.' surname='Newman' fullname='C. Newman'>
						<organization />
					</author>

					<date month='July' year='2002' />
				</front>

					<seriesInfo name='RFC' value='3339' />
					<format type='TXT' octets='35064' target='ftp://ftp.isi.edu/in-notes/rfc3339.txt' />
			</reference>


			<reference anchor='RFC4086'>
				<front>
					<title>Randomness Recommendations for Security</title>
					<author initials='D.E.' surname='Eastlake' fullname='Donald E. Eastlake 3rd'>
					<organization>Digital Equipment Corporation</organization>
					<address>
					<postal>
					<street>550 King Street</street>
					<street>LKG2-1/BB3</street>

					<city>Littleton</city>
					<region>MA</region>
					<code>01460</code>
					<country>US</country></postal>
					<phone>+1 508 486 6577</phone>
					<email>dee@lkg.dec.com</email></address></author>
					<author initials='J.I.' surname='Schiller' fullname='Jeffrey I. Schiller'>

					<organization>Massachusetts Institute of Technology</organization>
					<address>
					<postal>
					<street>77 Massachusetts Avenue</street>
					<city>Cambridge</city>
					<region>MA</region>
					<code>02139</code>
					<country>US</country></postal>
					<phone>+1 617 253 0161</phone>
					<email>jis@mit.edu</email></address></author>

					<author initials='S.' surname='Crocker' fullname='Stephen D. Crocker'>
					<organization>CyberCash Inc.</organization>
					<address>
					<postal>

					<street>2086 Hunters Crest Way</street>
					<city>Vienna</city>
					<region>VA</region>
					<code>22181</code>
					<country>US</country></postal>
					<phone>+1 703 620 1222</phone>
					<facsimile>+1 703 391 2651</facsimile>
					<email>crocker@cybercash.com</email></address></author>

					<date month='June' year='2005' />
					<abstract>
					<t>
					Security systems today are built on increasingly strong cryptographic algorithms
					that foil pattern analysis attempts. However, the security of these systems is
					dependent on generating secret quantities for passwords, cryptographic keys, and
					similar quantities.  The use of pseudo-random processes to generate secret
					quantities can result in pseudo-security.  The sophisticated attacker of these
					security systems may find it easier to reproduce the environment that produced the
					secret quantities, searching the resulting small set of possibilities, than to
					locate the quantities in the whole of the number space.
					</t>
					<t>
					Choosing random quantities to foil a resourceful and motivated adversary is
					surprisingly difficult.  This paper points out many pitfalls in using traditional
					pseudo-random number generation techniques for choosing such quantities.  It
					recommends the use of truly random hardware techniques and shows that the existing
					hardware on many systems can be used for this purpose.  It provides suggestions to
					ameliorate the problem when a hardware solution is not available.  And it gives
					examples of how large such quantities need to be for some particular applications.
					</t>
					</abstract>
				</front>
				<seriesInfo name='RFC' value='4086' />
				<format type='TXT' octets='114321' target='ftp://ftp.isi.edu/in-notes/rfc4086.txt' />
			</reference>




		</references>
	</back>
</rfc>
