<?xml version="1.0" encoding="UTF-8"?><?rfc linefile="1:/tmp/CGI28235.1"?><?rfc linefile="1:/tmp/CGI28235.1"?>
<!-- automatically generated by xml2rfc v1.34 on 2010-02-01T21:35:21Z -->
<!-- automatically generated by xml2rfc v1.34 on 2010-02-01T21:35:21Z -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->

<!-- xml2rfc-processed-entity RFC2119 -->
<!-- xml2rfc-processed-entity RFC2629 -->
<!-- xml2rfc-processed-entity RFC3552 -->
<!-- xml2rfc-processed-entity I-D.narten-iana-considerations-rfc2434bis -->
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="bcp" docName="draft-tkeiser-rxrpc-sec-clear-01" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="Cleartext Peer Identity Assertion">Rx Security Object Providing Cleartext Peer Identity Assertions</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Thomas Keiser" initials="T.E."
            surname="Keiser">
      <organization abbrev="Sine Nomine">Sine Nomine Associates</organization>

      <address>
        <postal>
          <street>43596 Blacksmith Square</street>

          <!-- Reorder these if your country does things differently -->

          <city>Ashburn</city>

          <region>VA</region>

          <code>20147</code>

          <country>USA</country>
        </postal>

        <phone>+1 703 723 6673</phone>

        <email>tkeiser@sinenomine.net</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <date year="2010" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>

    <workgroup>N/A</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>rx</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>
         There are a number of anonymous RxRPC applications which require
         identity assertions in order to ensure that the desired peer receives 
         and processes the procedure call.  This memo defines a replacement for
         the rxnull security class which provides a means for mutually agreeing
         upon who is communicating, without incurring cryptographic overhead.
         It should be noted that, much like rxnull, this security object is not
         suitable for use in a distributed environment due to its inability to
         provide integrity protection.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
         Many high-performance applications based upon Rx RPC cannot tolerate 
         cryptographic overhead.  In order to ensure correctness in the face of
         transport-layer address renumbering, some form of context needs to be 
         established between client and server to permit upper-layer applications 
         to reject processing of remote procedure calls which were misdirected.
      </t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119">RFC 2119</xref>.</t>
      </section>
    </section>

    <section title="Overview of Rx RPC">
      <t>
        Rx RPC is a remote procedure call mechanism built on top of UDP.  In order to establish
        a stateful call context on top of a stateless datagram protocol, Rx relies upon
        a number of client-asserted header fields to establish a flow-controlled 
        communications channel between peers.  To eliminate the need for context-establishment 
        round-trips, Rx relies upon client assertions to establish a stateful context.
      </t>

      <section title="Packet Mux">
        <t>
          Rx connection objects are identified by a tuple of packet header fields.  The most
          important control field is the most-significant bit of the epoch header field.  When
          this bit is asserted, the connection object is operating in multi-homing mode, as
          specified in <xref target="rx_spec">RXRPC</xref>.
          In the normal Rx operating mode (with the multi-homing bit set to zero), Rx 
          connections are identified by the following tuple: (host, port, epoch, cid), where
          these elemenets are defined as:

          <list style="hanging">
            <t hangText="host:">IPv4 address of peer</t>
            <t hangText="port:">UDP port of peer</t>
            <t hangText="epoch:">Rx header epoch field</t>
            <t hangText="cid:">Rx header cid field (channel ID bits masked to zero)</t>
          </list>

          However, when the multi-homing bit is asserted, the connection identifier tuple becomes:
          (epoch, cid).  Thus, multi-homed Rx connection objects have a shared (epoch, cid) namespace,
          independent of peer address.
        </t>
      </section>

    </section>

    <section title="Presenting Problems">
      <t>
        The design of this Rx security class is motivated by server and client renumbering
        incidents at large AFS-3 deployments.  When a file server is renumbered, there is a several
        hour window until the next VL_GetAddrsU RPC is performed to refresh the file server UUID
        to IPv4 address mappings in the client.  Due to the TTL-based invalidation of stale cached
        mappings, there is a substantial time interval during which RPCs can be delivered to the
        wrong file server, potentially leading to incorrect behavior.
      </t>

      <t>
        Similarly, client renumbering can lead to incorrect behavior due to a loss of cache
        coherence.  The AFS-3 callback mechanism relies upon correct knowledge of client UUID to
        IPv4 address mappings in order to deliver cache invalidation messages to clients.  When
        these mappings become stale due to intervening address renumbering events, advertisement of
        incorrect addresses, NATs, etc. these "call back" remote procedure calls may be delivered to
        the wrong client node.  In some circumstances this can lead to false state of success on the
        file server because an unintended client received, processed, and sent a response of success 
        to the file server.  Due to the success return code, the file server will no longer attempt 
        to deliver the invalidation, and the client to which the call back was supposed to be delivered 
        will continue to operate on stale cached data because it never received the cache invalidation 
        message.
      </t>

      <section title="Node Renumbering">
        <t>
          When servers are renumbered, one potential outcome is that two or more
          machines running the same service will swap addresses.  In this case, there
          is a possibility for the wrong machine to correctly interpret, and attempt to
          execute, a procedure call.
        </t>

        <t>
          In some cases, execution of an RPC by the wrong endpoint will still result in correct 
          behavior.  However, this is not generally true, where execution by an unintended 
          target could result in undefined, or even dangerous, behavior.  For example, in 
          afs3, existence of shadow clones could result in a situation where the RW shadow 
          is updated by an afsint RPC, instead of the canonical RW site.
        </t>
      </section>

      <section title="Epoch ID Multi-Homing Bit">
        <t>
          When the multi-homing bit is asserted, (connection,epoch) tuples become
          globally unique.  This mode of operation permits clients to contact the
          server on multiple addresses, thus allowing client operating systems to route
          datagrams as desired.  Current implementations of Rx bind the connection to
          the first peer address on which a datagram was received.  Since all reply
          datagrams are sent to the bound peer, connection hijacking becomes impossible.
          Unfortunately, this comes at the expense of handling client renumbering
          events.
        </t>
      </section>
    </section>

    <section title="Rx Clear Security Class">
      <t>
        In order to overcome the dangers inherent in assuming stability of transport
        addresses, the Rx Clear security class embeds a security header in all data packets.
        This security header contains application-specific endpoint identifier assertions 
        for both the source and destination.
      </t>

      <t>
        When a datagram is received by the wrong peer, 
        an Rx abort packet will be dispatched notifying the peer of the need to re-bind 
        transport addresses for this connection object.  When such an abort packet is received
        by a client connection, the error will be immediately propagated back to the caller so
        that application-specific logic may be invoked to refresh transport-layer address mappings
        for the intended destination endpoint.  In the server case, this memo standardizes new
        multi-homing Rx connection peer binding semantics which allow for graceful handling of
        client renumbering events.
      </t>

      <section title="Constants">
        <t>
          <list style="hanging" hangIndent="4">
            <t hangText="RX_SEC_ID_CLEAR:">
              An Rx security index will be allocated by the Grand Central Registrar.  As with
              all Rx security indices, this 8 bit integer will uniquely identify the security
              class bound to a given Rx datagram.
            </t>
            <t hangText="RXCL_HDR_VERS_1:">
              Rx Clear security header version 1 will be allocated by the Grand Central
              Registrar.  This version number will correspond to the XDR-encoded data
              structure RxClear_Header, as specified below.
            </t>
            <t hangText="RXCL_ERR_UNKNOWN_VERS:">
              An Rx error code will be allocated which communicates that this version of
              the Rx Clear security header is unsupported by the peer.  This error code will
              be sent as the user payload of an Rx abort packet.
            </t>
            <t hangText="RXCL_ERR_UNKNOWN_ID_TYPE:">
              An Rx error code will be allocated which communicates that this endpoint
              identifier type is not supported by the peer.  This error code will be sent
              as the user payload of an Rx abort packet.
            </t>
            <t hangText="RXCL_ERR_WRONG_PEER:">
              An Rx error code will be allocated which communicates mis-delivery of an
              Rx Clear-protected datagram to the wrong peer.  This error code will be sent 
              as the user payload of an Rx abort packet.
            </t>
<!-- I'm not sure we need this one; commenting out for now
(It was originally intended to be an abort return to the original caller in a case
 where call reply args were mis-delivered due to stale peer binding, and the server
 received an RXCL_ERR_WRONG_PEER abort from that client)
            <t hangText="RXCL_ERR_MH_PEER_MISMATCH:">
              An Rx error code will be allocated which communicates mis-delivery of an
              Rx Clear-protected datagram to the wrong-peer on a connection with the epoch multi-homing
              bit enabled.  This error code will be sent as the user payload of an
              Rx abort packet.
            </t>
-->
            <t hangText="RXCL_ERR_XCID_UNSUPP:">
              An Rx error code will be allocated which communicates to the peer that this
              node is incapable of supporting the extended connection id field.  This error
              code will be sent as the user payload of an Rx abort packet upon receipt of
              an RxClear header containing a non-zero clh_xcid field by a node which cannot
              support extended connection identifiers.
            </t>
          </list>
        </t>
      </section>

      <section title="Security Header">
        <t>
          In order to communicate expectations to the peer, all data packets travelling over
          an RxClear-protected connection will include an XDR-encoded security header which carries
          identity assertions.  The RxClear mechanism uses a header rather than a challenge-
          response mechanism because the additional round-trips required by the Rx challenge-
          response mechanism were deemed too costly for the typical unauthenticated Rx call 
          workload.
        </t>

        <t>
          The proposed security header is an XDR-encoded structure defined as follows:
        </t>

<!-- XXX will XDR correctly compact the first three fields? -->
        <figure align="center" anchor="rxclear_authenticator">
          <artwork>
struct rxClear_Header {
    u_char clh_version;          /* authenticator version number */
    u_char reserved;
    u_short clh_data_off;        /* data payload offset */
    afs_uint32 clh_xcid;         /* extended CID field */
    afs_uint32 clh_data_len;     /* data payload length */
    afs_uint32 clh_trl_off;      /* security trailer offset */
    afs_uint32 clh_flags;        /* miscellaneous control flags */
    afs_uint32 clh_id_type;      /* how to interpret opaque peer
                                    identifier payloads */
    opaque clh_src_id;           /* assertion of client identity */
    opaque clh_dst_id;           /* assertion of server identity */
};
          </artwork>
          <postamble>Rx Clear Security Header</postamble>
        </figure>

        <t>
          This security header will be an XDR-encoded data structure, which will occupy the first octets of the 
          data offset in an Rx packet -- it will start at the offset directly following the Rx packet header.
          The normal packet data will begin at the data offset specified in the clh_data_off field of the security
          header.  All implementations MUST obey an upper limit of 256 octets on the size of the XDR encoded security 
          header.  Implementors SHOULD safely handle packets with oversize security headers.
        </t>

        <t>
          <list style="hanging" hangIndent="4">
            <t hangText="clh_version:">
              This is the version of the Rx Clear security object header.  If this
              version is unknown by the peer, then the connection must be aborted.
            </t>
            <t hangText="clh_data_off:">
              This value specifies the beginning of the data payload, in units of octets from the
              beginning of the Rx packet payload.  This field is used by receivers to determine where to
              begin reading the data payload.
            </t>
            <t hangText="clh_xcid:">
              This field is reserved for future use as an extended connection identifier.  This field is included
              because it is known that there are drafts in-progress which steal bits from the Rx header connection 
              id field in order to provide for additional channel identifiers.  Implementations MUST set this 
              field to zero until extended cid protocol behavior is standardized.
            </t>
            <t hangText="clh_trl_off:">
              This value specifies the offset in octets of the clear security class packet trailer.  A value
              of zero indicates the absence of a security trailer.
            </t>
            <t hangText="clh_flags:">
              These bits are reserved for future allocation by the Grand Central Registrar.
            </t>
            <t hangText="clh_id_type:">
              This field identifies the contents of the src_id and dst_id opaque fields.  Values within
              this namespace are allocated by the Grand Central Registrar.
            </t>
            <t hangText="clh_src_id:">
              This field contains an application-specific source endpoint identifier.  For example, in the
              case of afs3, this will likely be a node UUID.
            </t>
            <t hangText="clh_dst_id:">
              This field contains an application-specific destination endpoint identifier.  For example, in the
              case of afs3, this will likely be a node UUID.
            </t>
          </list>
        </t>
      </section>

      <section title="Data Packet Validation">
        <t>
          Upon receipt of a data packet with the security index set to RX_SEC_ID_CLEAR, the node will XDR decode the
          security header, and subsequently validate the security header.  Following XDR decode, the node shall
          first verify that the clh_version field contains a supported version number.  In the event that the node
          does not support this RxClear version, the node will send an Rx abort packet to the peer with error code
          RXCL_ERR_UNKNOWN_VERS.
        </t>

        <t>
          The second step in validation involves the extended connection identifier field, clh_xcid.  If this node
          does not support extended cid, and the clh_xcid field is non-zero, then an abort packet with user payload
          RXCL_ERR_XCID_UNSUPP should be sent to the peer, and the connection should transition to an error state.
        </t>

        <t>
          Next, the application-specific endpoint identifier type specified in clh_id_type field is validated to ensure
          that the application layer can handle this identifier type.  If this endpoint identifier type is not 
          supported by the application layer, then the node will send an Rx abort packet with user payload of 
          RXCL_ERR_UNKNOWN_ID_TYPE, and the connection should transition to an error state.
        </t>

        <t>
          The application layer will then be asked to validate the clh_dst_id field.  If there is a mismatch, an
          abort packet will be sent to the peer with user payload RXCL_ERR_WRONG_PEER, and the Rx connection will then 
          transition into an error state.
        </t>
      </section>

      <section title="Abort Packet Handling">
        <t>
          Processing of received Rx Abort packets must be updated to handle the new RXCL_ERR_ error codes.  If such an error
          code is received on a connection with security index other than RX_SEC_ID_CLEAR, then behavior is undefined.
        </t>

        <section title="RXCL_ERR_UNKNOWN_VERS">
          <t>
            This error code indicates that the peer is unable to support the version of the RxClear security header sent in
            a packet.  The connection is transitioned into an error state.
          </t>
        </section>

        <section title="RXCL_ERR_UNKNOWN_ID_TYPE">
          <t>
            This error code indicates that the peer is unable to support this application-specific endpoint identifier type.
            The connection is transitioned into an error state.
          </t>
        </section>

        <section title="RXCL_ERR_WRONG_PEER">
          <t>
            This error code indicates that the packet was delivered to the wrong peer.  Behavior in this situation depends on
            several factors.  First, for connections where the epoch multi-homing bit is zero, the connection must be 
            transitioned to an error state.  For multi-homed connections, behavior further depends upon whether this is a
            client connection, or a server connection.  For client connections, the easiest course of action is to set the
            connection to an error state, and allow the client to re-resolve the application-specific endpoint-identifier to
            transport identifier mapping, allocate a new Rx connection, and re-try the call.

            In the case of a multi-homed server connection, the implementation SHOULD make a best-effort try to deliver the 
            call reply data to the correct destination, as this may be a non-idempotent procedure call.  This memo outlines 
            in detail new peer binding semantics for multi-homed Rx connections in another section.  Hence, whenever it is
            possible, the server will not transition a server connection into an error state upon receipt of this message.
            Instead, it SHOULD invalidate the peer currently bound to the connection so that future replies go to a different,
            hopefully correct, transport address.
          </t>
        </section>

        <section title="RXCL_ERR_XCID_UNUSPP">
          <t>
            This error code indicates that the peer is unable to support the extended connection identifier field in the
            RxClear security header.  The connection is transitioned to error state, and the implementation SHOULD mark the
            peer as being incapable of supporting extended connection identifiers so that connections allocated to this peer
            in the future contain a clh_xcid field with value zero.
          </t>
        </section>
      </section>
    </section>

    <section title="Multi-Home Behavior">
      <t>
        Rx supports multi-homed clients through the assertion of the most-significant bit in the Rx header epoch field.
        When this bit is asserted, a server will accept datagrams into a connection regardless of the source host address
        and port.  However, reply packets are always sent to the first peer address which contacted the server on any given
        (epoch, cid) tuple.  This behavior prevents connection hijacking, at the expense of robust multi-homing support.
      </t>

      <t>
        In order to properly support multi-homing this memo specifies relaxation of the peer binding policies.
        Most importantly, upon receipt of an RXCL_ERR_WRONG_PEER abort packet, an Rx server should
        not transition a server-mode connection to an error state.  Rather, it SHOULD mark the peer currently bound to the Rx
        connection as being incorrect so that responses may be sent to a different peer, as determined upon receipt of the next 
        ping packet.  Although this does open up room for connection hijacking, it does so only for anonymous connections, which
        are otherwise exposed to denial of service attacks.
      </t>

      <t>
        To address the issue of lack of response, new Rx server implementations SHOULD permit re-binding of the peer
        on server-mode connections.  To this end, servers should track liveness of peer addresses on a server connection
        in order to remove a dead peer from a connection.  If an Rx ping comes from an address other than the currently bound
        peer transport address, the Rx implementation MAY try to re-send unacknowledged packets to this other address.  If 
        these re-transmits are correctly aknowledged, the connection may be re-bound to the new peer.
      </t>

<!-- 
     XXX do we need/want to provide some text on rules/heuristics to be employed to attempt to limit session hijacking?
     e.g. do we want to limit this behavior to certain packet types that actually demonstrate that the peer has knowledge
     of enough state to "prove" (in a probabilistic sense) that it is the peer, and not some random hijacker? 

     All of which leads into the bigger question: given that Rx is susceptible to plenty of other DoS holes (e.g. spoofed aborts),
     does hijacking of an unauthenticated call really matter all that much?
-->
    </section>

    <?rfc needLines="8" ?>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        I would like to thank all of the participants at the 2009 Edinburgh AFS hackathon for their input into
        the design of this security mechanism.  Specifically, I would like to thank Jeffrey Altman for suggesting that it
        would be architecturally cleaner to place peer identity assertions into a security header, rather than modifying 
        AFS-3 RPCs to explicitly include application-layer identity assertions as IN parameters.
      </t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>

    <section anchor="GCO_registrar" title="GCO Registrar Considerations">
      <t>
        This memo includes several assigned numbers requests which must
        be considered by the Grand Central Registrar.
      </t>

      <section title="RxClear security index">
        <t>
          A new Rx security index must be allocated.  It is anticipated that given
          the small size of the security index namepsace, the allocation will
          only be satisfied after rough consensus is established on the 
          afs3-standardization@openafs.org mailing list.
        </t>
      </section>

      <section title="Rx error codes">
        <t>
          The Rx Clear security class allocates several new Rx error codes for use
          in Rx abort packet payloads.  Given that there are multiple Rx implementations,
          it is assumed that the GCO Registrar will be responsible for allocating new
          error table values.
        </t>
      </section>

      <section title="Rx Clear Security Header Version">
        <t>
          The Rx Clear security class includes a version number in its packet header.  This
          memo requests that the GCO Registrar control allocation of all version numbers for
          this protocol field.  Specifically, this memo requests allocation of version 1
          within this new namespace.
        </t>
      </section>

      <section title="Endpoint Identifier Type">
        <t>
          The Rx Clear security class provides a means of sending opaque application data,
          which is intended to provide a means of transmitting application-specific 
          transport-independent endpoint identifiers.  This memo requests that the GCO 
          Registrar control allocation of endpoint identifier type codes.
        </t>
      </section>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
         This protocol explicitly provides no means of encrypting nor integrity
         checking the contents of Rx headers or payloads.  It SHOULD NOT be used, except 
         in physically secured and isolated high-performance computing environments where
         cryptographic overhead is deemed to be unacceptable.
      </t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      <?rfc linefile="1:http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?>

<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='17491' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>
<?rfc linefile="582:/tmp/CGI28235.1"?>
    </references>

    <references title="Informative References">

      <reference anchor="rx_spec">
        <front>
          <title>Rx protocol specification draft</title>

          <author initials="N.Z." surname="Zeldovich">
            <organization>MIT</organization>
          </author>

          <date year="2002" />
        </front>
      </reference>

<!--
      <?rfc linefile="1:http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml"?>

<reference anchor='RFC2629'>

<front>
<title>Writing I-Ds and RFCs using XML</title>
<author initials='M.T.' surname='Rose' fullname='Marshall T. Rose'>
<organization>Invisible Worlds, Inc.</organization>
<address>
<postal>
<street>660 York Street</street>
<city>San Francisco</city>
<region>CA</region>
<code>94110</code>
<country>US</country></postal>
<phone>+1 415 695 3975</phone>
<email>mrose@not.invisible.net</email>
<uri>http://invisible.net/</uri></address></author>
<date year='1999' month='June' />
<area>General</area>
<keyword>RFC</keyword>
<keyword>Request for Comments</keyword>
<keyword>I-D</keyword>
<keyword>Internet-Draft</keyword>
<keyword>XML</keyword>
<keyword>Extensible Markup Language</keyword>
<abstract>
<t>This memo presents a technique for using XML
(Extensible Markup Language)
as a source format for documents in the Internet-Drafts (I-Ds) and
Request for Comments (RFC) series.</t></abstract></front>

<seriesInfo name='RFC' value='2629' />
<format type='TXT' octets='48677' target='ftp://ftp.isi.edu/in-notes/rfc2629.txt' />
<format type='HTML' octets='71741' target='http://xml.resource.org/public/rfc/html/rfc2629.html' />
<format type='XML' octets='53481' target='http://xml.resource.org/public/rfc/xml/rfc2629.xml' />
</reference>
<?rfc linefile="600:/tmp/CGI28235.1"?>

      <?rfc linefile="1:http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml"?>

<reference anchor='RFC3552'>

<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'>
<organization /></author>
<date year='2003' month='July' />
<abstract>
<t>All RFCs are required to have a Security Considerations section.  Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='72' />
<seriesInfo name='RFC' value='3552' />
<format type='TXT' octets='110393' target='ftp://ftp.isi.edu/in-notes/rfc3552.txt' />
</reference>
<?rfc linefile="602:/tmp/CGI28235.1"?>

      <?rfc linefile="1:http://xml.resource.org/public/rfc/bibxml3/reference.I-D.narten-iana-considerations-rfc2434bis.xml"?>

<reference anchor='I-D.narten-iana-considerations-rfc2434bis'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>

<author initials='T' surname='Narten' fullname='Thomas  Narten'>
    <organization />
</author>

<author initials='H' surname='Alvestrand' fullname='Harald Alvestrand'>
    <organization />
</author>

<date month='March' day='26' year='2008' />

<abstract><t>Many protocols make use of identifiers consisting of constants and other well-known values. Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec).  To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority. For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).  In order for IANA to manage a given name space prudently, it needs guidelines describing the conditions under which new values can be assigned, or when modifications to existing values can be made. If IANA is expected to play a role in the management of a name space, the IANA must be given clear and concise instructions describing that role.  This document discusses issues that should be considered in formulating a policy for assigning values to a name space and provides guidelines to document authors on the specific text that must be included in documents that place demands on IANA.  This document obsoletes RFC 2434. Contents  Status of this Memo.......................................... 1</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-narten-iana-considerations-rfc2434bis-09' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-narten-iana-considerations-rfc2434bis-09.txt' />
</reference>
<?rfc linefile="604:/tmp/CGI28235.1"?>
-->


    </references>

    <section anchor="app-additional" title="Additional Stuff">
      <t>This becomes an Appendix.</t>
    </section>

    <!-- Change Log

v00 2009-09-24  TEK   Initial version
v01 2010-01-29  TEK   make kolya draft informative

     -->
  </back>
</rfc>

