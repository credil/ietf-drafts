<?xml version="1.0" encoding="UTF-8"?><?rfc linefile="1:draft-ietf-dnsop-rfc4641bis.xml"?>
<!-- automatically generated by xml2rfc v1.34pre3 on 2009-03-02T11:02:21Z -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="no" ?>
<?rfc sortrefs="no" ?>

<!-- rfc number="4641" category="info" obsoletes="2541" -->

<rfc ipr="pre5378Trust200902" 
     obsoletes="2541"
     category="bcp" 
     docName="draft-ietf-dnsop-rfc4641bis-00"
     >



  <front>
    <title>DNSSEC Operational Practices</title>
    
    <author initials="O." surname="Kolkman" fullname="Olaf M. Kolkman">
      <organization>NLnet Labs</organization>
      <address>
	<postal>
	  <street>Kruislaan 419</street>
	  <city>Amsterdam</city>
	  <code>1098 VA</code>
	  <country>The Netherlands</country>
	</postal>
	<email>olaf@nlnetlabs.nl</email>
	<uri>http://www.nlnetlabs.nl</uri>
      </address>
    </author>
    
    
    <author initials="R." surname="Gieben" fullname="Miek Gieben">
      <organization>&#160;</organization>
      <address>
	<email>miek@miek.nl</email>
      </address>
    </author>
    
    <date day="2" month="March" year="2009" />
    <area>Operations and Management</area>
    <workgroup>DNSOP</workgroup>
    <keyword>DNSSEC</keyword>
    <keyword>operational</keyword>
    <abstract>
      <t> 
	This document describes a set of practices for operating the
	DNS with security extensions (DNSSEC).  The target audience is
	zone administrators deploying DNSSEC.
      </t>
      <t> 
	The document discusses operational aspects of using keys and
	signatures in the DNS. It discusses issues of key generation,
	key storage, signature generation, key rollover, and related
	policies.
      </t>      
      <t>
        This document obsoletes RFC 2541,
        as it covers more operational ground and gives more up-to-date requirements 
        with respect to key sizes and the new DNSSEC specification.
      </t>
    </abstract>
  </front>
  
  <!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  -->  
  <middle>
    
    <section title="Introduction">
      <t>
        This document describes how to run a DNS Security
(DNSSEC)-enabled environment. It is intended for operators who have
        knowledge of the DNS (see <xref target="RFC1034">RFC 1034</xref> 
        and <xref target="RFC1035">RFC 1035</xref>)
        and want to deploy DNSSEC. See <xref target="RFC4033">RFC 4033</xref> 
        for an introduction to DNSSEC, <xref target="RFC4034">RFC 4034</xref> for the newly introduced
        Resource Records (RRs), and 
        <xref target="RFC4035">RFC 4035</xref> for the protocol changes.
      </t>
    
      <t>
	During workshops and early operational deployment tests,
	operators and system administrators have gained experience about
	operating the DNS with security extensions (DNSSEC).  This
	document translates these experiences into a set of practices
	for zone administrators. At the time of writing, there exists
	very little experience with DNSSEC in production environments;
        this document should therefore explicitly not be seen as
        representing 'Best Current Practices'.
      </t>
      
      <t> 
	The procedures herein are focused on the maintenance of signed
	zones (i.e., signing and publishing zones on authoritative
	servers). It is intended that maintenance of zones such as
	re-signing or key rollovers be transparent to any verifying
	clients on the Internet.
      </t>
      
      
      <t> 
	The structure of this document is as follows. In <xref
	target="trustchain"/>, we discuss the importance of keeping the
	"chain of trust" intact.  Aspects of key generation and
	storage of private keys are discussed in <xref
	target="keys"/>; the focus in this section is mainly on the
	private part of the key(s).  <xref
	target="sigs_keyrolls_policies"/> describes considerations
	concerning the public part of the keys. Since these public keys
	appear in the DNS one has to take into account all kinds of
	timing issues, which are discussed in <xref target="time"
	/>. <xref target="keyroll"/> and <xref target="emergency"/>
	deal with the rollover, or supercession, of keys. Finally,
	<xref target="parents"/> discusses considerations on how
	parents deal with their children's public keys in order to
	maintain chains of trust.

	
      </t>
      <t>
	The typographic conventions used in
	this document are explained in <xref target="typography" />.
      </t>

      <t> 
	Since this is a document with operational suggestions and
	there are no protocol specifications, the <xref
	target="RFC2119">RFC 2119</xref> language does not apply.
      </t>

      <t>This document obsoletes <xref target="RFC2541">RFC 2541</xref> 
   to reflect the evolution of the underlying DNSSEC protocol since
   then. Changes in the choice of cryptographic algorithms, DNS
   record types and type names, and the parent-child key and signature
   exchange demanded a major rewrite and additional information and
   explanation. 
      </t>


      <section title="The Use of the Term 'key'">
	
	<t> 
	  It is assumed that the reader is familiar with the concept
	  of asymmetric keys on which DNSSEC is based (public key
	  cryptography <xref target="applied-crypto"/>). Therefore,
	  this document will use the term 'key' rather loosely. Where
	  it is written that 'a key is used to sign data' it is
	  assumed that the reader understands that it is the private
	  part of the key pair that is used for signing. It is also
	  assumed that the reader understands that the public part of
	  the key pair is published in the DNSKEY Resource Record and
	  that it is the public part that is used in key exchanges.
	</t>

      </section> <!-- The usage of the term key -->


      <section title="Time Definitions">

	<t> 
	  In this document, we will be using a number of time-related
	  terms. The following definitions apply:
	</t>
	<t>	
	  <list style="symbols">
	    <t>
	      "Signature validity period" The period that a signature
	      is valid.  It starts at the time specified in the
	      signature inception field of the RRSIG RR and ends at
	      the time specified in the expiration field of the RRSIG
	      RR.
	    </t>
	    
	    
	    <t>
	      "Signature publication period" Time after which a
	      signature (made with a specific key) is replaced with a
	      new signature (made with the same key). This replacement
	      takes place by publishing the relevant RRSIG in the
	      master zone file.  After one stops publishing an RRSIG
	      in a zone, it may take a while before the RRSIG has
	      expired from caches and has actually been removed from
	      the DNS.
	    </t> 
	    
	    <t>
	      "Key effectivity period" The period during which a key
	      pair is expected to be effective. This period is defined
	      as the time between the first inception time stamp and
	      the last expiration date of any signature made with this
	      key, regardless of any discontinuity in the use of the
	      key.  The key effectivity period can span multiple
	      signature validity periods.
	    </t>
	    
	    <t>
	      "Maximum/Minimum Zone Time to Live (TTL)" The maximum or
	      minimum value of the TTLs from the complete set of RRs
	      in a zone. Note that the minimum TTL is not the same as
	      the MINIMUM field in the SOA RR. See <xref
	      target="RFC2308" /> for more information.
	    </t>
	    
	    
	  </list>
	</t>
      </section> <!--Time definitions -->


    </section> <!-- Introduction -->
    <section anchor="trustchain" title="Keeping the Chain of Trust Intact">
      
      <!-- NEW TEXT START  DOP #3 -->
      <!--
	<t>
	 DNS has inherent delays in the propagation of data, e.g., from the
	 master to slave, caches timing out old copies before retrieving
	 fresh authoritative data.
	</t>

	<t> For the verifying clients it is important that data from
	secured zones can be used to build chains of trust regardless of
	whether the data came directly from an authoritative server, a
	caching nameserver or some middle box.
	</t>

	<t> Because of this administrators need to prepare for changes in
	advance and sequence actions appropriately to achieve smooth
	transitions.  Preparations include adjusting the TTL of records and
	RRSIG expirations.  Sequencing has to account for the worst case
	scenarios of data laying in compliant caches.
	</t>
	-->
      <!-- NEW TEXT END  DOP #3 -->

      
      <t>
	Maintaining a valid chain of trust is important because
	broken chains of trust will result in data being marked as
	  Bogus (as defined in <xref
	  target="RFC4033"/> Section 5), which
	  may cause entire (sub)domains to become invisible to
	  verifying clients. The administrators of secured zones have
	  to realize that their zone is, to verifying clients, part of a
	  chain of trust.
	</t>
	<t> 
	  As mentioned in the introduction, the procedures herein are
	  intended to ensure that maintenance of zones, such as re-signing or
	  key rollovers, will be transparent to the verifying clients on the
	  Internet.
	</t>
	<t>
	Administrators of secured zones will have to keep in mind that data
	published on an authoritative primary server will not be
	immediately seen by verifying clients; it may take some time for
	the data to be transferred to other secondary authoritative
	nameservers and clients may be fetching data from caching
	non-authoritative servers. In this light, note that
	the time for a zone transfer from master to slave is negligible when 
        using NOTIFY <xref target="RFC1996"/> and incremental transfer
        (IXFR) <xref target="RFC1995"/>.  It increases when full zone
        transfers (AXFR) are used in combination
        with NOTIFY.  It increases even more if you rely on full zone
        transfers based on only the SOA timing parameters for refresh.
	</t>
	<t>
	  For the verifying clients, it is important that data from
	  secured zones can be used to build chains of trust
	  regardless of whether the data came directly from an
	  authoritative server, a caching nameserver, or some middle
	  box. Only by carefully using the available timing parameters
	  can a zone administrator ensure that the data necessary for
	  verification can be obtained.
	</t>
	
	<t> 
	  The responsibility for maintaining the chain of trust is
	  shared by administrators of secured zones in the chain of
	  trust.  This is most obvious in the case of a 'key
	  compromise' when a trade-off between maintaining a valid
	  chain of trust and replacing the compromised keys as soon as
	  possible must be made.  Then zone administrators will have
	  to make a trade-off, between keeping the chain of trust
	  intact -- thereby allowing for attacks with the compromised
	  key -- or deliberately breaking the chain of trust and making
	  secured subdomains invisible to security-aware
	  resolvers. Also see <xref target="emergency"/>.
	  
	</t>
	
	
      </section><!-- Keeping the chain of trust intact -->

    
    
    
    
    <!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
    
    
    <!-- -->
    
    <section anchor="keys" title="Keys Generation and Storage"> <!-- Keys -->
      
      <t>This section describes a number of considerations with
      respect to the security of keys. It deals with the
      generation, effectivity period, size, and storage of private keys.
      </t>
      
      
      
      <section title="Zone and Key Signing Keys">
	<t>
	  
	  The DNSSEC validation protocol does not distinguish between
	  different types of DNSKEYs. All DNSKEYs can be used during the validation. In
	  practice, operators use Key Signing and Zone Signing Keys and
	  use the so-called Secure Entry Point (SEP) <xref target="RFC4035" />
          flag to distinguish between them during operations. 
	  The dynamics and considerations are discussed below.
	</t>
	<t>
	  
	  To make zone re-signing and key rollover procedures easier
	  to implement, it is possible to use one or more keys as Key
	  Signing Keys (KSKs). These keys will only sign the apex DNSKEY
	  RRSet in a zone. Other keys can be used to sign all the RRSets
	  in a zone and are referred to as Zone Signing Keys (ZSKs). In
	  this document, we assume that KSKs are the subset of
	  keys that are used for key exchanges with the parent and
	  potentially for configuration as trusted anchors -- the 
	  SEP keys. In this document, we assume a one-to-one mapping between 
          KSK and SEP keys and we assume the SEP flag to be set on all KSKs.
	</t>
	
	<section anchor="zsk-ksk-motivation" title="Motivations for the KSK and ZSK Separation">
	  
	  <t>
	    Differentiating between the KSK and ZSK functions has
	    several advantages:
	  </t>
	  
	  <t>
	    <list style="symbols">
	      <t>No parent/child interaction is required when ZSKs are
	      updated.</t>
	      <t>The KSK can be made stronger (i.e., using more bits in
	      the key material). This has little operational impact
	      since it is only used to sign a small fraction of the
	      zone data. Also, the KSK is only used to verify the zone's 
              key set, not for other RRSets in the zone.
	      </t>
	      
	      <t>As the KSK is only used to sign a key set, which is most
	      probably updated less frequently than other data in the zone,
	      it can be stored separately from and in a safer location
	      than the ZSK.</t>
	      
	      <t>A KSK can have a longer key effectivity period.</t>
	    </list>
	  </t>
	  
	  <t>
	   For almost any method of key management and zone signing, the KSK is
	   used less frequently than the ZSK. Once a key set is signed with the
	   KSK, all the keys in the key set can be used as ZSKs.  If a
	    ZSK is compromised, it can be simply dropped from the
	    key set. The new key set is then re-signed with the KSK.
	  </t>
	  
	  <t>
	    Given the assumption that for KSKs the SEP flag is set, the
	    KSK can be distinguished from a ZSK by examining the flag
	    field in the DNSKEY RR. If the flag field is an odd number it
	    is a KSK. If it is an even number it is a ZSK.
	  </t>
	  
	  <t> 
	    The Zone Signing Key can be used to sign all the data in
	    a zone on a regular basis. When a Zone Signing Key is to be
	    rolled, no interaction with the parent is needed.  This
	    allows for signature validity periods on the order
	    of days.
	  </t>
	  
	  <t> 
	    The Key Signing Key is only to be used to sign the
	    DNSKEY RRs in a zone. If a Key Signing Key is to be rolled
	    over, there will be interactions with parties other than the
	    zone administrator.  These can include the registry of the
	    parent zone or administrators of verifying resolvers that
	    have the particular key configured as secure entry
	    points. Hence, the key effectivity period of these keys can and
	    should be made much longer. Although, given a long enough
	    key, the key effectivity period can be on the order of years, we
	    suggest planning for a key effectivity on the order of a few
	    months so that a key rollover remains an operational
	    routine.
	  </t>
	  
	  
	</section> <!-- Motivations for the function -->
	<section anchor="high_level" title="KSKs for High-Level Zones">
	  <t>
	    Higher-level zones are generally more sensitive than
            lower-level zones.  Anyone controlling or breaking the security 
	    of a zone thereby obtains authority over all of its
	    subdomains (except in the case of resolvers that have
	    locally configured the public key of a subdomain, in which
            case this, and only this, subdomain wouldn't be affected by 
            the compromise of the parent zone).
	    Therefore, extra care should be taken with high-level
	    zones, and strong keys should be used.
	  </t>
	  <t>
	    The root zone is the most critical of all zones.  Someone
	    controlling or compromising the security of the root zone
	    would control the entire DNS namespace of all resolvers
	    using that root zone (except in the case of resolvers that
	    have locally configured the public key of a
	    subdomain). Therefore, the utmost care must be taken in the
	    securing of the root zone. The strongest and most carefully
	    handled keys should be used.  The root zone private key
	    should always be kept off-line.
	  </t>
	  
	  <t>   
	    Many resolvers will start at a root server for their
	    access to and authentication of DNS data.  Securely
	    updating the trust anchors in an enormous population of
	    resolvers around the world will be extremely difficult.
	  </t>
	</section>

      </section> <!-- Using Key Signing and Zone Signing Keys --> 



      <section title="Key Generation">
	<t> 
	  Careful generation of all keys is a sometimes overlooked but
	  absolutely essential element in any cryptographically secure
	  system.  The strongest algorithms used with the longest keys
	  are still of no use if an adversary can guess enough to
	  lower the size of the likely key space so that it can be
	  exhaustively searched.  Technical suggestions for the
	  generation of random keys will be found in <xref
	  target="RFC4086">RFC 4086</xref>. One should carefully assess if
	  the random number generator used during key generation adheres to
	  these suggestions.
	</t>
	<t>
	  Keys with a long effectivity period are particularly sensitive as
	  they will represent a more valuable target and be subject to attack
	  for a longer time than short-period keys.  It is strongly
	  recommended that long-term key generation occur off-line in a
	  manner isolated from the network via an air gap or, at a minimum,
	  high-level secure hardware.
	</t>

      </section> <!-- Key Generation -->


      <section anchor="key_lifetime" title="Key Effectivity Period">

	<t>For various reasons, keys in DNSSEC need to be changed once
	in a while.  The longer a key is in use, the greater the
	probability that it will have been compromised through
	carelessness, accident, espionage, or
	cryptanalysis. Furthermore, when key rollovers are too rare an
	event, they will not become part of the operational habit and
	there is risk that nobody on-site will remember the procedure
	for rollover when the need is there.
	</t>

	<t>
	 From a purely operational perspective, a reasonable key effectivity
	  period for Key Signing Keys is 13 months, with the intent to
	  replace them after 12 months.
	  An intended key effectivity period of a month is reasonable for
	  Zone Signing Keys.
	</t>
	<t>
	For key sizes that match these effectivity periods, see
	<xref target="key sizes"/>.
	</t>

        <!-- We have said this already >
	<t>
	  Using these recommendations
	  will lead to rollovers occurring frequently enough to become
	  part of 'operational habits'; the procedure does not have
	  to be reinvented every time a key is replaced.
	</t>
        -->

	<t>
	As argued in <xref target="high_level"/>, securely updating 
	trust anchors will be extremely difficult. 
	On the other hand, the "operational habit" argument does
	also apply to trust anchor reconfiguration. If a short key effectivity
	period is used and the trust anchor configuration has to be revisited
	on a regular basis, the odds that the configuration tends to be
	forgotten is smaller. The trade-off is against a system that is so dynamic
	that administrators of the validating clients will not be able to
	follow the modifications.
	</t>

	<t>
	  Key effectivity periods can be made very short, as in
	  a few minutes. But when replacing keys one has to
	  take the considerations from <xref target="time"/> and
	  <xref target="keyroll"/> into account. 
	</t>

      </section> <!-- key effectivity period -->


      <section anchor="key algorithm" title="Key Algorithm">
	<t>
	  There are currently three different types of algorithms that
	  can be used in DNSSEC: RSA, DSA, and elliptic curve cryptography.
	  The latter is fairly new and has yet to be standardized for
	  usage in DNSSEC.
	</t>
	<t>
	  RSA has been developed in an open and transparent
	  manner. As the patent on RSA expired in 2000, its use is now
	  also free. 
	</t>
	
	<t>DSA has been developed by the National Institute of
Standards and Technology (NIST). The creation of signatures 
	takes roughly the same time as with RSA, but is 10 to 40 times
	as slow for verification <xref target="applied-crypto"/>.
	</t>

	<t>
         We suggest the use of RSA/SHA-1 as the preferred algorithm for
         the key.  The current known attacks on RSA can be defeated by
         making your key longer. 
          As the MD5 hashing algorithm is showing cracks,
          we recommend the usage of SHA-1.
        </t>
        <t> 
        At the time of publication, it is known that the SHA-1 hash
        has cryptanalysis issues. There is work in progress on
        addressing these issues. We recommend the use of public key
        algorithms based on hashes stronger than SHA-1 (e.g., SHA-256), as
        soon as these algorithms are available in protocol
        specifications (see <xref target="I-D.ietf-dnsext-dnssec-rsasha256"/>
        and <xref target="RFC4509"/>) and implementations.
        </t>
      </section> <!-- Key algorithm -->

      <section anchor="key sizes" title="Key Sizes">
	<t>
	  When choosing key sizes, zone administrators will need to
	  take into account how long a key will be used, how much
	  data will be signed during the key publication period 
          (see Section 8.10 of <xref target="applied-crypto"/>), and,
	  optionally, how large the key size of the parent is. As the
	  chain of trust really is "a chain", there is not much sense
	  in making one of the keys in the chain several times larger than
	  the others. As always, it's the weakest link that defines the
	  strength of the entire chain. 
            Also see <xref
            target="zsk-ksk-motivation"/> for a discussion of how keys
            serving different roles (ZSK vs. KSK) may need different key
            sizes.  
	</t>

        <t>
        Generating a key of the correct size is a difficult problem; <xref
        target="RFC3766">RFC 3766</xref> tries to deal with that problem.
        The first part of the selection procedure in Section 1 of the
        RFC states:

        <figure>
        <artwork>
   1. Determine the attack resistance necessary to satisfy the 
      security requirements of the application.  Do this by 
      estimating the minimum number of computer operations that 
      the attacker will be forced to do in order to compromise 
      the security of the system and then take the logarithm base 
      two of that number.  Call that logarithm value "n".

      A 1996 report recommended 90 bits as a good all-around choice 
      for system security.  The 90 bit number should be increased 
      by about 2/3 bit/year, or about 96 bits in 2005.
        </artwork>
        </figure>
</t>
        <t>
         <xref target="RFC3766"/> goes on to explain how this number "n" 
        can be used to calculate the key sizes in public key cryptography.
        This culminated in the table given below (slightly modified for
	our purpose):
	</t>
	<t>

	  <figure>
<artwork>
   +-------------+-----------+--------------+
   | System      |           |              |
   | requirement | Symmetric | RSA or DSA   |
   | for attack  | key size  | modulus size |
   | resistance  | (bits)    | (bits)       |
   | (bits)      |           |              |
   +-------------+-----------+--------------+
   |     70      |     70    |      947     |
   |     80      |     80    |     1228     |
   |     90      |     90    |     1553     |
   |    100      |    100    |     1926     |
   |    150      |    150    |     4575     |
   |    200      |    200    |     8719     |
   |    250      |    250    |    14596     |
   +-------------+-----------+--------------+
</artwork>
</figure>
</t>
        <t>
        The key sizes given are rather large. This is because these
        keys are resilient against a trillionaire attacker. Assuming
        this rich attacker will not attack your key and that the key
        is rolled over once a year, we come to the following
        recommendations about KSK sizes: 1024 bits for low-value
        domains, 1300 bits for medium-value domains, and 2048 bits for
        high-value domains.
        </t>
        
        <t>
        Whether a domain is of low, medium, or high
        value depends solely on the views of the zone owner. One
could, for instance, view
        leaf nodes in the DNS as of low value, and top-level domains (TLDs) or the root
        zone of high value. The suggested key sizes should be safe for the
        next 5 years.  </t>

<!--
	  <t>
	  It is hard to give precise recommendations but Lenstra and Verheul
	  <xref target="selecting-crypto-key-sizes" /> supplied the
	  following table with lower bound estimates for cryptographic
	  key sizes. Their recommendations are based on a set of
	  explicitly formulated parameter settings, combined with
	  existing data points about cryptographic systems. For details we refer to
	  the original paper. Recent mathematical work indicates this table
          already is overly optimistic. Also see RFC3766 <xref
          target="RFC3766"/>.
	</t>
-->    
        <t>
          As ZSKs can be rolled over more easily (and thus more often),
          the key sizes can be made smaller. But as said in the
          introduction of this paragraph, making the ZSKs' key sizes too
          small (in relation to the KSKs' sizes) doesn't make much sense. 
          Try to limit the difference in size to about 100 bits.</t>

        <t>
        Note that nobody can see into the future and that these key
        sizes are only provided here as a guide. Further information
        can be found in
	<xref target="selecting-crypto-key-sizes" /> and
        Section 7.5 of <xref target="applied-crypto"/>. It should be noted
        though that  <xref target="selecting-crypto-key-sizes" /> is already 
        considered overly optimistic about what key sizes are considered safe.
        </t>

        <t>
        One final note concerning key sizes. Larger keys will increase
        the sizes of the RRSIG and DNSKEY records and will therefore
        increase the chance of DNS UDP packet overflow. Also, the time
        it takes to validate and create RRSIGs increases with larger
        keys, so don't needlessly double your key sizes.
        </t>

<!--
	  <t>
	    When determining a key size one should take into account
	    that a large key will be slower during generation and
            verification.  The time to verify an RSA signature (the most
            common operation) will vary with the square of the key size;
            signing will vary with the cube of the key size; and key
            generation will vary with the fourth power of the key size.
            Besides larger keys will also increase the sizes of the RRSIG
            and DNSKEY records and will therefore increase the chance of
            DNS UDP packet overflow. 
            </t>
-->

<!--
	<t>
	  <figure>
	    <artwork>
    Year    RSA Key Sizes       Year    RSA Key Sizes	

    2000        952             2015        1613        
    2001        990             2016        1664        
    2002        1028            2017        1717        
    2003        1068            2018        1771        
    2004        1108            2019        1825        


    2005        1149            2020        1881        
    2006        1191            2021        1937        
    2007        1235            2022        1995        
    2008        1279            2023        2054        
    2009        1323            2024        2113        

    2010        1369            2025        2174        
    2011        1416            2026        2236           
    2012        1464            2027        2299           
    2013        1513            2028        2362        
    2014        1562		2029        2427          
	      </artwork>
	    </figure>
	  </t>

	  <t>
	    For example, should you wish your (RSA) ZSK to last three years
	    from 2003, check the RSA key size values for 2006 in this
	    table. In this case it should be at least 1191 bits.
	  </t>
-->

	</section> <!-- Key sizes -->
	
	<section title="Private Key Storage">
	  <t>
	    It is recommended that, where possible, zone private keys
	    and the zone file master copy that is to be signed 
            be kept and used in
	    off-line, non-network-connected, physically secure
	    machines only.  Periodically, an application can be run to
	    add authentication to a zone by adding RRSIG and NSEC RRs.
	    Then the augmented file can be transferred.
	  </t>

	  <t> 
	  When relying on dynamic update to manage a signed zone
	  <xref target="RFC3007"/>, be
	  aware that at least one private key of the zone will have to reside on
	  the master server.  This key is only as secure as the amount of
	  exposure the server receives to unknown clients and the security
	  of the host.  Although not mandatory, one could administer the DNS
	  in the following way. The master that processes the dynamic
	  updates is unavailable from generic hosts on the Internet, it is
	  not listed in the NS RRSet, although its name appears in the SOA
	  RRs MNAME field.  The nameservers in the NS RRSet are able to
	  receive zone updates through NOTIFY, IXFR, AXFR, or an out-of-band
	  distribution mechanism. This approach is known as the "hidden
	  master" setup.
	  </t>
	  
	  <t>
	    The ideal situation is to have a one-way information flow
	    to the network to avoid the possibility of tampering from
	    the network.  Keeping the zone master file on-line on the
	    network and simply cycling it through an off-line signer
	    does not do this.  The on-line version could still be
	    tampered with if the host it resides on is compromised.
	    For maximum security, the master copy of the zone file
	    should be off-net and should not be updated based on an
	    unsecured network mediated communication.
	  </t>

	  <t>
	    In general, keeping a zone file off-line will not be
	    practical and the machines on which zone files are
	    maintained will be connected to a network. Operators are
	    advised to take security measures to shield unauthorized
	    access to the master copy.
	  </t>
	  <t>
	    For dynamically updated secured zones <xref
	    target="RFC3007"/>, both the master copy and
	    the private key that is used to update signatures on
	    updated RRs will need to be on-line.
	  </t>

	</section>

      </section> <!-- Key sec considerations -->


    

<section anchor="sigs_keyrolls_policies" title="Signature Generation, Key Rollover, and Related Policies">    





    <section anchor="time" title="Time in DNSSEC">
      <t>
	Without DNSSEC, all times in the DNS are relative. The SOA
	fields REFRESH, RETRY, and EXPIRATION are timers used to
	determine the time elapsed after a slave server synchronized
	with a master server. The Time to Live (TTL) value and the SOA
	RR minimum TTL parameter <xref target="RFC2308" /> are used to
	determine how long a forwarder should cache data after it has
	been fetched from an authoritative server. By using a
	signature validity period, DNSSEC introduces the notion of an
	absolute time in the DNS. Signatures in DNSSEC have an
	expiration date after which the signature is marked as invalid
	and the signed data is to be considered Bogus.
      </t>
      
      

      
      <section anchor="time_considerations" title="Time Considerations">
	
	<t>
	  Because of the expiration of signatures, one should consider the
	  following:
	</t>
	<t>
	  <list style="symbols">
	    
	    <t>
	      We suggest the Maximum Zone TTL of your zone data to be a
	      fraction of your signature validity period.
	    </t>
	    

	      <list style="hanging">
		
		<t>
		  If the TTL would be of similar order as the
		  signature validity period, then all RRSets fetched
		  during the validity period would be cached until the
		  signature expiration time.  Section 7.1 of <xref
		  target="RFC4033"/> suggests that "the resolver may
		  use the time remaining before expiration of the
		  signature validity period of a signed RRSet as an
		  upper bound for the TTL". As a result, query load on
		  authoritative servers would peak at signature
		  expiration time, as this is also the time at which
		  records simultaneously expire from caches.
		</t>
		<t>
		  To avoid query load peaks, we suggest the TTL on all
		  the RRs in your zone to be at least a few times
		  smaller than your signature validity period.
		</t>
	      </list>

	    <t>
	      We suggest the signature publication period to end at
	      least one Maximum Zone TTL duration before the end of
	      the signature validity period.
	    </t>
	    
	      <list style="hanging">
		
		<t>
		  Re-signing a zone shortly before the end of the
		  signature validity period may cause simultaneous
		  expiration of data from caches. This in turn may
		  lead to peaks in the load on authoritative servers.
		</t>
		
	      </list>	  

	    <t>
	      We suggest the Minimum Zone TTL to be long enough to
	      both fetch and verify all the RRs in the trust chain. In
	      workshop environments, it has been demonstrated <xref
	      target="NIST-workshop" /> that a low TTL (under 5 to 10
	      minutes) caused disruptions because of the following two
	      problems:
	    </t>
	      <list style="hanging">
		
		<t> 
		  1. During validation, some data may expire before
		  the validation is complete. The validator should be
		  able to keep all data until it is completed. This
		  applies to all RRs needed to complete the chain of
		  trust: DSes, DNSKEYs, RRSIGs, and the final answers,
		  i.e., the RRSet that is returned for the initial
		  query.
		</t>
		<t>
		  2. Frequent verification causes load on recursive
		  nameservers. Data at delegation points, DSes, DNSKEYs, and
		  RRSIGs benefit from caching. The TTL on those should be
		  relatively long.
		  
		</t>
	      </list>
	    <t>
	      Slave servers will need to be able to fetch newly signed
	      zones well before the RRSIGs in the zone served by the
	      slave server pass their signature expiration time.
	      
	    </t>
	    
	      <list style="hanging">
		
		
		<t> 
		  When a slave server is out of sync with its master
		  and data in a zone is signed by expired signatures,
		  it may be better for the slave server not to give
		  out any answer.
		</t>
		
		<t> 
		  Normally, a slave server that is not able to contact
		  a master server for an extended period will expire a
		  zone. When that happens, the server will respond
		  differently to queries for that zone. Some servers
		  issue SERVFAIL, whereas others turn off the 'AA' bit
		  in the answers.
		  
		  The time of expiration is set in the SOA
		  record and is relative to the last successful refresh
		  between the master and the slave servers. There exists no
		  coupling between the signature expiration of RRSIGs in
		  the zone and the expire parameter in the SOA.
		</t>
		
		<t>
		  If the server serves a DNSSEC zone, then it may well
		  happen that the signatures expire well before the SOA
		  expiration timer counts down to zero. It is not possible
		  to completely prevent this from happening by tweaking
		  the SOA parameters.
		</t>
		<t>
		  However, the effects can be minimized where the SOA
		  expiration time is equal to or shorter than the
		  signature validity period.
		</t>
		
		
		
		<t> 
		  The consequence of an authoritative server not being
		  able to update a zone, whilst that zone includes expired
		  signatures, is that non-secure resolvers will continue to
		  be able to resolve data served by the particular slave
		  servers while security-aware resolvers will experience
		  problems because of answers being marked as Bogus.
		</t>
		
		
		<t>
		  We suggest the SOA expiration timer being approximately
		  one third or one fourth of the signature validity period.
		  It will allow problems with transfers from the master server 
		  to be noticed before the actual signature times out.
		</t>
		
		
		<t> 
		  We also suggest that operators of nameservers that
		  supply secondary services develop 'watch dogs' to spot
		  upcoming signature expirations in zones they slave, and
		  take appropriate action.
		</t>
		
		<t> 
		  When determining the value for the expiration parameter
		  one has to take the following into account: What are the
		  chances that all my secondaries expire the zone? How quickly
		  can I reach an administrator of secondary servers to
		  load a valid zone? These questions are not DNSSEC
		  specific but may influence the choice of your signature
		  validity intervals.
		</t>
	      </list>
	    
	  </list>
	</t>
      </section> <!-- time considerations -->
    </section> <!-- time in DNS -->
    



    <section anchor="keyroll" title="Key Rollovers">
      

      <t>
	A DNSSEC key cannot be used forever (see <xref
	target="key_lifetime"/>).  So key rollovers -- or
	supercessions, as they are sometimes called -- are a fact of
	life when using DNSSEC.  Zone administrators who are in the
	process of rolling their keys have to take into account that
	data published in previous versions of their zone still lives
	in caches. When deploying DNSSEC, this becomes an important
	consideration; ignoring data that may be in caches may lead to
	loss of service for clients.
      </t>
      
      <t>The most pressing example of this occurs when zone material
      signed with an old key is being validated by a resolver that
      does not have the old zone key cached. If the old key is no
      longer present in the current zone, this validation fails,
      marking the data "Bogus".  Alternatively, an attempt could be
      made to validate data that is signed with a new key against
      an old key that lives in a local cache, also resulting in data
      being marked "Bogus".  </t>
      



      <section title="Zone Signing Key Rollovers">
	
	<t> For "Zone Signing Key rollovers", there are two ways to
	make sure that during the rollover data still cached
	can be verified with the new key sets or newly generated
	signatures can be verified with the keys still in
	caches. One schema, described in <xref target="dub-sig-zsk"/>, 
	uses double signatures; the other uses key
	pre-publication (<xref target="pre-pub-zsk" />). The pros,
	cons, and recommendations are described in <xref
	target="zsk-pro-con" />.

	</t>



	<section anchor="pre-pub-zsk" title="Pre-Publish Key Rollover">


	  <t>This section shows how to perform a ZSK rollover without
	  the need to sign all the data in a zone twice -- the
	  "pre-publish key rollover". This method has advantages in
	  the case of a key compromise. If the old key is compromised,
	  the new key has already been distributed in the DNS. The
	  zone administrator is then able to quickly switch to the new
	  key and remove the compromised key from the zone.  Another
	  major advantage is that the zone size does not double, as is
	  the case with the double signature ZSK rollover.  A small
	  "how-to" for this kind of rollover can be found in <xref
	  target="zskhowto" />.
	  </t>
	  <t>	
	    <figure>
	      <preample>
		<t>Pre-publish key rollover involves four stages as follows:</t>
	      </preample>
	    <artwork>
----------------------------------------------------------------
 initial         new DNSKEY       new RRSIGs      DNSKEY removal
----------------------------------------------------------------
 SOA0            SOA1             SOA2            SOA3
 RRSIG10(SOA0)   RRSIG10(SOA1)    RRSIG11(SOA2)   RRSIG11(SOA3)

 DNSKEY1         DNSKEY1          DNSKEY1         DNSKEY1
 DNSKEY10        DNSKEY10         DNSKEY10        DNSKEY11
                 DNSKEY11         DNSKEY11
 RRSIG1 (DNSKEY) RRSIG1 (DNSKEY)  RRSIG1(DNSKEY)  RRSIG1 (DNSKEY)
 RRSIG10(DNSKEY) RRSIG10(DNSKEY)  RRSIG11(DNSKEY) RRSIG11(DNSKEY)
----------------------------------------------------------------
	    </artwork>
            <postample>
	      <t>Pre-Publish Key Rollover</t>
            </postample>
	  </figure>
	  </t>
	  <t>
	    <list style="hanging">
	      <t hangText="initial:"> Initial version of the zone: DNSKEY 1
	      is the Key Signing Key. DNSKEY 10 is used to sign all
	      the data of the zone, the Zone Signing Key.
	      </t>
	      <t hangText="new DNSKEY:"> DNSKEY 11 is introduced into
	      the key set. Note that no signatures are generated with
	      this key yet, but this does not secure against brute
	      force attacks on the public key.  The minimum duration
	      of this pre-roll phase is the time it takes for the
	      data to propagate to the authoritative servers plus
	      TTL value of the key set. 
	      <!--This equates to two times the Maximum Zone TTL. -->
	      </t>
	      
	      <t hangText="new RRSIGs:"> At the "new RRSIGs" stage (SOA serial
	      2), DNSKEY 11 is used to sign the data in the zone
	      exclusively  (i.e., all the signatures from DNSKEY 10 are
	      removed from the zone). DNSKEY 10 remains published in
	      the key set. This way data that was loaded into caches
	      from version 1 of the zone can still be verified with
	      key sets fetched from version 2 of the zone.
	      The minimum time that the key set including DNSKEY 10
	      is to be published is the time that it takes for
	      zone data from the previous version of the zone to
	      expire from old caches, i.e., the time it takes for
	      this zone to propagate to all authoritative servers
	      plus the Maximum Zone TTL value of any of the data
	      in the previous version of the zone.
	      </t>

	      <t hangText="DNSKEY removal:"> DNSKEY 10 is removed from the
	      zone. The key set, now only containing DNSKEY 1 and
	      DNSKEY 11, is re-signed with the DNSKEY 1.

	      </t>
	    </list>
	  </t>
	  <t> The above scheme can be simplified by always
	  publishing the "future" key immediately after the rollover.
	  The scheme would look as follows (we show two rollovers); the
	  future key is introduced in "new DNSKEY" as DNSKEY 12 and again
	  a newer one, numbered 13, in "new DNSKEY (II)":

	  </t>
	  <t>

	    <figure>
            <preample>
             <t>
             </t>
            </preample>
	      <artwork>
    initial             new RRSIGs          new DNSKEY
   -----------------------------------------------------------------
    SOA0                SOA1                SOA2            
    RRSIG10(SOA0)       RRSIG11(SOA1)       RRSIG11(SOA2)   
  
    DNSKEY1             DNSKEY1             DNSKEY1        
    DNSKEY10            DNSKEY10            DNSKEY11       
    DNSKEY11            DNSKEY11            DNSKEY12       
    RRSIG1(DNSKEY)      RRSIG1 (DNSKEY)     RRSIG1(DNSKEY) 
    RRSIG10(DNSKEY)     RRSIG11(DNSKEY)     RRSIG11(DNSKEY) 
    ----------------------------------------------------------------

    ----------------------------------------------------------------
    new RRSIGs (II)     new DNSKEY (II)
    ----------------------------------------------------------------
    SOA3                SOA4
    RRSIG12(SOA3)       RRSIG12(SOA4)
  
    DNSKEY1             DNSKEY1
    DNSKEY11            DNSKEY12
    DNSKEY12            DNSKEY13
    RRSIG1(DNSKEY)      RRSIG1(DNSKEY) 
    RRSIG12(DNSKEY)     RRSIG12(DNSKEY)
    ----------------------------------------------------------------
	      </artwork>
              <postample>
              <t>
              Pre-Publish Key Rollover, Showing Two Rollovers
              </t>
              </postample>
</figure>
</t>
	    <t> Note that the key introduced in the "new DNSKEY" phase is not
	    used for production yet; the private key can thus be
	    stored in a physically secure manner and does not need to
	    be 'fetched' every time a zone needs to be signed.

</t>
	    
	  </section>
    
	  <section anchor="dub-sig-zsk" title="Double Signature Zone Signing Key Rollover">

	    <t>This section shows how to perform a ZSK key rollover
	    using the double zone data signature scheme, aptly named
	    "double signature rollover".
	    </t>
	    <t>During the "new DNSKEY" stage the new version of the zone
	    file will need to propagate to all authoritative servers
	    and the data that exists in (distant) caches will need to
	    expire, requiring at least the Maximum Zone TTL.
	    
	    </t>
	    <figure>
            <preample>
        <t>
        Double signature ZSK rollover involves three stages
        as follows:
        </t>
            </preample>
	      <artwork>
   ----------------------------------------------------------------
   initial             new DNSKEY         DNSKEY removal
   ----------------------------------------------------------------
   SOA0                SOA1               SOA2
   RRSIG10(SOA0)       RRSIG10(SOA1)      RRSIG11(SOA2)
                       RRSIG11(SOA1)
   DNSKEY1             DNSKEY1            DNSKEY1
   DNSKEY10            DNSKEY10           DNSKEY11
                       DNSKEY11
   RRSIG1(DNSKEY)      RRSIG1(DNSKEY)     RRSIG1(DNSKEY)
   RRSIG10(DNSKEY)     RRSIG10(DNSKEY)    RRSIG11(DNSKEY)
                       RRSIG11(DNSKEY)
   ----------------------------------------------------------------
	      </artwork>
              <postample>
                <t>
		  Double Signature Zone Signing Key Rollover
                <!--
                Stages of Deployment for Double Signature Zone Signing
                Key Rollover.
                -->
                </t>
              </postample>
	    </figure>
	    

	    <t><list style="hanging">
            <t hangText="initial:"> Initial Version
	    of the zone: DNSKEY 1 is the Key Signing Key. DNSKEY 10 is used
	    to sign all the data of the zone, the
	    Zone Signing Key.
	    </t>
	    <t hangText="new DNSKEY:"> At the "New DNSKEY" stage (SOA serial
	    1) DNSKEY 11 is introduced into the key set and all the
	    data in the zone is signed with DNSKEY 10 and DNSKEY
	    11. The rollover period will need to continue until all
	    data from version 0 of the zone has expired from
	    remote caches. This will take at least the Maximum
	    Zone TTL of version 0 of the zone.

	    </t>
	    <t hangText="DNSKEY removal:"> DNSKEY 10 is removed from the
	    zone. All the signatures from DNSKEY 10 are removed from
	    the zone. The key set, now only containing DNSKEY 11, is
	    re-signed with DNSKEY 1.  </t>
	    </list>

	    </t>
	    
	    <t> At every instance, RRSIGs from the previous version of
	    the zone can be verified with the DNSKEY RRSet from the
	    current version and the other way around. The data from
	    the current version can be verified with the data from the
	    previous version of the zone. The duration of the "new DNSKEY"
	    phase and the period between rollovers should be at least
	    the Maximum Zone TTL.

	    </t>
	    <t>Making sure that the "new DNSKEY" phase lasts until the
	    signature expiration time of the data in the initial version  of the
	    zone is recommended. This way all caches are cleared of the old
	    signatures.  However, this duration could be
	    considerably longer than the Maximum Zone TTL, making the
	    rollover a lengthy procedure.
	    </t>
	    <t>Note that in this example we assumed that the zone was
	    not modified during the rollover. New data can be
	    introduced in the zone as long as it is signed with both
	    keys.
	    </t>
	    
	    
	  </section> <!--double sig rollover-->
	  

	  <section anchor="zsk-pro-con" title="Pros and Cons of the Schemes">

	    <t>
	      <list style="hanging">
		<t hangText="Pre-publish key rollover:">
		  This rollover does not involve signing the zone data
		  twice. Instead, before the actual rollover, the
		  new key is published in the key set and thus is
		  available for cryptanalysis attacks. A small
		  disadvantage is that this process requires four
		  steps. Also the pre-publish scheme involves more
		  parental work when used for KSK rollovers as
		  explained in <xref target="diff_zsk_ksk"/>.
		</t>

		
		<t hangText="Double signature ZSK rollover:">
		  The drawback of this signing scheme is that during the
		  rollover the number of signatures in your zone doubles;
		  this may be prohibitive if you have very big zones. An
		  advantage is that it only requires three steps.

		</t>

	      </list>
	    </t>

	  </section> <!-- Pros and cons of the schemes -->
	  
	</section><!--Zone Signing key rollovers-->
	
	<section  anchor="ksk-rollover" title="Key Signing Key Rollovers">
	  
	  <t> For the rollover of a Key Signing Key, the same
	  considerations as for the rollover of a Zone Signing Key
	  apply. However, we can use a double signature scheme
	  to guarantee that old data (only the apex key set) in 
	  caches can be verified with a new key set and vice versa.
	  Since only the key set is signed with a KSK, zone size considerations
	  do not apply.
	  </t>
	  <t>
	    <figure>
            <preample>
            <t>
<!--            Key Signing Key Rollover involves four stages. Note that
            such a rollover involves interaction between the parent
            and child:
            -->
            </t>
            </preample>
	      <artwork>
--------------------------------------------------------------------
    initial        new DNSKEY        DS change       DNSKEY removal
--------------------------------------------------------------------
  Parent:
    SOA0           -------->         SOA1            -------->
    RRSIGpar(SOA0) -------->         RRSIGpar(SOA1)  -------->
    DS1            -------->         DS2             -------->
    RRSIGpar(DS)   -------->         RRSIGpar(DS)    -------->


  Child:
    SOA0            SOA1             -------->       SOA2
    RRSIG10(SOA0)   RRSIG10(SOA1)    -------->       RRSIG10(SOA2)
                                     -------->
    DNSKEY1         DNSKEY1          -------->       DNSKEY2 
                    DNSKEY2          -------->
    DNSKEY10        DNSKEY10         -------->       DNSKEY10
    RRSIG1 (DNSKEY) RRSIG1 (DNSKEY)  -------->       RRSIG2 (DNSKEY)
                    RRSIG2 (DNSKEY)  -------->
    RRSIG10(DNSKEY) RRSIG10(DNSKEY)  -------->       RRSIG10(DNSKEY)
--------------------------------------------------------------------
	      </artwork>
              <postample>
             <t>
            Stages of Deployment for a Double Signature Key Signing
Key Rollover
             </t>
              </postample>
	    </figure>
	  </t>

	  <t><list style="hanging"> <t hangText="initial:"> Initial version
	  of the zone.  The parental DS points to DNSKEY1. Before
	  the rollover starts, the child will have to verify what the
	  TTL is of the DS RR that points to DNSKEY1 -- it is needed
	  during the rollover and we refer to the value as TTL_DS.

	  </t>

	  <t hangText="new DNSKEY:"> During the
	  "new DNSKEY" phase, the zone administrator generates a second
	  KSK, DNSKEY2. The key is provided to the parent, and the
	  child will have to wait until a new DS RR has been
	  generated that points to DNSKEY2. After that DS RR has
	  been published on all servers authoritative for the
	  parent's zone, the zone administrator has to wait at least
	  TTL_DS to make sure that the old DS RR has expired from
	  caches.

	  </t>

          <t hangText="DS change:"> The parent replaces DS1 with
          DS2.
          </t>

	  <t hangText="DNSKEY removal:"> DNSKEY1 has been 
	  removed.
	  </t>
	  </list>
	  </t>
	  <t>The scenario above puts the responsibility for
	  maintaining a valid chain of trust with the child. It also
	  is based on the premise that the parent only has one DS RR
	  (per algorithm) per zone.  An alternative mechanism has been
	  considered.  Using an established trust relation, the
	  interaction can be performed in-band, and the removal of
	  the keys by the child can possibly be signaled by the parent. In
	  this mechanism, there are periods where there are two DS RRs
	  at the parent. Since at the moment of writing the protocol
	  for this interaction has not been developed, further discussion
	  is out of scope for this document.

	  </t>
	</section><!--Key signing key rollovers-->


      <section anchor="diff_zsk_ksk" title="Difference Between ZSK and KSK Rollovers">

	<t> Note that KSK rollovers and ZSK rollovers are different in the
	sense that a KSK rollover requires interaction with the parent (and
	possibly replacing of trust anchors) and the ensuing delay while waiting
	for it.
	</t>
	  
	<t>
	  A zone key 
	  rollover can be handled in two different ways: pre-publish (<xref
	  target="pre-pub-zsk"/>) and double signature (<xref
	  target="dub-sig-zsk"/>).
	</t>
	<t>
	  As the KSK is used to validate the key set and because the
	  KSK is not changed during a ZSK rollover, a cache is able to
	  validate the new key set of the zone.  The pre-publish
	  method would also work for a KSK rollover. The records that are to
	  be pre-published are the parental DS RRs.
	The pre-publish method has some drawbacks for KSKs. We first describe the
	rollover scheme and then indicate these drawbacks.
        </t>
	  <figure>
          <preample>
        <t>
        <!-- nothing -->
        </t>
          </preample>
	    <artwork>
--------------------------------------------------------------------
  initial         new DS           new DNSKEY      DS/DNSKEY removal
--------------------------------------------------------------------
Parent:
  SOA0            SOA1             -------->       SOA2
  RRSIGpar(SOA0)  RRSIGpar(SOA1)   -------->       RRSIGpar(SOA2) 
  DS1             DS1              -------->       DS2
                  DS2              -------->
  RRSIGpar(DS)    RRSIGpar(DS)     -------->       RRSIGpar(DS)   

Child:
  SOA0            -------->        SOA1            SOA1
  RRSIG10(SOA0)   -------->        RRSIG10(SOA1)   RRSIG10(SOA1)
                  -------->
  DNSKEY1         -------->        DNSKEY2         DNSKEY2
                  -------->         
  DNSKEY10        -------->        DNSKEY10        DNSKEY10
  RRSIG1 (DNSKEY) -------->        RRSIG2(DNSKEY)  RRSIG2 (DNSKEY)
  RRSIG10(DNSKEY) -------->        RRSIG10(DNSKEY) RRSIG10(DNSKEY)
--------------------------------------------------------------------
	    </artwork>
            <postample>
            <t>
            Stages of Deployment for a Pre-Publish Key Signing Key
            Rollover
            </t>
            </postample>
	  </figure> 

          <t>
	  When the child zone wants to roll, it notifies the
	  parent during the "new DS" phase and submits the new key (or
	  the corresponding DS) to the parent. 
	  The parent publishes DS1 and DS2, pointing to
	  DNSKEY1 and DNSKEY2, respectively. During the rollover ("new DNSKEY"
          phase), which
	  can take place as soon as the new DS set propagated through
	  the DNS, the child replaces DNSKEY1 with
   	  DNSKEY2. Immediately after that ("DS/DNSKEY removal" phase),
          it can notify the parent that the old DS record can be deleted.
	</t> 
        
        <t> The drawbacks of this scheme are that during the
	"new DS" phase the parent cannot verify the match between the
	DS2 RR and DNSKEY2 using the DNS -- as DNSKEY2 is not
        yet published. Besides, we introduce a
	"security lame" key (see <xref target="lame"/>). Finally, the
	child-parent interaction consists of two steps. The "double
	signature" method only needs one interaction.	
	
</t>



      </section> <!-- Difference Between ZSK and KSK Rollovers -->


	<!-- Adopted from  gilles - ambivalent on whether this is useful -->

	<section anchor="autokeyroll" title="Automated Key Rollovers">
	  <t>
	    As keys must be renewed periodically, there is some motivation to
	    automate the rollover process. Consider the following:
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		ZSK rollovers are easy to automate as only the child zone is involved. 
	      </t>

	      <t>
		A KSK rollover needs interaction between parent and child. 
		Data exchange is needed to provide the new keys to the parent; consequently, 
		this data must be authenticated and integrity must be guaranteed in order to avoid
		attacks on the rollover.
	      </t>
	      
	    </list>
	  </t>
	  
	</section> <!-- Automated Key Rollovers -->
	
      </section><!--Key rollover-->
      
      
      <section anchor="emergency" title="Planning for Emergency Key Rollover">


	<t> This section deals with preparation for a possible key
	compromise. Our advice is to have a documented procedure ready
	for when a key compromise is suspected or confirmed.
	</t>

	<t> When the private material of one of your keys is
	compromised it can be used for as long as a valid
	trust chain exists.  A trust chain remains
	intact for
	<list style="symbols">
	  <t> as long as a signature over the compromised key 
	  in the trust chain is valid,
	  </t>
	  <t> as long as a parental DS RR (and signature) points to
	  the compromised key,
	  </t>
	  <t> as long as the key is anchored in a resolver and is
	  used as a starting point for validation (this is generally the hardest
	  to update).

	  </t>
	</list>


	</t>
	<t>
	  While a trust chain to your compromised key
	  exists, your namespace is vulnerable to abuse by anyone who
	  has obtained illegitimate possession of the key. Zone
	  operators have to make a trade-off if the abuse of the
	  compromised key is worse than having data in caches that
	  cannot be validated. If the zone operator chooses to break
	  the trust chain to the compromised key, data in
	  caches signed with this key cannot be validated. However, if
	  the zone administrator chooses to take the path of a regular
	  rollover, the malicious key holder can spoof data so that
	  it appears to be valid. 
	</t>
	
	<section title="KSK Compromise">

          <t> A zone containing a DNSKEY RRSet with a compromised KSK
          is vulnerable as long as the compromised KSK is configured as
          trust anchor or a parental DS points to it.  </t> 

         <t> A compromised KSK can be used to sign the key set of an
          attacker's zone. That zone could be used to poison
          the DNS.  </t>

         <t>
          Therefore, when the KSK has been compromised, the trust anchor
          or the parental DS should be replaced as soon as
          possible. It is local policy whether to break the
          trust chain during the emergency rollover. The
          trust chain would be broken when the compromised
          KSK is removed from the child's zone
          while the parent still has a DS pointing to the compromised
          KSK (the assumption is that there is only one DS at the
          parent. If there are multiple DSes this does not apply -- however
	  the chain of trust of this particular key is broken).  </t>

	  <t> Note that an attacker's zone still uses the compromised KSK and the presence
	  of a parental DS would cause the data in this zone
	  to appear as valid. Removing the compromised key would cause
	  the attacker's zone to appear as valid and the child's zone as
	  Bogus. Therefore, we advise not to remove the KSK before the
	  parent has a DS to a new KSK in place. </t>

	<section title="Keeping the Chain of Trust Intact">

          <t>If we follow this advice, the timing of the replacement of
          the KSK is somewhat critical. The goal is to remove the
          compromised KSK as soon as the new DS RR is available at the
          parent. And also make sure that the signature made with a new
          KSK over the key set with the compromised KSK in it expires
          just after the new DS appears at the parent, thus removing
the old cruft in one swoop.
	  </t>

          <t>
          The procedure is as follows: 
         <list style="numbers"> 


          <t>Introduce a new KSK into the key set, keep the
          compromised KSK in the key set.</t>

         <t>Sign the key set, with a short validity period.  The
	  validity period should expire shortly after the DS is
	  expected to appear in the parent and the old DSes have
	  expired from caches.</t>

	  <t>Upload the DS for this new key to the parent.</t> 

          <t>Follow the procedure of the regular KSK rollover: Wait
          for the DS to appear in the authoritative servers and then
          wait as long as the TTL of the old DS RRs. If necessary
          re-sign the DNSKEY RRSet and modify/extend the expiration time.</t>

         <t> Remove the compromised
             DNSKEY RR from the zone and re-sign the key set using your
             "normal" validity interval.
	     </t>

        </list>

     </t>

           <t>
          An additional danger of a key compromise is that the
          compromised key could be used to facilitate a legitimate
          DNSKEY/DS rollover and/or nameserver changes at the parent. When
          that happens, the domain may be in dispute. An
          authenticated out-of-band and secure notify mechanism to
          contact a parent is needed in this case.
                  </t>
                  <!-- This is only when as DNSSEC keys are used to
                  validate the rollover -->
                  <t>
                  Note that this is only a problem when the DNSKEY and or
                  DS records are used for authentication at the parent.
                  </t>

	</section> <!-- Keeping the Chain of Trust Intact -->

	<section title="Breaking the Chain of Trust">
        <t> There are two methods to break the chain of trust. The first method causes the 
	child zone to appear 'Bogus' to validating resolvers. The other
        causes the child zone to appear 'insecure'. These are described below.
	</t>

	<t>
        In the method that causes the child zone to appear 'Bogus' to 
        validating resolvers, 
        the child zone
	replaces the current KSK with a new one and re-signs the key set.
	Next it sends the DS of the new key to the parent. Only after the
	parent has placed the new DS in the zone is the child's chain of
	trust repaired. 
	</t>
        <t>
	An alternative method of breaking the chain of trust is by
        removing the DS RRs from the parent zone altogether. As a result, the
        child zone would become insecure. 
	</t>
    

	</section> <!-- Breaking the Chain of Trust -->


	</section><!--KSK compromise-->

	<section title="ZSK Compromise">

	  <t> Primarily because there is no parental interaction
	  required when a ZSK is compromised, the situation is less
	  severe than with a KSK compromise. The zone must still
	  be re-signed with a new ZSK as soon as possible. As this is a
	  local operation and requires no communication between the
	  parent and child, this can be achieved fairly
	  quickly. However, one has to take into account that just as
	  with a normal rollover the immediate disappearance of the
	  old compromised key may lead to verification problems. 
          Also note that as long as the RRSIG
          over the compromised ZSK is not expired the zone may be still at
          risk.

	  </t>
	</section><!--ZSK compromise-->
	
	<section title="Compromises of Keys Anchored in Resolvers">


	  <t> A key can also be pre-configured in resolvers. For
	  instance, if DNSSEC is successfully deployed the root key
	  may be pre-configured in most security aware
	  resolvers.
	  </t> 

	  <t> If trust-anchor keys are compromised, the resolvers
	  using these keys should be notified of this fact. Zone
	  administrators may consider setting up a mailing list to
	  communicate the fact that a SEP key is about to be rolled
	  over. This communication will of course need to be
	  authenticated, e.g., by using digital signatures.
	  </t>
	  <t>
	    End-users faced with the task of updating an anchored key
	    should always validate the new key. New keys should be
	    authenticated out-of-band, for example, through the use of
	    an announcement website that is secured using secure
	    sockets (TLS) <xref target="RFC4366"/>.
	  </t>
	</section><!--Pre-configured key compromise-->
	
	
      </section> <!--Planning for key compromise -->
      
      <!--  -->

      <section anchor="parents" title="Parental Policies">


	<section title="Initial Key Exchanges and Parental Policies Considerations">

	  <t> The initial key exchange is always subject to the policies
	  set by the parent. When designing a key
	  exchange policy one should take into account that the
	  authentication and authorization mechanisms used during a key
	  exchange should be as strong as the authentication and
	  authorization mechanisms used for the exchange of delegation
	  information between parent and child. That is, there is no implicit 
	  need in DNSSEC to make the authentication process stronger than it was
	  in DNS.</t>


	  <t> Using the DNS itself as the source for the actual DNSKEY
	  material, with an out-of-band check on the validity of the
	  DNSKEY, has the benefit that it reduces the chances of user
	  error. A DNSKEY query tool can make use of the
	  SEP bit <xref target="RFC4035"/> to select the proper
	  key from a DNSSEC key set, thereby reducing the chance that
	  the wrong DNSKEY is sent. It can validate the self-signature
	  over a key; thereby verifying the ownership of the private
	  key material. Fetching the DNSKEY from the DNS ensures that
	  the chain of trust remains intact once the parent publishes
	  the DS RR indicating the child is secure.  </t>

	  <t> Note: the out-of-band verification is still needed when the
	  key material is fetched via the DNS. The parent can never be
	  sure whether or not the DNSKEY RRs have been spoofed.
	  </t>

	</section>
	
	<section title="Storing Keys or Hashes?">

	  <t>When designing a registry system one should consider
	  which of the DNSKEYs and/or the corresponding DSes to store.
	  Since a child zone might wish to have a DS published using a
	  message digest algorithm not yet understood by the registry,
	  the registry can't count on being able to generate the DS
	  record from a raw DNSKEY.  Thus, we recommend that registry
	  systems at least support storing DS records.
	  </t>

	  <t> It may also be useful to store DNSKEYs, since having
	  them may help during troubleshooting and, as long as the
	  child's chosen message digest is supported, the overhead of
	  generating DS records from them is minimal.  Having an
	  out-of-band mechanism, such as a registry directory (e.g., Whois), 
	  to find out which keys are used to generate DS Resource Records for
	  specific owners and/or zones may also help with
	  troubleshooting.
	  </t>

	  <t>The storage considerations also relate to the design of
	  the customer interface and the method by which data is
	  transferred between registrant and registry; Will the child
	  zone administrator be able to upload DS RRs with unknown
	  hash algorithms or does the interface only allow DNSKEYs? In
	  the registry-registrar model, one can use the DNSSEC
	  extensions to the Extensible Provisioning Protocol (EPP)
	  <xref target="RFC4310"/>, which allows transfer of DS RRs
	  and optionally DNSKEY RRs.
	  </t>
	  
	</section>

	<section title="Security Lameness" anchor="lame">

	  <t> Security lameness is defined as what happens when a
	  parent has a DS RR pointing to a non-existing
	  DNSKEY RR.  When this happens, the child's zone may be marked
	  "Bogus" by verifying DNS clients.
	  </t>

	 <t> As part of a comprehensive delegation check, the parent could,
	 at key exchange time, verify that the child's key is actually
	 configured in the DNS.
	  However, if a parent does not understand the hashing algorithm used
	  by child, the parental checks are limited to only comparing the key
	  id.
	  </t>
	  
	  <t>
	    Child zones should be very careful in removing DNSKEY material,
	    specifically SEP keys, for which a DS RR exists.
	  </t>

	  <t> Once a zone is "security lame", a fix (e.g., removing a
	  DS RR) will take time to propagate through the DNS.

	  </t>
	</section>
	
	<section anchor="DSvalidity" title="DS Signature Validity Period">

	  <t>Since the DS can be replayed as long as it has a valid
	  signature, a short signature validity period over the DS
	  minimizes the time a child is vulnerable in the case of a
	  compromise of the child's KSK(s).  A signature validity
	  period that is too short introduces the possibility that a
	  zone is marked "Bogus" in case of a configuration error in the
	  signer. There may not be enough time to fix the problems
	  before signatures expire.  Something as mundane as operator
	  unavailability during weekends shows the need for DS
	  signature validity periods longer than 2 days. We recommend an
	  absolute minimum for a DS signature validity period of a few days.
	  </t>

	  <t>The maximum signature validity period of the DS record depends on
	  how long child zones are willing to be vulnerable after a key compromise. On
	  the other hand, shortening the DS signature validity interval increases the
	  operational risk for the parent. Therefore, the parent may have policy to use
	  a signature validity interval that is considerably longer than the child would
	  hope for.
	  </t>

	<t> A compromise between the operational constraints of the parent
	and minimizing damage for the child may result in a DS signature
	validity period somewhere between a week and months.
	</t>
	  
	  <t>
	  In addition to the signature validity period, which sets a lower
	  bound on the number of times the zone owner will need to sign the
	  zone data and which sets an upper bound to the time a child is
	  vulnerable after key compromise,  there is the TTL value on the DS
	  RRs.  Shortening the TTL means that the authoritative servers will see more
	  queries.  But on the other hand, a short TTL lowers the persistence of
	  DS RRSets in caches thereby increasing the speed with which updated DS
	  RRSets propagate through the DNS.
	  </t>
	</section>

      </section><!-- Parental policies -->
      

      
    </section><!-- Signature generation key rollover and related policies -->      
      

      <section title="Security Considerations">

	<t> DNSSEC adds data integrity to the DNS. This document tries
	to assess the operational considerations to maintain a stable
	and secure DNSSEC service. Not taking into account the 'data
	propagation' properties in the DNS will cause validation
	failures and may make secured zones unavailable to
        security-aware resolvers.  </t> 
	
	
      </section><!--Security considerations-->
      

      <section title="IANA considerations">
	<t>There are no IANA considerations with respect to this document</t>
      </section>
      
      <section title="Acknowledgments">
	
	<t>
	  Most of the ideas in this document were the result of collective
	  efforts during workshops, discussions, and tryouts.
	</t>
	
	<t>
	  At the risk of forgetting individuals who were the original
	  contributors of the ideas, we would like to acknowledge people
	  who were actively involved in the compilation of this
	  document. In random order:
	  
	  Rip Loomis, Olafur Gudmundsson, Wesley Griffin, Michael
	  Richardson, Scott Rose, Rick van Rein, Tim McGinnis, Gilles
	  Guette Olivier Courtay, Sam Weiler, Jelte Jansen, Niall O'Reilly,
	  Holger Zuleger, Ed Lewis, Hilarie Orman, Marcos Sanz, and Peter 
          Koch.
	</t>
	
	<t>
	  Some material in this document has been copied
	  from <xref target="RFC2541">RFC 2541</xref>.
	</t>

	<t> 
	  Mike StJohns designed the key exchange between parent and
	  child mentioned in the last paragraph of <xref
	  target="ksk-rollover"/>
	</t>
	<t>
	  <xref target="autokeyroll"/> was supplied by G. Guette and
	  O. Courtay.
	</t>

	<t> Emma Bretherick, Adrian Bedford, and Lindy Foster corrected many of the
	spelling and style issues.</t>

	<t> Kolkman and Gieben take the blame for introducing all
miscakes (sic).


	</t>

        <t> While working on this document, Kolkman was employed by
the RIPE NCC and Gieben was employed by NLnet Labs.
	  </t>
	
      </section><!-- Acknowledgments -->
      
      

    </middle>
    
    
    <back>
      
      
      <references title='Normative References'>
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.1034.xml"?>

<reference anchor='RFC1034'>

<front>
<title abbrev='Domain Concepts and Facilities'>Domain names - concepts and facilities</title>
<author initials='P.' surname='Mockapetris' fullname='P. Mockapetris'>
<organization>Information Sciences Institute (ISI)</organization></author>
<date year='1987' day='1' month='November' /></front>

<seriesInfo name='STD' value='13' />
<seriesInfo name='RFC' value='1034' />
<format type='TXT' octets='129180' target='ftp://ftp.isi.edu/in-notes/rfc1034.txt' />
</reference>
<?rfc linefile="1928:draft-ietf-dnsop-rfc4641bis.xml"?>
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.1035.xml"?>

<reference anchor='RFC1035'>

<front>
<title abbrev='Domain Implementation and Specification'>Domain names - implementation and specification</title>
<author initials='P.' surname='Mockapetris' fullname='P. Mockapetris'>
<organization>USC/ISI</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90291</code>
<country>US</country></postal>
<phone>+1 213 822 1511</phone></address></author>
<date year='1987' day='1' month='November' /></front>

<seriesInfo name='STD' value='13' />
<seriesInfo name='RFC' value='1035' />
<format type='TXT' octets='125626' target='ftp://ftp.isi.edu/in-notes/rfc1035.txt' />
</reference>
<?rfc linefile="1929:draft-ietf-dnsop-rfc4641bis.xml"?>
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.4033.xml"?>

<reference anchor='RFC4033'>

<front>
<title>DNS Security Introduction and Requirements</title>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'>
<organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'>
<organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'>
<organization /></author>
<date year='2005' month='March' />
<abstract>
<t>The Domain Name System Security Extensions (DNSSEC) add data origin authentication and data integrity to the Domain Name System.  This document introduces these extensions and describes their capabilities and limitations.  This document also discusses the services that the DNS security extensions do and do not provide.  Last, this document describes the interrelationships between the documents that collectively describe DNSSEC. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4033' />
<format type='TXT' octets='52445' target='ftp://ftp.isi.edu/in-notes/rfc4033.txt' />
</reference>
<?rfc linefile="1930:draft-ietf-dnsop-rfc4641bis.xml"?>
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.4034.xml"?>

<reference anchor='RFC4034'>

<front>
<title>Resource Records for the DNS Security Extensions</title>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'>
<organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'>
<organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'>
<organization /></author>
<date year='2005' month='March' />
<abstract>
<t>This document is part of a family of documents that describe the DNS Security Extensions (DNSSEC). The DNS Security Extensions are a collection of resource records and protocol modifications that provide source authentication for the DNS. This document defines the public key (DNSKEY), delegation signer (DS), resource record digital signature (RRSIG), and authenticated denial of existence (NSEC) resource records. The purpose and format of each resource record is described in detail, and an example of each resource record is given.&lt;/t>&lt;t> This document obsoletes RFC 2535 and incorporates changes from all updates to RFC 2535. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4034' />
<format type='TXT' octets='63879' target='ftp://ftp.isi.edu/in-notes/rfc4034.txt' />
</reference>
<?rfc linefile="1931:draft-ietf-dnsop-rfc4641bis.xml"?>
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.4035.xml"?>

<reference anchor='RFC4035'>

<front>
<title>Protocol Modifications for the DNS Security Extensions</title>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'>
<organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'>
<organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'>
<organization /></author>
<date year='2005' month='March' />
<abstract>
<t>This document is part of a family of documents that describe the DNS Security Extensions (DNSSEC). The DNS Security Extensions are a collection of new resource records and protocol modifications that add data origin authentication and data integrity to the DNS. This document describes the DNSSEC protocol modifications. This document defines the concept of a signed zone, along with the requirements for serving and resolving by using DNSSEC. These techniques allow a security-aware resolver to authenticate both DNS resource records and authoritative DNS error indications.&lt;/t>&lt;t> This document obsoletes RFC 2535 and incorporates changes from all updates to RFC 2535. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4035' />
<format type='TXT' octets='130589' target='ftp://ftp.isi.edu/in-notes/rfc4035.txt' />
</reference>
<?rfc linefile="1932:draft-ietf-dnsop-rfc4641bis.xml"?>
      </references>
      

      
      
      <references title='Informative References'>
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.2119.xml"?>

<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='17491' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>
<?rfc linefile="1939:draft-ietf-dnsop-rfc4641bis.xml"?>      
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.1995.xml"?>

<reference anchor='RFC1995'>

<front>
<title>Incremental Zone Transfer in DNS</title>
<author initials='M.' surname='Ohta' fullname='Masataka Ohta'>
<organization>Computer Center Tokyo Institute of Technology</organization>
<address>
<postal>
<street>2-12-1, O-okayama</street>
<street>Meguro-ku</street>
<city>Tokyo</city>
<code>152</code>
<country>JP</country></postal>
<phone>+81 3 57343299</phone>
<facsimile>+81 3 57343415</facsimile>
<email>mohta@necom830.hpcl.titech.ac.jp</email></address></author>
<date year='1996' month='August' />
<abstract>
<t>This document proposes extensions to the DNS protocols to provide an incremental zone transfer (IXFR) mechanism.</t></abstract></front>

<seriesInfo name='RFC' value='1995' />
<format type='TXT' octets='16810' target='ftp://ftp.isi.edu/in-notes/rfc1995.txt' />
</reference>
<?rfc linefile="1940:draft-ietf-dnsop-rfc4641bis.xml"?>      
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.1996.xml"?>

<reference anchor='RFC1996'>

<front>
<title>A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY)</title>
<author initials='P.' surname='Vixie' fullname='Paul Vixie'>
<organization>Internet Software Consortium</organization>
<address>
<postal>
<street>Star Route Box 159A</street>
<city>Woodside</city>
<region>CA</region>
<code>94062</code>
<country>US</country></postal>
<phone>+1 415 747 0204</phone>
<email>paul@vix.com</email></address></author>
<date year='1996' month='August' />
<abstract>
<t>This memo describes the NOTIFY opcode for DNS, by which a master server advises a set of slave servers that the master's data has been changed and that a query should be initiated to discover the new data.</t></abstract></front>

<seriesInfo name='RFC' value='1996' />
<format type='TXT' octets='15247' target='ftp://ftp.isi.edu/in-notes/rfc1996.txt' />
</reference>
<?rfc linefile="1941:draft-ietf-dnsop-rfc4641bis.xml"?>      
        <?rfc?><?rfc linefile="1:bibxml/reference.RFC.3007.xml"?>

<reference anchor='RFC3007'>

<front>
<title>Secure Domain Name System (DNS) Dynamic Update</title>
<author initials='B.' surname='Wellington' fullname='B. Wellington'>
<organization /></author>
<date year='2000' month='November' />
<abstract>
<t>This document proposes a method for performing secure Domain Name System (DNS) dynamic updates. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3007' />
<format type='TXT' octets='18056' target='ftp://ftp.isi.edu/in-notes/rfc3007.txt' />
</reference>
<?rfc linefile="1942:draft-ietf-dnsop-rfc4641bis.xml"?>      
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.2308.xml"?>

<reference anchor='RFC2308'>

<front>
<title abbrev='DNS NCACHE'>Negative Caching of DNS Queries (DNS NCACHE)</title>
<author initials='M.' surname='Andrews' fullname='Mark Andrews'>
<organization>CSIRO - Mathematical and Information Sciences</organization>
<address>
<postal>
<street>Locked Bag 17</street>
<street>North Ryde NSW 2113</street>
<country>AUSTRALIA</country></postal>
<phone>+61 2 9325 3148</phone>
<email>Mark.Andrews@cmis.csiro.au</email></address></author>
<date year='1998' month='March' />
<area>Applications</area>
<keyword>domain name system</keyword>
<keyword>DNS</keyword>
<abstract>
<t>

   [RFC1034] provided a description of how to cache negative responses.

   It however had a fundamental flaw in that it did not allow a name

   server to hand out those cached responses to other resolvers, thereby

   greatly reducing the effect of the caching.  This document addresses

   issues raise in the light of experience and replaces [RFC1034 Section

   4.3.4].
</t>
<t>



   Negative caching was an optional part of the DNS specification and

   deals with the caching of the non-existence of an RRset [RFC2181] or

   domain name.

</t>
<t>


   Negative caching is useful as it reduces the response time for

   negative answers.  It also reduces the number of messages that have

   to be sent between resolvers and name servers hence overall network

   traffic.  A large proportion of DNS traffic on the Internet could be

   eliminated if all resolvers implemented negative caching.  With this

   in mind negative caching should no longer be seen as an optional part

   of a DNS resolver.
</t></abstract></front>

<seriesInfo name='RFC' value='2308' />
<format type='TXT' octets='41428' target='ftp://ftp.isi.edu/in-notes/rfc2308.txt' />
<format type='XML' octets='41491' target='http://xml.resource.org/public/rfc/xml/rfc2308.xml' />
</reference>
<?rfc linefile="1943:draft-ietf-dnsop-rfc4641bis.xml"?>
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.2541.xml"?>

<reference anchor='RFC2541'>

<front>
<title>DNS Security Operational Considerations</title>
<author initials='D.E.' surname='Eastlake' fullname='Donald E. Eastlake 3rd'>
<organization>IBM</organization>
<address>
<postal>
<street>65 Shindegan Hill Road</street>
<street>RR #1</street>
<city>Carmel</city>
<region>NY</region>
<code>10512</code>
<country>US</country></postal>
<phone>+1 914 276 2668</phone>
<facsimile>+1 914 784 3833</facsimile>
<email>dee3@us.ibm.com</email></address></author>
<date year='1999' month='March' />
<abstract>
<t>Secure DNS is based on cryptographic techniques.  A necessary part of the strength of these techniques is careful attention to the operational aspects of key and signature generation, lifetime, size, and storage.  In addition, special attention must be paid to the security of the high level zones, particularly the root zone.  This document discusses these operational aspects for keys and signatures used in connection with the KEY and SIG DNS resource records.</t></abstract></front>

<seriesInfo name='RFC' value='2541' />
<format type='TXT' octets='14498' target='ftp://ftp.isi.edu/in-notes/rfc2541.txt' />
</reference>
<?rfc linefile="1944:draft-ietf-dnsop-rfc4641bis.xml"?>
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.3766.xml"?>

<reference anchor='RFC3766'>

<front>
<title>Determining Strengths For Public Keys Used For Exchanging Symmetric Keys</title>
<author initials='H.' surname='Orman' fullname='H. Orman'>
<organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<date year='2004' month='April' />
<abstract>
<t>Implementors of systems that use public key cryptography to exchange symmetric keys need to make the public keys resistant to some predetermined level of attack.  That level of attack resistance is the strength of the system, and the symmetric keys that are exchanged must be at least as strong as the system strength requirements.  The three quantities, system strength, symmetric key strength, and public key strength, must be consistently matched for any network protocol usage.  While it is fairly easy to express the system strength requirements in terms of a symmetric key length and to choose a cipher that has a key length equal to or exceeding that requirement, it is harder to choose a public key that has a cryptographic strength meeting a symmetric key strength requirement.  This document explains how to determine the length of an asymmetric key as a function of a symmetric key strength requirement.  Some rules of thumb for estimating equivalent resistance to large-scale attacks on various algorithms are given.  The document also addresses how changing the sizes of the underlying large integers (moduli, group sizes, exponents, and so on) changes the time to use the algorithms for key exchange.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='86' />
<seriesInfo name='RFC' value='3766' />
<format type='TXT' octets='55939' target='ftp://ftp.isi.edu/in-notes/rfc3766.txt' />
</reference>
<?rfc linefile="1945:draft-ietf-dnsop-rfc4641bis.xml"?>
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.4086.xml"?>

<reference anchor='RFC4086'>

<front>
<title>Randomness Requirements for Security</title>
<author initials='D.' surname='Eastlake' fullname='D. Eastlake'>
<organization /></author>
<author initials='J.' surname='Schiller' fullname='J. Schiller'>
<organization /></author>
<author initials='S.' surname='Crocker' fullname='S. Crocker'>
<organization /></author>
<date year='2005' month='June' />
<abstract>
<t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts. However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities. The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.&lt;/t>&lt;t> Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult. This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities. It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='106' />
<seriesInfo name='RFC' value='4086' />
<format type='TXT' octets='114321' target='ftp://ftp.isi.edu/in-notes/rfc4086.txt' />
</reference>
<?rfc linefile="1946:draft-ietf-dnsop-rfc4641bis.xml"?>
	<?rfc?><?rfc linefile="1:bibxml/reference.RFC.4310.xml"?>

<reference anchor='RFC4310'>

<front>
<title>Domain Name System (DNS) Security Extensions Mapping for the Extensible Provisioning Protocol (EPP)</title>
<author initials='S.' surname='Hollenbeck' fullname='S. Hollenbeck'>
<organization /></author>
<date year='2005' month='December' />
<abstract>
<t>This document describes an Extensible Provisioning Protocol (EPP) extension mapping for the provisioning and management of Domain Name System security extensions (DNSSEC) for domain names stored in a shared central repository.  Specified in XML, this mapping extends the EPP domain name mapping to provide additional features required for the provisioning of DNS security extensions. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4310' />
<format type='TXT' octets='46326' target='ftp://ftp.isi.edu/in-notes/rfc4310.txt' />
</reference>
<?rfc linefile="1947:draft-ietf-dnsop-rfc4641bis.xml"?>
<reference anchor="selecting-crypto-key-sizes"> 
     <front>
       <title>Selecting Cryptographic Key
         Sizes</title>

       <author initials="A." surname="Lenstra" fullname="A. Lenstra">
         <organization></organization>
       </author>
       <author initials="E." surname="Verheul" fullname="E. Verheul">
         <organization></organization>
       </author>


       <date year="2001" />
     </front>
     <seriesInfo name="The Journal of Cryptology 14" value="(255-293)" />
   </reference>
<reference anchor="applied-crypto">
     <front>
       <title>Applied Cryptography: Protocols, Algorithms, and
         Source Code in C</title>

       <author initials="B." surname="Schneier" fullname="B. Schneier">
         <organization></organization>
       </author>

       <date year="1996" />
     </front>
     <seriesInfo name="ISBN (hardcover) 0-471-12845-7, ISBN
         (paperback) 0-471-59756-2" value="Published by John Wiley &amp;
Sons Inc." />
   </reference>
	<reference anchor="NIST-workshop">
     <front>
       <title>NIST DNSSEC workshop notes</title>

       <author initials="S." surname="Rose" fullname="S. Rose">
         <organization></organization>
       </author>

       <date month ="June" year="2001" />
     </front>
     <seriesInfo name="" value="" />
   </reference>

        <?rfc?><?rfc linefile="1:bibxml/reference.I-D.ietf-dnsext-dnssec-rsasha256"?>

<reference anchor='I-D.ietf-dnsext-dnssec-rsasha256'>
<front>
<title>Use of SHA-2 algorithms with RSA in DNSKEY and RRSIG Resource Records for  DNSSEC</title>

<author initials='J' surname='Jansen' fullname='Jelte Jansen'>
    <organization />
</author>

<date month='July' day='29' year='2008' />

<abstract><t>This document describes how to produce RSA/SHA-256 and RSA/SHA-512 DNSKEY and RRSIG resource records for use in the Domain Name System Security Extensions (DNSSEC, RFC 4033, RFC 4034, and RFC 4035).</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-dnsext-dnssec-rsasha256-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-dnsext-dnssec-rsasha256-05.txt' />
</reference>
<?rfc linefile="1993:draft-ietf-dnsop-rfc4641bis.xml"?>
        <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4509.xml"?>

<reference anchor='RFC4509'>

<front>
<title>Use of SHA-256 in DNSSEC Delegation Signer (DS) Resource Records (RRs)</title>
<author initials='W.' surname='Hardaker' fullname='W. Hardaker'>
<organization /></author>
<date year='2006' month='May' />
<abstract>
<t>This document specifies how to use the SHA-256 digest type in DNS Delegation Signer (DS) Resource Records (RRs).  DS records, when stored in a parent zone, point to DNSKEYs in a child zone. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4509' />
<format type='TXT' octets='14155' target='ftp://ftp.isi.edu/in-notes/rfc4509.txt' />
</reference>
<?rfc linefile="1994:draft-ietf-dnsop-rfc4641bis.xml"?>
        <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4366.xml"?>

<reference anchor='RFC4366'>

<front>
<title>Transport Layer Security (TLS) Extensions</title>
<author initials='S.' surname='Blake-Wilson' fullname='S. Blake-Wilson'>
<organization /></author>
<author initials='M.' surname='Nystrom' fullname='M. Nystrom'>
<organization /></author>
<author initials='D.' surname='Hopwood' fullname='D. Hopwood'>
<organization /></author>
<author initials='J.' surname='Mikkelsen' fullname='J. Mikkelsen'>
<organization /></author>
<author initials='T.' surname='Wright' fullname='T. Wright'>
<organization /></author>
<date year='2006' month='April' />
<abstract>
<t>This document describes extensions that may be used to add functionality to Transport Layer Security (TLS). It provides both generic extension mechanisms for the TLS handshake client and server hellos, and specific extensions using these generic mechanisms.&lt;/t>&lt;t> The extensions may be used by TLS clients and servers. The extensions are backwards compatible: communication is possible between TLS clients that support the extensions and TLS servers that do not support the extensions, and vice versa. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4366' />
<format type='TXT' octets='66344' target='ftp://ftp.isi.edu/in-notes/rfc4366.txt' />
</reference>
<?rfc linefile="1995:draft-ietf-dnsop-rfc4641bis.xml"?>
      </references>
      
      <section title="Terminology">

	<t> In this document, there is some jargon used that is defined
	in other documents. In most cases, we have not copied the text
	from the documents defining the terms but have given a more elaborate
	explanation of the meaning. Note that these explanations should not be 
	seen as authoritative.
	</t>

	<t>      
	  <list style="hanging">

	    <t hangText="Anchored key:">
	      A DNSKEY configured in resolvers around the globe. This key
	      is hard to update, hence the term anchored.
	    </t>


	    <t hangText="Bogus:">
	      Also see <xref target="RFC4033">Section
	      5 of</xref>.  An RRSet in DNSSEC is marked "Bogus" when a
	      signature of an RRSet does not validate against a DNSKEY.
	    </t>

	    <t hangText="Key Signing Key or KSK:">
	      A Key Signing Key (KSK) is a key that is used exclusively for
	      signing the apex key set.  The fact that a key is a KSK is
	      only relevant to the signing tool.
	    </t>

	    <t hangText="Key size:">
              The term 'key size' can be substituted by 'modulus size'
              throughout the document. It is mathematically more correct to
              use modulus size, but as this is a document directed at
              operators we feel more at ease with the term key size.
	    </t>
            
	    <t hangText="Private and public keys:">
	      DNSSEC secures the DNS through the use of public key
	      cryptography. Public key cryptography is based on the
	      existence of two (mathematically related) keys, a public key 
              and a private key. The
	      public keys are published in the DNS by use of the DNSKEY
	      Resource Record (DNSKEY RR). Private keys should
	      remain private.
	    </t>

	    <t hangText="Key rollover:">
	      A key rollover (also called key supercession in some
	      environments) is the act of replacing one key pair with
	      another at the end of a key effectivity period.
	    </t>
<!--
	    <t hangText="Key Suppercession">
	      The term used when rolling over a key while enjoying
	      a meal.
	    </t>
-->	   
	    <t hangText="Secure Entry Point (SEP) key:">
	      A KSK that has a parental DS record pointing to it or is
	      configured as a trust anchor. Although not required 
	      by the protocol, we recommend that the SEP flag
	       <xref target="RFC4035"/> is set on these keys.
	    </t>
            <t hangText="Self-signature:">
            This only applies to signatures over DNSKEYs; a signature
            made with DNSKEY x, over DNSKEY x is called a self-signature.
            Note: without further information, self-signatures convey no
            trust. They are useful to check the authenticity of the DNSKEY,
            i.e., they can be used as a hash.
            </t>

	    <t hangText="Singing the zone file:">
	      The term used for the event where an administrator joyfully
	      signs its zone file while producing melodic sound patterns.
	    </t>


	    <t hangText="Signer:">
	      The system that has access to the private key material and
	      signs the Resource Record sets in a zone. A signer may be
	      configured to sign only parts of the zone, e.g., only those
	      RRSets for which existing signatures are about to expire.
	    </t>
	    <t hangText="Zone Signing Key (ZSK):">
	      A key that is used for signing
	      all data in a zone.  The fact that a key is a ZSK is only
	      relevant to the signing tool.
	    </t>


	    <t hangText="Zone administrator:">
	      The 'role' that is responsible for signing a zone and
	      publishing it on the primary authoritative server.
	    </t>
	  </list>
	  
	</t>
      </section>




      <section anchor="zskhowto" title="Zone Signing Key Rollover How-To">
	
	<t> Using the pre-published signature scheme and the most
	conservative method to assure oneself that data does not
	live in caches, here follows the "how-to".
	</t>
	<list style="hanging">
	    
	    <t hangText="Step 0:">
	      The preparation: Create two keys and publish both in
	      your key set.  Mark one of the keys "active" and the
	      other "published". Use the "active" key for signing your
	      zone data. Store the private part of the "published"
	      key, preferably off-line.  The protocol does not provide
	      for attributes to mark a key as active or
	      published. This is something you have to do on your own,
	      through the use of a notebook or key management tool.
	    </t>
	    <t hangText="Step 1:">
	      Determine expiration: At the beginning of the
	      rollover make a note of the highest expiration time of
	      signatures in your zone file created with the current key
	      marked as active.

	    Wait until the expiration time marked in Step 1 has passed.
	    </t>

	    <t hangText="Step 2:">
	      Then start using the key that was marked
	      "published" to sign your data (i.e., mark it
	      "active"). Stop using the key that was marked
	      "active"; mark it "rolled".
	    </t>
	    
	    <t hangText="Step 3:">
	      It is safe to engage in a new rollover (Step
	      1) after at least one signature validity period.
	    </t>
	</list>
      </section><!--"Zone Signing key operational checklist-->
      



      <section anchor="typography" title="Typographic Conventions">
	<t>
	  The following typographic conventions are used in this document:

	  <list style="hanging">
	    <t hangText="Key notation:">
	      A key is denoted by DNSKEYx, where x is a number or an
              identifier, x could be thought of as the key id.
	    </t>
	    <t hangText="RRSet notations:">
	      RRs are only denoted by the type. All other information
	      -- owner, class, rdata, and TTL -- is left out. Thus:
	      "example.com 3600 IN A 192.0.2.1" is reduced to
	      "A". RRSets are a list of RRs. A example of this would
	      be "A1, A2", specifying the RRSet containing two "A"
	      records. This could again be abbreviated to just "A".
	    </t>
	      <t hangText="Signature notation:">
		Signatures are denoted as RRSIGx(RRSet), which means
		that RRSet is signed with DNSKEYx.
	      </t>

	      <t hangText="Zone representation:">
		Using the above notation we have simplified the
		representation of a signed zone by leaving out all
		unnecessary details such as the names and by
		representing all data by "SOAx"
	      </t>

	      <t hangText="SOA representation:">
		SOAs are represented as SOAx, where x is the serial
		number.
	      </t>
	  </list>

	  Using this notation the following signed zone:

	  <figure>
    <artwork>

example.net.      86400  IN SOA  ns.example.net. bert.example.net. (
                         2006022100   ; serial 
                         86400        ; refresh (  24 hours)
                         7200         ; retry   (   2 hours)
                         3600000      ; expire  (1000 hours)
                         28800 )      ; minimum (   8 hours)
                  86400  RRSIG   SOA 5 2 86400 20130522213204 (
                               20130422213204 14 example.net.
                               cmL62SI6iAX46xGNQAdQ... )
                  86400  NS      a.iana-servers.net.
                  86400  NS      b.iana-servers.net.
                  86400  RRSIG   NS 5 2 86400 20130507213204 (
                               20130407213204 14 example.net.
                               SO5epiJei19AjXoUpFnQ ... )
                  86400  DNSKEY  256 3 5 (
                               EtRB9MP5/AvOuVO0I8XDxy0... ) ; id = 14
                  86400  DNSKEY  257 3 5 (
                               gsPW/Yy19GzYIY+Gnr8HABU... ) ; id = 15 
                  86400  RRSIG   DNSKEY 5 2 86400 20130522213204 (
                               20130422213204 14 example.net.
                               J4zCe8QX4tXVGjV4e1r9... )
                  86400  RRSIG   DNSKEY 5 2 86400 20130522213204 (
                               20130422213204 15 example.net.
                               keVDCOpsSeDReyV6O... )
                  86400  RRSIG   NSEC 5 2 86400 20130507213204 (
                               20130407213204 14 example.net.
                               obj3HEp1GjnmhRjX... )
a.example.net.    86400  IN TXT  "A label"
                  86400  RRSIG   TXT 5 3 86400 20130507213204 (
                               20130407213204 14 example.net.
                               IkDMlRdYLmXH7QJnuF3v... )
                  86400  NSEC    b.example.com. TXT RRSIG NSEC
                  86400  RRSIG   NSEC 5 3 86400 20130507213204 (
                               20130407213204 14 example.net.
                               bZMjoZ3bHjnEz0nIsPMM... )
                  ...
	    </artwork>
	  </figure>
	  
	  is reduced to the following representation:
	  
	  <figure>
	    <artwork>
    SOA2006022100            
    RRSIG14(SOA2006022100)
    DNSKEY14           
    DNSKEY15          
                   
    RRSIG14(KEY)     
    RRSIG15(KEY)     
	    </artwork>
	  </figure>

	  The rest of the zone data has the same signature as the SOA
	  record, i.e., an RRSIG created with DNSKEY 14.

	</t>
      </section>

      <section anchor="DED" title="Document Editing History">
	<t>[To be removed prior to publication as an RFC]</t>
	<section title="draft-ietf-dnsop-rfc4641-00">
	  <t>
	    Version 0 was differs from RFC4641 in the following ways.
	  <list style="symbols">
	    <t>
	      Status of this memo appropriate for I-D
	    </t>
	    <t>
	      TOC formatting differs.
	    </t>
	    <t>
	      Whitespaces, linebreaks, and pagebreaks may be slightly different
	      because of xml2rfc generation.
	    </t>
	    <t>
	      References slightly reordered.
	    </t>
	    <t>
	      Applied the errata from
	      http://www.rfc-editor.org/errata_search.php?rfc=4641
	    </t>
	    <t>
	      Inserted trivial "IANA considertations" section.
	    </t>
	  </list>

	  In other words it should not contain substantive changes in
	  content as intended by the workinggroup for the original RFC4641.
	  </t>
	</section>
	<t>
	$Id: draft-ietf-dnsop-rfc4641bis.xml 23 2009-03-02 11:02:11Z olaf $
	</t>
      </section>

    </back>
    
</rfc>
  