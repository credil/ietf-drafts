


behave                                                        X. Li, Ed.
Internet-Draft                                               C. Bao, Ed.
Intended status: Informational         CERNET Center/Tsinghua University
Expires: April 29, 2009                                    F. Baker, Ed.
                                                           Cisco Systems
                                                        October 26, 2008


                     IP/ICMP Translation Algorithm
                 draft-baker-behave-v4v6-translation-00

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on April 29, 2009.

Abstract

   This document specifies an update to the Stateless IP/ICMP
   Translation Algorithm (SIIT) described in RFC 2765.  The algorithm
   translates between IPv4 and IPv6 packet headers (including ICMP
   headers).

   This specification addresses both a stateful and a stateless mode.
   In the stateful mode, translation state is maintained between IPv4
   address/transport/port tuples and IPv6 address/transport/port tuples,
   enabling IPv6 systems to open sessions with IPv4 systems.  In the
   stateless mode, translation information is carried in the address



Li, et al.               Expires April 29, 2009                 [Page 1]

Internet-Draft            IPv4/IPv6 Translation             October 2008


   itself, permitting both IPv4->IPv6 and IPv6->IPv4 session
   establishment with neither state nor configuration in the translator.
   The choice of operational mode is made by the operator deploying the
   network and is critical to the operation of the applications using
   it.

   Significant issues exist in the stateful mode that are not addressed
   in this document, related to the maintenance of the translation
   tables.  This document confines itself to the actual translation.

Acknowledgement of previous work

   This document is a product of the 2008-2009 effort to define a
   replacement for NAT-PT.  It is an update to and directly derivative
   from Erik Nordmark's [RFC2765], which similarly provides both
   stateless and stateful translation between IPv4 [RFC0791] and IPv6
   [RFC2460], and between ICMPv4 [RFC0792] and ICMPv6 [RFC4443].  The
   original document was a product of the NGTRANS working group.  Some
   text had been extracted from an old Internet Draft titled "IPAE: The
   SIPP Interoperability and Transition Mechanism" authored by R.
   Gilligan, E. Nordmark, and B. Hinden.

   The changes in this document reflect five components:

   1.  Updating references

   2.  Redescribing the network model to map to present and projected
       usage

   3.  Moving the address format to the framework document, to
       coordinate with other drafts on the topic

   4.  Some changes in ICMP.

   5.  Description of both stateful and stateless operation.
















Li, et al.               Expires April 29, 2009                 [Page 2]

Internet-Draft            IPv4/IPv6 Translation             October 2008


Table of Contents

   1.  Introduction and Motivation  . . . . . . . . . . . . . . . . .  4
     1.1.  Applicability and Limitations  . . . . . . . . . . . . . .  9
     1.2.  Assumptions  . . . . . . . . . . . . . . . . . . . . . . . 10
     1.3.  Stateless vs Stateful Mode . . . . . . . . . . . . . . . . 10
     1.4.  Impact Outside the Network Layer . . . . . . . . . . . . . 10
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . 12
   3.  Requirements . . . . . . . . . . . . . . . . . . . . . . . . . 12
   4.  Translating from IPv4 to IPv6  . . . . . . . . . . . . . . . . 12
     4.1.  Translating IPv4 Headers into IPv6 Headers . . . . . . . . 14
     4.2.  Translating UDP over IPv4  . . . . . . . . . . . . . . . . 16
     4.3.  Translating ICMPv4 Headers into ICMPv6 Headers . . . . . . 16
     4.4.  Translating ICMPv4 Error Messages into ICMPv6  . . . . . . 18
     4.5.  Knowing when to Translate  . . . . . . . . . . . . . . . . 19
   5.  Translating from IPv6 to IPv4  . . . . . . . . . . . . . . . . 19
     5.1.  Translating IPv6 Headers into IPv4 Headers . . . . . . . . 21
     5.2.  Translating ICMPv6 Headers into ICMPv4 Headers . . . . . . 22
     5.3.  Translating ICMPv6 Error Messages into ICMPv4  . . . . . . 24
     5.4.  Knowing when to Translate  . . . . . . . . . . . . . . . . 24
   6.  Implications for IPv6-Only Nodes . . . . . . . . . . . . . . . 25
   7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 25
   8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 26
   9.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 26
   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 26
     10.1. Normative References . . . . . . . . . . . . . . . . . . . 26
     10.2. Informative References . . . . . . . . . . . . . . . . . . 27
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 28
   Intellectual Property and Copyright Statements . . . . . . . . . . 30






















Li, et al.               Expires April 29, 2009                 [Page 3]

Internet-Draft            IPv4/IPv6 Translation             October 2008


1.  Introduction and Motivation

   An understanding of the framework presented in [FRAMEWORK] is
   presumed in this document.  With that remark...

   The transition mechanisms specified in [RFC4213] handle the case of
   dual IPv4/IPv6 hosts interoperating with both dual hosts and IPv4-
   only hosts, which is needed early in the transition to IPv6.  The
   dual hosts are assigned both an IPv4 and one or more IPv6 addresses.
   The number of available globally unique IPv4 addresses will become
   smaller and smaller as the Internet grows; we expect that there will
   be a desire to take advantage of the large IPv6 address and not
   require that every new Internet node have a permanently assigned IPv4
   address.

   There are several different scenarios where there might be IPv6-only
   hosts that need to communicate with IPv4-only hosts.  These IPv6
   hosts might be IPv4-capable, i.e. include an IPv4 implementation but
   not be assigned an IPv4 address, or they might not even include an
   IPv4 implementation.  Examples include:

   o  A completely new network with new devices that all support IPv6.
      In this case it might be beneficial to not have to configure the
      routers within the new network to route IPv4 since none of the
      hosts in the new network are configured with IPv4 addresses.  But
      these new IPv6 devices might occasionally need to communicate with
      some IPv4 nodes out on the Internet.

   o  An existing network where a large number of IPv6 devices are
      added.  The IPv6 devices might have both an IPv4 and an IPv6
      protocol stack but there is not enough global IPv4 address space
      to give each one of them a permanent IPv4 address.  In this case
      it is more likely that the routers in the network already route
      IPv4 and are upgraded to dual routers.

   However, there are other potential solutions in this area:

   o  If there is no IPv4 routing inside the network i.e., the cloud
      that contains the new devices, some possible solutions are to
      either use the translators specified in this document at the
      boundary of the cloud, or to use Application Layer Gateways (ALG)
      on dual nodes at the cloud's boundary.  The ALG solution is less
      flexible in that it is application protocol specific and it is
      also less robust since an ALG box is likely to be a single point
      of failure for a connection using that box.

   o  Otherwise, if IPv4 routing is supported inside the cloud and the
      implementations support both IPv6 and IPv4 it might suffice to



Li, et al.               Expires April 29, 2009                 [Page 4]

Internet-Draft            IPv4/IPv6 Translation             October 2008


      have a mechanism for allocating a temporary address IPv4 and use
      IPv4 end to end when communicating with IPv4-only nodes.  However,
      it would seem that such a solution would require the pool of
      temporary IPv4 addresses to be partitioned across all the subnets
      in the cloud which would either require a larger pool of IPv4
      addresses or result in cases where communication would fail due to
      no available IPv4 address for the node's subnet.

   This document specifies an algorithm that is one of the components
   needed to make IPv6-only nodes interoperate with IPv4-only nodes.

   The IPv4 address will be used as an IPv4-translated IPv6 address as
   specified in [FRAMEWORK] and the packets will travel through an IP/
   ICMP translator that will translate the packet headers between IPv4
   and IPv6 and translate the addresses in those headers between IPv4
   addresses on one side and IPv4-translated or IPv4-mapped IPv6
   addresses on the other side.  There is provision for both stateless
   and stateful mappings.  Translated IPv4 addresses will always use the
   mapped format; the source address of an IPv6 datagram translated from
   IPv4 will always use the mapped form.  The use of the mapped form in
   the IPv6 network is, however, at the administration's discretion.
   Three obvious models emerge:

   o  All systems in the IPv6 domain use IPv4-mapped addresses, which
      enables stateless translation for all systems in all cases and
      makes all systems directly accessible by the IPv4 domain,

   o  No systems in the IPv6 domain use IPv4-mapped addresses, which is
      a lot like IPv4 NAT behavior and prevents all IPv4 systems from
      accessing servers in the IPv6 domain, or

   o  Some systems in the IPv6 domain (probably servers or dominant
      peers in peer-to-peer applications) use IPv4-mapped addresses,
      which means that those systems so addressed are accessible as
      servers by systems in the IPv4 domain but others not usable as
      servers accessible by the IPv4 domain.

   This specification does not cover the mechanisms used for assignment
   of IPv4-mapped addresses to IPv6 nodes or their registration in the
   DNS.  One might expect IPv4-mapped addresses to be allocated by
   mechanisms similar to and derived from similar tools in IPv4
   networks.

   The figures below show how the IP/ICMP Translation algorithm is used
   in networks that use translation.  We show three cases, that of a
   single translator, that of multiple translators, and that of a domain
   that has both stateless and stateful translation.




Li, et al.               Expires April 29, 2009                 [Page 5]

Internet-Draft            IPv4/IPv6 Translation             October 2008


                --------          --------
              //  IPv4  \\      //  IPv6  \\
             /   Domain   \    /   Domain   \
            /             +----+      +--+   \
           |              |XLAT|      |S2|    |  Sn: Servers
           | +--+         +----+      +--+    |  Hn: Clients
           | |S1|         +----+              |
           | +--+         |DNS |      +--+    |  XLAT: V4/V6 NAT
            \     +--+    +----+      |H2|   /   DNS:  DNS Server
             \    |H1|    /    \      +--+  /
              \\  +--+  //      \\        //
                --------          --------

        Figure 1: Using translation for a single interchange point

   Figure 1 shows a routing domain in which IPv4 is implemented (whether
   IPv4-only or dual stack) and another domain in which only IPv6
   routing, and potentially only IPv6-only hosts, are implemented.
   There is a translator on the boundary between them, and a DNS server
   that can serve on both sides of the translator.  The translator
   advertises an IPv4 route for the prefix mapped into IPv6 addresses in
   the IPv4 domain, and an IPv6 route for its prefix mapping the IPv4
   routing domain into the IPv6 domain.

   o  If H2 decides to connect to S1, it asks the DNS server for a AAAA
      record, and sends its datagram to the IPv6 address in the
      response.  Unknown to it, routing takes it to a translator, which
      emits an IPv4 datagram into the IPv4 domain.

   o  If H1 seeks access to S2, it similarly asks the DNS server for an
      A record and is given the IPv4 address of S2.  Routing takes its
      data to the translator, which emits an IPv6 datagram into the IPv6
      domain.

   o  If H1 seeks S1, is obviously gets S1's IPv4 address and
      communicates with it directly; in the same way, if H2 seeks S2, it
      gets the AAAA record and communicates directly with S2 even if the
      address it chooses happens to be a mapped IPv4 address.

   By extension, one could imagine a case in which S2 has an IPv4-mapped
   address and H2 has a general IPv6 address - any legal IPv6 address
   other than one that the translator recognizes as an IPv4-mapped
   address.  In this case, should S2 (an IPv6 device using an IPv4-
   mapped address) access an IPv4 system, the behavior is as previously
   described.  However, should H2 seek to access S1, the behavior is
   similar to the familiar IPv4 NAT; the translator saves H2's address
   and source port number and an overlay IPv4 address and source port
   number in a database, and



Li, et al.               Expires April 29, 2009                 [Page 6]

Internet-Draft            IPv4/IPv6 Translation             October 2008


   o  for datagrams traveling H2->S1, translates the source address and
      port according to the defined translation, and

   o  for datagrams traveling S1->H2, translates the destination address
      and port according to the defined translation.

   A stateful mapping of this kind requires appropriate handling of port
   numbers and checksums, and of creation and deletion of state, as
   described in [I-D.bagnulo-behave-nat64].

                --------          --------
              //  IPv4  \\      //  IPv6  \\
             /   Domain   \    /   Domain   \
            /             +----+      +--+   \
           |              |XLAT|      |S3|    |  Sn: Servers
           | +--+         +----+      +--+    |  Hn: Clients
           | |S1|         +----+              |
           | +--+         |DNS |      +--+    |  XLAT: V4/V6 NAT
            \     +--+    +----+      |H3|   /   DNS:  DNS Server
             \    |H1|    /    \      +--+  /
              \   +--+   /      \          /
             /            \    /            \
            /             +----+             \
           | +--+         |XLAT|     +--+     |
           | |S2|         +----+     |S4|     |
           | +--+         +----+     +--+     |
           |      +--+    |DNS |       +--+   |
            \     |H2|    +----+       |H4|  /
             \    +--+    /    \       +--+ /
              \\        //      \\        //
                --------          --------


       Figure 2: Using translation with multiple interchange points

   Figure 2 similarly shows a routing domain in which IPv4 is
   implemented (whether IPv4-only or dual stack) and another domain in
   which only IPv6 routing, and potentially only IPv6-only hosts, are
   implemented.  The difference from Figure 1 is that there are more
   than one translation point on the boundary between them, and more
   than one DNS server.  As in the previous case, each translator
   advertises an IPv4 route for the prefix mapped into IPv6 addresses in
   the IPv4 domain, and an IPv6 route for its prefix mapping the IPv4
   routing domain into the IPv6 domain.  If these are run by the same
   administration, they are likely to use the same prefix.  They could
   also use different prefixes at the network administration's option,
   and if they have different administrations they likely would - and
   might apply various policies to such routing.



Li, et al.               Expires April 29, 2009                 [Page 7]

Internet-Draft            IPv4/IPv6 Translation             October 2008


   o  If H4 decides to connect to S1 or S2, it asks the DNS server for a
      AAAA record, and sends its datagram to the IPv6 address in the
      response.  Unknown to it, routing takes it to a translator, which
      emits an IPv4 datagram into the IPv4 domain.  If the prefixes used
      by the translators are the same, the choice of translator is
      immaterial; if they are different, routing will take it to the
      right translator.

   o  If H1 seeks access to S3 or S4, it similarly asks the DNS server
      for an A record and is given the relevant IPv4 address.  Routing
      similarly takes its data to one of the translators, which emits an
      IPv6 datagram into the IPv6 domain.

   o  If H1 seeks S1 or S2, is obviously gets the IPv4 address and
      communicates with it directly; in the same way, if H4 seeks S3 or
      S4, it gets the AAAA record and communicates directly with it even
      if the address it chooses happens to be a mapped IPv4 address.

   In both cases, if the "IPv4 network" is in fact dual stack and
   contains dual stack hosts, direct IPv6 connectivity is precisely that
   - direct.  There is no translation even if the addresses used are
   mapped IPv4 addresses, because the routing is provided by more
   specific prefixes; the only datagrams translated are those that
   follow the more general route to the translator.

   The protocol translators are assumed to fit around some piece of
   topology that includes some IPv6-only nodes and that may also include
   IPv4 nodes as well as dual nodes.  There has to be a translator on
   each path used by routing the "translatable" packets in and out of
   this cloud to ensure that such packets always get translated.  This
   does not require a translator at every physical connection between
   the cloud and the rest of the Internet since the routing can be used
   to deliver the packets to the translator.

   The IPv6-only node communicating with an IPv4 node through a
   translator will see an IPv4-mapped address for the peer and use an
   IPv4-translatable address for its local address for that
   communication.  When the IPv6-only node sends packets the IPv4-mapped
   address indicates that the translator needs to translate the packets.
   When the IPv4 node sends packets those will translated to have the
   IPv4-translatable address as a destination; it is not possible to use
   an IPv4-mapped or an IPv4-compatible address as a destination since
   that would either route the packet back to the translator (for the
   IPv4-mapped address) or make the packet be encapsulated in IPv4 (for
   the IPv4-compatible address).  Thus this specification introduces the
   new notion of an IPv4-translatable address.





Li, et al.               Expires April 29, 2009                 [Page 8]

Internet-Draft            IPv4/IPv6 Translation             October 2008


1.1.  Applicability and Limitations

   The use of this translation algorithm assumes that the IPv6 network
   is somehow well connected i.e. when an IPv6 node wants to communicate
   with another IPv6 node there is an IPv6 path between them.  Various
   tunneling schemes exist that can provide such a path, but those
   mechanisms and their use is outside the scope of this document.

   The translating function as specified in this document does not
   translate any IPv4 options and it does not translate IPv6 routing
   headers, hop-by-hop extension headers, or destination options
   headers.  It could be possible to define a translation between source
   routing in IPv4 and IPv6.  However such a translation would not be
   semantically correct due to the slight differences between the IPv4
   and IPv6 source routing.  Also, the usefulness of source routing when
   going through a header translator might be limited since all the
   IPv6-only routers would need to have an IPv4-translated IPv6 address
   since the IPv4-only node will send a source route option containing
   only IPv4 addresses.

   [RFC5382] describes the issues and algorithms in the translation of
   datagrams containing TCP segments.  The considerations of that
   document are applicable in this case as well.

   At first sight it might appear that the IPsec functionality
   [RFC4301][RFC4302][RFC4303] can not be carried across the translator.
   However, since the translator does not modify any headers above the
   logical IP layer (IP headers, IPv6 fragment headers, and ICMP
   messages) packets encrypted using ESP in Transport-mode can be
   carried through the translator.  [Note that this assumes that the key
   management can operate between the IPv6-only node and the IPv4-only
   node.]  The AH computation covers parts of the IPv4 header fields
   such as IP addresses, and the identification field (fields that are
   either immutable or predictable by the sender) [RFC4302].  While the
   translation algorithm is specified so that those IPv4 fields can be
   predicted by the IPv6 sender it is not possible for the IPv6 receiver
   to determine the value of the IPv4 Identification field in packets
   sent by the IPv4 node.  Thus as the translation algorithm is
   specified in this document it is not possible to use end-to-end AH
   through the translator.

   For ESP Tunnel-mode to work through the translator the IPv6 node
   would have to be able to both parse and generate "inner" IPv4 headers
   since the inner IP will be encrypted together with the transport
   protocol.

   Thus in practise, only ESP transport mode is relatively easy to make
   work through a translator, unless an ESP tunnel is explicitly



Li, et al.               Expires April 29, 2009                 [Page 9]

Internet-Draft            IPv4/IPv6 Translation             October 2008


   carrying IPv4 inner and IPv6 outer headers.

   IPv4 multicast addresses can not be mapped to IPv6 multicast
   addresses.  For instance, 224.1.2.3 is an IPv4 multicast address, but
   an IPv6 address mapped to general IPv4 addresses and containing that
   value is not an IPv6 multicast address.  While the IP/ICMP header
   translation aspect of this memo in theory works for multicast packets
   this address mapping limitation makes it impossible to apply the
   techniques in this memo for multicast traffic.

1.2.  Assumptions

   The IPv6 nodes using the translator must have an IPv4-translated IPv6
   address while it is communicating with IPv4-only nodes.

   Fragmented IPv4 UDP packets that do not contain a UDP checksum (i.e.
   the UDP checksum field is zero) are not of significant use over wide-
   areas in the Internet and will not be translated by the translator.
   An informal trace [Miller] in the backbone showed that out of
   34,984,468 IP packets there were 769 fragmented UDP packets with a
   zero checksum.  However, all of them were due to malicious or broken
   behavior; a port scan and first fragments of IP packets that are not
   a multiple of 8 bytes.

1.3.  Stateless vs Stateful Mode

   The translator has two possible modes of operation: stateless and
   stateful.  In both cases, we assume that a system that has an IPv4
   address but not an IPv6 address is communicating with a system that
   has an IPv6 address but no IPv4 address, or that the two systems do
   not have contiguous routing connectivity in either domain and hence
   are forced to have their communications translated.

   In the stateless mode, one system has an IPv4 address and one has an
   address of the form specified in [FRAMEWORK], which is explicitly
   mapped to an IPv4 address.  In this mode, there is no need to concern
   oneself with port translation or translation tables, as the IPv4 and
   IPv6 counterparts are algorithmically related.

   In the stateful mode, the system with the IPv4 address will be
   represented by that same address type, but the IPv6 system may use
   any [RFC4291] address except one in that range.  In this case, a
   translation table is required.

1.4.  Impact Outside the Network Layer

   The potential existence of IP/ICMP translators is already taken care
   of from a protocol perspective in [RFC2460].  However, an IPv6 node



Li, et al.               Expires April 29, 2009                [Page 10]

Internet-Draft            IPv4/IPv6 Translation             October 2008


   that wants to be able to use translators needs some additional logic
   in the network layer.

   The network layer in an IPv6-only node, when presented by the
   application with either an IPv4 destination address or an IPv4-mapped
   IPv6 destination address, is likely to drop the packet and return
   some error message to the application.  In order to take advantage of
   translators such a node should instead send an IPv6 packet where the
   destination address is the IPv4-mapped address and the source address
   is the node's temporarily assigned IPv4-translated address.  If the
   node does not have a temporarily assigned IPv4-translated address it
   should acquire one using mechanisms that are not discussed in this
   document.

   Note that the above also applies to a dual IPv4/IPv6 implementation
   node which is not configured with any IPv4 address.

   There are no extra changes needed to applications to operate through
   a translator beyond what applications already need to do to operate
   on a dual node.  The applications that have been modified to work on
   a dual node already have the mechanisms to determine whether they are
   communicating with an IPv4 or an IPv6 peer.  Thus if the applications
   need to modify their behavior depending on the type of the peer, such
   as ftp determining whether to fallback to using the PORT/PASV command
   when EPRT/EPSV fails (as specified in [RFC2428]), they already need
   to do that when running on dual nodes and the presence of translators
   does not add anything.  For example, when using the socket API
   [RFC3493] the applications know that the peer is IPv6 if they get an
   AF_INET6 address from the name service and the address is not an
   IPv4-mapped address (i.e., IN6_IS_ADDR_V4MAPPED returns false).  If
   this is not the case, i.e., the address is AF_INET or an IPv4-mapped
   IPv6 address, the peer is IPv4.

   One way of viewing the translator, which might help clarify why
   applications do not need to know that a translator is used, is to
   look at the information that is passed from the transport layer to
   the network layer.  If the transport passes down an IPv4 address
   (whether or not is in the IPv4-mapped encoding) this means that at
   some point there will be IPv4 packets generated.  In a dual node the
   generation of the IPv4 packets takes place in the sending node.  In
   an IPv6-only node conceptually the only difference is that the IPv4
   packet is generated by the translator - all the information that the
   transport layer passed to the network layer will be conveyed to the
   translator in some form.  That form just "happens" to be in the form
   of an IPv6 header.






Li, et al.               Expires April 29, 2009                [Page 11]

Internet-Draft            IPv4/IPv6 Translation             October 2008


2.  Terminology

   This documents uses the terminology defined in [RFC2460] and
   [RFC4213] with these clarifications:

   IPv4 capable node:  A node which has an IPv4 protocol stack.  In
      order for the stack to be usable the node must be assigned one or
      more IPv4 addresses.

   IPv4 enabled node:  A node which has an IPv4 protocol stack and is
      assigned one or more IPv4 addresses.  Both IPv4-only and IPv6/IPv4
      nodes are IPv4 enabled.

   IPv6 capable node:  A node which has an IPv6 protocol stack.  In
      order for the stack to be usable the node must be assigned one or
      more IPv6 addresses.

   IPv6 enabled node:  A node which has an IPv6 protocol stack and is
      assigned one or more IPv6 addresses.  Both IPv6-only and IPv6/IPv4
      nodes are IPv6 enabled.


3.  Requirements

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in [RFC2119].


4.  Translating from IPv4 to IPv6

   When an IPv4-to-IPv6 translator receives an IPv4 datagram addressed
   to a destination that lies outside of the attached IPv4 island, it
   translates the IPv4 header of that packet into an IPv6 header.  It
   then forwards the packet based on the IPv6 destination address.  The
   original IPv4 header on the packet is removed and replaced by an IPv6
   header.  Except for ICMP packets the transport layer header and data
   portion of the packet are left unchanged.













Li, et al.               Expires April 29, 2009                [Page 12]

Internet-Draft            IPv4/IPv6 Translation             October 2008


              +-------------+                 +-------------+
              |    IPv4     |                 |    IPv6     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |  Transport  |                 |  Fragment   |
              |   Layer     |      ===>       |   Header    |
              |   Header    |                 |(not always) |
              +-------------+                 +-------------+
              |             |                 |  Transport  |
              ~    Data     ~                 |   Layer     |
              |             |                 |   Header    |
              +-------------+                 +-------------+
                                              |             |
                                              ~    Data     ~
                                              |             |
                                              +-------------+


                    Figure 3: IPv4-to-IPv6 Translation

   One of the differences between IPv4 and IPv6 is that in IPv6 path MTU
   discovery is mandatory but it is optional in IPv4.  This implies that
   IPv6 routers will never fragment a packet - only the sender can do
   fragmentation.

   When the IPv4 node performs path MTU discovery (by setting the DF bit
   in the header) the path MTU discovery can operate end-to-end i.e.
   across the translator.  In this case either IPv4 or IPv6 routers
   might send back ICMP "packet too big" messages to the sender.  When
   these ICMP errors are sent by the IPv6 routers they will pass through
   a translator which will translate the ICMP error to a form that the
   IPv4 sender can understand.  In this case an IPv6 fragment header is
   only included if the IPv4 packet is already fragmented.

   However, when the IPv4 sender does not perform path MTU discovery the
   translator has to ensure that the packet does not exceed the path MTU
   on the IPv6 side.  This is done by fragmenting the IPv4 packet so
   that it fits in 1280 byte IPv6 packet since IPv6 guarantees that 1280
   byte packets never need to be fragmented.  Also, when the IPv4 sender
   does not perform path MTU discovery the translator MUST always
   include an IPv6 fragment header to indicate that the sender allows
   fragmentation.  That is needed should the packet pass through an
   IPv6-to-IPv4 translator.

   The above rules ensure that when packets are fragmented either by the
   sender or by IPv4 routers that the low-order 16 bits of the fragment
   identification is carried end-end to ensure that packets are
   correctly reassembled.  In addition, the rules use the presence of an



Li, et al.               Expires April 29, 2009                [Page 13]

Internet-Draft            IPv4/IPv6 Translation             October 2008


   IPv6 fragment header to indicate that the sender might not be using
   path MTU discovery i.e. the packet should not have the DF flag set
   should it later be translated back to IPv4.

   Other than the special rules for handling fragments and path MTU
   discovery the actual translation of the packet header consists of a
   simple mapping as defined below.  Note that ICMP packets require
   special handling in order to translate the content of ICMP error
   message and also to add the ICMP pseudo-header checksum.

4.1.  Translating IPv4 Headers into IPv6 Headers

   If the DF flag is not set and the IPv4 packet will result in an IPv6
   packet larger than 1280 bytes the IPv4 packet MUST be fragmented
   prior to translating it.  Since IPv4 packets with DF not set will
   always result in a fragment header being added to the packet the IPv4
   packets must be fragmented so that their length, excluding the IPv4
   header, is at most 1232 bytes (1280 minus 40 for the IPv6 header and
   8 for the Fragment header).  The resulting fragments are then
   translated independently using the logic described below.

   If the DF bit is set and the packet is not a fragment (i.e., the MF
   flag is not set and the Fragment Offset is zero) then there is no
   need to add a fragment header to the packet.  The IPv6 header fields
   are set as follows:

   Version:  6

   Traffic Class:  By default, copied from IP Type Of Service and
      Precedence field (all 8 bits are copied).  According to [RFC2474]
      the semantics of the bits are identical in IPv4 and IPv6.
      However, in some IPv4 environments these fields might be used with
      the old semantics of "Type Of Service and Precedence".  An
      implementation of a translator SHOULD provide the ability to
      ignore the IPv4 "TOS" and always set the IPv6 traffic class to
      zero.

   Flow Label:  0 (all zero bits)

   Payload Length:  Total length value from IPv4 header, minus the size
      of the IPv4 header and IPv4 options, if present.

   Next Header:  Protocol field copied from IPv4 header

   Hop Limit:  TTL value copied from IPv4 header.  Since the translator
      is a router, as part of forwarding the packet it needs to
      decrement either the IPv4 TTL (before the translation) or the IPv6
      Hop Limit (after the translation).  As part of decrementing the



Li, et al.               Expires April 29, 2009                [Page 14]

Internet-Draft            IPv4/IPv6 Translation             October 2008


      TTL or Hop Limit the translator (as any router) needs to check for
      zero and send the ICMPv4 or ICMPv6 "ttl exceeded" error.

   Source Address:  The the address is derived from the IPv4 address as
      specified in [FRAMEWORK].

   Destination Address:  In stateless mode, which is to say that if the
      IPv4 destination address is within the range of the stateless
      translation prefix described in Section 1.3, the address is
      derived from the IPv4 address as specified in [FRAMEWORK].

      In stateful mode, which is to say that if the IPv4 destination
      address is among the statefully-translated addresses, the IPv6
      address and transport layer destination port corresponding to the
      IPv4 destination address and source port are derived from the
      database reflecting current session state in the translator.

   If IPv4 options are present in the IPv4 packet, they are ignored
   i.e., there is no attempt to translate them.  However, if an
   unexpired source route option is present then the packet MUST instead
   be discarded, and an ICMPv4 "destination unreachable/source route
   failed" (Type 3/Code 5) error message SHOULD be returned to the
   sender.

   If there is need to add a fragment header (the DF bit is not set or
   the packet is a fragment) the header fields are set as above with the
   following exceptions:

   IPv6 fields:

      Payload Length:  Total length value from IPv4 header, plus 8 for
         the fragment header, minus the size of the IPv4 header and IPv4
         options, if present.

      Next Header:  Fragment Header (44).

   Fragment header fields:

      Next Header:  Protocol field copied from IPv4 header.

      Fragment Offset:  Fragment Offset copied from the IPv4 header.

      M flag  More Fragments bit copied from the IPv4 header.

      Identification  The low-order 16 bits copied from the
         Identification field in the IPv4 header.  The high-order 16
         bits set to zero.




Li, et al.               Expires April 29, 2009                [Page 15]

Internet-Draft            IPv4/IPv6 Translation             October 2008


4.2.  Translating UDP over IPv4

   If a UDP packet has a zero UDP checksum then a valid checksum must be
   calculated in order to translate the packet.  A stateless translator
   can not do this for fragmented packets but [MILLER] indicates that
   fragmented UDP packets with a zero checksum appear to only be used
   for malicious purposes.  Thus this is not believed to be a noticeable
   limitation.

   When a translator receives the first fragment of a fragmented UDP
   IPv4 packet and the checksum field is zero the translator SHOULD drop
   the packet and generate a system management event specifying at least
   the IP addresses and port numbers in the packet.  When it receives
   fragments other than the first it SHOULD silently drop the packet,
   since there is no port information to log.

   When a translator receives an unfragmented UDP IPv4 packet and the
   checksum field is zero the translator MUST compute the missing UDP
   checksum as part of translating the packet.  Also, the translator
   SHOULD maintain a counter of how many UDP checksums are generated in
   this manner.

4.3.  Translating ICMPv4 Headers into ICMPv6 Headers

   All ICMP messages that are to be translated require that the ICMP
   checksum field be updated as part of the translation since ICMPv6
   unlike ICMPv4 has a pseudo-header checksum just like UDP and TCP.

   In addition all ICMP packets need to have the Type value translated
   and for ICMP error messages the included IP header also needs
   translation.

   The actions needed to translate various ICMPv4 messages are:

   ICMPv4 query messages:

      Echo and Echo Reply (Type 8 and Type 0)  Adjust the type to 128
         and 129, respectively, and adjust the ICMP checksum both to
         take the type change into account and to include the ICMPv6
         pseudo-header.

      Information Request/Reply (Type 15 and Type 16)  Obsoleted in
         ICMPv4 Silently drop.

      Timestamp and Timestamp Reply (Type 13 and Type 14)  Obsoleted in
         ICMPv6 Silently drop.





Li, et al.               Expires April 29, 2009                [Page 16]

Internet-Draft            IPv4/IPv6 Translation             October 2008


      Address Mask Request/Reply (Type 17 and Type 18)  Obsoleted in
         ICMPv6 Silently drop.

      ICMP Router Advertisement (Type 9)  Single hop message.  Silently
         drop.

      ICMP Router Solicitation (Type 10)  Single hop message.  Silently
         drop.

      Unknown ICMPv4 types  Silently drop.

      IGMP messages:  While the MLD messages [RFC2710][RFC3590][RFC3810]
         are the logical IPv6 counterparts for the IPv4 IGMP messages
         all the "normal" IGMP messages are single-hop messages and
         should be silently dropped by the translator.  Other IGMP
         messages might be used by multicast routing protocols and,
         since it would be a configuration error to try to have router
         adjacencies across IPv4/IPv6 translators those packets should
         also be silently dropped.

       ICMPv4 error messages:

         Destination Unreachable (Type 3)  For all that are not
            explicitly listed below set the Type to 1.

            Translate the code field as follows:

            Code 0, 1 (net, host unreachable):  Set Code to 0 (no route
               to destination).

            Code 2 (protocol unreachable):  Translate to an ICMPv6
               Parameter Problem (Type 4, Code 1) and make the Pointer
               point to the IPv6 Next Header field.

            Code 3 (port unreachable):  Set Code to 4 (port
               unreachable).

            Code 4 (fragmentation needed and DF set):  Translate to an
               ICMPv6 Packet Too Big message (Type 2) with code 0.  The
               MTU field needs to be adjusted for the difference between
               the IPv4 and IPv6 header sizes.  Note that if the IPv4
               router did not set the MTU field i.e. the router does not
               implement [RFC1191], then the translator must use the
               plateau values specified in [RFC1191] to determine a
               likely path MTU and include that path MTU in the ICMPv6
               packet.  (Use the greatest plateau value that is less
               than the returned Total Length field.)




Li, et al.               Expires April 29, 2009                [Page 17]

Internet-Draft            IPv4/IPv6 Translation             October 2008


            Code 5 (source route failed):  Set Code to 0 (no route to
               destination).  Note that this error is unlikely since
               source routes are not translated.

            Code 6,7:  Set Code to 0 (no route to destination).

            Code 8:  Set Code to 0 (no route to destination).

            Code 9, 10 (communication with destination host
            administratively prohibited):  Set Code to 1 (communication
               with destination administratively prohibited)

            Code 11, 12:  Set Code to 0 (no route to destination).

         Redirect (Type 5)  Single hop message.  Silently drop.

         Source Quench (Type 4)  Obsoleted in ICMPv6 Silently drop.

         Time Exceeded (Type 11)  Set the Type field to 3.  The Code
            field is unchanged.

         Parameter Problem (Type 12)  Set the Type field to 4.  The
            Pointer needs to be updated to point to the corresponding
            field in the translated include IP header.

4.4.  Translating ICMPv4 Error Messages into ICMPv6

   There are some differences between the IPv4 and the IPv6 ICMP error
   message formats as detailed above.  In addition, the ICMP error
   messages contain the IP header for the packet in error which needs to
   be translated just like a normal IP header.  The translation of this
   "packet in error" is likely to change the length of the datagram thus
   the Payload Length field in the outer IPv6 header might need to be
   updated.

















Li, et al.               Expires April 29, 2009                [Page 18]

Internet-Draft            IPv4/IPv6 Translation             October 2008


              +-------------+                 +-------------+
              |    IPv4     |                 |    IPv6     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |   ICMPv4    |                 |   ICMPv6    |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |    IPv4     |      ===>       |    IPv6     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |   Partial   |                 |   Partial   |
              |  Transport  |                 |  Transport  |
              |   Layer     |                 |   Layer     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+


               Figure 4: IPv4-to-IPv6 ICMP Error Translation

   The translation of the inner IP header can be done by recursively
   invoking the function that translated the outer IP headers.

4.5.  Knowing when to Translate

   The translator is assumed to know the pool(s) of IPv4 address that
   are used to represent the internal IPv6-only nodes.  If the
   translator is implemented in a router providing both translation and
   normal forwarding, and the address is reachable by a more specific
   route without translation, the router should forward it without
   translating it.  In general, however, if the IPv4 destination field
   contains an address that falls in these configured sets of prefixes
   the packet needs to be translated to IPv6.


5.  Translating from IPv6 to IPv4

   When an IPv6-to-IPv4 translator receives an IPv6 datagram addressed
   to an IPv4-mapped IPv6 address, it translates the IPv6 header of that
   packet into an IPv4 header.  It then forwards the packet based on the
   IPv4 destination address.  The original IPv6 header on the packet is
   removed and replaced by an IPv4 header.  Except for ICMP packets the
   transport layer header and data portion of the packet are left
   unchanged.








Li, et al.               Expires April 29, 2009                [Page 19]

Internet-Draft            IPv4/IPv6 Translation             October 2008


              +-------------+                 +-------------+
              |    IPv6     |                 |    IPv4     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |  Fragment   |                 |  Transport  |
              |   Header    |      ===>       |   Layer     |
              |(if present) |                 |   Header    |
              +-------------+                 +-------------+
              |  Transport  |                 |             |
              |   Layer     |                 ~    Data     ~
              |   Header    |                 |             |
              +-------------+                 +-------------+
              |             |
              ~    Data     ~
              |             |
              +-------------+


                    Figure 5: IPv6-to-IPv4 Translation

   There are some differences between IPv6 and IPv4 in the area of
   fragmentation and the minimum link MTU that effect the translation.
   An IPv6 link has to have an MTU of 1280 bytes or greater.  The
   corresponding limit for IPv4 is 68 bytes.  Thus, unless there were
   special measures, it would not be possible to do end-to-end path MTU
   discovery when the path includes an IPv6-to-IPv4 translator since the
   IPv6 node might receive ICMP "packet too big" messages originated by
   an IPv4 router that report an MTU less than 1280.  However, [RFC2460]
   requires that IPv6 nodes handle such an ICMP "packet too big" message
   by reducing the path MTU to 1280 and including an IPv6 fragment
   header with each packet.  This allows end-to-end path MTU discovery
   across the translator as long as the path MTU is 1280 bytes or
   greater.  When the path MTU drops below the 1280 limit the IPv6
   sender will originate 1280 byte packets that will be fragmented by
   IPv4 routers along the path after being translated to IPv4.

   The only drawback with this scheme is that it is not possible to use
   PMTU to do optimal UDP fragmentation (as opposed to completely
   avoiding fragmentation) at sender since the presence of an IPv6
   Fragment header is interpreted that is it OK to fragment the packet
   on the IPv4 side.  Thus if a UDP application wants to send large
   packets independent of the PMTU, the sender will only be able to
   determine the path MTU on the IPv6 side of the translator.  If the
   path MTU on the IPv4 side of the translator is smaller then the IPv6
   sender will not receive any ICMP "too big" errors and can not adjust
   the size fragments it is sending.

   Other than the special rules for handling fragments and path MTU



Li, et al.               Expires April 29, 2009                [Page 20]

Internet-Draft            IPv4/IPv6 Translation             October 2008


   discovery the actual translation of the packet header consists of a
   simple mapping as defined below.  Note that ICMP packets require
   special handling in order to translate the content of ICMP error
   message and also to add the ICMP pseudo-header checksum.

5.1.  Translating IPv6 Headers into IPv4 Headers

   If there is no IPv6 Fragment header the IPv4 header fields are set as
   follows:

   Version:  4

   Internet Header Length:  5 (no IPv4 options)

   Type of Service (TOS) Octet:  By default, copied from the IPv6
      Traffic Class (all 8 bits).  According to [RFC2474] the semantics
      of the bits are identical in IPv4 and IPv6.  However, in some IPv4
      environments these bits might be used with the old semantics of
      "Type Of Service and Precedence".  An implementation of a
      translator SHOULD provide the ability to ignore the IPv6 traffic
      class and always set the IPv4 TOS Octet to a specified value.

   Total Length:  Payload length value from IPv6 header, plus the size
      of the IPv4 header.

   Identification:  All zero.

   Flags:  The More Fragments flag is set to zero.  The Don't Fragments
      flag is set to one.

   Fragment Offset:  All zero.

   Time to Live:  Hop Limit value copied from IPv6 header.  Since the
      translator is a router, as part of forwarding the packet it needs
      to decrement either the IPv6 Hop Limit (before the translation) or
      the IPv4 TTL (after the translation).  As part of decrementing the
      TTL or Hop Limit the translator (as any router) needs to check for
      zero and send the ICMPv4 or ICMPv6 "ttl exceeded" error.

   Protocol:  Next Header field copied from IPv6 header.

   Header Checksum:  Computed once the IPv4 header has been created.

   Source Address:  In stateless mode, which is to say that if the IPv6
      source address is within the range of the stateless translation
      prefix described in Section 1.3, the address format is derived
      from the IPv4 address as specified in [FRAMEWORK].




Li, et al.               Expires April 29, 2009                [Page 21]

Internet-Draft            IPv4/IPv6 Translation             October 2008


      In stateful mode, which is to say that if the IPv6 source address
      is not of the form described in [FRAMEWORK], the IPv4 source
      address and transport layer source port corresponding to the IPv6
      source address and source port are derived from the database
      reflecting current session state in the translator as described in
      [I-D.bagnulo-behave-nat64].

   Destination Address:  IPv6 packets that are translated have an IPv4-
      mapped destination address.  Thus the address is derived from the
      IPv6 address as specified in [FRAMEWORK].

   If any of an IPv6 hop-by-hop options header, destination options
   header, or routing header with the Segments Left field equal to zero
   are present in the IPv6 packet, they are ignored i.e., there is no
   attempt to translate them.  However, the Total Length field and the
   Protocol field would have to be adjusted to "skip" these extension
   headers.

   If a routing header with a non-zero Segments Left field is present
   then the packet MUST NOT be translated, and an ICMPv6 "parameter
   problem/ erroneous header field encountered" (Type 4/Code 0) error
   message, with the Pointer field indicating the first byte of the
   Segments Left field, SHOULD be returned to the sender.

   If the IPv6 packet contains a Fragment header the header fields are
   set as above with the following exceptions:

   Total Length:  Payload length value from IPv6 header, minus 8 for the
      Fragment header, plus the size of the IPv4 header.

   Identification:  Copied from the low-order 16-bits in the
      Identification field in the Fragment header.

   Flags:  The More Fragments flag is copied from the M flag in the
      Fragment header.  The Don't Fragments flag is set to zero allowing
      this packet to be fragmented by IPv4 routers.

   Fragment Offset:  Copied from the Fragment Offset field in the
      Fragment Header.

   Protocol:  Next Header value copied from Fragment header.

5.2.  Translating ICMPv6 Headers into ICMPv4 Headers

   All ICMP messages that are to be translated require that the ICMP
   checksum field be updated as part of the translation since ICMPv6
   unlike ICMPv4 has a pseudo-header checksum just like UDP and TCP.




Li, et al.               Expires April 29, 2009                [Page 22]

Internet-Draft            IPv4/IPv6 Translation             October 2008


   In addition all ICMP packets need to have the Type value translated
   and for ICMP error messages the included IP header also needs
   translation.

   The actions needed to translate various ICMPv6 messages are:

   ICMPv6 informational messages:

      Echo Request and Echo Reply (Type 128 and 129)  Adjust the type to
         0 and 8, respectively, and adjust the ICMP checksum both to
         take the type change into account and to exclude the ICMPv6
         pseudo-header.

      MLD Multicast Listener Query/Report/Done (Type 130, 131, 132)
         Single hop message.  Silently drop.

      Neighbor Discover messages (Type 133 through 137)  Single hop
         message.  Silently drop.

      Unknown informational messages  Silently drop.

   ICMPv6 error messages:

      Destination Unreachable (Type 1)  Set the Type field to 3.
         Translate the code field as follows:

         Code 0 (no route to destination):  Set Code to 1 (host
            unreachable).

         Code 1 (communication with destination administratively
         prohibited):  Set Code to 10 (communication with destination
            host administratively prohibited).

         Code 2 (beyond scope of source address):  Set Code to 1 (host
            unreachable).  Note that this error is very unlikely since
            the IPv4-translatable source address is considered to have
            global scope.

         Code 3 (address unreachable):  Set Code to 1 (host
            unreachable).

         Code 4 (port unreachable):  Set Code to 3 (port unreachable).

      Packet Too Big (Type 2)  Translate to an ICMPv4 Destination
         Unreachable with code 4.  The MTU field needs to be adjusted
         for the difference between the IPv4 and IPv6 header sizes
         taking into account whether or not the packet in error includes
         a Fragment header.



Li, et al.               Expires April 29, 2009                [Page 23]

Internet-Draft            IPv4/IPv6 Translation             October 2008


      Time Exceeded (Type 3)  Set the Type to 11.  The Code field is
         unchanged.

      Parameter Problem (Type 4)  If the Code is 1 translate this to an
         ICMPv4 protocol unreachable (Type 3, Code 2).  Otherwise set
         the Type to 12 and the Code to zero.  The Pointer needs to be
         updated to point to the corresponding field in the translated
         include IP header.

      Unknown error messages  Silently drop.

5.3.  Translating ICMPv6 Error Messages into ICMPv4

   There are some differences between the IPv4 and the IPv6 ICMP error
   message formats as detailed above.  In addition, the ICMP error
   messages contain the IP header for the packet in error which needs to
   be translated just like a normal IP header.  The translation of this
   "packet in error" is likely to change the length of the datagram thus
   the Total Length field in the outer IPv4 header might need to be
   updated.


              +-------------+                 +-------------+
              |    IPv6     |                 |    IPv4     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |   ICMPv6    |                 |   ICMPv4    |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |    IPv6     |      ===>       |    IPv4     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |   Partial   |                 |   Partial   |
              |  Transport  |                 |  Transport  |
              |   Layer     |                 |   Layer     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+


               Figure 6: IPv6-to-IPv4 ICMP Error Translation

   The translation of the inner IP header can be done by recursively
   invoking the function that translated the outer IP headers.

5.4.  Knowing when to Translate

   If the translator is implemented in a router providing both
   translation and normal forwarding, and the address is reachable by a



Li, et al.               Expires April 29, 2009                [Page 24]

Internet-Draft            IPv4/IPv6 Translation             October 2008


   more specific route without translation, the router should forward it
   without translating it.  Otherwise, when the translator receives an
   IPv6 packet with an IPv4-mapped destination address the packet will
   be translated to IPv4.


6.  Implications for IPv6-Only Nodes

   An IPv6-only node which works through an IPv4/IPv6 translator needs
   some modifications beyond a normal IPv6-only node.

   As specified in Section 1.4 the application protocols need to handle
   operation on a dual stack node.  In addition the protocol stack needs
   to be able to:

   o  Determine when an IPv4-translatable address needs to be allocated
      and the allocation needs to be refreshed/renewed.  This can
      presumably be done without involving the applications by e.g.
      handling this under the socket API.  For instance, when the
      connect or sendto socket calls are invoked they could check if the
      destination is an IPv4-mapped address and in that case allocate/
      refresh the IPv4-translatable address.

   o  Ensure, as part of the source address selection mechanism, that
      when the destination address is an IPv4-mapped address the source
      address MUST be an IPv4-translatable address.  And an IPv4-
      translatable address MUST NOT be used with other forms of IPv6
      destination addresses.

   o  Should the peer have AAAA/A6 address records the application (or
      resolver) SHOULD never fall back to looking for A address records
      even if communication fails using the available AAAA/A6 records.
      The reason for this restriction is to prevent traffic between two
      IPv6 nodes (which AAAA/A6 records in the DNS) from accidentally
      going through IPv4/IPv6 translation twice; from IPv6 to IPv4 and
      to IPv6 again.  It is considered preferable to instead signal a
      failure to communicate to the application.  The only case in which
      IPv6/IPv4/IPv6 translation makes sense is when no other route
      exists.


7.  IANA Considerations

   This memo adds no new IANA considerations.

   Note to RFC Editor: This section will have served its purpose if it
   correctly tells IANA that no new assignments or registries are
   required, or if those assignments or registries are created during



Li, et al.               Expires April 29, 2009                [Page 25]

Internet-Draft            IPv4/IPv6 Translation             October 2008


   the RFC publication process.  From the author's perspective, it may
   therefore be removed upon publication as an RFC at the RFC Editor's
   discretion.


8.  Security Considerations

   The use of stateless IP/ICMP translators does not introduce any new
   security issues beyond the security issues that are already present
   in the IPv4 and IPv6 protocols and in the routing protocols which are
   used to make the packets reach the translator.

   As the Authentication Header [RFC4302] is specified to include the
   IPv4 Identification field and the translating function not being able
   to always preserve the Identification field, it is not possible for
   an IPv6 endpoint to compute AH on received packets that have been
   translated from IPv4 packets.  Thus AH does not work through a
   translator.

   Packets with ESP can be translated since ESP does not depend on
   header fields prior to the ESP header.  Note that ESP transport mode
   is easier to handle than ESP tunnel mode; in order to use ESP tunnel
   mode the IPv6 node needs to be able to generate an inner IPv4 header
   when transmitting packets and remove such an IPv4 header when
   receiving packets.


9.  Acknowledgements

   This is under development by a large group of people.  Those who have
   posted to the list during the discussion include Andrew Sullivan,
   Andrew Yourtchenko, Brian Carpenter, Dan Wing, Ed Jankiewicz, Fred
   Baker, Hiroshi Miyata, Iljitsch van Beijnum, John Schnizlein, Kevin
   Yin, Magnus Westerlund, Marcelo Bagnulo Braun, Margaret Wasserman,
   Masahito Endo, Phil Roberts, Philip Matthews, Remi Denis-Courmont,
   Remi Despres, and Xing Li.


10.  References

10.1.  Normative References

   [FRAMEWORK]
              Baker, F., "Framework for IPv4/IPv6 Translation - baker-
              behave-v4v6-framework", October 2008.

   [I-D.bagnulo-behave-nat64]
              Bagnulo, M., Matthews, P., and I. Beijnum, "NAT64/DNS64:



Li, et al.               Expires April 29, 2009                [Page 26]

Internet-Draft            IPv4/IPv6 Translation             October 2008


              Network Address and Protocol Translation from IPv6 Clients
              to  IPv4 Servers", draft-bagnulo-behave-nat64-01 (work in
              progress), September 2008.

   [RFC0791]  Postel, J., "Internet Protocol", STD 5, RFC 791,
              September 1981.

   [RFC0792]  Postel, J., "Internet Control Message Protocol", STD 5,
              RFC 792, September 1981.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 2460, December 1998.

   [RFC2765]  Nordmark, E., "Stateless IP/ICMP Translation Algorithm
              (SIIT)", RFC 2765, February 2000.

   [RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, February 2006.

   [RFC4443]  Conta, A., Deering, S., and M. Gupta, "Internet Control
              Message Protocol (ICMPv6) for the Internet Protocol
              Version 6 (IPv6) Specification", RFC 4443, March 2006.

   [RFC5382]  Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P.
              Srisuresh, "NAT Behavioral Requirements for TCP", BCP 142,
              RFC 5382, October 2008.

10.2.  Informative References

   [I-D.petithuguenin-behave-stun-pmtud]
              Petit-Huguenin, M., "Path MTU Discovery Using Session
              Traversal Utilities for NAT (STUN)",
              draft-petithuguenin-behave-stun-pmtud-01 (work in
              progress), July 2008.

   [Miller]   Miller, G., "Email to the ngtrans mailing list",
              March 1999.

   [RFC1112]  Deering, S., "Host extensions for IP multicasting", STD 5,
              RFC 1112, August 1989.

   [RFC1191]  Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,
              November 1990.

   [RFC1981]  McCann, J., Deering, S., and J. Mogul, "Path MTU Discovery



Li, et al.               Expires April 29, 2009                [Page 27]

Internet-Draft            IPv4/IPv6 Translation             October 2008


              for IP version 6", RFC 1981, August 1996.

   [RFC2428]  Allman, M., Ostermann, S., and C. Metz, "FTP Extensions
              for IPv6 and NATs", RFC 2428, September 1998.

   [RFC2474]  Nichols, K., Blake, S., Baker, F., and D. Black,
              "Definition of the Differentiated Services Field (DS
              Field) in the IPv4 and IPv6 Headers", RFC 2474,
              December 1998.

   [RFC2710]  Deering, S., Fenner, W., and B. Haberman, "Multicast
              Listener Discovery (MLD) for IPv6", RFC 2710,
              October 1999.

   [RFC3493]  Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.
              Stevens, "Basic Socket Interface Extensions for IPv6",
              RFC 3493, February 2003.

   [RFC3590]  Haberman, B., "Source Address Selection for the Multicast
              Listener Discovery (MLD) Protocol", RFC 3590,
              September 2003.

   [RFC3810]  Vida, R. and L. Costa, "Multicast Listener Discovery
              Version 2 (MLDv2) for IPv6", RFC 3810, June 2004.

   [RFC4213]  Nordmark, E. and R. Gilligan, "Basic Transition Mechanisms
              for IPv6 Hosts and Routers", RFC 4213, October 2005.

   [RFC4301]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, December 2005.

   [RFC4302]  Kent, S., "IP Authentication Header", RFC 4302,
              December 2005.

   [RFC4303]  Kent, S., "IP Encapsulating Security Payload (ESP)",
              RFC 4303, December 2005.

   [RFC4821]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", RFC 4821, March 2007.

   [RFC4861]  Narten, T., Nordmark, E., Simpson, W., and H. Soliman,
              "Neighbor Discovery for IP version 6 (IPv6)", RFC 4861,
              September 2007.








Li, et al.               Expires April 29, 2009                [Page 28]

Internet-Draft            IPv4/IPv6 Translation             October 2008


Authors' Addresses

   Xing Li (editor)
   CERNET Center/Tsinghua University
   Room 225, Main Building, Tsinghua University
   Beijing,   100084
   China

   Phone: +86 62785983
   Email: xing@cernet.edu.cn


   Congxiao Bao (editor)
   CERNET Center/Tsinghua University
   Room 225, Main Building, Tsinghua University
   Beijing,   100084
   China

   Phone: +86 62785983
   Email: congxiao@cernet.edu.cn


   Fred Baker (editor)
   Cisco Systems
   Santa Barbara, California  93117
   USA

   Phone: +1-408-526-4257
   Email: fred@cisco.com






















Li, et al.               Expires April 29, 2009                [Page 29]

Internet-Draft            IPv4/IPv6 Translation             October 2008


Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.











Li, et al.               Expires April 29, 2009                [Page 30]

