<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict='yes'?>
<?rfc iprnotified='no'?>
<rfc category="std" docName="draft-templin-intarea-seal-34.txt"
     ipr="trust200902">
  <front>
    <title abbrev="SEAL">The Subnetwork Encapsulation and Adaptation Layer
    (SEAL)</title>

    <author fullname="Fred L. Templin" initials="F. L." role="editor"
            surname="Templin">
      <organization>Boeing Research &amp; Technology</organization>

      <address>
        <postal>
          <street>P.O. Box 3707</street>

          <city>Seattle</city>

          <region>WA</region>

          <code>98124</code>

          <country>USA</country>
        </postal>

        <email>fltemplin@acm.org</email>
      </address>
    </author>

    <date day="24" month="October" year="2011" />

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <abstract>
      <t>For the purpose of this document, a subnetwork is defined as a
      virtual topology configured over a connected IP network routing region
      and bounded by encapsulating border nodes. These virtual topologies are
      manifested by tunnels that may span multiple IP and/or sub-IP layer
      forwarding hops, and can introduce failure modes due to packet
      duplication and/or links with diverse Maximum Transmission Units (MTUs).
      This document specifies a Subnetwork Encapsulation and Adaptation Layer
      (SEAL) that accommodates such virtual topologies over diverse underlying
      link technologies.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>As Internet technology and communication has grown and matured, many
      techniques have developed that use virtual topologies (including tunnels
      of one form or another) over an actual network that supports the
      Internet Protocol (IP) <xref target="RFC0791"></xref><xref
      target="RFC2460"></xref>. Those virtual topologies have elements that
      appear as one hop in the virtual topology, but are actually multiple IP
      or sub-IP layer hops. These multiple hops often have quite diverse
      properties that are often not even visible to the endpoints of the
      virtual hop. This introduces failure modes that are not dealt with well
      in current approaches.</t>

      <t>The use of IP encapsulation (also known as "tunneling") has long been
      considered as the means for creating such virtual topologies. However,
      the insertion of an outer IP header reduces the effective path MTU
      visible to the inner network layer. When IPv4 is used, this reduced MTU
      can be accommodated through the use of IPv4 fragmentation, but
      unmitigated in-the-network fragmentation has been found to be harmful
      through operational experience and studies conducted over the course of
      many years <xref target="FRAG"></xref><xref target="FOLK"></xref><xref
      target="RFC4963"></xref>. Additionally, classical path MTU discovery
      <xref target="RFC1191"></xref> has known operational issues that are
      exacerbated by in-the-network tunnels <xref
      target="RFC2923"></xref><xref target="RFC4459"></xref>. The following
      subsections present further details on the motivation and approach for
      addressing these issues.</t>

      <section title="Motivation">
        <t>Before discussing the approach, it is necessary to first understand
        the problems. In both the Internet and private-use networks today,
        IPv4 is ubiquitously deployed as the Layer 3 protocol. The two primary
        functions of IPv4 are to provide for 1) addressing, and 2) a
        fragmentation and reassembly capability used to accommodate links with
        diverse MTUs. While it is well known that the IPv4 address space is
        rapidly becoming depleted, there is a lesser-known but growing
        consensus that other IPv4 protocol limitations have already or may
        soon become problematic.</t>

        <t>First, the IPv4 header Identification field is only 16 bits in
        length, meaning that at most 2^16 unique packets with the same
        (source, destination, protocol)-tuple may be active in the Internet at
        a given time <xref target="I-D.ietf-intarea-ipv4-id-update"></xref>.
        Due to the escalating deployment of high-speed links, however, this
        number may soon become too small by several orders of magnitude for
        high data rate packet sources such as tunnel endpoints <xref
        target="RFC4963"></xref>. Furthermore, there are many well-known
        limitations pertaining to IPv4 fragmentation and reassembly &ndash;
        even to the point that it has been deemed &ldquo;harmful&rdquo; in
        both classic and modern-day studies (see above). In particular, IPv4
        fragmentation raises issues ranging from minor annoyances (e.g.,
        in-the-network router fragmentation <xref target="RFC1981"></xref>) to
        the potential for major integrity issues (e.g., mis-association of the
        fragments of multiple IP packets during reassembly <xref
        target="RFC4963"></xref>).</t>

        <t>As a result of these perceived limitations, a
        fragmentation-avoiding technique for discovering the MTU of the
        forward path from a source to a destination node was devised through
        the deliberations of the Path MTU Discovery Working Group (PMTUDWG)
        during the late 1980&rsquo;s through early 1990&rsquo;s (see Appendix
        D). In this method, the source node provides explicit instructions to
        routers in the path to discard the packet and return an ICMP error
        message if an MTU restriction is encountered. However, this approach
        has several serious shortcomings that lead to an overall
        &ldquo;brittleness&rdquo; <xref target="RFC2923"></xref>.</t>

        <t>In particular, site border routers in the Internet are being
        configured more and more to discard ICMP error messages coming from
        the outside world. This is due in large part to the fact that
        malicious spoofing of error messages in the Internet is trivial since
        there is no way to authenticate the source of the messages <xref
        target="RFC5927"></xref>. Furthermore, when a source node that
        requires ICMP error message feedback when a packet is dropped due to
        an MTU restriction does not receive the messages, a path MTU-related
        black hole occurs. This means that the source will continue to send
        packets that are too large and never receive an indication from the
        network that they are being discarded. This behavior has been
        confirmed through documented studies showing clear evidence of path
        MTU discovery failures in the Internet today <xref
        target="TBIT"></xref><xref target="WAND"></xref><xref
        target="SIGCOMM"></xref>.</t>

        <t>The issues with both IPv4 fragmentation and this
        &ldquo;classical&rdquo; method of path MTU discovery are exacerbated
        further when IP tunneling is used <xref target="RFC4459"></xref>. For
        example, an ingress tunnel endpoint (ITE) may be required to forward
        encapsulated packets into the subnetwork on behalf of hundreds,
        thousands, or even more original sources within the end site that it
        serves. If the ITE allows IPv4 fragmentation on the encapsulated
        packets, persistent fragmentation could lead to undetected data
        corruption due to Identification field wrapping. If the ITE instead
        uses classical IPv4 path MTU discovery, it may be inconvenienced by
        excessive ICMP error messages coming from the subnetwork that may be
        either suspect or contain insufficient information for translation
        into error messages to be returned to the original sources.</t>

        <t>Although recent works have led to the development of a robust
        end-to-end MTU determination scheme <xref target="RFC4821"></xref>,
        they do not excuse tunnels from delivering path MTU discovery feedback
        when packets are lost due to size restrictions. Moreover, in current
        practice existing tunneling protocols mask the MTU issues by selecting
        a "lowest common denominator" MTU that may be much smaller than
        necessary for most paths and difficult to change at a later date.
        Therefore, a new approach to accommodate tunnels over links with
        diverse MTUs is necessary.</t>
      </section>

      <section title="Approach">
        <t>For the purpose of this document, a subnetwork is defined as a
        virtual topology configured over a connected network routing region
        and bounded by encapsulating border nodes. Example connected network
        routing regions include Mobile Ad hoc Networks (MANETs), enterprise
        networks and the global public Internet itself. Subnetwork border
        nodes forward unicast and multicast packets over the virtual topology
        across multiple IP and/or sub-IP layer forwarding hops that may
        introduce packet duplication and/or traverse links with diverse
        Maximum Transmission Units (MTUs).</t>

        <t>This document introduces a Subnetwork Encapsulation and Adaptation
        Layer (SEAL) for tunneling network layer protocols (e.g., IP, OSI,
        etc.) over IP subnetworks that connect Ingress and Egress Tunnel
        Endpoints (ITEs/ETEs) of border nodes. It provides a modular
        specification designed to be tailored to specific associated tunneling
        protocols. A transport-mode of operation is also possible, and
        described in Appendix C.</t>

        <t>SEAL provides a minimal mid-layer encapsulation that accommodates
        links with diverse MTUs and allows routers in the subnetwork to
        perform efficient duplicate packet detection. The encapsulation
        further ensures packet header integrity, data origin authentication
        and anti-replay <xref target="I-D.ietf-savi-framework"></xref><xref
        target="RFC4302"></xref>.</t>

        <t>SEAL treats tunnels that traverse the subnetwork as ordinary links
        that must support network layer services. Moreover, SEAL provides
        dynamic mechanisms to ensure a maximal per-destination path MTU over
        the tunnel. This is in contrast to static approaches which avoid MTU
        issues by selecting a lowest common denominator MTU value that may be
        overly conservative for the vast majority of tunnel paths and
        difficult to change even when larger MTUs become available.</t>

        <t>The following sections provide the SEAL normative specifications,
        while the appendices present non-normative additional
        considerations.</t>
      </section>
    </section>

    <section title="Terminology and Requirements">
      <t>The following terms are defined within the scope of this
      document:</t>

      <t><list style="hanging">
          <t hangText="subnetwork"><vspace />a virtual topology configured
          over a connected network routing region and bounded by encapsulating
          border nodes.</t>

          <t hangText="Ingress Tunnel Endpoint"><vspace />a virtual interface
          over which an encapsulating border node (host or router) sends
          encapsulated packets into the subnetwork.</t>

          <t hangText="Egress Tunnel Endpoint"><vspace />a virtual interface
          over which an encapsulating border node (host or router) receives
          encapsulated packets from the subnetwork.</t>

          <t hangText="inner packet"><vspace />an unencapsulated network layer
          protocol packet (e.g., IPv6 <xref target="RFC2460"></xref>, IPv4
          <xref target="RFC0791"></xref>, OSI/CLNP <xref
          target="RFC1070"></xref>, etc.) before any outer encapsulations are
          added. Internet protocol numbers that identify inner packets are
          found in the IANA Internet Protocol registry <xref
          target="RFC3232"></xref>.</t>

          <t hangText="outer IP packet"><vspace />a packet resulting from
          adding an outer IP header (and possibly other outer headers) to a
          SEAL-encapsulated inner packet.</t>

          <t hangText="packet-in-error"><vspace />the leading portion of an
          invoking data packet encapsulated in the body of an error control
          message (e.g., an ICMPv4 <xref target="RFC0792"></xref> error
          message, an ICMPv6 <xref target="RFC4443"></xref> error message,
          etc.).</t>

          <t hangText="Packet Too Big (PTB)"><vspace />a control plane message
          indicating an MTU restriction (e.g., an ICMPv6 "Packet Too Big"
          message <xref target="RFC4443"></xref>, an ICMPv4 "Fragmentation
          Needed" message <xref target="RFC0792"></xref>, etc.).</t>

          <t hangText="IP"><vspace />used to generically refer to either IP
          protocol version, i.e., IPv4 or IPv6.</t>
        </list></t>

      <t>The following abbreviations correspond to terms used within this
      document and/or elsewhere in common Internetworking nomenclature:</t>

      <t><list>
          <t>DF - the IPv4 header "Don't Fragment" flag <xref
          target="RFC0791"></xref><vspace /></t>

          <t>ETE - Egress Tunnel Endpoint<vspace /></t>

          <t>HLEN - the length of the SEAL header plus outer headers and
          trailers<vspace /></t>

          <t>ITE - Ingress Tunnel Endpoint<vspace /></t>

          <t><vspace /></t>

          <t><vspace /></t>

          <t>MTU - Maximum Transmission Unit<vspace /></t>

          <t><vspace /></t>

          <t><vspace /></t>

          <t><vspace /></t>

          <t>SCMP - the SEAL Control Message Protocol<vspace /></t>

          <t>SDU - SCMP Destination Unreachable message<vspace /></t>

          <t>SPP - SCMP Parameter Problem message<vspace /></t>

          <t>SPTB - SCMP Packet Too Big message<vspace /></t>

          <t><vspace /></t>

          <t>SEAL - Subnetwork Encapsulation and Adaptation
          Layer<vspace /></t>

          <t>SEAL_PORT - a transport-layer service port number used for
          SEAL<vspace /></t>

          <t>SEAL_PROTO - an IPv4 protocol number used for SEAL<vspace /></t>

          <t>TE - Tunnel Endpoint (i.e., either ingress or egress)
          <vspace /></t>

          <t>VET - Virtual Enterprise Traversal<vspace /></t>
        </list></t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>. When used in lower case (e.g., must, must not,
      etc.), these words MUST NOT be interpreted as described in <xref
      target="RFC2119"></xref>, but are rather interpreted as they would be in
      common English.</t>
    </section>

    <section title="Applicability Statement">
      <t>SEAL was originally motivated by the specific case of subnetwork
      abstraction for Mobile Ad hoc Networks (MANETs), however it soon became
      apparent that the domain of applicability also extends to subnetwork
      abstractions over enterprise networks, ISP networks, SOHO networks, the
      global public Internet itself, and any other connected network routing
      region. SEAL along with the Virtual Enterprise Traversal (VET) <xref
      target="I-D.templin-intarea-vet"></xref> tunnel virtual interface
      abstraction are the functional building blocks for a new Internetworking
      architecture based on Routing and Addressing in Networks with Global
      Enterprise Recursion (RANGER) <xref target="RFC5720"></xref><xref
      target="RFC6139"></xref> and the Internet Routing Overlay Network (IRON)
      <xref target="I-D.templin-ironbis"></xref>.</t>

      <t>SEAL provides a network sublayer for encapsulation of an inner
      network layer packet within outer encapsulating headers. SEAL can also
      be used as a sublayer within a transport layer protocol data payload,
      where transport layer encapsulation is typically used for Network
      Address Translator (NAT) traversal as well as operation over subnetworks
      that give preferential treatment to certain "core" Internet protocols
      (e.g., TCP, UDP, etc.). The SEAL header is processed the same as for
      IPv6 extension headers, i.e., it is not part of the outer IP header but
      rather allows for the creation of an arbitrarily extensible chain of
      headers in the same way that IPv6 does.</t>

      <t>To accommodate MTU diversity, the Egress Tunnel Endpoint (ETE) acts
      as a passive observer that simply informs the Ingress Tunnel Endpoint
      (ITE) of any packet size limitations. This allows the ITE to return
      appropriate path MTU discovery feedback to the previous hop on the path
      toward the original source even if the network path between the ITE and
      ETE filters ICMP messages.</t>

      <t>SEAL further ensures packet header integrity, data origin
      authentication and anti-replay <xref
      target="I-D.ietf-savi-framework"></xref><xref
      target="RFC4301"></xref><xref target="RFC4302"></xref>. The SEAL
      encapsulation in many respects is simply a lightweight version of the IP
      Security (IPsec) Authentication Payload (AUTH), however its purpose is
      to provide minimal authenticating services along multiple hops of a
      bridged segment within a path while leaving data integrity services as
      an end-to-end consideration.</t>
    </section>

    <section title="SEAL Specification">
      <t>The following sections specify the operation of SEAL:</t>

      <section title="VET Interface Model">
        <t>SEAL is an encapsulation sublayer used within VET non-broadcast,
        multiple access (NBMA) tunnel virtual interfaces. Each VET interface
        connects an ITE to one or more ETE "neighbors" via tunneling across an
        underlying subnetwork. The tunnel neighbor relationship between the
        ITE and each ETE may be either unidirectional or bidirectional.</t>

        <t>A unidirectional tunnel neighbor relationship allows the near end
        ITE to send data packets forward to the far end ETE, while the ETE
        only returns control messages when necessary. A bidirectional tunnel
        neighbor relationship is one over which both TEs can exchange both
        data and control messages.</t>

        <t>Implications of the VET unidirectional and bidirectional models for
        SEAL are discussed in <xref
        target="I-D.templin-intarea-vet"></xref>.</t>
      </section>

      <section title="SEAL Model of Operation">
        <t>SEAL-enabled ITEs encapsulate each inner packet in a SEAL header
        and any outer encapsulations as shown in <xref
        target="encaps1"></xref>:</t>

        <t><figure anchor="encaps1" title="SEAL Encapsulation">
            <artwork><![CDATA[                             +--------------------+
                             ~   outer IP header  ~
                             +--------------------+
                             ~  other outer hdrs  ~
                             +--------------------+
                             ~    SEAL Header     ~
+--------------------+       +--------------------+
|                    |  -->  |                    |
~        Inner       ~  -->  ~        Inner       ~
~       Packet       ~  -->  ~       Packet       ~
|                    |  -->  |                    |
+--------------------+       +--------------------+
                             ~   outer trailers   ~
                             +--------------------+]]></artwork>
          </figure></t>

        <t>The ITE inserts the SEAL header according to the specific tunneling
        protocol. For simple encapsulation of an inner network layer packet
        within an outer IP header (e.g., <xref target="RFC1070"></xref><xref
        target="RFC2003"></xref><xref target="RFC2473"></xref><xref
        target="RFC4213"></xref>, etc.), the ITE inserts the SEAL header
        between the inner packet and outer IP headers as: IP/SEAL/{inner
        packet}.</t>

        <t>For encapsulations over transports such as UDP (e.g., in the same
        manner as for <xref target="RFC4380"></xref>), the ITE inserts the
        SEAL header between the outer transport layer header and the inner
        packet, e.g., as IP/UDP/SEAL/{inner packet}. (Here, the UDP header is
        seen as an "other outer header" as depicted in <xref
        target="encaps1"></xref>.)</t>

        <t>The following sections specify the SEAL header format and
        SEAL-related operations of the ITE and ETE.</t>
      </section>

      <section title="SEAL Header Format">
        <t>The SEAL header is formatted as follows:</t>

        <t><figure anchor="minimal" title="SEAL Header Format ">
            <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |VER|C|A|R| RSV |     NEXTHDR   |    PREFLEN    |    LINK_ID    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             PKT_ID                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Checksum                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure></t>

        <t>where the header fields are defined as:</t>

        <t><list style="hanging">
            <t hangText="VER (2)"><vspace />a 2-bit version field. This
            document specifies Version 0 of the SEAL protocol, i.e., the VER
            field encodes the value 0.</t>

            <t hangText="C (1)"><vspace />the "Control/Data" bit. Set to 1 by
            the ITE in SEAL Control Message Protocol (SCMP) control messages,
            and set to 0 in ordinary data packets.</t>

            <t hangText="A (1)"><vspace />the "Acknowledgement Requested" bit.
            Set to 1 by the ITE in SEAL data packets for which it wishes to
            receive an explicit acknowledgement from the ETE.</t>

            <t hangText="R (1)"><vspace />the "Redirect" bit. For data
            packets, set to 1 by the ITE to inform the ETE that the source is
            accepting redirects (see:<xref target="I-D.templin-intarea-vet">
            </xref>).</t>

            <t hangText="RSV (3)"><vspace />a 3-bit Reserved field. Must be
            set to 0 for this version of the SEAL specification.</t>

            <t hangText="NEXTHDR (8)">an 8-bit field that encodes the next
            header Internet Protocol number the same as for the IPv4 protocol
            and IPv6 next header fields.</t>

            <t hangText="PREFLEN (8)">an 8-bit field that encodes the length
            of the prefix to be applied to the source address of inner
            packets.</t>

            <t hangText="LINK_ID (8)"><vspace />an 8-bit link identification
            value, set to a unique value by the ITE for each underlying link
            over which it will send encapsulated packets to ETEs.</t>

            <t hangText="PKT_ID (32)"><vspace />a 32-bit per-packet
            identification field. Set to a monotonically-incrementing 32-bit
            value for each SEAL packet transmitted.</t>

            <t hangText="Checksum (32)"><vspace />a 32-bit Checksum that
            covers the first 128 bytes of the packet beginning with the SEAL
            header. The value128 is chosen so that at least the SEAL header as
            well as the inner packet network and transport layer headers are
            covered by the checksum.</t>
          </list>Setting of the various bits and fields of the SEAL header is
        specified in the following sections.</t>
      </section>

      <section title="ITE Specification">
        <section title="Tunnel Interface Soft State">
          <t>The ITE maintains a per-ETE checksum calculation algorithm and
          secret key to verify the Checksum in the SEAL header.</t>
        </section>

        <section title="Tunnel Interface MTU">
          <t>The tunnel interface must present a constant MTU value to the
          inner network layer as the size for admission of inner packets into
          the interface. Since VET NBMA tunnel virtual interfaces may support
          a large set of ETEs that accept widely varying maximum packet sizes,
          however, a number of factors should be taken into consideration when
          selecting a tunnel interface MTU.</t>

          <t>Due to the ubiquitous deployment of standard Ethernet and similar
          networking gear, the nominal Internet cell size has become 1500
          bytes; this is the de facto size that end systems have come to
          expect will either be delivered by the network without loss due to
          an MTU restriction on the path or a suitable ICMP Packet Too Big
          (PTB) message returned. When large packets sent by end systems incur
          additional encapsulation at an ITE, however, they may be dropped
          silently within the tunnel since the network may not always deliver
          the necessary PTBs <xref target="RFC2923"></xref>.</t>

          <t>The ITE should therefore set a tunnel interface MTU of at least
          1500 bytes plus extra room to accommodate any additional
          encapsulations that may occur on the path from the original source.
          The ITE can also set smaller MTU values; however, care must be taken
          not to set so small a value that original sources would experience
          an MTU underflow. In particular, IPv6 sources must see a minimum
          path MTU of 1280 bytes, and IPv4 sources should see a minimum path
          MTU of 576 bytes.</t>

          <t>The ITE can alternatively set an indefinite MTU on the tunnel
          interface such that all inner packets are admitted into the
          interface without regard to size. For ITEs that host applications
          that use the tunnel interface directly, this option must be
          carefully coordinated with protocol stack upper layers since some
          upper layer protocols (e.g., TCP) derive their packet sizing
          parameters from the MTU of the outgoing interface and as such may
          select too large an initial size. This is not a problem for upper
          layers that use conservative initial maximum segment size estimates
          and/or when the tunnel interface can reduce the upper layer's
          maximum segment size, e.g., by reducing the size advertised in the
          MSS option of outgoing TCP messages.</t>

          <t>The inner network layer protocol consults the tunnel interface
          MTU when admitting a packet into the interface. For non-SEAL inner
          IPv4 packets with the IPv4 Don't Fragment (DF) bit set to 0, if the
          packet is larger than the tunnel interface MTU the inner IPv4 layer
          uses IPv4 fragmentation to break the packet into fragments no larger
          than the tunnel interface MTU. The ITE then admits each fragment
          into the interface as an independent packet.</t>

          <t>For all other inner packets, the inner network layer admits the
          packet if it is no larger than the tunnel interface MTU; otherwise,
          it drops the packet and sends a PTB error message to the source with
          the MTU value set to the tunnel interface MTU. The message contains
          as much of the invoking packet as possible without the entire
          message exceeding the network layer minimum MTU (e.g., 576 bytes for
          IPv4, 1280 bytes for IPv6, etc.).</t>

          <t>In light of the above considerations, the ITE SHOULD configure an
          indefinite MTU on tunnel *router* interfaces. The ITE MAY instead
          set a finite MTU on tunnel *host* interfaces.</t>
        </section>

        <section title="Submitting Packets for Encapsulation">
          <t>The ITE maintains HLEN as the sum of the lengths of the SEAL
          header and any outer headers and trailers. The ITE must include the
          length of the uncompressed outer headers and trailers when
          calculating HLEN even if the tunnel is using header compression. The
          ITE then prepares each inner packet/fragment admitted into the
          tunnel interface for encapsulation according to its length.</t>

          <t>For IPv4 inner packets with DF=0 in the IPv4 header, the ITE
          fragments the packet into IPv4 fragments of a length that (when
          added to HLEN) is unlikely to incur additional fragmentation on the
          path to the ETE. (It is crucial that the ITE be conservative in it's
          selection of an inner fragment size, since the ETE will discard any
          packet that arrives as multiple IPv4 fragments after reassembly.)The
          ITE then submits each fragment for SEAL encapsulation as specified
          in Section 4.4.4.</t>

          <t>For all other inner packets, the ITE checks whether the length of
          the packet plus HLEN is larger than the MTU of the outgoing
          interface. If the packet is not too large, the ITE submits it for
          SEAL encapsulation as specified in Section 4.4.4. Otherwise, the ITE
          sends a PTB message toward the source address of the inner
          packet.</t>

          <t>To send the PTB message, the ITE first checks its forwarding
          tables to discover the previous hop toward the source address of the
          inner packet. If the previous hop is reached via the same tunnel
          interface, the ITE sends an SCMP PTB (SPTB) message to the previous
          hop (see: Section 4.6.1). Otherwise, the ITE sends a PTB message
          appropriate to the inner protocol version back to the source. (In
          both cases, the ITE sets the MTU field in the (S)PTB message to the
          MTU of the underlying interface minus HLEN.) The ITE then discards
          the packet.</t>
        </section>

        <section title="SEAL Encapsulation">
          <t>The ITE next encapsulates the inner packet in a SEAL header
          formatted as specified in Section 4.3. The ITE sets NEXTHDR to the
          Internet Protocol number corresponding to the encapsulated inner
          packet. For example, the ITE sets NEXTHDR to the value '4' for
          encapsulated IPv4 packets <xref target="RFC2003"></xref>, the value
          '41' for encapsulated IPv6 packets <xref
          target="RFC2473"></xref><xref target="RFC4213"></xref>, the value
          '80' for encapsulated OSI packets <xref target="RFC1070"></xref>,
          etc.</t>

          <t>The ITE then sets PREFLEN to the length of the prefix to be
          applied to the inner source address. The ITE's claimed PREFLEN is
          subject to verification by the ETE; hence, the ITE must not
          advertise a length that it is not authorized to use. Next, the ITE
          sets R=1 if redirects are permitted (see: <xref
          target="I-D.templin-intarea-vet"></xref>). (Note that if this
          process is entered via re-encapsulation (see: Section 4.5.4),
          PREFLEN and R are instead copied from the SEAL header of the
          re-encapsulated packet. This implies that the PREFLEN and R values
          are propagated across a chain of ITE/ETEs that must all be
          authorized to represent the prefix.)</t>

          <t>The ITE next sets C=0 and sets A=1 if an explicit acknowledgement
          is required from the ETE (see: Section 4.4.6). The ITE then sets
          LINK_ID to the value assigned to the underlying link and sets PKT_ID
          to a monotonically-increasing integer value, beginning with the vale
          0 in the first packet transmitted..</t>

          <t>The ITE finally sets the Checksum field to 0, calculates the
          Checksum over the first 128 bytes of the packet beginning with the
          SEAL header and leading portion of the inner packet, then writes the
          value in the Checksum field. (If there are fewer than 128 bytes, the
          Checksum is calculated up to the end of the inner packet.) The
          Checksum is calculated using an algorithm agreed on by the ITE and
          ETE. The algorithm uses a shared secret key so that the ETE can
          verify that the Checksum was generated by the ITE.</t>
        </section>

        <section title="Outer Encapsulation">
          <t>Following SEAL encapsulation, the ITE next encapsulates the
          packet in the requisite outer headers and trailers according to the
          specific encapsulation format (e.g., <xref target="RFC1070"></xref>,
          <xref target="RFC2003"></xref>, <xref target="RFC2473"></xref>,
          <xref target="RFC4213"></xref>, etc.), except that it writes
          'SEAL_PROTO' in the protocol field of the outer IP header (when
          simple IP encapsulation is used) or writes 'SEAL_PORT' in the outer
          destination transport service port field (e.g., when IP/UDP
          encapsulation is used).</t>

          <t>When UDP encapsulation is used, the ITE sets the UDP header
          fields as specified in Section 5.5.4 of <xref
          target="I-D.templin-intarea-vet"></xref>. The ITE then performs
          outer IP header encapsulation as specified in Section 5.5.5 of <xref
          target="I-D.templin-intarea-vet"></xref>. If this process is entered
          via re-encapsulation (see: Section 4.5.4), the ITE instead follows
          the outer IP/UDP re-encapsulation procedures specified in Section
          5.5.6 of <xref target="I-D.templin-intarea-vet"></xref>.</t>

          <t>When IPv4 is used as the outer encapsulation layer, the ITE
          finally sets the DF flag in the IPv4 header of each segment. If the
          path to the ETE correctly implements IP fragmentation (see: Section
          4.4.6), the ITE sets DF=0; otherwise, it sets DF=1.</t>

          <t>When IPv6 is used as the outer encapsulation layer, the "DF" flag
          is absent but implicitly set to 1. The packet therefore will not be
          fragmented within the subnetwork, since IPv6 deprecates
          in-the-network fragmentation.</t>

          <t>Following outer encapsulation, the ITE sends each outer packet
          via the underlying link corresponding to LINK_ID.</t>
        </section>

        <section title="Probing Strategy">
          <t>When IPv4 is used as the outer encapsulation layer, the ITE can
          perform a qualification exchange over an underlying link to
          determine whether the subnetwork path to the ETE correctly
          implements IP fragmentation. This procedure could be employed, e.g.,
          to determine whether there are any middleboxes on the path that
          violate the <xref target="RFC1812"></xref>, Section 5.2.6
          requirement that: "A router MUST NOT reassemble any datagram before
          forwarding it".</t>

          <t>To perform this qualification, the ITE prepares a SEAL Neighbor
          Solicitation (SNS) message as specified in <xref
          target="I-D.templin-intarea-vet"></xref> then splits the packet into
          two outer IP fragments and sends both fragments to the ETE over the
          same underlying link. If the ETE returns an SPTB message with
          non-zero MTU (see Section 4.6.1.1), then the subnetwork path
          correctly implements IP fragmentation. If the ETE instead returns a
          SEAL Neighbor Solicitation (SNA) message, however, then a middlebox
          in the subnetwork is reassembling the IP fragments before they are
          delivered to the ETE (i.e., in violation of <xref
          target="RFC1812"></xref>).</t>

          <t>In addition to any control plane probing, all SEAL encapsulated
          data packets sent by the ITE are considered implicit probes. SEAL
          data packets that use IPv4 as the outer layer of encapsulation with
          DF=0 will elicit SPTB messages from the ETE if any IPv4
          fragmentation occurs in the path. SEAL data packets that use either
          IPv6 or IPv4 with DF=1 as the outer layer of encapsulation may be
          dropped by a router on the path to the ETE which will return a PTB
          message of the appropriate outer IP protocol to the ITE.</t>

          <t>If the PTB message includes enough information (see Section
          4.4.7), the ITE can then use the identifying information in the SEAL
          header along with the addresses within the packet-in-error to
          determine whether the message corresponds to one of its recent SEAL
          data packet transmissions. If the previous hop toward the inner
          source address within the packet-in-error is reached via the same
          tunnel interface the SEAL data packet was sent on, the ITE
          translates the PTB into an SPTB message and forwards it to the
          previous hop. Otherwise, the ITE translates the message into a PTB
          appropriate for the inner header and forwards it to the inner source
          address.</t>

          <t>The ITE should also send explicit probes, periodically, to verify
          that the ETE is still reachable. The ITE sets A=1 in the SEAL header
          of a packet to be used as an explicit probe. The probe will elicit
          an SPTB message from the ETE as an acknowledgement (see Section
          4.6.1.1). The ITE can also send an SNS message to elicit an SNA
          response from the ETE when there are no convenient data packets to
          use as explicit probes.</t>
        </section>

        <section title="Processing ICMP Messages">
          <t>When the ITE sends SEAL data packets, it may receive raw ICMP
          error messages <xref target="RFC0792"></xref><xref
          target="RFC4443"></xref> from either the ETE or from routers within
          the subnetwork. The ICMP messages include an outer IP header,
          followed by an ICMP header, followed by a portion of the SEAL data
          packet that generated the error (also known as the
          "packet-in-error") beginning with the outer IP header.</t>

          <t>The ITE can use the identifying information in the SEAL header
          along with the source and destination addresses within the
          packet-in-error to confirm that the ICMP message came from either
          the ETE or an on-path router, and can use any additional information
          to determine whether to accept or discard the message.</t>

          <t>The ITE should specifically process raw ICMPv4 Protocol
          Unreachable messages and ICMPv6 Parameter Problem messages with Code
          "Unrecognized Next Header type encountered" as a hint that the ETE
          does not implement the SEAL protocol. The ITE can also process other
          raw ICMPv4 messages as a hint that the path to the ETE may be
          failing. Specific actions that the ITE may take in these cases are
          out of scope.</t>
        </section>
      </section>

      <section title="ETE Specification">
        <section title="Tunnel Interface Soft State">
          <t>The ETE maintains a per-ITE checksum calculation algorithm and
          secret key to verify the Checksum in the SEAL header.</t>
        </section>

        <section title="Reassembly Buffer Requirements">
          <t>The ETE observes the minimum reassembly buffer sizes specified
          for IPv4 <xref target="RFC0791"></xref> and IPv6 <xref
          target="RFC2460"></xref>.</t>
        </section>

        <section title="IP-Layer Reassembly">
          <t>If the SEAL data packet did not undergo outer IP fragmentation,
          the ETE submits it for decapsulation as specified in Section 4.5.4.
          Otherwise, the ETE submits each IP fragment for reassembly.</t>

          <t>The ETE should maintain conservative IP-layer reassembly cache
          high- and low-water marks. When the size of the reassembly cache
          exceeds this high-water mark, the ETE should actively discard
          incomplete reassemblies (e.g., using an Active Queue Management
          (AQM) strategy) until the size falls below the low-water mark. The
          ETE should also actively discard any pending reassemblies that
          clearly have no opportunity for completion, e.g., when a
          considerable number of new fragments have arrived before a fragment
          that completes a pending reassembly arrives.</t>

          <t>The ETE gathers the outer IP fragments of a fragmented SEAL
          packet until it has received enough initial fragments to include the
          first 128 bytes of the SEAL packet beyond the outer headers
          beginning with the SEAL header (or up to the end of the packet if
          the packet itself includes less than 128 bytes). Using this leading
          portion of the (partially) reassembled SEAL packet, the ETE then
          verifies the SEAL header Checksum. If the Checksum is correct, the
          ETE sends an SPTB message back to the ITE (see Section 4.6.1.1).</t>

          <t>Whether or not the Checksum was correct, the ETE then discards
          all IP fragments of the fragmented SEAL packet (i.e., it does not
          submit the reassembled packet for decapsulation).</t>
        </section>

        <section title="Decapsulation and Re-Encapsulation">
          <t>The ETE next checks the SEAL header of the (unfragmented) SEAL
          packet. If the PKT_ID is not within the window of acceptable next
          PKT_ID values from this ITE, or if the SEAL header includes an
          incorrect Checksum value, the ETE silently drops the packet.
          Otherwise, if the packet has an incorrect value in other SEAL header
          fields the ETE discards the packet and returns an SCMP "Parameter
          Problem" (SPP) message (see Section 4.6.1.2). Finally, if the SEAL
          header has A=1 the ETE sends an SPTB message with MTU=0 back to the
          ITE (see Section 4.6.1.1).</t>

          <t>Next, the ETE processes the inner packet according to the header
          type indicated in the SEAL NEXTHDR field. If the next hop toward the
          destination address of the inner packet will be via a different
          interface than the SEAL packet arrived on, the ETE discards the
          outer headers and delivers the inner packet either to the local host
          or to the next hop interface if the packet is not destined to the
          local host.</t>

          <t>If the next hop is on the same interface the SEAL packet arrived
          on, however, the ETE submits the inner packet for SEAL
          re-encapsulation beginning with the specification in Section 4.4.3
          above.</t>
        </section>
      </section>

      <section title="The SEAL Control Message Protocol (SCMP)">
        <t>SEAL provides a companion SEAL Control Message Protocol (SCMP) that
        uses the same message types and formats as for the Internet Control
        Message Protocol for IPv6 (ICMPv6) <xref target="RFC4443"></xref>.
        When the TE prepares an SCMP message, it sets the Type and Code fields
        to the same values that would appear in the corresponding ICMPv6
        message, then calculates the SCMP message header checksum. The TE then
        formats the Message Body the same as for the corresponding ICMPv6
        message. The TE then encapsulates the SCMP message in the SEAL header
        as well as the outer headers and trailers as shown in <xref
        target="scmpencaps"></xref>:</t>

        <t><figure anchor="scmpencaps" title="SCMP Message Encapsulation">
            <artwork><![CDATA[                                    +--------------------+
                                    ~   outer IP header  ~
                                    +--------------------+
                                    ~  other outer hdrs  ~
                                    +--------------------+
                                    ~    SEAL Header     ~
       +--------------------+       +--------------------+
       ~ SCMP message header~  -->  ~ SCMP message header~
       +--------------------+  -->  +--------------------+
       ~  SCMP message body ~  -->  ~  SCMP message body ~
       +--------------------+  -->  +--------------------+
                                    ~   outer trailers   ~
            SCMP Message            +--------------------+
        before encapsulation
                                          SCMP Packet
                                      after encapsulation]]></artwork>
          </figure></t>

        <t>The following sections specify the generation, processing and
        relaying of SCMP messages.</t>

        <section title="Generating SCMP Error Messages">
          <t>ETEs generate SCMP error messages in response to receiving
          certain SEAL data packets using the format shown in <xref
          target="control2"></xref>:</t>

          <t><figure anchor="control2" title="SCMP Error Message Format">
              <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |     Code      |            Checksum           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Type-Specific Data                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           As much of invoking SEAL data packet as             |
   ~    possible (beginning immediately after the SEAL header)     ~
   |        without the SCMP packet exceeding 576 bytes (*)        |

   (*) also known as the "packet-in-error"]]></artwork>
            </figure>The error message includes the 4 byte SCMP message
          header, followed by a 4 byte Type-Specific Data field, followed by
          the leading portion of the invoking SEAL data packet (beginning
          immediately after the SEAL header) as the "packet-in-error". The
          packet-in-error includes as much of the leading portion of the
          invoking SEAL data packet as possible extending to a length that
          would not cause the entire SCMP packet following outer encapsulation
          to exceed 576 bytes.</t>

          <t>When the ETE processes a SEAL data packet for which the SEAL
          header Checksum is correct but an error must be returned, it
          prepares an SCMP error message as shown in <xref
          target="control2"></xref>. The ETE sets the Type and Code fields in
          the SCMP header according to the appropriate error message type,
          fills out the Type-Specific Data field and includes the
          packet-in-error. The ETE then calculates the SCMP message checksum
          the same as specified for ICMPv6, except that the checksum begins
          with the SCMP message header, i.e., and not a pseudo-header of the
          outer header. The ETE writes the checksum value in the SCMP message
          Checksum field.</t>

          <t>The ETE next encapsulates the SCMP message in the requisite SEAL
          and outer headers as shown in <xref target="scmpencaps"></xref>.
          During encapsulation, the ETE sets the outer destination
          address/port numbers of the SCMP packet to the outer source
          address/port numbers of the original SEAL data packet and sets the
          outer source address/port numbers to its own outer address/port
          numbers.</t>

          <t>The ETE then sets (C=1; A=0; R=0; NEXTHDR=0) in the SEAL header,
          then sets PREFLEN to 0 unless otherwise specified. If the neighbor
          relationship between the ETE and the source ITE is unidirectional,
          the ETE then writes random values in the LINK_ID and PKT_ID fields
          of the SEAL header. If the neighbor relationship is bidirectional,
          the ETE instead writes values appropriate to the bidirectional
          neighbor state in the LINK_ID and PKT_ID fields.</t>

          <t>The ETE then calculates and sets the SEAL header Checksum field
          the same as specified for SEAL data packet encapsulation in Section
          4.4.4 Next, the ETE encapsulates the SCMP message in the requisite
          outer headers the same as for SEAL data packets in Section 4.4.5.
          When IPv4 is used as the outer layer of encapsulation, the ETE sets
          the DF=1 in the outer header unless the SCMP message is an SNS
          message used for the path fragmentation qualification procedure
          described in Section 4.4.6. The ETE then sends the resulting SCMP
          packet to the ITE.</t>

          <t>NB: A simplified implementation of this method entails creating a
          copy of the original data packet, inserting the SCMP message header
          and Type-Specific Data fields between the SEAL header and inner
          headers, truncating the resulting message to 576 bytes if necessary,
          then preparing the SEAL and outer header fields as described
          above.</t>

          <t>The following sections describe additional considerations for
          various SCMP error messages:</t>

          <section title="Generating SCMP Packet Too Big (SPTB) Messages">
            <t>An ETE generates an SCMP "Packet Too Big" (SPTB) message when
            it receives the leading 128 bytes of a SEAL protocol packet that
            arrived as multiple outer IP fragments. The ETE prepares the SPTB
            message the same as for the corresponding ICMPv6 PTB message, and
            writes the length of the outer IP first fragment (i.e., the
            fragment with MF=1 and Offset=0) in the MTU field of the
            message.</t>

            <t>The ETE also generates an SPTB message when it receives an
            unfragmented SEAL protocol data packet with A=1 in the SEAL
            header. The ETE prepares the SPTB message the same as above,
            except that it writes the value 0 in the MTU field. The message is
            therefore a control plane acknowledgement of a data plane probe,
            and does not signify a packet size restriction.</t>
          </section>

          <section title="Generating Other SCMP Error Messages">
            <t>An ETE generates an SCMP "Destination Unreachable" (SDU)
            message under the same circumstances that an IPv6 system would
            generate an ICMPv6 Destination Unreachable message.</t>

            <t>An ETE generates an SCMP "Parameter Problem" (SPP) message when
            it receives a SEAL packet with an incorrect value in the SEAL
            header.</t>

            <t>TEs generate other SCMP message types using methods and
            procedures specified in other documents. For example, SCMP message
            types used for tunnel neighbor coordinations are specified in VET
            <xref target="I-D.templin-intarea-vet"></xref>.</t>
          </section>
        </section>

        <section title="Processing SCMP Error Messages">
          <t>For each SCMP error message it receives, the TE first verifies
          that the outer addresses of the SCMP packet, the SEAL header
          Checksum, and the SCMP message header checksum are correct. If the
          identifying addresses and/or checksums are incorrect, the TE
          discards the message; otherwise, it processes the message as
          follows:</t>

          <section title="Processing SCMP PTB Messages">
            <t>After an ITE sends a SEAL data packet to an ETE, it may receive
            an SPTB message with a packet-in-error containing the leading
            portion of the inner packet (see: Section 4.6.1.1). If the SPTB
            message has MTU=0, the ITE processes the message as confirmation
            that the ETE is responsive and discards the message. If the SPTB
            message is the response to a fragmented SNS message used for path
            qualification (see Section 4.4.6), the ITE processes the message
            as a confirmation that the path supports IP fragmentation.
            Otherwise, the ITE processes the message as an indication of a
            packet size limitation.</t>

            <t>If the MTU value is no less than 1280, the value is likely to
            represent the true MTU of the restricting link on the path to the
            ETE. If the MTU value is less than 1280, however, the ITE cannot
            determine the true MTU due to the possibility that a router on the
            path is generating runt first fragments. Instead, the ITE can
            consult a plateau table (e.g., as described in <xref
            target="RFC1191"></xref>) to rewrite the MTU value to a reduced
            size. For example, if the ITE receives an SPTB message with
            MTU=256 and inner header length 1500, it can rewrite the MTU to
            1400. If the ITE subsequently receives an SPTB message with
            MTU=256 and inner header length 1400, it can rewrite the MTU to
            1300, etc.</t>

            <t>The ITE then checks its forwarding tables to determine the
            previous hop on the reverse path toward the source address of the
            inner packet in the packet-in-error. If the previous hop is
            reached over a different interface than the SPTB message arrived
            on, and the inner packet is not an IPv4 packet with DF=0, the ITE
            transcribes the message into a format appropriate for the inner
            packet and sends the resulting transcribed message to the original
            source. If the inner packet is an IPv4 packet with DF=0, however,
            the ITE instead discards the SPTB message and caches the MTU value
            as the fragmentation size to use for fragmentation of future inner
            IPv4 packets destined to the inner destination address (see
            Section 4.4.3).</t>

            <t>If the previous hop is reached over the same tunnel interface
            that the SPTB message arrived on, the ITE instead relays the
            message to the previous hop. In order to relay the message, the
            ITE rewrites the SEAL header fields with values corresponding to
            the previous hop. Next, the ITE replaces the SPTB's outer headers
            with headers of the appropriate protocol version and fills in the
            header fields as specified in Sections 5.5.4-5.5.6 of <xref
            target="I-D.templin-intarea-vet"></xref>, where the destination
            address/port correspond to the previous hop and the source
            address/port correspond to the ITE. The ITE then sends the message
            to the previous hop the same as if it were issuing a new SPTB
            message.</t>
          </section>

          <section title="Processing Other SCMP Error Messages">
            <t>An ITE may receive an SDU message with an appropriate code
            under the same circumstances that an IPv6 node would receive an
            ICMPv6 Destination Unreachable message. The ITE relays the message
            toward the source address of the inner packet within the
            packet-in-error the same as specified for SPTB messages in Section
            4.6.2.1.</t>

            <t>An ITE may receive an SPP message when the ETE receives a SEAL
            packet with an incorrect value in the SEAL header. The ITE should
            examine the incorrect SEAL header field setting to determine
            whether a different setting should be used in subsequent packets,
            but does not relay the message further.</t>

            <t>TEs process other SCMP message types using methods and
            procedures specified in other documents. For example, SCMP message
            types used for tunnel neighbor coordinations are specified in VET
            <xref target="I-D.templin-intarea-vet"></xref>.</t>
          </section>
        </section>
      </section>
    </section>

    <section title="Link Requirements">
      <t>Subnetwork designers are expected to follow the recommendations in
      Section 2 of <xref target="RFC3819"></xref> when configuring link
      MTUs.</t>
    </section>

    <section title="End System Requirements">
      <t>SEAL ensures that tunnels return the necessary path MTU discovery
      control messages. However, end systems are strongly encouraged to also
      implement their own end-to-end MTU assurance, e.g., using Packetization
      Layer Path MTU Discovery per <xref target="RFC4821"></xref>.</t>
    </section>

    <section title="Router Requirements">
      <t>IPv4 routers within the subnetwork are strongly encouraged to
      implement IPv4 fragmentation such that the first fragment is the largest
      and approximately the size of the underlying link MTU, i.e., they should
      not generate runt first fragments.</t>

      <t>IPv6 routers within the subnetwork are required to generate the
      necessary PTB messages when they drop outer IPv6 packets due to an MTU
      restriction.</t>
    </section>

    <section title="IANA Considerations">
      <t>The IANA is instructed to allocate an IP protocol number for
      'SEAL_PROTO' in the 'protocol-numbers' registry.</t>

      <t>The IANA is instructed to allocate a Well-Known Port number for
      'SEAL_PORT' in the 'port-numbers' registry.</t>

      <t>The IANA is instructed to establish a "SEAL Protocol" registry to
      record SEAL Version values. This registry should be initialized to
      include the initial SEAL Version number, i.e., Version 0.</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>SEAL provides a segment-by-segment data origin authentication and
      anti-replay service across the multiple segments of a re-encapsulating
      tunnel. It further provides a segment-by-segment integrity check of the
      headers of encapsulated packets, but does not verify the integrity of
      the rest of the packet beyond the headers. SEAL therefore considers full
      message integrity checking as an end-to-end consideration, and is
      therefore compatible with end-to-end securing mechanisms such as TLS/SSL
      <xref target="RFC5246"></xref>.</t>

      <t>An amplification/reflection attack is possible when an attacker sends
      IP first fragments with spoofed source addresses to an ETE in an attempt
      to generate a stream of SCMP messages returned to a victim ITE. The SEAL
      header Checksum as well as the inner headers of the packet-in-error
      provide mitigation for the ETE to detect and discard SEAL segments with
      spoofed source addresses.</t>

      <t>The SEAL header is sent in-the-clear the same as for the outer IP and
      other outer headers. In this respect, the threat model is no different
      than for IPv6 extension headers. Unlike IPv6 extension headers, however,
      the SEAL header is protected by an integrity check that also covers the
      inner packet headers.</t>

      <t>Security issues that apply to tunneling in general are discussed in
      <xref target="RFC6169"></xref>.</t>
    </section>

    <section title="Related Work">
      <t>Section 3.1.7 of <xref target="RFC2764"></xref> provides a high-level
      sketch for supporting large tunnel MTUs via a tunnel-level segmentation
      and reassembly capability to avoid IP level fragmentation. This
      capability was implemented in the first edition of SEAL, but is now
      deprecated.</t>

      <t>Section 3 of <xref target="RFC4459"> </xref> describes inner and
      outer fragmentation at the tunnel endpoints as alternatives for
      accommodating the tunnel MTU.</t>

      <t>Section 4 of <xref target="RFC2460"></xref> specifies a method for
      inserting and processing extension headers between the base IPv6 header
      and transport layer protocol data. The SEAL header is inserted and
      processed in exactly the same manner.</t>

      <t>IPsec/AUTH is <xref target="RFC4301"></xref><xref
      target="RFC4301"></xref> is used for full message integrity verification
      between tunnel endpoints, whereas SEAL only ensures integrity for the
      inner packet headers. The AYIYA proposal <xref
      target="I-D.massar-v6ops-ayiya"></xref> uses similar means for providing
      full message authentication and integrity.</t>

      <t>The concepts of path MTU determination through the report of
      fragmentation and extending the IP Identification field were first
      proposed in deliberations of the TCP-IP mailing list and the Path MTU
      Discovery Working Group (MTUDWG) during the late 1980's and early
      1990's. An historical analysis of the evolution of these concepts, as
      well as the development of the eventual path MTU discovery mechanism for
      IP, appears in Appendix D of this document.</t>
    </section>

    <section anchor="acknowledge" title="Acknowledgments">
      <t>The following individuals are acknowledged for helpful comments and
      suggestions: Jari Arkko, Fred Baker, Iljitsch van Beijnum, Oliver
      Bonaventure, Teco Boot, Bob Braden, Brian Carpenter, Steve Casner, Ian
      Chakeres, Noel Chiappa, Remi Denis-Courmont, Remi Despres, Ralph Droms,
      Aurnaud Ebalard, Gorry Fairhurst, Washam Fan, Dino Farinacci, Joel
      Halpern, Sam Hartman, John Heffner, Thomas Henderson, Bob Hinden,
      Christian Huitema, Eliot Lear, Darrel Lewis, Joe Macker, Matt Mathis,
      Erik Nordmark, Dan Romascanu, Dave Thaler, Joe Touch, Mark Townsley, Ole
      Troan, Margaret Wasserman, Magnus Westerlund, Robin Whittle, James
      Woodyatt, and members of the Boeing Research &amp; Technology NST
      DC&amp;NT group.</t>

      <t>Discussions with colleagues following the publication of RFC5320 have
      provided useful insights that have resulted in significant improvements
      to this, the Second Edition of SEAL.</t>

      <t>Path MTU determination through the report of fragmentation was first
      proposed by Charles Lynn on the TCP-IP mailing list in 1987. Extending
      the IP identification field was first proposed by Steve Deering on the
      MTUDWG mailing list in 1989.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.0791"?>

      <?rfc include="reference.RFC.0792"?>

      <?rfc include="reference.RFC.4443"?>

      <?rfc include="reference.RFC.3971"?>

      <?rfc include="reference.RFC.4861"?>

      <?rfc include="reference.RFC.2119"?>

      <?rfc include="reference.RFC.2460"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1063"?>

      <?rfc include="reference.RFC.1191"?>

      <?rfc include="reference.RFC.1981"?>

      <?rfc include="reference.RFC.2003"?>

      <?rfc include="reference.RFC.2473"?>

      <?rfc include="reference.RFC.2923"?>

      <?rfc include="reference.RFC.3366"?>

      <?rfc include="reference.RFC.3819"?>

      <?rfc include="reference.RFC.4213"?>

      <?rfc include="reference.RFC.1812"?>

      <?rfc include="reference.RFC.4380"?>

      <?rfc include="reference.RFC.4301"?>

      <?rfc include="reference.RFC.4302"?>

      <?rfc include="reference.RFC.5246"?>

      <?rfc include="reference.RFC.4459"?>

      <?rfc include="reference.RFC.4821"?>

      <?rfc include="reference.RFC.4963"?>

      <?rfc include="reference.RFC.2764"?>

      <?rfc include="reference.RFC.2675"?>

      <?rfc include="reference.RFC.5445"?>

      <?rfc include="reference.RFC.1070"?>

      <?rfc include="reference.RFC.3232"?>

      <?rfc include="reference.RFC.4191"?>

      <?rfc include="reference.RFC.4987"?>

      <?rfc include="reference.RFC.5720"?>

      <?rfc include="reference.I-D.templin-intarea-vet"?>

      <?rfc include="reference.I-D.ietf-savi-framework"?>

      <?rfc include="reference.I-D.templin-ironbis"?>

      <?rfc include="reference.RFC.6139"?>

      <?rfc include="reference.RFC.5927"?>

      <?rfc include="reference.RFC.6169"?>

      <?rfc include="reference.I-D.ietf-intarea-ipv4-id-update"?>

      <?rfc include="reference.I-D.templin-aero"?>

      <?rfc include="reference.I-D.massar-v6ops-ayiya"?>

      <reference anchor="FRAG">
        <front>
          <title>Fragmentation Considered Harmful</title>

          <author fullname="Christopher Kent" initials="C" surname="Kent">
            <organization></organization>
          </author>

          <author fullname="Jeffrey Mogul" initials="J" surname="Mogul">
            <organization></organization>
          </author>

          <date month="October" year="1987" />
        </front>
      </reference>

      <reference anchor="FOLK">
        <front>
          <title>Beyond Folklore: Observations on Fragmented Traffic</title>

          <author fullname="Colleen Shannon" initials="C" surname="Shannon">
            <organization></organization>
          </author>

          <author fullname="David Moore" initials="D" surname="Moore">
            <organization></organization>
          </author>

          <author fullname="k claffy" initials="k" surname="claffy">
            <organization></organization>
          </author>

          <date month="December" year="2002" />
        </front>
      </reference>

      <reference anchor="MTUDWG">
        <front>
          <title>IETF MTU Discovery Working Group mailing list,
          gatekeeper.dec.com/pub/DEC/WRL/mogul/mtudwg-log, November 1989 -
          February 1995.</title>

          <author fullname="" initials="" surname="">
            <organization></organization>
          </author>

          <date month="" year="" />
        </front>
      </reference>

      <reference anchor="TCP-IP">
        <front>
          <title>Archive/Hypermail of Early TCP-IP Mail List,
          http://www-mice.cs.ucl.ac.uk/multimedia/misc/tcp_ip/, May 1987 - May
          1990.</title>

          <author fullname="" initials="" surname="">
            <organization></organization>
          </author>

          <date month="" year="" />
        </front>
      </reference>

      <reference anchor="TBIT">
        <front>
          <title>Measuring Interactions Between Transport Protocols and
          Middleboxes</title>

          <author fullname="Alberto Medina" initials="A" surname="Medina">
            <organization></organization>
          </author>

          <author fullname="Mark Allman" initials="M" surname="Allman">
            <organization></organization>
          </author>

          <author fullname="Sally Floyd" initials="S" surname="Floyd">
            <organization></organization>
          </author>

          <date month="October" year="2004" />
        </front>
      </reference>

      <reference anchor="WAND">
        <front>
          <title>Inferring and Debugging Path MTU Discovery Failures</title>

          <author fullname="Matthew Luckie" initials="M" surname="Luckie">
            <organization></organization>
          </author>

          <author fullname="Kenjiro Cho" initials="K" surname="Cho">
            <organization></organization>
          </author>

          <author fullname="Bill Owens" initials="B" surname="Owens">
            <organization></organization>
          </author>

          <date month="October" year="2005" />
        </front>
      </reference>

      <reference anchor="SIGCOMM">
        <front>
          <title>Measuring Path MTU Discovery Behavior</title>

          <author fullname="Matthew Luckie" initials="M" surname="Luckie">
            <organization></organization>
          </author>

          <author fullname="Ben Stasiewicz" initials="B" surname="Stasiewicz">
            <organization></organization>
          </author>

          <date month="November" year="2010" />
        </front>
      </reference>
    </references>

    <section title="Reliability">
      <t>Although a SEAL tunnel may span an arbitrarily-large subnetwork
      expanse, the IP layer sees the tunnel as a simple link that supports the
      IP service model. Links with high bit error rates (BERs) (e.g., IEEE
      802.11) use Automatic Repeat-ReQuest (ARQ) mechanisms <xref
      target="RFC3366"></xref> to increase packet delivery ratios, while links
      with much lower BERs typically omit such mechanisms. Since SEAL tunnels
      may traverse arbitrarily-long paths over links of various types that are
      already either performing or omitting ARQ as appropriate, it would
      therefore often be inefficient to also require the tunnel endpoints to
      also perform ARQ.</t>
    </section>

    <section title="Integrity">
      <t>The SEAL header includes a Checksum field that covers the SEAL header
      and at least the inner packet headers. This provides for header
      integrity verification on a segment-by-segment basis for a segmented
      re-encapsulating tunnel path.</t>

      <t>Fragmentation and reassembly schemes must consider packet-splicing
      errors, e.g., when two fragments from the same packet are concatenated
      incorrectly, when a fragment from packet X is reassembled with fragments
      from packet Y, etc. The primary sources of such errors include
      implementation bugs and wrapping IP ID fields.</t>

      <t>In terms of wrapping ID fields, when IPv4 is used as the outer IP
      protocol, the 16-bit IP ID field can wrap with only 64K packets with the
      same (src, dst, protocol)-tuple alive in the system at a given time
      <xref target="RFC4963"></xref> increasing the likelihood of reassembly
      mis-associations</t>

      <t>SEAL avoids reassembly mis-associations by unconditionally discarding
      any fragmented SEAL packets following reassembly.</t>
    </section>

    <section title="Transport Mode">
      <t>SEAL can also be used in "transport-mode", e.g., when the inner layer
      comprises upper-layer protocol data rather than an encapsulated IP
      packet. For instance, TCP peers can negotiate the use of SEAL (e.g., by
      inserting a 'SEAL_OPTION' TCP option during connection establishment)
      for the carriage of protocol data encapsulated as IPv4/SEAL/TCP. In this
      sense, the "subnetwork" becomes the entire end-to-end path between the
      TCP peers and may potentially span the entire Internet.</t>

      <t>If both TCPs agree on the use of SEAL, their protocol messages will
      be carried as IPv4/SEAL/TCP and the connection will be serviced by the
      SEAL protocol using TCP (instead of an encapsulating tunnel endpoint) as
      the transport layer protocol. The SEAL protocol for transport mode
      otherwise observes the same specifications as for Section 4.</t>
    </section>

    <section title="Historic Evolution of PMTUD">
      <t>The topic of Path MTU discovery (PMTUD) saw a flurry of discussion
      and numerous proposals in the late 1980's through early 1990. The
      initial problem was posed by Art Berggreen on May 22, 1987 in a message
      to the TCP-IP discussion group <xref target="TCP-IP"></xref>. The
      discussion that followed provided significant reference material for
      [FRAG]. An IETF Path MTU Discovery Working Group <xref
      target="MTUDWG"></xref> was formed in late 1989 with charter to produce
      an RFC. Several variations on a very few basic proposals were
      entertained, including:</t>

      <t><list style="numbers">
          <t>Routers record the PMTUD estimate in ICMP-like path probe
          messages (proposed in [FRAG] and later <xref
          target="RFC1063"></xref>)</t>

          <t>The destination reports any fragmentation that occurs for packets
          received with the "RF" (Report Fragmentation) bit set (Steve
          Deering's 1989 adaptation of Charles Lynn's Nov. 1987 proposal)</t>

          <t>A hybrid combination of 1) and Charles Lynn's Nov. 1987 (straw
          RFC draft by McCloughrie, Fox and Mogul on Jan 12, 1990)</t>

          <t>Combination of the Lynn proposal with TCP (Fred Bohle, Jan 30,
          1990)</t>

          <t>Fragmentation avoidance by setting "IP_DF" flag on all packets
          and retransmitting if ICMPv4 "fragmentation needed" messages occur
          (Geof Cooper's 1987 proposal; later adapted into <xref
          target="RFC1191"></xref> by Mogul and Deering).</t>
        </list></t>

      <t>Option 1) seemed attractive to the group at the time, since it was
      believed that routers would migrate more quickly than hosts. Option 2)
      was a strong contender, but repeated attempts to secure an "RF" bit in
      the IPv4 header from the IESG failed and the proponents became
      discouraged. 3) was abandoned because it was perceived as too
      complicated, and 4) never received any apparent serious consideration.
      Proposal 5) was a late entry into the discussion from Steve Deering on
      Feb. 24th, 1990. The discussion group soon thereafter seemingly lost
      track of all other proposals and adopted 5), which eventually evolved
      into <xref target="RFC1191"></xref> and later <xref
      target="RFC1981"></xref>.</t>

      <t>In retrospect, the "RF" bit postulated in 2) is not needed if a
      "contract" is first established between the peers, as in proposal 4) and
      a message to the MTUDWG mailing list from jrd@PTT.LCS.MIT.EDU on Feb 19.
      1990. These proposals saw little discussion or rebuttal, and were
      dismissed based on the following the assertions:</t>

      <t><list style="symbols">
          <t>routers upgrade their software faster than hosts</t>

          <t>PCs could not reassemble fragmented packets</t>

          <t>Proteon and Wellfleet routers did not reproduce the "RF" bit
          properly in fragmented packets</t>

          <t>Ethernet-FDDI bridges would need to perform fragmentation (i.e.,
          "translucent" not "transparent" bridging)</t>

          <t>the 16-bit IP_ID field could wrap around and disrupt reassembly
          at high packet arrival rates</t>
        </list>The first four assertions, although perhaps valid at the time,
      have been overcome by historical events. The final assertion is
      addressed by the mechanisms specified in SEAL.</t>
    </section>
  </back>
</rfc>
