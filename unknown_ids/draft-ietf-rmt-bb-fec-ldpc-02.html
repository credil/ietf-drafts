<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Low Density Parity Check (LDPC) Staircase and Triangle Forward Error Correction (FEC) Schemes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Low Density Parity Check (LDPC) Staircase and Triangle Forward Error Correction (FEC) Schemes">
<meta name="keywords" content="LDPC, FEC">
<meta name="generator" content="xml2rfc v1.30 (http://xml.resource.org/)">
<style type='text/css'>
<!--
    body {
        font-family: verdana, charcoal, helvetica, arial, sans-serif;
        margin: 2em;
        font-size: small ; color: #000000 ; background-color: #ffffff ; }
    .title { color: #990000; font-size: x-large ;
        font-weight: bold; text-align: right;
        font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
        background-color: transparent; }
    .filename { color: #666666; font-size: 18px; line-height: 28px;
        font-weight: bold; text-align: right;
        font-family: helvetica, arial, sans-serif;
        background-color: transparent; }
    td.rfcbug { background-color: #000000 ; width: 30px ; height: 30px ;
        text-align: justify; vertical-align: middle ; padding-top: 2px ; }
    td.rfcbug span.RFC { color: #666666; font-weight: bold; text-decoration: none;
        background-color: #000000 ;
        font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
        font-size: x-small ; }
    td.rfcbug span.hotText { color: #ffffff; font-weight: normal; text-decoration: none;
        text-align: center ;
        font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
        font-size: x-small ; background-color: #000000; }
    /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
    div#counter{margin-top: 100px}

    a.info{
        position:relative; /*this is the key*/
        z-index:24;
        text-decoration:none}

    a.info:hover{z-index:25; background-color:#990000 ; color: #ffffff ;}

    a.info span{display: none}

    a.info:hover span.info{ /*the span will display just on :hover state*/
        display:block;
        position:absolute;
        font-size: smaller ;
        top:2em; left:2em; width:15em;
        padding: 2px ;
        border:1px solid #333333;
        background-color:#eeeeee; color:#990000;
        text-align: left ;}

     A { font-weight: bold; }
     A:link { color: #990000; background-color: transparent ; }
     A:visited { color: #333333; background-color: transparent ; }
     A:active { color: #333333; background-color: transparent ; }

    p { margin-left: 2em; margin-right: 2em; }
    p.copyright { font-size: x-small ; }
    p.toc { font-size: small ; font-weight: bold ; margin-left: 3em ;}
    table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
    td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

    span.emph { font-style: italic; }
    span.strong { font-weight: bold; }
    span.verb, span.vbare { font-family: "Courier New", Courier, monospace ; }

    span.vemph { font-style: italic; font-family: "Courier New", Courier, monospace ; }
    span.vstrong { font-weight: bold; font-family: "Courier New", Courier, monospace ; }
    span.vdeluxe { font-weight: bold; font-style: italic; font-family: "Courier New", Courier, monospace ; }

    ol.text { margin-left: 2em; margin-right: 2em; }
    ul.text { margin-left: 2em; margin-right: 2em; }
    li { margin-left: 3em;  }

    pre { margin-left: 3em; color: #333333;  background-color: transparent;
        font-family: "Courier New", Courier, monospace ; font-size: small ;
        text-align: left;
        }

    h3 { color: #333333; font-size: medium ;
        font-family: helvetica, arial, sans-serif ;
        background-color: transparent; }
    h4 { font-size: small; font-family: helvetica, arial, sans-serif ; }

    table.bug { width: 30px ; height: 15px ; }
    td.bug { color: #ffffff ; background-color: #990000 ;
        text-align: center ; width: 30px ; height: 15px ;
         }
    td.bug A.link2 { color: #ffffff ; font-weight: bold;
        text-decoration: none;
        font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
        font-size: x-small ; background-color: transparent }

    td.header { color: #ffffff; font-size: x-small ;
        font-family: arial, helvetica, sans-serif; vertical-align: top;
        background-color: #666666 ; width: 33% ; }
    td.author { font-weight: bold; margin-left: 4em; font-size: x-small ; }
    td.author-text { font-size: x-small; }
    table.full { vertical-align: top ; border-collapse: collapse ;
        border-style: solid solid solid solid ;
        border-color: black black black black ;
        font-size: small ; text-align: center ; }
    table.headers, table.none { vertical-align: top ; border-collapse: collapse ;
        border-style: none;
        font-size: small ; text-align: center ; }
    table.full th { font-weight: bold ;
        border-style: solid ;
        border-color: black black black black ; }
    table.headers th { font-weight: bold ;
        border-style: none none solid none;
        border-color: black black black black ; }
    table.none th { font-weight: bold ;
        border-style: none; }
    table.full td {
        border-style: solid solid solid solid ;
        border-color: #333333 #333333 #333333 #333333 ; }
    table.headers td, table.none td { border-style: none; }

    hr { height: 1px }
-->
</style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">RMT</td><td class="header">V. Roca</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">INRIA</td></tr>
<tr><td class="header">Expires: December 23, 2006</td><td class="header">C. Neumann</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Thomson Research</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">D. Furodet</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">STMicroelectronics</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">June 21, 2006</td></tr>
</table></td></tr></table>
<div align="right"><span class="title"><br />Low Density Parity Check (LDPC) Staircase and Triangle Forward Error Correction (FEC) Schemes</span></div>
<div align="right"><span class="title"><br />draft-ietf-rmt-bb-fec-ldpc-02.txt</span></div>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on December 23, 2006.</p>

<h3>Copyright Notice</h3>
<p>
Copyright &copy; The Internet Society (2006).</p>

<h3>Abstract</h3>

<p>This document describes two Fully-Specified FEC Schemes,
		LDPC-Staircase and LDPC-Triangle, and their application to the
		reliable delivery of objects on packet erasure channels.
		These systematic FEC codes belong to the well known class of
		``Low Density Parity Check'' (LDPC) codes, and are large block
		FEC codes in these sense of RFC3453. 
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
<a href="#anchor1">2.</a>&nbsp;
Requirements notation<br />
<a href="#anchor2">3.</a>&nbsp;
Definitions, Notations and Abbreviations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">3.1.</a>&nbsp;
Definitions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">3.2.</a>&nbsp;
Notations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">3.3.</a>&nbsp;
Abbreviations<br />
<a href="#anchor6">4.</a>&nbsp;
Formats and Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FPI">4.1.</a>&nbsp;
FEC Payload IDs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FEC_OTI">4.2.</a>&nbsp;
FEC Object Transmission Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">4.2.1.</a>&nbsp;
Mandatory Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#common_elements">4.2.2.</a>&nbsp;
Common Elements<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scheme_specific_elt">4.2.3.</a>&nbsp;
Scheme-Specific Element<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FEC_OTI_encoding_format">4.2.4.</a>&nbsp;
Encoding Format<br />
<a href="#procedures">5.</a>&nbsp;
Procedures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#general">5.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#max_source_block_length">5.2.</a>&nbsp;
Determining the Maximum Source Block Length (B)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encoding_symbol_length">5.3.</a>&nbsp;
Determining the Encoding Symbol Length (E) and Number of
Encoding Symbols per Group (G)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#n-algorithm">5.4.</a>&nbsp;
Determining the Number of Encoding Symbols of a Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encoding_symbol_group">5.5.</a>&nbsp;
Identifying the Symbols of an Encoding Symbol Group<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#prng">5.6.</a>&nbsp;
Pseudo Random Number Generator<br />
<a href="#ldpc_staircase">6.</a>&nbsp;
Full Specification of the LDPC-Staircase Scheme<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">6.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#staircase_matrix">6.2.</a>&nbsp;
Parity Check Matrix Creation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encoding_staircase">6.3.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#decoding_staircase">6.4.</a>&nbsp;
Decoding<br />
<a href="#ldpc_triangle">7.</a>&nbsp;
 Full Specification of the LDPC-Triangle Scheme<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">7.1.</a>&nbsp;
General<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">7.2.</a>&nbsp;
Parity Check Matrix Creation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#encoding_triangle">7.3.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">7.4.</a>&nbsp;
Decoding<br />
<a href="#anchor14">8.</a>&nbsp;
Security Considerations<br />
<a href="#anchor15">9.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#trivial_decoding">Appendix&nbsp;A.</a>&nbsp;
Trivial Decoding Algorithm (Informative Only)<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;Introduction</h3>

<p><a class="info" href="#RFC3453">RFC 3453<span> (</span><span class="info">Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;The Use of Forward Error Correction (FEC) in Reliable Multicast,&rdquo; December&nbsp;2002.</span><span>)</span></a> [3]
introduces large block FEC codes as an alternative to small
block FEC codes like Reed-Solomon.
The main advantage of such large block codes is the possibility to operate
efficiently on source blocks of size several tens of thousands (or more)
source symbols.
The present document introduces 
the Fully-Specified FEC Encoding ID XX that is intended to be used with
the "Low Density Parity Check" (LDPC) Staircase FEC codes, and 
the Fully-Specified FEC Encoding ID YY that is intended to be used with
the "Low Density Parity Check" (LDPC)-Triangle FEC codes
<a class="info" href="#Roca04">[4]<span> (</span><span class="info">Roca, V. and C. Neumann, &ldquo;Design, Evaluation and Comparison of Four 		Large Block FEC Codecs: LDPC, LDGM, LDGM-Staircase and LDGM-Triangle, Plus 		a Reed-Solomon Small Block FEC Codec,&rdquo; June&nbsp;2004.</span><span>)</span></a><a class="info" href="#Mac03">[7]<span> (</span><span class="info">MacKay, D., &ldquo;Information Theory, Inference and Learning Algorithms,&rdquo; 2003.</span><span>)</span></a>.
Both schemes belong the broad class of large block codes.
</p>
<p>
</p>
<blockquote class="text">
<p> -- editor's note:
This document makes use of the FEC Encoding ID
values XX and YY that will be specified after IANA assignment -- 
</p>
</blockquote><p>

</p>
<p>
LDPC codes rely on a dedicated matrix, called a "Parity Check
Matrix", at the encoding and decoding ends. The parity check matrix
defines relationships (or constraints) between the various encoding
symbols (i.e. source symbols and repair symbols), that are later used
by the decoder to reconstruct the original k source symbols if some
of them are missing. These codes are systematic, in the sense that
the encoding symbols include the source symbols in addition to the
repair symbols.
</p>
<p>
Since the encoder and decoder must operate on the same parity
check matrix, information must be communicated between them as
part of the FEC Object Transmission information.
</p>
<p>
A publicly available reference implementation of these codes is available
and distributed under a GNU/LGPL license <a class="info" href="#LDPCrefimpl">[6]<span> (</span><span class="info">Roca, V., Neumann, C., and J. Laboure, &ldquo;LDPC-Staircase/LDPC-Triangle Codec Reference Implementation,&rdquo; .</span><span>)</span></a>.

</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;Requirements notation</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
    "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
    and "OPTIONAL" in this document are to be interpreted as
    described in <a class="info" href="#RFC2119">[1]<span> (</span><span class="info">Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;Definitions, Notations and Abbreviations</h3>

<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;Definitions</h3>

<p>This document uses the same terms and definitions as those
specified in <a class="info" href="#fec-bb-revised">[2]<span> (</span><span class="info">Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; January&nbsp;2006.</span><span>)</span></a>.
Additionally, it uses the following definitions:
</p>
<blockquote class="text">
<p>Encoding Symbol Group:	a group of encoding symbols that are
				sent together, within the same packet, and
				whose relationships to the source object can
				be derived from a single Encoding Symbol
				ID.
</p>
<p>Source Packet:		a data packet containing only source
				symbols.
</p>
<p>Repair Packet:		a data packet containing only repair
				symbols.
</p>
</blockquote><p>

</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;Notations</h3>

<p>This document uses the following notations:
</p>
<blockquote class="text">
<p>L		denotes the object transfer length in bytes
</p>
<p>k		denotes the source block length in symbols,
		i.e. the number of source symbols of a source block
</p>
<p>n		denotes the encoding block length, i.e. the number of
		encoding symbols generated for a source block
</p>
<p>E		denotes the encoding symbol length in bytes
</p>
<p>B		denotes the maximum source block length in symbols,
		i.e. the maximum number of source symbols per source block
</p>
<p>N		denotes the number of source blocks into which the object
		shall be partitioned
</p>
<p>G		denotes the number of encoding symbols per group, i.e.
		the number of symbols sent in the same packet
</p>
<p>rate		denotes the "code rate", i.e. the k/n ratio
</p>
<p>max_n	denotes the maximum number of encoding symbols generated for any
		source block
</p>
<p>srand(s)	denotes the initialization function of the pseudo-random
		number generator, where s is the seed (s > 0)
</p>
<p>rand(m)	denotes a pseudo-random number generator, that returns
		a new random integer in [0; m-1] each time it is called
</p>
</blockquote>

<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;Abbreviations</h3>

<p>This document uses the following abbreviations:
</p>
<blockquote class="text">
<p>ESI:		Encoding Symbol ID
</p>
<p>FEC OTI:	FEC Object Transmission Information
</p>
</blockquote>

<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;Formats and Codes</h3>

<a name="FPI"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;FEC Payload IDs</h3>

<p>The FEC Payload ID is composed of the Source Block 
   Number and the Encoding Symbol ID:
</p>
<p>
</p>
<blockquote class="text">
<p>The Source Block Number (12 bit field) identifies from which source block
   of the object the encoding symbol(s) in the payload is(are) generated.
   There are a maximum of 2^^12 blocks per object.
</p>
<p>The Encoding Symbol ID (20 bit field) identifies which encoding
   symbol(s) generated from the source block is(are) carried in the packet payload.
   There are a maximum of 2^^20 encoding symbols per block.
   The first k values (0 to k-1) identify source symbols, the remaining n-k
   values (k to n-k-1) identify repair symbols.
</p>
</blockquote><p>

</p>
<p>There MUST be exactly one FEC Payload ID per packet.
In case of en Encoding Symbol Group,
when multiple encoding symbols are sent in the same packet,
the FEC Payload ID refers to the first symbol of the packet.
The other symbols can be deduced from the ESI of the first symbol
thanks to a dedicated function, as explained in
<a class="info" href="#encoding_symbol_group">Section&nbsp;5.5<span> (</span><span class="info">Identifying the Symbols of an Encoding Symbol Group</span><span>)</span></a>

</p><br /><hr />
<a name="fig_fec_payload_id_for_1"></a>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Source Block Number  |      Encoding Symbol ID (20 bits)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre><table border="0" cellpadding="0" cellspacing="2"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: FEC Payload ID encoding format for FEC Encoding ID XX and YY&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<a name="FEC_OTI"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;FEC Object Transmission Information</h3>

<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;Mandatory Elements</h3>

<p>
</p>
<ul class="text">
<li>FEC Encoding ID: 
   the Fully-Specified FEC Schemes described in this document use
   the FEC Encoding ID XX for LDPC-Staircase and FEC Encoding ID YY for
   LDPC-Triangle.
   
</li>
</ul><p>

</p>
<a name="common_elements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;Common Elements</h3>

<p> The following elements MUST be defined with the present FEC Scheme:
</p>
<p>
</p>
<ul class="text">
<li>Transfer-Length (L): a non-negative integer indicating the length of the
      object in bytes.
      There are some restrictions on the maximum Transfer-Length that
      can be supported:
      
<blockquote class="text">
<p>maximum transfer length = 2^^12 * B * E
</p>
</blockquote>
      For instance, if B=2^^19 (because of a code rate of 1/2, 
      <a class="info" href="#max_source_block_length">Section&nbsp;5.2<span> (</span><span class="info">Determining the Maximum Source Block Length (B)</span><span>)</span></a>), and if E=1024 bytes,
      then the maximum transfer length is 2^^41 bytes (or 2 TB).
      The upper limit, with symbols of size 2^^16-1 bytes and a code rate
      larger or equal to 1/2, amounts to 2^^47 bytes (or 128 TB).
      
</li>
<li>Encoding-Symbol-Length (E): a non-negative integer indicating the length
      of each encoding symbol in bytes.
</li>
<li>Maximum-Source-Block-Length (B): a non-negative integer indicating the
      maximum number of source symbols in a source block.
      There are some restrictions on the maximum B value, as explained in
      <a class="info" href="#max_source_block_length">Section&nbsp;5.2<span> (</span><span class="info">Determining the Maximum Source Block Length (B)</span><span>)</span></a>.
      
</li>
<li>Max-Number-of-Encoding-Symbols (max_n): a non-negative integer
      indicating the maximum number of encoding symbols generated for
      any source block.
      There are some restrictions on the maximum max_n value.
      In particular max_n is at most equal to 2^^20.
      
</li>
</ul><p>

</p>
<p><a class="info" href="#procedures">Section&nbsp;5<span> (</span><span class="info">Procedures</span><span>)</span></a> explains how to derive the values
      of each of these elements.
</p>
<a name="scheme_specific_elt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;Scheme-Specific Element</h3>

<p> The following element MUST be defined with the present FEC Scheme.
It contains two distinct pieces of information:
</p>
<p>
</p>
<ul class="text">
<li> G: a non-negative integer indicating the number of encoding symbols
    per group used for the object. The default value is 1, meaning that
    each packet contains exactly one symbol.
    Values greater than 1 can also be defined, as explained in
    <a class="info" href="#encoding_symbol_length">Section&nbsp;5.3<span> (</span><span class="info">Determining the Encoding Symbol Length (E) and Number of Encoding Symbols per Group (G)</span><span>)</span></a>.
    
</li>
<li> PRNG seed: The seed is a 32 bit unsigned integer between 1 and 
    0x7FFFFFFE (i.e. 2^^31-2) inclusive. This value is used to initialize the
    Pseudo Random Number Generator (<a class="info" href="#prng">Section&nbsp;5.6<span> (</span><span class="info">Pseudo Random Number Generator</span><span>)</span></a>).
    This element is optional. Whether or not it is present in the FEC OTI
    is signaled in the associated encoding format through an appropriate
    mechanism (see <a class="info" href="#FEC_OTI_encoding_format">Section&nbsp;4.2.4<span> (</span><span class="info">Encoding Format</span><span>)</span></a>).
    When the PRNG seed is not carried within the FEC OTI, it is assumed that
    encoder and decoders use another way to communicate the information,
    or use a fixed, predefined value.
</li>
</ul><p>

</p>
<a name="FEC_OTI_encoding_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4"></a><h3>4.2.4.&nbsp;Encoding Format</h3>

<p>This section shows two possible encoding formats of the above FEC OTI.
    The present document does not specify when or how these encoding
    formats should be used.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4.1"></a><h3>4.2.4.1.&nbsp;Using the General EXT_FTI Format</h3>

<p>
The FEC OTI binary format is the following, when the EXT_FTI mechanism
is used.

</p><br /><hr />
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   HET = 64    | HEL (=4 or 5) |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                      Transfer-Length (L)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  |       G       |   B (MSB)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        B (LSB)        |   Max Nb of Enc. Symbols  (max_n)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.                       Optional PRNG seed                      .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre><table border="0" cellpadding="0" cellspacing="2"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;EXT_FTI Header for FEC Encoding ID 132&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<p>
In particular:
</p>
<ul class="text">
<li>The HEL (Header Extension Length) indicates whether the optional
	PRNG seed is present (HEL=5) or not (HEL=4).
</li>
<li>The Transfer-Length (L) field size (48 bits) is larger than the
	size required to store the maximum transfer length
	(<a class="info" href="#common_elements">Section&nbsp;4.2.2<span> (</span><span class="info">Common Elements</span><span>)</span></a>) for field alignment purposes.
</li>
<li>The Maximum-Source-Block-Length (B) field (20 bits)
	is split into two parts:
	the 8 most significant bits (MSB) are in the third 32-bit
	word of the EXT_FTI, and the remaining 12 least significant
	bits (LSB) are in fourth 32-bit word.
</li>
</ul><p>

</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4.2"></a><h3>4.2.4.2.&nbsp;Using the FDT Instance (FLUTE specific)</h3>

<p>When it is desired that the FEC OTI be carried in the FDT Instance
of a FLUTE session, the following XML elements must be described 
for the associated object:
</p>
<ul class="text">
<li>FEC-OTI-Transfer-length
</li>
<li>FEC-OTI-Encoding-Symbol-Length
</li>
<li>FEC-OTI-Maximum-Source-Block-Length
</li>
<li>FEC-OTI-Max-Number-of-Encoding-Symbols
</li>
<li>FEC-OTI-Number-Encoding-Symbols-per-Group
</li>
<li>FEC-OTI-PRNG-seed (optional)
</li>
</ul><p>
When no PRNG seed is to be carried in the FEC OTI, the sender 
simply omits the FEC-OTI-PRNG-seed element.

</p>
<a name="procedures"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;Procedures</h3>

<p>This section defines procedures that are common to FEC Encoding IDs
XX and YY.
</p>
<a name="general"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;General</h3>

<p>
The B (maximum source block length in symbols) and
E (encoding symbol length in bytes) parameters are first determined,
as explained in the following sections.

</p>
<p>
The source object is then partitioned using the
block partitioning algorithm specified in <a class="info" href="#fec-bb-revised">[2]<span> (</span><span class="info">Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; January&nbsp;2006.</span><span>)</span></a>.
To that purpose, the B, L (object transfer length in bytes), and E
arguments are provided.
As a result, the object is partitioned into N source blocks.
These blocks are numbered consecutively from 0 to N-1.
The first I source blocks consist of A_large source symbols, the
remaining N-I source blocks consist of A_small source symbols.
Each source symbol is E bytes in length, except perhaps the last
symbol which may be shorter.

</p>
<p>
For each block the actual number of encoding symbols is determined,
as explained in the following section.

</p>
<p>
Then, FEC encoding and decoding can be done block per block, independently.
To that purpose, a parity check matrix is created, that forms
a system of linear equations between the repair and source symbols of a
given block, where the basic operator is XOR.

</p>
<p>
This parity check matrix is logically divided into two parts:
the left side (from column 0 to k-1) which describes
the occurrence of each source symbol in the equation system;
and the right side (from column k to n-1) which describes
the occurrence of each repair symbol in the equation system.
An entry (a "1") in the matrix at position (i,j) (i.e.
at row i and column j) means that the symbol with ESI i
appears in equation j of the system.
The only difference between the LDPC-Staircase and LDPC-Triangle
schemes is the construction of the right sub-matrix.

</p>
<p>
When the parity symbols have been created, the sender will transmit
source and parity symbols.
The way this transmission occurs can largely impact the erasure recovery
capabilities of the LDPC-* FEC.
In particular, sending parity symbols in sequence is suboptimal.
Instead it is usually recommended the shuffle these symbols.
The interested reader will find more details in <a class="info" href="#Neumann05">[5]<span> (</span><span class="info">Neumann, C., Roca, V., Francillon, A., and D. Furodet, &ldquo;Impacts of Packet Scheduling and Packet Loss Distribution on FEC Performances: Observations and Recommendations,&rdquo; October&nbsp;2005.</span><span>)</span></a>.

</p>
<p>
The following sections detail how the B, E, and n parameters are determined
(respectively <a class="info" href="#max_source_block_length">Section&nbsp;5.2<span> (</span><span class="info">Determining the Maximum Source Block Length (B)</span><span>)</span></a>,
<a class="info" href="#encoding_symbol_length">Section&nbsp;5.3<span> (</span><span class="info">Determining the Encoding Symbol Length (E) and Number of Encoding Symbols per Group (G)</span><span>)</span></a> and
<a class="info" href="#n-algorithm">Section&nbsp;5.4<span> (</span><span class="info">Determining the Number of Encoding Symbols of a Block</span><span>)</span></a>),
how encoding symbol groups are created
(<a class="info" href="#encoding_symbol_group">Section&nbsp;5.5<span> (</span><span class="info">Identifying the Symbols of an Encoding Symbol Group</span><span>)</span></a>),
and finally specify the PRNG
(<a class="info" href="#prng">Section&nbsp;5.6<span> (</span><span class="info">Pseudo Random Number Generator</span><span>)</span></a>).

</p>
<a name="max_source_block_length"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;Determining the Maximum Source Block Length (B)</h3>

<p>
The B parameter (maximum source block length in symbols) depends
on several parameters:
the code rate (rate), the Encoding Symbol ID field length of the FEC
Payload ID (20 bits), as well as possible internal codec limitations.

</p>
<p>
The B parameter cannot be larger than the following values, derived
from the FEC Payload ID limitations, for a given code rate:
      </p>
<blockquote class="text">
<p>max1_B = 2^^(20 - ceil(Log2(1/rate)))
</p>
</blockquote><p>

</p>
<p>
Some common max1_B values are:
</p>
<ul class="text">
<li>rate == 1 (no repair symbols): max_B = 2^^20 = 1,048,576
</li>
<li>1 > rate >= 1/2: max1_B = 2^^19 = 524,288 symbols
</li>
<li>1/2 > rate >= 1/4: max1_B = 2^^18 = 262,144 symbols
</li>
<li>1/4 > rate >= 1/8: max1_B = 2^^17 = 131,072 symbols
</li>
</ul><p>

</p>
<p>Additionally, a codec MAY impose other limitations on the maximum
block size. 
This is the case for instance when the codec uses internally 16 bit
integers to store the Encoding Symbol ID, since it does not enable to
store all the possible values of a 20 bit field.
In that case, if for instance 1 > rate >= 1/2, then the maximum block
size is 2^^15.
Other limitations may also apply, for instance because of a limited working
memory size.
This decision MUST be clarified at implementation time, when the target
use case is known. This results in a max2_B limitation.
</p>
<p>
Then, B is given by:
      </p>
<blockquote class="text">
<p>B = min(max1_B, max2_B)
</p>
</blockquote><p>
Note that this calculation is only required at the coder, since the
B parameter is communicated to the decoder through the FEC OTI.

</p>
<a name="encoding_symbol_length"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;Determining the Encoding Symbol Length (E) and Number of
Encoding Symbols per Group (G)</h3>

<p>
The E parameter usually depends on the maximum transmission unit on the
path (PMTU) from the source to the receivers.
In order to minimize the protocol header overhead
(e.g. the LCT/UDP/IPv4 or IPv6 headers in case of ALC), E is chosen as large
as possible.
In that case, E is chosen so that the size of a packet composed of a single
symbol (G=1) remains below but close to the PMTU.

</p>
<p>
Yet other considerations can exist.
For instance, the E parameter can be made a function of the object transfer
length.
Indeed, LDPC codes are known to offer better protection for large blocks.
In case of small objects, it can be a good practice to reduce the encoding
symbol length (E) in order to artificially increase the number of symbols,
and therefore the block size.

</p>
<p>
In order to minimize the protocol header overhead, several symbols can
be grouped in the same Encoding Symbol Group (i.e. G &gt; 1).
Depending on how many symbols are grouped (G) and on the packet loss rate
(which leads to loosing G symbols at a time), this strategy might or might
not be appropriate.
A balance must therefore be found.

</p>
<p>
The current specification does not mandate any value for either E or G.
The current specification only provides an example of possible choices for E and G.
Note that this choice is done by the sender.
Then the E and G parameters are communicated to the receivers thanks to
the FEC OTI.

</p>
<p>
Example:

</p>
<p>
First define the target packet size, pkt_sz (usually the PMTU minus the
various protocol headers).
The pkt_sz must be chosen in such a way that the symbol size is an
integer. This can require that pkt_sz be a multiple of 4, 8 or 16 (see the table below).
Then calculate the number of packets: nb_pkts = ceil(L / pkt_sz).
Finally use the following table to find a possible G value.

</p>
<p style='text-align: center'>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center"><col align="center"><col align="center">
<tr><th align="center">Number of packets</th><th align="center">G</th><th align="center">Symbol size</th><th align="center">k</th></tr>
<tr>
<td align="center">4000 &le; nb_pkts</td>
<td align="center">1</td>
<td align="center">pkt_sz</td>
<td align="center">4000 &le; k</td>
</tr>
<tr>
<td align="center">1000 &le; nb_pkts &lt; 4000</td>
<td align="center">4</td>
<td align="center">pkt_sz / 4</td>
<td align="center">4000 &le; k &lt; 16000</td>
</tr>
<tr>
<td align="center">500 &le; nb_pkts &lt; 1000</td>
<td align="center">8</td>
<td align="center">pkt_sz / 8</td>
<td align="center">4000 &le; k &lt; 8000</td>
</tr>
<tr>
<td align="center">1 &le; nb_pkts &lt; 500</td>
<td align="center">16</td>
<td align="center">pkt_sz / 16</td>
<td align="center">16 &le; k &lt; 8000</td>
</tr>
</table>

<a name="n-algorithm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;Determining the Number of Encoding Symbols of a Block</h3>

<p>The following algorithm, also called "n-algorithm", explains how to
determine the actual number of encoding symbols for a given block.
</p>
<p> AT A SENDER: 
</p>
<p> Input:
</p>
<blockquote class="text">
<p>B:		Maximum source block length, for any source block.
		<a class="info" href="#max_source_block_length">Section&nbsp;5.2<span> (</span><span class="info">Determining the Maximum Source Block Length (B)</span><span>)</span></a> explains how
		to determine its value.
</p>
<p>k:		Current source block length. This parameter is given by the
		source blocking algorithm.
</p>
<p>rate:	FEC code rate, which is provided by the user (e.g. when
		starting a FLUTE sending application).
		It is expressed as a floating point value.
		The rate value must be such that the resulting number of
		encoding symbols per block is at most equal to 2^^20
		(<a class="info" href="#FPI">Section&nbsp;4.1<span> (</span><span class="info">FEC Payload IDs</span><span>)</span></a>).
               	
</p>
</blockquote><p>

</p>
<p>
Output:
</p>
<blockquote class="text">
<p>max_n:	Maximum number of encoding symbols generated for any
		source block
</p>
<p>n:		Number of encoding symbols generated for this source block
</p>
</blockquote><p>

</p>
<p>
      Algorithm:
      </p>
<blockquote class="text">
<p>max_n = floor(B / rate);
</p>
<p>if (max_n &ge; 2^^20) then return an error ("invalid code rate");
</p>
<p>(NB: if max_n has been defined as explained in
		<a class="info" href="#max_source_block_length">Section&nbsp;5.2<span> (</span><span class="info">Determining the Maximum Source Block Length (B)</span><span>)</span></a>, this
		error should never happen)
</p>
<p>n = floor(k * max_n / B);
</p>
</blockquote><p>

</p>
<p>AT A RECEIVER: 
</p>
<p>Input:
</p>
<blockquote class="text">
<p>B:		Extracted from the received FEC OTI
</p>
<p>max_n:	Extracted from the received FEC OTI
</p>
<p>k:		Given by the source blocking algorithm
</p>
</blockquote><p>

</p>
<p>Output:
</p>
<blockquote class="text">
<p>n:
</p>
</blockquote><p>

</p>
<p>
      Algorithm:
      </p>
<blockquote class="text">
<p>n = floor(k * max_n / B);
</p>
</blockquote><p>

</p>
<a name="encoding_symbol_group"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;Identifying the Symbols of an Encoding Symbol Group</h3>

<p>
When multiple encoding symbols are sent in the same packet, the
FEC Payload ID information of the packet MUST refer to the first
encoding symbol.
It MUST then be possible to identify each symbol from this single FEC Payload
ID. To that purpose, the symbols of an Encoding Symbol Group (i.e.
packet):
</p>
<ul class="text">
<li>MUST all be either source symbols, or repair symbols.
	Therefore only source packets and repair packets are
	permitted, not mixed ones.
</li>
<li>are identified by a function, ESIs_of_group(), that takes
	as argument:
	
<ul class="text">
<li> for a sender, the index of the Encoding Symbol Group
	(i.e. packet) that the application wants to create,
</li>
<li> for a receiver, the ESI information contained in the
	FEC Payload ID.
</li>
</ul>
	and returns the list of G Encoding Symbol IDs that will
	be packed together.
	In case of a source packet, the G source symbols are
	taken consecutively.
	In case of a repair packet, the G repair symbols are
	chosen randomly, as explained below.
	
</li>
</ul><p>

</p>
<p>
The system must first be initialized by creating a random permutation
of the n-k indexes.
This initialization function MUST be called immediately after creating
the parity check matrix.
More precisely, since the PRNG seed is not re-initialized, no call to
the PRNG function must have happened between the time the parity check
matrix has been initialized and the time the following initialization
function is called.
This is true both at a sender and at a receiver.

</p>
<pre>
/*
 * Initialization function.
 * Warning: use only when G > 1.
 */
initialize_tables ()
{
    int i;
    int randInd;
    int backup;

    /* initialize the two tables that map ID
     * (i.e. ESI-k) to/from TxSequence. */
    for (i = 0; i < n - k; i++) {
        IDtoTxseq[i] = i;
        txseqToID[i] = i;
    }
    /* now randomize everything */
    for (i = 0; i < n - k; i++) {
        randInd = rand(n - k);
        backup  = IDtoTxseq[i];
        IDtoTxseq[i] = IDtoTxseq[randInd];
        IDtoTxseq[randInd] = backup;
        txseqToID[IDtoTxseq[i]] =  i;
        txseqToID[IDtoTxseq[randInd]] = randInd;
    }
    return;
}
</pre><p>


</p>
<p>
It is then possible, at the sender, to determine the sequence of
G Encoding Symbol IDs that will be part of the group.

</p>
<pre>
/*
 * Determine the sequence of ESIs of the packet under construction
 * at a sender.
 * Warning: use only when G > 1.
 * PktIdx (IN):  index of the packet, in {0..ceil(n/G)} range
 * ESIs[] (OUT): list of ESI of the packet
 */
sender_find_ESIs_of_group (int      PktIdx,
                           ESI_t    ESIs[])
{
    int i;

    if (is_source_packet(PktIdx) == true) {
        /* this is a source packet */
        ESIs[0] = (PktIdx * G) % k;
        for (i = 0; i < G; i++) {
                ESIs[i] = ESIs[0] + i;
        }
    } else {
        /* this is a repair packet */
        for (i = 0; i < G; i++) {
            ESIs[i] =
                k +
                txseqToID[(i + (PktIdx - nbSourcePkts) * G)
                          % (n - k)];
        }
    }
    return;
}
</pre><p>


</p>
<p>
Similarly, upon receiving an Encoding Symbol Group (i.e. packet),
a receiver can determine the sequence of G Encoding Symbol IDs
from the first ESI, esi0, that is contained in the FEC Payload ID.

</p>
<pre>
/*
 * Determine the sequence of ESIs of a packet received.
 * Warning: use only when G > 1.
 * esi0 (IN):  : ESI contained in the FEC Payload ID
 * ESIs[] (OUT): list of ESI of the packet
 */
receiver_find_ESIs_of_group (ESI_t    esi0,
                             ESI_t    ESIs[])
{
    int i;

    if (is_source_packet(esi0) == true) {
        /* this is a source packet */
        for (i = 0; i < G; i++) {
            ESIs[i] = (esi0 + i) % k;
        }
    } else {
        /* this is a repair packet */
        for (i = 0; i < G; i++) {
            ESIs[i] =
                k +
                txseqToID[(i + IDtoTxseq[esi0 - k])
                          % (n - k)];
        }
    }
}
</pre><p>


</p>
<a name="prng"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.6"></a><h3>5.6.&nbsp;Pseudo Random Number Generator</h3>

<p>
The present FEC Encoding ID relies on a pseudo-random number
generator (PRNG) that must be fully specified, in particular in order
to enable the receivers and the senders to build the same parity
check matrix.
The minimal standard generator <a class="info" href="#Park88">[8]<span> (</span><span class="info">Park, S. and K. Miller, &ldquo;Random Number Generators: Good Ones are Hard to Find,&rdquo; 1988.</span><span>)</span></a> is used.
It defines a simple multiplicative congruential algorithm: Ij+1 = A * Ij
(modulo M), with the following choices: A = 7^^5 = 16807 and
M = 2^^31 - 1 = 2147483647.
Several implementations of this PRNG are known and discussed in
the literature. All of them provide the same sequence of pseudo
random numbers. A validation criteria of such a PRNG is the following:
if seed = 1, then the 10,000th value returned MUST be equal to 1043618065.

</p>
<p>
The following implementation uses the Park and Miller algorithm with the
optimization suggested by D. Carta in <a class="info" href="#Carta90">[9]<span> (</span><span class="info">Carta, D., &ldquo;Two Fast Implementations of the Minimal Standard Random Number Generator,&rdquo; January&nbsp;1990.</span><span>)</span></a>.

</p>
<pre>
unsigned long           seed;


/*
 * Initialize the PRNG with a seed between
 * 1 and 0x7FFFFFFE (i.e. 2^^31-2) inclusive.
 */
void srand (unsigned long s)
{
        if ((s > 0) && (s < 0x7FFFFFFF))
                seed = s;
        else
                exit(-1);
}

/*
 * Returns a random integer in [0; maxv-1]
 * Derived from rand31pmc, Robin Whittle,
 * September 20th, 2005.
 * http://www.firstpr.com.au/dsp/rand31/
 *      16807           multiplier constant (7^^5)
 *      0x7FFFFFFF      modulo constant (2^^31-1)
 * The inner PRNG produces a value between 1 and
 * 0x7FFFFFFE (2^^31-2) inclusive.
 * This value is then scaled between 0 and maxv-1
 * inclusive.
 */
unsigned long
rand (unsigned long maxv)
{
        unsigned long   hi, lo;

        lo = 16807 * (seed & 0xFFFF);
        hi = 16807 * (seed >> 16);  /* binary shift to right */
        lo += (hi & 0x7FFF) << 16; /* binary shift to left */
        lo += hi >> 15;
        if (lo > 0x7FFFFFFF)
                lo -= 0x7FFFFFFF;
        seed = (long)lo;
        /* don't use modulo, least significant bits are less random
         * than most significant bits [Numerical Recipies in C] */
        return ((unsigned long)
                ((double)seed * (double)maxv / (double)0x7FFFFFFF));
}
</pre><p>


</p>
<a name="ldpc_staircase"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;Full Specification of the LDPC-Staircase Scheme</h3>

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;General</h3>

<p>The LDPC-Staircase scheme is identified by the Fully-Specified FEC Encoding ID XX.

</p>
<p>
The PRNG used by the LDPC-Staircase scheme must be initialized by a seed.
This PRNG seed is an optional instance-specific FEC OTI element
(<a class="info" href="#scheme_specific_elt">Section&nbsp;4.2.3<span> (</span><span class="info">Scheme-Specific Element</span><span>)</span></a>).
When this PRNG seed is not carried within the FEC OTI, it is assumed that
encoder and decoders either use another way to communicate the seed value
or use a fixed, predefined value.

</p>
<a name="staircase_matrix"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;Parity Check Matrix Creation</h3>

<p>
The LDPC-Staircase matrix can be divided into two parts: 
the left side of the matrix defines in which equations the source symbols
are involved;
the right side of the matrix defines in which equations the repair symbols
are involved.

</p>
<p>
The left side is generated with the following algorithm:

</p>
<pre>
   /* initialize a list of possible choices to
    * guarantee a homogeneous "1" distribution */
   for (h = 3*k-1; h >= 0; h--) {
       u[h] = h % (n-k);
   }
   /* left limit within the list of possible choices, u[] */
   t = 0;

   for (j = 0; j < k; j++) { /* for each source symbol column */
       for (h = 0; h < 3; h++) { /* add 3 "1s" */
           /* check that valid available choices remain */
           for (i = t; i < 3*k && matrix_has_entry(u[i], j); i++);

           if (i < 3*k) {
               /* choose one index within the list of possible
                * choices */
               do {
                   i = t + rand(3*k-t);
               } while (matrix_has_entry(u[i], j));
               matrix_insert_entry(u[i], j);

               /* replace with u[t] which has never been chosen */
               u[i] = u[t];
               t++;
           } else {
               /* no choice left, choose one randomly */
               do {
                   i = rand(n-k);
               } while (matrix_has_entry(i, j));
               matrix_insert_entry(i, j);
           }
       }
   }

   /* Add extra bits to avoid rows with less than two "1s" */
   for (i = 0; i < n-k; i++) { /* for each row */
       if (degree_of_row(i) == 0) {
           j = rand(k);
           e = matrix_insert_entry(i, j);
       }
       if (degree_of_row(i) == 1) {
           do {
               j = rand(k);
           } while (matrix_has_entry(i, j));
           matrix_insert_entry(i, j);
       }
   }
</pre><p>


The right side (the staircase) is generated by the following algorithm:

</p>
<pre>
   matrix_insert_entry(0, k);    /* first row */
   for (i = 1; i < n-k; i++) {   /* for the following rows */
       matrix_insert_entry(i, k+i);   /* identity */
       matrix_insert_entry(i, k+i-1); /* staircase */
   }
</pre><p>


</p>
<p>
Note that just after creating this parity check matrix, when
encoding symbol groups are used (i.e. G &gt; 1), the
function initializing the two random permutation tables 
(<a class="info" href="#encoding_symbol_group">Section&nbsp;5.5<span> (</span><span class="info">Identifying the Symbols of an Encoding Symbol Group</span><span>)</span></a>) MUST be called.
This is true both at a sender and at a receiver.

</p>
<a name="encoding_staircase"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;Encoding</h3>

<p>
Thanks to the staircase matrix, repair symbol creation is straightforward:
each repair symbol is equal to the sum of all source symbols in the
associated equation, plus the previous repair symbol (except for the first repair symbol).
Therefore encoding MUST follow the natural repair symbol order:
start with the first repair symbol, and
generate repair symbol with ESI i before symbol ESI i+1.

</p>
<a name="decoding_staircase"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;Decoding</h3>

<p>
Decoding basically consists in solving a system of n-k linear equations
whose variables are the source an repair symbols.
Of course, the final goal is to recover the value of source symbols only.

</p>
<p>
To that purpose, many techniques are possible.
One of them is the following trivial algorithm <a class="info" href="#Zyablov74">[10]<span> (</span><span class="info">Zyablov, V. and M. Pinsker, &ldquo;Decoding Complexity of Low-Density Codes for Transmission in a Channel                  with Erasures,&rdquo; January-March&nbsp;1974.</span><span>)</span></a>:
given a set of linear equations, if one of them has only one
remaining unknown variable, then the value of this variable is
that of the constant term.
So, replace this variable by its value in all the remaining linear
equations and reiterate. The value of several variables can
therefore be found recursively.
Applied to LDPC FEC codes working over an erasure packet, the
parity check matrix defines a set of linear equations whose
variables are the source symbols and repair symbols.
Receiving or decoding a symbol is equivalent to having the
value of a variable.
<a class="info" href="#trivial_decoding">Appendix&nbsp;A<span> (</span><span class="info">Trivial Decoding Algorithm (Informative Only)</span><span>)</span></a> sketches a possible implementation
of this algorithm.

</p>
<p>
The Gauss elimination technique (or any optimized derivative) is another
possible decoding technique. Hybrid solutions that start by using the
trivial algorithm above and finish with a Gauss elimination are also
possible.

</p>
<p>
Because interoperability does not depend on the decoding algorithm used,
the current document does not recommend any particular technique.
This choice is left to the codec developer.

</p>
<p>
Yet choosing a decoding technique will have great practical impacts.
It will impact the erasure capabilities: a Gauss elimination 
technique enables to solve the system with a smaller number of symbols
compared to the trivial technique.
It will also impact the CPU load:
a Gauss elimination technique requires much more processing than
the trivial technique.
Depending on the target use case, the codec developer will
favor one feature or the other.

</p>
<a name="ldpc_triangle"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp; Full Specification of the LDPC-Triangle Scheme</h3>

<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;General</h3>

<p> LDPC-Triangle is identified by the Fully-Specified FEC Encoding ID YY.
</p>
<p>
The PRNG used by the LDPC-Triangle scheme must be initialized by a seed.
This PRNG seed is an optional instance-specific FEC OTI element
(<a class="info" href="#scheme_specific_elt">Section&nbsp;4.2.3<span> (</span><span class="info">Scheme-Specific Element</span><span>)</span></a>).
When this PRNG seed is not carried within the FEC OTI, it is assumed that
encoder and decoders either use another way to communicate the seed value
or use a fixed, predefined value.

</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;Parity Check Matrix Creation</h3>

<p>
The LDPC-Triangle matrix can be divided into two parts: 
the left side of the matrix defines in which equations the source symbols
are involved;
the right side of the matrix defines in which equations the repair symbols
are involved.

</p>
<p>
The left side is generated with the same algorithm as that of LDPC-Staircase
(<a class="info" href="#staircase_matrix">Section&nbsp;6.2<span> (</span><span class="info">Parity Check Matrix Creation</span><span>)</span></a>).

</p>
<p>
The right side (the triangle) is generated with the following algorithm:

</p>
<pre>
   matrix_insert_entry(0, k);    /* first row */
   for (i = 1; i < n-k; i++) {   /* for the following rows */
       matrix_insert_entry(i, k+i);   /* identity */
       matrix_insert_entry(i, k+i-1); /* staircase */
       /* now fill the triangle */
       j = i-1;
       for (l = 0; l < j; l++) { /* limit the # of "1s" added */
           j = rand(j);
           matrix_insert_entry(i, k+j);
       }
   }
</pre><p>


</p>
<p>
Note that just after creating this parity check matrix, when
encoding symbol groups are used (i.e. G &gt; 1), the
function initializing the two random permutation tables 
(<a class="info" href="#encoding_symbol_group">Section&nbsp;5.5<span> (</span><span class="info">Identifying the Symbols of an Encoding Symbol Group</span><span>)</span></a>) MUST be called.
This is true both at a sender and at a receiver.

</p>
<a name="encoding_triangle"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;Encoding</h3>

<p>
Here also repair symbol creation is straightforward: each repair
symbol is equal to the sum of all source symbols in the associated equation, 
plus the repair symbols in the triangle.
Therefore encoding MUST follow the natural repair symbol order:
start with the first repair symbol, and
generate repair symbol with ESI i before symbol ESI i+1.

</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4"></a><h3>7.4.&nbsp;Decoding</h3>

<p>
Decoding basically consists in solving a system of n-k linear equations,
whose variables are the source an repair symbols.
Of course, the final goal is to recover the value of source symbols only.
To that purpose, many techniques are possible, as explained in
<a class="info" href="#decoding_staircase">Section&nbsp;6.4<span> (</span><span class="info">Decoding</span><span>)</span></a>.

</p>
<p>
Because interoperability does not depend on the decoding algorithm used,
the current document does not recommend any particular technique.
This choice is left to the codec implementer.

</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;Security Considerations</h3>

<p>The security considerations for this document are the same as that
of <a class="info" href="#fec-bb-revised">[2]<span> (</span><span class="info">Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; January&nbsp;2006.</span><span>)</span></a>.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;Acknowledgments</h3>

<p><a class="info" href="#n-algorithm">Section&nbsp;5.4<span> (</span><span class="info">Determining the Number of Encoding Symbols of a Block</span><span>)</span></a> is derived from a previous Internet-Draft,
and we would like to thank S. Peltotalo and J. Peltotalo for their
contribution.
We would also like to thank Pascal Moniot, Laurent Fazio,
Aurelien Francillon and Shao Wenjian for their comments.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[1]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; RFC&nbsp;2119, BCP&nbsp;14, March&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="fec-bb-revised">[2]</a></td>
<td class="author-text">Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; &nbsp;draft-ietf-rmt-fec-bb-revised-03.txt (work in progress), January&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3453">[3]</a></td>
<td class="author-text">Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;<a href="ftp://ftp.isi.edu/in-notes/rfc3453.txt">The Use of Forward Error Correction (FEC) in Reliable Multicast</a>,&rdquo; RFC&nbsp;3453, December&nbsp;2002.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="Roca04">[4]</a></td>
<td class="author-text">Roca, V. and C. Neumann, &ldquo;Design, Evaluation and Comparison of Four
		Large Block FEC Codecs: LDPC, LDGM, LDGM-Staircase and LDGM-Triangle, Plus
		a Reed-Solomon Small Block FEC Codec,&rdquo; &nbsp;INRIA Research Report RR-5225, June&nbsp;2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="Neumann05">[5]</a></td>
<td class="author-text">Neumann, C., Roca, V., Francillon, A., and D. Furodet, &ldquo;Impacts of Packet Scheduling and Packet Loss Distribution on FEC Performances: Observations and Recommendations,&rdquo; &nbsp;ACM CoNEXT'05 Conference, Toulouse, France
		(an extended version is available as INRIA Research Report RR-5578), October&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="LDPCrefimpl">[6]</a></td>
<td class="author-text">Roca, V., Neumann, C., and J. Laboure, &ldquo;LDPC-Staircase/LDPC-Triangle Codec Reference Implementation,&rdquo; &nbsp;INRIA Rhone-Alpes and STMicroelectronics, http://planete-bcast.inrialpes.fr/.</td></tr>
<tr><td class="author-text" valign="top"><a name="Mac03">[7]</a></td>
<td class="author-text">MacKay, D., &ldquo;Information Theory, Inference and Learning Algorithms,&rdquo; Cambridge University Press,&nbsp;ISBN: 0521642981, 2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="Park88">[8]</a></td>
<td class="author-text">Park, S. and K. Miller, &ldquo;Random Number Generators: Good Ones are Hard to Find,&rdquo; &nbsp;Communications of the ACM, Vol. 31, No. 10, pp.1192-1201, 1988.</td></tr>
<tr><td class="author-text" valign="top"><a name="Carta90">[9]</a></td>
<td class="author-text">Carta, D., &ldquo;Two Fast Implementations of the Minimal Standard Random Number Generator,&rdquo; &nbsp;Communications of the ACM, Vol. 33, No. 1, pp.87-88, January&nbsp;1990.</td></tr>
<tr><td class="author-text" valign="top"><a name="Zyablov74">[10]</a></td>
<td class="author-text">Zyablov, V. and M. Pinsker, &ldquo;Decoding Complexity of Low-Density Codes for Transmission in a Channel
                 with Erasures,&rdquo; &nbsp;Translated from Problemy Peredachi Informatsii, Vol.10, No. 1, pp.15-28, January-March&nbsp;1974.</td></tr>
</table>

<a name="trivial_decoding"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;Trivial Decoding Algorithm (Informative Only)</h3>

<p>
A trivial decoding algorithm is sketched below (please see <a class="info" href="#LDPCrefimpl">[6]<span> (</span><span class="info">Roca, V., Neumann, C., and J. Laboure, &ldquo;LDPC-Staircase/LDPC-Triangle Codec Reference Implementation,&rdquo; .</span><span>)</span></a>
for the details omitted here):

</p>
<pre>
  Initialization: allocate a table of partial sum buffers:
                  partial_sum[n-k], one per equation;
                  Reset all the buffers to 0;

  /*
   * For each newly received or decoded symbol, try to make progress
   * in the decoding of the associated source block.
   * new_esi  (IN):  ESI of the new symbol, which is also the index
   *                 in [0; n-1]
   * new_symb (IN):  New symbol received or decoded
   */
  void
  decoding_step(ESI_t     new_esi,
                symbol_t  *new_symb)
  {
      If (new_symb is an already decoded or received symbol) {
          Return;        /* don't waste time with this symbol */
      }

      If (new_symb is the last missing source symbol) {
          Return;        /* decoding is now finished */
      }

      Create an empty list of equations having symbols decoded during
      this decoding step;

      /*
       * First add this new symbol to all partial sums of the
       * associated equations.
       */
      For (each equation eq in which new_symb is a variable and
           having more than one unknown variable) {

          Add new_symb to partial_sum[eq];

          Remove entry(eq, new_esi) from the H matrix;

          If (degree of equation eq == 1) {
              /* new symbol can be decoded, remember the equation */
              Append eq to the list of equations having symbols
              decoded during this decoding step;
          }
      }

      /*
       * Then finish with recursive calls to decoding_step() for each
       * newly decoded symbols.
       */
      For (each equation eq in the list of equations having symbols
           decoded during this decoding step) {

          /*
           * Because of the recursion below, we need to check that
           * decoding is not finished, and that the equation is
           * __still__ of degree 1
           */
          If (decoding is finished) {
              break;        /* exit from the loop */
          }

          If ((degree of equation eq == 1) {
              Let dec_esi be the ESI of the newly decoded symbol in
              equation eq;

              Remove entry(eq, dec_esi);

              Allocate a buffer, dec_symb, for this symbol, and
              copy partial_sum[eq] to dec_symb;

              /* finally, call this function recursively */
              decoding_step(dec_esi, dec_symb);
          }
      }
  }
</pre><p>


</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Vincent Roca</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">INRIA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">655, av. de l'Europe</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Zirst; Montbonnot</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">ST ISMIER cedex  38334</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:vincent.roca@inrialpes.fr">vincent.roca@inrialpes.fr</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://planete.inrialpes.fr/~roca/">http://planete.inrialpes.fr/~roca/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Christoph Neumann</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Thomson Research</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">46, Quai A. Le Gallo</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Boulogne Cedex  92648</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:christoph.neumann@thomson.net">christoph.neumann@thomson.net</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://planete.inrialpes.fr/~chneuman/">http://planete.inrialpes.fr/~chneuman/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">David Furodet</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">STMicroelectronics</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">12, Rue Jules Horowitz</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">BP217</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Grenoble Cedex  38019</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:david.furodet@st.com">david.furodet@st.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.st.com/">http://www.st.com/</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Intellectual Property Statement</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
<h3>Disclaimer of Validity</h3>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY),
THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM
ALL WARRANTIES,
EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</p>
<h3>Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The Internet Society (2006).
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<h3>Acknowledgment</h3>
<p class='copyright'>
Funding for the RFC Editor function is currently provided by the
Internet Society.</p>
</body></html>
