<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
        <!ENTITY rfc2277 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2277.xml">
        <!ENTITY rfc2119 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
        <!ENTITY rfc2781 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2781.xml">
        <!ENTITY rfc5321 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5321.xml">
        <!ENTITY rfc3261 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
        <!ENTITY rfc3263 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3263.xml">
        <!ENTITY rfc3629 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml">
        <!ENTITY rfc3688 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3688.xml">
        <!ENTITY rfc3986 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
        <!ENTITY rfc6116 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6116.xml">
        <!ENTITY rfc4725 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4725.xml">
        <!ENTITY rfc5067 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5067.xml">
        <!ENTITY rfc4949 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml">
        <!ENTITY rfc5486 PUBLIC ""
          "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5486.xml">
		<!ENTITY I-D.ietf-drinks-usecases-requirements SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-drinks-usecases-requirements.xml">
		
		<!ENTITY I-D.ietf-drinks-sppp-over-soap SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-drinks-sppp-over-soap.xml">
		
]>


<rfc category="std" docName="draft-ietf-drinks-spprov-11"
  ipr="trust200902">

  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <?rfc toc="yes" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc iprnotified="no" ?>
  <?rfc strict="yes" ?>

  <front>
    <title abbrev="draft-drinks-spprov"> Session Peering Provisioning
      Protocol Data Model</title>

    <author initials="J-F.M." surname="Mule"
      fullname="Jean-Francois Mule">
      <organization>CableLabs </organization>
      <address>
                        <postal>
                                <street>858 Coal Creek Circle</street>
                                <city>Louisville</city> <region>CO</region> 
                                <code>80027</code>
                                <country>USA</country>
                        </postal>
                        <email>jfm@cablelabs.com</email>
                </address>
    </author>

    <author initials="K.C." surname="Cartwright"
      fullname="Kenneth Cartwright">
      <organization>TNS</organization>
      <address>
                        <postal>
                                <street>1939 Roland Clarke Place</street>
                                <city>Reston</city> <region>VA</region> 
                                <code>20191</code>
                                <country>USA</country>
                        </postal>
                        <email>kcartwright@tnsi.com</email>
                </address>
    </author>

    <author initials="S.A." surname="Ali" fullname="Syed Wasim Ali">
      <organization>NeuStar</organization>
      <address>
                        <postal>
                                <street>46000 Center Oak Plaza</street>
                                <city>Sterling</city> <region>VA</region> 
                                <code>20166</code>
                                <country>USA</country>
                        </postal>
                        <email>syed.ali@neustar.biz</email>
                </address>
    </author>

    <author initials="A.M." surname="Mayrhofer"
      fullname="Alexander Mayrhofer">
      <organization>enum.at GmbH</organization>
      <address>
                        <postal>
                                <street>Karlsplatz 1/9</street>
                                <city>Wien</city> <region> </region> 
                                <code>A-1010</code>
                                <country>Austria</country>
                        </postal>
                        <email>alexander.mayrhofer@enum.at</email>
                </address>
    </author>

    <date year="2011" />

    <area>Real-time Applications and Infrastructure Area</area>

    <workgroup>DRINKS</workgroup>

    <abstract>
      <t> This document specifies the data model and the overall structure for 
      a protocol to provision session establishment data into Session Data Registries and SIP
        Service Provider data stores. The protocol is called the Session Peering Provisioning
        Protocol (SPPP).  The provisioned data is typically used by network elements for session
        peering. </t>
    </abstract>
  </front>

  <middle>
    <!--  Note: this is how you can put a note in the draft for yourself or for the co-authors to check on -->
    <section anchor="introduction" title="Introduction">
      <t> Service providers and enterprises use registries to make
        session routing decisions for Voice over IP, SMS and
        MMS traffic exchanges. This document is narrowly focused on
        the provisioning protocol for these registries. This protocol
        prescribes a way for an entity to provision session-related
        data into a registry. The data being provisioned can be
        optionally shared with other participating peering entities.
        The requirements and use cases driving this protocol have been
        documented in <xref
          target="I-D.ietf-drinks-usecases-requirements"/>. The reader
        is expected to be familiar with the terminology defined in the
        previously mentioned document. <vspace blankLines="1"/> Three
        types of provisioning flows have been described in the use
        case document: client to registry provisioning, registry to
        local data repository and registry to registry. This document
        addresses client to registry aspect to fulfill the need to provision 
        Session Establishment Data (SED). The protocol that supports flow of
        messages to facilitate client to registry provisioning is referred 
        to as Session Peering Provisioning Protocol (SPPP).</t>

        <t>Please note that the role of the "client" and the "server" only
          applies to the connection, and those roles are not related
          in any way to the type of entity that participates in a
          protocol exchange. For example, a registry might also
          include a "client" when such a registry initiates a
          connection (for example, for data distribution to SSP). </t>

      <t>
        <figure align="center" anchor="RegFlows">
          <artwork align="center">
            <![CDATA[
*--------*               *------------*               *------------*
|        | (1). Client   |            | (3).Registry  |            |
| Client | ------------> |  Registry  |<------------->|  Registry  | 
|        |   to Registry |            |  to Registry  |            |
*--------*               *------------*               *------------*
                              /  \                          \
                             /    \                          \
                            /      \                          \
                           /        \                          v
                          /          \                         ...
                         /            \
                        / (2). Distrib \
                       / Registry data  \
                      /  to local data   \
                     V      store         V
                    +----------+       +----------+
                    |Local Data|       |Local Data|
                    |Repository|       |Repository|
                    +----------+       +----------+
                       ]]>
          </artwork>
          <postamble> Three Registry Provisioning Flows </postamble>
        </figure>
      </t>

      <t>The data provisioned for session establishment is typically
        used by various downstream SIP signaling systems to route a
        call to the next hop associated with the called domain. These
        systems typically use a local data store ("Local Data
        Repository") as their source of session routing information.
        More specifically, the SED data is the set of parameters that
        the outgoing signaling path border elements (SBEs) need to
        initiate the session. See <xref target="RFC5486"/> for more
        details. <vspace blankLines="1"/> A "terminating" SIP Service
        Provider (SSP) provisions SED into the registry to be
        selectively shared with other peer SSPs. Subsequently, a
        registry may distribute the provisioned data into local data
        repositories used for look-up queries (identifier -> URI) or
        for lookup and location resolution (identifier -> URI ->
        ingress SBE of terminating SSP). In some cases, the registry
        may additionally offer a central query resolution service (not
        shown in the above figure). </t>
      <t> A key requirement for the SPPP protocol is to be able to
        accommodate two basic deployment scenarios: <list
          style="numbers">
          <t> A resolution system returns a Look-Up Function (LUF) that 
            comprises of the target domain
            to assist in call routing (as described in <xref
              target="RFC5486"/>). In this case, the querying entity
            may use other means to perform the Location Routing
            Function (LRF) which in turn helps determine the actual
            location of the Signaling Function in that domain. </t>
          <t> A resolution system returns both a Look-Up function (LUF)
             and Location Routing Function (LRF) to locate the SED data fully. </t>
        </list>
      </t>

      <t> In terms of protocol design, SPPP is agnostic to
        the transport. This document includes the specification of the
        data model and identifies, but does not specify, the means to enable 
        protocol operations within a request and response structure.  That aspcect 
        of the specificaiton has been delegated to the "transport" specification 
        for the protocol.  To encourage
        interoperability, the protocol supports extensibility aspects. </t>
      <t> Transport requirements are provided in this document to help
        with the selection of the optimum transport mechanism. (<xref
          target="I-D.ietf-drinks-sppp-over-soap"/>) identifies a SOAP
        transport mechanism for SPPP. </t>
      <t> This document is organized as follows: <list style="symbols"
          hangIndent="5">
          <t>
            <xref target="terminology"/> provides the terminology; 
          </t>
          <t>
            <xref target="highleveldesign"/> provides an overview
            of SPPP, including the functional entities and data model; </t>
          <t>
            <xref target="transportreq"/> specifies requirements for
            SPPP transport protocols; </t>
          <t>
            <xref target="basicdatastructures"/> describes the base protocol 
            data structures, the generic response codes and messages, 
            and the basic object type most first class objects extend from;</t>
          <t>
            <xref target="protocolDataModelObjects"/> detailed descriptoins of 
            the data model object specifications;</t>
          <t>
            <xref target="xmlconsiderations"/> defines XML
            considerations that XML parsers must meet to conform to
            this specification; </t> 
           <t><xref target="formalspecification"/> normatively defines the SPPP 
           protocol using its XML Schema Definition. 
           </t>
        </list>
      </t>
    </section>

    <section anchor="terminology" title="Terminology">
      <t> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described
        in <xref target="RFC2119"/>. </t>
      <t> This document reuses terms from <xref target="RFC3261"/>,
          <xref target="RFC5486"/>, use cases and requirements
        documented in <xref
          target="I-D.ietf-drinks-usecases-requirements"/> and the
        ENUM Validation Architecture <xref target="RFC4725"/>. </t>
      <t> In addition, this document specifies the following
        additional terms: <vspace blankLines="1"/>
        <list style="hanging">
          <t hangText="SPPP: "> Session Peering Provisioning Protocol,
            the protocol used to provision data into a Registry (see
            arrow labeled "1." in Figure 1 of <xref
              target="I-D.ietf-drinks-usecases-requirements"/>). It is
            the primary scope of this document. <vspace blankLines="1"
            />
          </t>
          <t hangText="SPDP: "> Session Peering Distribution Protocol,
            the protocol used to distribute data to Local Data
            Repository (see arrow labeled "2." in Figure 1 of <xref
              target="I-D.ietf-drinks-usecases-requirements"/>).
              <vspace blankLines="1"/>
          </t>
          <t hangText="Client: "> An application that supports an SPPP
            client; it is sometimes referred to as a "registry
            client". <vspace blankLines="1"/>
          </t>
          <t hangText="Registry: "> The Registry operates a master
            database of Session Establishment Data for one or more
            Registrants. <vspace blankLines="1"/>A Registry acts as an SPPP server. <vspace blankLines="1"/>
          </t>
          <t hangText="Registrant: "> In this document we extend the
            definition of a Registrant based on <xref target="RFC4725"
            />. The Registrant is the end-user, the person or
            organization that is the "holder" of the Session
            Establishment Data being provisioned into the Registry by a Registrar.
            For example, in <xref
              target="I-D.ietf-drinks-usecases-requirements"/>, a
            Registrant is pictured as a SIP Service Provider in Figure
            2. <vspace blankLines="1"/> Within the confines of a Registry, a Registrant is uniquely identified by a well-known ID.<vspace blankLines="1"/>
          </t>
          <t hangText="Registrar: "> In this document we extend
            the definition of a Registrar from <xref target="RFC4725"
            />. A Registrar is an entity that performs provisioning operations on behalf
            of a Registrant by interacting with the Registry via SPPP 
            operations.  In other words the Registrar is the SPPP Client.  The Registrar 
            and Registrant roles are logically separate to allow, but not require, a single Registrar to 
            perform provisioning operations on behalf of more than one Registrant.
          </t>
          <t hangText="Peering Organization: "> A Peering Organization is 
          an entity to which a Registrant's Route Groups are made visible using 
          the operations of SPPP.
          </t>
        </list>
      </t>
    </section>

    <section anchor="highleveldesign" title="Protocol High Level Design">
      <t> This section introduces the structure of the data model and
        provides the information framework for the SPPP. An
        overview of the protocol operations is first provided with a
        typical deployment scenario. The data model is then defined
        along with all the objects manipulated by the protocol and
        their relationships. </t>

      <section anchor="datamodel" title="Protocol Data Model">
        <t> The data model illustrated and described in <xref
            target="SPPP_datamodel"/> defines the logical objects and
          the relationships between these objects that the SPPP
          protocol supports. SPPP defines the protocol operations
          through which an SPPP client populates a registry with these
          logical objects. Various clients belonging to different
          registrars may use the protocol for populating the
          registry's data. </t>
        
          <t> The logical structure presented below is consistent with
            the terminology and requirements defined in <xref
              target="I-D.ietf-drinks-usecases-requirements"/>. </t>

          <figure align="center" anchor="SPPP_datamodel">
            <preamble> </preamble>
            <artwork align="center"><![CDATA[
+-------------+      +------------------+
| all object  |      |Organization:     |
| types       |----->|orgId             |
+------+------+      |                  |
 All objects are     +------------------+
 associated with an      ^
 organization to         |A Route Group is
 identify the            |associated with        +-----[abstract]-+
 object's registrant	 |zero or more Peering   | Route Record:  |
                         |Organizations          |  rrName,       |
                         |                       |  priority,     |
                +--------+--------------+        |  extension     |
                |Route Group:           |------->|                |
                |  rant,                |        +----------------+
                |  rgName,              |            ^
                |  destGrpRef,          |            |
                |  isInSvc,             |            |Various types
                |  rrRef,               |            |of Route
                |  peeringOrg,          |            |Records...
                |  sourceIdent,         |      +-----+------------+
                |  priority,            |      |        |         |
                |  extension            |   +----+  +-------+ +----+    
                +-----------------------+   | URI|  | NAPTR | | NS | 
                   |                        +----+  +-------+ +----+
                   |
                   |              +----------[abstract]-+          
                   |              |Public Identifier:   |
                   |              |                     |
                   |              |  rant,              |
                   v              |  publicIdentifier,  |
     +----------------------+     |  destGrpRef,        |
     | Dest Group:          |<----|  rrRef,             |
     |   rant,              |     |  extension          |
     |   dgName,            |     +---------------------+
     |   extension          |                ^             
     +----------------------+                |Various types
                                             |of Public     
                                             |Identifiers...   
                          +---------+-------+------------...
                          |         |       |     |
                      +------+  +-----+  +-----+ +-----+
                      |  TN  |  | TNP |  | TNR | | RN  |
                      +------+  +-----+  +-----+ +-----+
]]></artwork>
            <postamble> SPPP Data Model </postamble>
          </figure>

          <t> The objects and attributes that comprise the data model
            can be described as follows (objects listed from the
            bottom up): <list style="symbols">
                <t> Public Identifier: <vspace blankLines="0"/> 
                From a broad perspective a public identifier is a well-known
                attribute that is used as the key to perform resolution 
                lookups. Within the context of SPPP, a public identifier 
                object can be a telephone number, a range of telephone 
                numbers, a PSTN Routing Number (RN), or a TN prefix. <vspace blankLines="1"/> 
                An SPPP Public Identifier is associated with a Destination Group to
                create a logical grouping of Public Identifiers that share a common set of
                Routes. <vspace blankLines="1"/> A TN Public Identifier
                may optionally be associated with zero or more
                individual Route Records. This ability for a Public
                Identifier to be directly associated with a set of Route
                Records (e.g. target URI), as opposed to being
                associated with a Destination Group, supports the use
                cases where the target URI contains data specifically
                tailored to an individual TN Public Identifier. </t> 
                <t> Destination Group: <vspace blankLines="0"/> 
                A named collection of zero or more Public Identifiers that 
                can be associated with one or more Route Groups for the 
                purpose of facilitating the management of their common 
                routing information. </t>
                <t> Route Group: <vspace blankLines="0"/>
                A Route Group contains a set of Route Record references, 
                a set of Destination Group references, and a set of 
                peering organization identifiers.  This is used to 
                establish a three part relationships between a set of 
                Public Identifiers, the routing information 
                (SED) shared across the Public Identifiers, and the list of peering organizations whose query 
                responses from the resolution system may include the routing information from a given route group. In addition, the sourceIdent element within a Route 
                Group, in concert with the set of peering organization 
                identifiers, enables fine-grained source based routing.  
                For further details about the Route Group and source based routing, 
                refer to the definitions and descriptions of the Route 
                Group operations found later in this document. </t>           
                <t> Route Record: <vspace blankLines="0"/>
                A Route Record contains the data that a resolution system 
                returns in response to a successful query for a Public 
                Identifier.  Route Records are generally associated with a Route 
                Group when the SED within is not specific to a Public Identifier. 
                <vspace blankLines="0"/> To support the use cases defined in 
                <xref target="I-D.ietf-drinks-usecases-requirements"/>, 
                SPPP defines three type of Route Records:
                URIType, NAPTRType, and NSType. These Route Records
                extend the abstract type RteRecType and inherit the
                common attribute 'priority' that is meant for setting
                precedence across the route records defined within a
                Route Group in a protocol agnostic fashion. </t> 
                <t> Organization: <vspace blankLines="0"/> An
                Organization is an entity that may fulfill the role of a 
                registrant or a peering organization.  All SPPP objects are 
                associated with an organization identifier to identify 
                each object's registrant, while tracking the identity 
                of the registrar that provisioned each SPPP object is 
                left as a matter of policy for an SPPP implementation. 
                A Route Group object is also associated with a set of zero 
                or more organization identifiers that identify the peering  
                organization(s) whose resolution query responses may include 
                the routing information (SED) defined in the Route Records 
                within that Route Group. A peering organization is an entity that the registrant intends to share the SED data with. A route group SPPP object is associated with a set of zero or more organization identifiers that identify the peering organizations whose resolution query responses may include the routing information (SED) defined in the route records within that route group.</t>
            </list>
          </t>
     
       </section>
       
      <section anchor="timestamp" title="Time Value">
        <t>Some SPPP request and response messages include time value(s) defined as type xs:dateTime, a built-in W3C XML Schema Datatype. Use of unqualified local time value is discouraged as it can lead to interoperability issues. The value of time attribute MUST BE expressed in Coordinated Universal Time (UTC) format without the timezone digits.</t>
        <t>&quot;2010-05-30T09:30:10Z&quot; is an example of an acceptable time value for use in SPPP messages. &quot;2010-05-30T06:30:10+3:00&quot; is a valid UTC time, but it is not approved for use in SPPP messages.</t>
      </section>

    </section>

    <section anchor="transportreq" title="Transport Protocol Requirements">

      <t> This section provides requirements for transport protocols
        suitable for SPPP. More specifically, this section specifies
        the services, features, and assumptions that SPPP delegates to
        the chosen transport and envelope technologies. </t>

      <section anchor="transpconnreq" title="Connection Oriented">
        <t> The SPPP follows a model where a client
          establishes a connection to a server in order to further
          exchange SPPP messages over such point-to-point
          connection. A transport protocol for SPPP MUST therefore be
          connection oriented. </t>
      </section>

      <section anchor="requestresponse"
        title="Request and Response Model">

        <t> Provisioning operations in SPPP follow the request-response
          model, where a client sends a request message to initiate a transaction 
          and the server responds with a response.
          Multiple subsequent request-response exchanges MAY be
          performed over a single persistent connection. </t>
        <t> Therefore, a transport protocol for SPPP MUST follow the
          request-response model by allowing a response to be sent to
          the request initiator.</t>
      </section>

      <section anchor="connectionlength" title="Connection Lifetime">
        <t> Some use cases involve provisioning a single request to a
          network element. Connections supporting such provisioning
          requests might be short-lived, and may be established only on
          demand. Other use cases involve either provisioning a large dataset, 
          or a constant stream of small updates, either of which would likely
          require long-lived connections. </t>
        <t> Therefore, a protocol suitable for SPPP SHOULD be able to support
          both short-lived as well as long-lived connections. </t>
      </section>

      <section anchor="authentication" title="Authentication">
        <t> All SPPP objects are associated with a registrant identifier. SPPP Clients   
          provisions SPPP objects on behalf of registrants.  An authenticated SPP Client is a registrar.  Therefore, the SPPP transport protocol MUST provide means for an SPPP server to authenticate an SPPP Client.  </t>
      </section>

      <section anchor="authorization" title="Authorization">
        <t>After successful authentication of the SPPP client as a registrar the registry performs authorization checks to determine if the registrar is authorized to act on behalf of the 
          Registrant whose identifier is included in the SPPP request.  Refer to the Security Considerations section for further guidance.  
        </t>
      </section>

      <section anchor="confidentiality"
        title="Confidentiality and Integrity">
<t>In some deployments, the SPPP objects that an SPPP registry manages can be private in nature.  As a result it MAY NOT be appropriate to for transmission in plain text over a connection to the SPPP registry. Therefore, the transport protocol SHOULD provide means for end-to-end encryption between the SPPP client and server.</t>

<t>For some SPPP implementations, it may be acceptable for the data to be transmitted in plain text, but the failure to detect a change in data after it leaves the SPPP client and before it is received at the server, either by accident or with a malicious intent, will adversely affect the stability and integrity of the registry. Therefore, the transport protocol SHOULD provide means for data integrity protection.</t>
      </section>

      <section anchor="timing" title="Near Real Time">
        <t> Many use cases require near real-time responses from the
          server. Therefore, a DRINKS transport protocol MUST support
          near real-time response to requests submitted by the client.
        </t>
      </section>

      <section anchor="respsizes" title="Request and Response Sizes">
        <t>Use of SPPP may involve simple updates that may consist of small number of bytes, such as, update of a single public identifier. Other provisioning operations may constitute large number of datasets as in adding millions records to a registry. As a result, a suitable transport protocol for SPPP SHOULD accommodate datasets of various sizes.</t>
      </section>

      <section anchor="reqorder"
        title="Request and Response Correlation">
        <t> A transport protocol suitable for SPPP MUST allow
          responses to be correlated with requests. </t>
      </section>

      <section anchor="ack" title="Request Acknowledgement">
        <t> Data transported in the SPPP is likely crucial
          for the operation of the communication network that is being
          provisioned. A SPPP client responsible for provisioning SED to the registry
          has a need to know if the submitted requests have been processed 
          correctly.</t>
        <t>Failed transactions
          can lead to situations where a subset of public identifiers
          or even SSPs might not be reachable, or
          the provisioning state of the network is inconsistent. </t>
        <t> Therefore, a transport protocol for SPPP MUST provide a
          response for each request, so that a client can identify
          whether a request succeeded or failed. </t>
      </section>

      <section anchor="mandatorytransport" title="Mandatory Transport">
        <t>At the time of this writing, a choice of transport protocol has been provided in <xref target="I-D.ietf-drinks-sppp-over-soap"/>. To encourage interoperability, the SPPP server MUST provide support for this transport protocol. With time, it is possible that other transport layer choices may surface that agree with the requirements discussed above.</t>
      </section>

    </section>
    
    <section anchor="basicdatastructures" title="Base Protocol Data Structures">

       <t>SPPP contains some common data structures for most of the supported object types.  
       This section describes these common data structures.</t>
       
       <section anchor="BasicObjType" title="Basic Object Type and Organization Identifiers">
       		<t> This section introduces the basic object type that most first 
       		class objects derive from. </t>
       		<t> All first class objects extend the basic object type 
       		   BasicObjType that contains the identifier of the 
              registrant organization that owns this object, the identifier of the 
              registrar organization that created this object, the date 
              and time that the object was created 
              by the server, and the date and time that the object 
              was last modified.</t>
        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[
	<complexType name="BasicObjType" abstract="true">
		<sequence>
			<element name="rant" type="spppb:OrgIdType"/>
			<element name="rar" type="spppb:OrgIdType"/>
			<element name="cDate" type="dateTime" 
			   minOccurs="0"/>
			<element name="mDate" type="dateTime" 
			   minOccurs="0"/>
			<element name="ext" type="spppb:ExtAnyType" 
			   minOccurs="0"/>
		</sequence>
	</complexType>
                        ]]>
            </artwork>
          </figure>
        </t>
        
        <t>
        	The identifiers used for registrants (rant), registrars (rar), 
        	and peering organizations (peeringOrg) are instances of 
        	OrgIdType. The OrgIdType is defined as a string and all 
        	OrgIdType instances SHOULD follow the textual 
        	convention: "namespace:value" (for example "iana-en:32473").  See 
        	the IANA Consideration section for more details.
        </t>

   	  </section>
  	
  	  <section anchor="ObjKeyType" title="Object Key Type">
  	    <t> The SPPP data model contains some object relationships.  In some cases these object 
  	    relationships are established by embedding the unique identity of the related object 
  	    inside the relating object.  The abstract type called ObjKeyType is where this unique 
  	    identity is housed.  Because this objec type is abstract, it MUST be specifid in a concrete 
  	    form in any conforming SPPP "transport specification".  This may also be used in query/getter 
  	    operaitons.</t>

        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[

		<complexType name="ObjKeyType" abstract="true">
			<annotation>
				<documentation>
				  -- Generic type that represents the 
				  key for various objects in SPPP. --
				</documentation>
			</annotation>
		</complexType>
                        ]]>
            </artwork>
          </figure>
        </t>
		
      </section>
      
  	</section>

    <section anchor="protocolDataModelObjects" title="Protocol Data Model Objects">
      <t> This section provides a description of the specification of each supported data model object (the nouns) and 
      identifies the commands (the verbs) that MUST be supported for each data model object. However,
      the specification of the data structures necessary to support each command is delegated to the 
      transport specification.</t>

      <section anchor="destGroup" title="Destination Group">
        <t> As described in the introductory sections, a Destination Group
          represents a set of Public Identifiers with common routing information. The transport 
          protocol MUST support the ability to Create, Modify, Get, and Delete Destination Groups.  
          The DestGrpType object structure is defined as follows: </t>

        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[
  <complexType name="DestGrpType">
    <complexContent>
     <extension base="spppb:BasicObjType">
      <sequence>
         <element name="dgName" type="spppb:ObjNameType"/>
      </sequence>
     </extension>
    </complexContent>
  </complexType>
                        ]]>
            </artwork>
          </figure>
        </t>

        <t>The DestGrpType object is composed of the following
          elements: <list style="symbols" hangIndent="5">
            <t> base: All first class objects extend  
              BasicObjType that contains the ID of the 
              registrant organization that owns this object,
              the date and time that the object was created 
              by the server, and the date and time that the object 
              was last modified. If the client passed in either the 
              created date or the modification date, the server will 
              ignore them.  The server sets these two date/time values.</t>
            <t> dgName: The character string that contains the
              name of the Destination Group. This uniquely identifies this
              object within the context of the registrant ID (a child
              element of the base element as described above). </t>
            <t> ext: Point of extensibility described in a previous
              section of this document. </t>
          </list>
        </t>
      </section>


      <section anchor="pubId" title="Public Identifier">

        <t>A Public Identifier is the search key used for locating the session 
        establishment data (SED).  In many cases, a Public Identifier is attributed 
        to the end user who has a retail relationship with the service provider or 
        registrant organization.  SPPP supports the notion of the carrier-of-record 
        as defined in <xref target="RFC5067"/>.  Therefore, the registrant under whom the Public 
        Identity is being created can optionally claim to be a carrier-of-record.</t>

        <t>SPPP identifies two types of Public Identifiers: telephone numbers (TN), 
        and the routing numbers (RN). SPPP provides structures to manage a single 
        TN, a contiguous range of TNs, and a TN prefix.   The transport protocol 
        MUST support the ability to Create, Modify, Get, and Delete Public Identifiers.</t>

        <t>The abstract XML schema type definition PubIDType is a generalization 
        for the concrete the Public Identifier schema types. PubIDType element 'dgName' 
        represents the name of the destination group that a given Public Identifier is 
        a member of.  Because a Destination Group is uniquely identified by its 
        composite business key, which is comprised of its registrant ID, rantId, 
        and its name, dgName, the Public Identity's containing Destination Group 
        is identified by the Public Identity's dgName element and the Public 
        Identity's registrant ID, rantId, element.  The PubIDType object structure 
        is defined as follows:</t>

        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[
  <complexType name="PubIdType" abstract="true">
    <complexContent>
     <extension base="spppb:BasicObjType">
       <sequence>
         <element name="dgName" type="spppb:ObjNameType" 
            minOccurs="0"/>
       </sequence>
     </extension>
    </complexContent>
  </complexType>
              ]]> 
           </artwork>
          </figure>
        </t>

          <t>A Public Identifier may be provisioned as a member of a Destination Group or 
          provisioned outside of a Destination Group.  A Public Identifier that 
          is provisioned as a member of a Destination Group is intended to be 
          associated with its SED through the Route Group(s) that are associated 
          with its containing Destination Group.  A Public Identifier that is not 
          provisioned as a member of a Destination Group is intended to be 
          associated with its SED through the Route Records that are directly 
          associated with the Public Identifier.</t>

          <t>A telephone number is provisioned using the TNType, an extension of 
          PubIDType. Each TNType object is uniquely identified by the combination 
          of its <![CDATA[<tn>]]> element, and the unique key of its parent Destination Group 
          (dgName and rantId).  In other words a given telephone number string 
          may exist within one or more Destination Groups, but must not exist 
          more than once within a Destination Group.  TNType is defined as follows: </t>

          <t>
            <figure title="">
              <artwork align="left">
                <![CDATA[
    <complexType name="TNType">
	  <complexContent>
	    <extension base="spppb:PubIdType">
		  <sequence>
		    <element name="tn" type="spppb:NumberType"/>
		    <element name="rrRef" type="spppb:RteRecRefType" 
			  minOccurs="0" maxOccurs="unbounded"/>
		    <element name="corInfo" type="spppb:CORInfoType" 
			  minOccurs="0"/>
		  </sequence>
	    </extension>
	   </complexContent>
	</complexType>
	
	<simpleType name="NumberType">
		<restriction base="token">
			<maxLength value="20"/>
			<pattern value="\+?\d\d*"/>
		</restriction>
	</simpleType>

              ]]> 
              </artwork>
            </figure>
          </t>          

          <t>TNType consists of the following attributes:
            <list style="symbols" hangIndent="5">
              <t>tn: Telephone number to be added to the registry.</t>
              <t>rrRef: Optional reference to route records that are directly 
              associated with the TN Public Identifier. Following the SPPP 
              data model, the route record could be a protocol agnostic 
              URIType or another type.</t>
              <t>corInfo: corInfo is an optional parameter of type 
              CORInfoType that allows the registrant organization to 
              set forth a claim to be the carrier-of-record (see <xref target ="RFC5067"/>).
              This is done by setting the value of &lt;corClaim&gt; element 
              of the CORInfoType object structure to &quot;true&quot;. The 
              other two parameters of the CORInfoType, &lt;cor&gt; 
              and &lt;corDate&gt; are set by the registry to describe the 
              outcome of the carrier-of-record claim by the registrant. 
              In general, inclusion of &lt;corInfo&gt; parameter is useful 
              if the registry has the authority information, such as, the 
              number portability data, etc., in order to qualify whether 
              the registrant claim can be satisfied. If the carrier-of-record 
              claim disagrees with the authority data in the registry, whether 
              the TN add operation fails or not is a matter of policy and it 
              is beyond the scope of this document. In the response 
              message &lt;spppUpdateResponse&gt;, the SPPP server must 
              include the &lt;cor&gt; parameter of the &lt;corInfo&gt; element 
              to let the registrant know the outcome of the claim.</t>
            </list>
          </t>
          
          <t>A routing number is provisioned using the RNType, an 
          extension of PubIDType. SSPs that possess the number 
          portability data may be able to leverage the RN search 
          key to discover the ingress routes for session establishment. 
          Therefore, the registrant organization can add the RN and 
          associate it with the appropriate destination group to share 
          the route information.  Each RNType object is uniquely 
          identified by the combination of its <![CDATA[<rn>]]> element, and the 
          unique key of its parent Destination Group (dgName and rantId).  
          In other words a given routing number string may exist within one 
          or more Destination Groups, but must not exist more than once 
          within a Destination Group.  RNType is defined as follows: </t>

          <t>
            <figure title="">
              <artwork align="left">
                <![CDATA[
<complexType name="RNType">
  <complexContent>
	<extension base="spppb:PubIdType">
	  <sequence>
		<element name="rn" type="spppb:NumberType"/>
		<element name="corInfo" type="spppb:CORInfoType" 
		   minOccurs="0"/>
	  </sequence>
	</extension>
  </complexContent>
</complexType>
                ]]> 
              </artwork>
            </figure>
          </t>

          <t>RNType has the following attributes:
          <list style="symbols" hangIndent="5">
            <t>rn: Routing Number used as the search key.</t>
            <t>corInfo: Optional &lt;corInfo&gt; element of type CORInfoType.</t>
          </list>
          </t>

          <t>TNRType structure is used to provision a contiguous range of 
          telephone numbers. The object definition requires a starting TN 
          and an ending TN that together define the span of the TN range. 
          Use of TNRType is particularly useful when expressing a TN range 
          that does not include all the TNs within a TN block or prefix. The 
          TNRType definition accommodates the open number plan as well such 
          that the TNs that fall between the start and end TN range may 
          include TNs with different length variance. Whether the registry 
          can accommodate the open number plan semantics is a matter of 
          policy and is beyond the scope of this document.  Each TNRType 
          object is uniquely identified by the combination of its <![CDATA[<startTn>]]> 
          and <![CDATA[<endTn>]]> elements, and the unique key of its parent Destination 
          Group (dgName and rantId).  In other words a given TN Range may 
          exist within one or more Destination Groups, but must not exist 
          more than once within a Destination Group.  TNRType object 
          structure definition is as follows:</t>

          <t>
            <figure title="">
              <artwork align="left">
                <![CDATA[
<complexType name="TNRType">
  <complexContent>
	<extension base="spppb:PubIdType">
	  <sequence>
		<element name="startTn" type="spppb:NumberType"/>
		<element name="endTn" type="spppb:NumberType"/>
		<element name="corInfo" type="spppb:CORInfoType" 
		   minOccurs="0"/>
	  </sequence>
	</extension>
  </complexContent>
</complexType>
              ]]> 
              </artwork>
            </figure>
          </t>          

          <t>TNRType has the following attributes:
            <list style="symbols" hangIndent="5">
              <t>startTn: Starting TN in the TN range</t>
              <t>endTn: The last TN in the TN range</t>
              <t>corInfo: Optional &lt;corInfo&gt; element of type CORInfoType</t>
            </list>
          </t>

          <t>In some cases, it is useful to describe a set of TNs with the help of 
          the first few digits of the telephone number, also referred to as the telephone 
          number prefix or a block. A given TN prefix may include TNs with different 
          length variance in support of open number plan. Once again, whether the registry 
          supports the open number plan semantics is a matter of policy and it is beyond 
          the scope of this document. The TNPType data structure is used to provision a 
          TN prefix.  Each TNPType object is uniquely identified by the combination of 
          its <![CDATA[<tnPrefix>]]> element, and the unique key of its parent Destination Group 
          (dgName and rantId).  TNPType is defined as follows:</t>

          <t>
            <figure title="">
              <artwork align="left">
                <![CDATA[
<complexType name="TNPType">
  <complexContent>
	<extension base="spppb:PubIdType">
	  <sequence>
		<element name="tnPrefix" type="spppb:NumberType"/>
		<element name="corInfo" type="spppb:CORInfoType" 
		   minOccurs="0"/>
	  </sequence>
	</extension>
  </complexContent>
</complexType>
              ]]> 
              </artwork>
            </figure>
          </t>          

          <t>TNPType consists of the following attributes:

            <list style="symbols" hangIndent="5">
              <t>tnPrefix: The telephone number prefix</t>
              <t>corInfo: Optional &lt;corInfo&gt; element of type CORInfoType.</t>
            </list>
          </t>

      </section>

      <section anchor="rteGrp" title="Route Group">
        <t> As described in the introductory sections, a Route Group
          represents a combined grouping of Route Records that define
          route information, Destination Groups that contain a set of
          Public Identifiers with common routing information, and the
          list of peer organizations that have access to these public
          identifiers using this route information. It is this
          indirect linking of public identifiers to their route 
          information that significantly improves the scalability and
          manageability of the peering data. Additions and changes to
          routing information are reduced to a single operation on a
          Route Group or Route Record , rather than millions of data updates 
          to individual public identifier records that individually contain
          their peering data. The transport protocol MUST support the 
          ability to Create, Modify, Get, and Delete Route Groups.  
          The RteGrpType object structure is defined as follows: </t>

        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[
<complexType name="RteGrpType">
  <complexContent>
	<extension base="spppb:BasicObjType">
	  <sequence>
		<element name="rgName" type="spppb:ObjNameType"/>
		<element name="rrRef" type="spppb:RteRecRefType" 
		  minOccurs="0" maxOccurs="unbounded"/>
		<element name="dgName" type="spppb:ObjNameType" 
		   minOccurs="0" maxOccurs="unbounded"/>
		<element name="peeringOrg" type="spppb:OrgIdType" 
		   minOccurs="0" maxOccurs="unbounded"/>
		<element name="sourceIdent" 
		   type="spppb:SourceIdentType" 
		   minOccurs="0" maxOccurs="unbounded"/>
		<element name="isInSvc" type="boolean"/>
		<element name="priority" type="unsignedShort"/>
		<element name="ext" type="spppb:ExtAnyType" 
		   minOccurs="0"/>
		</sequence>
	 </extension>
  </complexContent>
</complexType>
  
 <complexType name="RteRecRefType">
   <sequence>
     <element name="rrKey" type="spppb:ObjKeyType"/>
     <element name="priority" type="unsignedShort"/>
     <element name="ext" type="spppb:ExtAnyType" 
        minOccurs="0"/>
   </sequence>
 </complexType>
                        ]]>
            </artwork>
          </figure>
        </t>

        <t>The RteGrpType object is composed of the following
          elements: <list style="symbols" hangIndent="5">
            <t> base: All first class objects extend 
              BasicObjType that contains the ID of the 
              registrant organization that owns this object, 
              the date and time that the object was created 
              by the server, and the date and time that the object 
              was last modified. If the client passes in either the 
              created date or the modification date, the server will  
              ignore them.  The server sets these two date/time values.</t>
            <t> rgName: The character string that contains the
              name of the Route Group. It uniquely identifies this
              object within the context of the registrant ID (a child
              element of the base element as described above). </t>
            <t> rrRef: Set of zero or more objects of type RteRecRefType
              that house the unique keys of the Route Records that the 
              RteGrpType object refers to and their relative priority 
              within the context of a given route group. The associated Route  
              Records contain the routing information, sometimes called SED, 
              associated with this Route Group.</t>
            <t> dgName: Set of zero or more names of DestGrpType
              object instances. Each dgName name, in association with
              this Route Group's registrant ID, uniquely identifies a
              DestGrpType object instance whose public identifiers are
              reachable using the routing information housed in this
              Route Group.  An intended side affect of this is that 
              a Route Group cannot provide routing information for a 
              Destination Group belonging to another registrant. </t>
            <t> peeringOrg: Set of zero or more peering organization
              IDs that have accepted an offer to receive this Route
              Group's information. The set of peering organizations in
              this list is not directly settable or modifiable using
              the addRteGrpsRqst operation. This set is instead
              controlled using the route offer and accept operations. </t>
            <t> sourceIdent: Set of zero or more SourceIdentType
              object instances. These objects, described further
              below, house the source identification schemes and
              identifiers that are applied at resolution time as part
              of source based routing algorithms for the Route Group. </t>
            <t> isInSvc: A boolean element that defines whether this
              Route Group is in service. The routing information
              contained in a Route Group that is in service is a
              candidate for inclusion in resolution responses for
              public identities residing in the Destination Group
              associated with this Route Group. The routing
              information contained in a Route Group that is not in
              service is not a candidate for inclusion in resolution
              responses. </t>
            <t> priority: Zero or one priority value that can be used 
              to provide a relative value weighting of one Route Group 
              over another.  The manner in which this value is used, 
              perhaps in conjunction with other factors, is a matter of 
              policy.</t>
            <t> ext: Point of extensibility described in a previous
              section of this document. </t>
          </list>
        </t>

        <t> As described above, the Route Group contains a set of references 
          to route record objects. A route record object is based on an
          abstract type: RteRecType. The concrete types that use
          RteRecType as an extension base are NAPTRType, NSType, and
          URIType. The definitions of these types are included the Route 
          Record section of this document. </t>

        <t> The RteGrpType object provides support for source-based 
          routing via the peeringOrg data element and more granular 
          source base routing via the source identity element. The 
          source identity element provides the ability to specify zero or
          more of the following in association with a given Route
          Group: a regular expression that is matched against the
          resolution client IP address, a regular expression that is
          matched against the root domain name(s), and/or a regular
          expression that is matched against the calling party URI(s).
          The result will be that, after identifying the visible Route
          Groups whose associated Destination Group(s) contain the
          lookup key being queried and whose peeringOrg list contains 
          the querying organizations organization ID, the resolution server 
          will evaluate the characteristics of the Source URI, and Source
          IP address, and root domain of the lookup key being queried.
          The resolution server then compares these criteria against the 
          source identity criteria associated with the Route Groups. The
          routing information contained in Route Groups that have
          source based routing criteria will only be included in the
          resolution response if one or more of the criteria matches
          the source criteria from the resolution request.  The Source 
          Identity data element is of type SourceIdentType, whose structure 
          is defined as follows:</t>

        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[
<complexType name="SourceIdentType">
  <sequence>
	<element name="sourceIdentLabel" type="token"/>
	<element name="sourceIdentScheme" 
	  type="spppb:SourceIdentSchemeType"/>
	<element name="ext" type="spppb:ExtAnyType" 
	   minOccurs="0"/>
  </sequence>
</complexType>
  
<simpleType name="SourceIdentSchemeType">
	<restriction base="token">
		<enumeration value="uri"/>
		<enumeration value="ip"/>
		<enumeration value="rootDomain"/>
	</restriction>
</simpleType>
                        ]]>
            </artwork>
          </figure>
        </t>

        <t>The SourceIdentType object is composed of the following
          data elements: <list style="symbols" hangIndent="5">
            <t> sourceIdentScheme: The source identification scheme
              that this source identification criteria applies to and
              that the associated sourceIdentRegex should be matched
              against. </t>
            <t> sourceIdentRegex: The regular expression that should
              be used to test for a match against the portion of the
              resolution request that is dictated by the associated
              sourceIdentScheme. </t>
            <t> ext: Point of extensibility described in a previous
              section of this document. </t>
          </list>
        </t>

        <t>As with the responses to all update operations, the result 
        of the AddRteGrpRqstType operation is contained in the generic 
        spppUpdateResponse data structure described in an earlier sections 
        of this document.  For a detailed description of the 
        spppUpdateResponse data structure refer to that section of the 
        document.</t>

      </section>


      <section anchor="rteRec" title="Route Record">
        <t> As described in the introductory sections, a Route Group
          represents a combined grouping of Route Records that define
          route information. However, Route Records need not be created to 
          just serve a single Route Group.  Route Records can be created 
          and managed to serve multiple Route Groups.  As a result, a change 
          to the properties of a network node used for 
          multiple routes, would necessitate just a single update operation 
          to change the properties of that node.  The change would then be 
          reflected in all the Route Groups whose route record set contains 
          a reference to that node. The transport protocol MUST support the 
          ability to Create, Modify, Get, and Delete Route Records.  
          The RteRecType object structure is defined as follows: </t>

        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[
<complexType name="RteRecType" abstract="true">
  <complexContent>
	<extension base="spppb:BasicObjType">
   	  <sequence>
		<element name="rrName" type="spppb:ObjNameType"/>
		<element name="priority" type="unsignedShort" 
		   minOccurs="0"/>
  	  </sequence>
    </extension>
  </complexContent>
</complexType>
                        ]]>
            </artwork>
          </figure>
        </t>

        <t>The RteRecType object is composed of the following
          elements: <list style="symbols" hangIndent="5">
            <t> base: All first class objects extend 
              BasicObjType that contains the ID of the 
              registrant organization that owns this object, 
              the date and time that the object was created 
              by the server, and the date and time that the object 
              was last modified. If the client passes in either the 
              created date or the modification date, the server will  
              ignore them.  The server sets these two date/time values.</t>
            <t> rrName: The character string that contains the
              name of the Route Record. It uniquely identifies this
              object within the context of the registrant ID (a child
              element of the base element as described above). </t>
            <t> priority: Zero or one priority value that can be used 
              to provide a relative value weighting of one Route Record 
              over another.  The manner in which this value is used, 
              perhaps in conjunction with other factors, is a matter of 
              policy.</t>
          </list>
        </t>

        <t> As described above, route records are based on an
          abstract type: RteRecType. The concrete types that use
          RteRecType as an extension base are NAPTRType, NSType, and
          URIType. The definitions of these types are included below.
          The NAPTRType object is comprised of the data elements
          necessary for a NAPTR that contains routing information for a
          Route Group. The NSType object is comprised of the data
          elements necessary for a DNS name server that points to another
          DNS server that contains the desired routing information.  
          The NSType is relevant only when the resolution protocol is ENUM.
          The URIType object is comprised of the data elements
          necessary to house a URI. </t>

        <t> The data provisioned in a registry can be leveraged for
          many purposes and queried using various protocols including
          SIP, ENUM and others. It is for this reason that a route
          record type offers a choice of URI and DNS resource record
          types. URIType fulfills the need for both SIP and ENUM 
          protocols. When a given URIType is associated to a destination 
          group, the user part of the replacement string &lt;uri&gt; that 
          may require the Public Identifier cannot be preset. As a SIP 
          Redirect, the resolution server will apply &lt;ere&gt; pattern 
          on the input Public Identifier in the query and process the 
          replacement string by substituting any back reference(s) 
          in the &lt;uri&gt; to arrive at the final URI that is returned 
          in the SIP Contact header. For an ENUM query, the resolution 
          server will simply return the value of the &lt;ere&gt; 
          and &lt;uri&gt; members of the URIType in the NAPTR REGEX parameter.</t>

        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[
<complexType name="NAPTRType">
  <complexContent>
	<extension base="spppb:RteRecType">
  	  <sequence>
		<element name="order" type="unsignedShort"/>
		<element name="flags" type="spppb:FlagsType" 
		   minOccurs="0"/>
		<element name="svcs" type="spppb:SvcType"/>
		<element name="regx" type="spppb:RegexParamType" 
		   minOccurs="0"/>
		<element name="repl" type="spppb:ReplType" 
		   minOccurs="0"/>
		<element name="ttl" type="positiveInteger" 
		   minOccurs="0"/>
		<element name="ext" type="spppb:ExtAnyType" 
		   minOccurs="0"/>
	  </sequence>
	</extension>
  </complexContent>
</complexType>
  
<complexType name="NSType">
  <complexContent>
	<extension base="spppb:RteRecType">
	  <sequence>
		<element name="hostName" type="token"/>
		<element name="ipAddr" type="spppb:IPAddrType" 
		   minOccurs="0" maxOccurs="unbounded"/>
		<element name="ttl" type="positiveInteger" 
		   minOccurs="0"/>
		<element name="ext" type="spppb:ExtAnyType" 
		   minOccurs="0"/>
	  </sequence>
	</extension>
  </complexContent>
</complexType>

<complexType name="IPAddrType">
  <sequence>
	<element name="addr" type="spppb:AddrStringType"/>
	<element name="ext" type="spppb:ExtAnyType" 
	   minOccurs="0"/>
  </sequence>
  <attribute name="type" type="spppb:IPType" 
     default="v4"/>
</complexType>
  
 <simpleType name="IPType">
   <restriction base="token">
     <enumeration value="IPv4"/>
     <enumeration value="IPv6"/>
   </restriction>
 </simpleType>
  
<complexType name="URIType">
  <complexContent>
	<extension base="spppb:RteRecType">
	  <sequence>
		<element name="ere" type="token" 
		   default="^(.*)$"/>
		<element name="uri" type="anyURI"/>
		<element name="ext" type="spppb:ExtAnyType" 
		   minOccurs="0"/>
	  </sequence>
	</extension>
  </complexContent>
</complexType>
  
<simpleType name="flagsType">
	<restriction base="token">
		<length value="1"/>
		<pattern value="[A-Z]|[a-z]|[0-9]"/>
	</restriction>
</simpleType>

                        ]]>
            </artwork>
          </figure>
        </t>

        <t>The NAPTRType object is composed of the following elements:
            <list style="symbols" hangIndent="5">
            <t> order: Order value in an ENUM NAPTR, relative to other
              NAPTRType objects in the same Route Group. </t>
            <t> svcs: ENUM service(s) that are served by the SBE. This
              field's value must be of the form specified in <xref target="RFC6116"/>
              (e.g., E2U+pstn:sip+sip). The allowable values are a
              matter of policy and not limited by this protocol. </t>
            <t> regx: NAPTR’s regular expression field. If this is not
              included then the Repl field must be included. </t>
            <t> repl: NAPTR replacement field, should only be provided
              if the Regex field is not provided, otherwise the server will ignore it</t>
            <t> ttl: Number of seconds that an addressing server may
              cache this NAPTR. </t>
            <t> ext: Point of extensibility described in a previous
              section of this document. </t>
          </list>
        </t>

        <t>The NSType object is composed of the following elements:
            <list style="symbols" hangIndent="5">
            <t> hostName: Fully qualified host name of the name
              server. </t>
            <t> ipAddr: Zero or more objects of type IpAddrType. Each
              object holds an IP Address and the IP Address type, IPv4
              or IP v6. </t>
            <t> ttl: Number of seconds that an addressing server may
              cache this DNS name server. </t>
            <t> ext: Point of extensibility described in a previous
              section of this document. </t> </list>
        </t>

        <t>The URIType object is composed of the following elements:
            <list style="symbols" hangIndent="5">
            <t>ere: The POSIX Extended Regular Expression (ere) as
              defined in <xref target="RFC3986"/>. 
            </t>
            <t>uri: the URI as defined in <xref target="RFC3986"/>. In some 
            cases, this will serve as the replacement string and it will be 
            left to the resolution server to arrive at the final usable URI.
            </t>
          </list>
        </t>

      </section>

      <section anchor="rtegrpoffer" title="Route Group Offer">
        <t> The list of peer organizations whose resolution responses
          can include the routing information contained in a given
          Route Group is controlled by the organization to which a
          Route Group object belongs (its registrant), and the peer
          organization that submits resolution requests (a data
          recipient, also know as a peering organization). The registrant 
          offers access to a Route Group by submitting a Route Group Offer. 
          The data recipient can then accept or reject that offer.
          Not until access to a Route Group has been offered and
          accepted will the data recipient's organization ID be
          included in the peeringOrg list in a Route Group object, and
          that Route Group's peering information become a candidate
          for inclusion in the responses to the resolution requests
          submitted by that data recipient. The transport protocol MUST support the 
          ability to Create, Modify, Get, Delete, Accept and Reject Route Group Offers.  
          The RteGrpOfferType object structure is defined as follows: </t>

        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[
<complexType name="RteGrpOfferType">
  <complexContent>
	<extension base="spppb:BasicObjType">
	  <sequence>
		<element name="rteGrpOfferKey" 
		   type="spppb:RteGrpOfferKeyType"/>
		<element name="status" 
		   type="spppb:RteGrpOfferStatusType"/>
		<element name="offerDateTime" type="dateTime"/>
		<element name="acceptDateTime" type="dateTime" 
		   minOccurs="0"/>
		<element name="ext" type="spppb:ExtAnyType" 
		   minOccurs="0"/>
		</sequence>
 	 </extension>
  </complexContent>
</complexType>
  
<complexType name="RteGrpOfferKeyType" abstract="true">
  <annotation>
	<documentation>
	-- Generic type that represents the key for a route
	route group offer. Must be defined in concrete form 
	in the transport specificaiton. --
   	</documentation>
  </annotation>
</complexType>
  
<simpleType name="RteGrpOfferStatusType">
   <restriction base="token">
      <enumeration value="offered"/>
      <enumeration value="accepted"/>
    </restriction>
  </simpleType>
                        ]]>
            </artwork>
          </figure>
        </t>

        <t>The RteGrpOfferType object is composed of the following
          elements: <list style="symbols" hangIndent="5">
            <t> base: All first class objects extend  
              BasicObjType that contains the ID of the 
              registrant organization that owns this object, 
              the date and time that the object was created 
              by the server, and the date and time that the object 
              was last modified. If the client passed in either the 
              created date or the modification date, the will ignore 
              them.  The server sets these two date/time values.</t>
            <t> rteGrpOfferKey: The object that identifies the route
              that is or has been offered and the organization that it
              is or has been offered to.</t>
            <t> status: The status of the offer, offered or accepted.
              The server controls the status. It is
              automatically set to "offered" when ever a new Route
              Group Offer is added, and is automatically set to
              "accepted" if and when that offer is accepted. The value
              of the element is ignored when passed in by the client. </t>
            <t> offerDateTime: Date and time in UTC when the Route
              Group Offer was added. </t>
            <t> acceptDateTime: Date and time in UTC when the Route
              Group Offer was accepted. </t>
          </list>
        </t>

        <t> Accepting a Route Group Offer:  Not until access to a Route Group has 
           been offered and accepted will the registrant's organization ID be  
          included in the peeringOrg list in that Route Group object,
          and that Route Group's peering information become a
          candidate for inclusion in the responses to the resolution
          requests submitted by that registrant.  A Route Group Offer that is in 
          the "offered" status is accepted by, or on behalf
          of, the registrant to which it has been offered. When the Route Group 
          Offer is accepted the the Route Group Offer is moved to the "accepted" 
          status and adds that data recipient's organization ID into the list
          of peerOrgIds for that Route Group.</t>

        <t> Rejecting a Route Group Offer:  The registrant to which a Route Group 
          has been offered has the option of rejecting a Route Group Offer.  
          Furthermore, that offer may be rejected, regardless of whether or not 
          it has been previously accepted.  A Route Group Offer that is in 
          the "offered" or "accepted" status is rejected by, or on behalf
          of, the registrant to which it has been offered. When the Route Group 
          Offer is rejected that Route Group Offer is deleted, and, if appropriate,
          the data recipient's organization ID is removed from the list of
          peeringOrg IDs for that Route Group.</t>

     </section>
      

      <section anchor="egressRte" title="Egress Route">

       <t>In a high-availability environment, the originating SSP likely has more 
       than one egress paths to the ingress SBE of the target SSP.  If the 
       originating SSP wants to exercise greater control and choose a specific 
       egress SBE to be associated to the target ingress SBE, it can do so using 
       the AddEgrRteRqstType object.</t>

       <t>Lets assume that the target SSP has offered to share one or more ingress 
       route information and that the originating SSP has accepted the offer. In 
       order to add the egress route to the registry, the originating SSP uses a 
       valid regular expression to rewrite ingress route in order to include the 
       egress SBE information. Also, more than one egress route can be associated 
       with a given ingress route in support of fault-tolerant configurations. The 
       supporting SPPP structure provides a way to include route precedence 
       information to help manage traffic to more than one outbound egress SBE.</t>

        <t>The transport protocol MUST support the ability to Create, Modify, Get, 
        and Delete Egress Routes.  The EgrRteType object structure is defined as 
        follows: </t>
        
        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[
<complexType name="EgrRteType">
  <complexContent>
	<extension base="spppb:BasicObjType">
	  <sequence>
		<element name="egrRteName" type="spppb:ObjNameType"/>
		<element name="pref" type="unsignedShort"/>
		<element name="regxRewriteRule" 
		  type="spppb:RegexParamType"/>
		<element name="ingrRteRec" type="spppb:ObjKeyType" 
		   minOccurs="0" maxOccurs="unbounded"/>
		<element name="ext" type="spppb:ExtAnyType" 
		  minOccurs="0"/>
	  </sequence>
	</extension>
  </complexContent>
</complexType>
         ]]>
            </artwork>
          </figure>
        </t>

        <t>The EgrRteType object is composed of the following
          elements: <list style="symbols" hangIndent="5">
            <t> base: All first class objects extend 
              BasicObjType that contains the ID of the 
              registrant organization that owns this object, 
              the date and time that the object was created 
              by the server, and the date and time that the object 
              was last modified. If the client passes in either the 
              created date or the modification date, the server will  
              ignore them.  The server sets these two date/time values.</t>
            <t> egrRteName: The name of the egress route. </t>
            <t> pref: The preference of this egress route relative to other
              egress routes that may get selected when responding to a 
              resolution request.</t>
            <t> regxRewriteRule: The regular expression re-write rule
              that should be applied to the regular expression of the
              ingress NAPTR(s) that belong to the ingress route.</t>
            <t> ingrRteRec: The ingress route records that the
              egress route should be used for. </t>
            <t> ext: Point of extensibility described in a previous
              section of this document. </t>
          </list>
        </t>

      </section>

    </section>
    
    <section anchor="xmlconsiderations" title="XML Considerations">
      <t> XML serves as the encoding format for SPPP, allowing complex
        hierarchical data to be expressed in a text format that can be
        read, saved, and manipulated with both traditional text tools
        and tools specific to XML. <vspace blankLines="1"/> XML is
        case sensitive. Unless stated otherwise, XML specifications
        and examples provided in this document MUST be interpreted in
        the character case presented to develop a conforming
        implementation. <vspace blankLines="1"/> This section
        discusses a small number of XML-related considerations
        pertaining to SPPP. </t>

      <section anchor="namespaces" title="Namespaces">
        <t> All SPPP elements are defined in the namespaces 
        in the IANA Considerations section and in the Formal Protocol 
        Specification section of this document.
        </t>
      </section>
      
      <section anchor="versioning" title="Versioning and Character Encoding">
        <t> All XML instances SHOULD begin with an
          <![CDATA[ <?xml?> ]]> declaration to identify the version of
          XML that is being used, optionally identify use of the
          character encoding used, and optionally provide a hint to an
          XML parser that an external schema file is needed to
          validate the XML instance. <vspace blankLines="1"/>
          Conformant XML parsers recognize both UTF-8 (defined in
            <xref target="RFC3629"/>) and UTF-16 (defined in <xref
            target="RFC2781"/>); per <xref target="RFC2277"/> UTF-8 is
          the RECOMMENDED character encoding for use with SPPP. </t>
        <t> Character encodings other than UTF-8 and UTF-16 are
          allowed by XML. UTF-8 is the default encoding assumed by XML
          in the absence of an "encoding" attribute or a byte order
          mark (BOM); thus, the "encoding" attribute in the XML
          declaration is OPTIONAL if UTF-8 encoding is used. SPPP
          clients and servers MUST accept a UTF-8 BOM if present,
          though emitting a UTF-8 BOM is NOT RECOMMENDED. </t>
        <t> Example XML declarations: <vspace blankLines="1"/>
          <![CDATA[ <?xml version="1.0" encoding="UTF-8" standalone="no"?>]]>
        </t>
      </section>

    </section>

    <section anchor="securityconsiderations" title="Security Considerations">

      <t>Many SPPP implementations manage data that is considered confidential and critical. Furthermore, SPPP implementations can support provisioning activities for multiple registrars and registrants.  As a result any SPPP implementation must address the requirements for confidentiality, authentication, and authorization.</t>

      <t>With respect to confidentiality and authentication, the transport protocol requirements section of this document contains security properties that the transport protocol must provide so that authenticated endpoints can exchange data confidentially and with integrity protection. Refer to that section and the resulting transport protocol specification document for the specific solutions to authentication and confidentiality.</t>

      <t>With respect to authorization, the SPPP server implementation must define and implement a set of authorization rules that precisely address (1) which registrars will be authorized to create/modify/delete each SPPP object type for given registrant(s) and (2) which registrars will be authorized to view/get each SPPP object type for given registrant(s).  These authorization rules are a matter of policy and are not specified within the context of SPPP. However, any SPPP implementation must specify these authorization rules in order to function in a reliable and safe manner.</t>

      <t>In some situations, it may be required to protect against denial of involvement (see <xref target="RFC4949"/>) and tackle non-repudiation concerns in regards to SPPP messages. This type of protection is useful to satisfy authenticity concerns related to SPPP messages beyond the end-to-end connection integrity, confidentiality, and authentication protection that the transport layer provides. This is an optional feature and some SPPP implementations MAY provide support for it.</t>

      <t>It is not uncommon for the logging systems to document on-the-wire messages for various purposes, such as, debug, audit, and tracking. At the minimum, the various support and administration staff will have access to these logs. Also, if an unprivileged user gains access to the SPPP deployments and/or support systems, it will have access to the information that is potentially deemed confidential. To manage information disclosure concerns beyond the transport level, SPPP implementations MAY provide support for encryption at the SPPP object level.</t>

      <t>Anti-replay protection ensures that a given SPPP object replayed at a later time doesn't affect the integrity of the system. SPPP provides at least one mechanism to fight against replay attacks. Use of the optional client transaction identifier allows the SPPP client to correlate the request message with the response and to be sure that it is not a replay of a server response from earlier exchanges. Use of unique values for the client transaction identifier is highly encouraged to avoid chance matches to a potential replay message.</t>

      <t>The SPPP client or registrar can be a separate entity acting on behalf of the registrant in facilitating provisioning transactions to the registry. Further, the transport layer provides end-to-end connection protection between SPPP client and the SPPP server. Therefore, man-in-the-middle attack is a possibility that may affect the integrity of the data that belongs to the registrant and/or expose peer data to unintended actors in case well-established peering relationships already exist.</t>

    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t> This document uses URNs to describe XML namespaces and XML
        schemas conforming to a registry mechanism described in <xref
          target="RFC3688"/>. </t>
      <t> Two URI assignments are requested. <vspace blankLines="1"/>
        Registration request for the SPPP XML namespace: <vspace
          blankLines="0"/> urn:ietf:params:xml:ns:sppp:base:1 <vspace
          blankLines="0"/> Registrant Contact: IESG <vspace
          blankLines="0"/> XML: None. Namespace URIs do not represent
        an XML specification. </t>
      <t> Registration request for the XML schema: <vspace
          blankLines="0"/> URI: urn:ietf:params:xml:schema:sppp:1
          <vspace blankLines="0"/> Registrant Contact: IESG <vspace
          blankLines="0"/> XML: See the "Formal Specification" section
        of this document (<xref target="formalspecification"/>). </t>
      <t>
      	IANA is requested to create a new SPPP registry for Organization Identifiers that will indicate valid strings to be used for well-known enterprise namespaces.
      	<vspace
          blankLines="0"/>
      	This document makes the following assignments for the OrgIdType namespaces:
	  </t>
        <t>
          <figure title="">
            <artwork align="left">
              <![CDATA[
      Namespace                    OrgIdType namespace string
      ----                         ----------------------------
      IANA Enterprise Numbers       iana-en
                              ]]>
            </artwork>
          </figure>

      </t>
    </section>

    <section anchor="formalspecification" title="Formal Specification">
      <t> This section provides the draft XML Schema Definition for
        SPPP. </t>
      <t>
        <figure title="">
          <artwork align="left">
            <![CDATA[


<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns:spppb="urn:ietf:params:xml:ns:sppp:base:1" 
      xmlns="http://www.w3.org/2001/XMLSchema" 
      targetNamespace="urn:ietf:params:xml:ns:sppp:base:1" 
      elementFormDefault="qualified" xml:lang="EN">
  <annotation>
	<documentation>
		---- Generic Object key types to be defined by 
		specific Transport/Architecture. The types
		defined here can be extended by the
		specific architecture to define the Object
		 Identifiers. ----
	</documentation>
  </annotation>
  <complexType name="ObjKeyType" abstract="true">
	<annotation>
		<documentation>
		---- Generic type that represents the key for various
	    objects in SPPP. ----
     	</documentation>
	</annotation>
  </complexType>
  <complexType name="RteGrpOfferKeyType" abstract="true">
	<annotation>
		<documentation>
		---- Generic type that represents the key for a route
		group offer. ----
   		</documentation>
	</annotation>
  </complexType>
  <annotation>
	   <documentation>
	      ---- Object Type Definitions ---- 
	   </documentation>
  </annotation>
  <complexType name="RteGrpType">
	<complexContent>
	  <extension base="spppb:BasicObjType">
	    <sequence>
		  <element name="rgName" type="spppb:ObjNameType"/>
		  <element name="rrRef" type="spppb:RteRecRefType" 
		   minOccurs="0" maxOccurs="unbounded"/>
	  	  <element name="dgName" type="spppb:ObjNameType" 
		   minOccurs="0" maxOccurs="unbounded"/>
		  <element name="peeringOrg" type="spppb:OrgIdType" 
		   minOccurs="0" maxOccurs="unbounded"/>
		  <element name="sourceIdent"
		    type="spppb:SourceIdentType" 
		    minOccurs="0" maxOccurs="unbounded"/>
		  <element name="isInSvc" type="boolean"/>
		  <element name="priority" type="unsignedShort"/>
		  <element name="ext" type="spppb:ExtAnyType" 
		   minOccurs="0"/>
		</sequence>
	  </extension>
	</complexContent>
  </complexType>
  <complexType name="DestGrpType">
	<complexContent>
	  <extension base="spppb:BasicObjType">
	    <sequence>
		  <element name="dgName" type="spppb:ObjNameType"/>
		</sequence>
	  </extension>
	 </complexContent>
  </complexType>
  <complexType name="PubIdType" abstract="true">
	<complexContent>
	  <extension base="spppb:BasicObjType">
		<sequence>
	  	  <element name="dgName" type="spppb:ObjNameType" 
			   minOccurs="0"/>
		</sequence>
	  </extension>
	</complexContent>
  </complexType>
	<complexType name="TNType">
	  <complexContent>
		<extension base="spppb:PubIdType">
		  <sequence>
			<element name="tn" type="spppb:NumberType"/>
			<element name="rrRef" 
			  type="spppb:RteRecRefType" minOccurs="0" 
			  maxOccurs="unbounded"/>
			<element name="corInfo" 
			  type="spppb:CORInfoType" minOccurs="0"/>
		  </sequence>
		</extension>
	  </complexContent>
	</complexType>
	<complexType name="TNRType">
	 <complexContent>
	  <extension base="spppb:PubIdType">
		<sequence>
		  <element name="startTn" type="spppb:NumberType"/>
		  <element name="endTn" type="spppb:NumberType"/>
		  <element name="corInfo" type="spppb:CORInfoType" 
			 minOccurs="0"/>
		</sequence>
	   </extension>
	 </complexContent>
	</complexType>
	<complexType name="TNPType">
	 <complexContent>
	  <extension base="spppb:PubIdType">
	   <sequence>
		 <element name="tnPrefix" type="spppb:NumberType"/>
		 <element name="corInfo" type="spppb:CORInfoType" 
		   minOccurs="0"/>
	   </sequence>
	  </extension>
	 </complexContent>
	</complexType>
	<complexType name="RNType">
	  <complexContent>
		<extension base="spppb:PubIdType">
		  <sequence>
		   <element name="rn" type="spppb:NumberType"/>
		   <element name="corInfo" type="spppb:CORInfoType" 
			 minOccurs="0"/>
		  </sequence>
		</extension>
	  </complexContent>
	</complexType>
	<complexType name="RteRecType" abstract="true">
	 <complexContent>
	  <extension base="spppb:BasicObjType">
		<sequence>
		  <element name="rrName" type="spppb:ObjNameType"/>
		  <element name="priority" type="unsignedShort" 
			minOccurs="0"/>
		</sequence>
	   </extension>
	 </complexContent>
	</complexType>
	<complexType name="NAPTRType">
	  <complexContent>
		<extension base="spppb:RteRecType">
		  <sequence>
		   <element name="order" type="unsignedShort"/>
		   <element name="flags" type="spppb:FlagsType" 
			  minOccurs="0"/>
		   <element name="svcs" type="spppb:SvcType"/>
		   <element name="regx" type="spppb:RegexParamType" 
			 minOccurs="0"/>
		   <element name="repl" type="spppb:ReplType" 
			 minOccurs="0"/>
		   <element name="ttl" type="positiveInteger" 
			 minOccurs="0"/>
		   <element name="ext" type="spppb:ExtAnyType" 
			 minOccurs="0"/>
		  </sequence>
		</extension>
	  </complexContent>
	</complexType>
	<complexType name="NSType">
	  <complexContent>
		<extension base="spppb:RteRecType">
		  <sequence>
		   <element name="hostName" type="token"/>
		   <element name="ipAddr" type="spppb:IPAddrType" 
			 minOccurs="0" maxOccurs="unbounded"/>
		   <element name="ttl" type="positiveInteger" 
			 minOccurs="0"/>
		   <element name="ext" type="spppb:ExtAnyType" 
			 minOccurs="0"/>
		  </sequence>
		</extension>
	  </complexContent>
	</complexType>
	<complexType name="URIType">
	  <complexContent>
		<extension base="spppb:RteRecType">
		  <sequence>
			<element name="ere" type="token" 
			   default="^(.*)$"/>
			<element name="uri" type="anyURI"/>
			<element name="ext" type="spppb:ExtAnyType" 
			   minOccurs="0"/>
		  </sequence>
		</extension>
	  </complexContent>
	</complexType>
	<complexType name="RteGrpOfferType">
	  <complexContent>
		<extension base="spppb:BasicObjType">
		 <sequence>
		  <element name="rteGrpOfferKey" 
			type="spppb:RteGrpOfferKeyType"/>
		  <element name="status" 
			type="spppb:RteGrpOfferStatusType"/>
		  <element name="offerDateTime" type="dateTime"/>
		  <element name="acceptDateTime" type="dateTime" 
			minOccurs="0"/>
		  <element name="ext" type="spppb:ExtAnyType" 
			minOccurs="0"/>
		  </sequence>
		</extension>
	  </complexContent>
	</complexType>
   <complexType name="EgrRteType">
	 <complexContent>
	  <extension base="spppb:BasicObjType">
	   <sequence>
		<element name="egrRteName" 
		  type="spppb:ObjNameType"/>
		<element name="pref" type="unsignedShort"/>
		<element name="regxRewriteRule" 
		  type="spppb:RegexParamType"/>
		<element name="ingrRteRec" 
		  type="spppb:ObjKeyType" 
		  minOccurs="0" maxOccurs="unbounded"/>
		<element name="ext" type="spppb:ExtAnyType" 
		  minOccurs="0"/>
	   </sequence>
	  </extension>
	 </complexContent>
	</complexType>
	<annotation>
		<documentation>
		-- Abstract Object and Element Type Defs --
		</documentation>
	</annotation>
	<complexType name="BasicObjType" abstract="true">
	  <sequence>
		<element name="rant" type="spppb:OrgIdType"/>
		<element name="rar" type="spppb:OrgIdType"/>
		<element name="cDate" type="dateTime" 
		   minOccurs="0"/>
		<element name="mDate" type="dateTime"             
		   minOccurs="0"/>
		<element name="ext" type="spppb:ExtAnyType" 
		   minOccurs="0"/>
		</sequence>
	</complexType>
	<complexType name="RegexParamType">
	  <sequence>
		<element name="ere" type="spppb:RegexType" 
		   default="^(.*)$"/>
		<element name="repl" type="spppb:ReplType"/>
	  </sequence>
	</complexType>
	<complexType name="IPAddrType">
	  <sequence>
		<element name="addr" type="spppb:AddrStringType"/>
		<element name="ext" type="spppb:ExtAnyType" 
		   minOccurs="0"/>
	  </sequence>
	  <attribute name="type" type="spppb:IPType" 
	     default="v4"/>
	</complexType>
	<complexType name="RteRecRefType">
	  <sequence>
		<element name="rrKey" type="spppb:ObjKeyType"/>
		<element name="priority" type="unsignedShort"/>
		<element name="ext" type="spppb:ExtAnyType" 
		   minOccurs="0"/>
	  </sequence>
	</complexType>
	<complexType name="SourceIdentType">
	  <sequence>
		<element name="sourceIdentLabel" type="token"/>
		<element name="sourceIdentScheme" 
		   type="spppb:SourceIdentSchemeType"/>
		<element name="ext" type="spppb:ExtAnyType" 
		   minOccurs="0"/>
	  </sequence>
	</complexType>
	<complexType name="CORInfoType">
	  <sequence>
		<element name="corClaim" type="boolean" 
		  default="true"/>
		<element name="cor" type="boolean" 
		  default="false" minOccurs="0"/>
		<element name="corDate" type="dateTime"   
		  minOccurs="0"/>
	  </sequence>
	</complexType>
	<complexType name="SvcMenuType">
	  <sequence>
		<element name="serverStatus" 
		  type="spppb:ServerStatusType"/>
		<element name="majMinVersion" type="token" 
		   maxOccurs="unbounded"/>
		<element name="objURI" type="anyURI" 
		   maxOccurs="unbounded"/>
		<element name="extURI" type="anyURI" 
		   minOccurs="0" maxOccurs="unbounded"/>
	  </sequence>
	</complexType>
	<complexType name="ExtAnyType">
	  <sequence>
		<any namespace="##other" maxOccurs="unbounded"/>
	  </sequence>
	</complexType>
	<simpleType name="FlagsType">
		<restriction base="token">
			<length value="1"/>
			<pattern value="[A-Z]|[a-z]|[0-9]"/>
		</restriction>
	</simpleType>
	<simpleType name="SvcType">
		<restriction base="token">
			<minLength value="1"/>
		</restriction>
	</simpleType>
	<simpleType name="RegexType">
		<restriction base="token">
			<minLength value="1"/>
		</restriction>
	</simpleType>
	<simpleType name="ReplType">
		<restriction base="token">
			<minLength value="1"/>
			<maxLength value="255"/>
		</restriction>
	</simpleType>
	<simpleType name="OrgIdType">
		<restriction base="token"/>
	</simpleType>
	<simpleType name="ObjNameType">
		<restriction base="token">
			<minLength value="3"/>
			<maxLength value="80"/>
		</restriction>
	</simpleType>
	<simpleType name="TransIdType">
		<restriction base="token">
			<minLength value="3"/>
			<maxLength value="120"/>
		</restriction>
	</simpleType>
	<simpleType name="MinorVerType">
		<restriction base="unsignedLong"/>
	</simpleType>
	<simpleType name="AddrStringType">
		<restriction base="token">
			<minLength value="3"/>
			<maxLength value="45"/>
		</restriction>
	</simpleType>
	<simpleType name="IPType">
		<restriction base="token">
			<enumeration value="v4"/>
			<enumeration value="v6"/>
		</restriction>
	</simpleType>
	<simpleType name="SourceIdentSchemeType">
		<restriction base="token">
			<enumeration value="uri"/>
			<enumeration value="ip"/>
			<enumeration value="rootDomain"/>
		</restriction>
	</simpleType>
	<simpleType name="ServerStatusType">
		<restriction base="token">
			<enumeration value="inService"/>
			<enumeration value="outOfService"/>
		</restriction>
	</simpleType>
	<simpleType name="RteGrpOfferStatusType">
		<restriction base="token">
			<enumeration value="offered"/>
			<enumeration value="accepted"/>
		</restriction>
	</simpleType>
	<simpleType name="NumberType">
		<restriction base="token">
			<maxLength value="20"/>
			<pattern value="\+?\d\d*"/>
		</restriction>
	</simpleType>
</schema>

            ]]>
          </artwork>
        </figure>

      </t>
    </section>

    <section title="Acknowledgments">
      <t>This document is a result of various discussions held in the 
      DRINKS working group and within the DRINKS protocol design team, 
      which is comprised of the following individuals, in alphabetical 
      order: Alexander Mayrhofer, Deborah A Guyton, David Schwartz, 
      Lisa Dusseault, Manjul Maharishi, Mickael Marrache, Otmar Lendl, 
      Richard Shockey, Samuel Melloul, and Sumanth Channabasappa.</t>
    </section>

  </middle>

  <back>
    <references title="Normative References"> &rfc2119; &rfc2277;
      &rfc3629; &rfc3688; &rfc3986; &rfc5067; &rfc4949;
      &I-D.ietf-drinks-sppp-over-soap; </references>

    <references title="Informative References"> &rfc5321; &rfc3261;
      &rfc6116; &rfc4725; &rfc5486; &rfc2781;
      &I-D.ietf-drinks-usecases-requirements; </references>
  </back>

</rfc>
