<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<!-- This is built from a template for a generic Internet Draft. Suggestions for
     improvement welcome - write to Brian Carpenter, brian.e.carpenter @ gmail.com -->

<!-- This can be converted using the Web service at http://xml.resource.org/experimental.html
     (which supports the latest, sometimes undocumented and under-tested, features.) -->

<?rfc toc="yes"?>            <!-- You want a table of contents -->
<?rfc symrefs="yes"?>        <!-- Use symbolic labels for references -->
<?rfc sortrefs="yes"?>       <!-- This sorts the references -->
<?rfc iprnotified="no" ?>    <!-- Change to "yes" if someone has disclosed IPR for the draft -->
<?rfc compact="yes"?>

<!-- You need one entry like the following for each RFC referenced -->


<!ENTITY RFC2119 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119'>
<!ENTITY RFC2629 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629'>
<!ENTITY RFC2460 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2460'>
<!ENTITY RFC3697 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3697'>
<!ENTITY RFC4301 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301'>
<!ENTITY RFC4302 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4302'>
<!ENTITY RFC4303 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4303'>
<!ENTITY RFC2474 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2474'>
<!ENTITY RFC2827 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2827'>
<!ENTITY RFC2205 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2205'>


<!-- You need one entry like the following for each I-D referenced -->

<!-- ENTITY DRAFT-conta1 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.conta-ipv6-flow-label.xml"> -->
<!-- ENTITY DRAFT-metzler SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.metzler-ipv6-flowlabel.xml"> -->


<!ENTITY DRAFT-conta2 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.conta-diffserv-ipv6-fl-classifier.xml">
<!ENTITY DRAFT-chakra SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.chakravorty-6lsa.xml">
<!ENTITY DRAFT-bannerj SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.banerjee-flowlabel-ipv6-qos.xml">
<!ENTITY DRAFT-roberts SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.roberts-inband-qos-ipv6.xml">
<!ENTITY DRAFT-beck1 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.martinbeckman-ietf-ipv6-fls-ipv6flowswitching.xml">
<!ENTITY DRAFT-beck2 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.martinbeckman-ietf-ipv6-amp-ipv6hcamp.xml">
<!ENTITY DRAFT-nonce SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.blake-ipv6-flow-label-nonce.xml">
<!ENTITY DRAFT-ecmp SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.carpenter-flow-ecmp.xml">
<!ENTITY DRAFT-hu SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hu-flow-label-cases.xml">
<!ENTITY DRAFT-gont SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.gont-6man-flowlabel-security.xml">
<!ENTITY DRAFT-rationale SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-6man-flow-update.xml">

<!-- This defines the specific filename and version number of your draft (and inserts the appropriate IETF boilerplate -->
<rfc ipr="pre5378Trust200902" docName="draft-ietf-6man-flow-3697bis-04" category="std" obsoletes="3697" updates="2205, 2460">  


<front>
<title abbrev="IPv6 Flow Label Specification">IPv6 Flow Label Specification</title>

<author initials="S." surname="Amante" fullname="Shane Amante">
<organization abbrev="Level 3"></organization>
  <address>
      <postal>
        <street>Level 3 Communications, LLC</street>
        <street>1025 Eldorado Blvd</street>
        <city>Broomfield</city>
        <region>CO</region>
        <code>80021</code>
        <country>USA</country>
      </postal>
      <email>shane@level3.net</email>
  </address>
</author>


<author initials="B. E." surname="Carpenter" fullname="Brian Carpenter">
    <organization abbrev="Univ. of Auckland"></organization>
    <address>
      <postal>
        <street>Department of Computer Science</street>
        <street>University of Auckland</street>
        <street>PB 92019</street>
        <city>Auckland</city>
        <region></region>
        <code>1142</code>
        <country>New Zealand</country>
      </postal>
      
      <email>brian.e.carpenter@gmail.com</email>
    </address>
</author>

   <author fullname="Sheng Jiang" initials="S.J." surname="Jiang">
      <organization>Huawei Technologies Co., Ltd</organization>
      <address>
        <postal>
          <street>Huawei Building, No.3 Xinxi Rd.,</street>
          <city>Shang-Di Information Industry Base, Hai-Dian District, Beijing</city>
          <country>P.R. China</country>
        </postal>
        <email>jiangsheng@huawei.com</email>
      </address>
    </author>

   <author fullname="Jarno Rajahalme" initials="J." surname="Rajahalme">
      <organization>Nokia Siemens Networks</organization>
      <address>
        <postal>
          <street>Linnoitustie 6</street>
          <city>02600  Espoo</city>
          <country>Finland</country>
        </postal>
        <email>jarno.rajahalme@nsn.com</email>
      </address>
    </author>

<date day="11" month="May" year="2011" />

<area>Internet</area>
<workgroup>6MAN</workgroup>

 


<abstract>

<t>This document specifies the IPv6 Flow Label field and the minimum
   requirements for IPv6 nodes labeling flows, IPv6 nodes
   forwarding labeled packets, and flow state establishment methods.
   Even when mentioned as examples of possible uses of the flow
   labeling, more detailed requirements for specific use cases are out
   of scope for this document.
</t>
<t>The usage of the Flow Label field enables efficient IPv6 flow
   classification based only on IPv6 main header fields in fixed
   positions.
</t>
    
</abstract>
</front>

<middle>
<section anchor="intro" title="Introduction">

<t>From the viewpoint of the network layer, a flow is a sequence of packets sent from a particular source to a
   particular unicast, anycast, or multicast destination that a node
   desires to label as a flow.  From an upper layer viewpoint, a flow could consist of all packets in a
   specific transport connection or a media stream.  However, a flow is
   not necessarily 1:1 mapped to a transport connection. </t>


<t>Traditionally, flow classifiers have been based on the 5-tuple of the
   source and destination addresses, ports, and the transport protocol
   type.  However, some of these fields may be unavailable due to either
   fragmentation or encryption, or locating them past a chain of IPv6
   extension headers may be inefficient.  Additionally, if classifiers
   depend only on IP layer headers, later introduction of alternative
   transport layer protocols will be easier. </t>

<t>The usage of the 3-tuple of the Flow Label and the Source and
   Destination Address fields enables efficient IPv6 flow
   classification, where only IPv6 main header fields in fixed positions
   are used. </t>

<t>The flow label could be used in both stateless and stateful scenarios.
   A stateless scenario is one where any node that processes the flow label in any way
   does not need to store any information about a flow before or after a packet has been
   processed. A stateful scenario is one where a node that processes the flow label value
   needs to store information about the flow, including the flow label value. A stateful
   scenario might also require a signaling mechanism to establish flow state in the network. </t>

<t>The flow label can be used most simply in stateless scenarios.
   This specification concentrates on the stateless model and how it can be used
   as a default mechanism. Details of stateful models, signaling, specific flow state
   establishment methods and their related service models are out of scope for this
   specification. The basic requirement for stateful models is
   set forth in <xref target="estreq"/>.  </t>

<t>The minimum level of IPv6 flow support consists of labeling the
   flows. A specific goal is to enable and encourage the use of the
   flow label for various forms of stateless load distribution, especially across
   Equal Cost Multi-Path (EMCP) and/or Link Aggregation Group (LAG) paths.
   ECMP and LAG are methods to bond together multiple physical links used to 
   procure the required capacity necessary to carry an offered load
   greater than the bandwidth of an individual physical link.     
   IPv6 source nodes SHOULD be able
   to label known flows (e.g., TCP connections, application streams),
   even if the node itself does not require any flow-specific
   treatment.  Node requirements for stateless flow
   labeling are given in <xref target="labreq"/>. </t>


<t>This document replaces <xref target="RFC3697"/> and Section 6 and Appendix A of <xref target="RFC2460"/>. 
A rationale for the changes made is documented in <xref target="I-D.ietf-6man-flow-update"/>.
The present document also includes
a correction to <xref target="RFC2205"/> concerning the flow label.</t>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section> <!-- intro -->



<section anchor="spec" title="IPv6 Flow Label Specification">

<t>The 20-bit Flow Label field in the IPv6 header <xref target="RFC2460"/> is used by a
   node to label packets of a flow.  A Flow Label of zero is used to
   indicate packets that have not been labeled.  Packet classifiers can use the
   triplet of Flow Label, Source Address, and Destination Address fields
   to identify which flow a particular packet belongs to.  Packets are
   processed in a flow-specific manner by nodes that are able to do so in a
   stateless manner, or that have been set up with flow-specific state.
   The nature of the specific treatment and the methods for flow state establishment
   are out of scope for this specification. </t>

<t>Flow label values should be chosen such that their bits exhibit
   a high degree of variability, making them suitable for use as part of
   the input to a hash function used in a load distribution scheme.
   At the same time, third parties should be unlikely to be able to
   guess the next value that a source of flow labels will choose. </t>

<t>In statistics, a discrete uniform distribution is defined as
   a probability distribution in which each value in a given range
   of equally spaced values (such as a sequence of integers) is equally
   likely to be chosen as the next value. The values in such a distribution
   exhibit both variability and unguessability. Thus, as specified below
   in <xref target="labreq"/>, an approximation to
   a discrete uniform distribution is preferable as the source of
   flow label values. Intentionally, there are no precise mathematical requirements
   placed on the distribution or the method used to achieve such a distribution.</t>

<t>Once set to a non-zero value, the Flow Label MUST be delivered unchanged to
   the destination node(s). That is, a forwarding node MUST NOT change the flow label value in an arriving packet if
   it is non-zero. 
   A possible exception to this rule is if a security gateway for operational security
   reasons changes a non-zero Flow Label value to a different non-zero value
   compliant with this RFC; see <xref target="covert"/> for details. </t>

<t> There is no way to verify whether a flow label has been modified en route
or whether it belongs to a uniform distribution.
Therefore, no Internet-wide mechanism can depend mathematically on unmodified and uniformly
distributed flow labels; they have a "best effort" quality. 
Implementers should be aware that the flow label is an unprotected field that could have been
accidentally or intentionally changed en route (see <xref target="security"/>).
This leads to the following formal rule:</t>

<list style="symbols">
<!-- <t>Implementations MUST
   take appropriate steps to protect themselves from being
   vulnerable to denial of service and other types of attack that
   could result (see <xref target="theft"/>).</t>  -->

<t>Forwarding nodes such as routers and load distributors MUST NOT depend only on Flow Label
values being uniformly distributed. In any usage such as a hash key for load distribution,
the Flow Label bits MUST be combined at least with bits from other sources within the packet,
so as to produce a constant hash value for each flow and a suitable distribution of hash
values across flows. Typically the other fields used will be some or all components
of the usual 5-tuple. In this way, load distribution will still occur even if the Flow Label
values are poorly distributed. </t>
</list>

<t> Although uniformly distributed flow
label values are recommended below, and will always be helpful for load distribution, it is unsafe to assume
their presence in the general case, and the use case needs to work even if the flow label
value is zero. </t>


<t>As a general practice, packet flows should not be reordered, and the use of the Flow Label field does not affect this.  In particular, a Flow label value of zero does not imply that reordering is acceptable. </t>

<!-- <t>An IPv6 node that does not set the flow label to a non-zero value, or make use of it in any way, MUST
   ignore it when receiving or forwarding a packet. </t> -->
</section> <!-- spec -->


<section anchor="labreq" title="Flow Labeling Requirements in the Stateless Scenario">

<t>This section defines the minimum requirements for methods of setting the flow label value
within the stateless scenario of flow label usage. </t>

<t>To enable Flow Label based classification, source nodes SHOULD assign
   each unrelated transport connection and application data stream to a
   new flow. A typical definition of a flow for this purpose is any set
   of packets carrying the same 5-tuple {dest addr, source addr, protocol, dest port, source port}. </t>

   <t>It is desirable that flow label values should be uniformly distributed
   to assist load distribution. It is therefore RECOMMENDED that source hosts support the flow label by 
   setting the flow label field for all packets of a given flow to the same value
   chosen from an approximation to a discrete uniform distribution. 
   Both stateful and stateless methods of assigning a value could be used,
   but it is outside the scope of this specification to mandate an algorithm. 
   The algorithm SHOULD ensure that the resulting flow label values are unique
   with high probability.  However, if two simultaneous flows are by chance assigned the same
   flow label value, and have the same source and destination addresses, it simply
   means that they will receive the same treatment throughout the network.
   As long as this is a low probability event, it will not significantly affect load distribution. </t>

<t>A possible stateless algorithm is to use a suitable 20 bit hash of values from the IP packet's 5-tuple.
A simple hash function is described in <xref target="Appendix1"/>. 
</t>

<t>An alternative approach is to to use a pseudo-random number generator to assign a flow label value for
a given transport session; such a method will require minimal local state to be kept at the source node,
by recording the flow label associated with each transport socket. </t>

<t>Viewed externally, either of these approaches will produce values that appear to be uniformly distributed and pseudo-random. </t>

<t>An implementation in which flow labels are assigned sequentially is NOT RECOMMENDED, as it would then
be simple for on-path observers to guess the next value. </t>

<!-- <t>An OPTIONAL algorithm for generating such a pseudo-random value is described in <xref target="I-D.gont-6man-flowlabel-security"/>. </t> -->

<!-- The preceding sentence was deleted, and the reference was changed to Informative, since the cited draft is not progressing on the standards track at this time. --> 

<t>A source node which does not otherwise set the flow label
   MUST set its value to zero. </t>

<t>A node that forwards a flow whose flow label value in arriving packets is zero
MAY change the flow label value. In that case, it is RECOMMENDED 
that the forwarding node sets the flow label field for a flow to a uniformly distributed value
as just described for source nodes. </t>
 <list style='symbols'>
 <t>The same considerations apply as to source hosts setting the flow label; in particular,
 the normal case is that a flow is defined by the 5-tuple. </t>
 <t>This option, if implemented, would presumably be used by first-hop or ingress routers. It might place a
 considerable per-packet processing load on them, even if they adopted a stateless method of 
 flow identification and label assignment. This is why the principal recommendation is that 
 the source host should set the label.
 </t>
 </list>

<t>The preceding rules taken together allow a given network to
include routers that set flow labels on behalf of hosts that do not do so.
They also recommend that flow labels exported
to the Internet are always either zero or uniformly distributed. </t>



</section> <!-- labreq -->


<section anchor="estreq" title="Flow State Establishment Requirements">

<t>A node that sets the flow label MAY also take part in a flow state
   establishment method that results in assigning specific treatments to
   specific flows, possibly including signaling.  Any such method MUST NOT
   disturb nodes taking part in the stateless scenario just described. Thus, any node that sets
   flow label values according to a stateful scheme MUST choose labels that
   conform to <xref target="labreq"/> of the present specification. Further details
   are not discussed in this document. </t>

</section> <!-- estreq -->


<section title="Essential correction to RFC 2205">
<t><xref target="RFC2460"/> reduced the size of the flow label field from 24 to 20 bits.
The references to a 24 bit flow label field on pages 87 and 88 of <xref target="RFC2205"/> are updated accordingly. </t>
</section>


<section anchor="security" title="Security Considerations">

<t>This section considers security issues raised by the use of the Flow
   Label, including the potential for denial-of-service attacks, and the
   related potential for theft of service by unauthorized traffic
   (<xref target="theft"/>).  <xref target="ipsec"/> addresses the use of the Flow Label in
   the presence of IPsec including its interaction with IPsec tunnel
   mode and other tunneling protocols.  We also note that inspection of
   unencrypted Flow Labels may allow some forms of traffic analysis by
   revealing some structure of the underlying communications.  Even if
   the flow label were encrypted, its presence as a constant value in a
   fixed position might assist traffic analysis and cryptoanalysis. </t>

<t>The flow label is not protected in any way, even if IPsec authentication <xref target="RFC4302"/> 
is in use, so it can be forged by an on-path attacker. Implementers are advised that any en-route
change to the flow label value is undetectable. On the other hand, a uniformly distributed
pseudo-random flow label cannot be readily guessed by an attacker; see 
<xref target="I-D.gont-6man-flowlabel-security"/> for further discussion. </t>

<section anchor="covert" title="Covert Channel Risk">

<t>The flow label could be used as a covert data channel, since apparently
   pseudo-random flow label values could in fact consist of covert data. This
   could for example be achieved using a series of otherwise innocuous UDP
   packets whose flow label values constitute a covert message, or by co-opting
   a TCP session to carry a covert message in the flow labels of successive packets.
   Both of these could be recognised as suspicious - the first because isolated UDP
   packets would not normally be expected to have non-zero flow labels, and the
   second because the flow label values in a given TCP session should all
   be equal. However, other methods, such as co-opting the flow labels of
   occasional packets, might be rather hard to detect. </t>

   <t>In situations where the covert channel risk is considered significant,
   the only certain defense is for a firewall
   to rewrite non-zero flow labels in a stateless manner, like a first-hop
   router (see <xref target="labreq"/>). This would be an exceptional violation
   of the rule that the flow label, once set to a non-zero value, must not be changed.
   To preserve load distribution capability, such a firewall MUST NOT set non-zero
   flow labels to zero.
   </t>

</section>

<section anchor="theft" title="Theft and Denial of Service">

<t>Since the mapping of network traffic to flow-specific treatment is
   triggered by the IP addresses and Flow Label value of the IPv6
   header, an adversary may be able to obtain unintended service by
   modifying the IPv6 header or by injecting packets with false
   addresses and/or labels.  Theft of service is not further discussed
   in this document, since it can only be analysed for specific stateful
   methods of using the flow label. However, a denial of service attack 
   becomes possible in the stateless model when the modified or injected
   traffic depletes the resources available to forward it and other
   traffic streams.  If a DoS attack were undertaken
   against a given Flow Label (or set of Flow Labels), then traffic
   containing an affected Flow Label might well experience worse-than-best-effort
   network performance. </t>

<t>Note that since the treatment of IP headers by nodes is typically
   unverified, there is no guarantee that flow labels sent by a node are
   set according to the recommendations in this document.
   A man-in-the-middle or injected-traffic denial of service attack specifically
   directed at flow label handling would involve setting unusual flow labels.
   For example, an attacker could set all flow labels reaching a given router
   to the same arbitrary non-zero value, or could perform rapid cycling of
   flow label values such that the packets of a given flow will each have
   a different value. Either of these attacks would cause a stateless load
   distribution algorithm to perform badly and would cause a stateful
   classifier to behave incorrectly. For this reason, stateless classifiers
   should not use the flow label alone to control load distribution,
   and stateful classifiers should include explicit methods to detect
   and ignore suspect flow label values. </t> 

<t>Since flows are identified by the 3-tuple of the Flow Label and the
   Source and Destination Address, the risk of denial of
   service introduced by the Flow Label is closely related to the risk
   of denial of service by address spoofing.  An adversary who
   is in a position to forge an address is also likely to be able to
   forge a label, and vice versa. </t>

<t>There are two issues with different properties: Spoofing of the Flow
   Label only, and spoofing of the whole 3-tuple, including Source and
   Destination Address. </t>

<t>The former can be done inside a node which is using or transmitting
   the correct source address.  The ability to spoof a Flow Label
   typically implies being in a position to also forge an address, but
   in many cases, spoofing an address may not be interesting to the
   spoofer, especially if the spoofer's goal is theft of service, rather
   than denial of service. </t>

<t>The latter can be done by a host which is not subject to ingress
   filtering <xref target="RFC2827"/> or by an intermediate router. Due to its
   properties, this is typically useful only for denial of service. In
   the absence of ingress filtering, almost any third party could
   instigate such an attack. </t>

<t>In the presence of ingress filtering, forging a non-zero Flow Label
   on packets that originated with a zero label, or modifying or
   clearing a label, could only occur if an intermediate system such as
   a router was compromised, or through some other form of man-in-the-
   middle attack.  </t>

</section>
<section anchor="ipsec" title="IPsec and Tunneling Interactions">

<t>The IPsec protocol, as defined in <xref target="RFC4301"/>, <xref target="RFC4302"/>,
   <xref target="RFC4303"/> does not include
   the IPv6 header's Flow Label in any of its cryptographic calculations
   (in the case of tunnel mode, it is the outer IPv6 header's Flow Label
   that is not included).  Hence modification of the Flow Label by a
   network node has no effect on IPsec end-to-end security, because it
   cannot cause any IPsec integrity check to fail.  As a consequence,
   IPsec does not provide any defense against an adversary's
   modification of the Flow Label (i.e., a man-in-the-middle attack). </t>

<t>IPsec tunnel mode provides security for the encapsulated IP header's
   Flow Label.  A tunnel mode IPsec packet contains two IP headers: an
   outer header supplied by the tunnel ingress node and an encapsulated
   inner header supplied by the original source of the packet.  When an
   IPsec tunnel is passing through nodes performing flow classification,
   the intermediate network nodes operate on the Flow Label in the outer
   header.  At the tunnel egress node, IPsec processing includes
   removing the outer header and forwarding the packet (if required)
   using the inner header.  The IPsec protocol requires that the inner
   header's Flow Label not be changed by this decapsulation processing
   to ensure that modifications to label cannot be used to launch theft-
   or denial-of-service attacks across an IPsec tunnel endpoint.  This
   document makes no change to that requirement; indeed it forbids
   changes to the Flow Label. </t>

<t>When IPsec tunnel egress decapsulation processing includes a
   sufficiently strong cryptographic integrity check of the encapsulated
   packet (where sufficiency is determined by local security policy),
   the tunnel egress node can safely assume that the Flow Label in the
   inner header has the same value as it had at the tunnel ingress node. </t>

<t>This analysis and its implications apply to any tunneling protocol
   that performs integrity checks.  Of course, any Flow Label set in an
   encapsulating IPv6 header is subject to the risks described in the
   previous section. </t>
</section>

<section title="Security Filtering Interactions">

<t>The Flow Label does nothing to eliminate the need for packet
   filtering based on headers past the IP header, if such filtering is
   deemed necessary for security reasons on nodes such as firewalls or
   filtering routers. </t>

</section>

   
</section> <!-- security -->

<section title="Differences from RFC 3697"/>

<t>The main differences between this specification and its predecessor are as follows:</t>
<list style="symbols">
<t>This specification encourages non-zero flow label values
to be used, and clearly defines how to set a non-zero value. </t>
<t>It encourages a stateless model with uniformly distributed flow
label values. </t>
<t>It does not specify any details of a stateful model. </t>
<t>It retains the rule that the flow label must not be changed en route, but allows routers to set the label on behalf of hosts that do not do so. </t>
<t>It discusses the covert channel risk and its consequences for firewalls. </t>
</list>
<t>For further details see <xref target="I-D.ietf-6man-flow-update"/>. </t>



<section anchor="iana" title="IANA Considerations">
   <t>This document requests no action by IANA. </t>
</section> <!-- iana -->




<section anchor="ack" title="Acknowledgements">

<t>
Valuable comments and contributions were made by
Ran Atkinson,
Fred Baker,
Steve Blake,
Remi Despres,
Alan Ford,
Fernando Gont,
Brian Haberman,
Tony Hain,
Joel Halpern,
Qinwen Hu,
Chris Morrow,
Thomas Narten,
Mark Smith,
Pascal Thubert,
Iljitsch van Beijnum,
and other participants in the 6man working group.</t>

<t>Cristian Calude suggested the von Neumann algorithm in <xref target="Appendix1"/>. </t>

<t>Steve Deering and Alex Conta were co-authors of RFC 3697, on which this document is based. </t>

<t>Contributors to the original development of RFC 3697 included
   Ran Atkinson, Steve Blake, Jim Bound, Francis Dupont,
   Robert Elz, Tony Hain, Robert Hancock, Bob Hinden, Christian Huitema,
   Frank Kastenholz, Thomas Narten, Charles Perkins, Pekka Savola,
   Hesham Soliman, Michael Thomas, Margaret Wasserman, and Alex Zinin. </t>

<t>This document was produced using the xml2rfc tool
<xref target="RFC2629"/>.</t>

</section> <!-- ack -->


<section anchor ="changes" title="Change log [RFC Editor: Please remove]">

<t>draft-ietf-6man-flow-3697bis-04: update to resolve further WG comments, 2011-05-11:</t>
  <list style="symbols">
  <t>Suggested a specific hash algorithm to generate a flow label. </t>
  <t>Removed reference to stateful domain. </t>
  <t>Added text about covert channel and tuned text about firewall behavior; removed
     the confusing word "immutable". </t>
  <t>Added that Section 6 of RFC 2460 is replaced. </t>
  <t>Editorial fixes. </t>
  </list>


<t>draft-ietf-6man-flow-3697bis-03: update to resolve WGLC comments, 2011-05-02:</t>
  <list style="symbols">
  <t>Clarified that the network layer view of flows is agnostic about transport sessions. </t>
  <t>Honed the definition of stateless v stateful models. </t>
  <t>Honed the text about using a pseudo-random function. </t>
  <t>Moved material about violation of immutability to Security section, and rephrased accordingly. </t>
  <t>Dropped material about setting the flow label at a domain exit router: doesn't belong here now that we have dropped almost all the stateful text. </t>
  <t>Removed normative reference to draft-gont-6man-flowlabel-security. </t>
  <t>Removed the statement that a node that does not set or use the flow label must ignore it: this statement appears to be a no-op. </t>
  <t>Added a summary of changes from RFC 3697. </t>
  <t>Miscellaneous editorial fixes. </t>
  </list>
<t>draft-ietf-6man-flow-3697bis-02: update to remove most text about stateful methods, 2011-03-13</t>
<t>draft-ietf-6man-flow-3697bis-01: update after resolving 11 initial issues, 2011-02-26</t>
<t>draft-ietf-6man-flow-3697bis-00: original version, built from RFC3697 and draft-ietf-6man-flow-update-01, 2011-01-31</t>


</section> <!-- changes -->

</middle>

<back>

<references title="Normative References">

&RFC2460;
&RFC2119;
&RFC2205;


</references>

<references title="Informative References">

&RFC2629;
&RFC2827;
&RFC3697;
&RFC4301;
&RFC4302;
&RFC4303;
&DRAFT-rationale;
&DRAFT-gont;

<reference anchor='vonNeumann' >
<front>
<title>Various techniques used in connection with random digits</title>
<author initials="J." surname="von Neumann" fullname="John von Neumann"/>
<date year='1951'/>
</front>
<seriesInfo name="National Bureau of Standards Applied Math Series" value="12, 36-38"/>
</reference>

  
</references>

<section anchor="Appendix1" title="Simple 20-bit Hash Function">

<t>As mentioned in <xref target="labreq"/>, a stateless hash function may be used to generate a flow label value from
an IPv6 packet's 5-tuple. An example function, based on an algorithm by von Neumann known to produce
an approximately uniform distribution <xref target="vonNeumann"/>, is as follows:</t>

<t><list style="numbers">
<t>Split the destination and source addresses into two 64 bit values each, thus transforming
the 5-tuple into a 7-tuple. </t>
<t>Add the seven components together using unsigned 64 bit arithmetic, discarding any carry bits. </t>
<t>Apply the von Neumann algorithm to the resulting string of 64 bits: 
      <list><t>Starting at the least significant end, select two bits. </t>
            <t>If the two bits are 00 or 11, discard them. </t>
            <t>If the two bits are 01, output a 0 bit. </t>
            <t>If the two bits are 10, output a 1 bit. </t>
            <t>Repeat with the next two bits in the input 64 bit string. </t>
            <t>Stop when 20 bits have been output (or when the 64 bit string is exhausted). </t> </list></t> 
<t>In the highly unlikely event that the result is exactly zero, 
set the flow label arbitrarily to the value 1. </t>
</list></t>

</section>



</back>
</rfc>

