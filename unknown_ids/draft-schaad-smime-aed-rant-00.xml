<?xml version="1.0" encoding="UTF-8"?><?rfc linefile="1:aed-review.xml"?>
<!-- automatically generated by xml2rfc v1.35 on 2010-11-23T07:10:22Z -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!--
--><!-- xml2rfc-processed-entity RFC3610 -->
  <!-- xml2rfc-processed-entity RFC3852 -->
  <!-- xml2rfc-processed-entity RFC5083 -->
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xlst' ?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<rfc category="info" docName="draft-schaad-smime-aed-rant-00" ipr="trust200902">
  <front>
    <title abbrev="AED Comments">Commentary on the Design of the Authenticated Encrypted Data Content Type</title>
    <author fullname="Jim Schaad" initials="J." surname="Schaad">
      <organization>Soaring Hawk Consulting</organization>
      <address>
        <email>jimsch@augustcellars.com</email>
      </address>
    </author>
    <date/>
    <abstract>
      <t>The Authenticated Encrypted Data Content Type allows for the use of Authenticated Encryption modes with block cipher algorithms.  At the time of the original design there was discussion about the relative location of the authenticated attributes and the encrypted content in the ASN.1 structure.  With the benefits of implementation experience I revisit the discussion made  at the time and re-evaluate the decision made.</t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction">
      <t>
        When the Authenticated Encryption content type defined in RFC 5083 <xref target="RFC5083"/> was being discussed, the S/MIME working group had no actual implementation experience to guide it in some of the decisions that were being made at the time.  
The final ASN.1 adopted has been replicated in in <xref target="ASN"/> for the convenience of the reader.</t>
<t>The major focus of the discussions centered on the relative placement of the encrypted data blob (contained in  the authEncryptedContentInfo field) and the authenticated attributes (contained in the authAttrs field).  As can be seen from the ASN.1 the final decision was to place the authenticated data after the encrypted content.  This was counter to the arguments that I made at the time which was to place the authenticated data before the encrypted content.</t>
<figure title="AuthEnvelopedData ASN.1 Extract" align="center" anchor="ASN"><artwork>
 AuthEnvelopedData ::= SEQUENCE {
   version CMSVersion,
   originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
   recipientInfos RecipientInfos,
   authEncryptedContentInfo EncryptedContentInfo,
   authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
   mac MessageAuthenticationCode,
   unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
</artwork></figure>
      <t>In this document I am revisiting that decision based on the implementation experience that I have since garnered and re-evaluate the location of these two fields based on that experience.</t>
      <t>This document is organized as follows:
        <list style="symbols">
          <t><xref target="history"/> contains a review of the arguments presented at the time.</t>
          <t><xref target="algs"/> has a taxonomy  of a number of authenticated encryption algorithms.</t>
          <t><xref target="criteria"/> presents a set of criteria to be used.</t>
          <t><xref target="opinion"/> contains my personal conclusions on the issue.</t>
          <t><xref target="rebuttal"/> contains rebuttals (or maybe not).</t>
        </list>
      </t>
      <t>The major part of my discussion focuses on the desirability to use a streaming model for processing the ASN.1 structure and the data contained within it.  This will be further detailed in <xref target="criteria"/>.</t>
      <section title="Terminology">
        <t>The following is a list of standardized terms used in the document:
          <list style="hanging">
            <t hangText="AE"> is an abbreviation for Authenticated Encryption.  This is block cipher mode of operation which simultaneously provides confidentiality and integrity assurances on the data.</t>
            <t hangText="AEAD"> is an abbreviation for Authenticated Encryption with Auxiliary Data.  This is a block cipher mode of operation which simultaneously provides confidentiality and integrity assurances on the message data as well as integrity assurances on an additional set of data.</t>
            <t hangText="Message Data"> is the section of the input data that is to be authenticated and encrypted by the AE or AEAD algorithm mode. For CMS, the encrypted message data is placed in the encryptedContent field of the authEncryptedContentInfo sequence.</t>
            <t hangText="Authenticated Data"> is the section of input data that is to be authenticated but not encrypted.  For CMS, the authenticated data is the sequence in the authAttrs field.</t>
            <t hangText="Authentication Tag"> is a value that is generated by the mode which is used to validate the integrity of the data.  The Authentication Tag is sometimes implicit and does not exist as an independent value.  For CMS, it is assumed that the use of the algorithm will define an explicit tag and the tag will be placed in the mac field.</t>
            <t hangText="Streaming Model"> is a method of doing the processing such that the ASN.1 processing and the cryptographic processing can be interleaved with each other.</t>
          </list>
        </t>
      </section>
    </section>
    <section title="Historic Arguments" anchor="history">
      <t>A review of the mailing list threads at the time the issue was being debated lead to the following issues being discussed.</t>
      <t>
        <list style="numbers">
          <t>Consistency with the existing CMS data types:
            <list style="empty">
            <t>PRO:  We have working implementations of both AuthenticatedData and SignedData which work.  In both of these cases the data structures are ordered such that the message data precedes the authenticated data.  Keeping the order consistent makes coding easier and leads to fewer mistakes.</t>
            <t>CON:  Being constant is nice, however if it does not work correctly that does not matter.</t>
            </list>
          </t>
          <t>Authenticated attributes that are derived from the message content:
            <list style="empty">
              <t>PRO: It should be possible to create authenticated attributes based on the content of the data to be encrypted and have these attributes authenticated.  Placing the attribute before the message content means that one must buffer the message content to do this. 
The example of this presented on the mailing list was the ability for a sender to process the body of the message on fly by a virus checker and publish the result of the virus checking as an authenticated attribute.  
This is the same thing that currently happens today for both SignedData and AuthenticatedData where the hash of the message data is computed on the fly and then placed in the signed/authenticated attributes when are then processed to compute the signature or mac values.
</t>
              <t>CON: Placing this information after the message data means that the recipient can not know to perform matching processing, if necessary, in order to check the value presented by the sender.  The analogous step for the SignedData structure is the need for the recipient to hash the message data during processing in order to correctly validate the signed attribute fields.</t>
            </list>
          </t>
          <t>The decision should be dictated by Algorithm Characteristics:
            <list style="empty">
              <t>PRO: The order of placing the attributes before the message data was dictated by a specific choice of algorithms (CCM and GCM) and that other authenticated encryption algorithms (specifically CWC) would naturally place the attributes second.</t>
              <t>CON: No detailed analysis of algorithms was done.  However, the attribute data should be expected to be much smaller than the message data and thus it makes more sense to cache the attributes for later processing than to cache the message data for later processing.</t>
            </list>
          </t>
          <t>Resource requirements for the sender and recipient:
            <list style="empty">
              <t>What happens with resource constrained devices that are acting as senders or recipients?  The initial argument dealt with the question of resource limited senders that would not be able to store intermediate data, but the same question applies to resource limited recipients.  We know that this was intended to be used with firmware upgrades as one option, but it could equally be used by a device sending out reports to a central server.  This is a case where a close analysis would need to be done on the algorithm being used and how it will affect the resources needed.</t>
            </list>
          </t>
          <t>Relative frequency of processing:  
            <list style="empty">
              <t>There was a certain amount of discussion of the question of the relative frequency of processing between the sender and the recipient of a message.  This would have bearing on the question of which entity the decisions should be optimized for.  One set of people argued that recipients process messages more frequently than senders.  Another set of people argued that there exist applications where the sender may create messages that are never verified.</t>
            </list>
          </t>
        </list>
      </t>
    </section>
    <section title="Algorithm Taxonomy" anchor="algs">
      <t>As can be seen from some of the arguments above, we needed to have done an analysis of the AEAD algorithms that might be used with the new data structure in order to get better input for the decision that was made.  In this section, we will define a set of criteria that we are going to use to analysis the set of algorithms and then describe how each algorithm fits our criteria.</t>

      <t>NIST has been gathering information on Authenticated Encryption Modes over the last decade.  Information on these modes can be found at <eref target="http://crc.nist.gov/groups/ST/toolkit/BCM/modes_development.html"/>.  For simplicity I used this as the set of algorithms to look at in order to characterize the requirements for the purposes of comparison with the characteristics required by the Authenticated Encryption data structure.</t>

      <t>In this section we will look at 11 AE algorithms from the NIST submissions along with an algorithm <xref target="GUTMANN"/> being developed by Peter Gutmann.  Since we are interested in how to setup a streaming model, the criteria we are looking at are chosen with that in mode.  The major characteristics we are going to be looking at are:

        <list style="numbers">
          <t>What are the parameters used for the algorithm?  This contains a list of the elements that are needed for processing exclusive of the key value.  These are the items that would need to be encoded in the ASN.1 parameters field of AlgorithmInformation.</t>
          <t>What information is actually authenticated?  This is a list of the data which is actually authenticated in the order of authentication.</t>
          <t>What information is required before the first byte of message data can be processed?  Assuming that the first byte of message data is to be processed upon it being decoded from the ASN.1 (or encoded to ASN.1), what items of information are needed by the encryption/decryption algorithm prior to it being encrypted.</t>
          <t>What information is required before the first byte authenticated data can be processed?  Assuming that the first byte of authenticated data is to be processed upon it being decoded from the ASN.1 (or encoded to ASN.1), what items of information are needed by the encryption/decryption algorithm prior to it being authenticated.</t>
        </list>
</t>

      <t>NIST is currently in the middle of doing a review and selection process for new modes to adopt as US security standards.  For simplicity the set of algorithms that I will be looking at come from the current set of candidate algorithms that are being reviewed for this purpose.  One additional algorithm added to this is a simple hash and encrypt algorithm that has been proposed by Peter Gutmann.</t>
      <section title="CCM: Counter with CBC-MAC" anchor="CCM">
        <t>The Counter with CBC-MAC (CCM) mode was deisgned and documented by Doug Whiting, Russ Housley and Niels Ferguson.  A full description of the mode can be found in RFC 3610 <xref target="RFC3610"/> and on the NIST website.  CCM is one of the standardized NIST modes (see <xref target="NIST-800-38C"/>) and is one of the two modes that are currently documented for use with the CMS Authenticated Encryption structures.</t>
        <t>The characteristics of the algorithm are:
          <list style="numbers">
            <t>The parameters of the algorithm are a nonce and the length of the tag to be generated.</t>
            <t>The data actually authenticated is:
              <list style="letters">
                <t>The nonce value,</t>
                <t>The length of authentication tag,</t>
                <t>The length of message data,</t>
                <t>The length of authenticated data,</t>
                <t>The authenticated data,</t>
                <t>The message data</t>
              </list>
            </t>
            <t>Before the first byte of message data can be processed, you must know:
              <list style="letters">
                <t>The nonce value</t>
                <t>The length of the authentication tag</t>
                <t>The length of the message</t>
                <t>The length of authenticated data,</t>
                <t>The authenticated data</t>
              </list>
            </t>
            <t>Before the first byte of the authenticated data can be processed, you must know:
              <list style="letters">
                <t>The nonce value,</t>
                <t>The length of the authentication tag</t>
                <t>The length of the message</t>
                <t>The length of authenticated data,</t>
              </list>
            </t>
          </list>
        </t>
        <t>This algorithm mode provides major problems for a sender to process in a streaming model.  The lengths of the message data and the authenticated data are both required to be known before any bytes of the message data or authenticated data can be processed.  Except in cases where fixed length messages will be generated, it is required that the message data be cached prior to encrypting.</t>
        <t>This algorithm provides some problems for recipients in processing, but under the correct circumstances can be processed under a streaming model.  The length of the message data must be presented to the recipient before the message data is given.  The authenticated data must be presented before the message data is presented.  Optimal use of this algorithm would require that 1) the authenticated data be moved before the message data bytes and 2) a requirement be established that either the message data be DER encoded or the message data length be published as part of the authenticated data.</t>
      </section>
      <section title="CS: Cipher-State">
        <t>Cipher-State is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interested to this discussion.</t>
      </section>
      <section title="CWC: Carter Wegman with Counter">
        <t>The Carter Wegman with Counter Authenticated Encryption mode was designed by Tadayoshi Kohno, John Viega and Doug Whiting.  A full description of the mode can be found in <xref target="CWC"/> and on the NIST website.</t>
        <t>The characteristics of the algorithm are:
          <list style="numbers">
            <t>The only parameter of the algorithm is a nonce.</t>
            <t>The data actually authenticated is:
              <list style="letters">
                <t>The nonce,</t>
                <t>The authenticated data,</t>
                <t>The encrypted message data</t>
              </list>
            </t>
            <t>Before the first byte of data can be processed, you must know:
              <list style="letters">
                <t>The nonce value,</t>
                <t>The authenticated data</t>
              </list>
            </t>
            <t>Before the first byte of authenticated data can be processed, you must know:
              <list style="letters">
                <t>The nonce value</t>
              </list>
            </t>
          </list>
        </t>
        <t>It should be noted that the analysis above is for a simplistic implementation of the algorithm such as would normally be done in software.  The algorithm is designed so that it can be performed in parallel, it would be possible for message data bytes to be fully processed before the authenticated data bytes are processed.  The full details of this approach are not spelled out in the referenced documents.</t>
        <t>This algorithm can be easily streamed for the sender provided that the authenticated data are generated  prior to the message data being generated.</t>
        <t>This algorithm can be easily streamed for the recipient provided that the authenticated data is presented prior to the message data being presented.</t>
      </section>
      <section title="EAX: A Conventional Authenticated-Encryption Mode">
        <t>A Conventional Authenticated-Encryption Mode was designed and documented by M. Bellare, P. Rogaway and D. Wagner.  A full description of the algorithm can be found at <xref target="EAX"/> and on the NIST website.</t>
        <t>The characteristics of the algorithm are:
          <list style="numbers">
            <t>The only parameter of the algorithm is a nonce.</t>
            <t>The data actually authenticated is:
              <list style="letters">
                <t>The nonce,</t>
                <t>The authenticated attributes,</t>
                <t>The encrypted message.</t>
              </list>
            </t>
            <t>Before the first byte of data can be processed, you must know:
              <list style="letters">
                <t>The nonce value.</t>
              </list>
            </t>
            <t>Before the first byte of the data can be processed, you must know:
              <list style="letters">
                <t>The nonce value.</t>
              </list>
            </t>
            <t>Before the first byte of authenticated data can be processed, you must know: nothing.</t>
          </list>
        </t>
        <t>This mode computes the authentication value on the authenticated data and on the encrypted message separately - so they can be computed in any order - and combines the results together after the entire message has been processed.</t>
        <t>This algorithm can easily be streamed for the sender.  The order of generating the authenticated data and message data is immaterial.</t>
        <t>This algorithm can easily be streamed for the recipient.  The order of presenting the authenticated data and the message data is immaterial.</t>
      </section>
      <section title="GCM: Galois/Counter Mode">
        <t>The Galois/Counter Mode of Operation (GCM) was designed and documented by David McGrew and John Viega.  A full description of the algorithm can be found on the NIST website.  GCM is one of the standardized NIST modes (see <xref target="NIST-800-38D"/>) and is one of the two modes that are currently documented for use with the CMS Authenticated Encryption structures.</t>
        <t>The characteristics of the algorithm are:
          <list style="numbers">
            <t>The parameters of the algorithm are a nonce and the length of the tag to be generated.</t>
            <t>The data actually authenticated is:
              <list style="letters">
                <t>The authenticated data,</t>
                <t>The encrypted message data,</t>
                <t>The length of the authenticated data,</t>
                <t>The length of the message data.</t>
              </list>
            </t>
            <t>Before the first byte of message data can be processed, you must know:
              <list style="letters">
                <t>The nonce value.</t>
                <t>The authenticated data.</t>
              </list>
            </t>
            <t>Before the first byte of authenticated data can be processed you must know: nothing.</t>
          </list>
        </t>
        <t>This mode can easily be used in a stream model for senders provided the authenticated data is generated prior to the message data.</t>
        <t>This mode can easily be used in a stream model for recipients provided that the authenticated data is presented prior to the message data.</t>
      </section>
      <section title="IACBC: Integrity Aware Cipher Block Chaining">
        <t>Integrity Aware Cipher Block Chaining is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interested to this discussion.</t>
      </section>
      <section title="IAPM: Integrity Aware Parallelizable Mode">
        <t>Integrity Aware Parallelizable Mode is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interested to this discussion.</t>
      </section>
      <section title="OCB: Offset Codebook">
        <t>Offset Codebook mode is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interested to this discussion.</t>
        <t>However, an addendum to the original mode submission described a method of adding the AEAD capability to any AE algorithm.  This was described by Phillip Rogaway in <xref target="OCB-AD1"/> as section 5 and designated as Ciphertext Translation.</t>
        <t>The characteristics of this algorithm are:
          <list style="numbers">
            <t>This mode adds no additional parameters to the underlying AE algorithm parameters.</t>
            <t>The data actually authenticated is:
              <list style="letters">
                <t>The message data</t>
                <t>The authenticated data</t>
              </list>
            </t>
            <t>Before the first byte of data can be processed, you must know: the same information as for the AE mode by itself.</t>
            <t>Before the first byte of authenticated data can be processed you must know: nothing.</t>
          </list>
        </t>
        <t>It needs to be noted that before one can process the last t bytes of the message (for either encryption or decryption) the authenticated data must be known.  The value t is equal to the length of the output function for the authenticated data processor.  This does mean that an indication that one is in the last t bytes of processing the data is needed for both encryption and decryption modes.</t>
        <t>The sender can operate using a streaming model as long as it buffers the last t bytes of message data so that it can be correctly tagged and sent to the cryptographic code as needing special processing.  The authenticated data must be computed prior to the last t bytes of the encryption stream being produced.  One possible way of dealing with this is to make the last t bytes the authentication tag as there is no explicit authentication tag created.</t>
        <t>The recipient can operate using a streaming model as long as it buffers the last t bytes of encrypted data so that it can be correctly tagged when sent to the cryptographic code.  As no separate authentication tag is created by the algorithm, the authenticated attributes must be presented prior to the last bytes of the encrypted data stream being decrypted.</t>
      </section>
      <section title="PCFB: Propagating Cipher Feedback">
        <t>Propagating Cipher Feedback is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interested to this discussion.</t>
      </section>
      <section title="SIV: Synthetic IV">
        <t>The Synthetic IV (SIV) mode was designed and documented by Phillip Rogaway and Thomas Shrimpton.  A full description of the algorithm can be found on the NIST website at <xref target="SIV"/>.  </t>
        <t>The characteristics of the algorithm are:
          <list style="numbers">
            <t>The parameters of the algorithm are:
              <list style="letters">
                <t>None for the sender of the message</t>
                <t>An IV value for the recipient of the message.  (The IV value acts as the authentication tag.)</t>
              </list>
            </t>
            <t>The data actually authenticated is:
              <list style="letters">
                <t>The authenticated data</t>
                <t>The message data</t>
              </list>
            </t>
            <t>Before the first byte of data can be processed, you must know:
              <list style="letters">
                <t>The authenticated attributes.</t>
              </list>
            </t>
            <t>Before the first byte of authenticated data can be processed, you must know: nothing.</t>
          </list>
        </t>
        <t>The algorithm does not use a nonce value, instead the IV used for the counter mode is computed from the authenticated data and message data.  The IV is then emitted as the authentication tag.  Note that this also means that the message data must processed twice by the cryptographic code.  Once to do the authentication computation and produce the IV and one to do the counter mode encryption.</t>
        <t>This algorithm cannot be streamed by the sender.  Since the IV used for the counter mode encryption of the message data depends on all of the message data, the message data must actually be processed twice by the encryption algorithm.</t>
        <t>The algorithm can easily be streamed by the recipient. The requirement is that the authenticated attributes and the IV be presented to the recipient before the message data is presented.  The authentication check is then done by comparing the IV passed in with the IV computed.</t>
      </section>
      <section title="XCBC: eXtended Cipher Block Chaining Encryption">
        <t>eXtended Cipher Block Chaining Encryption is an algorithm that supports an AE mode of operation, but not an AEAD mode of operation.  As such it does not matter where the authenticated parameters would be placed as they are not supported by the mode.  This mode is therefore not of interested to this discussion.</t>
      </section>
      <section title="MAC-Authenticated Encryption">
        <t>The MAC-Authenticated Encryption mode has been documented by Peter Gutmann.  This mode is documented in <xref target="GUTMANN"/>.</t>
        <t>The characteristics of the algorithm are:
          <list style="numbers">
            <t>The parameters of the algorithm are:
              <list style="letters">
                <t>A key derivation algorithm,</t>
                <t>A keyed MAC algorithm,</t>
                <t>An encryption algorithm</t>
              </list>
            </t>
            <t>The data actually authenticated is:
              <list style="letters">
                <t>The encrypted message,</t>
                <t>The authenticated attributes.</t>
              </list>
            </t>
            <t>Before the first byte of the message data can be processed, you must know: nothing.</t>
            <t>Before the first byte of the authenticated data can be processed, you must know:
              <list style="letters">
                <t>The encrypted message data.</t>
              </list>
            </t>
          </list>
        </t>
        <t>This algorithm can easily be used in a streaming model by the sender.</t>
        <t>This algorithm can easily be used in a streaming model by the recipient.</t>
        <t>Note: In the series of messages that I exchanged with Peter during the design of this algorithm, on of the things he noted was that to make streaming easier he should put the authenticated attributes after the message data.  Thus the algorithm was designed to make sure that streaming worked well with the current encoding.</t>
      </section>
    </section>
    <section title="My Assumptions" anchor="criteria">
      <t>This section will list the set of criteria that I am using in making my conclusions.  Again, the most important thing in my mind is the ability to implement a streaming model for encode and decode operations.</t>

      <t>
        <list style="numbers">
          <t>We want to implement using a single pass streaming module to encode and decode the structures.  There are many reasons to do so:
            <list style="numbers">
              <t>The amount of resources used is minimized by not buffering the entity of the message at each level of wrapping.</t>
              <t>The fact that not all messages are DER encode means that there is no single buffer in the original message that can be treated as a single input buffer.</t>
              <t>The message may be feed to the encoder/decode in chunks due to the way things are read from files, the fact that nodes in trees are emitted serially or the fact that removal of transfer encoding is normally done on small buffers.</t>
              </list>

            <list style="empty">
              <t>There is one argument that says one should buffer up the entire encrypted buffer, decrypt in one chunk and then pass on the data in one piece.  Since the name of the algorithm class is encrypted and authenticated, one should perhaps actually authenticate that the data is correct prior to releasing the data for additional processing.
              </t>
              <t>I believe that it is sufficient to check that the encrypted buffer has been authenticated prior to acting on the data contained in the encrypted buffer.  Thus I believe it makes sense to continue doing the decode and either fail on the decode operation and propagate a failure up either when the decode itself fails or when the authentication check is actually made.  In this way it is no different than the processing of a signed message where the signature may be checked long after the message has been fully decoded.  In fact this is the normal case for an S/MIME client where the content is often viewable with some indication that the validation of the signature failed for some reason.</t>
            </list>
          </t>

          <t>The relative lengths of the data to be encrypted and the attributes to be protected are such that the encrypted data is generally much larger than the attributes.  Thus if one has to cache one in a streaming mode, it is preferable to cache the attributes.</t>
          
        </list>
      </t>
    </section>
    <section title="Conclusions" anchor="opinion">
      <t>I now look again at the arguments presented in <xref target="history"/> and review the arguements presented.  All of the opinions in this section are mine and may or may not be represent those of any other people.  <xref target="rebuttal"/> contains the opinions of other people.</t>
      <t>
        <list style="numbers">
          <t>Consistency with the existing CMS data types:
            <list style="empty">
              <t>This criteria should only be used a tie breaker in the event that all other criteria come out equal.  When looking at this argument I am reminded of the following:
                <figure align="center">
                  <artwork>
A foolish consistency is the hobgoblin of little minds, 
adored by little statesmen and philosophers and divines
                          (Ralph Waldo Emerson 1841)</artwork>
                </figure>
              </t>
            </list>
          </t>
          <t>Authenticated attributes that are derived from the message content:
            <list style="empty">
              <t>This argument is slightly more believable than it was before I began this document as I now have an attribute which is derived from the message content, however this attribute is the length of the message data and in order to be useful it needs to be placed before the message data is consumed. (See <xref target="CCM"/>.)</t>
              <t>I found this argument to be difficult to believe at the time it was presented, and I have not changed my mind since then.  The argument that this means the authenticated attributes comes second would mean that this is an attribute that is attested to by the sender, but is not verified in any way by the recipient.  If the recipient needed to do any processing then it would be much more desirable to have the attribute occur before the message data so that the recipient can setup to do the necessary processing prior to processing the message data.</t>
              <t>I would argue that this is not a criteria that should not have be considered when making the decisions.</t>
            </list>
          </t>
          <t>The decision should be dictated by Algorithm Characteristics:
            <list style="empty">
              <t>Looking at the taxonomy of algorithms that is presented in <xref target="algs"/> we come up with the following results:
                <list>
                  <t>The algorithms which cannot be easily streamed are: CCM, SIV (sender)</t>
                  <t>The algorithms which need attributes before the message body are: CWC (simple implementation), GCM, SIV (recipient)</t>
                  <t>The algorithms which need the message body before the attributes are: MAC-Authenticated</t>
                  <t>The algorithms which can have either the body or the attributes first are: CWC (parallelized implementation), EAX, OCB</t>
                </list>
              </t>
              <t>From the above, we can see that having the attributes before the message data would allow for a simple implementation in all but the case of CCM and SIV for the sender.  (The addition of a length authenticated attribute would allow CCM to fall into the second category for a recipient.)  The only one which causes any problems is the MAC-Authenticated algorithm which was actually explicitly designed to work backwards.</t>
              <t>From the above, we can see that having the message data before the attributes means that in at least half the cases means that the message data must be cached until the attributes can be processed.</t>
              <t>If we had done this analysis at the time the decision was made then we should have made the decision to place the attributes first.</t>
            </list>
          </t>
          <t>Resource requirements for the sender and recipient:
            <list style="empty">
          <t>It is no more likely that the sender of a message is resource constrained than it is for the recipient of the message to be resource constrained.  This means that it is better for a set of algorithms and layout to be chosen that will work well in a streaming model under normal circumstances than to optimize for either the sender or the recipient.</t>
            </list>
          </t>
          <t>Relative frequency of processing:  
            <list style="empty">
              <t>In my opinion, most of the time messages that are created using an authenticated encryption algorithm will be decrypted by at least one recipient.  Messages which are not decrypted will exist, either from being lost in the ether or from being cached until needed, but these will be the smallest part of the set.  Messages which need to be decrypted multiple times by a single recipient will generally be a small number as well, unless it because part of the S/MIME standard.  However I believe that a significant number of messages will be created that will have multiple recipients.  This may be done by creating multiple lock boxes up front, or by creating the lock boxes on demand in cases where it does not matter than a traffic analysis can be done that multiple recipients have gotten the same message.  (An example of this might be sending a firmware upgrade to multiple devices, where the message is transferred on demand and it does not matter that an observer can see that the same set of firmware is being installed on multiple machines.  This would be something that could probably be assumed anyway.)</t>
              <t>I therefore think that overall more messages will be decoded and decrypted than encrypted and encoded.  This would mean that a bias should be placed for the recipients of messages not the sender of messages in making decisions.</t>
            </list>
          </t>
        </list>
      </t>
      <t>Based on the above, I would say that we should modify the order of these fields in the event that the document is updated.</t>
      <t>It is unfortunate that I did not see the republication of the document from <xref target="RFC3852"/> to <xref target="RFC5083"/> as I would have made these arguments at that time.</t>
    </section>
    <section title="Rebuttals" anchor="rebuttal">
      <t>This section has been left open for people who wish to express an opinion other than mine.</t>
    </section>
    <section title="Security Considerations">
      <t>This document discusses a security related document, however it makes no changes to the document.  As such there are no actual security implications for this document.</t>
    </section>
    <section title="IANA Considerations">
      <t>No action by IANA is required for this document.</t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <?rfc linefile="1:bibxml/reference.RFC.3610.xml"?>

<reference anchor='RFC3610'>

<front>
<title>Counter with CBC-MAC (CCM)</title>
<author initials='D.' surname='Whiting' fullname='D. Whiting'>
<organization /></author>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<author initials='N.' surname='Ferguson' fullname='N. Ferguson'>
<organization /></author>
<date year='2003' month='September' />
<abstract>
<t>Counter with CBC-MAC (CCM) is a generic authenticated encryption block cipher mode.  CCM is defined for use with 128-bit block ciphers, such as the Advanced Encryption Standard (AES).</t></abstract></front>

<seriesInfo name='RFC' value='3610' />
<format type='TXT' octets='64509' target='http://www.rfc-editor.org/rfc/rfc3610.txt' />
</reference>
<?rfc linefile="422:aed-review.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.5083.xml"?>

<reference anchor='RFC5083'>

<front>
<title>Cryptographic Message Syntax (CMS) Authenticated-Enveloped-Data Content Type</title>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>This document describes an additional content type for the Cryptographic Message Syntax (CMS).  The authenticated-enveloped-data content type is intended for use with authenticated encryption modes.  All of the various key management techniques that are supported in the CMS enveloped-data content type are also supported by the CMS authenticated-enveloped-data content type. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5083' />
<format type='TXT' octets='22810' target='http://www.rfc-editor.org/rfc/rfc5083.txt' />
</reference>
<?rfc linefile="423:aed-review.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.3852.xml"?>

<reference anchor='RFC3852'>

<front>
<title>Cryptographic Message Syntax (CMS)</title>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<date year='2004' month='July' />
<abstract>
<t>This document describes the Cryptographic Message Syntax (CMS).  This syntax is used to digitally sign, digest, authenticate, or encrypt arbitrary message content. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3852' />
<format type='TXT' octets='15541' target='http://www.rfc-editor.org/rfc/rfc3852.txt' />
</reference>
<?rfc linefile="424:aed-review.xml"?>
      <reference anchor="GUTMANN">
        <front>
          <title>Using MAC-authenticated Encryption in the Cryptographic Message Syntax (CMS)</title>
          <author initials="P." surname="Gutmann"/>
        </front>
      </reference>
      <reference anchor="NIST-800-38C">
        <front>
          <title>Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality</title>
          <author initials="M." surname="Dworkin"/>
          <date year="2004" month="May"/>
        </front>
        <seriesInfo name="NIST Special Publication" value="800-38C"/>
        <format target="http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf" type="pdf"/>
      </reference>
      <reference anchor="NIST-800-38D">
        <front>
          <title>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</title>
          <author initials="M." surname="Dworkin"/>
          <date year="2007" month="November"/>
        </front>
        <seriesInfo name="NIST Special Publication" value="800-38D"/>
        <format target="http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38D.pdf" type="pdf"/>
      </reference>
      <reference anchor="CWC">
        <front>
          <title>The CWC authenticated encryption (assoicated data) mode</title>
          <author initials="T." surname="Kohno"/>
          <author initials="J." surname="Viega"/>
          <author initials="D." surname="Whiting"/>
          <date year="2003" month="May"/>
        </front>
        <format target="http://eprint.iacr.org/2003/106" type="UNK"/>
      </reference>
      <reference anchor="EAX">
        <front>
          <title>EAX: A Conventional Authenticated-Encryption Mode</title>
          <author initials="M." surname="Bellare"/>
          <author initials="P." surname="Rogaway"/>
          <author initials="D." surname="Wagner"/>
          <date year="2003"/>
        </front>
        <format target="http://eprint.iacr.org/2003/069" type="UNK"/>
      </reference>
      <reference anchor="OCB-AD1">
        <front>
          <title>The Associated-Data Problem</title>
          <author initials="P." surname="Rogaway"/>
          <date year="2001" month="November"/>
        </front>
        <format target="http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/ocb/ocb-ad1.pdf" type="pdf"/>
      </reference>
      <reference anchor="SIV">
        <front>
          <title>The SIV Mode of Operation for Deterministic Authenticated-Encryption (Key Wrap) and Misuse-Resistant Nonce-Based Authenticated-Encryption</title>
          <author initials="P." surname="Rogaway"/>
          <author initials="T." surname="Shrimpton"/>
          <date year="2007" month="August"/>
        </front>
        <format target="http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/siv/siv.pdf" type="pdf"/>
      </reference>
    </references>
  </back>
</rfc>
