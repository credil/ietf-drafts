<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!-- General -->
<?rfc strict="yes" ?>   <!-- Enforce Internet-Drafts nits & DTD validity? -->
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<!-- References -->
<?rfc symrefs="yes"?>   <!-- Show symbolic links (yes) or numbers (no). -->
<?rfc sortrefs="yes" ?> <!-- Sort references? -->
<!-- Comments -->
<?rfc comments="yes" ?> <!-- Display <cref> elements? -->
<?rfc inline="yes" ?>   <!-- Place comments inline (yes) or in comments section (no). -->
<?rfc editing="no" ?>   <!-- Insert editing marks? -->
<!-- Table of Contents -->
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc tocompact="yes"?>
<!-- End of directives; start of RFC. -->
<rfc category="info" ipr="trust200902" docName="draft-lanz-cicm-km-00">
  <front>
    <title abbrev="CICM Key Management">
      Common Interface to Cryptographic Modules (CICM) Key Management
    </title>
    <author fullname="Daniel J. Lanz" initials="D." surname="Lanz">
      <organization abbrev="MITRE">The MITRE Corporation</organization>
      <address>
        <email>dlanz@mitre.org</email>
      </address>
    </author>
    <author fullname="Lev Novikov" initials="L." surname="Novikov">
      <organization abbrev="MITRE">The MITRE Corporation</organization>
      <address>
        <email>lnovikov@mitre.org</email>
      </address>
    </author>
    <date year="2011" month="January" />
    <area>Security</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <abstract>
      <t>[RFC Editor: Please update the RFC references prior to publication.]</t>
      <t>This memo defines a programming interface for the management of
      cryptographic keys as outlined in draft-lanz-cicm-model-00 and required
      by draf-lanz-cicm-02 including managing a key database as well as individual
      symmetric and asymmetric keys.</t>
      <t>Comments are solicited and should be addressed to the mailing list at cicm@ietf.org.</t>
    </abstract>
  </front>
  <middle><!-- Content. -->
    <section title="Introduction">
      <t>This document defines the key management functions for the Common Interface to
      Cryptographic Modules (CICM) as defined in <xref target="CICM" />. The underlying logical
      model and terminology is defined in <xref target="CICM-LM" />.</t>
      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
        and "OPTIONAL" in this document are to be interpreted as
        described in <xref target="RFC2119" />.</t>
      </section>
      <section title="Definition Language">
        <t>This document uses the Interface Definition Language (IDL) <xref target="IDL" /> to
        specify language-neutral interfaces and is not intended to prescribe or preclude a particular
        communications protocol such as General Inter-ORB Protocol (GIOP) <xref target="CORBA" />
        between programs in different address spaces or on different devices. In other words, any specific
        protocol is strictly OPTIONAL. See Definition Language in <xref target="CICM" />
        for more information.
        </t>
      </section>
      <section title="Conformance and Extension Language">
        <t>This document contains definitions for several opaque data parameters whose
        format is not defined by CICM. Instead, implementers are required to create an
        Implementation Conformance Statement which MUST reference a standard format or
        define a module developer-specific format implemented by the module for these
        datatypes. See Conformance and Extensions in <xref target="CICM" /> for more details.</t>
      </section>
    </section>
    <section title="CICM Dependencies">
      <t>This document depends on type definitions and interfaces that
      are defined in other CICM documents.</t>

      <section title="Namespaces">
        <t>The CICM namespace is defined in <xref target="CICM" />.</t>
      </section>
      <section title="Types">
        <t>The following type definitions are defined in <xref target="CICM" />:
          <list>
            <t>CICM::UInt32</t>
            <t>CICM::CharString</t>
            <t>CICM::Buffer</t>
            <t>CICM::Status (including all return values)</t>
            <t>CICM::LocalPort</t>
            <t>CICM::Classification</t>
          </list>
        </t>
        <t>The type definitions for the following identifiers are defined in
          <xref target="CICM-CM" />:
          <list>
            <t>CICM::SymEncrAlgorithmId</t>
            <t>CICM::SymEncrAlgorithmId</t>
            <t>CICM::HashAlgorithmId</t>
            <t>CICM::KeyWrapAlgorithmId</t>
            <t>CICM::ProtocolId</t>
          </list>
        </t>
      </section>
      <section title="Interfaces">
        <t>The interface CICM::Iterator is defined in <xref target="CICM" />; CICM::Negotiator
        is defined in <xref target="CICM-CM" />.</t>
      </section>
    </section>
    <section title="General Key Concepts">
       <section title="Creating and Establishing Keys">
          <t>This specification provides facilities to convey key material
          into a cryptographic module via one of several methods,
          including importing key into the module through the API
          or a key fill interface, or generating or deriving key on the module.</t>
          <t>Key material may also be created through the use of a key
          establishment protocol between the module and a key infrastructure
          component or another module. Such a protocol is initiated between
          two or more parties to establish a secret key over a communications
          channel. The specification supports conveying generic protocol
          messages to and from a cryptographic module to effect the
          establishment of this secret key. See the CICM::KeyProtocolSender
          and CICM::KeyProtocolReceiver interfaces for additional
          information.</t>
          <t>Key metadata may be retrieved and set for individual keys.
          Metadata elements include the key identifier, alias, and
          classification. Keys imported via a fill device that are untagged
          may require certain metadata to be applied after the conclusion of
          the load, for example.</t>
          <!-- t>{FIGURE REMOVED}</t>
          <t>Figure 19. Interface Inheritance Diagram
            for AsymKey and SymKey, Depicting Key Creation Methods</t-->
        </section>
        <section title="Exporting Keys">
          <t>Key material may also be exported out of a
          cryptographic module through the use of the key export
          functionality to enable transfer to another entity or for storage
          within the host system.</t>
        </section>
        <section title="Destroying Keys">
          <t>This specification provides the ability to
          permanently and irretrievably destroy key material. These
          capabilities apply to keys managed by the module, whether stored
          internal to the module or stored externally.</t>
          <!-- t>{FIGURE REMOVED}</t>
          <t>Figure 20. Interface Relationship and
            Inheritance Diagram Depicting Key Zeroization</t -->
        </section>
        <section title="Locating Keys">
          <t>A key is typically designated by a global
          identifier defined by the external key management system from which
          the key originated. Alternatively, a key may be designated by a
          numeric value representing the physical storage location of the key
          within the module. Key location methods enable a key object
          representing the key specified by a supplied identifier to be
          retrieved by the caller.</t>
          <t>Note that the format of the key identifier is not defined by
          CICM. The Implementation Conformance Statement (see Conformance and Extensions
          in <xref target="CICM" />) MUST reference a standard format or
          define a module developer-specific format implemented by the module
          for this datatype.</t>
          <!-- t>{FIGURE REMOVED}</t>
          <t>Figure 21. Interface Relationship Diagram for Key Managers</t -->
        </section>
        <section title="Protecting Keys">
          <t>These methods enable the encryption and
          decryption of key material to support transferring keys between
          modules or other entities (including storage of key material
          external to the module).</t>
          <!-- t>{FIGURE REMOVED}</t>
          <t>Figure 22. Interface Inheritance Diagram
            for AsymKey and SymKey, Depicting Key Protection Methods</t -->
        </section>
        <section title="Identifiers">
          <figure>
            <preamble>Type CICM::KeyId</preamble>
            <artwork><![CDATA[typedef CICM::CharString KeyId;]]></artwork>
            <postamble>Unique key identifier.</postamble>
          </figure>
        </section>
				<section title="Interface CICM::Key">
					<figure>
					  <preamble>Interface CICM::Key</preamble>
					  <artwork><![CDATA[interface Key {]]></artwork>
					  <postamble>Interface from which symmetric and asymmetric key interfaces inherit.</postamble>
					</figure>
					<section title="CICM::Key Types and Constants">
						<figure>
						  <preamble>Type CICM::Key::State</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 State;]]></artwork>
						  <postamble>Indicates whether or not the key is valid.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Key::C_KEY_INVALID</preamble>
<artwork><![CDATA[const CICM::Key::State
	C_KEY_INVALID = 0x00006010;]]></artwork>
							<postamble>Key is invalid.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Key::C_KEY_VALID_WRAPPED</preamble>
<artwork><![CDATA[const CICM::Key::State
	C_KEY_VALID_WRAPPED = 0x00006013;]]></artwork>
							<postamble>Key is valid and in wrapped form.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Key::C_KEY_VALID_UNWRAPPED</preamble>
<artwork><![CDATA[const CICM::Key::State
	C_KEY_VALID_UNWRAPPED = 0x00006015;]]></artwork>
							<postamble>Key is valid and in unwrapped form.</postamble>
						</figure>
						<figure>
						  <preamble>Type CICM::Key::UsageStatus</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 UsageStatus;]]></artwork>
						  <postamble>Indicates whether a key usage is allowed or forbidden.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Key::C_KEY_USAGE_ALLOWED</preamble>
<artwork><![CDATA[const CICM::Key::UsageStatus
	C_KEY_USAGE_ALLOWED = 0x00006016;]]></artwork>
							<postamble>Key is valid for this usage.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::Key::C_KEY_USAGE_FORBIDDEN</preamble>
<artwork><![CDATA[const CICM::Key::UsageStatus
	C_KEY_USAGE_FORBIDDEN = 0x00006019;]]></artwork>
							<postamble>Key is not valid for this usage.</postamble>
						</figure>
					</section>
					<section title="CICM::Key Attributes">
						<figure>
						  <preamble>Attribute CICM::Key::identifier</preamble>
						  <artwork><![CDATA[attribute CICM::CharString identifier;]]></artwork>
						  <postamble>Unique global identifier for this key.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This identifier is the string representation of a key
								management authority-specific global key identifier. The
								identifier may be composed of multiple components; the
								representation of these components within the CICM identifier
								string is not defined in this specification. The Implementation
								Conformance Statement (see Conformance and Extensions
                in <xref target="CICM" />) MUST reference a standard format or define a module
								developer-specific format implemented by the module for this
								identifier.</t>
							</list>
						</t><t>Warning:
							<list>
								<t>This attribute MUST NOT be implemented if CICM::Key::location is implemented.</t>
							</list>
						</t>
						<figure>
						  <preamble>Attribute CICM::Key::location</preamble>
						  <artwork><![CDATA[attribute CICM::UInt32 location;]]></artwork>
						  <postamble>Module-specific physical storage location for this key.</postamble>
						</figure>
						<t>Warning:
							<list>
								<t>This attribute should only be used when a module utilizes a
								key storage model that requires keys of particular types to be
								stored in specific locations or in situations where keys are
								tied to module capabilities based upon physical location of the
								key. Because of the architectural knowledge of a module
								required, its use is highly discouraged because it virtually
								guarantees that code using it will be incompatible with other
								dissimilar modules. This attribute MUST NOT be implemented if
								CICM::Key::identifier is implemented.</t>
							</list>
						</t>
						<figure>
						  <preamble>Attribute CICM::Key::alias</preamble>
						  <artwork><![CDATA[attribute CICM::CharString alias;]]></artwork>
						  <postamble>Key alias, to assist in distinguishing one key from another.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::Key::classification</preamble>
						  <artwork><![CDATA[attribute CICM::Classification classification;]]></artwork>
						  <postamble>Key classification level.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::Key::caveat</preamble>
						  <artwork><![CDATA[attribute CICM::CharString caveat;]]></artwork>
						  <postamble>Key caveat, a protective marking or distribution/handling
							instruction that may augment classification level.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::Key::authority</preamble>
						  <artwork><![CDATA[attribute CICM::CharString authority;]]></artwork>
						  <postamble>Key management authority governing generation and use of key.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::Key::state</preamble>
						  <artwork><![CDATA[readonly attribute CICM::Key::State state;]]></artwork>
						  <postamble>State of key. A key may become invalid if zeroized, for
							example. Note that if an attempt is made to use an invalid key, the
							method accepting the key reference will return with an appropriate
							error status.</postamble>
						</figure>
					</section>
					<section title="CICM::Key Methods">
						<figure>
						  <preamble>Method CICM::Key::wrap()</preamble>
<artwork><![CDATA[CICM::Status wrap(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm
);]]></artwork>
						  <postamble>Instruct module to wrap key, destroying the original
							unwrapped key and replacing it with the newly wrapped key.</postamble>
						</figure>
						<t>Parameters:
							<list>
								<t>[in] kek Reference to key encryption key.</t>
								<t>[in] algorithm Key wrap algorithm/mode used to wrap key.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
								  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
								  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
								  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
								  S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_WRAPPED,
								  S_KEY_NOT_WRAPPABLE, S_KEY_WRAPPED_EXISTS, S_ALGO_INVALID,
								  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Key::unwrap()</preamble>
<artwork><![CDATA[CICM::Status unwrap(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm
);]]></artwork>
						  <postamble>Instruct module to unwrap key, destroying the original
							wrapped key and replacing it with the newly unwrapped key.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] kek Reference to key decryption key.</t>
							<t>[in] algorithm Key wrap algorithm/mode used to unwrap key.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
								  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
								  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
								  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
								  S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION,
								  S_KEY_UNWRAPPED_EXISTS, S_KEY_MALFORMED,
								  S_KEY_METADATA_MALFORMED, S_ALGO_INVALID,
								  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Key::export()</preamble>
<artwork><![CDATA[CICM::Status export(
	out CICM::Buffer key_material
);]]></artwork>
						  <postamble>Export key material from a cryptographic module as an opaque
							binary object.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The key must have been previously wrapped, if required. See CICM::Key::wrap.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[out] key_material Binary version of the key.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
								  S_KEY_EXPIRED, S_KEY_WRAPPED, S_KEY_NOT_WRAPPED,
								  S_KEY_NOT_EXPORTABLE, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Key::export_via_fill_interface()</preamble>
<artwork><![CDATA[CICM::Status export_via_fill_interface(
	in  CICM::LocalPort fill_port
);]]></artwork>
						  <postamble>Export key material from a cryptographic module via a port
							representing a key fill interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>The key must have been previously wrapped, if required. See
								CICM::Key::wrap.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] fill_port The local port from which the key will emanate.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
								  S_KEY_EXPIRED, S_KEY_WRAPPED, S_KEY_NOT_WRAPPED,
								  S_KEY_NOT_EXPORTABLE, S_KEY_FILL_DEVICE_NOT_CONNECTED,
								  S_KEY_FILL_NOT_INITIATED, S_LOCAL_PORT_INVALID,
								  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Key::zeroize()</preamble>
						  <artwork><![CDATA[CICM::Status zeroize();]]></artwork>
						  <postamble>Zeroize the selected key.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Future cryptographic operations depending upon this key
								MUST fail with a CICM::S_KEY_INVALID status.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::KeyDatabase">
					<figure>
					  <preamble>Interface CICM::KeyDatabase</preamble>
					  <artwork><![CDATA[interface KeyDatabase {]]></artwork>
					  <postamble>CICM::KeyDatabase supports zeroizing keys and reencrypting a
						module key database. It is accessed from CICM::CryptoModule via the
						CICM::CryptoModule::key_database attribute.</postamble>
					</figure>

					<section title="CICM::KeyDatabase Methods">
						<figure>
						  <preamble>Method CICM::KeyDatabase::zeroize()</preamble>
						  <artwork><![CDATA[CICM::Status zeroize();]]></artwork>
						<postamble>Zeroize all key material on the module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This method renders all instantiated key objects invalid.
								Future cryptographic operations depending upon zeroized keys
								MAY fail with a CICM::S_KEY_INVALID status.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::KeyDatabase::reencrypt()</preamble>
						  <artwork><![CDATA[CICM::Status reencrypt();]]></artwork>
						  <postamble>Re-encrypt the module key database.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>This method uses a module-managed key to protect the key
								database and only applies to keys managed by the module,
								whether stored internal to the module or stored externally.
								Keys stored external to the module and not directly managed by
								the module must utilize the key wrap methods to protect key
								material.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Asymmetric Keys">
				<section title="Interface CICM::AsymKeyManager">
					<figure>
					  <preamble>Interface CICM::AsymKeyManager</preamble>
					  <artwork><![CDATA[interface AsymKeyManager {]]></artwork>
					  <postamble>CICM::AsymKeyManager supports retrieving, importing, and
						generating asymmetric keysets. It is accessed from
						CICM::CryptoModule via the CICM::CryptoModule::asym_key_manager
						attribute. CICM::AsymKeyManager constructs the
						CICM::AsymKeyIterator and CICM::AsymKey interfaces.</postamble>
					</figure>
					<!-- t>{FIGURE REMOVED}</t>
					<t>Figure 23. Interface Relationship Diagram for AsymKeyManager</t -->

					<section title="CICM::AsymKeyManager Attributes">
						<figure>
						  <preamble>AttributeCICM::AsymKeyManager::asymkey_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymKeyIterator asymkey_iterator;]]></artwork>
						  <postamble>Returns an iterator to enable a reference to each asymmetric
							keyset in the module key database to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							  <t>The returned iterator is set to the beginning of the iterated
							  sequence.</t>
							</list>
						</t>
					</section>
					<section title="CICM::AsymKeyManager Methods">
						<figure>
						  <preamble>Method CICM::AsymKeyManager::get_key_by_id()</preamble>
<artwork><![CDATA[CICM::Status get_key_by_id(
	in  CICM::KeyId key_id,
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Retrieves a reference to the asymmetric keyset corresponding
							to the specified infrastructure-specific identifier.</postamble>
						</figure>
						<t>Warning:
							<list>
								<t>This method MUST NOT be implemented if
								CICM::AsymKeyManager::get_key_by_phys_location is
								implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] key_id Unique identifier of the keyset to be retrieved.</t>
								<t>[out] key_ref Reference to keyset corresponding to key
									  identifier.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
								  S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INVALID_ID,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::get_key_by_phys_location()</preamble>
<artwork><![CDATA[CICM::Status get_key_by_phys_location(
	in  CICM::UInt32 phys_location,
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Retrieves a reference to the asymmetric keyset corresponding
							to the specified module physical storage location.</postamble>
						</figure>
						<t>Warning:
							<list>
								<t>This call should only be used when a module utilizes a key
								storage model that requires keys of particular types to be
								stored in specific locations or in situations where keys are
								tied to module capabilities based upon physical location of the
								key. Because of the architectural knowledge of a module
								required, its use is highly discouraged because it virtually
								guarantees that code using it will be incompatible with other
								dissimilar modules.</t>
								<t>This method MUST NOT be implemented if
								CICM::AsymKeyManager::get_key_by_id is implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] phys_location Physical location of the key to be retrieved.</t>
								<t>[out] key_ref Reference to key corresponding to physical
									  location.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
								  S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_PHYSICAL_LOC,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::get_key_last_filled()</preamble>
<artwork><![CDATA[CICM::Status get_key_last_filled(
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Retrieves a reference to the asymmetric keyset corresponding
							to the keyset most recently filled via a key fill device.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>A client program may need to initiate this action if key
								material imported into a module does not contain the
								corresponding key metadata. This method allows a reference to
								the last keyset filled over the key fill interface to be
								referenced to enable metadata to be applied directly to the
								resulting keyset. The error status CICM::S_NOT_AVAILABLE is
								returned if no key is filled.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] key_ref Object representing last filled key.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
								<t>SymKeyManager::get_key_last_filled for the symmetric
								version of this method.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::import_key()</preamble>
<artwork><![CDATA[CICM::Status import_key(
	in  CICM::Buffer key_material,
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Import asymmetric keysets into a cryptographic module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Keysets may be imported into a module as wrapped entities,
								necessitating the use of CICM::Key::unwrap to decrypt the
								keyset prior to use.</t>
								<t>Keyset attributes may optionally be set to create or
								supplement key metadata.</t>
								<t>The format of the key material value is not defined by CICM.
								The Implementation Conformance Statement (see Conformance and Extensions
                in <xref target="CICM" />) MUST reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Warning:
							<list>
								<t>This method MUST NOT be implemented if
								CICM::AsymKeyManager::import_key_into_phys_location is
								implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] key_material Key material to be imported into the module.</t>
								<t>[out] key_ref Reference to newly imported key.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED,
								  S_KEY_METADATA_MALFORMED, S_KEY_TRUST_ANCHOR,
								  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<t>See also:
							<list>
								<t>CICM::SymKeyManager::import_key for the symmetric version
								of this method.</t>
								<t>CICM::AsymKeyManager::import_key_via_fill for the key fill
								version of this method.</t>
								<t>CICM::AsymKeyManager::import_key_into_phys_location for the
								version of this method that imports key into a specific module
								key location.</t>
								<t>CICM::AsymKeyManager::import_key_via_fill_into_phys_location
								for the version of this method that fills key into a specific
								module key location.</t>
							</list>
						</t>
						<figure>
							<preamble>Method CICM::AsymKeyManager::import_key_into_phys_location()</preamble>
<artwork><![CDATA[CICM::Status import_key_into_phys_location(
	in  CICM::Buffer key_material,
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);]]></artwork>
							<postamble>Import key material into a specific physical key location in
							a cryptographic module.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>Keysets may be imported into a module as wrapped entities,
								necessitating the use of CICM::Key::unwrap to decrypt the
								keyset prior to use.</t>
								<t>Keyset object attributes may optionally be set to create or
								supplement keyset metadata.</t>
								<t>The format of the key material value is not defined by CICM.
								The Implementation Conformance Statement (see Conformance and Extensions
                in <xref target="CICM" />) MUST reference a standard format or
								define a module developer-specific format implemented by the
								module for this datatype.</t>
							</list>
						</t><t>Warning:
							<list>
								<t>This call should only be used when a module utilizes a key
								storage model that requires keys of particular types to be
								stored in specific locations or in situations where keys are
								tied to module capabilities based upon physical location of the
								key. Because of the architectural knowledge of a module
								required, its use is highly discouraged because it virtually
								guarantees that code using it will be incompatible with other
								dissimilar modules.</t>
								<t>This method MUST NOT be implemented if
								CICM::AsymKeyManager::import_key is implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] key_material Key material to be imported into the module.</t>
								<t>[in] phys_location Physical location into which to import keyset.</t>
								<t>[out] key_ref Reference to newly imported keyset.</t>
							</list>
						</t><t>Returns:
							<list>
								<t>S_OK, S_GENERAL_ERROR,
								  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC,
								  S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED,
								  S_KEY_TRUST_ANCHOR, S_TOKEN_NOT_PRESENT,
								  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::import_key_via_fill()</preamble>
<artwork><![CDATA[CICM::Status import_key_via_fill(
	in  CICM::LocalPort fill_port,
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Initiate the import of key material via a key fill
							interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>In some cases, a key fill device can initiate and effect
								the filling of key into a module completely independent of the
								host and thus any API control. In such cases, the host will
								utilize the CICM::AsymKeyManager::get_key_by_id,
								CICM::AsymKeyManager::get_key_by_phys_location, or
								CICM::AsymKeyManager::get_key_last_filled methods after the key
								fill has completed to enable future reference to the keyset.</t>
								<t>Keysets may be imported into a module as wrapped entities,
								necessitating the use of CICM::Key::unwrap to decrypt the key
								prior to use.</t>
								<t>Keyset attributes may optionally be set to create or
								supplement keyset metadata.</t>
							</list>
						</t><t>Warning:
							<list>
								<t>This method MUST NOT be implemented if
								CICM::AsymKeyManager::import_key_via_fill_into_phys_location is
								implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
								<t>[in] fill_port Fill port on which to initiate import.</t>
								<t>[out] key_ref Reference to newly imported keyset.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED,
							  S_KEY_METADATA_MALFORMED, S_KEY_FILL_DEVICE_NOT_CONNECTED,
							  S_KEY_FILL_NOT_INITIATED, S_KEY_TRUST_ANCHOR,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::import_key_via_fill_into_phys_location()</preamble>
<artwork><![CDATA[CICM::Status import_key_via_fill_into_phys_location(
	in  CICM::LocalPort fill_port,
	in  CICM::UInt32 phys_location,
	out CICM::AsymKey key_ref
);]]></artwork>
						  <postamble>Initiate the import of key material into a specific key
							physical location via a key fill interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
								<t>In some cases, a key fill device can initiate and effect
								the filling of key into a module completely independent of the
								host and thus any API control. In such cases, the host will
								utilize the CICM::AsymKeyManager::get_key_by_id,
								CICM::AsymKeyManager::get_key_by_phys_location, or
								CICM::AsymKeyManager::get_key_last_filled methods after the key
								fill has completed to enable future reference to the keyset.</t>
								<t>Keysets may be imported into a module as wrapped entities,
								necessitating the use of CICM::Key::unwrap to decrypt the
								keyset prior to use.</t>
								<t>Keyset attributes may optionally be set to create or
								supplement keyset metadata.</t>
							</list>
						</t><t>Warning:
							<list>
							<t>This call should only be used when a module utilizes a key
							storage model that requires keys of particular types to be
							stored in specific locations or in situations where keys are
							tied to module capabilities based upon physical location of the
							key. Because of the architectural knowledge of a module
							required, its use is highly discouraged because it virtually
							guarantees that code using it will be incompatible with other
							dissimilar modules.</t>
							<t>This method MUST NOT be implemented if
							CICM::AsymKeyManager::import_key_via_fill is
							implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] fill_port Port of the key fill interface.</t>
							<t>[in] phys_location Physical location into which to import keyset.</t>
							<t>[out] key_ref Reference to newly imported keyset.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC,
							  S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED,
							  S_KEY_FILL_DEVICE_NOT_CONNECTED, S_KEY_FILL_NOT_INITIATED,
							  S_KEY_TRUST_ANCHOR, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKeyManager::generate_key_pair()</preamble>
<artwork><![CDATA[CICM::Status generate_key_pair(
	in  CICM::AsymEncrAlgorithmId algorithm,
	out CICM::AsymKey key_ref
);]]></artwork>
						<postamble>Generate an asymmetric key pair compatible with the
						characteristics of the specified algorithm.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] algorithm Desired algorithm of resulting asymmetric key pair.</t>
							<t>[out] key_ref Reference to newly generated key pair.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AsymKey">
					<figure>
					  <preamble>Interface CICM::AsymKey</preamble>
					  <artwork><![CDATA[interface AsymKey : CICM::Key {]]></artwork>
						<postamble>CICM::AsymKey serves as an abstraction for an asymmetric
						keyset, which may comprise an asymmetric key pair, the public and
						private key components of a keypair, the digital certificate
						corresponding to the keyset public key, one or more verification
						certificates in the certificate chain of trust, and related public
						domain parameters; and supports operations on asymmetric keys,
						including wrapping and unwrapping.</postamble>
					</figure>

					<section title="CICM::AsymKey Inheritance">
						<t>CICM::AsymKey inherits from: CICM::Key.</t>
					</section>
					<section title="CICM::AsymKey Types and Constants">
						<figure>
						  <preamble>Type CICM::AsymKey::Usage</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Usage;]]></artwork>
							<postamble>Asymmetric key usage types.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_ASYM_DATA_ENCIPHERMENT</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_ASYM_DATA_ENCIPHERMENT = 0x00006001;]]></artwork>
							<postamble>Key intended for enciphering data.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_ASYM_KEY_ENCIPHERMENT</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_ASYM_KEY_ENCIPHERMENT = 0x00006002;]]></artwork>
							<postamble>Key intended for enciphering other keys.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_CERT_SIGN</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_CERT_SIGN = 0x00006004;]]></artwork>
							<postamble>Key intended for signing/verifying digital certificates.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_CRL_SIGN</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_CRL_SIGN = 0x00006007;]]></artwork>
						  <postamble>Key intended for signing/verifying certificate revocation lists.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_DIGITAL_SIGNATURE</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_DIGITAL_SIGNATURE = 0x00006008;]]></artwork>
							<postamble>Key intended for producing digital signatures.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_INFRA_KEY_AGREEMENT</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_INFRA_KEY_AGREEMENT = 0x0000600B;]]></artwork>
							<postamble>Key intended for participating in an infrastructure key
							  agreement protocol.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_P2P_KEY_AGREEMENT</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_P2P_KEY_AGREEMENT = 0x0000600D;]]></artwork>
						  <postamble>Key intended for participating in a peer-to-peer key
						  agreement protocol.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::AsymKey::C_USAGE_SEED</preamble>
<artwork><![CDATA[const CICM::AsymKey::Usage
	C_USAGE_SEED = 0x0000600E;]]></artwork>
							<postamble>Key intended to serve as seed material.</postamble>
						</figure>
					</section>
					<section title="CICM::AsymKey Methods">
						<figure>
						  <preamble>Method CICM::AsymKey::wrap_and_copy()</preamble>
<artwork><![CDATA[CICM::Status wrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::AsymKey wrapped_key
);]]></artwork>
						<postamble>Instruct module to wrap keyset, resulting in two keysets, the
						original unwrapped keyset and the newly wrapped keyset.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] kek Reference to key encryption key.</t>
							<t>[in] algorithm Key wrap algorithm/mode used to wrap keyset.</t>
							<t>[out] wrapped_key Reference to resulting wrapped keyset.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_WRAPPED,
							  S_KEY_NOT_WRAPPABLE, S_KEY_WRAPPED_EXISTS, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::wrap_and_copy for the symmetric version of
							this method.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKey::unwrap_and_copy()</preamble>
<artwork><![CDATA[CICM::Status unwrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::AsymKey unwrapped_key
);]]></artwork>
						<postamble>Instruct module to unwrap key, resulting in two keys, the
						original wrapped key and the newly unwrapped key.</postamble>
						</figure>
						<t>Parameters:
							<list>
							  <t>[in] kek Reference to key decryption key.</t>
							  <t>[in] algorithm Key wrap algorithm/mode used to unwrap keyset.</t>
							  <t>[out] unwrapped_key Reference to resulting unwrapped keyset.</t>
							</list>
						</t><t>Returns:
							<list>
							  <t>
								S_OK, S_GENERAL_ERROR,
								S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
								S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
								S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
								S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
								S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
								S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
								S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
								S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION,
								S_KEY_UNWRAPPED_EXISTS, S_KEY_MALFORMED,
								S_KEY_METADATA_MALFORMED, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
								S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT   </t>
							</list>
						</t><t>See also:
							<list>
							  <t>CICM::SymKey::unwrap_and_copy for the symmetric version of
							  this method.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::AsymKey::validate_key_usage()</preamble>
<artwork><![CDATA[CICM::Status validate_key_usage(
	in  CICM::AsymKey::Usage usage_type,
	out CICM::Key::UsageStatus valid
);]]></artwork>
						<postamble>Validate that this keyset may be used for a specific purpose.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, a given keyset can be used for multiple
							purposes.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] usage_type Specific purpose to validate.</t>
							<t>[out] valid Indiciates whether or not the key may be used for the
								  specified purpose.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::validate_key_usage for the symmetric version
							of this method.</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AsymKeyIterator">
					<figure>
					  <preamble>Interface CICM::AsymKeyIterator</preamble>
					  <artwork><![CDATA[interface AsymKeyIterator : CICM::Iterator {]]></artwork>
					<postamble>CICM::AsymKeyIterator supports retrieving a reference to each
					usable asymmetric key on a module. CICM::AsymKeyIterator constructs
					the CICM::AsymKey interface.</postamble>
					</figure>
					<section title="CICM::AsymKeyIterator Inheritance">
						<t>CICM::AsymKeyIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::AsymKeyIterator Methods">
						<figure>
						  <preamble>Method CICM::AsymKeyIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::AsymKey asym_key_ref
);]]></artwork>
							<postamble>Returns a reference to the next asymmetric key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Use CICM::Iterator::has_next to determine if additional
							elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] asym_key_ref Reference to next asymmetric key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Symmetric Keys">
				<section title="Interface CICM::SymKeyManager">
					<figure>
					  <preamble>Interface CICM::SymKeyManager</preamble>
					  <artwork><![CDATA[interface SymKeyManager {]]></artwork>
						<postamble>CICM::SymKeyManager supports retrieving, importing,
						generating and deriving symmetric keys; and operating key
						management protocols. It is accessed from CICM::CryptoModule via
						the CICM::CryptoModule::sym_key_manager attribute.
						CICM::SymKeyManager constructs the CICM::KeyProtocolSender,
						CICM::KeyProtocolReceiver, CICM::SymKeyIterator, and CICM::SymKey
						interfaces.</postamble>
					</figure>
					<!-- t>{FIGURE REMOVED}</t>
					<t>Figure 24. Interface Relationship Diagram for SymKeyManager</t -->

					<section title="CICM::SymKeyManager Attributes">
						<figure>
						  <preamble>AttributeCICM::SymKeyManager::symkey_iterator</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymKeyIterator symkey_iterator;]]></artwork>
						<postamble>Returns an iterator to enable a reference to each symmetric
						key in the module key database to be retrieved.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The returned iterator is set to the beginning of the
							iterated sequence.</t>
							</list>
						</t>
						<figure>
						  <preamble>AttributeCICM::SymKeyManager::key_protocol_sender</preamble>
						  <artwork><![CDATA[readonly attribute CICM::KeyProtocolSender key_protocol_sender;]]></artwork>
						<postamble>CICM::KeyProtocolSender supports sending key management
						protocol-related messages into a module.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::SymKeyManager::key_protocol_receiver</preamble>
						  <artwork><![CDATA[readonly attribute CICM::KeyProtocolReceiver key_protocol_receiver;]]></artwork>
						<postamble>CICM::KeyProtocolReceiver supports receiving key management
						protocol-related messages from a module. CICM::KeyProtocolReceiver
						constructs the CICM::SymKey interface.</postamble>
						</figure>
					</section>
					<section title="CICM::SymKeyManager Methods">
						<figure>
						  <preamble>Method CICM::SymKeyManager::get_key_by_id()</preamble>
<artwork><![CDATA[CICM::Status get_key_by_id(
	in  CICM::KeyId key_id,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Retrieves a reference to the symmetric key corresponding to
						the specified infrastructure-specific identifier.</postamble>
						</figure>
						<t>Warning:
							<list>
							<t>This method MUST NOT be implemented if
							CICM::SymKeyManager::get_key_by_phys_location is
							implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] key_id Unique identifier of the key to be retrieved.</t>
							<t>[out] key_ref Reference to key corresponding to key
								  identifier.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INVALID_ID,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::get_key_by_phys_location()</preamble>
<artwork><![CDATA[CICM::Status get_key_by_phys_location(
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Retrieves a reference to the symmetric key corresponding to
						the specified module physical storage location.</postamble>
						</figure>
						<t>Warning:
							<list>
							<t>This call should only be used when a module utilizes a key
							storage model that requires keys of particular types to be
							stored in specific locations or in situations where keys are
							tied to module capabilities based upon physical location of the
							key. Because of the architectural knowledge of a module
							required, its use is highly discouraged because it virtually
							guarantees that code using it will be incompatible with other
							dissimilar modules.</t>
							<t>This method MUST NOT be implemented if
							CICM::SymKeyManager::get_key_by_id is implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] phys_location Physical location of the key to be retrieved.</t>
							<t>[out] key_ref Reference to key corresponding to physical
								  location.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_PHYSICAL_LOC,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::get_key_last_filled()</preamble>
<artwork><![CDATA[CICM::Status get_key_last_filled(
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Retrieves a reference to the symmetric key corresponding to
						the key most recently filled via a key fill device.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>A client program may need to initiate this action if key
							material imported into a module does not contain the
							corresponding key metadata. This method allows a reference to
							the last key filled over the key fill interface to be
							referenced to enable metadata to be applied directly to the
							resulting key. The error status CICM::S_NOT_AVAILABLE is
							returned if no key is filled.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] key_ref Reference to last filled key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_NOT_AVAILABLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::import_key()</preamble>
<artwork><![CDATA[CICM::Status import_key(
	in  CICM::Buffer key_material,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Import key material or seed key for pseudorandom data
						generation into a cryptographic module.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Keys may be imported into a module as wrapped entities,
							necessitating the use of CICM::Key::unwrap to decrypt the key
							prior to use.</t>
							<t>Key attributes may optionally be set to create or supplement
							key metadata.</t>
							<t>The format of the key material value is not defined by CICM.
							The Implementation Conformance Statement (see Conformance and Extensions
              in <xref target="CICM" />) must reference a standard format or
							define a module developer-specific format implemented by the
							module for this datatype.</t>
							</list>
						</t><t>Warning:
							<list>
							<t>This method MUST NOT be implemented if
							CICM::SymKeyManager::import_key_into_phys_location is
							implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] key_material Key material to be imported into the module.</t>
							<t>[out] key_ref Reference to newly imported key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED,
							  S_KEY_METADATA_MALFORMED, S_KEY_TRUST_ANCHOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::import_key_into_phys_location()</preamble>
<artwork><![CDATA[CICM::Status import_key_into_phys_location(
	in  CICM::Buffer key_material,
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Import key material or seed key for pseudorandom data
						generation into a specific physical key location in a cryptographic
						module.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Keys may be imported into a module as wrapped entities,
							necessitating the use of CICM::Key::unwrap to decrypt the key
							prior to use.</t>
							<t>Key attributes may optionally be set to create or supplement
							key metadata.</t>
							<t>The format of the key material value is not defined by CICM.
							The Implementation Conformance Statement (see Conformance and Extensions
              in <xref target="CICM" />) must reference a standard format or
							define a module developer-specific format implemented by the
							module for this datatype.</t>
							</list>
						</t><t>Warning:
							<list>
							<t>This call should only be used when a module utilizes a key
							storage model that requires keys of particular types to be
							stored in specific locations or in situations where keys are
							tied to module capabilities based upon physical location of the
							key. Because of the architectural knowledge of a module
							required, its use is highly discouraged because it virtually
							guarantees that code using it will be incompatible with other
							dissimilar modules.</t>
							<t>This method MUST NOT be implemented if
							CICM::SymKeyManager::import_key is implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] key_material Key material to be imported into the module.</t>
							<t>[in] phys_location Physical location into which to import key.</t>
							<t>[out] key_ref Reference to newly imported key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC,
							  S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED,
							  S_KEY_TRUST_ANCHOR, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::import_key_via_fill()</preamble>
<artwork><![CDATA[CICM::Status import_key_via_fill(
	in  CICM::LocalPort fill_port,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Initiate the import of key material via a key fill
						interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, a key fill device can initiate and effect
							the filling of key into a module completely independent of the
							host and thus any API control. In such cases, the host will
							utilize the CICM::SymKeyManager::get_key_by_id,
							CICM::SymKeyManager::get_key_by_phys_location, or
							CICM::SymKeyManager::get_key_last_filled methods after the key
							fill has completed to enable future reference to the key.</t>
							<t>Keys may be imported into a module as wrapped entities,
							necessitating the use of CICM::Key::unwrap to decrypt the key
							prior to use.</t>
							<t>Key attributes may optionally be set to create or supplement
							key metadata.</t>
							</list>
						</t><t>Warning:
							<list>
							<t>This method MUST NOT be implemented if
							CICM::SymKeyManager::import_key_via_fill_into_phys_location is
							implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] fill_port Port of the key fill interface.</t>
							<t>[out] key_ref Reference to newly imported key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_MALFORMED,
							  S_KEY_METADATA_MALFORMED, S_KEY_FILL_DEVICE_NOT_CONNECTED,
							  S_KEY_FILL_NOT_INITIATED, S_KEY_TRUST_ANCHOR,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::import_key_via_fill_into_phys_location()</preamble>
<artwork><![CDATA[CICM::Status import_key_via_fill_into_phys_location(
	in  CICM::LocalPort fill_port,
	in  CICM::UInt32 phys_location,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Initiate the import of key material into a specific key
						physical location via a key fill interface.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, a key fill device can initiate and effect
							the filling of key into a module completely independent of the
							host and thus any API control. In such cases, the host will
							utilize the CICM::SymKeyManager::get_key_by_id,
							CICM::SymKeyManager::get_key_by_phys_location, or
							CICM::SymKeyManager::get_key_last_filled methods after the key
							fill has completed to enable future reference to the key.</t>
							<t>Keys may be imported into a module as wrapped entities,
							necessitating the use of CICM::Key::unwrap to decrypt the key
							prior to use.</t>
							<t>Key attributes may optionally be set to create or supplement
							key metadata.</t>
							</list>
						</t><t>Warning:
							<list>
							<t>This call should only be used when a module utilizes a key
							storage model that requires keys of particular types to be
							stored in specific locations or in situations where keys are
							tied to module capabilities based upon physical location of the
							key. Because of the architectural knowledge of a module
							required, its use is highly discouraged because it virtually
							guarantees that code using it will be incompatible with other
							dissimilar modules.</t>
							<t>This method MUST NOT be implemented if
							CICM::SymKeyManager::import_key_via_fill is
							implemented.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] fill_port Port of the key fill interface.</t>
							<t>[in] phys_location Physical location into which to import key.</t>
							<t>[out] key_ref Reference to newly imported key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_PHYSICAL_LOC,
							  S_KEY_MALFORMED, S_KEY_METADATA_MALFORMED,
							  S_KEY_FILL_DEVICE_NOT_CONNECTED, S_KEY_FILL_NOT_INITIATED,
							  S_KEY_TRUST_ANCHOR, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::generate_key()</preamble>
<artwork><![CDATA[CICM::Status generate_key(
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::SymKey key_ref
)]]></artwork>
						<postamble>Generate a symmetric key compatible with the characteristics
						of the specified algorithm.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] algorithm Desired algorithm of resulting symmetric key.</t>
							<t>[out] key_ref Reference to newly generated key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::derive_key()</preamble>
<artwork><![CDATA[CICM::Status derive_key(
	in  CICM::CharString password,
	in  CICM::Buffer salt,
	in  CICM::UInt32 iteration_count,
	in  CICM::HashAlgorithmId hash_algorithm,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Derives a symmetric key from a password and other parameters
						using a password-based key derivation function (PBKDF).</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] password Password for conversion into a cryptographic
								  key.</t>
							<t>[in] salt Binary salt value.</t>
							<t>[in] iteration_count Positive integer representing number of iterations to
								  apply to hashing algorithm.</t>
							<t>[in] hash_algorithm Hash function applied to derive key.</t>
							<t>[in] algorithm Desired algorithm/mode of resulting symmetric key.</t>
							<t>[out] key_ref Reference to newly derived key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_PASSWORD_INVALID,
							  S_PASSWORD_INVALID_CHAR, S_PASSWORD_INVALID_LEN,
							  S_SALT_INVALID, S_ITERATION_COUNT_INVALID</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyManager::derive_deterministic_key()</preamble>
<artwork><![CDATA[CICM::Status derive_deterministic_key(
	in  CICM::SymKey key_prod_key,
	in  CICM::CharString shared_secret,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Derives a symmetric key using a distributed deterministic key
						generation scheme.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This may be used by peers in an ad-hoc group who initially
							only share a key production key (KPK) but are subsequently able
							to share an additional secret.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] key_prod_key Key production key.</t>
							<t>[in] shared_secret Text-based secret sharable amongst peers in a group.</t>
							<t>[in] algorithm Desired algorithm/mode of resulting symmetric key.</t>
							<t>[out] key_ref Reference to newly derived key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_PASSWORD_INVALID,
							  S_PASSWORD_INVALID_CHAR, S_PASSWORD_INVALID_LEN</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::SymKey">
					<figure>
					  <preamble>Interface CICM::SymKey</preamble>
					  <artwork><![CDATA[interface SymKey : CICM::Key {]]></artwork>
					<postamble>CICM::SymKey serves as a reference to a symmetric key
					contained within a module and supports operations on symmetric
					keys, including key conversion, updating, wrapping, and unwrapping.</postamble>
					</figure>

					<section title="CICM::SymKey Inheritance">
						<t>CICM::SymKey inherits from: CICM::Key.</t>
					</section>
					<section title="CICM::SymKey Types and Constants">
						<figure>
						  <preamble>Type CICM::SymKey::Usage</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Usage;]]></artwork>
						<postamble>Symmetric key usage types.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::SymKey::C_USAGE_GENERATE_KEYSTREAM</preamble>
<artwork><![CDATA[const CICM::SymKey::Usage
	C_USAGE_GENERATE_KEYSTREAM = 0x0000601A;]]></artwork>
							<postamble>Key intended for generating keystream.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::SymKey::C_USAGE_KEY_PRODUCTION_KEY</preamble>
<artwork><![CDATA[const CICM::SymKey::Usage
	C_USAGE_KEY_PRODUCTION_KEY = 0x0000601C;]]></artwork>
							<postamble>Key intended for producing other keys.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::SymKey::C_USAGE_MESSAGE_AUTHENTICATION_CODE</preamble>
<artwork><![CDATA[const CICM::SymKey::Usage
	C_USAGE_MESSAGE_AUTHENTICATION_CODE = 0x0000601F;]]></artwork>
						  <postamble>Key intended for computing a Message Authentication Code.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::SymKey::C_USAGE_SYM_DATA_ENCIPHERMENT</preamble>
<artwork><![CDATA[const CICM::SymKey::Usage
	C_USAGE_SYM_DATA_ENCIPHERMENT = 0x00006020;]]></artwork>
							<postamble>Key intended for enciphering data.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::SymKey::C_USAGE_SYM_KEY_ENCIPHERMENT</preamble>
<artwork><![CDATA[const CICM::SymKey::Usage
	C_USAGE_SYM_KEY_ENCIPHERMENT = 0x00006023;]]></artwork>
							<postamble>Key intended for enciphering other keys.</postamble>
						</figure>
					</section>
					<section title="CICM::SymKey Attributes">
						<figure>
						  <preamble>Attribute CICM::SymKey::update_count</preamble>
						  <artwork><![CDATA[readonly attribute CICM::UInt32 update_count;]]></artwork>
							<postamble>Key update count.</postamble>
						</figure>
					</section>
					<section title="CICM::SymKey Methods">
						<figure>
						  <preamble>Method CICM::SymKey::update()</preamble>
						  <artwork><![CDATA[CICM::Status update();]]></artwork>
						<postamble>Cryptographically update the key using the key's native
						algorithm. The update modifies the existing key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The new update count resulting from a call to this method
							is available as an attribute of the key object.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_WRAPPED,
							  S_KEY_UPDATE_MAX, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::update_with_algo for the version of this
							method that accepts an algorithm parameter.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKey::update_with_algo()</preamble>
<artwork><![CDATA[CICM::Status update_with_algo(
	in  CICM::SymEncrAlgorithmId algorithm
);]]></artwork>
						<postamble>Cryptographically update the key using the specified key
						update algorithm. The update modifies the existing key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The new update count resulting from a call to this method
							is available as an attribute of the key object.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] algorithm Cryptographic algorithm/mode to use to effect the key
								  update.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_INCOMPATIBLE, S_KEY_WRAPPED,
							  S_KEY_UPDATE_MAX, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::update for the version of this method that
							does not require an algorithm to be specified.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKey::wrap_and_copy()</preamble>
<artwork><![CDATA[CICM::Status wrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::SymKey wrapped_key
);]]></artwork>
						<postamble>Instruct module to wrap key, resulting in two keys, the
						original unwrapped key and the newly wrapped key.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] kek Reference to key encryption key.</t>
							<t>[in] algorithm Key wrap algorithm/mode used to wrap key.</t>
							<t>[out] wrapped_key Reference to resulting wrapped key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION, S_KEY_WRAPPED,
							  S_KEY_NOT_WRAPPABLE, S_KEY_WRAPPED_EXISTS, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::AsymKey::wrap_and_copy for the asymmetric version of
							this method.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKey::unwrap_and_copy()</preamble>
<artwork><![CDATA[CICM::Status unwrap_and_copy(
	in  CICM::Key kek,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::SymKey unwrapped_key
);]]></artwork>
						<postamble>Instruct module to unwrap key, resulting in two keys, the
						original wrapped key and the newly unwrapped key.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] kek Reference to key decryption key.</t>
							<t>[in] algorithm Key wrap algorithm/mode used to unwrap key.</t>
							<t>[out] unwrapped_key Reference to resulting unwrapped key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_KEY_INCOMPATIBLE, S_KEY_CLASSIFICATION,
							  S_KEY_UNWRAPPED_EXISTS, S_KEY_MALFORMED,
							  S_KEY_METADATA_MALFORMED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::AsymKey::unwrap_and_copy for the asymmetric version
							of this method.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKey::validate_key_usage()</preamble>
<artwork><![CDATA[CICM::Status validate_key_usage(
	in  CICM::SymKey::Usage usage_type,
	out CICM::Key::UsageStatus valid
);]]></artwork>
						<postamble>Validate that this key may be used for a specific
						purpose.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, a given key can be used for multiple
							purposes.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] usage_type Specific purpose to validate.</t>
							<t>[out] valid Indiciates if the key may be used for the specified
								  purpose.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::AsymKey::validate_key_usage for the asymmetric
							version of this method.</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::SymKeyIterator">
					<figure>
					  <preamble>Interface CICM::SymKeyIterator</preamble>
					  <artwork><![CDATA[interface SymKeyIterator : CICM::Iterator {]]></artwork>
					<postamble>CICM::SymKeyIterator supports retrieving a reference to each
					usable symmetric key on a module. CICM::SymKeyIterator constructs
					the CICM::SymKey interface.</postamble>
					</figure>

					<section title="CICM::SymKeyIterator Inheritance">
						<t>CICM::SymKeyIterator inherits from: CICM::Iterator.</t>
					</section>
					<section title="CICM::SymKeyIterator Methods">
						<figure>
						  <preamble>Method CICM::SymKeyIterator::get_next()</preamble>
<artwork><![CDATA[CICM::Status get_next(
	out CICM::SymKey sym_key_ref
);]]></artwork>
						<postamble>Returns a reference to the next symmetric key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Use CICM::Iterator::has_next to determine if additional
							elements exist.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] sym_key_ref Reference to next symmetric key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Key Protocol">
				<t>The key management capabilities described
				here support certain key management protocols, including key
				establishment/distribution protocols such as Diffie-Hellman, EC-DH,
				and EC-MQV; trust anchor management protocols; the importation of
				key white lists (acceptable keys) or black lists (revoked keys or
				keys restricted administratively); and the execution of remote key
				functions. These key protocol IDL interfaces initiate a key
				agreement protocol between two or more entities to establish a
				secret key over an insecure communications channel. CICM channel
				negotiators (CICM::Negotiator) similarly initiate a key agreement
				protocol with a remote entity, but this typically results in an
				ephemeral key, in contrast to these key protocol interfaces which
				result in a persistent symmetric key that can be used by a variety
				of key management and channel management functions.</t>
				<t>For the purposes of these key protocol-related interfaces, a
				client program using the CICM API is only an intermediary in a key
				management protocol being conducted between a cryptographic module
				and other participants in a protocol session. In this role, a
				client program determines which module(s) should be involved and
				conveys the protocol messages, but otherwise does not participate
				in the protocol session. The client may be responsible for
				determining which key agreement protocol to use as well as for the
				reliable transport of messages passed between the peer entities.
				The interactions that comprise a protocol session in its entirety
				may entail a number of exchanges among the participants in the
				protocol. Any results from calls to key protocol methods during the
				course of the protocol exchange must be communicated to the
				appropriate peer entity by the caller. The progress, success, or
				failure of the protocol session is determined by the modules and
				other active participants in the interaction.</t>
				<t>CICM key protocol functionality is exported via two independent
				objects: CICM::KeyProtocolSender for protocol messages inbound to
				the module and CICM::KeyProtocolReceiver for messages outbound from
				the module. Access to each respective object is available via
				CICM::SymKeyManager::key_protocol_sender and
				CICM::SymKeyManager::key_protocol_receiver.</t>
				<t>The key protocol methods support protocol sessions that may be
				long-term interactions potentially extending over several
				invocations of the controlling client program. To allow for this
				possibility, KeyProtocolReceiver::get_from_module may be used to
				"query" a module to determine if a response is ready and, if so, to
				retrieve response traffic (including current session status
				information) from the module. Thus, a single response from the
				module may take the form of a number of queries by the client
				program, with any productive response deferred until the module is
				ready:
				<list>
					<t>query, response is C_PROTOCOL_RECEIVE_BUSY</t>
					<t>query, response is C_PROTOCOL_RECEIVE_BUSY</t>
					<t>...</t>
					<t>query, response is C_PROTOCOL_RECEIVE_BUSY</t>
					<t>query, results returned, response is C_PROTOCOL_RECEIVE_OKAY</t>
				</list>
				</t>
				<t>In the example above, the client program expects either a
				"condition" update from the module as part of the protocol session,
				or the most recent results from the active session. Thus, the
				client program queries the module periodically until it is ready to
				produce a response.</t>
				<t>The traffic relayed by these functions is part of a specific
				protocol session. The protocol governing this session is specified
				with the protocol parameter, either the value
				CICM::IMPLICIT_PROTOCOL_ID, denoting that the message itself
				indicates the protocol, or a unique protocol identifier designating
				the protocol directly. If the protocol parameter is
				CICM::IMPLICIT_PROTOCOL_ID but the message does not indicate the
				protocol, then the method fails, returning the
				CICM::S_PROTO_UNDETERMINED error status.</t>
				<t>The initial message in a protocol exchange can be generated
				either by the cryptographic module or some other party, including
				some party in a key management infrastructure or the client program
				itself. If the initial message is generated by the cryptographic
				module, a two-step process allows the message to be retrieved from
				the module:
				<list style="numbers">
				  <t>The module notifies the client program that a protocol
				  message is available to be retrieved via the CICM module event
				  listener facility (this requires a
				  CICM::ModuleEventListener::C_MODULE_KEY_PROTO_MESSAGE to have
				  been previously registered by the client program). The listener
				  facility provides an opaque buffer as part of the notification
				  that is passed to the module in the following step to identify
				  the specific protocol message involved.</t>
				  <t>The CICM::KeyProtocolReceiver::get_from_module method is used
				  to retrieve the message from the module.</t>
				</list>
				</t>
				<t>If the initial message is generated by some other party, the
				CICM::KeyProtocolSender::put_into_module method is used to convey
				the message into the module.</t>
				<t>Any key protocol-related key fill device interactions are
				outside the scope of the API.</t>
				<t>Individual protocol events do not require a transaction
				identifier. Instead, each message itself indicates where it is to
				be forwarded (i.e. which module or other participant is to receive
				the message). This means that the client program must be capable of
				determining which module to associate with a given message,
				possibly by examining metadata conveyed with the message.</t>

				<section title="Participants in the Interaction">
					<t>There are three types of
					participants in a protocol session using the key protocol
					functionality:
					<list style="symbols">
					  <t>The cryptographic modules themselves. Note that although
					  these methods work with modules individually, there may in fact
					  be several modules involved in a single protocol session, e.g.,
					  to deliver the same key material to several modules available to
					  a host or in a net.</t>
					  <t>The other participants (generally key management
					  infrastructure components) that also take an active part in the
					  session, i.e., those that generate and/or consume messages
					  exchanged in the session (perhaps with status indications
					  embedded in the messages). All active participants, to the extent
					  they find necessary, maintain and update internal status as the
					  session continues.</t>
					  <t>The intermediary client program that conveys the messages
					  among the active participants in the session (the cryptographic
					  modules themselves and the other active participants in the
					  session). Note that a module may generate a message for
					  transmission to another module as part of the protocol
					  session.</t>
					</list></t>
					<t>The CICM API is the interface between the intermediary client
					programs and the cryptographic modules. All exchanges for a
					specific protocol session between a given module and other modules
					or other active participants (Party 1, ..., Party N) are mediated
					by the intermediary client program using CICM. Although the client
					program does not directly participate in the protocol session, the
					client program may be asked during the negotiation process to
					display identifying information about the remote party in the
					protocol to a human user who must determine if the remote party is
					the expected remote party in the protocol and, if so, must
					positively acknowledge this assertion to allow the protocol to
					continue. Some protocol sessions will not require this peer
					validation interaction (e.g., validation of the peer using a trust
					anchor is deemed sufficient or an external trusted display handles
					the user interaction).</t>
					<t>Except for recognizing the specific role of the cryptographic
					modules themselves, assignment of roles in the protocol to the
					active participants is out of scope for this document.</t>
				</section>
				<section title="Return Status, Condition, and Session Status">
					<t>The key
					protocol interfaces convey messages between modules and the
					intermediary client program but do not conduct the actual protocol
					session. However, the client program still needs to know something
					about the state of the session, so the key protocol methods impart
					three types of status information:
					<list style="symbols">
					  <t>Status return value indicates the status of the method call
					  itself. In the event of a failure, it gives an indication of what
					  the failure was. Note that the returned value does not indicate
					  the state of the protocol session itself: It could report a
					  faulty call (e.g., an invalid protocol identifier) even when the
					  protocol session is still making progress, and it could report a
					  successful exchange with the cryptographic module even when the
					  module decides that the session has reached an error
					  condition.</t>
					  <t>The returned condition indication summarizes for the client
					  program the state of the session, perhaps to be used along with
					  other information to suggest what the client program should do
					  next as part of the current protocol session.</t>
					  <t>The current or resulting status of the protocol session is
					  embedded in the message conveyed between the client program and
					  the active participants. The client program typically will not
					  interpret the contents of this message; instead, it will simply
					  convey the message to the appropriate active participants, who
					  may then interpret the status in the message and take the
					  appropriate next step in the protocol.</t>
					</list></t>
				</section>
				<section title="Generic Scenario">
					<t>The following diagram presents a generic
					scenario for a key protocol session. This diagram does not show
					message exchanges with any other active participants, since they
					are out of scope for the API. Note that, although responses from
					the module to the intermediary client program are represented as
					arrows in the diagram, in fact, the module actually conveys the
					response only when the client program explicitly asks or is
					prompted by an event to ask for it.</t>
          <figure><artwork><![CDATA[
 Intermediary
Client Program                                      Module
     |                                                |
     | A1: start key protocol                         |
     |----------------------------------------------->|
     |                                                |
     | M1: key protocol start C_PROTOCOL_SEND_OKAY    |
     |<===============================================|
     |                                                |
     | A2: send protocol message                      |
     |----------------------------------------------->|
     |                                                |
     | M2: message C_PROTOCOL_SEND_OKAY, more pending |
     |<===============================================|
     |                                                |
    ...             (protocol continues)             ...
     |                                                |
     | An: send protocol message                      |
     |----------------------------------------------->|
     | Mn: message C_PROTOCOL_SEND_OKAY, protocol done|
     |<===============================================|
     |                                                |]]></artwork>
     <postamble>Figure 1. Generic Scenario for Key
					  Protocol Session Initiated by a Key Infrastructure
					  Component</postamble>
          </figure>
					<t>The notional key infrastructure-initiated message exchanges are
					as follows:
					<list style="symbols">
					  <t>Event "A1": Start key protocol - The client program receives
					  the first protocol message from a key infrastructure component
					  and sends it to the module using
					  KeyProtocolSender::put_into_module. The returned condition
					  indicates that the protocol session is C_PROTOCOL_SEND_OKAY.</t>
					  <t>Event "M1": Successful start to key protocol - The client
					  program requests the module's response using
					  KeyProtocolReceiver::get_from_module. This response is the
					  module's first message in this exchange and includes the current
					  status of the session. Multiple queries could respond with a BUSY
					  condition before a C_PROTOCOL_SEND_OKAY condition is finally
					  returned. The C_PROTOCOL_SEND_OKAY condition indicates that the
					  session is in progress and a response message has been returned.
					  The client program is responsible for forwarding the resulting
					  response message to another active protocol participant.</t>
					  <t>Event "A2": Send protocol message - The client program
					  forwards the next message in the protocol sequence received from
					  the infrastructure component to the module using the
					  KeyProtocolSender::put_into_module method. The returned condition
					  indicates that the protocol session is C_PROTOCOL_SEND_OKAY.</t>
					  <t>Event "M2": Message C_PROTOCOL_SEND_OKAY, more pending - The
					  module provides another message in this exchange using
					  KeyProtocolReceiver::get_from_module. The returned condition
					  indicates that the protocol session is C_PROTOCOL_SEND_OKAY and a
					  responding message has been returned.</t>
					  <t>Event "An": Send protocol message - The client program
					  forwards what is ultimately the last message in the protocol
					  sequence to the module using
					  KeyProtocolSender::put_into_module.</t>
					  <t>Event "Mn": Message C_PROTOCOL_SEND_OKAY, protocol done - The
					  module provides the corresponding last message in this exchange
					  when the client program queries the module using
					  KeyProtocolReceiver::get_from_module. The returned condition
					  indicates that the protocol session is DONE and the last
					  responding message in this protocol session has been returned. As
					  shown here, the module determines (or at least reports to the
					  client program) when the protocol session is done. Another active
					  participant could plausibly make this determination.</t>
					</list></t>
				</section>
				<section title="Key Agreement Example Using Diffie-Hellman Protocol">
					<t>The
					following example depicts a notional key infrastructure ("Entity
					A") initiating an authenticated Diffie-Hellman Discrete Logarithm
					(DH-DL) key agreement protocol with a cryptographic module ("Entity
					B"). A host running a client program using CICM for interactions
					with the module interposes itself between the key infrastructure
					and the module.</t>
          <figure>
<artwork><![CDATA[
  Entity A       Client      Key Protocol  Key Protocol    Entity B
 (g,p,certA)     Program        Sender       Receiver     (g,p,certB)
     |              |              |             |            |
 generates a        |              |             |            |
     |              |              |             |            |
 calculates         |              |             |            |
A = g^a mod p       |              |             |            |
     |              |              |             |            |
     |[g,p,a,certA] |              |             |            |
     |------------->|              |             |            |
     |        put_into_module([g,p,a,certA])     |            |
     |              |------------->|      [g,p,a,certA]       |
     |              |              |------------------------->|
     |              |              |            ok            |
     |              |              |<=========================|
     |           C_PROTOCOL_SEND_OKAY            |            |
     |              |<=============|             |            |
     |              |     get_from_module()      |            |
     |              |--------------------------->|            |
     |              |              |             |----------->|
     |              |              |             |            |
     |              |              |             |       generates b
     |              |              |             |            |
     |              |              |             |       calculates
     |              |              |             |      B = g^b mod p
     |              |              |             |            |
     |              |              |             |  [B,certB] |
     |              |         [B,certB]          |<===========|
     |   [B,certB]  |<===========================|            |
     |<=============|              |             |            |
     |              |              |             |            |
 calculates         |              |             |       calculates
K = B^a mod p       |              |             |      K = A^b mod p
     |              |              |             |            |]]></artwork>
          <postamble>Figure 2. Example of a Two-key
					  Diffie-Hellman Discrete Logarithm (DH-DL) Key Agreement Protocol
					  Initiated by a Key Infrastructure</postamble>
          </figure>
					<t>The following are the steps required to use CICM in the protocol
					example between a notional key infrastructure ("Entity A") and a
					cryptographic module ("Entity B"):
					<list style="numbers">
					  <t>The following are prepositioned at both communicating
					  elements:
					  <list style="symbols">
						<t>Domain parameters g and p.</t>
						<t>Digital certificate.</t>
						<t>Signature verification key required to validate the
						certificate of the other entity.</t>
						</list></t>
					  <t>"Entity A" generates random value a.</t>
					  <t>"Entity A" calculates A=g^a mod p.</t>
					  <t>"Entity A" signs the value A calculated above using its
					  static private key whose corresponding static public key is
					  contained in its certificate.</t>
					  <t>"Entity A" sends the signed value A and cert-A to the client
					  program on the intermediary host as an opaque binary buffer.</t>
					  <t>The client program on the intermediary host calls
					  KeyProtocolSender::put_into_module to send the opaque binary
					  buffer received by the client program to the module; if a
					  CICM::KeyProtocolSender::C_PROTOCOL_SEND_DISPLAY condition is
					  returned from this call, the following steps SHOULD be performed
					  (the steps do not appear in the diagram):
					  <list style="letters">
						<t>"Entity A" calls CICM::Negotiator::get_remote_info to
						retrieve information about the remote peer; this information
						(including name/organization and classification level) are
						extracted from cert-B and returned in CICM::PeerInfo.</t>
						<t>The client program on the intermediary host displays the
						identifying information returned above in CICM::PeerInfo to a
						human user and asks for positive acknowledgement that the
						entity initiating the protocol is in fact a legal entity to
						initiate the protocol.</t>
						<t>If the human user does not recognize the remote entity and
						declines to give positive acknowledgement, the client program
						abandons the protocol. In this example, positive
						acknowledgement is given, and the client program calls
						CICM::KeyProtocolReceiver::get_from_module to request a
						protocol response.</t>
					  </list></t>
					  <t>"Entity B" generates random value b.</t>
					  <t>"Entity B" calculates B=g^b mod p, using parameters g and p
					  that it previously agreed it would use when initiating a protocol
					  exchange with "Entity A."</t>
					  <t>"Entity B" signs the value B calculated above using its
					  static private key whose corresponding static public key is
					  contained in its certificate.</t>
					  <t>"Entity B" returns an opaque binary buffer containing its
					  signed value B and cert-B to the caller of
					  KeyProtocolReceiver::get_from_module with a condition of
					  DONE.</t>
					  <t>The client program on the intermediary host sends the opaque
					  binary buffer to "Entity A".</t>
					  <t>Both entities verify their peer's certificate is valid.</t>
					  <t>"Entity A" calculates K=B^a mod p.</t>
					  <t>"Entity B" calculates K=A^b mod p.</t>
					  <t>Both entities now share a symmetric key K.</t>
					</list></t>
				</section>
				<section title="Protocol Support Examples">
					<t>As previously stated, these
					methods support a wide range of key management protocols. The
					following is a notional list of such protocols with a description
					of their intended usage:
					<list style="symbols">
					  <t>Key agreement/distribution protocols - Key material can be
					  distributed and keys can be agreed upon using the DH-DL, EC-DH,
					  EC-MQV, or related protocols.</t>
					  <t>Remote key functions - Messages containing key-related
					  commands (i.e., zeroize, rekey) requiring authentication by the
					  module prior to execution may be presented using these
					  functions.</t>
					  <t>Trust anchor management protocols - Trust anchor management
					  commands and data may be sent as opaque data elements which are
					  interpreted by the module in a protocol-specific manner.</t>
					  <t>Key revocation messages - Opaque data elements identifying
					  certificates associated with keys which have been revoked or
					  accepted. The ability to handle a list of revoked keys allows a
					  module to prevent further usage of these keys, including
					  performing key agreement with an entity that is known to have
					  been compromised or no longer possesses the roles or affiliations
					  described in the certificate.</t>
					</list></t>
				</section>
				<section title="Interface CICM::KeyProtocolSender">
					<figure>
					  <preamble>Interface CICM::KeyProtocolSender</preamble>
					  <artwork><![CDATA[interface KeyProtocolSender : CICM::Negotiator {]]></artwork>
					<postamble>CICM::KeyProtocolSender supports sending key management
					protocol-related messages into a module.</postamble>
					</figure>

					<section title="CICM::KeyProtocolSender Inheritance">
						<t>CICM::KeyProtocolSender inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::KeyProtocolSender Types and Constants">
						<figure>
						  <preamble>Type CICM::KeyProtocolSender::Condition</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Condition;]]></artwork>
						<postamble>Condition values summarize for the client program the state
						of the session. This information can be used along with other
						information to suggest what the client program should do next as
						part of the current protocol session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_OKAY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_OKAY = 0x00006045;]]></artwork>
						  <postamble>Denotes that the session is in progress and a response
						  message is available.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_DONE</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_DONE = 0x00006046;]]></artwork>
							<postamble>Denotes that the session terminated successfully.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_ERROR</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_ERROR = 0x00006049;]]></artwork>
						  <postamble>Denotes that the session terminated with an error
						  condition.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_DISPLAY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_DISPLAY = 0x0000604A;]]></artwork>
						  <postamble>As with the C_PROTOCOL_SEND_OKAY condition, denotes that
						  the session is in progress and a response message is available,
						  but additionally denotes that identification information
						  extracted from the remote certificate is available via a call to
						  the CICM::Negotiator::get_remote_info method; the information
						  retrieved from a call to this method must be displayed to a human
						  user on the host and validated before the protocol should be
						  allowed to continue. Note that a trusted display may be employed
						  by the module for the same purpose but, because no API
						  interaction would be involved, the C_PROTOCOL_SEND_DISPLAY
						  condition would not be returned.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_ABORTED</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_ABORTED = 0x0000604C;]]></artwork>
						  <postamble>Denotes that the human user reviewing the remote peer
						  information chose to reject it and abort the protocol.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_MESSAGE_INVALID</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_MESSAGE_INVALID = 0x0000604F;]]></artwork>
						  <postamble>Denotes that the conveyed message was found to be invalid
						  for the protocol. This event does not terminate the protocol
						  session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_MESSAGE_INTEGRITY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_MESSAGE_INTEGRITY = 0x00006051;]]></artwork>
						  <postamble>Denotes that the conveyed message failed one or more
						  integrity checks used in the protocol. This event does not
						  terminate the protocol session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolSender::C_PROTOCOL_SEND_PROTOCOL_VIOLATION</preamble>
<artwork><![CDATA[const CICM::KeyProtocolSender::Condition
	C_PROTOCOL_SEND_PROTOCOL_VIOLATION = 0x00006052;]]></artwork>
						  <postamble>Denotes that a message or attempted action unexpected at
						  the current point in the protocol session was noted. This event
						  does not terminate the protocol session.</postamble>
						</figure>
					</section>
					<section title="CICM::KeyProtocolSender Methods">
						<figure>
						  <preamble>Method CICM::KeyProtocolSender::put_into_module()</preamble>
<artwork><![CDATA[CICM::Status put_into_module(
	in  CICM::ProtocolId protocol,
	in  CICM::Buffer message,
	out CICM::KeyProtocolSender::Condition condition
);]]></artwork>
						<postamble>Initiate or recommence a key management protocol session,
						forwarding a message to the cryptographic module. If the
						C_PROTOCOL_SEND_DISPLAY condition results, the get_remote_info
						method should be called to retrieve identity information about the
						remote peer for display to and validation by the responsible user
						before the protocol negotiation is allowed to continue.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The format of the conveyed message is not defined by CICM.
							If the client program must be capable of generating the
							message, then the Implementation Conformance Statement (see
							Conformance and Extensions in <xref target="CICM" />) MUST reference a
							standard format or define a module developer-specific format
							implemented by the module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] protocol Designate the protocol to be followed for this
								  session; the same value must be used for this parameter
								  for all calls to this method or to get_from_module, as
								  part of the same protocol session.</t>
							<t>[in] message Message conveyed to the module as part of the current
								  protocol session.</t>
							<t>[out] condition Condition of the current protocol session; the
								  calling client program must interpret this value to
								  determine what its next action must be.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::KeyProtocolSender::put_into_module_algo for the
							version of this method that accepts an algorithm.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::KeyProtocolSender::put_into_module_algo()</preamble>
<artwork><![CDATA[CICM::Status put_into_module_algo(
	in  CICM::ProtocolId protocol,
	in  CICM::Buffer message,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::KeyProtocolSender::Condition condition
);]]></artwork>
						<postamble>Initiate or recommence a key management protocol session,
						forwarding a message to the cryptographic module. If the
						C_PROTOCOL_SEND_DISPLAY condition results, the get_remote_info
						method should be called to retrieve identity information about the
						remote peer for display to and validation by the responsible user
						before the protocol negotiation is allowed to continue. This method
						differs from KeyProtocolSender::put_into_module in that it enables
						the caller to specify the desired algorithm of the resulting
						symmetric key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The format of the conveyed message is not defined by CICM.
							If the client program must be capable of generating the
							message, then the Implementation Conformance Statement (see
						  Conformance and Extensions in <xref target="CICM" />) MUST reference a
							standard format or define a module developer-specific format
							implemented by the module for this datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] protocol Designate the protocol to be followed for this
								  session; the same value must be used for this parameter
								  for all calls to this method or to get_from_module, as
								  part of the same protocol session.</t>
							<t>[in] message Message conveyed to the module as part of the current
								  protocol session.</t>
							<t>[in] algorithm Algorithm/mode of resulting symmetric key.</t>
							<t>[out] condition Condition of the current protocol session; the
								  calling client program must interpret this value to
								  determine what its next action must be.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::KeyProtocolSender::put_into_module for the version of
							this method that does not require an algorithm.</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::KeyProtocolReceiver">
					<figure>
					  <preamble>Interface CICM::KeyProtocolReceiver</preamble>
					  <artwork><![CDATA[interface KeyProtocolReceiver {]]></artwork>
					<postamble>CICM::KeyProtocolReceiver supports receiving key management
					protocol-related messages from a module. CICM::KeyProtocolReceiver
					constructs the CICM::SymKey interface.</postamble>
					</figure>

					<section title="CICM::KeyProtocolReceiver Types and Constants">
						<figure>
						  <preamble>Type CICM::KeyProtocolReceiver::Condition</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 Condition;]]></artwork>
						<postamble>Condition values summarize for the client program the state
						of the session. This information can be used along with other
						information to suggest what the client program should do next as
						part of the current protocol session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_OKAY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_OKAY = 0x00006034;]]></artwork>
						  <postamble>Denotes that the session is in progress and a response
						  message has been returned.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_DONE</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_DONE = 0x00006037;]]></artwork>
							<postamble>Denotes that the session terminated successfully.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_BUSY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_BUSY = 0x00006038;]]></artwork>
						  <postamble>Denotes that the session is in progress but no response
						  message or error indication is available at the current time; in
						  this case, the client program must make additional calls to
						  CICM::KeyProtocolReceiver::get_from_module to determine when the
						  response message has become available and retrieve the
						  message.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_ERROR</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_ERROR = 0x0000603B;]]></artwork>
						  <postamble>Denotes that the session terminated with an error condition
						  and a response message has been returned.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_ABORTED</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_ABORTED = 0x0000603D;]]></artwork>
						  <postamble>Denotes that the human user reviewing the remote peer
						  information chose to reject it and abort the protocol.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_MESSAGE_INVALID</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_MESSAGE_INVALID = 0x0000603E;]]></artwork>
						  <postamble>Denotes that the conveyed message was found to be invalid
						  for the protocol. This event does not terminate the protocol
						  session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_MESSAGE_INTEGRITY</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_MESSAGE_INTEGRITY = 0x00006040;]]></artwork>
						  <postamble>Denotes that the conveyed message failed one or more
						  integrity checks used in the protocol. This event does not
						  terminate the protocol session.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::KeyProtocolReceiver::C_PROTOCOL_RECEIVE_VIOLATION</preamble>
<artwork><![CDATA[const CICM::KeyProtocolReceiver::Condition
	C_PROTOCOL_RECEIVE_VIOLATION = 0x00006043;]]></artwork>
						  <postamble>Denotes that a message or attempted action unexpected at
						  the current point in the protocol session was noted. This event
						  does not terminate the protocol session.</postamble>
						</figure>
					</section>
					<section title="CICM::KeyProtocolReceiver Methods">
						<figure>
						  <preamble>Method CICM::KeyProtocolReceiver::abort()</preamble>
						  <artwork><![CDATA[CICM::Status abort();]]></artwork>
						  <postamble>Abort negotiation.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This method may be called at any point in the negotiation
							process for any reason. However, it must be called in the event
							the identification information for the remote peer does not
							correspond to the expected peer.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_NOT_IN_PROGRESS</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::KeyProtocolReceiver::get_from_module()</preamble>
<artwork><![CDATA[CICM::Status get_from_module(
	in  CICM::ProtocolId protocol,
	out CICM::Buffer message,
	out CICM::KeyProtocolReceiver::Condition condition
);]]></artwork>
							<postamble>Initiate or recommence a key management protocol session,
							soliciting a response from the cryptographic module.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The format of the conveyed message is not defined by CICM.
							If the client program must be capable of interpreting the
							contents of the message, then the Implementation Conformance
							Statement (see Conformance and Extensions in <xref target="CICM" />) MUST
							reference a standard format or define a module
							developer-specific format implemented by the module for this
							datatype.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] protocol Designate the protocol to be followed for this
								  session; the same value must be used for this parameter
								  for all calls to this method or to
								  CICM::KeyProtocolSender::put_into_module, as part of the
								  same protocol session.</t>
							<t>[out] message Message returned from the module as part of the
								  current protocol session; message may be of length
								  zero.</t>
							<t>[out] condition Condition of the current protocol session; the
								  calling client program must interpret this value to
								  determine what its next action must be.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::KeyProtocolReceiver::get_key()</preamble>
<artwork><![CDATA[CICM::Status get_key(
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>At successful conclusion of a key agreement/distribution
						protocol session (when the returned condition is
						C_PROTOCOL_RECEIVE_DONE), this method is called to retrieve a
						reference to the key resulting from the session.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Note that, in those cases where the protocol session does
							not result in a key (e.g., a key revocation message, key white
							list or black list is presented to the module via this
							interface), calling this method will result in an
							CICM::S_INVALID_STATE error.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] key_ref Reference to key resulting from a successful protocol
								  session.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_NOT_IN_PROGRESS</t>
							</list>
						</t>
					</section>
				</section>
			</section>
      <section title="IANA Considerations">
        <t>[RFC Editor: Please remove this section prior to publication.]</t>
        <t>This document has no IANA actions.</t>
      </section>
      <section title="Security Considerations">
        <section title="Authorization">
          <t>The use of cryptographic key material is often limited to a set of
          authorized users. Authorization may be revoked by administrative means
          not defined by CICM or, in the extreme case, by zeroizing the key.</t>
          <t>The Key Protocol capabilities can also be used to manage key white lists
          and black lists which may limit authorized access to cryptographic material.</t>
        </section>
        <section title="Authentication">
          <t>The operations defined in this document require properly authorized
          and authenticated users in order to create, manage, import, export, or
          manipulate cryptographic key material.</t>
        </section>
        <section title="Entity Authentication">
          <t>When using the Key Protocol mechanism, the module will typically authenticate
          that the party with which it is communicating is the party which is intended.
          When the module receives the certificate of the communicating party, this information
          is extracted and provided in a CICM::PeerInfo object which must be positively identified
          before the protocol continues forward.</t>
          <t>Key Protocol also provides the capability to store revocation lists which may
          prevent the module from performing key agreement with an entity that is known to have
          to have been compromised or no longer possesses the roles or affiliations described
          in the certificate.</t>
        </section>
        <section title="Confidentiality">
          <t>A common use of cryptographic key material is to provide confidentiality
          between two communicating entities. See <xref target="CICM-CM" /> for the
          details of different confidential communications channels.</t>
        </section>
        <section title="Data Integrity">
          <t>Asymmetric keys are often used to provide data integrity capabilities.
          See <xref target="CICM-CM" /> for channels that provide data integrity.</t>
        </section>
        <section title="Inappropriate Usage">
          <t>CICM defines a set of error codes (S_KEY_USED_INVALID, S_KEY_USED_EXPIRED,
          S_KEY_USED_CLASSIFICATION, S_KEY_INVALID, S_KEY_EXPIRED, S_KEY_INCOMPATIBLE,
          S_KEY_CLASSIFICATION) to mitigate against the inappropriate key usage.</t>
          <t>Additionally, CICM provides the Key::state and Key::classification attributes
          as well as the SymKey::validate_key_usage() and AsymKey::validate_key_usage() methods
          to provide information about the appropriate uses for each key.</t>
        </section>
      </section>
  </middle>
  <back><!-- Back material. -->
    <references title="Normative References">
      <?rfc include="reference.RFC.2119" ?>

      <reference anchor="CICM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM)
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-02.txt" />
      </reference>

      <reference anchor="CICM-KM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Key Management
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-keys-00.txt" />
      </reference>

      <reference anchor="CICM-CM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Channel Management
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-channels-00.txt" />
      </reference>

      <reference anchor="IDL">
        <front>
          <title>Information technology — Open Distributed Processing — Interface Definition Language</title>
          <author>
            <organization>International Standards Organization</organization>
          </author>
          <date year="1999" month="March" day="15" />
        </front>
        <seriesInfo name="ISO/IEC" value="14750:1999(E)" />
      </reference>
    </references>
    <references title="Informative References">
      <?rfc include="reference.RFC.3552" ?>

      <reference anchor="CICM-LM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Logical Model
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-model-00.txt" />
      </reference>

      <reference anchor="CORBA">
        <front>
          <title>Common Object Request Broker Architecture (CORBA) Specification, Version 3.1</title>
          <author>
            <organization>Object Management Group</organization>
          </author>
          <date year="2008" month="January" />
        </front>
      </reference>
    </references>
    <section anchor="idl-code" title="IDL Definitions"><figure><artwork><![CDATA[module CICM {
  typedef CICM::CharString KeyId;

  interface Key {
    typedef CICM::UInt32 State;
    const CICM::Key::State C_KEY_INVALID = 0x00006010;
    const CICM::Key::State C_KEY_VALID_WRAPPED = 0x00006013;
    const CICM::Key::State C_KEY_VALID_UNWRAPPED = 0x00006015;

    typedef CICM::UInt32 UsageStatus;
    const CICM::Key::UsageStatus C_KEY_USAGE_ALLOWED = 0x00006016;
    const CICM::Key::UsageStatus C_KEY_USAGE_FORBIDDEN = 0x00006019;

    attribute CICM::CharString identifier;
    attribute CICM::UInt32 location;
    attribute CICM::CharString alias;
    attribute CICM::Classification classification;
    attribute CICM::CharString caveat;
    attribute CICM::CharString authority;
    readonly attribute CICM::Key::State state;

    CICM::Status wrap(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm );

    CICM::Status unwrap(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm );

    CICM::Status export(
      out CICM::Buffer key_material );

    CICM::Status export_via_fill_interface(
      in  CICM::LocalPort fill_port );

    CICM::Status zeroize();
  };

  interface SymKey : CICM::Key {
    typedef CICM::UInt32 Usage;
    const CICM::SymKey::Usage
      C_USAGE_GENERATE_KEYSTREAM = 0x0000601A;

    const CICM::SymKey::Usage
      C_USAGE_KEY_PRODUCTION_KEY = 0x0000601C;

    const CICM::SymKey::Usage
      C_USAGE_MESSAGE_AUTHENTICATION_CODE = 0x0000601F;

    const CICM::SymKey::Usage
      C_USAGE_SYM_DATA_ENCIPHERMENT = 0x00006020;

    const CICM::SymKey::Usage
      C_USAGE_SYM_KEY_ENCIPHERMENT = 0x00006023;

    readonly attribute CICM::UInt32 update_count;

    CICM::Status update();

    CICM::Status update_with_algo(
      in  CICM::SymEncrAlgorithmId algorithm );

    CICM::Status wrap_and_copy(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm,
      out CICM::SymKey wrapped_key );

    CICM::Status unwrap_and_copy(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm,
      out CICM::SymKey unwrapped_key );

    CICM::Status validate_key_usage(
      in  CICM::SymKey::Usage usage_type,
      out CICM::Key::UsageStatus valid );
  };

  interface AsymKey : CICM::Key {
    typedef CICM::UInt32 Usage;
    const CICM::AsymKey::Usage
      C_USAGE_ASYM_DATA_ENCIPHERMENT = 0x00006001;

    const CICM::AsymKey::Usage
      C_USAGE_ASYM_KEY_ENCIPHERMENT = 0x00006002;

    const CICM::AsymKey::Usage
      C_USAGE_CERT_SIGN = 0x00006004;

    const CICM::AsymKey::Usage
      C_USAGE_CRL_SIGN = 0x00006007;

    const CICM::AsymKey::Usage
      C_USAGE_DIGITAL_SIGNATURE = 0x00006008;

    const CICM::AsymKey::Usage
      C_USAGE_INFRA_KEY_AGREEMENT = 0x0000600B;

    const CICM::AsymKey::Usage
      C_USAGE_P2P_KEY_AGREEMENT = 0x0000600D;

    const CICM::AsymKey::Usage
      C_USAGE_SEED = 0x0000600E;

    CICM::Status wrap_and_copy(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm,
      out CICM::AsymKey wrapped_key );

    CICM::Status unwrap_and_copy(
      in  CICM::Key kek,
      in  CICM::KeyWrapAlgorithmId algorithm,
      out CICM::AsymKey unwrapped_key );

    CICM::Status validate_key_usage(
      in  CICM::AsymKey::Usage usage_type,
      out CICM::Key::UsageStatus valid );
  };

  interface SymKeyIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::SymKey sym_key_ref );
  };

  interface AsymKeyIterator : CICM::Iterator {
    CICM::Status get_next(
      out CICM::AsymKey asym_key_ref );
  };

  interface KeyProtocolSender : CICM::Negotiator {
    typedef CICM::UInt32 Condition;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_OKAY = 0x00006045;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_DONE = 0x00006046;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_ERROR = 0x00006049;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_DISPLAY = 0x0000604A;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_ABORTED = 0x0000604C;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_MESSAGE_INVALID = 0x0000604F;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_MESSAGE_INTEGRITY = 0x00006051;

    const CICM::KeyProtocolSender::Condition
      C_PROTOCOL_SEND_PROTOCOL_VIOLATION = 0x00006052;

    CICM::Status put_into_module(
      in  CICM::ProtocolId protocol,
      in  CICM::Buffer message,
      out CICM::KeyProtocolSender::Condition condition );

    CICM::Status put_into_module_algo(
      in  CICM::ProtocolId protocol,
      in  CICM::Buffer message,
      in  CICM::SymEncrAlgorithmId algorithm,
      out CICM::KeyProtocolSender::Condition condition );
  };

  interface KeyProtocolReceiver {
    typedef CICM::UInt32 Condition;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_OKAY = 0x00006034;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_DONE = 0x00006037;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_BUSY = 0x00006038;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_ERROR = 0x0000603B;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_ABORTED = 0x0000603D;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_MESSAGE_INVALID = 0x0000603E;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_MESSAGE_INTEGRITY = 0x00006040;

    const CICM::KeyProtocolReceiver::Condition
      C_PROTOCOL_RECEIVE_VIOLATION = 0x00006043;

    CICM::Status abort();

    CICM::Status get_from_module(
      in  CICM::ProtocolId protocol,
      out CICM::Buffer message,
      out CICM::KeyProtocolReceiver::Condition condition );

    CICM::Status get_key(
      out CICM::SymKey key_ref );
  };

  interface SymKeyManager {
    readonly attribute CICM::SymKeyIterator symkey_iterator;
    readonly attribute CICM::KeyProtocolSender key_protocol_sender;
    readonly attribute CICM::KeyProtocolReceiver key_protocol_receiver;

    CICM::Status get_key_by_id(
      in  CICM::KeyId key_id,
      out CICM::SymKey key_ref );

    CICM::Status get_key_by_phys_location(
      in  CICM::UInt32 phys_location,
      out CICM::SymKey key_ref );

    CICM::Status get_key_last_filled(
      out CICM::SymKey key_ref );

    CICM::Status import_key(
      in  CICM::Buffer key_material,
      out CICM::SymKey key_ref );

    CICM::Status import_key_into_phys_location(
      in  CICM::Buffer key_material,
      in  CICM::UInt32 phys_location,
      out CICM::SymKey key_ref );

    CICM::Status import_key_via_fill(
      in  CICM::LocalPort fill_port,
      out CICM::SymKey key_ref );

    CICM::Status import_key_via_fill_into_phys_location(
      in  CICM::LocalPort fill_port,
      in  CICM::UInt32 phys_location,
      out CICM::SymKey key_ref );

    CICM::Status generate_key(
      in  CICM::SymEncrAlgorithmId algorithm,
      out CICM::SymKey key_ref );

    CICM::Status derive_key(
      in  CICM::CharString password,
      in  CICM::Buffer salt,
      in  CICM::UInt32 iteration_count,
      in  CICM::HashAlgorithmId hash_algorithm,
      in  CICM::SymEncrAlgorithmId algorithm,
      out CICM::SymKey key_ref );

    CICM::Status derive_deterministic_key(
      in  CICM::SymKey key_prod_key,
      in  CICM::CharString shared_secret,
      in  CICM::SymEncrAlgorithmId algorithm,
      out CICM::SymKey key_ref );
  };

  interface AsymKeyManager {
    readonly attribute CICM::AsymKeyIterator asymkey_iterator;

    CICM::Status get_key_by_id(
      in  CICM::KeyId key_id,
      out CICM::AsymKey key_ref );

    CICM::Status get_key_by_phys_location(
      in  CICM::UInt32 phys_location,
      out CICM::AsymKey key_ref );

    CICM::Status get_key_last_filled(
      out CICM::AsymKey key_ref );

    CICM::Status import_key(
      in  CICM::Buffer key_material,
      out CICM::AsymKey key_ref );

    CICM::Status import_key_into_phys_location(
      in  CICM::Buffer key_material,
      in  CICM::UInt32 phys_location,
      out CICM::SymKey key_ref );

    CICM::Status import_key_via_fill(
      in  CICM::LocalPort fill_port,
      out CICM::AsymKey key_ref );

    CICM::Status import_key_via_fill_into_phys_location(
      in  CICM::LocalPort fill_port,
      in  CICM::UInt32 phys_location,
      out CICM::AsymKey key_ref );

    CICM::Status generate_key_pair(
      in  CICM::AsymEncrAlgorithmId algorithm,
      out CICM::AsymKey key_ref );
  };

  interface KeyDatabase {
    CICM::Status zeroize();
    CICM::Status reencrypt();
  };
};]]></artwork></figure>
    </section>
  </back>
</rfc>