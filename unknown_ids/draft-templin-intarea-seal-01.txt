


Network Working Group                                    F. Templin, Ed.
Internet-Draft                              Boeing Research & Technology
Intended status: Standards Track                           June 17, 2009
Expires: December 19, 2009


        The Subnetwork Encapsulation and Adaptation Layer (SEAL)
                   draft-templin-intarea-seal-01.txt

Status of this Memo

   This Internet-Draft is submitted to IETF in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on December 19, 2009.

Copyright Notice

   Copyright (c) 2009 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents in effect on the date of
   publication of this document (http://trustee.ietf.org/license-info).
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.

Abstract

   For the purpose of this document, subnetworks are defined as virtual
   topologies that span connected network regions bounded by
   encapsulating border nodes.  These virtual topologies may span



Templin                 Expires December 19, 2009               [Page 1]

Internet-Draft                    SEAL                         June 2009


   multiple IP and/or sub-IP layer forwarding hops, and can introduce
   failure modes due to packet duplication and/or links with diverse
   Maximum Transmission Units (MTUs).  This document specifies a
   Subnetwork Encapsulation and Adaptation Layer (SEAL) that
   accommodates such virtual topologies over diverse underlying link
   technologies.


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  Motivation . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.2.  Approach . . . . . . . . . . . . . . . . . . . . . . . . .  6
   2.  Terminology and Requirements . . . . . . . . . . . . . . . . .  6
   3.  Applicability Statement  . . . . . . . . . . . . . . . . . . .  8
   4.  SEAL Protocol Specification (Version 0)  . . . . . . . . . . .  8
     4.1.  Model of Operation . . . . . . . . . . . . . . . . . . . .  8
     4.2.  SEAL Header Format (Version 0) . . . . . . . . . . . . . . 10
     4.3.  ITE Specification  . . . . . . . . . . . . . . . . . . . . 11
       4.3.1.  Tunnel Interface MTU . . . . . . . . . . . . . . . . . 11
       4.3.2.  Admitting Packets into the Tunnel Interface  . . . . . 12
       4.3.3.  Segmentation . . . . . . . . . . . . . . . . . . . . . 13
       4.3.4.  Encapsulation  . . . . . . . . . . . . . . . . . . . . 15
       4.3.5.  Probing Strategy . . . . . . . . . . . . . . . . . . . 15
       4.3.6.  Packet Identification  . . . . . . . . . . . . . . . . 16
       4.3.7.  Sending SEAL Protocol Packets  . . . . . . . . . . . . 16
       4.3.8.  Processing Raw ICMP Messages . . . . . . . . . . . . . 17
       4.3.9.  Processing SEAL Control Messages . . . . . . . . . . . 17
     4.4.  ETE Specification  . . . . . . . . . . . . . . . . . . . . 19
       4.4.1.  Reassembly Buffer Requirements . . . . . . . . . . . . 19
       4.4.2.  IP-Layer Reassembly  . . . . . . . . . . . . . . . . . 19
       4.4.3.  SEAL-Layer Reassembly  . . . . . . . . . . . . . . . . 20
       4.4.4.  Decapsulation and Delivery to Upper Layers . . . . . . 21
       4.4.5.  Sending SEAL Control Messages  . . . . . . . . . . . . 21
   5.  SEAL Protocol Specification (Version 1)  . . . . . . . . . . . 28
     5.1.  Model of Operation . . . . . . . . . . . . . . . . . . . . 28
     5.2.  SEAL Header Format (Version 1) . . . . . . . . . . . . . . 28
     5.3.  ITE Specification  . . . . . . . . . . . . . . . . . . . . 29
       5.3.1.  Tunnel Interface MTU . . . . . . . . . . . . . . . . . 29
       5.3.2.  Admitting Packets into the Tunnel Interface  . . . . . 29
       5.3.3.  Segmentation . . . . . . . . . . . . . . . . . . . . . 29
       5.3.4.  Encapsulation  . . . . . . . . . . . . . . . . . . . . 30
       5.3.5.  Probing Strategy . . . . . . . . . . . . . . . . . . . 30
       5.3.6.  Packet Identification  . . . . . . . . . . . . . . . . 30
       5.3.7.  Sending SEAL Protocol Packets  . . . . . . . . . . . . 30
       5.3.8.  Processing Raw ICMP Messages . . . . . . . . . . . . . 30
       5.3.9.  Processing SEAL Control Messages . . . . . . . . . . . 30
     5.4.  ETE Specification  . . . . . . . . . . . . . . . . . . . . 30



Templin                 Expires December 19, 2009               [Page 2]

Internet-Draft                    SEAL                         June 2009


       5.4.1.  Reassembly Buffer Requirements . . . . . . . . . . . . 30
       5.4.2.  IP-Layer Reassembly  . . . . . . . . . . . . . . . . . 31
       5.4.3.  SEAL-Layer Reassembly  . . . . . . . . . . . . . . . . 31
       5.4.4.  Decapsulation and Delivery to Upper Layers . . . . . . 31
       5.4.5.  Sending SEAL Control Messages  . . . . . . . . . . . . 31
   6.  Link Requirements  . . . . . . . . . . . . . . . . . . . . . . 31
   7.  End System Requirements  . . . . . . . . . . . . . . . . . . . 31
   8.  Router Requirements  . . . . . . . . . . . . . . . . . . . . . 31
   9.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 32
   10. Security Considerations  . . . . . . . . . . . . . . . . . . . 32
   11. Related Work . . . . . . . . . . . . . . . . . . . . . . . . . 32
   12. SEAL Advantages over Classical Methods . . . . . . . . . . . . 33
   13. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 34
   14. References . . . . . . . . . . . . . . . . . . . . . . . . . . 34
     14.1. Normative References . . . . . . . . . . . . . . . . . . . 34
     14.2. Informative References . . . . . . . . . . . . . . . . . . 35
   Appendix A.  Reliability . . . . . . . . . . . . . . . . . . . . . 37
   Appendix B.  Transport Mode  . . . . . . . . . . . . . . . . . . . 37
   Appendix C.  Historic Evolution of PMTUD . . . . . . . . . . . . . 38
   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 39































Templin                 Expires December 19, 2009               [Page 3]

Internet-Draft                    SEAL                         June 2009


1.  Introduction

   As Internet technology and communication has grown and matured, many
   techniques have developed that use virtual topologies (including
   tunnels of one form or another) over an actual network that supports
   the Internet Protocol (IP) [RFC0791][RFC2460].  Those virtual
   topologies have elements that appear as one hop in the virtual
   topology, but are actually multiple IP or sub-IP layer hops.  These
   multiple hops often have quite diverse properties that are often not
   even visible to the endpoints of the virtual hop.  This introduces
   failure modes that are not dealt with well in current approaches.

   The use of IP encapsulation has long been considered as the means for
   creating such virtual topologies.  However, the insertion of an outer
   IP header reduces the effective path MTU as-seen by the IP layer.
   When IPv4 is used, this reduced MTU can be accommodated through the
   use of IPv4 fragmentation, but unmitigated in-the-network
   fragmentation has been found to be harmful through operational
   experience and studies conducted over the course of many years
   [FRAG][FOLK][RFC4963].  Additionally, classical path MTU discovery
   [RFC1191] has known operational issues that are exacerbated by in-
   the-network tunnels [RFC2923][RFC4459].  The following subsections
   present further details on the motivation and approach for addressing
   these issues.

1.1.  Motivation

   Before discussing the approach, it is necessary to first understand
   the problems.  In both the Internet and private-use networks today,
   IPv4 is ubiquitously deployed as the Layer 3 protocol.  The two
   primary functions of IPv4 are to provide for 1) addressing, and 2) a
   fragmentation and reassembly capability used to accommodate links
   with diverse MTUs.  While it is well known that the addressing
   properties of IPv4 are limited (hence, the larger address space
   provided by IPv6), there is a lesser-known but growing consensus that
   other limitations may be unable to sustain continued growth.

   First, the IPv4 header Identification field is only 16 bits in
   length, meaning that at most 2^16 packets pertaining to the same
   (source, destination, protocol, Identification)-tuple may be active
   in the Internet at a given time.  Due to the escalating deployment of
   high-speed links (e.g., 1Gbps Ethernet), however, this number may
   soon become too small by several orders of magnitude.  Furthermore,
   there are many well-known limitations pertaining to IPv4
   fragmentation and reassembly - even to the point that it has been
   deemed "harmful" in both classic and modern-day studies (cited
   above).  In particular, IPv4 fragmentation raises issues ranging from
   minor annoyances (e.g., in-the-network router fragmentation) to the



Templin                 Expires December 19, 2009               [Page 4]

Internet-Draft                    SEAL                         June 2009


   potential for major integrity issues (e.g., mis-association of the
   fragments of multiple IP packets during reassembly).

   As a result of these perceived limitations, a fragmentation-avoiding
   technique for discovering the MTU of the forward path from a source
   to a destination node was devised through the deliberations of the
   Path MTU Discovery Working Group (PMTUDWG) during the late 1980's
   through early 1990's (see Appendix C).  In this method, the source
   node provides explicit instructions to routers in the path to discard
   the packet and return an ICMP error message if an MTU restriction is
   encountered.  However, this approach has several serious shortcomings
   that lead to an overall "brittleness".

   In particular, site border routers in the Internet are being
   configured more and more to discard ICMP error messages coming from
   the outside world.  This is due in large part to the fact that
   malicious spoofing of error messages in the Internet is made simple
   since there is no way to authenticate the source of the messages.
   Furthermore, when a source node that requires ICMP error message
   feedback when a packet is dropped due to an MTU restriction does not
   receive the messages, a path MTU-related black hole occurs.  This
   means that the source will continue to send packets that are too
   large and never receive an indication from the network that they are
   being discarded.

   The issues with both IPv4 fragmentation and this "classical" method
   of path MTU discovery are exacerbated further when IP-in-IP tunneling
   is used.  For example, site border routers that are configured as
   ingress tunnel endpoints may be required to forward packets into the
   subnetwork on behalf of hundreds, thousands, or even more original
   sources located within the site.  If IPv4 fragmentation were used,
   this would quickly wrap the 16-bit Identification field and could
   lead to undetected data corruption.  If classical IPv4 path MTU
   discovery were used instead, the site border router may be
   inconvenienced by excessive ICMP error messages coming from the
   subnetwork that may be either untrustworthy or insufficiently
   provisioned to allow translation into error messages to be returned
   to the original sources.

   The situation is exacerbated further still by IPsec tunnels, since
   only the first IPv4 fragment of a fragmented packet contains the
   transport protocol selectors (e.g., the source and destination ports)
   required for identifying the correct security association rendering
   fragmentation useless under certain circumstances.  Even worse, there
   may be no way for a site border router that configures an IPsec
   tunnel to transcribe the encrypted packet fragment contained in an
   ICMP error message into a suitable ICMP error message to return to
   the original source.



Templin                 Expires December 19, 2009               [Page 5]

Internet-Draft                    SEAL                         June 2009


   Due to these many limitations, a new approach to accommodate links
   with diverse MTUs is necessary.

1.2.  Approach

   For the purpose of this document, subnetworks are defined as virtual
   topologies that span connected network regions bounded by
   encapsulating border nodes.  Subnetworks in this sense correspond
   exactly to the "enterprise" abstraction defined in Virtual Enterprise
   Traversal (VET) [I-D.templin-autoconf-dhcp] and Routing and
   Addressing in Next-Generation EnteRprises (RANGER)
   [I-D.templin-ranger][I-D.russert-rangers].  Examples include the
   global Internet interdomain routing core, Mobile Ad hoc Networks
   (MANETs) and enterprise networks.  Subnetwork border nodes forward
   unicast and multicast IP packets over the virtual topology across
   multiple IP and/or sub-IP layer forwarding hops that may introduce
   packet duplication and/or traverse links with diverse Maximum
   Transmission Units (MTUs).

   This document introduces a Subnetwork Encapsulation and Adaptation
   Layer (SEAL) for tunnel-mode operation of IP over subnetworks that
   connect Ingress and Egress Tunnel Endpoints (ITEs/ETEs) of border
   nodes.  It provides a standalone specification designed to be
   tailored to specific associated tunneling protocols such as VET
   [I-D.templin-autoconf-dhcp], the Locator-Identifier Split Protocol
   (LISP) [I-D.ietf-lisp] and others.  A transport-mode of operation is
   also possible, and described in Appendix B.  SEAL accommodates links
   with diverse MTUs, protects against off-path denial-of-service
   attacks, and supports efficient duplicate packet detection through
   the use of a minimal mid-layer encapsulation.

   SEAL encapsulation introduces an extended Identification field for
   packet identification and a mid-layer segmentation and reassembly
   capability that allows simplified cutting and pasting of packets.
   Moreover, SEAL senses in-the-network IPv4 fragmentation as a "noise"
   indication that packet sizing parameters are "out of tune" with
   respect to the network path.  As a result, SEAL can naturally tune
   its packet sizing parameters to eliminate the in-the-network
   fragmentation.

   SEAL encapsulation additionally includes a 2-bit version number.
   This document specifies SEAL protocol versions 0 and 1.


2.  Terminology and Requirements

   The terms "inner", "mid-layer", and "outer", respectively, refer to
   the innermost IP (layer, protocol, header, packet, etc.) before any



Templin                 Expires December 19, 2009               [Page 6]

Internet-Draft                    SEAL                         June 2009


   encapsulation, the mid-layer IP (protocol, header, packet, etc.)
   after any mid-layer '*' encapsulation, and the outermost IP (layer,
   protocol, header, packet etc.) after SEAL/*/IPv4 encapsulation.

   The term "IP" used throughout the document refers to either Internet
   Protocol version (IPv4 or IPv6).  Additionally, the notation IPvX/*/
   SEAL/*/IPvY refers to an inner IPvX packet encapsulated in any mid-
   layer '*' encapsulations, followed by the SEAL header, followed by
   any outer '*' encapsulations, followed by an outer IPvY header, where
   the notation "IPvX" means either IP protocol version (IPv4 or IPv6).

   The following abbreviations correspond to terms used within this
   document and elsewhere in common Internetworking nomenclature:

      ITE - Ingress Tunnel Endpoint

      ETE - Egress Tunnel Endpoint

      PTB - an ICMPv6 "Packet Too Big", an ICMPv4 "Fragmentation Needed"
      or a SEAL Reassembly Report message.

      DF - the IPv4 header "Don't Fragment" flag

      MHLEN - the length of any mid-layer '*' headers and trailers

      OHLEN - the length of the outer encapsulating SEAL/*/IPv4 headers

      HLEN - the sum of MHLEN and OHLEN

      S_MRU - the SEAL Maximum Reassembly Unit

      S_MSS - the SEAL Maximum Segment Size

      S_CSS - the SEAL Clamped Segment Size

      SEAL_ID - a 32-bit Identification value, randomly initialized and
      monotonically incremented for each SEAL protocol packet

      SEAL_PROTO - an IPv4 protocol number used for SEAL

      SEAL_CPORT - a TCP/UDP service port number used for SEAL control
      plane messaging

      SEAL_DPORT - a TCP/UDP service port number used for SEAL data
      plane messaging

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this



Templin                 Expires December 19, 2009               [Page 7]

Internet-Draft                    SEAL                         June 2009


   document, are to be interpreted as described in [RFC2119].


3.  Applicability Statement

   SEAL was motivated by the specific case of subnetwork abstraction for
   Mobile Ad hoc Networks (MANETs); however, the domain of applicability
   also extends to subnetwork abstractions of enterprise networks, ISP
   networks, SOHO networks, the interdomain routing core, and many
   others.  In particular, SEAL is a natural complement to the
   enterprise network abstraction manifested through the VET mechanism
   [I-D.templin-autoconf-dhcp], the RANGER architecture
   [I-D.templin-ranger][I-D.russert-rangers] and the LISP protocol
   [I-D.ietf-lisp].  The term "subnetwork" within this document is used
   synonymously with the term "enterprise" that appears in these
   references.

   SEAL introduces a minimal new sublayer for IPvX in IPvY encapsulation
   (e.g., as IPv6/SEAL/IPv4), and appears as a subnetwork encapsulation
   as seen by the inner IP layer.  SEAL can also be used as a sublayer
   for encapsulating inner IP packets within outer UDP/IPv4 headers
   (e.g., as IPv6/SEAL/UDP/IPv4) such as for the Teredo domain of
   applicability [RFC4380].  When it appears immediately after the outer
   IPv4 header, the SEAL header is processed exactly as for IPv6
   extension headers.

   This document discusses the use of IPv4 as the outer encapsulation
   layer; however, the same principles apply when IPv6 is used as the
   outer layer.


4.  SEAL Protocol Specification (Version 0)

   This section specifies the fully-functioned version of SEAL known as
   "SEAL Version 0", or "SEAL-MAX".  A minimal version of SEAL known as
   "SEAL Version 1", or "SEAL-LITE", is specified in Section 5.

4.1.  Model of Operation

   SEAL provides an encapsulation sublayer that supports the
   transmission of unicast and multicast packets across an underlying IP
   network.  SEAL-enabled ITEs insert a SEAL header during the
   encapsulation of inner IP packets in mid-layer and outer
   encapsulating headers/trailers.  For example, an inner IPv6 packet
   would appear as IPv6/*/SEAL/*/IPv4 after mid-layer and outer
   encapsulations, where '*' denotes zero or more additional
   encapsulation sublayers.




Templin                 Expires December 19, 2009               [Page 8]

Internet-Draft                    SEAL                         June 2009


   SEAL-enabled ITEs add mid-layer '*' and outer SEAL/*/IPv4
   encapsulations to the inner packets they inject into a subnetwork,
   where the outermost IPv4 header contains the source and destination
   addresses of the subnetwork entry/exit points (i.e., the ITE/ETE),
   respectively.  ITEs encapsulate each inner IP packet in mid-layer and
   outer encapsulations as shown in Figure 1:

                                            +-------------------------+
                                            |                         |
                                            ~   Outer */IPv4 headers  ~
                                            |                         |
   I                                        +-------------------------+
   n                                        |       SEAL Header       |
   n      +-------------------------+       +-------------------------+
   e      ~ Any mid-layer * headers ~       ~ Any mid-layer * headers ~
   r      +-------------------------+       +-------------------------+
          |                         |       |                         |
   I -->  ~         Inner IP        ~  -->  ~         Inner IP        ~
   P -->  ~         Packet          ~  -->  ~         Packet          ~
          |                         |       |                         |
   P      +-------------------------+       +-------------------------+
   a      ~  Any mid-layer trailers ~       ~  Any mid-layer trailers ~
   c      +-------------------------+       +-------------------------+
   k                                        ~    Any outer trailers   ~
   e                                        +-------------------------+
   t
           (After mid-layer encaps.)        (After SEAL/*/IPv4 encaps.)

                       Figure 1: SEAL Encapsulation

   where the SEAL header is inserted as follows:

   o  For simple IPvX/IPvY encapsulations (e.g.,
      [RFC2003][RFC2004][RFC2473][RFC4213]), the SEAL header is inserted
      between the inner and outer IP headers as: IPvX/SEAL/IPvY.

   o  For tunnel-mode IPsec encapsulations, [RFC4301], the SEAL header
      is inserted between the {AH,ESP} header and outer IP headers as:
      IPvX/*/{AH,ESP}/SEAL/IPvY.

   o  For IP encapsulations over transports such as UDP, the SEAL header
      is inserted immediately after the outer transport layer header,
      e.g., as IPvX/*/SEAL/UDP/IPvY.

   SEAL-encapsulated packets include a SEAL_ID to uniquely identify each
   packet.  Routers within the subnetwork use the SEAL_ID for duplicate
   packet detection, and ITEs/ETEs use the SEAL_ID for SEAL
   segmentation/reassembly and protection against off-path attacks.



Templin                 Expires December 19, 2009               [Page 9]

Internet-Draft                    SEAL                         June 2009


   For IPv4, the SEAL_ID is formed from the concatenation of the 16-bit
   ID Extension field in the SEAL header as the most-significant bits,
   and with the 16-bit Identification value in the outer IPv4 header as
   the least-significant bits.  For IPv6, the SEAL_ID is written into
   the 32-bit Identification field of the fragment header.  For tunnels
   that traverse middleboxes that might rewrite the IP ID field, e.g., a
   Network Address Translator, the SEAL_ID is instead maintained only
   within the ID field in the SEAL header.

   SEAL enables a multi-level segmentation and reassembly capability.
   First, the ITE can use IPv4 fragmentation to fragment inner IPv4
   packets before SEAL encapsulation.  Secondly, the SEAL layer itself
   provides a simple cutting-and-pasting capability for mid-layer
   packets to avoid IP fragmentation on the outer packet.  Finally,
   ordinary IP fragmentation is permitted on the outer packet after SEAL
   encapsulation and used to detect and dampen any in-the-network
   fragmentation as quickly as possible.

   The following sections specify the SEAL header format and SEAL-
   related operations of the ITE and ETE, respectively.

4.2.  SEAL Header Format (Version 0)

   The SEAL version 0 header is formatted as follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |VER|A|I|F|M|RSV|  NEXTHDR/SEG  |         ID Extension          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                  Figure 2: SEAL Version 0 Header Format

   where the header fields are defined as:

   VER (2)
      a 2-bit value that encodes the SEAL protocol version number.  This
      section describes Version 0 of the SEAL protocol, i.e., the VER
      field encodes the value '00'.

   A (1)
      the "Acknowledgement Requested" bit.  Set to 1 if the ITE wishes
      to receive an explicit acknowledgement from the ETE.

   I (1)
      the "Information Request Solicit" bit.  Set to 1 if the ITE wishes
      the ETE to initiate an Information Request.




Templin                 Expires December 19, 2009              [Page 10]

Internet-Draft                    SEAL                         June 2009


   F (1)
      the "First Segment" bit.  Set to 1 if this SEAL protocol packet
      contains the first segment (i.e., Segment #0) of a mid-layer
      packet.

   M (1)
      the "More Segments" bit.  Set to 1 if this SEAL protocol packet
      contains a non-final segment of a multi-segment mid-layer packet.

   RSV (2)
      a 2-bit Reserved field.  Set to 0 for the purpose of this
      specification.

   NEXTHDR/SEG (8)  an 8-bit field.  When 'F'=1, encodes the next header
      Internet Protocol number the same as for the IPv4 protocol and
      IPv6 next header fields.  When 'F'=0, encodes a segment number of
      a multi-segment mid-layer packet.  (The segment number 0 is
      reserved.)

   ID Extension (16)
      a 16-bit Identification extension field.

4.3.  ITE Specification

4.3.1.  Tunnel Interface MTU

   The ITE configures a tunnel virtual interface over one or more
   underlying links that connect the border node to the subnetwork.  The
   tunnel interface must present a fixed MTU to the inner IP layer
   (i.e., Layer 3) as the size for admission of inner IP packets into
   the tunnel.  Since the tunnel interface may support a potentially
   large set of ETEs, however, care must be taken in setting a large-
   enough MTU for all ETEs while still upholding end system
   expectations.

   Due to the ubiquitous deployment of standard Ethernet and similar
   networking gear, the nominal Internet cell size has become 1500
   bytes; this is the de facto size that end systems have come to expect
   will either be delivered by the network without loss due to an MTU
   restriction on the path or a suitable PTB message returned.  However,
   the network may not always deliver the necessary PTBs, leading to
   MTU-related black holes [RFC2923].  The ITE therefore requires a
   means for conveying 1500 byte (or smaller) packets to the ETE without
   loss due to MTU restrictions and without dependence on PTB messages
   from within the subnetwork.

   In common deployments, there may be many forwarding hops between the
   original source and the ITE.  Within those hops, there may be



Templin                 Expires December 19, 2009              [Page 11]

Internet-Draft                    SEAL                         June 2009


   additional encapsulations (IPSec, L2TP, other SEAL encapsulations,
   etc.) such that a 1500 byte packet sent by the original source might
   grow to a larger size by the time it reaches the ITE for
   encapsulation as an inner IP packet.  Similarly, additional
   encapsulations on the path from the ITE to the ETE could cause the
   encapsulated packet to become larger still and trigger in-the-network
   fragmentation.  In order to preserve the end system expectations, the
   ITE therefore requires a means for conveying these larger packets to
   the ETE even though there may be links within the subnetwork that
   configure a smaller MTU.

   The ITE should therefore set a tunnel virtual interface MTU of 1500
   bytes plus extra room to accommodate any additional encapsulations
   that may occur on the path from the original source (i.e., even if
   the path to the ETE does not support an MTU of this size).  The ITE
   can set larger MTU values still, but should select a value that is
   not so large as to cause excessive PTBs coming from within the tunnel
   interface (see Sections 4.3.3 and 4.3.8).  The ITE can also set
   smaller MTU values; however, care must be taken not to set so small a
   value that original sources would experience an MTU underflow.  In
   particular, IPv6 sources must see a minimum path MTU of 1280 bytes,
   and IPv4 sources should see a minimum path MTU of 576 bytes.

   The ITE can alternatively set an indefinite MTU on the tunnel virtual
   interface such that all inner IP packets are admitted into the
   interface without regard to size.  This option must be carefully
   coordinated with the ITE's protocol stack upper layers, since some
   upper layer protocols (e.g., TCP) derive their packet sizing
   parameters from the MTU of the underlying interface and as such may
   select too large an initial size.  This is not a problem for upper
   layers that use conservative initial estimates, e.g., when mechanisms
   such as Packetization Layer Path MTU Discovery [RFC4821] are used.

4.3.2.  Admitting Packets into the Tunnel Interface

   The inner IP layer consults the tunnel interface MTU when admitting a
   packet into the interface.  For IPv4 packets with the IPv4 Don't
   Fragment (DF) bit set to 0, if the packet is larger than the tunnel
   interface MTU the inner IP layer uses IP fragmentation to break the
   packet into fragments no larger than the tunnel interface MTU.  The
   ITE then admits each fragment into the tunnel as an independent
   packet.

   For all other packets, the ITE admits the packet if it is no larger
   than the tunnel interface MTU; otherwise, it drops the packet and
   sends an ICMP PTB error message to the source with the MTU value set
   to the tunnel interface MTU.  The message must contain as much of the
   invoking packet as possible without the entire message exceeding the



Templin                 Expires December 19, 2009              [Page 12]

Internet-Draft                    SEAL                         June 2009


   minimum IP MTU (i.e., 576 bytes for IPv4 and 1280 bytes for IPv6).

   Note that when the tunnel interface sets an indefinite MTU all
   packets are unconditionally admitted into the interface without
   fragmentation.

4.3.3.  Segmentation

   For each ETE, the ITE maintains soft state within the tunnel
   interface (e.g., in a destination cache) used to support inner
   fragmentation and SEAL segmentation.  The soft state includes the
   following:

   o  a Mid-layer Header Length (MHLEN); set to the length of any mid-
      layer '*' encapsulation headers and trailers (e.g., for '*' = AH,
      ESP, NULL, etc.).  MHLEN additionally includes 4 extra bytes for a
      trailing mid-layer checksum (see below).

   o  an Outer Header Length (OHLEN); set to the length of the outer
      SEAL/*/IP encapsulation headers and trailers.

   o  a total Header Length (HLEN); set to MHLEN plus OHLEN.

   o  a SEAL Maximum Segment Size (S_MSS); initialized to a value that
      is no larger than the underlying IP interface MTU.  The ITE
      decreases or increases S_MSS based on any SEAL Reassembly Report
      messages received (see Section 4.3.9).

   o  a SEAL Clamped Segment Size (S_CSS); a value that is no larger
      than S_MSS and that would also be unlikely to incur fragmentation
      beyond the tunnel, (e.g., 576 bytes for IPv4 and 1280 bytes for
      IPv6).  May be set to larger values only if there is high
      assurance that all links within the tunnel configure a larger MTU.
      The ITE decreases S_CSS in conjunction with S_MSS, but only
      increases S_CSS to a "safe" value as above if S_MSS is increased.

   o  a SEAL Maximum Reassembly Unit (S_MRU); initialized to the larger
      of S_MSS and the known or estimated Maximum Receive Unit (MRU)
      actually configured by the ETE (2KB minimum default).  The ITE
      decreases or increases S_MRU based on any SEAL Reassembly Report
      messages received (see Section 4.3.9).  When (S_MRU>(S_MSS*256)),
      the ITE uses (S_MSS*256) as the effective S_MRU value.

   After an inner packet/fragment has been admitted into the tunnel
   interface the ITE uses the following algorithm to determine whether
   the packet can be accommodated at all and (if so) whether inner IP
   fragmentation is needed:




Templin                 Expires December 19, 2009              [Page 13]

Internet-Draft                    SEAL                         June 2009


   o  if the inner packet is an IPv6 packet or an IPv4 packet with DF=1,
      and the packet is larger than (S_MRU - HLEN), the ITE drops the
      packet and sends an ICMP PTB message to the original source with
      an MTU value of (S_MRU - HLEN) the same as described in Section
      4.3.2; else,

   o  if the inner packet is a SEAL IPv4 packet with DF=0, and the
      packet is larger than (S_MRU - HLEN), the ITE uses inner IPv4
      fragmentation to break the packet into fragments no larger than
      (S_MRU - HLEN); else,

   o  if the inner packet is a non-SEAL IPv4 packet with DF=0, the ITE
      uses inner IPv4 fragmentation to break the packet into fragments
      no larger than (S_CSS - HLEN); else,

   o  the ITE processes the packet without inner fragmentation.

   (Note that in the above the ITE must also track whether the tunnel
   interface is using header compression on the inner */IP headers.  If
   so, the ITE must include the length of the uncompressed */IP inner
   header when calculating the total length of the inner packet.)

   The ITE next encapsulates each inner packet/fragment in the MHLEN
   bytes of mid-layer '*' headers and trailers and reserves 4 bytes for
   a trailing checksum at the end of the mid-layer trailers.  The ITE
   then calculates a checksum of the mid-layer packet using the 16-bit
   Fletcher Checksum algorithm specified in [RFC1146], Appendix II, and
   writes the 'A' portion as the most significant 16 bits and the 'B'
   portion as the least significant 16 bits.

   If the length of the resulting mid-layer packet plus OHLEN is greater
   than S_MSS, the ITE must additionally perform SEAL segmentation.  To
   do so, it breaks the mid-layer packet into N segments (N <= 256) that
   are no larger than (S_MSS - OHLEN) bytes each.  Each segment, except
   the final one, MUST be of equal length.  The first byte of each
   segment MUST begin immediately after the final byte of the previous
   segment, i.e., the segments MUST NOT overlap.  The ITE SHOULD
   generate the smallest number of segments possible, e.g., it SHOULD
   NOT generate 6 smaller segments when the packet could be accommodated
   with 4 larger segments.

   Note that this SEAL segmentation ignores the fact that the mid-layer
   packet may be unfragmentable outside of the subnetwork.  This
   segmentation process is a mid-layer (not an IP layer) operation
   employed by the ITE to adapt the mid-layer packet to the subnetwork
   path characteristics, and the ETE will restore the packet to its
   original form during reassembly.  Therefore, the fact that the packet
   may have been segmented within the subnetwork is not observable



Templin                 Expires December 19, 2009              [Page 14]

Internet-Draft                    SEAL                         June 2009


   outside of the subnetwork.

4.3.4.  Encapsulation

   Following SEAL segmentation, the ITE encapsulates each segment in a
   SEAL header formatted as specified in Section 4.3.2 with VER='00' and
   RSV='00'.  For the first segment, the ITE sets F=1 and sets NEXTHDR
   to the Internet Protocol number of the encapsulated packet; the ITE
   next sets M=1 if there are more segments or sets M=0 otherwise.  For
   each non-initial segment of an N-segment mid-layer packet (N <= 256),
   the ITE sets (F=0; M=1; SEG=1) in the SEAL header of the first non-
   initial segment, sets (F=0; M=1; SEG=2) in the next non-initial
   segment, etc., and sets (F=0; M=0; SEG=N-1) in the final segment.
   (Note that the value SEG=0 is not used.)

   The ITE next encapsulates each segment in the requisite */IP outer
   headers according to the specific encapsulation format (e.g.,
   [RFC2003], [RFC2473], [RFC4213], [RFC4380], etc.), except that it
   writes 'SEAL_PROTO' in the protocol field of the outer IP header
   (when simple IP encapsulation is used) or writes 'SEAL_DPORT' in the
   outer destination service port field (e.g., when UDP/IP encapsulation
   is used).  The ITE finally sets the A bit as specified in Section
   4.3.5 (if necessary), sets the packet identification values as
   specified in Section 4.3.6 and sends the packets as specified in
   Section 4.3.7.

   Note that when IPv6 is used as the outer IP encapsulation layer, the
   ITE must insert an IPv6 fragment header with an Identification value
   set as described in Section 4.3.6.

4.3.5.  Probing Strategy

   All SEAL packets sent by the ITE are considered implicit probes, and
   will elicit Reassembly Reports from the ETE with a new value for
   S_MSS if any IP fragmentation occurs in the path.  Thereafter, the
   ITE may periodically reset S_MSS to a larger value (e.g., the
   underlying IP interface MTU minus OHLEN bytes) to detect path MTU
   increases.

   The ITE should additionally send explicit probes, periodically, to
   verify that the ETE is still reachable and to manage a window of
   SEAL_IDs.  The ITE sets (A=1; F=1) in the SEAL header of a first-
   segment to be used as an explicit probe, where the probe can be
   either an ordinary data packet or a NULL packet created by setting
   the 'Next Header' field to a value of "No Next Header" (see Section
   4.7 of [RFC2460]).  The probe will elicit a Reassembly Report from
   the ETE as an acknowledgement.




Templin                 Expires December 19, 2009              [Page 15]

Internet-Draft                    SEAL                         June 2009


   The ITE can also send probes using non-initial SEAL segments to
   determine whether any of the preceding segments of the same SEAL
   packet are missing.  The probe will elicit a Reassembly Report from
   the ETE with a Bitmap of received and missing segments.

   Finally, the ITE MAY send "expendable" probe packets (see Section
   4.3.7) in order to generate ICMP PTB messages from routers on the
   path to the ETE.

4.3.6.  Packet Identification

   For the purpose of packet identification, the ITE maintains a SEAL_ID
   value as per-ETE soft state, e.g., in the destination cache.  The ITE
   randomly initializes SEAL_ID when the soft state is created, and
   monotonically increments it for each successive SEAL protocol packet
   it sends to the ETE.

   For each outer IPv4 packet, the ITE writes the least-significant 16
   bits of the SEAL_ID value into the Identification field in the outer
   IPv4 header, and writes the most-significant 16 bits in the ID
   Extension field in the SEAL header.  For each outer IPv6 packet, the
   ITE writes the entire SEAL_ID value into the Identification field in
   the IPv6 fragment header.

   For ITE->ETR tunnels specifically designed for the traversal of
   Network Address Translators (NATs) and other middleboxes that may
   rewrite the outer IP ID field, the ITE instead writes least
   significant bits of the SEAL_ID in the ID field of the SEAL header
   and writes a random value in the Identification field in the outer IP
   header.  Since the ID field in the SEAL header is only 16 bits,
   however, the ITE must limit the rate at which it sends packets to
   avoid wrapping the ID field.  Alternatively, the ITE and ETE can use
   SEAL-LITE to obtain a larger ID field in the SEAL header (see Section
   5.3.6).

4.3.7.  Sending SEAL Protocol Packets

   Following SEAL segmentation and encapsulation, the ITE sets DF=0 for
   ordinary SEAL/*/IPv4 packets, but may set DF=1 for "expendable" SEAL/
   */IPv4 packets (e.g., for NULL packets used as probes -- see Section
   4.3.5).  For SEAL/*/IPv6 packets, the "DF" bit is always implicitly
   set to 1, but when a fragment header is included a translating router
   on the path may still fragment the packet.

   The ITE sends each outer packet that encapsulates a segment of the
   same mid-layer packet into the tunnel in canonical order, i.e.,
   segment 0 first, followed by segment 1, etc., and finally segment
   N-1.



Templin                 Expires December 19, 2009              [Page 16]

Internet-Draft                    SEAL                         June 2009


4.3.8.  Processing Raw ICMP Messages

   The ITE may receive "raw" ICMP error messages [RFC0792][RFC4443] from
   either the ETE or routers within the subnetwork that comprise an
   outer IP header, followed by an ICMP header, followed by a portion of
   the SEAL packet that generated the error (also known as the "packet-
   in-error").  The ITE can use the SEAL ID encoded in the packet-in-
   error as a nonce to confirm that the ICMP message came from either
   the ETE or an on-path router, and can use any additional information
   to determine whether to accept or discard the message.

   The ITE should specifically process raw ICMPv4 Protocol Unreachable
   messages and ICMPv6 Parameter Problem messages with Code
   "Unrecognized Next Header type encountered" as a hint that the ETE
   does not implement the SEAL protocol.

4.3.9.  Processing SEAL Control Messages

   In addition to any raw ICMP messages, the ITE may receive UDP/IP SEAL
   control messages from the ETE formatted as specified in Section 4.4.5
   and with 'SEAL_CPORT' as the UDP destination port.  The ITE must
   therefore monitor the 'SEAL_CPORT' UDP port and process any messages
   that arrive on that port.

   For each control message, the ITE verifies the UDP checksum and
   discards the message if the checksum is incorrect.  The ITE can then
   verify that the SEAL_ID is within the current window of transmitted
   SEAL_IDs for this ETE.  If the SEAL_ID is outside of the window, the
   ITE discards the message; otherwise, it advances the window and
   processes the message.  The ITE processes SEAL control messages as
   follows:

4.3.9.1.  Reassembly Report (Type=0)

   When the ITE receives a Reassembly Report formatted as specified in
   Section 4.4.5.1, it processes the message according to the Code value
   as follows:

4.3.9.1.1.  IP Fragmentation Experienced (Code=0)

   The ITE records the value in the S_MRU field in its soft state for
   this ETE and adjusts the S_MSS value in its soft state.  If the S_MSS
   value in the Reassembly Report is greater than 576 (i.e., the nominal
   minimum MTU for IPv4 links), the ITE records this new value in its
   soft state.  If the S_MSS value in the report is less than the
   current soft state value and also less than 576, the can discern that
   IP fragmentation is occurring but it cannot determine the true MTU of
   the restricting link due to a router on the path generating runt



Templin                 Expires December 19, 2009              [Page 17]

Internet-Draft                    SEAL                         June 2009


   first-fragments.

   The ITE should therefore search for a reduced S_MSS value through an
   iterative searching strategy that parallels (Section 5 of [RFC1191]).
   This searching strategy may require multiple iterations of sending
   SEAL packets using a reduced S_MSS and receiving additional
   Reassembly Report messages, but it will soon converge to a stable
   value.  During this process, it is essential that the ITE reduce
   S_MSS based on the first Reassembly Report message received, and
   refrain from further reducing S_MSS until SEAL Reassembly Report
   messages pertaining to packets sent under the new S_MSS are received.

4.3.9.1.2.  Segment Acknowledged (Code=1)

   The ITE records the value in the S_MRU field in its soft state for
   this ETE.  If the S_MSS value in the report is non-zero, the ITE also
   adjusts its S_MSS value the same as for an IP Fragmentation
   Experienced message (see Section 4.3.9.1.1).

   The ITE next examines the Bitmap field to determine which segments of
   this SEAL packet were received.  The map is arranged with segment 0
   represented as the most significant bit, segment 1 represented as the
   next most significant bit, etc., up to the segment that triggered the
   reassembly report (i.e., segment N) as the final bit.  For example,
   when N=6 the bit map '0110011' means that segments 1, 2, 5 and 6 were
   received but segments 0, 3 and 4 were missing from the ETE's
   reassembly buffer.  The ITE can then retransmit segments 0, 3 and 4
   if it still has them in its cache, and if there is reason to believe
   the retransmissions may satisfy the pending reassembly.

4.3.9.1.3.  Packet Too Big (Code=2)

   The ITE records the value in the S_MRU field in its soft state for
   this ETE.

4.3.9.1.4.  Time Exceeded (Code=3)

   The ITE examines the time encoded in the Data field, and reduces its
   S_MRU estimate for this ETE if it there is significant evidence that
   large packets are timing out prior to SEAL reassembly completion.
   The ITE may log the event for network management purposes.

4.3.9.1.5.  Checksum Incorrect (Code=4)

   The ITE may log the event for network management purposes.  When
   sustained Checksum Incorrect messages are received from this ETE, the
   ITE may also benefit by adjusting its packet sizing parameters.




Templin                 Expires December 19, 2009              [Page 18]

Internet-Draft                    SEAL                         June 2009


4.3.9.2.  Parameter Problem (Type=1)

   When the ITE receives a Parameter Problem message formatted as
   specified in Section 4.4.5.2, it examines the encapsulated SEAL
   header in the message to determine whether the header was corrupted
   or whether the header specified features that the ETE did not
   recognize.  The ITE MAY log the event for network management
   purposes.  For uncorrupted headers, the SHOULD adjust its SEAL header
   parameters in subsequent SEAL packets.

4.3.9.3.  Information Request (Type=2)

   When the ITE receives an Information Request message formatted as
   specified in Section 4.4.5.5 and with a SEAL_ID that corresponds to a
   SEAL packet that it sent earlier with I=1, it sends an Information
   Reply as specified in Section 4.4.5.6.

4.4.  ETE Specification

4.4.1.  Reassembly Buffer Requirements

   ETEs must be capable of performing IP-layer reassembly for SEAL
   protocol IP packets up to 2KB in length, and must also be capable of
   performing SEAL-layer reassembly for mid-layer packets up to (2KB -
   OHLEN).  Hence, ETEs:

   o  MUST configure a reassembly buffer of at least 2KB

   o  MAY configure a larger reassembly buffer

   o  MUST be capable of discarding SEAL packets that are too large to
      reassemble

   Note that the ETE must retain the SEAL/*/IP header during both IP-
   layer and SEAL-layer reassembly for the purpose of associating the
   fragments/segments of the same packet.

4.4.2.  IP-Layer Reassembly

   ETEs perform standard IP-layer reassembly for SEAL protocol IP
   fragments, and should maintain a conservative reassembly cache high-
   and low-water mark .  When the size of the reassembly cache exceeds
   this high-water mark, the ETE should actively discard incomplete
   reassemblies (e.g., using an Active Queue Management (AQM) strategy)
   until the size falls below the low-water mark.  The ETE should also
   actively discard any pending reassemblies that clearly have no
   opportunity for completion, e.g., when a considerable number of new
   fragments have been received before a fragment that completes a



Templin                 Expires December 19, 2009              [Page 19]

Internet-Draft                    SEAL                         June 2009


   pending reassembly has arrived.

   When the ETE processes the IP first-fragment (i.e, one with MF=1 and
   Offset=0 in the IP header) of a fragmented SEAL packet, it sends a
   SEAL Reassembly Report message back to the ITE with the S_MSS field
   set to the length of the first-fragment and with the S_MRU field set
   to the size of the ETE's reassembly buffer (see Section 4.4.5).

4.4.3.  SEAL-Layer Reassembly

   Following IP reassembly of a SEAL segment, the ETE adds the segment
   to a SEAL-Layer pending-reassembly queue according to the (Source,
   Destination, SEAL_ID)-tuple found in the outer SEAL/*/IP headers.
   The ETE performs SEAL-layer reassembly through simple in-order
   concatenation of the encapsulated segments of the same mid-layer
   packet from N consecutive SEAL packets.  SEAL-layer reassembly
   requires the ETE to maintain a cache of recently received segments
   for a hold time that would allow for reasonable inter-segment delays
   (e.g., 15 seconds).  When a SEAL reassembly times out, the ETE
   discards the incomplete reassembly and returns a Reassembly Report -
   Time Exceeded message to the ITE (see Section 4.4.5).  As for IP-
   layer reassembly, the ETE should also maintain a conservative
   reassembly cache high- and low-water mark and should actively discard
   any pending reassemblies that clearly have no opportunity for
   completion, e.g., when a considerable number of new SEAL packets have
   been received before a packet that completes a pending reassembly has
   arrived.

   When the ETE receives a SEAL packet with an incorrect value in the
   SEAL header, it discards the packet and returns a Parameter Problem
   message (see Section 4.4.5).  If the ETE receives a SEAL packet for
   which a segment with the same (Source, Destination, SEAL_ID)-tuple is
   already in the queue, it must determine whether to accept the new
   segment and release the old, or drop the new segment.  If accepting
   the new segment would cause an inconsistency with other segments
   already in the queue (e.g., differing segment lengths), the ETE drops
   the segment that is least likely to complete the reassembly.

   When the ETE adds a SEAL packet with A=1 and with SEG=N to a
   reassembly queue, it sends a Reassembly Report - Segment Acknowledged
   message back to the ITE as specified in Section 4.4.6 that contains a
   bitmask of this and all prior segments already in the queue beginning
   with segment 0 in the most-significant bit, segment 1 in the next
   bit, etc.,up to segment N in the final bit.  For example, when N=4,
   the bitmask '01101' indicates that segments 1, 2 and 4 are in the
   queue while segments 0 and 3 are missing.

   After all segments are gathered, the ETE reassembles the mid-layer



Templin                 Expires December 19, 2009              [Page 20]

Internet-Draft                    SEAL                         June 2009


   packet by concatenating the segments encapsulated in N consecutive
   SEAL packets beginning with the initial segment (i.e., SEG=0) and
   followed by any non-initial segments 1 through N-1.  That is, for an
   N-segment mid-layer packet, reassembly entails the concatenation of
   the SEAL-encapsulated mid-layer packet segments with (F=1, M=1,
   SEAL_ID=j) in the first SEAL header, followed by (F=0, M=1, SEG=1,
   SEAL_ID=(j+1)) in the next SEAL header, followed by (F=0, M=1, SEG=2,
   SEAL_ID=(j+2)), etc., up to (F=0, M=0, SEG=(N-1), SEAL_ID=(j + N-1))
   in the final SEAL header.  (Note that modulo arithmetic based on the
   length of the SEAL_ID field is used).

   When the ETE determines that a mid-layer packet is too large to
   reassemble, it releases the reassembly queue resources and sends a
   Reassembly Report - Packet Too Big message back to the ITE with the
   S_MRU field set to the size of the ETE's reassembly buffer (see
   Section 4.4.5).

4.4.4.  Decapsulation and Delivery to Upper Layers

   Following SEAL-layer reassembly, the ETE verifies the trailing
   checksum of the mid-layer packet using the algorithm in Section
   4.3.3.  If the checksum is incorrect, the ETE discards the packet and
   sends a Reassembly Report - Checksum Incorrect message to the ITE
   (see Section 4.4.5).  If the reassembled mid-layer packet is larger
   than (S_MRU-OHLEN), the ETE discards the packet and sends a
   Reassembly Report - Packet Too Big message to the ITE (see Section
   4.4.5).

   Otherwise, the ETE discards the outer and mid-layer headers and
   trailers, and delivers the inner packet to the upper-layer protocol
   indicated in the SEAL Next Header field.  (If the reassembled packet
   if it was a NULL packet (see Section 4.3.4), the ETE instead silently
   discards the packet).

4.4.5.  Sending SEAL Control Messages

   The ETE generates SEAL control messages in response to certain SEAL
   packets.  SEAL control messages are formated much the same as for
   ICMPv4 [RFC0792] and ICMPv6 [RFC4443] messages, and are used for very
   similar purposes.  The ETE prepares each control message as a UDP/IP
   packet as shown in Figure 3:










Templin                 Expires December 19, 2009              [Page 21]

Internet-Draft                    SEAL                         June 2009


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      ~              UDP/IP Headers (dport=SEAL_CPORT)                ~
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            SEAL ID                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Type      |     Code      |             Data              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                         Message Body                          +
      |                                                               |
      +-+-+   ...

                   Figure 3: SEAL Control Message Format

   The control message consists of outer UDP/IP headers followed by a
   32-bit SEAL_ID followed by a 32-bit control field followed by the
   message body.  When the ETE/ITE prepares a control message, it sets
   the outer IP destination and source addresses of the message to the
   source and destination addresses (respectively) of the SEAL packet
   that triggered the message.  If the destination address in the packet
   was multicast, the ETE/ITE instead sets the outer IP source address
   to an address assigned to the underlying IP interface.  The ETE/ITE
   next sets the UDP destination port to 'SEAL_CPORT'' and sets the UDP
   source port to a constant value of its choosing.  It then sets the
   SEAL_ID to the Identification value encoded in the SEAL packet that
   triggered the message.

   As for ICPMv4 and ICMPv6 messages, the SEAL control header includes
   an 8-bit Type field in bits 0 thru 7 and an 8-bit Code field in bits
   8 thru 15.  Unlike ICMPv4 and ICMPv6 messages, however, the control
   header does not include a checksum field (since the UDP header
   already contains a checksum) but instead includes a 16-bit Data field
   in bits 16 thru 31.  The ETE/ITE sets the Type, Code, Data and
   Message body fields according to the specific SEAL control message
   type, then sends the message.  The following types are currently
   defined; other values for Type will be recorded in the IANA registry
   for SEAL:

4.4.5.1.  Reassembly Report (Type=0)

   The ETE generates a Reassembly Report to inform the ITE of various
   conditions encountered during SEAL-layer reassembly.  The following
   values for Code are defined:




Templin                 Expires December 19, 2009              [Page 22]

Internet-Draft                    SEAL                         June 2009


   o  Code = 0 : IP Fragmentation Experienced

   o  Code = 1 : Segment Acknowledged

   o  Code = 2 : Packet Too Big

   o  Code = 3 : Time Exceeded

   o  Code = 4 : Checksum Incorrect

   (Other values for Code will be recorded in the IANA registry for
   SEAL.)

   The ETE prepares the Reassembly Report according to the Code as
   follows:

4.4.5.1.1.  IP Fragmentation Experienced (Code=0)

   When the ITE receives an IP first-fragment of a SEAL packet that
   experienced outer IP fragmentation, it examines SEAL header and
   examines the IP reassembly buffer to assess the likelihood that
   reassembly will complete.  If the 'A" bit is not set in the SEAL
   header, or if IP reassembly completion appears unlikely, the ETE uses
   the IP first-fragment to prepare a "Reassembly Report - IP
   Fragmentation Experienced" message with Type=0, Code=0, and Data=0.
   The message is formatted as follows

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=0     |     Code=0    |            Data=0             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       SEAL Header of Packet that Triggered the Report         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             S_MRU                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             S_MSS                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

           Figure 4: IP Fragmentation Experienced Message Format

   The ETE unconditionally writes the size of its reassembly buffer (see
   Section 4.4.1) in the S_MRU field and writes the length of the first
   IP fragment in the S_MSS field.

   If the 'A' bit is set in the SEAL header and IP reassembly completion
   appears likely, the ETE should refrain from sending this message if
   possible and instead send a Segment Acknowledged message according to



Templin                 Expires December 19, 2009              [Page 23]

Internet-Draft                    SEAL                         June 2009


   the next section.  (Note that it is not an error for the ETE to
   generate both the IP Fragmentation Experienced and Segment
   Acknowledged messages for the same SEAL packet, however this may be
   inefficient in some instances.)

4.4.5.1.2.  Segment Acknowledged (Code=1)

   When the ITE receives a SEAL segment following IP reassembly that has
   the 'A' bit set in the SEAL header, it prepares a "Reassembly Report
   - Segment Acknowledged" message with Type=0, Code=1, and Data=0.  The
   message is formatted as follows

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=0     |     Code=1    |            Data=0             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       SEAL Header of Packet that Triggered the Report         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             S_MRU                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             S_MSS                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             Bitmap                            |
      +-+-+   ...

               Figure 5: Segment Acknolwedged Message Format

   The ETE unconditionally writes the size of its reassembly buffer in
   the S_MRU field.  If the Segment arrived as multiple IP fragments,
   the ETE also writes the length of the IP first-fragment in the S_MSS
   field; otherwise, it writes the value 0 in that field.

   The ETE next includes a Bitmap recording this and all preceding
   segments of the same SEAL packet that are already in its SEAL
   reassembly buffer.  For each segment, the Bitmap records the value 1
   if the segment is present and 0 if the segment is absent.  The most
   significant bit of the Bitmap corresponds to segment 0, the next-most
   significant bit corresponds to segment 1, etc., and the least
   significant bit corresponds to the final segment.  For example, when
   SEG=6 in the SEAL header, the bit map '0110011' means that segments
   1, 2, 5 and 6 were received but segments 0, 3 and 4 were missing from
   the ETE's reassembly buffer.  The Bitmap must include at least (SEG+
   1)-many bits, where SEG is at most 255.







Templin                 Expires December 19, 2009              [Page 24]

Internet-Draft                    SEAL                         June 2009


4.4.5.1.3.  Packet Too Big (Code=2)

   The ETE generates a "Reassembly Report - Packet Too Big" message when
   it discards a SEAL packet that is too large for it to receive.  The
   ETE sets Type=0, Code=2, and Data to 0 .  The ETE then writes the
   SEAL header of segment 0 of the packet that generated the error into
   the first four bytes of the message body, then writes the size of its
   reassembly buffer in the S_MRU field.  The message is formatted as
   follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=0     |     Code=2    |    Data=(Time, in Seconds)    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    SEAL Header of First SEAL Segment of the Too-big Packet    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             S_MRU                             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 6: Segment Acknolwedged Message Format

4.4.5.1.4.  Time Exceeded (Code=3)

   The ETE generates a "Reassembly Report - Time Exceeded" message when
   it discards an incomplete SEAL reassembly buffer due to a reassembly
   timeout.  The ETE sets Type=0, Code=3, and sets Data to the time in
   seconds from when the initial SEAL segment arrived until the
   reassembly time expired.  The ETE finally writes the SEAL header of
   segment 0 of the packet that generated the error into the first four
   bytes of the message body.  If segment 0 is unavailable, the ETE
   instead writes the SEAL header of the first available segment.  The
   message is formatted as follows:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Type=0     |     Code=3    |    Data=(Time, in Seconds)    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  SEAL Header of First SEAL Segment in the Reassembly Buffer   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 7: Segment Acknolwedged Message Format








Templin                 Expires December 19, 2009              [Page 25]

Internet-Draft                    SEAL                         June 2009


4.4.5.1.5.  Checksum Incorrect (Code=4)

   The ETE generates a "Reassembly Report - Checksum Incorrect" message
   when it reassembles a SEAL packet with an invalid checksum.  The ETE
   sets Type=0, Code=4 and Data=0.  The ETE finally writes the SEAL
   header of the first segment of the packet into the first four bytes
   of the message body.  The message is formatted as follows:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type=0     |     Code=4    |              Data=0           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               SEAL Header of First SEAL Segment               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

           Figure 8: Reassembly Checksum Failure Message Format

4.4.5.2.  Parameter Problem (Type=1)

   The ETE generates a Parameter Problem message when it receives a SEAL
   packet with an invalid value in one of the SEAL header fields.  The
   ETE sets Type=1 and Code=0, then sets data to the bit number of the
   SEAL header field that triggered the error (e.g., when Data=8, the
   parameter problem is specific to the NEXTHDR/SEG field).  The ETE
   finally writes the SEAL header of the packet that generated the error
   into the first four bytes of the message body.

   The Parameter Problem message is formatted as follows:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type=1     |     Code=0    |      Data=SEAL Header bit #   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  SEAL Header of Packet that Triggered the Parameter Problem   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                Figure 9: Parameter Problem Message Format

   Other values for Code will be recorded in the IANA registry for SEAL.

4.4.5.3.  Information Request (Type=2)

   The ETE generates an Information Request message when it receives a
   SEAL packet with I=1 in the SEAL header.  The ETE sets Type=2 and
   sets Code/Data to values that are specific to the associated
   tunneling protocol (for example, the LISP protocol can use the



Templin                 Expires December 19, 2009              [Page 26]

Internet-Draft                    SEAL                         June 2009


   Information Request message to request mapping updates).  The message
   body further contains opaque data that is interpreted according to
   the Code/Data values.

   When Code=0, both Data and the Opaque Data are discarded upon receipt
   by the ETE.  The information request message is formatted as follows:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type=2     |     Code=0    |            Data=X             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Opaque Data                           |
   +-+-+-+  ...

               Figure 10: Information Request Message Format

   Other values for Code will be recoded in the IANA registry for SEAL.

   After the ETE sends an Information Request message, it must retry
   until it receives a corresponding Information Reply (see Section
   4.4.5.4).  Note that while in this loop the ETE may receive further
   SEAL packets with I=1.  In that case, the ETE should begin sending
   Information Requests specific to the SEAL_ID of the new packet and
   should not dwell on the old SEAL_ID.

4.4.5.4.  Information Reply (Type=3)

   When the ETE sends an Information Request message to the ITE, the ITE
   responds by sending an Information Reply message back to the ETE with
   the IP source and destination address set to the destination and
   source address, the UDP destination port set to the UDP source port,
   and the SEAL-ID set to the same value that was present in the
   Information Request message.

   The ITE sets Type=3 and sets Code/Data to values that are specific to
   the associated tunneling protocol (for example, the LISP protocol can
   use the Information Reply message to encode mapping updates).  The
   message body further contains opaque data that is interpreted
   according to the Code/Data values.

   When Code=0, both Data and the Opaque Data are discarded upon receipt
   by the ETE.  The information reply message is formatted as follows:








Templin                 Expires December 19, 2009              [Page 27]

Internet-Draft                    SEAL                         June 2009


     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type=3     |     Code=0    |            Data=X             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Opaque Data                           |
   +-+-+-+  ...

                Figure 11: Information Reply Message Format

   Other values for Code will be recoded in the IANA registry for SEAL.


5.  SEAL Protocol Specification (Version 1)

   This section specifies a minimal version of SEAL known as "SEAL
   Version 1", or "SEAL-LITE".  SEAL-LITE observes the same protocol
   specifications as for SEAL-MAX (see Section 4) with the exception
   that the ITE/ETE do not perform segmentation and reassembly.  In
   particular, the ETE unilaterally drops any SEAL-LITE packets that
   arrive as multiple IP fragments and/or multiple SEAL segments.

   SEAL-LITE can be considered for use by associated tunneling protocol
   specifications when it highly unlikely that "marginal" links will
   occur in any path, e.g., when it is known that the vast majority of
   links configure MTUs that are appreciably larger than 1500 bytes.
   SEAL-LITE can also be used in instances when it is acceptable for the
   ITE to return ICMP PTB messages for packet sizes smaller than 1500
   bytes.  Finally, the use of SEAL-LITE requires that the associated
   tunneling protocol specification either defines a next header field
   or ensures that the data immediately following the SEAL header is an
   IP header (i.e., either IPv4 or IPv6).  The use of SEAL-LITE must
   therefore be carefully examined in relation to the particular use
   case.

   With respect to Section 4, the SEAL-LITE protocol corresponds to
   SEAL-MAX as follows:

5.1.  Model of Operation

   SEAL-LITE follows the same model of operation as for SEAL-MAX as
   described in Section 4.1 except as noted in the following sections.

5.2.  SEAL Header Format (Version 1)

   The SEAL-LITE header is formatted as follows:





Templin                 Expires December 19, 2009              [Page 28]

Internet-Draft                    SEAL                         June 2009


       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |VER|A|I|                    Identification                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                  Figure 12: SEAL Version 1 Header Format

   where the header fields are defined as:

   VER (2)
      a 2-bit value that encodes the SEAL protocol version number.  This
      section describes Version 1 of the SEAL protocol, i.e., the VER
      field encodes the value '01'.

   A (1)
      the "Acknowledgement Requested" bit.  Set to 1 if the ITE wishes
      to receive an explicit acknowledgement from the ETE.

   I (1)
      the "Information Request Solicit" bit.  Set to 1 if the ITE wishes
      the ETE to initiate an Information Request.

   Identification (28)
      a 28-bit identification field.

5.3.  ITE Specification

5.3.1.  Tunnel Interface MTU

   SEAL-LITE observes the SEAL-MAX specification found in Section 4.3.1.

5.3.2.  Admitting Packets into the Tunnel Interface

   SEAL-LITE observes the SEAL-MAX specification found in Section 4.3.2.

5.3.3.  Segmentation

   SEAL-LITE observes the SEAL-MAX specification found in Section 4.3.3,
   except that the inner fragmentation algorithm is adjusted to avoid
   all fragmentation and/or segmentation either within or beyond the
   tunnel as follows:

   o  if the inner packet is an IPv6 packet or an IPv4 packet with DF=1,
      and the packet is larger than (MIN(S_MRU, S_MSS) - HLEN), the ITE
      drops the packet and sends an ICMP PTB message to the original
      source with an MTU value of (MIN(S_MRU, S_MSS) - HLEN) the same as
      described in Section 4.3.2; else,



Templin                 Expires December 19, 2009              [Page 29]

Internet-Draft                    SEAL                         June 2009


   o  if the inner packet is an IPv4 packet with DF=0, and the packet is
      larger than (S_CSS - HLEN), the ITE uses inner IPv4 fragmentation
      to break the packet into fragments no larger than (S_CSS - HLEN);
      else,

   o  the ITE processes the packet without inner fragmentation.

5.3.4.  Encapsulation

   SEAL-LITE observes the SEAL-MAX specification found in Section 4.3.4,
   except that it uses the header format defined in this section and
   with the VER field set to '01'.  In particular, SEAL-LITE uses the A
   and I bits the same as specified for SEAL-MAX.

5.3.5.  Probing Strategy

   SEAL-LITE observes the SEAL-MAX specification found in Section 4.3.5.

5.3.6.  Packet Identification

   SEAL-LITE observes the SEAL-MAX soft state specifications found in
   Section 4.3.6, but the SEAL_ID is treated as a 28-bit value that is
   written into the Identification field in the SEAL header.

   As for the SEAL-MAX specification in Section 4.3.6, SEAL-LITE
   increments the Identification field (modulo 28) for each consecutive
   SEAL packet.

5.3.7.  Sending SEAL Protocol Packets

   SEAL-LITE observes the SEAL-MAX specification found in Section 4.3.7.

5.3.8.  Processing Raw ICMP Messages

   SEAL-LITE observes the SEAL-MAX specification found in Section 4.3.8.

5.3.9.  Processing SEAL Control Messages

   SEAL-LITE observes the SEAL-MAX specification found in Section 4.3.9.

5.4.  ETE Specification

5.4.1.  Reassembly Buffer Requirements

   SEAL-LITE does not maintain a reassembly buffer for SEAL reassembly.






Templin                 Expires December 19, 2009              [Page 30]

Internet-Draft                    SEAL                         June 2009


5.4.2.  IP-Layer Reassembly

   SEAL-LITE uses SEAL-protocol IP first-fragments solely for the
   purpose of generating SEAL Reassembly Reports as specified in Section
   4.4.2, but thereafter discards all SEAL-protocol IP fragments.

5.4.3.  SEAL-Layer Reassembly

   SEAL-LITE does not observe the SEAL-MAX reassembly procedures in
   Section 4.4.3; Instead, the SEAL-LITE ETE discards all SEAL packets
   with F=0 following IP layer reassembly, and may also return
   Reassembly Report - Packet Too Big messages when a packet that is too
   large to receive is discarded.

   As for SEAL-MAX, SEAL-LITE returns a Parameter Problem for SEAL
   packets with unrecognized values in the SEAL header.

5.4.4.  Decapsulation and Delivery to Upper Layers

   SEAL-LITE observes the SEAL-MAX specification found in Section 4.4.4.

5.4.5.  Sending SEAL Control Messages

   SEAL-LITE observes the SEAL-MAX specification found in Section 4.4.5.


6.  Link Requirements

   Subnetwork designers are expected to follow the recommendations in
   Section 2 of [RFC3819] when configuring link MTUs.


7.  End System Requirements

   SEAL provides robust mechanisms for returning PTB messages; however,
   end systems that send unfragmentable IP packets larger than 1500
   bytes are strongly encouraged to use Packetization Layer Path MTU
   Discovery per [RFC4821].


8.  Router Requirements

   IPv4 routers within the subnetwork are strongly encouraged to
   implement IPv4 fragmentation such that the first-fragment is the
   largest and approximately the size of the underlying link MTU, i.e.,
   they should avoid generating runt first-fragments.





Templin                 Expires December 19, 2009              [Page 31]

Internet-Draft                    SEAL                         June 2009


9.  IANA Considerations

   The IANA is instructed to allocate an IP protocol number for
   'SEAL_PROTO' in the 'protocol-numbers' registry.

   The IANA is instructed to allocate a Well-Known Port number for both
   'SEAL_CPORT' and 'SEAL_DPORT' in the 'port-numbers' registry.

   The IANA is instructed to establish a "SEAL Control Protocol"
   registry to record SEAL control message Code and Type values.  This
   registry should be initialized to include the Code and Type values
   defined in Section 4.4.5.


10.  Security Considerations

   Unlike IPv4 fragmentation, overlapping fragment attacks are not
   possible due to the requirement that SEAL segments be non-
   overlapping.

   An amplification/reflection attack is possible when an attacker sends
   IP first-fragments with spoofed source addresses to an ETE, resulting
   in a stream of Reassembly Report messages returned to a victim ITE.
   The SEAL_ID in the encapsulated segment of the spoofed IP first-
   fragment provides mitigation for the ITE to detect and discard
   spurious Reassembly Reports.

   The SEAL header is sent in-the-clear (outside of any IPsec/ESP
   encapsulations) the same as for the outer */IPv4 headers.  As for
   IPv6 extension headers, the SEAL header is protected only by L2
   integrity checks and is not covered under any L3 integrity checks.


11.  Related Work

   Section 3.1.7 of [RFC2764] provides a high-level sketch for
   supporting large tunnel MTUs via a tunnel-level segmentation and
   reassembly capability to avoid IP level fragmentation, which is in
   part the same approach used by tunnel-mode SEAL.  SEAL could
   therefore be considered as a fully functioned manifestation of the
   method postulated by that informational reference.

   Section 3 of [RFC4459] describes inner and outer fragmentation at the
   tunnel endpoints as alternatives for accommodating the tunnel MTU;
   however, the SEAL protocol specifies a mid-layer segmentation and
   reassembly capability that is distinct from both inner and outer
   fragmentation.




Templin                 Expires December 19, 2009              [Page 32]

Internet-Draft                    SEAL                         June 2009


   Section 4 of [RFC2460] specifies a method for inserting and
   processing extension headers between the base IPv6 header and
   transport layer protocol data.  The SEAL header is inserted and
   processed in exactly the same manner.

   The concepts of path MTU determination through the report of
   fragmentation and extending the IP Identification field were first
   proposed in deliberations of the TCP-IP mailing list and the Path MTU
   Discovery Working Group (MTUDWG) during the late 1980's and early
   1990's.  SEAL supports a report fragmentation capability using bits
   in an extension header (the original proposal used a spare bit in the
   IP header) and supports ID extension through a 16-bit field in an
   extension header (the original proposal used a new IP option).  A
   historical analysis of the evolution of these concepts, as well as
   the development of the eventual path MTU discovery mechanism for IP,
   appears in Appendix A of this document.


12.  SEAL Advantages over Classical Methods

   The SEAL approach offers a number of distinct advantages over the
   classical path MTU discovery methods [RFC1191] [RFC1981]:

   1.  Classical path MTU discovery *always* results in packet loss when
       an MTU restriction is encountered.  Using SEAL, IP fragmentation
       provides a short-term interim mechanism for ensuring that packets
       are delivered while SEAL adjusts its packet sizing parameters.

   2.  Classical path MTU discovery requires that routers generate an
       ICMP PTB message for *all* packets lost due to an MTU
       restriction; this situation is exacerbated at high data rates and
       becomes severe for in-the-network tunnels that service many
       communicating end systems.  Since SEAL ensures that packets no
       larger than S_MRU are delivered, however, it is sufficient for
       the ETE to return ICMP PTB messages subject to rate limiting and
       not for every packet-in-error.

   3.  Classical path MTU may require several iterations of dropping
       packets and returning ICMP PTB messages until an acceptable path
       MTU value is determined.  Under normal circumstances, SEAL
       determines the correct packet sizing parameters in a single
       iteration.

   4.  Using SEAL, ordinary packets serve as implicit probes without
       exposing data to unnecessary loss.  SEAL also provides an
       explicit probing mode not available in the classic methods.





Templin                 Expires December 19, 2009              [Page 33]

Internet-Draft                    SEAL                         June 2009


   5.  Using SEAL, ETEs encapsulate ICMP error messages in an outer
       UDP/IP header such that packet-filtering network middleboxes will
       not filter them the same as for"raw" ICMP messages that may be
       generated by an attacker.

   6.  Most importantly, all SEAL packets have a 32-bit Identification
       value that can be used for duplicate packet detection purposes
       and to match ICMP error messages with actual packets sent without
       requiring per-packet state; hence, certain denial-of-service
       attack vectors open to the classical methods are eliminated.

   In summary, the SEAL approach represents an architecturally superior
   method for ensuring that packets of various sizes are either
   delivered or deterministically dropped.  When end systems use their
   own end-to-end MTU determination mechanisms [RFC4821], the SEAL
   advantages are further enhanced.


13.  Acknowledgments

   The following individuals are acknowledged for helpful comments and
   suggestions: Jari Arkko, Fred Baker, Iljitsch van Beijnum, Oliver
   Bonaventure, Teco Boot, Bob Braden, Brian Carpenter, Steve Casner,
   Ian Chakeres, Noel Chiappa, Remi Denis-Courmont, Aurnaud Ebalard,
   Gorry Fairhurst, Dino Farinacci, Joel Halpern, Sam Hartman, John
   Heffner, Thomas Henderson, Bob Hinden, Christian Huitema, Darrel
   Lewis, Joe Macker, Matt Mathis, Erik Nordmark, Dan Romascanu, Dave
   Thaler, Joe Touch, Pascal Thubert, Margaret Wasserman, Magnus
   Westerlund, Robin Whittle, James Woodyatt, and members of the Boeing
   Research & Technology NST DC&NT group.

   Path MTU determination through the report of fragmentation was first
   proposed by Charles Lynn on the TCP-IP mailing list in 1987.
   Extending the IP identification field was first proposed by Steve
   Deering on the MTUDWG mailing list in 1989.


14.  References

14.1.  Normative References

   [RFC0791]  Postel, J., "Internet Protocol", STD 5, RFC 791,
              September 1981.

   [RFC0792]  Postel, J., "Internet Control Message Protocol", STD 5,
              RFC 792, September 1981.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate



Templin                 Expires December 19, 2009              [Page 34]

Internet-Draft                    SEAL                         June 2009


              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 2460, December 1998.

   [RFC4443]  Conta, A., Deering, S., and M. Gupta, "Internet Control
              Message Protocol (ICMPv6) for the Internet Protocol
              Version 6 (IPv6) Specification", RFC 4443, March 2006.

14.2.  Informative References

   [FOLK]     C, C., D, D., and k. k, "Beyond Folklore: Observations on
              Fragmented Traffic", December 2002.

   [FRAG]     Kent, C. and J. Mogul, "Fragmentation Considered Harmful",
              October 1987.

   [I-D.ietf-lisp]
              Farinacci, D., Fuller, V., Meyer, D., and D. Lewis,
              "Locator/ID Separation Protocol (LISP)",
              draft-ietf-lisp-01 (work in progress), May 2009.

   [I-D.russert-rangers]
              Russert, S., Fleischman, E., and F. Templin, "RANGER
              Scenarios", draft-russert-rangers-00 (work in progress),
              May 2009.

   [I-D.templin-autoconf-dhcp]
              Templin, F., "Virtual Enterprise Traversal (VET)",
              draft-templin-autoconf-dhcp-38 (work in progress),
              April 2009.

   [I-D.templin-ranger]
              Templin, F., "Routing and Addressing in Next-Generation
              EnteRprises (RANGER)", draft-templin-ranger-07 (work in
              progress), February 2009.

   [MTUDWG]   "IETF MTU Discovery Working Group mailing list,
              gatekeeper.dec.com/pub/DEC/WRL/mogul/mtudwg-log, November
              1989 - February 1995.".

   [RFC1063]  Mogul, J., Kent, C., Partridge, C., and K. McCloghrie, "IP
              MTU discovery options", RFC 1063, July 1988.

   [RFC1146]  Zweig, J. and C. Partridge, "TCP alternate checksum
              options", RFC 1146, March 1990.

   [RFC1191]  Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,



Templin                 Expires December 19, 2009              [Page 35]

Internet-Draft                    SEAL                         June 2009


              November 1990.

   [RFC1981]  McCann, J., Deering, S., and J. Mogul, "Path MTU Discovery
              for IP version 6", RFC 1981, August 1996.

   [RFC2003]  Perkins, C., "IP Encapsulation within IP", RFC 2003,
              October 1996.

   [RFC2004]  Perkins, C., "Minimal Encapsulation within IP", RFC 2004,
              October 1996.

   [RFC2473]  Conta, A. and S. Deering, "Generic Packet Tunneling in
              IPv6 Specification", RFC 2473, December 1998.

   [RFC2764]  Gleeson, B., Heinanen, J., Lin, A., Armitage, G., and A.
              Malis, "A Framework for IP Based Virtual Private
              Networks", RFC 2764, February 2000.

   [RFC2923]  Lahey, K., "TCP Problems with Path MTU Discovery",
              RFC 2923, September 2000.

   [RFC3366]  Fairhurst, G. and L. Wood, "Advice to link designers on
              link Automatic Repeat reQuest (ARQ)", BCP 62, RFC 3366,
              August 2002.

   [RFC3692]  Narten, T., "Assigning Experimental and Testing Numbers
              Considered Useful", BCP 82, RFC 3692, January 2004.

   [RFC3819]  Karn, P., Bormann, C., Fairhurst, G., Grossman, D.,
              Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L.
              Wood, "Advice for Internet Subnetwork Designers", BCP 89,
              RFC 3819, July 2004.

   [RFC4213]  Nordmark, E. and R. Gilligan, "Basic Transition Mechanisms
              for IPv6 Hosts and Routers", RFC 4213, October 2005.

   [RFC4301]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, December 2005.

   [RFC4380]  Huitema, C., "Teredo: Tunneling IPv6 over UDP through
              Network Address Translations (NATs)", RFC 4380,
              February 2006.

   [RFC4459]  Savola, P., "MTU and Fragmentation Issues with In-the-
              Network Tunneling", RFC 4459, April 2006.

   [RFC4727]  Fenner, B., "Experimental Values In IPv4, IPv6, ICMPv4,
              ICMPv6, UDP, and TCP Headers", RFC 4727, November 2006.



Templin                 Expires December 19, 2009              [Page 36]

Internet-Draft                    SEAL                         June 2009


   [RFC4821]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", RFC 4821, March 2007.

   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler, "IPv4 Reassembly
              Errors at High Data Rates", RFC 4963, July 2007.

   [TCP-IP]   "Archive/Hypermail of Early TCP-IP Mail List,
              http://www-mice.cs.ucl.ac.uk/multimedia/misc/tcp_ip/, May
              1987 - May 1990.".


Appendix A.  Reliability

   Automatic Repeat-ReQuest (ARQ) mechanisms are used to ensure reliable
   delivery between the endpoints of links [RFC3366] (e.g., on-link
   neighbors in an IEEE 802.11 network) as well as between the endpoints
   of an end-to-end transport (e.g., the endpoints of a TCP connection).
   Implementations of this specification can use the Bitmap feature of
   Reassembly Report control messages as a hint of segments for
   retransmission, however this may not be ideally suitable for all SEAL
   use cases since retransmission of lost segments may require
   considerable state maintenance at the ITE and may also result in
   considerable delay variance and packet reordering within the
   subnetwork.

   Alternate reliability mechanisms such as Forward Error Correction
   (FEC) may also be used for the purpose of improved reliability.  Such
   mechanisms may entail the ITE performing proactive transmissions of
   redundant data, e.g., by sending multiple copies of the same data.
   Signaling from the ETE may also be considered as a means for the ETE
   to dynamically inform the ITE of changing FEC conditions.

   Future studies should examine the use of ARQ and FEC mechanisms for
   improved reliability in the face of loss due to congestion, signal
   intermittence, etc.


Appendix B.  Transport Mode

   SEAL can also be used in "transport-mode", e.g., when the inner layer
   includes upper-layer protocol data rather than an encapsulated IP
   packet.  For instance, TCP peers can negotiate the use of SEAL for
   the carriage of protocol data encapsulated as TCP/SEAL/IPv4.  In this
   sense, the "subnetwork" becomes the entire end-to-end path between
   the TCP peers and may potentially span the entire Internet.

   Sections 4 and 5 specify the operation of SEAL in "tunnel mode",
   i.e., when there are both an inner and outer IP layer with a SEAL



Templin                 Expires December 19, 2009              [Page 37]

Internet-Draft                    SEAL                         June 2009


   encapsulation layer between.  However, the SEAL protocol can also be
   used in a "transport mode" of operation within a subnetwork region in
   which the inner-layer corresponds to a transport layer protocol
   (e.g., UDP, TCP, etc.) instead of an inner IP layer.

   For example, two TCP endpoints connected to the same subnetwork
   region can negotiate the use of transport-mode SEAL for a connection
   by inserting a 'SEAL_OPTION' TCP option during the connection
   establishment phase.  If both TCPs agree on the use of SEAL, their
   protocol messages will be carried as TCP/SEAL/IPv4 and the connection
   will be serviced by the SEAL protocol using TCP (instead of an
   encapsulating tunnel endpoint) as the transport layer protocol.  The
   SEAL protocol for transport mode otherwise observes the same
   specifications as for Sections 4 and 5.


Appendix C.  Historic Evolution of PMTUD

   (Taken from "Neighbor Affiliation Protocol for IPv6-over-(foo)-over-
   IPv4"; written 10/30/2002):

   The topic of Path MTU discovery (PMTUD) saw a flurry of discussion
   and numerous proposals in the late 1980's through early 1990.  The
   initial problem was posed by Art Berggreen on May 22, 1987 in a
   message to the TCP-IP discussion group [TCP-IP].  The discussion that
   followed provided significant reference material for [FRAG].  An IETF
   Path MTU Discovery Working Group [MTUDWG] was formed in late 1989
   with charter to produce an RFC.  Several variations on a very few
   basic proposals were entertained, including:

   1.  Routers record the PMTUD estimate in ICMP-like path probe
       messages (proposed in [FRAG] and later [RFC1063])

   2.  The destination reports any fragmentation that occurs for packets
       received with the "RF" (Report Fragmentation) bit set (Steve
       Deering's 1989 adaptation of Charles Lynn's Nov. 1987 proposal)

   3.  A hybrid combination of 1) and Charles Lynn's Nov. 1987 (straw
       RFC draft by McCloughrie, Fox and Mogul on Jan 12, 1990)

   4.  Combination of the Lynn proposal with TCP (Fred Bohle, Jan 30,
       1990)

   5.  Fragmentation avoidance by setting "IP_DF" flag on all packets
       and retransmitting if ICMPv4 "fragmentation needed" messages
       occur (Geof Cooper's 1987 proposal; later adapted into [RFC1191]
       by Mogul and Deering).




Templin                 Expires December 19, 2009              [Page 38]

Internet-Draft                    SEAL                         June 2009


   Option 1) seemed attractive to the group at the time, since it was
   believed that routers would migrate more quickly than hosts.  Option
   2) was a strong contender, but repeated attempts to secure an "RF"
   bit in the IPv4 header from the IESG failed and the proponents became
   discouraged. 3) was abandoned because it was perceived as too
   complicated, and 4) never received any apparent serious
   consideration.  Proposal 5) was a late entry into the discussion from
   Steve Deering on Feb. 24th, 1990.  The discussion group soon
   thereafter seemingly lost track of all other proposals and adopted
   5), which eventually evolved into [RFC1191] and later [RFC1981].

   In retrospect, the "RF" bit postulated in 2) is not needed if a
   "contract" is first established between the peers, as in proposal 4)
   and a message to the MTUDWG mailing list from jrd@PTT.LCS.MIT.EDU on
   Feb 19. 1990.  These proposals saw little discussion or rebuttal, and
   were dismissed based on the following the assertions:

   o  routers upgrade their software faster than hosts

   o  PCs could not reassemble fragmented packets

   o  Proteon and Wellfleet routers did not reproduce the "RF" bit
      properly in fragmented packets

   o  Ethernet-FDDI bridges would need to perform fragmentation (i.e.,
      "translucent" not "transparent" bridging)

   o  the 16-bit IP_ID field could wrap around and disrupt reassembly at
      high packet arrival rates

   The first four assertions, although perhaps valid at the time, have
   been overcome by historical events.  The final assertion is addressed
   by the mechanisms specified in SEAL.


Author's Address

   Fred L. Templin (editor)
   Boeing Research & Technology
   P.O. Box 3707
   Seattle, WA  98124
   USA

   Email: fltemplin@acm.org







Templin                 Expires December 19, 2009              [Page 39]


