<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc authorship="yes"?>
<?rfc tocappendix="yes"?>
<rfc category="std" docName="draft-ietf-roll-rpl-04" ipr="trust200902">
  <front>
    <title abbrev="draft-ietf-roll-rpl-04">RPL: IPv6 Routing Protocol for Low
    power and Lossy Networks</title>

    <author fullname="Tim Winter" initials="T" role="editor" surname="Winter">
      <organization></organization>

      <address>
        <email>wintert@acm.org</email>
      </address>
    </author>

    <author fullname="Pascal Thubert" initials="P" role="editor"
            surname="Thubert">
      <organization abbrev="Cisco Systems">Cisco Systems</organization>

      <address>
        <postal>
          <street>Village d'Entreprises Green Side</street>

          <street>400, Avenue de Roumanille</street>

          <street>Batiment T3</street>

          <city>Biot - Sophia Antipolis</city>

          <code>06410</code>

          <country>FRANCE</country>
        </postal>

        <phone>+33 497 23 26 34</phone>

        <email>pthubert@cisco.com</email>
      </address>
    </author>

    <author fullname="ROLL Design Team" initials="" surname="ROLL Design Team">
      <organization>IETF ROLL WG</organization>

      <address>
        <email>rpl-authors@external.cisco.com</email>
      </address>
    </author>

    <date day="26" month="October" year="2009" />

    <area>Routing Area</area>

    <workgroup>Networking Working Group</workgroup>

    <keyword>Draft</keyword>

    <abstract>
      <t>Low power and Lossy Networks (LLNs) are a class of network in which
      both the routers and their interconnect are constrained: LLN routers
      typically operate with constraints on (any subset of) processing power,
      memory and energy (battery), and their interconnects are characterized
      by (any subset of) high loss rates, low data rates and instability. LLNs
      are comprised of anything from a few dozen and up to thousands of LLN
      routers, and support point-to- point traffic (between devices inside the
      LLN), point-to-multipoint traffic (from a central control point to a
      subset of devices inside the LLN) and multipoint-to- point traffic (from
      devices inside the LLN towards a central control point). This document
      specifies the IPv6 Routing Protocol for LLNs (RPL), which provides a
      mechanism whereby multipoint-to-point traffic from devices inside the
      LLN towards a central control point, as well as point-to-multipoint
      traffic from the central control point to the devices inside the LLN, is
      supported. Support for point-to-point traffic is also available.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Low power and Lossy Networks (LLNs) are made largely of constrained
      nodes (with limited processing power, memory, and sometimes energy when
      they are battery operated). These routers are interconnected by lossy
      links, typically time supporting only low data rates, that are usually
      unstable with relatively low packet delivery rates. Another
      characteristic of such networks is that the traffic patterns are not
      simply unicast, but in many cases point-to-multipoint or
      multipoint-to-point. Furthermore such networks may potentially comprise
      up to thousands of nodes. These characteristics offer unique challenges
      to a routing solution: the IETF ROLL Working Group has defined
      application-specific routing requirements for a Low power and Lossy
      Network (LLN) routing protocol, specified in <xref
      target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
      target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
      target="RFC5673"></xref>, and <xref target="RFC5548"></xref>. This
      document specifies the IPv6 Routing Protocol for Low power and Lossy
      Networks (RPL).</t>

      <section title="Design Principles">
        <t>RPL was designed with the objective to meet the requirements
        spelled out in <xref
        target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
        target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
        target="RFC5673"></xref>, and <xref target="RFC5548"></xref>. Because
        those requirements are heterogeneous and sometimes incompatible in
        nature, the approach is first taken to design a protocol capable of
        supporting a core set of functionalities corresponding to the
        intersection of the requirements. (Note: it is intended that as this
        design evolves optional features may be added to address some
        application specific requirements). This is a key protocol design
        decision providing a granular approach in order to restrict the core
        of the protocol to a minimal set of functionalities, and to allow each
        implementation of the protocol to be optimized in terms of, e.g.,
        minimizing required code space and use of limited computation
        resources.</t>

        <t>Multiple instances of the protocol can be operated at the same time
        in order to serve different and potentially antagonistic constraints.
        Instances run independently of one another with no required
        interaction. A node might participate to multiple instances and route
        independently along the associated topologies. This specification
        defines only the protocol operation for the node within one instance.
        Consideration is given to default behavior that enables future
        extensions for the multiple instances and related policies.</t>

        <t>It must be noted that RPL is not restricted to the aforementioned
        applications and is expected to be used in other environments. All
        "MUST" application requirements that cannot be satisfied by RPL will
        be specifically listed in the Appendix A, accompanied by a
        justification.</t>

        <t>The core set of functionalities is to be capable of operating in
        the most severely constrained environments, with minimal requirements
        for memory, energy, processing, communication, and other consumption
        of limited resources from nodes. Trade-offs inherent in the
        provisioning of protocol features will be exposed to the implementer
        in the form of configurable parameters, such that the implementer can
        further tweak and optimize the operation of RPL as appropriate to a
        specific application and implementation. Finally, RPL is designed to
        consult implementation specific policies to determine, for example,
        the evaluation of routing metrics.</t>

        <t>A set of companion documents to this specification will provide
        further guidance in the form of applicability statements specifying a
        set of operating points appropriate to the Building Automation, Home
        Automation, Industrial, and Urban application scenarios.</t>
      </section>

      <section title="Expectations of Link Layer Type">
        <t>This specification does not rely on any particular features of a
        specific link layer technologies. It is anticipated that an
        implementer should be able to operate RPL over a variety of different
        link layers, including but not limited to low power wireless or PLC
        (Power Line Communication) technologies.</t>

        <t>Implementers may find <xref target="RFC3819">RFC 3819</xref> a
        useful reference when designing a link layer interface between RPL and
        a particular link layer technology.</t>
      </section>
    </section>

    <section anchor="Terminology" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>

      <t>This document requires readers to be familiar with the terminology
      described in `Terminology in Low power And Lossy Networks' <xref
      target="I-D.ietf-roll-terminology"></xref>.</t>

      <t><list hangIndent="6" style="hanging">
          <t hangText="DAG:">Directed Acyclic Graph. A directed graph having
          the property that all edges are oriented in such a way that no
          cycles exist. In the RPL context, all edges are contained in paths
          oriented toward and terminating at one or more root nodes (a DAG
          root, or sink- typically a Low power and Lossy Network Border Router
          (LBR)). For the purpose of this document, the term DAG is often used
          to refer to a DAG Iteration as defined below.</t>

          <t hangText="DAG Instance:">A DAG Instance is a set of possibly
          multiple Destination Oriented DAGs. A network may have more than one
          DAG Instance, and a RPL router can participate to multiple DAG
          instances. Each DAG Instance operates independently of other DAG
          Instances. This document describes operation within a single DAG
          instance.</t>

          <t hangText="InstanceID:">Unique identifier of a DAG Instance.</t>

          <t hangText="Destination Oriented DAG:">A DAG rooted at a single
          destination, which is a node with no outgoing edges. The tuple
          (InstanceID, DAGID) uniquely identifies a Destination Oriented DAG.
          In the RPL context, a router can can belong to at most one
          Destination Oriented DAG per DAG Instance.</t>

          <t hangText="DAGID:">The identifier of a DAG root. The DAGID must be
          unique within the scope of a DAG Instance in the LLN.</t>

          <t hangText="DAG Iteration:">The DAG that results from the iterative
          process that reshapes the Destination Oriented DAG upon a
          stimulation by the root.</t>

          <t hangText="DAGSequenceNumber:">A sequential counter that is
          incremented by the root to form a new Iteration of a DAG. A DAG
          Iteration is identified uniquely by the (InstanceID, DAGID,
          DAGSequenceNumber) tuple.</t>

          <t hangText="DAG parent:">A parent of a node within a DAG is one of
          the immediate successors of the node on a path towards the DAG
          root.</t>

          <t hangText="DAG sibling:">A sibling of a node within a DAG is
          defined in this specification to be any neighboring node which is
          located at the same rank within a DAG. Note that siblings defined in
          this manner do not necessarily share a common parent.</t>

          <t hangText="DAG root:">A DAG root is a node within the DAG that has
          no outgoing edges. Because the graph is acyclic, by definition all
          DAGs must have at least one DAG root and all paths terminate at a
          DAG root.</t>

          <t hangText="Sub-DAG">The sub-DAG of a node is the set of other
          nodes in the DAG that might use a path towards the DAG root that
          contains the node. Nodes in the sub-DAG of a node have a greater
          rank (although not all nodes of greater rank are in the
          sub-DAG).</t>

          <t hangText="Grounded:">A DAG is grounded if it contains a DAG root
          offering connectivity to an external routed infrastructure such as
          the public Internet or a private core (non-LLN) IP network.</t>

          <t hangText="Floating:">A DAG is floating if is not grounded. A
          floating DAG is not expected to reach any additional external routed
          infrastructure such as the public Internet or a private core
          (non-LLN) IP network.</t>

          <t hangText="Inward:">Inward refers to the direction from leaf nodes
          towards DAG roots, following the orientation of the edges within the
          DAG.</t>

          <t hangText="Outward:">Outward refers to the direction from DAG
          roots towards leaf nodes, going against the orientation of the edges
          within the DAG.</t>

          <t hangText="OCP:">Objective Code Point. The Objective Code Point is
          used to indicate which Objective Function is in use in a DAG. The
          Objective Code Point is further described in <xref
          target="I-D.ietf-roll-routing-metrics"></xref>.</t>

          <t hangText="OF:">Objective Function. The Objective Function (OF)
          defines which routing metrics, optimization objectives, and related
          functions are in use in a DAG. The Objective Function is further
          described in <xref
          target="I-D.ietf-roll-routing-metrics"></xref>.</t>
        </list></t>

      <t>Note that in this document, the terms `node' and `LLN router' are
      used interchangeably.</t>
    </section>

    <section anchor="ProtocolModel" title="Protocol Model">
      <t>The aim of this section is to describe RPL in the spirit of <xref
      target="RFC4101"></xref>. Protocol details can be found in further
      sections.</t>

      <section anchor="ProtocolOverview" title="Overview">
        <section title="Topology Instance and Objectives">
          <t>A topology instance of RPL exists over the scope of an LLN in
          support of a particular application, or service, and is optimized
          according to a certain objective, as determined by an Objective
          Function (OF), and may be characterized by certain destination
          prefixes as well. A topology instance, or DAG Instance, may be
          administratively associated with an InstanceID.</t>

          <t>A single topology instance may comprise:</t>

          <t><list style="symbols">
              <t>a single Destination Oriented DAG with a single DAG root
              <list>
                  <t>For example, a DAG optimized to minimize latency rooted
                  at a single centralized lighting controller in a home
                  automation application.</t>
                </list></t>

              <t>multiple uncoordinated Destination Oriented DAGs with
              independent DAG roots (differing DAGIDs) <list>
                  <t>For example, multiple data collection points in an urban
                  data collection application that do not have an always-on
                  backbone suitable to coordinate to form a single DAG, and
                  further use the formation of multiple DAGs as a means to
                  dynamically and autonomously partition the network.</t>
                </list></t>

              <t>a single Destination Oriented DAG with multiple DAG roots
              coordinating over some backbone <list>
                  <t>For example, multiple border routers operating with a
                  reliable backbone, e.g. in support of a 6LowPAN application,
                  that are capable to act as logically equivalent sinks to the
                  same DAG.</t>
                </list></t>

              <t>a combination of one of the above as suited to some
              application scenario</t>
            </list></t>

          <t>The exact deployment scenario is determined as appropriate to the
          application and capabilities of the LLN nodes. What is suitable for
          one deployment may not be possible or necessary for another.</t>

          <t>Traffic is bound to a specific DAG Instance by a marking in the
          flow label of the IPv6 header. Traffic originating in support of a
          particular application may be tagged to follow an appropriate
          instance, for example to follow paths optimized for low latency or
          low energy. The provisioning or automated discovery of a mapping
          between an InstanceID and a type or service of application traffic
          is beyond the scope of this specification.</t>

          <t>Conceptually a node running RPL may capable to maintain a
          membership in multiple DAG Instances in support of different
          application services and/or optimization objectives. For example,
          one instance may optimize for minimizing latency and a separate
          orthogonal instance may optimize for minimizing energy. This
          scenario does introduce some additional considerations, for example
          loop avoidance and default routing behavior. These considerations
          are beyond the scope of this specification and are intended to be
          elaborated on in a future revision of this or a companion
          specification. As such, this specification will deal exclusively
          with the scenario where a node implements RPL in support of a single
          DAG Instance.</t>
        </section>

        <section title="Multipoint-to-Point Traffic Flows and DAGs">
          <t>Many of the dominant traffic flows in support of the LLN
          application scenarios are MP2P flows (<xref
          target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
          target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
          target="RFC5673"></xref>, and <xref target="RFC5548"></xref>). These
          flows are rooted at designated nodes that have some application
          significance, such as providing connectivity to an external routed
          infrastructure. The term "external" is used to refer to the public
          Internet or a core private (non-LLN) IP network.</t>

          <t>LLN nodes running RPL will construct Directed Acyclic Graphs
          (DAGs) rooted at DAG roots, which may be naturally designated
          according to their application significance. This structure provides
          the routing solution for the dominant MP2P traffic flows. The DAG
          structure further provides each node potentially multiple successors
          for MP2P flows, which may be used for, e.g., local route repair or
          load balancing.</t>

          <t>Nodes running RPL are able to further restrict the scope of the
          routing problem by using the DAG as a reference topology. By
          referencing a rank property that is related to the positions in the
          DAG, nodes are able to determine their positions in a DAG relative
          to each other. This information is used by RPL in part to construct
          rules for movement relative to the DAG that endeavor to avoid loops.
          It is important to note that the rank property is derived from
          metrics, and not directly from the position in the DAG (<xref
          target="DAGRank"></xref>).</t>
        </section>

        <section title="Point-to-Multipoint Traffic Flows">
          <t>As DAGs are organized, RPL will use a destination advertisement
          mechanism to build up routing tables in support of outward P2MP
          traffic flows. This mechanism, using the DAG as a reference,
          distributes routing information across intermediate nodes (between
          the DAG leaves and the root), guided along the DAG, such that the
          routes toward destination prefixes in the outward direction may be
          set up. As the DAG undergoes modification during DAG maintenance,
          the destination advertisement mechanism can be triggered to update
          the outward routing state.</t>
        </section>

        <section title="Point-to-Point Traffic Flows">
          <t>A baseline support for P2P traffic in RPL is provided by the DAG,
          as P2P traffic may flow inward along the DAG until a common parent
          is reached that has stored an entry for the destination in its
          routing table and is capable of directing the traffic outward along
          the correct outward path. RPL also provides support for the trivial
          case where a P2P destination may be a `one-hop' neighbor. In the
          present document RPL does not specify nor preclude any additional
          mechanisms that may be capable to compute and install more optimal
          routes into LLN nodes in support of arbitrary P2P traffic according
          to some routing metric.</t>
        </section>
      </section>

      <section title="Protocol Operation">
        <section title="DAG Construction">
          <section title="DAG Information Object (DIO)">
            <t>A DAG Information Object is defined and used by RPL in order to
            build and maintain a DAG. This document defines an ICMPv6 Message
            Type RPL Control Message, which is capable to carry the DIO. The
            DIO message conveys information about the DAG, including:</t>

            <t><list style="symbols">
                <t>A DAGID used to identify the DAG as sourced from the DAG
                root. The DAGID must be unique to a single DAG in the scope of
                the LLN.</t>

                <t>Objective Function identified by an Objective Code Point
                (OCP) as described below.</t>

                <t>Rank information used by nodes to determine their positions
                in the DAG relative to each other.</t>

                <t>Sequence number originated from the DAG root, used to aid
                in identification of dependent sub-DAGs and coordinate
                topology changes in a manner so as to avoid loops.</t>

                <t>Indications and configuration for the DAG, e.g. grounded or
                floating, administrative preference, ...</t>

                <t>A set of path metrics and constraints, as further described
                in <xref target="I-D.ietf-roll-routing-metrics"></xref>.</t>

                <t>List of additional destination prefixes reachable inwards
                along the DAG.</t>
              </list></t>

            <t>The DIO messages are issued whenever a change is detected to
            the DAG such that a node is able to determine that a region of the
            DAG has become inconsistent. As the DAG stabilizes the period at
            which RA messages occur is configured to taper off, reducing the
            steady-state overhead of DAG maintenance. The periodic issue of
            DIO messages, along with the triggered DIO messages in response to
            inconsistency, is one feature that enables RPL to operate in the
            presence of unreliable links.</t>
          </section>

          <section title="Grounded and Floating DAGs">
            <t>Certain LLN nodes may offer connectivity to an external routed
            infrastructure in support of an application scenario. These nodes
            are designated `grounded', and may serve as the DAG roots of a
            grounded DAG. DAGs that do not have a grounded DAG root are
            floating DAGs. In either case routes may be provisioned toward the
            DAG root, although in the floating case there is no expectation to
            reach an external infrastructure. Some applications will include
            permanent floating DAGs.</t>
          </section>

          <section title="Administrative Preference">
            <t>An administrative preference may be associated with each DAG
            root, and thereby each DAG, in order that some DAGs in the LLN may
            be more preferred over other DAGs. For example, a DAG root that is
            sinking traffic in support of a data collection application may be
            configured by the application to be very preferred. A transient
            DAG, e.g. a DAG that is only existing until a permanent DAG is
            found, may be configured to be less preferred. The administrative
            preference offers a way to engineer the formation of the DAG in
            support of the application.</t>
          </section>

          <section title="Objective Function (OF)">
            <t>The Objective Function (OF) conveys and controls the
            optimization objectives in use within the DAG. The Objective
            Function is indicated by an Objective Code Point (OCP), and is
            further specified in <xref
            target="I-D.ietf-roll-routing-metrics"></xref>. Each instance of
            an allocated OF indicates:</t>

            <t><list style="symbols">
                <t>The set of metrics used within the DAG</t>

                <t>The method used for least cost path determination.</t>

                <t>The method used to compute DAG Rank</t>

                <t>The methods used to prepare metrics for propagation within
                a DIO message</t>
              </list></t>

            <t>By using defined OCPs that are understood by all nodes in a
            particular implementation, and by conveying them in the DIO
            message, RPL nodes may work to build optimized LLN using a variety
            of application and implementation specific metrics and goals.</t>

            <t>A default OF, OF0 (designated by OCP value of 0x0000), is
            specified with a well-defined default behavior. OF0 may be used to
            define RPL behaviors in the case where a node encounters a DIO
            message containing a code point that it does not support, if
            allowed by policy.</t>
          </section>

          <section title="Distributed Algorithm Operation">
            <t>A high level overview of the distributed algorithm which
            constructs the DAG is as follows:</t>

            <t><list style="symbols">
                <t>Some nodes may be initially provisioned to act as DAG
                roots, either permanent or transient, with associated
                preferences.</t>

                <t>Nodes will maintain a data structure containing their
                candidate (viable) neighbors, as determined by the
                implementation. This data structure will also track DAG
                information as learned from and associated with each
                neighbor.</t>

                <t>Nodes that are members of a DAG, including DAG roots, will
                multicast DIO messages as needed (when inconsistency is
                detected), to their link-local neighbors. Nodes will also
                respond to DIS messages.</t>

                <t>Nodes that receive DIO messages may either discard the DIO
                based on several criteria, including rank-based loop avoidance
                rules, or process the DIO to maintain a position in an
                existing DAG or improve a position as according to an
                Objective Function (OF) and current path cost.</t>

                <t>Nodes manage a set of DAG Parents according to the rules
                specified by RPL. This set is also augmented to include DAG
                siblings.</t>

                <t>DIO messages may be emitted more or less frequently as a
                function of DAG consistency.</t>

                <t>As less preferred DAGs encounter more preferred DAGs that
                offer equivalent or better optimization objectives for the
                same InstanceID, the nodes in the less preferred DAGs may
                leave to join the more preferred DAGs, finally leaving only
                the more preferred DAGs. This is an illustration of the
                mechanism by which an application may engineer DAG
                construction.</t>

                <t>The nodes provision routing table entries for the
                destinations specified by the DIO towards their DAG Parents.
                Nodes may provision a DAG Parent as a default gateway.</t>
              </list></t>
          </section>
        </section>

        <section title="Destination Advertisement">
          <t>As RPL constructs DAGs, nodes may provision routes toward
          destinations advertised through DIO messages through their selected
          parents, and are thus able to send traffic inward along the DAG by
          forwarding to their selected parents. However, this mechanism alone
          is not sufficient to support P2MP traffic flowing outward along the
          DAG from the DAG root toward nodes. A destination advertisement
          mechanism is employed by RPL to build up routing state in support of
          these outward flows. The destination advertisement mechanism may not
          be supported in all implementations, as appropriate to the
          application requirements. A DAG root that supports using the
          destination advertisement mechanism to build up routing state will
          indicate such in the DIO message. A DAG root that supports using the
          destination advertisement mechanism must be capable of allocating
          enough state to store the routing state received from the LLN.</t>

          <section title="Destination Advertisement Object (DAO)">
            <t>A Destination Advertisement Object is defined and used by RPL
            in order to convey the destination information inward along the
            DAG toward the DAG root. This document defines an ICMPv6 Message
            Type RPL Control Message, which is capable to carry the DAO. The
            information conveyed in the DAO message includes the
            following:</t>

            <t><list style="symbols">
                <t>A lifetime and sequence counter to determine the freshness
                of the destination advertisement.</t>

                <t>Depth information used by nodes to determine how far away
                the destination (the source of the destination advertisement)
                is</t>

                <t>Prefix information to identify the destination, which may
                be a prefix, an individual host, or multicast listeners</t>

                <t>Reverse Route information to record the nodes visited
                (along the outward path) when the intermediate nodes along the
                path cannot support storing state for Hop-By-Hop routing.</t>
              </list></t>
          </section>

          <section title="Destination Advertisement Operation">
            <t>As the DAG is constructed and maintained, nodes are capable to
            emit DAO messages to a subset of their DAG parents.</t>

            <section title="`One-Hop' Neighbors">
              <t>As a special case, a node may periodically emit a link-local
              multicast IPv6 DAO message advertising its locally available
              destination prefixes. This mechanism allows for the one-hop
              neighbors of a node to learn explicitly of the prefixes on the
              node, and in some application specific scenarios this is
              desirable in support of provisioning a trivial `one-hop' route.
              In this case, nodes that receive the multicast destination
              advertisement may use it to provision the one-hop route only,
              and not engage in any additional processing (so as not to engage
              the mechanisms used by a DAG parent).</t>
            </section>

            <section title="Operation in Support of Stateful Nodes">
              <t>When a (unicast) DAO message reaches a node capable of
              storing routing state, the node extracts information from the
              DAO message and updates its local database with a record of the
              DAO message and the neighbor that it was received from. When the
              node later propagates DAO messages, it selects the best (least
              depth) information for each destination and conveys this
              information again in the form of DAO messages to a subset of its
              own DAG parents. At this time the node may perform route
              aggregation if it is able, thus reducing the overall number of
              DAO messages.</t>
            </section>

            <section title="Operation in Support of Stateless Nodes">
              <t>When a (unicast) DAO message reaches a node incapable of
              storing additional state, the node must append the next-hop
              address (from which neighbor the DAO message was received) to a
              Reverse Route Stack carried within the DAO message. The node
              then passes the DAO message on to one or more of its DAG parents
              without storing any additional state.</t>

              <t>When a node that is capable of storing routing state
              encounters a (unicast) DAO message with a Reverse Route Stack
              that has been populated, the node knows that the DAO message has
              traversed a region of nodes that did not record any routing
              state. The node is able to detach and store the Reverse Route
              State and associate it with the destination described by the DAO
              message. Subsequently the node may use this information to
              construct a source route in order to bridge the region of nodes
              that are unable to support Hop-By-Hop routing to reach the
              destination.</t>
            </section>

            <section title="Additional Considerations">
              <t>Further aggregations of DAO messages prefix reachability
              information by destinations are possible in order to support
              additional scalability.</t>

              <t>A special case of an DAO message, termed a `no-DAO', may be
              used to tear down the routing state that has been established by
              the destination advertisement mechanism in case of, e.g.,
              unreachability or other events that affect the outward routing
              state.</t>

              <t>A further example of the operation of the destination
              advertisement mechanism is available in <xref
              target="DestinationAdvertisementExample"></xref></t>
            </section>
          </section>
        </section>
      </section>

      <section title="Loop Avoidance and Stability">
        <t>The goal of a guaranteed consistent and loop free global routing
        solution for an LLN may not be practically achieved given the real
        behavior and volatility of the underlying metrics. The trade offs to
        achieve a stable approximation of global convergence may be too
        restrictive with respect to the need of the LLN to react quickly in
        response to the lossy environment. Globally the LLN may be able to
        achieve a weak convergence, in particular as link changes are able to
        be handled locally and result in minimal changes to global
        topology.</t>

        <t>RPL does not aim to guarantee loop free path selection, or strong
        global convergence. In order to reduce control overhead, in particular
        the expense of mechanisms such as count-to-infinity, RPL does try to
        avoid the creation of loops when undergoing topology changes.</t>

        <t>RPL includes rank-based mechanisms for detecting loops to ensure
        that packets make forward progress within the DAG and trigger DAG
        repair if necessary.</t>

        <section title="Greediness and Rank-based Instabilities">
          <t>Once a node has joined a DAG, RPL disallows certain behaviors,
          including greediness, in order to prevent resulting instabilities in
          the DAG.</t>

          <t>If a node is allowed to be greedy and attempts to move deeper in
          the DAG, beyond its most preferred parent, in order to increase the
          size of the DAG parent set, then an instability can result. This is
          illustrated in <xref target="Greedy"></xref>.</t>

          <t>Suppose a node is willing to receive and process a DIO messages
          from a node in its own sub-DAG, and in general a node deeper than
          it. In such cases a chance exists to create a feedback loop, wherein
          two or more nodes continue to try and move in the DAG in order to
          optimize against each other. In some cases this will result in an
          instability. It is for this reason that RPL mandates that a node
          never receive and process DIO messages from deeper nodes. This rule
          creates an `event horizon', whereby a node cannot be influenced into
          an instability by the action of nodes that may be in its own
          sub-DAG.</t>

          <t>A further example of the consequences of greedy operation, and
          instability related to processing DIO messages from nodes of greater
          rank, may be found in <xref target="ExGreedyExample"></xref></t>
        </section>

        <section title="DAG Loops">
          <t>A DAG loop may occur when a node detaches from the DAG and
          reattaches to a device in its prior sub-DAG. This may happen in
          particular when DIO messages are missed. Strict use of the DAG
          sequence number can eliminate this type of loop.</t>
        </section>

        <section title="DAO Loops">
          <t>A DAO loop may occur when the parent has a route installed upon
          receiving and processing a DAO message from a child, but the child
          has subsequently cleaned up the state. This loop happens when a
          no-DAO was missed till a heartbeat cleans up all states. RPL
          includes loop detection mechanisms that may mitigate the impact of
          DAO loops and trigger their repair.</t>

          <t>In the case where stateless DAO operation is used, i.e. source
          routing specifies the outwards routes, then DAO Loops should not
          occur on the stateless portions of the path.</t>
        </section>

        <section title="Sibling Loops">
          <t>Sibling loops could occur if a group of siblings kept choosing
          amongst themselves as successors such that a packet does not make
          forward progress. This specification limits the number of times that
          sibling forwarding may be used at a given rank to prevent sibling
          loops.</t>
        </section>
      </section>
    </section>

    <section anchor="ConstrainedLLNs"
             title="Routing Metrics and Constraints Used By RPL">
      <t>Routing metrics are used by routing protocols to compute the shortest
      paths. Interior Gateway Protocols (IGPs) such as IS-IS (<xref
      target="RFC5120"></xref>) and OSPF (<xref target="RFC4915"></xref>) use
      static link metrics. Such link metrics can simply reflect the bandwidth
      or can also be computed according to a polynomial function of several
      metrics defining different link characteristics; in all cases they are
      static metrics. Some routing protocols support more than one metric: in
      the vast majority of the cases, one metric is used per (sub)topology.
      Less often, a second metric may be used as a tie-breaker in the presence
      of Equal Cost Multiple Paths (ECMP). The optimization of multiple
      metrics is known as an NP complete problem and is sometimes supported by
      some centralized path computation engine.</t>

      <t>In contrast, LLNs do require the support of both static and dynamic
      metrics. Furthermore, both link and node metrics are required. In the
      case of RPL, it is virtually impossible to define one metric, or even a
      composite, that will satisfy all use cases.</t>

      <t>In addition, RPL supports constrained-based routing where constraints
      may be applied to link and nodes. If a link or a node does not satisfy a
      required constraint, it is `pruned' from the candidate list thus leading
      to a constrained shortest path.</t>

      <t>The set of supported link/node constraints and metrics is specified
      in <xref target="I-D.ietf-roll-routing-metrics"></xref>.</t>

      <t>The role of the Objective Function is to advertise routing metrics
      and constraints in addition to the objectives used to compute the
      (constrained) shortest path.</t>

      <t><list hangIndent="11" style="hanging">
          <t hangText="Example 1:">Shortest path: path offering the shortest
          end-to-end delay</t>

          <t hangText="Example 2:">Constrained shortest path: the path that
          does traverse any battery-operated node and that optimizes the path
          reliability</t>
        </list></t>
    </section>

    <section anchor="SpecCore" title="RPL Protocol Specification">
      <section anchor="RPLMessages" title="RPL Messages">
        <section anchor="RPLControlMessage" title="ICMPv6 RPL Control Message">
          <t>This document defines the RPL Control Message, a new ICMPv6
          message. The RPL Control Message has the following general format,
          in accordance with <xref target="RFC4443"></xref>:</t>

          <t><figure anchor="ICMPFormat" title="RPL Control Message">
              <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                         Message Body                          +
    |                                                               |
]]></artwork>
            </figure></t>

          <t>The RPL Control message is an ICMPv6 information message with a
          requested Type of 155.</t>

          <t>The Code will be used to identify RPL Control Messages as
          follows:</t>

          <t><list style="symbols">
              <t>0x01: DAG Information Solicitation (<xref
              target="DAGInformationSolicitation"></xref>)</t>

              <t>0x02: DAG Information Object (<xref
              target="DAGInformationObject"></xref>)</t>

              <t>0x04: Destination Advertisement Object (<xref
              target="DestinationAdvertisementObject"></xref>)</t>
            </list></t>
        </section>

        <section anchor="DAGInformationSolicitation"
                 title="DAG Information Solicitation (DIS)">
          <t>The DAG Information Solicitation (DIS) message may be used to
          solicit a DAG Information Object from a RPL node. Its use is
          analogous to that of a Router Solicitation; a node may use DIS to
          probe its neighborhood for nearby DAGs. The DAG Information
          Solicitation carries no additional message body.</t>
        </section>

        <section anchor="DAGInformationObject"
                 title="DAG Information Object (DIO)">
          <t>The DAG Information Object carries a number of metrics and other
          information that allows a node to discover a DAG, select its DAG
          parents, and identify its siblings while employing loop avoidance
          strategies.</t>

          <section anchor="DIOBaseOption" title="DIO Base Option">
            <t>The DIO Base Option is a container option, which is always
            present, and might contain a number of suboptions. The base option
            regroups the minimum information set that is mandatory in all
            cases.</t>

            <t><figure anchor="DIObase" title="DIO Base Option">
                <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |G|D|A|0|0| Prf |   Sequence    |  InstanceID   |    DAGRank    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                            DAGID                              |
    +                                                               +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   sub-option(s)...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
              </figure></t>

            <t><list hangIndent="6" style="hanging">
                <t hangText="Control Field:">The DAG Control Field is
                currently allocated as follows: <list hangIndent="6"
                    style="hanging">
                    <t hangText="Grounded (G):">The Grounded (G) flag is set
                    when the DAG root is offering connectivity to an external
                    routed infrastructure such as the Internet.</t>

                    <t hangText="Destination Advertisement Trigger (D):">The
                    Destination Advertisement Trigger (D) flag is set when the
                    DAG root or another node in the successor chain decides to
                    trigger the sending of destination advertisements in order
                    to update routing state for the outward direction along
                    the DAG, as further detailed in <xref
                    target="DestinationAdvertisement"></xref>. Note that the
                    use and semantics of this flag are still under
                    investigation.</t>

                    <t hangText="Destination Advertisement Supported (A):">The
                    Destination Supported (A) bit is set when the DAG root is
                    capable to support the collection of destination
                    advertisement related routing state and enables the
                    operation of the destination advertisement mechanism
                    within the DAG.</t>

                    <t hangText="DAGPreference (Prf):">3-bit unsigned integer
                    set by the DAG root to its preference and unchanged at
                    propagation. DAGPreference ranges from 0x00 (least
                    preferred) to 0x07 (most preferred). The default is 0
                    (least preferred). The DAG preference provides an
                    administrative mechanism to engineer the self-organization
                    of the LLN, for example indicating the most preferred LBR.
                    If a node has the option to join a more preferred DAG
                    while still meeting other optimization objectives, then
                    the node will generally seek to join the more preferred
                    DAG as determined by the OF.</t>
                  </list></t>

                <t>Unassigned bits of the Control Field are considered as
                reserved. They MUST be set to zero on transmission and MUST be
                ignored on receipt.</t>

                <t hangText="Sequence Number:">8-bit unsigned integer set by
                the DAG root, incremented according to a policy provisioned at
                the DAG root, and propagated with no change outwards along the
                DAG. Each increment SHOULD have a value of 1 and may cause a
                wrap back to zero.</t>

                <t hangText="InstanceID:">8-bit field indicating the topology
                instance associated with the DAG, as provisioned at the DAG
                root.</t>

                <t hangText="DAGRank:">8-bit unsigned integer indicating the
                DAG rank of the node sending the DIO message. The DAGRank of
                the DAG root is ROOT_RANK. DAGRank is further described in
                <xref target="DAGDiscovery"></xref>.</t>

                <t hangText="DAGID:">128-bit unsigned integer which uniquely
                identify a DAG. This value is set by the DAG root. The global
                IPv6 address of the DAG root can be used, however. the DAGID
                MUST be unique per DAG within the scope of the LLN. In the
                case where a DAG root is rooting multiple DAGs the DAGID MUST
                be unique for each DAG rooted at a specific DAG root.</t>
              </list></t>

            <t>The following values MUST NOT change during the propagation of
            DIO messages outwards along the DAG:<?rfc subcompact="yes"?><list>
                <t>Grounded (G)</t>

                <t>Destination Advertisement Supported (A)</t>

                <t>DAGPreference (Prf)</t>

                <t>Sequence</t>

                <t>InstanceID</t>

                <t>DAGID</t>
              </list><?rfc subcompact="no"?>All other fields of the DIO
            message may be updated at each hop of the propagation.</t>

            <section title="DIO Suboptions">
              <t>In addition to the minimum options presented in the base
              option, several suboptions are defined for the DIO message:</t>

              <section title="Format">
                <t><figure anchor="DIOsub"
                    title="DIO Suboption Generic Format">
                    <artwork><![CDATA[
     0                   1                   2      
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
    |  Subopt. Type |         Subopt Length         | Subopt Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
]]></artwork>
                  </figure></t>

                <t><list hangIndent="6" style="hanging">
                    <t hangText="Suboption Type:">8-bit identifier of the type
                    of suboption. When processing a DIO message containing a
                    suboption for which the Suboption Type value is not
                    recognized by the receiver, the receiver MUST silently
                    ignore the unrecognized option, continue to process the
                    following suboption, correctly handling any remaining
                    options in the message.</t>

                    <t hangText="Suboption Length:">16-bit unsigned integer,
                    representing the length in octets of the suboption, not
                    including the suboption Type and Length fields.</t>

                    <t hangText="Suboption Data:">A variable length field that
                    contains data specific to the option.</t>
                  </list></t>

                <t>The following subsections specify the DIO message
                suboptions which are currently defined for use in the DAG
                Information Object.</t>

                <t>Implementations MUST silently ignore any DIO message
                suboptions options that they do not understand.</t>

                <t>DIO message suboptions may have alignment requirements.
                Following the convention in IPv6, these options are aligned in
                a packet such that multi-octet values within the Option Data
                field of each option fall on natural boundaries (i.e., fields
                of width n octets are placed at an integer multiple of n
                octets from the start of the header, for n = 1, 2, 4, or
                8).</t>
              </section>

              <section title="Pad1">
                <t>The Pad1 suboption does not have any alignment
                requirements. Its format is as follows:</t>

                <t><figure anchor="DIOsubPad1" title="Pad 1">
                    <artwork><![CDATA[
     0
     0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+
    |   Type = 0    |
    +-+-+-+-+-+-+-+-+
]]></artwork>
                  </figure></t>

                <t>NOTE! the format of the Pad1 option is a special case - it
                has neither Option Length nor Option Data fields.</t>

                <t>The Pad1 option is used to insert one or two octets of
                padding in the DIO message to enable suboptions alignment. If
                more than two octets of padding is required, the PadN option,
                described next, should be used rather than multiple Pad1
                options.</t>
              </section>

              <section title="PadN">
                <t>The PadN option does not have any alignment requirements.
                Its format is as follows:</t>

                <t><figure anchor="DIOsubPadN" title="Pad N">
                    <artwork><![CDATA[
     0                   1                   2      
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
    |   Type = 1    |         Subopt Length         | Subopt Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
]]></artwork>
                  </figure></t>

                <t>The PadN option is used to insert three or more octets of
                padding in the DIO message to enable suboptions alignment. For
                N (N &gt; 2) octets of padding, the Option Length field
                contains the value N-3, and the Option Data consists of N-3
                zero-valued octets. PadN Option data MUST be ignored by the
                receiver.</t>
              </section>

              <section title="DAG Metric Container">
                <t>The DAG Metric Container suboption may be aligned as
                necessary to support its contents. Its format is as
                follows:</t>

                <t><figure anchor="DIOsubLLNMetric"
                    title="DAG Metric Container">
                    <artwork><![CDATA[
     0                   1                   2      
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
    |   Type = 2    |       Container Length        | DAG Metric Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
]]></artwork>
                  </figure></t>

                <t>The DAG Metric Container is used to report aggregated path
                metrics along the DAG. The DAG Metric Container may contain a
                number of discrete node, link, and aggregate path metrics as
                chosen by the implementer. The Container Length field contains
                the length in octets of the DAG Metric Data. The order,
                content, and coding of the DAG Metric Container data is as
                specified in <xref
                target="I-D.ietf-roll-routing-metrics"></xref>.</t>

                <t>The processing and propagation of the DAG Metric Container
                is governed by implementation specific policy functions.</t>
              </section>

              <section title="Destination Prefix">
                <t>The Destination Prefix suboption does not have any
                alignment requirements. Its format is as follows:</t>

                <t><figure anchor="DIOsubDestinationPrefix"
                    title="DAG Destination Prefix">
                    <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 3    |            Length             |Resvd|Prf|Resvd|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        Prefix Lifetime                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Prefix Length |                                               |
    +-+-+-+-+-+-+-+-+                                               |
    |             Destination Prefix (Variable Length)              |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
                  </figure></t>

                <t>The Destination Prefix suboption is used when the DAG root,
                or another node located inwards along the DAG on the path to
                the DAG root, needs to indicate that it offers connectivity to
                destination prefixes other than the default. This may be
                useful in cases where more than one LBR is operating within
                the LLN and offering connectivity to different administrative
                domains, e.g. a home network and a utility network. In such
                cases, upon observing the Destination Prefixes offered by a
                particular DAG, a node MAY decide to join multiple DAGs in
                support of a particular application.</t>

                <t>The Length is coded as the length of the suboption in
                octets, excluding the Type and Length fields.</t>

                <t>Prf is the Route Preference as in <xref
                target="RFC4191"></xref>. The reserved fields MUST be set to
                zero on transmission and MUST be ignored on receipt.</t>

                <t>The Prefix Lifetime is a 32-bit unsigned integer
                representing the length of time in seconds (relative to the
                time the packet is sent) that the Destination Prefix is valid
                for route determination. A value of all one bits (0xFFFFFFFF)
                represents infinity. A value of all zero bits (0x00000000)
                indicates a loss of reachability.</t>

                <t>The Prefix Length is an 16-bit unsigned integer that
                indicates the number of leading bits in the destination
                prefix.</t>

                <t>The Destination Prefix contains Prefix Length significant
                bits of the destination prefix. The remaining bits of the
                Destination Prefix, as required to complete the trailing
                octet, are set to 0.</t>

                <t>In the event that a DIO message may need to specify
                connectivity to more than one destination, the Destination
                Prefix suboption may be repeated.</t>
              </section>

              <section title="DAG Timer Configuration">
                <t>The DAG Timer Configuration suboption does not have any
                alignment requirements. Its format is as follows:</t>

                <t><figure anchor="DIOsubDAGTimerConfig"
                    title="DAG Timer Configuration">
                    <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 4    |            Length             | DIOIntDoubl.  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  DIOIntMin.   |
    +-+-+-+-+-+-+-+-+
]]></artwork>
                  </figure></t>

                <t>The DAG Timer Configuration suboption is used to distribute
                configuration information for DAG Timer Operation through the
                DAG. The information communicated in this suboption is
                generally static and unchanging within the DAG, therefore it
                is not necessary to include in every DIO. This suboption MAY
                be included periodically by the DAG Root, and SHOULD be
                included in response to a unicast request, e.g. a DAG
                Information Solicitation (DIS) message.</t>

                <t>The Length is coded as 2.</t>

                <t>DIOIntervalDoublings is an 8-bit unsigned integer.
                Configured on the DAG root and used to configure the trickle
                timer governing when DIO message should be sent within the
                DAG. DIOIntervalDoublings is the number of times that the
                DIOIntervalMin is allowed to be doubled during the trickle
                timer operation.</t>

                <t>DIOIntervalMin is an 8-bit unsigned integer. Configured on
                the DAG root and used to configure the trickle timer governing
                when DIO message should be sent within the DAG. The minimum
                configured interval for the DIO trickle timer in units of ms
                is 2^DIOIntervalMin. For example, a DIOIntervalMin value of
                16ms is expressed as 4.</t>
              </section>
            </section>
          </section>
        </section>

        <section anchor="DestinationAdvertisementObject"
                 title="Destination Advertisement Object (DAO)">
          <t>The Destination Advertisement Object (DAO) is used to propagate
          destination information inwards along the DAG. The RPL use of the
          DAO allows the nodes in the DAG to build up routing state for nodes
          contained in the sub-DAG in support of traffic flowing outward along
          the DAG.</t>

          <t><figure anchor="DAObject"
              title="The Destination Advertisement Object (DAO)">
              <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |         DAO Sequence          |  InstanceID   |   DAO Rank    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          DAO Lifetime                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           Route Tag                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Prefix Length |    RRCount    |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
    |                   Prefix (Variable Length)                    |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Reverse Route Stack (Variable Length)             |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
            </figure></t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="DAO Sequence:">Incremented by the node that owns
              the prefix for each new DAO message for that prefix.</t>

              <t hangText="InstanceID:">8-bit field indicating the topology
              instance associated with the DAG, as learned from the DIO.</t>

              <t hangText="DAO Rank:">Set by the node that owns the prefix and
              first issues the DAO message to its rank.</t>

              <t hangText="DAO Lifetime:">32-bit unsigned integer. The length
              of time in seconds (relative to the time the packet is sent)
              that the prefix is valid for route determination. A value of all
              one bits (0xFFFFFFFF) represents infinity. A value of all zero
              bits (0x00000000) indicates a loss of reachability.</t>

              <t hangText="Route Tag:">32-bit unsigned integer. The Route Tag
              may be used to give a priority to prefixes that should be
              stored. This may be useful in cases where intermediate nodes are
              capable of storing a limited amount of routing state. The
              further specification of this field and its use is under
              investigation.</t>

              <t hangText="Prefix Length:">Number of valid leading bits in the
              IPv6 Prefix.</t>

              <t hangText="RRCount:">8-bit unsigned integer. This counter is
              used to count the number of entries in the Reverse Route Stack.
              A value of `0' indicates that no Reverse Route Stack is
              present.</t>

              <t hangText="Prefix:">Variable-length field containing an IPv6
              address or a prefix of an IPv6 address. The Prefix Length field
              contains the number of valid leading bits in the prefix. The
              bits in the prefix after the prefix length (if any) are reserved
              and MUST be set to zero on transmission and MUST be ignored on
              receipt.</t>

              <t hangText="Reverse Route Stack:">Variable-length field
              containing a sequence of RRCount (possibly compressed) IPv6
              addresses. A node that adds on to the Reverse Route Stack will
              append to the list and increment the RRCount.</t>
            </list></t>
        </section>
      </section>

      <section anchor="ConceptualDataStructures"
               title="Conceptual Data Structures">
        <t>The RPL implementation MUST maintain the following conceptual data
        structures in support of DAG discovery:</t>

        <t><list style="symbols">
            <t>A set of candidate neighbors</t>

            <t>For each DAG:</t>

            <list>
              <t>A set of DAG parents and siblings</t>
            </list>
          </list></t>

        <section title="Candidate Neighbors Data Structure">
          <t>The set of candidate neighbors is to be populated by neighbors
          that are discovered by the neighbor discovery mechanism and further
          qualified as statistically stable as per the mechanisms discussed in
          <xref target="I-D.ietf-roll-routing-metrics"></xref>. The candidate
          neighbors, and related metrics, should demonstrate
          stability/reliability beyond a certain threshold, and it is
          recommended that a local confidence value be maintained with respect
          to the neighbor in order to track this. Implementations MAY choose
          to bound the maximum size of the candidate neighbor set, in which
          case a local confidence value will assist in ordering neighbors to
          determine which ones should remain in the candidate neighbor set and
          which should be evicted.</t>

          <t>If Neighbor Unreachability Detection (NUD) determines that a
          candidate neighbor is no longer reachable, then it shall be removed
          from the candidate neighbor set. In the case that the candidate
          neighbor has associated states in the DAG parent set or active DA
          entries, then the removal of the candidate neighbor shall be
          coordinated with tearing down these states. All provisioned routes
          associated with the candidate neighbor should be removed.</t>
        </section>

        <section title="Directed Acyclic Graphs (DAGs) Data Structure">
          <t>At a given point of time, a DAG Iteration is uniquely identified
          by the tuple (DagID, InstanceID, DAGSequenceNumber) where a change
          in the sequence denotes the iteration of a given DAG over time. When
          a single device is capable to root multiple DAGs in support of an
          application need for multiple optimization objectives it MUST
          produce a different and unique (DagID, InstanceID) pair for each of
          the multiple DAGs.</t>

          <t>For each DAG that a node is, or may become, a member of, the
          implementation MUST keep a DAG table with the following entries:</t>

          <t>
            <list style="symbols">
              <t>InstanceID</t>

              <t>DAGID</t>

              <t>DAGSequenceNumber</t>

              <t>DAG Metric Container, including DAGObjectiveCodePoint</t>

              <t>A set of Destination Prefixes offered inwards along the
              DAG</t>

              <t>A set of DAG parents and siblings</t>

              <t>A timer to govern the sending of DIO messages for the DAG</t>
            </list>
          </t>

          <t>When a DAG is discovered for which no DAG data structure is
          instantiated, and the node wants to join, then the DAG data
          structure is instantiated.</t>

          <t>When the DAG parent set is depleted (i.e. the last DAG is
          removed), then the DAG data structure SHOULD be suppressed after the
          expiration of an implementation-specific local timer. An
          implementation SHOULD delay before deallocating the DAG data
          structure in order to observe that the DAGSequenceNumber has
          incremented should any new DAG parents appear for the DAG.</t>

          <section title="DAG Parents/Siblings Structure">
            <t>When the DAG is self-rooted, the set of DAG parents/siblings is
            empty.</t>

            <t>In all other cases, for each node in the set, the
            implementation MUST keep a record of:</t>

            <t>
              <list style="symbols">
                <t>a reference to the neighboring device which is the DAG
                parent or sibling</t>

                <t>a record of most recent information taken from the DAG
                Information Object last processed from the DAG parent</t>
              </list>
            </t>

            <t>DAG parents may be ordered, according to the OF. When ordering
            DAG parents, in consultation with the OF, the most preferred DAG
            parent may be identified. All current DAG parents must have a rank
            less than self. All current DAG siblings must have a rank equal to
            self.</t>

            <t>When nodes are added to or removed from the DAG set the most
            preferred DAG parent may have changed. The role of all the nodes
            in the list should be reevaluated. In particular, any nodes having
            a rank greater than self after such a change must be evicted from
            the set.</t>
          </section>

          <t>An implementation may choose to keep these records as an
          extension of the Default Router List (DRL).</t>
        </section>
      </section>

      <section anchor="DAGRank" title="DAG Rank">
        <t>Based on the selection of DAG Parents, the metrics conveyed by the
        most preferred DAG parent, the nodes own metrics and configuration,
        and a related function defined by the OF, a node will be able to
        compute a value for its rank as a consequence of selecting a most
        preferred DAG parent.</t>

        <t>The rank value feeds back into the DAG parent selection according
        to a loop-avoidance strategy. Once a DAG parent has been added, and a
        rank value for the node within the DAG has been computed, the nodes
        further options with regard to DAG parent selection and movement
        within the DAG are restricted in favor of loop avoidance.</t>

        <t>It is important to note that the DAG Rank is not itself a metric,
        although its value is derived from and influenced by the use of
        metrics to select DAG parents and take up a position in the DAG. The
        only aim of the rank is to inform loop avoidance and detection.</t>

        <t>The computation of the DAG Rank MUST be done in such a way so as to
        maintain the following properties for any nodes M and N that are
        neighbors in the LLN:</t>

        <t><list hangIndent="8" style="hanging">
            <t hangText="DAGRank(M) is less than DAGRank(N):">In this case, M
            is probably located in a more preferred position than N in the DAG
            with respect to the metrics and optimizations defined by the
            objective code point. In any fashion, Node M may safely be a DAG
            parent for Node N without risk of creating a loop. Further, for a
            node N, all parents in the DAG parent set must be of rank less
            than self's DAGRank(N). In other words, the rank presented by a
            node N MUST be greater (deeper) than that presented by any of its
            parents.<!--<list>
                    <t>For example, a Node M of rank 3 is likely located in a
                    more optimum position than a Node N of rank 5. A packet
                    directed inwards and forwarded from Node N to Node M will
                    always make forward progress with respect to the DAG
                    organization on that link; there is no risk of Node M at
                    rank 3 forwarding the packet back into Node N's sub-DAG at
                    rank of 5 or greater (which would be a sufficient
                    condition for a loop to occur).</t>
                  </list>--></t>

            <t hangText="DAGRank(M) equals DAGRank(N):">In this case M and N
            are located positions of relatively the same optimality within the
            DAG. In some cases, Node M may be used as a successor by Node N,
            but with related chance of creating a loop that must be detected
            and broken by some other means.<!-- <list>
                    <t>If Node M is at rank 3 and node N is at rank 3, then
                    they are siblings; by definition Node M and N cannot be in
                    each others sub-DAG. They may then forward to each other
                    failing serviceable parents, making `sideways' progress
                    (but not reverse progress). If another sibling or more
                    gets involved there may then be some chance for 3 or more
                    way loops, which is the risk of sibling forwarding.</t>
                  </list>--></t>

            <t hangText="DAGRank(M) is greater than DAGRank(N):">In this case,
            then node M is located in a less preferred position than N in the
            DAG with respect to the metrics and optimizations defined by the
            objective code point. Further, Node (M) may in fact be in Node
            (N)'s sub-DAG. There is a higher risk to Node (N) selecting Node
            (M) as a DAG parent, as such a selection may create a loop.<!--<list>
                    <t>For example, if Node M is of rank 3 and Node N is of
                    rank 5, then by definition Node N is in a less optimum
                    position than Node N. Further, Node N at rank 5 may in
                    fact be in Node M's own sub-DAG, and forwarding a packet
                    directed inwards towards the DAG root from M to N will
                    result in backwards progress and possibly a loop.</t>
                  </list>--></t>
          </list></t>

        <t>As an example, the DAG Rank could be computed in such a way so as
        to closely track ETX when the objective function is to minimize ETX,
        or latency when the objective function is to minimize latency, or in a
        more complicated way as appropriate to the objective code point being
        used within the DAG.</t>
      </section>

      <section anchor="DAGDiscovery" title="DAG Discovery and Maintenance">
        <t>DAG discovery locates the nearest sink (aka root), as determined
        according to some metrics and constraints, and forms a Directed
        Acyclic Graph towards that sink, by identifying a set of DAG parents.
        During this process DAG discovery also identifies siblings, which may
        be used later to provide additional path diversity towards the DAG
        root. DAG discovery enables nodes to implement different policies for
        selecting their DAG parents in the DAG by using implementation
        specific policy functions. DAG discovery specifies a set of rules to
        be followed by all implementations in order to ensure interoperation.
        DAG discovery also standardizes the format that is used to advertise
        the most common information that is used in order to select DAG
        parents.</t>

        <t>One of these information, the DAG rank, is used by DAG discovery to
        provide loop avoidance even if nodes implement different policies. The
        DAG Rank is computed as specified by the OF in use by the DAG,
        demonstrating the properties described in <xref
        target="DAGRank"></xref>. The rank should be computed in such a way so
        as to provide a comparable basis with other nodes which may not use
        the same metric at all.</t>

        <t>The DAG discovery procedures take into account a number of factors,
        including:</t>

        <t><list style="symbols">
            <t>RPL rules for loop avoidance based on DAGs and ranks</t>

            <t>The Objective Function</t>

            <t>The advertised metrics</t>

            <t>Local policy functions (e.g. a bounded number of candidate
            neighbors).</t>
          </list></t>

        <section anchor="DAGDiscoveryRules" title="DAG Discovery Rules">
          <t>In order to organize and maintain loopless structure, the DAG
          discovery implementation in the nodes MUST obey to the following
          rules and definitions:</t>

          <section anchor="DAGDiscoveryRulesDAD" title="DAGs">
            <t><list style="numbers">
                <t>DAG discovery instantiates LLN topologies that are each
                optimized for specific constraints and goals. A topology
                assumes the shape of a DAG, and a DAG Instance is uniquely
                identified by its instanceID.</t>

                <t>For reasons of scalability and operations of the protocol,
                a DAG Instance is partitioned into a set of DAGs rooted at a
                destination, aka Destination Oriented DAGs. A destination is
                uniquely identified by a DAGID so a DAG rooted at a
                destination is uniquely identified by the pair (InstanceID,
                DAGID).</t>

                <t>A Destination Oriented DAG is periodically reconstructed
                from the root, by incrementing a DAGSequenceNumber. An
                Iteration of a Destination Oriented DAG is thus uniquely
                identified by the tuple (InstanceID, DAGID,
                DAGSequenceNumber). Through this document, the graph formed by
                this iterative process is referred to as the DAG Iteration, or
                in short, the DAG.</t>

                <t>The rank is defined within the scope of a DAG Iteration as
                an abstract coordinate to compare the relative position of
                nodes and ensure forward progress of the traffic.</t>

                <t>A node MUST belong at most to one DAG Iteration per
                InstanceID and MUST select all its parents and siblings within
                that same DAG Iteration.</t>
              </list></t>
          </section>

          <section anchor="DAGDiscoveryRulesSeq" title="DAG Sequence Number">
            <t><list style="numbers">
                <t>The DAGSequenceNumber is incremented by the root and
                flooded through DIOs.</t>

                <t>The root floods a new DAGSequenceNumber periodically, at a
                rate that depends on the deployment. This rate can be set to 0
                if other methods such as loop detection are considered
                sufficient to solve the routing issues in that deployment.</t>

                <t>The root MAY also flood a new DAGSequenceNumber on-demand.
                The details of the mechanism to signal the root to do so are
                to be specified in a future revision of this document.</t>

                <t>A parent that advertises the new DAGSequenceNumber can not
                possibly belong to the sub-DAG of a node that still advertises
                an older DAGSequenceNumber. The node MAY thus attach to that
                parent regardless of the relative rank, and this situation is
                equivalent to jumping onto a different Destination Oriented
                DAG.</t>

                <t>Thus, as a new DAGSequenceNumber spreads, a new DAG
                Iteration forms that supersedes the previous one. During a
                DAGSequenceNumber transition, a node MAY decide to forward
                packets via 'future parents' that belong to the same
                Destination Oriented DAG (same InstanceID and DagID), but a
                more recent (incremented) DAGSequenceNumber.</t>
              </list></t>
          </section>

          <section anchor="DAGDiscoveryRulesRoot" title="DAG Root">
            <t><list style="numbers">
                <t>A node that does not have any DAG parent MAY become the
                root of its own floating DAG. It's rank is ROOT_RANK.</t>

                <t>A (non-LLN) router is considered connected to a grounded
                infrastructure at rank BASE_RANK. A LLN node that is attached
                to such an infrastructure router is the DAG root of its own
                grounded DAG. It's rank is ROOT_RANK.</t>

                <t>In a deployment that uses a backbone link to federate a
                number of LLN roots, it is possible to run RPL over the
                backbone and use one router as a backbone root. The backbone
                root exposes a rank of BASE_RANK over the backbone. All the
                LLN roots that are parented to that backbone root, including
                the backbone root if it also serves as LLN root, expose a rank
                of ROOT_RANK over the LLN and act as multiple roots for a same
                DAG, coordinated by the backbone root.</t>

                <t>The DAG root exposes the DAG in the DIO message and LLN
                nodes propagate the DIO message outwards along the DAG.</t>
              </list></t>
          </section>

          <section anchor="DAGDiscoveryRulesMove" title="Moving Inside a DAG">
            <t><list style="numbers">
                <t>A node moves when it changes its parent selection within
                the same DAG Iteration. When a node moves (within its DAG) in
                a fashion that cause its rank to decrease, the node MUST
                abandon all parents and siblings with a rank larger than self,
                and MAY adopt as siblings nodes with the same rank.</t>

                <t>A node MAY move at any time, with no delay, within its DAG
                when the move does not cause the node to increase its own DAG
                rank, as per the rank calculation indicated by the OF.</t>

                <t>A node MUST NOT move outwards along a DAG that it is
                attached to, causing the DAG rank to increase. If a node
                cannot stay within the DAG without a rank increase, then it
                MUST poison its routes as described in <xref
                target="DAGDiscoveryRulesdetach"></xref>.</t>

                <t>When DIO messages are received from other routers located
                at lesser rank in the same DAG, those routers are eligible for
                consideration as DAG parents. DIO messages received from other
                routers located at the same rank in the same DAG may be
                considered as coming from siblings. DIO messages that are
                received from other routers located at greater rank within the
                same DAG might cause greedy behaviors and loops; such a DIO is
                ignored unless: <list style="numbers">
                    <t>The DIO comes from an existing parent or sibling; in
                    which case that parent must be removed.</t>

                    <t>The DIO comes from a node that has better OF ratings
                    than any parent known at this point; in that case, this
                    potential parent MAY be remembered in order to jump at a
                    better position when the next sequence is flooded.</t>
                  </list></t>
              </list></t>
          </section>

          <section anchor="DAGDiscoveryRulesJump"
                   title="Jumping Onto Another DAG">
            <t><list style="numbers">
                <t>A node jumps when it performs a new parent selection
                whereby its DAG Iteration changes within the same DAG
                Instance. When a node jumps onto a new DAG Iteration, it MUST
                abandon all parents and siblings from its previous
                position.</t>

                <t>A node MAY jump from its current DAG onto any other DAG
                that provides service for the same InstanceID if it is
                preferred by the OF, for example for reasons such as
                connectivity, configured preference, free medium time, size,
                security, bandwidth, DAG rank, or whatever metrics the LLN
                uses. This is allowed regardless of the rank that the node
                reaches in the new DAG.</t>

                <!-- TBD turn this into an implementation note? 
                <t>If a node has selected a new set of DAG parents but has not
                jumped yet (because it is waiting for DAG Hop timer to
                elapse), the node is UNSTABLE and MUST NOT send DIOs for that
                DAG.</t>
                -->

                <t>A node that jumps should attempt to transmit all the
                packets received as part of the previous DAG along the
                previous DAG. In other words, it should switch the parent set
                only after the outstanding packet queue of packets received
                prior to announcing the jump is exhausted.</t>

                <t>Jumping back onto a previous DAG <!--within a short period of time -->
                is equivalent to moving inside that DAG and obeys the same
                rules. <!--That period of time must be sufficient for DIOs that advertise the
                          previous situation to have spread so that the probability is high 
                          that the node does not jump back into its own sub-DAG. -->
                To satisfy this, a node detaching from a DAG SHOULD remember
                its DAG as identified by the tuple (InstanceID, DagID,
                DAGSequenceNumber) as well as its rank within that DAG for
                long as that DAG exists.<!--    TBD      In practice, the node needs not maintain its history information
                forever, but for such a period of time as it can be expected
                that the risk of forming loops is reduced sufficiently by the
                                propagation of the route poisoning described in 
                                <xref target="DAGDiscoveryRulesdetach"/>. --></t>
              </list></t>
          </section>

          <section anchor="DAGDiscoveryRulesdetach"
                   title="Poisoning a Broken Path">
            <t><list style="numbers">
                <t>A node SHOULD poison its inwards routes when it looses all
                of its current feasible parents, i.e. the set of DAG parents
                becomes depleted, and it can not jump onto an alternate
                DAG.</t>

                <t>In order to poison its inwards routes, a node MAY stay at
                its position within its DAG (that is maintain its InstanceID,
                DagID, DAGSequenceNumber and Rank) but it SHOULD immediately
                advertise a rank of INFINITE_RANK in a DIO so as to force all
                its children to remove it from their parent list and try an
                alternate path. The node SHOULD then wait for a new DAG
                Iteration (DAGSequenceNumber increment) before resuming its
                operation in the same Destination Oriented DAG.<!-- For the same
                constraints, the node might not be able to support the DAG Hop
                Timer and it MAY move or jump at anytime and without a
                wait.--></t>

                <t>Alternatively, a node MAY detach from its DAG. A node that
                detaches becomes root of its own floating DAG and MUST
                immediately advertise its new situation in a DIO.</t>

                <t>Either way, the route poisoning will recursively be flooded
                throughout the impacted sub-DAG as children lose their last
                parent in the original DAG.</t>

                <t>The loss of a DIO message may interrupt the flooding. This
                can be compensated by cheer repetition through the trickle
                algorithm. If that also fails, packet loops will be prevented
                by the detection mechanism described in <xref
                target="loopdetect"></xref>.</t>
              </list></t>
          </section>

          <section anchor="DAGDiscoveryRulesfollow" title="Following a Parent">
            <t><list style="numbers">
                <t>If a node that receives a DIO from one of its DAG parents
                indicating that the parent has left the DAG, it may either
                follow that parent or stay in its current DAG through an
                alternate DAG parent if that is possible.<!-- The node may follow
                its parent without a wait in order to prevent packet loss.--></t>

                <t>If a DAG parent increases its rank such that the node rank
                would have to change, and if the node does not wish to follow
                (e.g. it has alternate options), then the DAG parent SHOULD be
                evicted from the DAG parent set. If the DAG parent is the last
                in the DAG parent set, then the node SHOULD chose to follow
                it.</t>
              </list></t>
          </section>

          <section anchor="DAGDiscoveryRulesincons" title="DAG Inconsistency">
            <t><list style="numbers">
                <t>When a node detects or causes a DAG inconsistency, as
                described in <xref target="TrickleInconsistencies"></xref>,
                then the node SHOULD send an unsolicited DIO message to its
                one-hop neighbors. The DIO is updated to propagate the new DAG
                information. Such an event MUST also cause the trickle timer
                governing the periodic sending of DIO messages to be
                reset.</t>
              </list></t>
          </section>
        </section>

        <section title="Reception and Processing of DIO messages">
          <t>When an DIO message is received from a source device named SRC,
          the receiving node must first determine whether or not the DIO
          message should be accepted for further processing, and subsequently
          present the DIO message for further processing if eligible.</t>

          <t>
            <list style="numbers">
              <t>If the DIO message is malformed, then the DIO message is not
              eligible for further processing and is silently discarded. A RPL
              implementation MAY log the reception of a malformed DIO
              message.</t>

              <t>If SRC is not a member of the candidate neighbor set, then
              the DIO is not eligible for further processing. (Further
              evaluation/confidence of this neighbor is necessary)</t>

              <t>If the DIO message advertises a DAG that the node is already
              a member of, then:</t>

              <list style="symbols">
                <t>If the rank of SRC as reported in the DIO message is lesser
                than that of the node within the DAG, then the DIO message
                MUST be considered for further processing.</t>

                <t>If the rank of SRC as reported in the DIO message is equal
                to that of the node within the DAG, then SRC is marked as a
                sibling and the DIO message is not eligible for further
                processing.</t>

                <t>If the rank of SRC as reported in the DIO message is higher
                than that of the node within the DAG, and SRC is not a DAG
                parent, then the DIO message MUST NOT be considered for
                further processing</t>
              </list>

              <t>Even if not processed further, information from a DIO might
              be remembered for instance if SRC is preferable to the current
              parents per the OF selection process.</t>

              <t>If SRC is a DAG parent for any other DAG that the node is
              attached to, then the DIO message MUST be considered for further
              processing (the DAG parent may have jumped).</t>

              <t>If the DIO message advertises a DAG that offers a better (new
              or alternate) solution to an optimization objective desired by
              the node, then the DIO message MUST be considered for further
              processing.</t>
            </list>
          </t>

          <section title="Overview of DIO Message Processing">
            <t>
              <list>
                <t>If the received DIO message is for a new/alternate DAG:</t>

                <list>
                  <t>If the node has sent an DIO message within the risk
                  window as described in <xref target="DAGCollision" /> then a
                  collision has occurred; do not process the DIO message any
                  further.</t>

                  <t>If the SRC node is also a DAG parent for another DAG that
                  the node is a member of, and if the new/alternate DAG is the
                  same InstanceID as the other DAG, then the DAG parent is
                  known to have jumped.</t>

                  <list>
                    <t>Remove SRC as a DAG parent from the other DAG</t>

                    <t>If the other DAG is now empty of candidate parents,
                    then prepare to directly follow SRC into the new DAG by
                    adding it as a DAG parent for the new DAG, else ignore the
                    DIO message (do not follow the parent).</t>
                  </list>

                  <t>Instantiate a data structure for the new/alternate DAG if
                  necessary</t>

                  <t>If the new/alternate DAG offers a better solution to the
                  optimization objectives, then jump: copy the DIO information
                  place the neighbor into the DAG parent set.</t>
                </list>

                <t>If the DIO message is for a known/existing DAG:</t>

                <list>
                  <t>Process the DIO message as per the rules in <xref
                  target="DAGDiscovery" /></t>
                </list>
              </list>
            </t>
          </section>

          <t>As DIO messages are received from candidate neighbors, the
          neighbors may be promoted to DAG parents by following the rules of
          DAG discovery as described in <xref target="DAGDiscovery" />. When a
          node places a neighbor into the DAG Parent set, the node becomes
          attached to the DAG through the new parent node.</t>

          <t>In the DAG discovery implementation, the most preferred parent
          should be used to restrict which other nodes may become DAG parents.
          Some nodes in the DAG parent set may be of a rank less than or equal
          to the most preferred DAG parent. (This case may occur, for example,
          if an energy constrained device is at a lesser rank but should be
          avoided as per an optimization objective, resulting in a more
          preferred parent at a greater rank).</t>
        </section>

        <section title="DIO Transmission">
          <t>Each node maintains a timer that governs when to multicast DIO
          messages. This timer is implemented as a trickle timer operating
          over a variable interval. Trickle timers are further detailed in
          <xref target="TrickleImplementation"></xref>. The governing
          parameters for the timer should be configured consistently across
          the DAG, and are provided by the DAG root in the DIO message. In
          addition to periodic DIO messages, each node may respond to a DIS
          message with a DIO message.</t>

          <t><list style="symbols">
              <t>When a node detects an inconsistency, it SHOULD reset the
              interval of the trickle timer to a minimum value, causing DIO
              messages to be emitted more frequently as part of a strategy to
              quickly correct the inconsistency. Such inconsistencies may be,
              for example, an update to a key parameter (e.g. sequence number)
              in the DIO message or a loop detected when a node located
              inwards along the DAG forwards traffic outwards. Inconsistencies
              are further detailed in <xref
              target="TrickleInconsistencies"></xref>.</t>

              <t>When a node enters a mode of consistent operation within a
              DAG, i.e. DIO messages from its DAG parents are consistent and
              no other inconsistencies are detected, it may begin to open up
              the interval of the trickle timer towards a maximum value,
              causing DIO messages to be emitted less frequently, thus
              reducing network maintenance overhead and saving energy
              consumption.</t>

              <t>When a node is initialized, it MAY be configured to remain
              silent and not multicast any DIO messages until it has
              encountered and joined a DAG (perhaps initially probing for a
              nearby DAG with an DIS message). Alternately, it may choose to
              root its own floating DAG and begin multicasting DIO messages
              using a default trickle configuration. The second case may be
              advantageous if it is desired for independent nodes to begin
              aggregating into scattered floating DAGs in the absence of a
              grounded node, for example in support of LLN installation and
              commissioning.</t>
            </list></t>

          <t>Note that if multiple DAG roots are participating in the same
          DAG, i.e. offering DIO messages with the same DAGID, then they must
          coordinate with each other to ensure that their DIO messages are
          consistent when they emit DIO messages. In particular the Sequence
          number must be identical from each DAG root, regardless of which of
          the multiple DAG roots issues the DIO message, and changes to the
          Sequence number should be issued at the same time. The specific
          mechanism of this coordination, e.g. along a non-LLN network between
          DAG roots, is beyond the scope of this specification.</t>
        </section>

        <section anchor="TrickleImplementation"
                 title="Trickle Timer for DIO Transmission">
          <t>RPL treats the construction of a DAG as a consistency problem,
          and uses a trickle timer <xref target="Levis08"></xref> to control
          the rate of control broadcasts.</t>

          <t>For each DAG that a node is part of, the node must maintain a
          single trickle timer. The required state contains the following
          conceptual items:</t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="I:">The current length of the communication
              interval</t>

              <t hangText="T:">A timer with a duration set to a random value
              in the range [I/2, I]</t>

              <t hangText="C:">Redundancy Counter</t>

              <t hangText="I_min:">The smallest communication interval in
              milliseconds. This value is learned from the DIO message as
              (2^DIOIntervalMin)ms. The default value is
              DEFAULT_DIO_INTERVAL_MIN.</t>

              <t hangText="I_doublings:">The number of times I_min should be
              doubled before maintaining a constant rate, i.e. I_max = I_min *
              2^I_doublings. This value is learned from the DIO message as
              DIOIntervalDoublings. The default value is
              DEFAULT_DIO_INTERVAL_DOUBLINGS.</t>
            </list></t>

          <section title="Resetting the Trickle Timer">
            <t>The trickle timer for a DAGID is reset by:</t>

            <t><list style="numbers">
                <t>Setting I_min and I_doublings to the values learned from
                the DIO message.</t>

                <t>Setting C to zero.</t>

                <t>Setting I to I_min.</t>

                <t>Setting T to a random value as described above.</t>

                <t>Restarting the trickle timer to expire after a duration
                T</t>
              </list></t>

            <t>When node learns about a DAG through a DIO message and makes
            the decision to join it, it initializes the state of the trickle
            timer by resetting the trickle timer and listening. Each time it
            hears a consistent DIO message for this DAG from a DAG parent, it
            MAY increment C.</t>

            <t>When the timer fires at time T, the node compares C to the
            redundancy constant, DEFAULT_DIO_REDUNDANCY_CONSTANT. If C is less
            than that value, the node generates a new DIO message and
            multicasts it. When the communication interval I expires, the node
            doubles the interval I so long as it has previously doubled it
            fewer than I_doubling times, resets C, and chooses a new T
            value.</t>
          </section>

          <section anchor="TrickleInconsistencies"
                   title="Determination of Inconsistency">
            <t>The trickle timer is reset whenever an inconsistency is
            detected within the DAG, for example:</t>

            <t><list style="symbols">
                <t>The node joins a new DAGID</t>

                <t>The node moves within a DAGID</t>

                <t>The node receives a modified DIO message from a DAG
                parent</t>

                <t>A DAG parent forwards a packet intended to move inwards,
                indicating an inconsistency and possible loop.</t>

                <t>A metric communicated in the DIO message is determined to
                be inconsistent, as according to a implementation specific
                path metric selection engine.</t>

                <t>The rank of a DAG parent has changed.</t>
              </list></t>
          </section>
        </section>
      </section>

      <section anchor="DAGSequenceIncrement"
               title="DAG Sequence Number Increment">
        <t>The DAG root makes the sole determination of when to revise the
        DAGSequenceNumber by incrementing it upwards. When the
        DAGSequenceNumber is increased an inconsistency results, causing DIO
        messages to be sent back outwards along the DAG to convey the change.
        The degree to which this mechanism is relied on may be determined by
        the implementation- on one hand it may serve as a periodic heartbeat,
        refreshing the DAG states, and on the other hand it may result in a
        constant steady-state control cost overhead which is not
        desirable.</t>

        <t>Some implementations may provide an administrative interface, such
        as a command line, at the DAG root whereby the DAGSequenceNumber may
        be caused to increment in response to some policy outside of the scope
        of RPL.</t>

        <t>Other implementations may make use of a periodic timer to
        automatically increment the DAGSequenceNumber, resulting in a periodic
        DAG iteration at a rate appropriate to the application and
        implementation. Other automated mechanisms to determine
        DAGSequenceNumber increments are also possible as appropriate to a
        deployment.</t>
      </section>

      <section title="DAG Selection">
        <t>The DAG selection is implementation and algorithm dependent. Nodes
        SHOULD prefer to join DAGs for InstanceIDs advertising OCPs and
        destinations compatible with their implementation specific objectives.
        In order to limit erratic movements, and all metrics being equal,
        nodes SHOULD keep their previous selection. Also, nodes SHOULD provide
        a means to filter out a candidate parent whose availability is
        detected as fluctuating, at least when more stable choices are
        available.</t>

        <t>When connection to a fixed network is not possible or preferable
        for security or other reasons, scattered DAGs MAY aggregate as much as
        possible into larger DAGs in order to allow connectivity within the
        LLN.</t>

        <t>A node SHOULD verify that bidirectional connectivity and adequate
        link quality is available with a candidate neighbor before it
        considers that candidate as a DAG parent.</t>
      </section>

      <section title="Administrative rank">
        <t>When the DAG is formed under a common administration, or when a
        node performs a certain role within a community, it might be
        beneficial to associate a range of acceptable rank with that node. For
        instance, a node that has limited battery should be a leaf unless
        there is no other choice, and may then augment the rank computation
        specified by the OF in order to expose an exaggerated rank.</t>
      </section>

      <section anchor="DAGCollision" title="Collision">
        <t>A race condition occurs if 2 nodes send DIO messages at the same
        time and then attempt to join each other. This might happen, for
        example, between nodes which act as DAG root of their own DAGs. In
        order to detect the situation, LLN Nodes time stamp the sending of DIO
        message. Any DIO message received within a short link-layer-dependent
        period introduces a risk. It is up to the implementation to define the
        duration of the risk window.</t>

        <t>There is risk of a collision when a node receives and processes a
        DIO within the risk window. For example, it may occur that two nodes
        are associated with different DAGs and near-simultaneously send DIO
        messages, which are received and processed by both, and possibly
        result in both nodes simultaneously deciding to attach to each other.
        As a remedy, in the face of a potential collision, as determined by
        receiving a DIO within the risk window, the DIO message is not
        processed. It is expected that subsequent DIOs would not cross.</t>
      </section>

      <section title="Guidelines for Objective Functions">
        <section title="Objective Function">
          <t>An Objective Function (OF) allows for the selection of a DAG to
          join, and a number of peers in that DAG as parents. The OF is used
          to compute an ordered list of parents. The OF is also responsible to
          compute the rank of the device within the DAG.</t>

          <t>The Objective Function is specified in the DIO message within a
          DAG Metric Container using an Objective Code Point (OCP), as
          specified in <xref target="I-D.ietf-roll-routing-metrics" />, and
          indicates the method that must be used to compute the DAG (e.g.
          "minimize the path cost using the ETX metric and avoid `Blue'
          links"). The Objective Code Points are specified in <xref
          target="I-D.ietf-roll-routing-metrics" />. This document specifies
          an Objective Function, OF0, in support of default operation. In the
          case where the DIO does not include an OCP specification in the DAG
          Metric Container, OF0 MAY be presumed.</t>

          <t>Most Objective Functions are expected to follow the same abstract
          behavior:</t>

          <list style="symbols">
            <t>The parent selection is triggered each time an event indicates
            that a potential next hop information is updated. This might
            happen upon the reception of a DIO message, a timer elapse, or a
            trigger indicating that the state of a candidate neighbor has
            changed.</t>

            <t>An OF scans all the interfaces on the device. Although there
            may typically be only one interface in most application scenarios,
            there might be multiple of them and an interface might be
            configured to be usable or not for RPL operation. An interface can
            also be configured with a preference or dynamically learned to be
            better than another by some heuristics that might be link-layer
            dependent and are out of scope. Finally an interface might or not
            match a required criterion for an Objective Function, for instance
            a degree of security. As a result some interfaces might be
            completely excluded from the computation, while others might be
            more or less preferred.</t>

            <t>An OF scans all the candidate neighbors on the possible
            interfaces to check whether they can act as a router for a DAG.
            There might be multiple of them and a candidate neighbor might
            need to pass some validation tests before it can be used. In
            particular, some link layers require experience on the activity
            with a router to enable the router as a next hop.</t>

            <t>An OF computes self's rank by adding the step of rank to that
            candidate to the rank of that candidate. The step of rank is
            computed by estimating the link as follows:</t>

            <list style="symbols">
              <t>The step of rank might vary from 1 to 16.</t>

              <list style="symbols">
                <t>1 indicates a unusually good link, for instance a link
                between powered devices in a mostly battery operated
                environment.</t>

                <t>4 indicates a `normal'/typical link, as qualified by the
                implementation.</t>

                <t>16 indicates a link that can hardly be used to forward any
                packet, for instance a radio link with quality indicator or
                expected transmission count that is close to the acceptable
                threshold.</t>
              </list>

              <t>Candidate neighbors that would cause self's rank to increase
              are ignored</t>
            </list>

            <t>Candidate neighbors that advertise an OF incompatible with the
            set of OF specified by the policy functions are ignored.</t>

            <t>As it scans all the candidate neighbors, the OF keeps the
            current best parent and compares its capabilities with the current
            candidate neighbor. The OF defines a number of tests that are
            critical to reach the objective. A test between the routers
            determines an order relation.</t>

            <list style="symbols">
              <t>If the routers are roughly equal for that relation then the
              next test is attempted between the routers,</t>

              <t>Else the best of the 2 becomes the current best parent and
              the scan continues with the next candidate neighbor</t>

              <t>Some OFs may include a test to compare the ranks that would
              result if the node joined either router</t>
            </list>

            <t>When the scan is complete, the preferred parent is elected and
            self's rank is computed as the preferred parent rank plus the step
            in rank with that parent.</t>

            <t>Other rounds of scans might be necessary to elect alternate
            parents and siblings. In the next rounds:</t>

            <list style="symbols">
              <t>Candidate neighbors that are not in the same DAG are
              ignored</t>

              <t>Candidate neighbors that are of greater rank than self are
              ignored</t>

              <t>Candidate neighbors of an equal rank to self (siblings) are
              ignored</t>

              <t>Candidate neighbors of a lesser rank than self (non-siblings)
              are preferred</t>
            </list>
          </list>
        </section>

        <section title="Objective Function 0 (OF0)">
          <t>This document specifies a default objective function, called OF0,
          indicated by an OCP value of 0x0000. OF0 is the default objective
          function of RPL, and can be used if allowed by the policy of the
          processing node when the OF indicated in the DIO message is unknown
          to the node. If not allowed, then the DIO message is simply ignored
          and not processed by the node. OF0 is notable in that it does not
          use physical metrics as described in <xref
          target="I-D.ietf-roll-routing-metrics"></xref>, but is only based on
          abstract information from the DIO message such as rank and
          administrative preference.</t>

          <t>OF0 favors connectivity. That is, the Objective Function is
          designed to find the nearest sink into a 'grounded' topology, and if
          there is none then join any network per order of administrative
          preference. The metric in use is the rank.</t>

          <t>OF0 selects a preferred parent and a backup next hop if one is
          available. The backup next hop might be a parent or a sibling. All
          the traffic is routed via the preferred parent. When the link
          conditions do not let a packet through to the preferred parent, the
          packet is passed to the backup next hop.</t>

          <t>The step of rank is 4 for each hop.</t>

          <section title="Selection of the Preferred Parent">
            <t>As it scans all the candidate neighbors, OF0 keeps the parent
            that is the best for the following criteria (in order):</t>

            <t><list style="numbers">
                <t>The interface must be usable and any administrative
                preference associated with the interface applies first.</t>

                <t>A candidate that would cause the node to augment the rank
                in the current DAG is not considered.</t>

                <t>A router that has been validated as usable, e.g. with a
                local confidence that has exceeded some pre-configured
                threshold, is better.</t>

                <t>If none are grounded then a DAG with a more preferred
                administrative preference (DAGPreference) is better.</t>

                <t>A router that offers connectivity to a grounded DAG is
                better.</t>

                <t>A lesser resulting rank is better.</t>

                <t>A DAG for which there is an alternate parent is better.
                This check is optional. It is performed by computing the
                backup next hop while assuming that this router won.</t>

                <t>The DAG that was in use already is preferred.</t>

                <t>The preferred parent that was in use already is better.</t>

                <t>A router that has announced a DIO message more recently is
                preferred.</t>
              </list></t>
          </section>

          <section title="Selection of the Backup Next Hop">
            <list style="symbols">
              <t>The interface must be usable and the administrative
              preference (if any) applies first.</t>

              <t>The preferred parent is ignored.</t>

              <t>Candidate neighbors that are not in the same DAG are
              ignored.</t>

              <t>Candidate neighbors with a higher rank are ignored.</t>

              <t>Candidate neighbors of a better rank than self (non-siblings)
              are preferred.</t>

              <t>A router that has been validated as usable, e.g. with a local
              confidence that has exceeded some pre-configured threshold, is
              better.</t>

              <t>The router with a better router preference wins.</t>

              <t>The backup next hop that was in use already is better.</t>
            </list>
          </section>
        </section>
      </section>

      <section anchor="DestinationAdvertisement"
               title="Establishing Routing State Outward Along the DAG">
        <t>The destination advertisement mechanism supports the dissemination
        of routing state required to support traffic flows outward along the
        DAG, from the DAG root toward nodes.</t>

        <t>As a result of destination advertisement operation:</t>

        <t><list style="symbols">
            <t>DAG discovery establishes a DAG oriented toward a DAG root
            along which inward routes toward the DAG root are set up.</t>

            <t>Destination advertisement establishes outward routes along the
            DAG. Such paths consist of:</t>

            <?rfc subcompact="yes"?>

            <list style="symbols">
              <t>Hop-By-Hop routing state within islands of `stateful'
              nodes.</t>

              <t>Source Routing `bridges' across nodes that do not retain
              state.</t>
            </list>

            <?rfc subcompact="no"?>
          </list></t>

        <t>Destinations disseminated with the destination advertisement
        mechanism may be prefixes, individual hosts, or multicast listeners.
        The mechanism supports nodes of varying capabilities as follows:</t>

        <t><list style="symbols">
            <t>When nodes are capable of storing routing state, they may
            inspect destination advertisements and learn hop-by-hop routing
            state toward destinations by populating their routing tables with
            the routes learned from nodes in their sub-DAG. In this process
            they may also learn necessary piecewise source routes to traverse
            regions of the LLN that do not maintain routing state. They may
            perform route aggregation on known destinations before emitting
            Destination Advertisements.</t>

            <t>When nodes are incapable of storing routing state, they may
            forward destination advertisements, recording the reverse route as
            the go in order to support the construction of piecewise source
            routes.</t>
          </list></t>

        <t>Nodes that are capable of storing routing state, and finally the
        DAG roots, are able to learn which destinations are contained in the
        sub-DAG below the node, and via which next-hop neighbors. The
        dissemination and installation of this routing state into nodes allows
        for Hop-By-Hop routing from the DAG root outwards along the DAG. The
        mechanism is further enhance by supporting the construction of source
        routes across stateless `gaps' in the DAG, where nodes are incapable
        of storing additional routing state. An adaptation of this mechanism
        allows for the implementation of loose-source routing.</t>

        <t>A special case, the reception of a destination advertisement
        addressed to a link-local multicast address, allows for a node to
        learn destinations directly available from its one-hop neighbors.</t>

        <t>A design choice behind advertising routes via destination
        advertisements is not to synchronize the parent and children databases
        along the DAG, but instead to update them regularly to recover from
        the loss of packets. The rationale for that choice is time variations
        in connectivity across unreliable links. If the topology can be
        expected to change frequently, synchronization might be an excessive
        goal in terms of exchanges and protocol complexity. The approach used
        here results in a simple protocol with no real peering. The
        destination advertisement mechanism hence provides for periodic
        updates of the routing state, as cued by occasional RAs and other
        mechanisms, similarly to other protocols such as RIP <xref
        target="RFC2453"></xref>.</t>

        <section title="Destination Advertisement Operation">
          <section title="Overview">
            <t>According to implementation specific policy, a subset or all of
            the feasible parents in the DAG may be selected to receive prefix
            information from the destination advertisement mechanism. This
            subset of DAG parents shall be designated the set of DA
            parents.</t>

            <t>As DAO messages for particular destinations move inwards along
            the DAG, a sequence counter is used to guarantee their freshness.
            The sequence counter is incremented by the source of the DAO
            message (the node that owns the prefix, or learned the prefix via
            some other means), each time it issues a DAO message for its
            prefix. Nodes that receive the DAO message and, if scope allows,
            will be forwarding a DAO message for the unmodified destination
            inwards along the DAG, will leave the sequence number unchanged.
            Intermediate nodes will check the sequence counter before
            processing a DAO message, and if the DAO is unchanged (the
            sequence counter has not changed), then the DAO message will be
            discarded without additional processing. Further, if the DAO
            message appears to be out of synch (the sequence counter is 2 or
            more behind the present value) then the DAO state is considered to
            be stale and may be purged, and the DAO message is discarded. A
            depth is also added for tracking purposes; the depth is
            incremented at each hop as the DAO message is propagated up the
            DAG. Nodes that are storing routing state may use the depth to
            determine which possible next-hops for the destination are more
            optimal.</t>

            <t>If destination advertisements are activated in the DIO message
            as indicated by the `D' bit, the node sends unicast destination
            advertisements to one of its DA parents, that is selected as most
            favored for incoming outwards traffic. The node only accepts
            unicast destination advertisements from any nodes but those
            contained in the DA parent subset.</t>

            <t>Receiving a DIO message with the `D' destination advertisement
            bit set from a DAG parent stimulates the sending of a delayed
            destination advertisement back, with the collection of all known
            prefixes (that is the prefixes learned via destination
            advertisements for nodes lower in the DAG, and any connected
            prefixes). If the Destination Advertisement Supported (A) bit is
            set in the DIO message for the DAG, then a destination
            advertisement is also sent to a DAG parent once it has been added
            to the DA parent set after a movement, or when the list of
            advertised prefixes has changed.</t>

            <t>A node that modifies its DAG Parent set may set the `D' bit in
            subsequent DIO propagation in order to trigger destination
            advertisements to be updated to its DAG Parents and other inward
            nodes on the DAG. Additional recommendations and guidelines
            regarding the use of this mechanism are still under consideration
            and will be elaborated in a future revision of this
            specification.</t>

            <t>Destination advertisements may advertise positive (prefix is
            present) or negative (removed) DAO messages, termed as no-DAOs. A
            no-DAO is stimulated by the disappearance of a prefix below. This
            is discovered by timing out after a request (a DIO message) or by
            receiving a no-DAO. A no-DAO is a conveyed as a DAO message with a
            DAO Lifetime of ZERO_LIFETIME.</t>

            <t>A node that is capable of recording the state information
            conveyed in a unicast DAO message will do so upon receiving and
            processing the DAO message, thus building up routing state
            concerning destinations below it in the DAG. If a node capable of
            recording state information receives a DAO message containing a
            Reverse Route Stack, then the node knows that the DAO message has
            traversed one or more nodes that did not retain any routing state
            as it traversed the path from the DAO source to the node. The node
            may then extract the Reverse Route Stack and retain the included
            state in order to specify Source Routing instructions along the
            return path towards the destination. The node MUST set the RRCount
            back to zero and clear the Reverse Route Stack prior to passing
            the DAO message information on.</t>

            <t>A node that is unable to record the state information conveyed
            in the DAO message will append the next-hop address to the Reverse
            Route Stack, increment the RRCount, and then pass the destination
            advertisement on without recording any additional state. In this
            way the Reverse Route Stack will contain a vector of next hops
            that must be traversed along the reverse path that the DAO message
            has traveled. The vector will be ordered such that the node
            closest to the destination will appear first in the list. In such
            cases, if it is useful to the implementation to try and build up
            redundant paths, the node may choose to convey the destination
            advertisement to one or more DAG parents in order of preference as
            guided by an implementation specific policy.</t>

            <t>In some cases (called hybrid cases), some nodes along the path
            a destination advertisement follows inward along the DAG may store
            state and some may not. The destination advertisement mechanism
            allows for the provisioning of routing state such that when a
            packet is traversing outwards along the DAG, some nodes may be
            able to directly forward to the next hop, and other nodes may be
            able to specify a piecewise source route in order to bridge spans
            of stateless nodes within the path on the way to the desired
            destination.</t>

            <t>In the case where no node is able to store any routing state as
            destination advertisements pass by, and the DAG root ends up with
            DAO messages that contain a completely specified route back to the
            originating node in the form of the inverted Reverse Route Stack.
            A DAG root should not request (Destination Advertisement Trigger)
            nor indicate support (Destination Advertisement Supported) for
            destination advertisements if it is not able to store the Reverse
            Route Stack information in this case.</t>

            <t>The destination advertisement mechanism requires stateful nodes
            to maintain lists of known prefixes. A prefix entry contains the
            following abstract information:</t>

            <t><list style="symbols">
                <t>A reference to the ND entry that was created for the
                advertising neighbor.</t>

                <t>The IPv6 address and interface for the advertising
                neighbor.</t>

                <t>The logical equivalent of the full destination
                advertisement information (including the prefixes, depth, and
                Reverse Route Stack, if any).</t>

                <t>A 'reported' Boolean to keep track whether this prefix was
                reported already, and to which of the DA parents.</t>

                <t>A counter of retries to count how many DIO messages were
                sent on the interface to the advertising neighbor without
                reachability confirmation for the prefix.</t>
              </list></t>

            <t>Note that nodes may receive multiple information from different
            neighbors for a specific destination, as different paths through
            the DAG may be propagating information inwards along the DAG for
            the same destination. A node that is recording routing state will
            keep track of the information from each neighbor independently,
            and when it comes time to propagate the DAO message for a
            particular prefix to the DA parents, then the DAO information will
            be selected from among the advertising neighbors who offer the
            least depth to the destination.</t>

            <t>The destination advertisement mechanism stores the prefix
            entries in one of 3 abstract lists; the Connected, the Reachable
            and the Unreachable lists.</t>

            <t>The Connected list corresponds to the prefixes owned and
            managed by the local node.</t>

            <t>The Reachable list contains prefixes for which the node keeps
            receiving DAO messages, and for those prefixes which have not yet
            timed out.</t>

            <t>The Unreachable list keeps track of prefixes which are no
            longer valid and in the process of being deleted, in order to send
            DAO messages with zero lifetime (also called no-DAO) to the DA
            parents.</t>

            <section anchor="DATimers"
                     title="Destination Advertisement Timers">
              <t>The destination advertisement mechanism requires 2 timers;
              the DelayDAO timer and the RemoveTimer.</t>

              <t><list style="symbols">
                  <t>The DelayDAO timer is armed upon a stimulation to send a
                  destination advertisement (such as a DIO message from a DA
                  parent). When the timer is armed, all entries in the
                  Reachable list as well as all entries for Connected list are
                  set to not be reported yet for that particular DA
                  parent.</t>

                  <t>The DelayDAO timer has a duration that is DEF_DAO_LATENCY
                  divided by a multiple of the DAG rank of the node. The
                  intention is that nodes located deeper in the DAG should
                  have a shorter DelayDAO timer, allowing DAO messages a
                  chance to be reported from deeper in the DAG and potentially
                  aggregated along sub-DAGs before propagating further
                  inwards.</t>

                  <t>The RemoveTimer is used to clean up entries for which DAO
                  messages are no longer being received from the sub-DAG.</t>

                  <list style="symbols">
                    <t>When a DIO message is sent that is requesting
                    destination advertisements, a flag is set for all DAO
                    entries in the routing table.</t>

                    <t>If the flag has already been set for a DAO entry, the
                    retry count is incremented.</t>

                    <t>If a DAO message is received to confirm the entry, the
                    entry is refreshed and the flag and count may be
                    cleared.</t>

                    <t>If at least one entry has reached a threshold value and
                    the RemoveTimer is not running, the entry is considered to
                    be probably gone and the RemoveTimer is started.</t>

                    <t>When the RemoveTimer elapse, DAO messages with lifetime
                    0, i.e. no-DAOs, are sent to explicitly inform DA parents
                    that the entries which have reached the threshold are no
                    longer available, and the related routing states may be
                    propagated and cleaned up.</t>
                  </list>

                  <t>The RemoveTimer has a duration of min
                  (MAX_DESTROY_INTERVAL, TBD(DIO Trickle Timer Interval)).</t>
                </list></t>
            </section>
          </section>

          <section title="Multicast Destination Advertisement Messages">
            <t>It is also possible for a node to multicast a DAO message to
            the link-local scope all-nodes multicast address FF02::1. This
            message will be received by all node listening in range of the
            emitting node. The objective is to enable direct P2P
            communication, between destinations directly supported by
            neighboring nodes, without needing the RPL routing structure to
            relay the packets.</t>

            <t>A multicast DAO message MUST be used only to advertise
            information about self, i.e. prefixes in the Connected list or
            addresses owned by this node. This would typically be a multicast
            group that this node is listening to or a global address owned by
            this node, though it can be used to advertise any prefix owned by
            this node as well. A multicast DAO message is not used for routing
            and does not presume any DAG relationship between the emitter and
            the receiver; it MUST NOT be used to relay information learned
            (e.g. information in the Reachable list) from another node;
            information obtained from a multicast DAO MAY be installed in the
            routing table and MAY be propagated by a router in unicast
            DAOs.</t>

            <t>A node receiving a multicast DAO message addressed to FF02::1
            MAY install prefixes contained in the DAO message in the routing
            table for local use. Such a node MUST NOT perform any other
            processing on the DAO message (i.e. such a node does not presume
            it is a DA parent).</t>
          </section>

          <section title="Unicast Destination Advertisement Messages from Child to Parent">
            <t>When sending a destination advertisement to a DA parent, a node
            includes the DAOs for prefix entries not already reported (since
            the last DA Trigger from an DIO message) in the Reachable and
            Connected lists, as well as no-DAOs for all the entries in the
            Unreachable list. Depending on its policy and ability to retain
            routing state, the receiving node SHOULD keep a record of the
            reported DAO message. If the DAO message offers the best route to
            the prefix as determined by policy and other prefix records, the
            node SHOULD install a route to the prefix reported in the DAO
            message via the link local address of the reporting neighbor and
            it SHOULD further propagate the information in a DAO message.</t>

            <t>The DIO message from the DAG root is used to synchronize the
            whole DAG, including the periodic reporting of destination
            advertisements back up the DAG. Its period is expected to vary,
            depending on the configuration of the trickle timer that governs
            the RAs.</t>

            <t>When a node receives a DIO message over an LLN interface from a
            DA parent, the DelayDAO is armed to force a full update.</t>

            <t>When the node broadcasts a DIO message on an LLN interface, for
            all entries on that interface:</t>

            <t><list style="symbols">
                <t>If the entry is CONFIRMED, it goes PENDING with the retry
                count set to 0.</t>

                <t>If the entry is PENDING, the retry count is incremented. If
                it reaches a maximum threshold, the entry goes ELAPSED If at
                least one entry is ELAPSED at the end of the process: if the
                RemoveTimer is not running then it is armed with a jitter.</t>
              </list></t>

            <t>Since the DelayDAO timer has a duration that decreases with the
            depth, it is expected to receive all DAO messages from all
            children before the timer elapses and the full update is sent to
            the DA parents.</t>

            <t>Once the RemoveTimer is elapsed, the prefix entry is scheduled
            to be removed and moved to the Unreachable list if there are any
            DA parents that need to be informed of the change in status for
            the prefix, otherwise the prefix entry is cleaned up right away.
            The prefix entry is removed from the Unreachable list when no more
            DA parents need to be informed. This condition may be satisfied
            when a no-DAO is sent to all current DA parents indicating the
            loss of the prefix, and noting that in some cases parents may have
            been removed from the set of DA parents.</t>
          </section>

          <section title="Other Events">
            <t>Finally, the destination advertisement mechanism responds to a
            series of events, such as:</t>

            <t><list style="symbols">
                <t>Destination advertisement operation stopped: All entries in
                the abstract lists are freed. All the routes learned from DAO
                messages are removed.</t>

                <t>Interface going down: for all entries in the Reachable list
                on that interface, the associated route is removed, and the
                entry is scheduled to be removed.</t>

                <t>Loss of routing adjacency: When the routing adjacency for a
                neighbor is lost, as per the procedures described in <xref
                target="MaintenanceRoutingAdjacency"></xref>, and if the
                associated entries are in the Reachable list, the associated
                routes are removed, and the entries are scheduled to be
                destroyed.</t>

                <t>Changes to DA parent set: all entries in the Reachable list
                are set to not 'reported' and DelayDAO is armed.</t>
              </list></t>
          </section>

          <section title="Aggregation of Prefixes by a Node">
            <t>There may be number of cases where a aggregation may be shared
            within a group of nodes. In such a case, it is possible to use
            aggregation techniques with destination advertisements and improve
            scalability.</t>

            <t>Other cases might occur for which additional support is
            required:</t>

            <t><list style="numbers">
                <t>The aggregating node is attached within the sub-DAG of the
                nodes it is aggregating for.</t>

                <t>A node that is to be aggregated for is located somewhere
                else within the DAG, not in the sub-DAG of the aggregating
                node.</t>

                <t>A node that is to be aggregated for is located somewhere
                else in the LLN.</t>
              </list></t>

            <t>Consider a node M that is performing an aggregation, and a node
            N that is to be a member of the aggregation group. A node Z
            situated above the node M in the DAG, but not above node N, will
            see the advertisements for the aggregation owned by M but not that
            of the individual prefix for N. Such a node Z will route all the
            packets for node N towards node M, but node M will have no route
            to the node N and will fail to forward.</t>

            <t>Additional protocols may be applied beyond the scope of this
            specification to dynamically elect/provision an aggregating node
            and groups of nodes eligible to be aggregated in order to provide
            route summarization for a sub-DAG.</t>
          </section>
        </section>
      </section>

      <section anchor="loopdetect" title="Loop Detection">
        <t>RPL loop avoidance mechanisms are kept simple and designed to
        minimize churn and states. Loops may form for a number of reasons,
        from control packet loss to sibling forwarding. RPL includes a
        reactive loop detection technique that protects from meltdown and
        triggers repair of broken paths.</t>

        <t>RPL loop detection uses information that is placed into the packet
        in the flow label. It assumes that the flow label may be overloaded
        for this purpose. The flow label is constructed as follows: <t>
            <figure anchor="flowlabel" title="RPL Flow Label">
              <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                            |O|S|R|D|  SenderRank   |  InstanceID   |
                            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
]]></artwork>
            </figure>
          </t></t>

        <t><list hangIndent="6" style="hanging">
            <t hangText="Outwards 'O' bit:">1-bit flag indicating whether the
            packet is expected to progress inwards or outwards. A router sets
            the 'O' bit when the packet is expect to progress outwards (using
            DAO routes), and resets it when forwarding towards the root of the
            DAG. A host MUST set the bit to 0.</t>

            <t hangText="Sibling 'S' bit:">1-bit flag indicating whether the
            packet has been forwarded via a sibling at the present rank, and
            denotes a risk of a sibling loop. A host sets the bit to 0.</t>

            <t hangText="Rank-Error 'R' bit:">1-bit flag indicating whether a
            rank error was detected. A rank error is detected when there is a
            mismatch in the relative ranks and the direction as indicated in
            the 'O' bit. A host MUST set the bit to 0.</t>

            <t hangText="DAO-Error 'D' bit:">1-bit flag indicating whether a
            DAO error was detected. An undetected DAO error would have
            resulted in an inward to outward transition that is not expected
            with this spec. A host MUST set the bit to 0.</t>

            <t hangText="SenderRank:">8-bit field indicating the rank of the
            sender. A host MUST set the rank to INFINITE_RANK. A router MUST
            place its own rank in the flow label when forwarding.</t>

            <t hangText="InstanceID:">8-bit field indicating the DAG instance
            along which the packet is sent.</t>
          </list></t>

        <section title="Host Basic Operation">
          <t>It is expected that a host that does not participate to RPL in
          any fashion is configured to set the flow label to all zeroes in its
          outgoing packets. The host MAY send a packet to any router
          regardless of the DAG and RPL operations at large.</t>

          <t>A host that participates to RPL SHOULD zero out all the flags,
          and it MUST set the sender rank to INFINITE_RANK. If the host can
          map a flow to a given InstanceID then it MUST set the flow label
          accordingly. Forwarding rules are the same for this host and a
          router, and are described in the next section.</t>
        </section>

        <section title="Instance Forwarding">
          <t>Instance IDs is used to avoid loops between DAGs from different
          origins. DAGs that constructed for antagonistic constraints might
          contain paths that, if mixed together, would yield loops. Those
          loops are avoided by forwarding a packet along the DAG that is
          associated to a given instance.</t>

          <t>The InstanceID is placed by the source in the flow label. It is
          not meaningful if the packet has the flow label set to all zeroes.
          Otherwise it MUST match the DAG instance onto which the packet is
          placed by any node, be it a host or router.</t>

          <t>When a router receives a packet that is flagged with a given
          instance ID and the node can forward the packet along the DAG
          associated to that instance, then the router MUST do so and leave
          the instance ID flag unchanged.</t>

          <t>If any node can not forward a packet along the DAG associated to
          the instance ID in the flow label, then the node MAY either change
          the InstanceID to match a DAG that it is using for this packet or
          discard the packet. That decision is based on a policy.</t>

          <t>The default policy is as follows: if the node can forward along
          the DAG associated to the instance RPL_DEFAULT_INSTANCE then it
          should do so. Otherwise it should drop the packet.</t>
        </section>

        <section title="DAG Inconsistency Loop Detection">
          <t>The DAG is inconsistent is the direction of a packet does not
          match the rank relationship. A receiver detects an inconsistency if
          it receives a packet with either: <list>
              <t>the 'O' bit set (to outwards) from a node of a higher
              rank.</t>

              <t>the 'O' bit reset (for inwards) from a node of a lesser
              rank.</t>

              <t>the 'S' bit set (to sibling) from a node of a different
              rank.</t>
            </list></t>

          <t>The propagation of a new sequence creates local inconsistencies.
          In particular, it is possible for a router to forward a packet to a
          future parent (same instance, same DAGID, higher sequence) without a
          loop, regardless of the rank of that parent. In that case, the
          sending router MUST present itself as a host on the future DAG and
          use a rank of INFINITE_RANK as it forwards the packets via a future
          parent to avoid a false positive.</t>

          <t>One inconsistency along the path is not considered as a critical
          error and the packet may continue. But a second detection along the
          path of a same packet should not occur and the packet is
          dropped.</t>

          <t>This process is controlled by the Rank-Error bit in the Flow
          Label. When an inconsistency, is detected on a packet, if the
          Rank-Error bit was not set then the Rank-Error bit is set. If it was
          set the packet is discarded and the trickle timer is reset.</t>
        </section>

        <section title="Sibling Loop Avoidance">
          <t>When a packet is forwarded along siblings, it cannot be checked
          for forward progress and may loop between siblings. Experimental
          evidence has shown that one sibling hop can be very useful but is
          generally sufficient to avoid loops. Based on that evidence, this
          specification enforces the simple rule that a packet may not make 2
          sibling hops in a row.</t>

          <t>When a host issues a packet or when a router forwards a packet to
          a non sibling, the Sibling bit in the packet must be reset. When a
          router forwards to a sibling: if the Sibling bit was not set then
          the Sibling bit is set. If the Sibling bit was set then the packet
          is discarded. This does not denote a graph inconsistency but
          indicates that a new graph should probably be formed with a new
          sequence.</t>
        </section>

        <section title="DAO Inconsistency Loop Detection and Recovery">
          <t>A DAO inconsistency happens when router that has an outwards DAO
          route via a child that is a remnant from an obsolete state that is
          not matched in the child. With DAO inconsistency loop recovery, a
          packet can be used to recursively explore and cleanup the obsolete
          DAO states along a sub-DAG.</t>

          <t>In a general manner, a packet that goes outwards should never go
          inwards again. So rather than routing inwards a packet with the
          Outwards bit set, the router MUST discard the packet. If DAO
          inconsistency loop recovery is applied, then the router SHOULD send
          the packet to the parent that passed it with the DAO-Error bit
          set.</t>

          <t>Upon a packet with a DAO bit set, the parent MUST remove the
          routing states that caused forwarding to that child, clear DAO-Error
          bit and send the packet again. The packet will make its way either
          to an alternate child or inwards to a parent. If that parent still
          has an inconsistent DAO state via self, the process will recurse and
          that state will be cleaned up as well.</t>
        </section>
      </section>

      <section title="Multicast Operation">
        <t>This section describes further the multicast routing operations
        over an IPv6 RPL network, and specifically how unicast DAOs can be
        used to relay group registrations inwards. Wherever the following text
        mentions MLD, one can read MLDv2 or v3.</t>

        <t>As is traditional, a listener uses a protocol such as MLD with a
        router to register to a multicast group.</t>

        <t>Along the path between the router and the root of the DAG, MLD
        requests are mapped and transported as DAO messages within the RPL
        protocol; each hop coalesces the multiple requests for a same group as
        a single DAO message to the parent(s), in a fashion similar to proxy
        IGMP, but recursively between child router and parent up to the
        root.</t>

        <t>A router might select to pass a listener registration DAO message
        to its preferred parent only, in which case multicast packets coming
        back might be lost for all of its sub-DAG if the transmission fails
        over that link. Alternatively the router might select to copy
        additional parents as it would do for DAO messages advertising unicast
        destinations, in which case there might be duplicates that the router
        will need to prune.</t>

        <t>As a result, multicast routing states are installed in each router
        on the way from the listeners to the root, enabling the root to copy a
        multicast packet to all its children routers that had issued a DAO
        message including a DAO for that multicast group, as well as all the
        attached nodes that registered over MLD.</t>

        <t>For unicast traffic, it is expected that the grounded root of an
        RPL DAG terminates RPL and MAY redistribute the RPL routes over the
        external infrastructure using whatever routing protocol is used there.
        For multicast traffic, the root MAY proxy MLD for all the nodes
        attached to the RPL routers (this would be needed if the multicast
        source is located in the external infrastructure). For such a source,
        the packet will be replicated as it flows outwards along the DAG based
        on the multicast routing table entries installed from the DAO
        message.</t>

        <t>For a source inside the DAG, the packet is passed to the preferred
        parents, and if that fails then to the alternates in the DAG. The
        packet is also copied to all the registered children, except for the
        one that passed the packet. Finally, if there is a listener in the
        external infrastructure then the DAG root has to further propagate the
        packet into the external infrastructure.</t>

        <t>As a result, the DAG Root acts as an automatic proxy Rendezvous
        Point for the RPL network, and as source towards the Internet for all
        multicast flows started in the RPL LLN. So regardless of whether the
        root is actually attached to the Internet, and regardless of whether
        the DAG is grounded or floating, the root can serve inner multicast
        streams at all times.</t>
      </section>

      <section anchor="MaintenanceRoutingAdjacency"
               title="Maintenance of Routing Adjacency">
        <t>The selection of successors, along the default paths inward along
        the DAG, or along the paths learned from destination advertisements
        outward along the DAG, leads to the formation of routing adjacencies
        that require maintenance.</t>

        <t>In IGPs such as OSPF <xref target="RFC4915"></xref> or IS-IS <xref
        target="RFC5120"></xref>, the maintenance of a routing adjacency
        involves the use of Keepalive mechanisms (Hellos) or other protocols
        such as BFD (<xref target="I-D.ietf-bfd-base"></xref>) and MANET
        Neighborhood Discovery Protocol (NHDP <xref
        target="I-D.ietf-manet-nhdp"></xref>). Unfortunately, such an approach
        is not desirable in constrained environments such as LLN and would
        lead to excessive control traffic in light of the data traffic with a
        negative impact on both link loads and nodes resources. Overhead to
        maintain the routing adjacency should be minimized. Furthermore, it is
        not always possible to rely on the link or transport layer to provide
        information of the associated link state. The network layer needs to
        fall back on its own mechanism.</t>

        <t>Thus RPL makes use of a different approach consisting of probing
        the neighbor using a Neighbor Solicitation message (see <xref
        target="RFC4861"></xref>). The reception of a Neighbor Advertisement
        (NA) message with the "Solicited Flag" set is used to verify the
        validity of the routing adjacency. Such mechanism MAY be used prior to
        sending a data packet. This allows for detecting whether or not the
        routing adjacency is still valid, and should it not be the case,
        select another feasible successor to forward the packet.</t>
      </section>

      <section anchor="PacketForwarding" title="Packet Forwarding">
        <t>When forwarding a packet to a destination, precedence is given to
        selection of a next-hop successor as follows:</t>

        <t><list style="numbers">
            <t>In the scope of this specification, it is preferred to select a
            successor from a DAG that matches the InstanceID marked in the
            IPv6 header of the packet being forwarded.</t>

            <t>If a local administrative preference favors a route that has
            been learned from a different routing protocol than RPL, then use
            that successor.</t>

            <t>If there is an entry in the routing table matching the
            destination that has been learned from a multicast destination
            advertisement (e.g. the destination is a one-hop neighbor), then
            use that successor.</t>

            <t>If there is an entry in the routing table matching the
            destination that has been learned from a unicast destination
            advertisement (e.g. the destination is located outwards along the
            sub-DAG), then use that successor.</t>

            <t>If there is a DAG offering a route to a prefix matching the
            destination, then select one of those DAG parents as a
            successor.</t>

            <t>If there is a DAG parent offering a default route then select
            that DAG parent as a successor.</t>

            <t>If there is a DAG offering a route to a prefix matching the
            destination, but all DAG parents have been tried and are
            temporarily unavailable (as determined by the forwarding
            procedure), then select a DAG sibling as a successor.</t>

            <t>Finally, if no DAG siblings are available, the packet is
            dropped. ICMP Destination Unreachable may be invoked. An
            inconsistency is detected.</t>
          </list></t>

        <t>TTL MUST be decremented when forwarding. If the packet is being
        forwarded via a sibling, then the TTL MAY be decremented more
        aggressively (by more than one) to limit the impact of possible
        loops.</t>

        <t>Note that the chosen successor MUST NOT be the neighbor that was
        the predecessor of the packet (split horizon), except in the case
        where it is intended for the packet to change from an inward to an
        outward flow, such as switching from DIO routes to DAO routes as the
        destination is neared.</t>
      </section>
    </section>

    <section title="RPL Constants and Variables">
      <t><list hangIndent="6" style="hanging">
          <t hangText="ZERO_LIFETIME">This is the special value of a lifetime
          that indicates immediate death and removal. ZERO_LIFETIME has a
          value of 0.</t>

          <t hangText="BASE_RANK">This is the rank for a virtual root that
          might be used to coordinate multiple roots. BASE_RANK has a value of
          0.</t>

          <t hangText="ROOT_RANK">This is the rank for a DAG root. ROOT_RANK
          has a value of 1.</t>

          <t hangText="INFINITE_RANK">This is the constant maximum for the
          rank. INFINITE_RANK has a value of 0xFF.</t>

          <t hangText="RPL_DEFAULT_INSTANCE">This is the instance ID that is
          used by this protocol by a node without a policy to know any better.
          RPL_DEFAULT_INSTANCE has a value of 0.</t>

          <t hangText="DEFAULT_DIO_INTERVAL_MIN">To be determined</t>

          <t hangText="DEFAULT_DIO_INTERVAL_DOUBLINGS">To be determined</t>

          <t hangText="DEF_DAO_LATENCY">To be determined</t>

          <t hangText="MAX_DESTROY_INTERVAL">To be determined</t>

          <t hangText="DIO Timer">One instance per DAG that a node is a member
          of. Expiry triggers DIO message transmission. Trickle timer with
          variable interval in [0, DIOIntervalMin..2^DIOIntervalDoublings].
          See <xref target="TrickleImplementation"></xref></t>

          <t hangText="DAG Sequence Number Increment Timer">Up to one instance
          per DAG that the node is acting as DAG root of. May not be supported
          in all implementations. Expiry triggers revision of
          DAGSequenceNumber, causing a new series of updated DIO message to be
          sent. Interval should be chosen appropriate to propagation time of
          DAG and as appropriate to application requirements (e.g. response
          time vs. overhead). See <xref
          target="DAGSequenceIncrement"></xref></t>

          <t hangText="DelayDAO Timer">Up to one instance per DA parent (the
          subset of DAG parents chosen to receive destination advertisements)
          per DAG. Expiry triggers sending of DAO message to the DA parent.
          The interval is to be proportional to DEF_DAO_LATENCY/(node rank),
          such that nodes of greater rank (further outward along the DAG)
          expire first, coordinating the sending of DAO messages to allow for
          a chance of aggregation. See <xref target="DATimers"></xref></t>

          <t hangText="RemoveTimer">Up to one instance per DA entry per
          neighbor (i.e. those neighbors that have given DAO messages to this
          node as a DAG parent) Expiry triggers a change in state for the DA
          entry, setting up to do unreachable (No-DAO) advertisements or
          immediately deallocating the DA entry if there are no DA parents.
          The interval is min(MAX_DESTROY_INTERVAL, TBD(DIO Trickle Timer
          Interval)). See <xref target="DATimers"></xref></t>
        </list></t>
    </section>

    <section anchor="Manageability" title="Manageability Considerations">
      <t>The aim of this section is to give consideration to the manageability
      of RPL, and how RPL will be operated in LLN beyond the use of a MIB
      module. The scope of this section is to consider the following aspects
      of manageability: fault management, configuration, accounting and
      performance.</t>

      <section title="Control of Function and Policy">
        <section title="Initialization Mode">
          <t>When a node is first powered up, it may either choose to stay
          silent and not send any multicast DIO message until it has joined a
          DAG, or to immediately root a transient DAG and start sending
          multicast DIO messages. A RPL implementation SHOULD allow
          configuring whether the node should stay silent or should start
          advertising DIO messages.</t>

          <t>Furthermore, the implementation SHOULD to allow configuring
          whether or not the node should start sending an DIS message as an
          initial probe for nearby DAGs, or should simply wait until it
          received RA messages from other nodes that are part of existing
          DAGs.</t>
        </section>

        <section title="DIO Base option">
          <t>RPL specifies a number of protocol parameters.</t>

          <t>A RPL implementation SHOULD allow configuring the following
          routing protocol parameters, which are further described in <xref
          target="DIOBaseOption"></xref>:</t>

          <?rfc subcompact="yes"?>

          <t><list hangIndent="6" style="hanging">
              <t hangText="DAGPreference"></t>

              <t hangText="InstanceID"></t>

              <t hangText="DAGObjectiveCodePoint"></t>

              <t hangText="DAGID"></t>

              <t hangText="Destination Prefixes"></t>

              <t hangText="DIOIntervalDoublings"></t>

              <t hangText="DIOIntervalMin"></t>

              <t></t>

              <t hangText="DAG Root behavior:">In some cases, a node may not
              want to permanently act as a DAG root if it cannot join a
              grounded DAG. For example a battery-operated node may not want
              to act as a DAG root for a long period of time. Thus a RPL
              implementation MAY support the ability to configure whether or
              not a node could act as a DAG root for a configured period of
              time.</t>

              <t></t>

              <t hangText="DAG Table Entry Suppression">A RPL implementation
              SHOULD provide the ability to configure a timer after the
              expiration of which the DAG table that contains all the records
              about a DAG is suppressed, to be invoked if the DAG parent set
              becomes empty.</t>
            </list></t>

          <?rfc subcompact="no"?>
        </section>

        <section title="Trickle Timers">
          <t>A RPL implementation makes use of trickle timer to govern the
          sending of DIO message. Such an algorithm is determined a by a set
          of configurable parameters that are then advertised by the DAG root
          along the DAG in DIO messages.</t>

          <t>For each DAG, a RPL implementation MUST allow for the monitoring
          of the following parameters, further described in <xref
          target="TrickleImplementation"></xref>:</t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="I"></t>

              <t hangText="T"></t>

              <t hangText="C"></t>

              <t hangText="I_min"></t>

              <t hangText="I_doublings:"></t>
            </list></t>

          <t>A RPL implementation SHOULD provide a command (for example via
          API, CLI, or SNMP MIB) whereby any procedure that detects an
          inconsistency may cause the trickle timer to reset.</t>
        </section>

        <section title="DAG Sequence Number Increment">
          <t>A RPL implementation may allow by configuration at the DAG root
          to refresh the DAG states by updating the DAGSequenceNumber. A RPL
          implementation SHOULD allow configuring whether or not periodic or
          event triggered mechanism are used by the DAG root to control
          DAGSequenceNumber change.</t>
        </section>

        <section title="Destination Advertisement Timers">
          <t>The following set of parameters of the DAO messages SHOULD be
          configurable:</t>

          <t><list style="symbols">
              <t>The DelayDAO timer</t>

              <t>The Remove timer</t>
            </list></t>
        </section>

        <section title="Policy Control">
          <t>DAG discovery enables nodes to implement different policies for
          selecting their DAG parents.</t>

          <t>A RPL implementation SHOULD allow configuring the set of
          acceptable or preferred Objective Functions (OF) referenced by their
          Objective Codepoints (OCPs) for a node to join a DAG, and what
          action should be taken if none of a node's candidate neighbors
          advertise one of the configured allowable Objective Functions.</t>

          <t>A node in an LLN may learn routing information from different
          routing protocols including RPL. It is in this case desirable to
          control via administrative preference which route should be favored.
          An implementation SHOULD allow for specifying an administrative
          preference for the routing protocol from which the route was
          learned.</t>

          <t>A RPL implementation SHOULD allow for the configuration of the
          "Route Tag" field of the DAO messages according to a set of rules
          defined by policy.</t>
        </section>

        <section title="Data Structures">
          <t>Some RPL implementation may limit the size of the candidate
          neighbor list in order to bound the memory usage, in which case some
          otherwise viable candidate neighbors may not be considered and
          simply dropped from the candidate neighbor list.</t>

          <t>A RPL implementation MAY provide an indicator on the size of the
          candidate neighbor list.</t>
        </section>
      </section>

      <section title="Information and Data Models">
        <t>The information and data models necessary for the operation of RPL
        will be defined in a separate document specifying the RPL SNMP
        MIB.</t>
      </section>

      <section title="Liveness Detection and Monitoring">
        <t>The aim of this section is to describe the various RPL mechanisms
        specified to monitor the protocol.</t>

        <t>As specified in <xref target="ConceptualDataStructures"></xref>, an
        implementation must maintain a set of data structures in support of
        DAG discovery:</t>

        <t><list style="symbols">
            <t>The candidate neighbors data structure</t>

            <t>For each DAG:</t>

            <list style="symbols">
              <t>A set of DAG parents</t>
            </list>
          </list></t>

        <section title="Candidate Neighbor Data Structure">
          <t>A node in the candidate neighbor list is a node discovered by the
          some means and qualified to potentially become of neighbor or a
          sibling (with high enough local confidence). A RPL implementation
          SHOULD provide a way monitor the candidate neighbors list with some
          metric reflecting local confidence (the degree of stability of the
          neighbors) measured by some metrics.</t>

          <t>A RPL implementation MAY provide a counter reporting the number
          of times a candidate neighbor has been ignored, should the number of
          candidate neighbors exceeds the maximum authorized value.</t>
        </section>

        <section title="Directed Acyclic Graph (DAG) Table">
          <t>For each DAG, a RPL implementation MUST keep track of the
          following DAG table values:</t>

          <t><list style="symbols">
              <t>DAGID</t>

              <t>DAGObjectiveCodePoint</t>

              <t>A set of Destination Prefixes offered inwards along the
              DAG</t>

              <t>A set of DAG Parents</t>

              <t>timer to govern the sending of DIO messages for the DAG</t>

              <t>DAGSequenceNumber</t>
            </list></t>

          <t>The set of DAG parents structure is itself a table with the
          following entries:</t>

          <t><list style="symbols">
              <t>A reference to the neighboring device which is the DAG
              parent</t>

              <t>A record of most recent information taken from the DAG
              Information Object last processed from the DAG Parent</t>

              <t>A flag reporting if the Parent is a DA Parent as described in
              <xref target="DestinationAdvertisement"></xref></t>
            </list></t>
        </section>

        <section title="Routing Table">
          <t>For each route provisioned by RPL operation, a RPL implementation
          MUST keep track of the following:</t>

          <t><list style="symbols">
              <t>Destination Prefix</t>

              <t>Destination Prefix Length</t>

              <t>Lifetime Timer</t>

              <t>Next Hop</t>

              <t>Next Hop Interface</t>

              <t>Flag indicating that the route was provisioned from one
              of:<list>
                  <t>Unicast DAO message</t>

                  <t>DIO message</t>

                  <t>Multicast DAO message</t>
                </list></t>
            </list></t>
        </section>

        <section title="Other RPL Monitoring Parameters">
          <t>A RPL implementation SHOULD provide a counter reporting the
          number of a times the node has detected an inconsistency with
          respect to a DAG parent, e.g. if the DAGID has changed.</t>

          <t>A RPL implementation MAY log the reception of a malformed DIO
          message along with the neighbor identification if avialable.</t>
        </section>

        <section title="RPL Trickle Timers">
          <t>A RPL implementation operating on a DAG root MUST allow for the
          configuration of the following trickle parameters:</t>

          <t><list style="symbols">
              <t>The DIOIntervalMin expressed in ms</t>

              <t>The DIOIntervalDoublings</t>
            </list></t>

          <t>A RPL implementation MAY provide a counter reporting the number
          of times an inconsistency (and thus the trickle timer has been
          reset).</t>
        </section>
      </section>

      <section title="Verifying Correct Operation">
        <t>This section has to be completed in further revision of this
        document to list potential Operations and Management (OAM) tools that
        could be used for verifying the correct operation of RPL.</t>
      </section>

      <section title="Requirements on Other Protocols and Functional Components">
        <t>RPL does not have any impact on the operation of existing
        protocols.</t>
      </section>

      <section title="Impact on Network Operation">
        <t>To be completed.</t>
      </section>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Security Considerations for RPL are to be developed in accordance
      with recommendations laid out in, for example, <xref
      target="I-D.tsao-roll-security-framework"></xref>.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <section title="RPL Control Message">
        <t>The RPL Control Message is an ICMP information message type that is
        to be used carry DAG Information Objects, DAG Information
        Solicitations, and Destination Advertisement Objects in support of RPL
        operation.</t>

        <t>IANA has defined a ICMPv6 Type Number Registry. The suggested type
        value for the RPL Control Message is 155, to be confirmed by IANA.</t>
      </section>

      <section title="New Registry for RPL Control Codes">
        <t>IANA is requested to create a registry, RPL Control Codes, for the
        Code field of the ICMPv6 RPL Control Message.</t>

        <t>New codes may be allocated only by an IETF Consensus action. Each
        code should be tracked with the following qualities:</t>

        <t><list style="symbols">
            <t>Code</t>

            <t>Description</t>

            <t>Defining RFC</t>
          </list></t>

        <t>Three codes are currently defined:</t>

        <texttable title="RPL Control Codes">
          <ttcol align="center">Code</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0x01</c>

          <c>DAG Information Solicitation</c>

          <c>This document</c>

          <c>0x02</c>

          <c>DAG Information Object</c>

          <c>This document</c>

          <c>0x04</c>

          <c>Destination Advertisement Object</c>

          <c>This document</c>
        </texttable>
      </section>

      <section title="New Registry for the Control Field of the DIO Base Option">
        <t>IANA is requested to create a registry for the Control field of the
        DIO Base Option.</t>

        <t>New bit numbers may be allocated only by an IETF Consensus action.
        Each bit should be tracked with the following qualities:</t>

        <t><list style="symbols">
            <t>Bit number (counting from bit 0 as the most significant
            bit)</t>

            <t>Capability description</t>

            <t>Defining RFC</t>
          </list></t>

        <t>Four groups are currently defined:</t>

        <texttable title="DIO Base Option Flags">
          <ttcol align="center">Bit</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0</c>

          <c>Grounded DAG</c>

          <c>This document</c>

          <c>1</c>

          <c>Destination Advertisement Trigger</c>

          <c>This document</c>

          <c>2</c>

          <c>Destination Advertisement Supported</c>

          <c>This document</c>

          <c>5,6,7</c>

          <c>DAG Preference</c>

          <c>This document</c>
        </texttable>
      </section>

      <section title="DAG Information Object (DIO) Suboption">
        <t>IANA is requested to create a registry for the DIO Base Option
        Suboptions</t>

        <texttable title="DAG Information Option (DIO) Base Option Suboptions">
          <ttcol align="center">Value</ttcol>

          <ttcol align="left">Meaning</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0</c>

          <c>Pad1 - DIO Padding</c>

          <c>This document</c>

          <c>1</c>

          <c>PadN - DIO suboption padding</c>

          <c>This document</c>

          <c>2</c>

          <c>DAG Metric Container</c>

          <c>This Document</c>

          <c>3</c>

          <c>Destination Prefix</c>

          <c>This Document</c>

          <c>4</c>

          <c>DAG Timer Configuration</c>

          <c>This Document</c>
        </texttable>
      </section>

      <section title="Objective Code Point for the Default Objective Function OF0">
        <t>This specification specifies the Default Objective Function (called
        OF0) for which the OCP field of the OF object, as defined in <xref
        target="I-D.ietf-roll-routing-metrics"></xref>, is equal to 0x0000</t>

        <texttable title="OCP Allocation">
          <ttcol align="center">Value</ttcol>

          <ttcol align="left">Meaning</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0</c>

          <c>OF0</c>

          <c>This document</c>
        </texttable>
      </section>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The authors would like to acknowledge the review, feedback, and
      comments from Emmanuel Baccelli, Dominique Barthel, Yusuf Bashir,
      Mathilde Durvy, Manhar Goindi, Mukul Goyal, Anders Jagd, Quentin Lampin,
      Jerry Martocci, Alexandru Petrescu, and Don Sturek.</t>

      <t>The authors would like to acknowledge the guidance and input provided
      by the ROLL Chairs, David Culler and JP Vasseur.</t>

      <t>The authors would like to acknowledge prior contributions of Robert
      Assimiti, Mischa Dohler, Julien Abeille, Ryuji Wakikawa, Teco Boot,
      Patrick Wetterwald, Bryan Mclaughlin, Carlos J. Bernardos, Thomas
      Watteyne, Zach Shelby, Caroline Bontoux, Marco Molteni, Billy Moon, and
      Arsalan Tavakoli, which have provided useful design considerations to
      RPL.</t>
    </section>

    <section title="Contributors">
      <t>RPL is the result of the contribution of the following members of the
      ROLL Design Team, including the editors, and additional contributors as
      listed below:</t>

      <figure>
        <artwork><![CDATA[
JP Vasseur
Cisco Systems, Inc
11, Rue Camille Desmoulins
Issy Les Moulineaux,   92782
France

Email: jpv@cisco.com
 

Jonathan W. Hui
Arch Rock Corporation
501 2nd St. Ste. 410
San Francisco, CA  94107
USA

Email: jhui@archrock.com


Thomas Heide Clausen
LIX, Ecole Polytechnique, France

Phone: +33 6 6058 9349
EMail: T.Clausen@computer.org
URI:   http://www.ThomasClausen.org/


Richard Kelsey
Ember Corporation
Boston, MA
USA

Phone: +1 617 951 1225
Email: kelsey@ember.com


Philip Levis
Stanford University
358 Gates Hall, Stanford University
Stanford, CA  94305-9030
USA

Email: pal@cs.stanford.edu


Stephen Dawson-Haggerty
UC Berkeley
Soda Hall, UC Berkeley
Berkeley, CA  94720
USA

Email: stevedh@cs.berkeley.edu


Kris Pister
Dust Networks
30695 Huntwood Ave.
Hayward,   94544
USA

Email: kpister@dustnetworks.com


Anders Brandt
Zensys, Inc.
Emdrupvej 26
Copenhagen, DK-2100
Denmark

Email: abr@zen-sys.com
    ]]></artwork>
      </figure>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.I-D.draft-ietf-roll-building-routing-reqs-07.xml'?>

      <?rfc include='reference.I-D.draft-ietf-roll-home-routing-reqs-08.xml'?>

      <?rfc include='reference.RFC.5673'?>

      <?rfc include="reference.RFC.5548"?>

      <?rfc include='reference.I-D.ietf-roll-terminology.xml'?>

      <?rfc include='reference.I-D.ietf-roll-routing-metrics.xml'?>

      <?rfc include='reference.I-D.tsao-roll-security-framework.xml'?>

      <?rfc include="reference.RFC.2453"?>

      <?rfc include="reference.RFC.3819"?>

      <?rfc include="reference.RFC.4101"?>

      <?rfc include="reference.RFC.4191"?>

      <?rfc include="reference.RFC.4443"?>

      <?rfc include="reference.RFC.4861"?>

      <?rfc include="reference.RFC.4915"?>

      <?rfc include="reference.RFC.5120"?>

      <?rfc include="reference.I-D.draft-ietf-bfd-base-09.xml"?>

      <?rfc include="reference.I-D.draft-ietf-manet-nhdp-10.xml"?>

      <reference anchor="Levis08"
                 target="http://portal.acm.org/citation.cfm?id=1364804">
        <front>
          <title abbrev="Levis08">The Emergence of a Networking Primitive in
          Wireless Sensor Networks</title>

          <author fullname="Philip Levis" initials="P." surname="Levis">
            <organization></organization>
          </author>

          <author fullname="Eric Brewer" initials="E." surname="Brewer">
            <organization></organization>
          </author>

          <author fullname="David Culler" initials="D." surname="Culler">
            <organization></organization>
          </author>

          <author fullname="David Gay" initials="D." surname="Gay">
            <organization></organization>
          </author>

          <author fullname="Samuel Madden" initials="S." surname="Madden">
            <organization></organization>
          </author>

          <author fullname="Neil Patel" initials="N." surname="Patel">
            <organization></organization>
          </author>

          <author fullname="Joe Polastre" initials="J." surname="Polastre">
            <organization></organization>
          </author>

          <author fullname="Scott Shenker" initials="S." surname="Shenker">
            <organization></organization>
          </author>

          <author fullname="Robert Szewczyk" initials="R." surname="Szewczyk">
            <organization></organization>
          </author>

          <author fullname="Alec Woo" initials="A." surname="Woo">
            <organization></organization>
          </author>

          <date month="July" year="2008" />
        </front>

        <seriesInfo name="Communications of the ACM," value="v.51 n.7" />

        <format target="http://portal.acm.org/citation.cfm?id=1364804"
                type="HTML" />
      </reference>
    </references>

    <section anchor="Requirements" title="Requirements">
      <section title="Protocol Properties Overview">
        <t>RPL demonstrates the following properties, consistent with the
        requirements specified by the application-specific requirements
        documents.</t>

        <section title="IPv6 Architecture">
          <t>RPL is strictly compliant with layered IPv6 architecture.</t>

          <t>Further, RPL is designed with consideration to the practical
          support and implementation of IPv6 architecture on devices which may
          operate under severe resource constraints, including but not limited
          to memory, processing power, energy, and communication. The RPL
          design does not presume high quality reliable links, and operates
          over lossy links (usually low bandwidth with low packet delivery
          success rate).</t>
        </section>

        <section title="Typical LLN Traffic Patterns">
          <t>Multipoint-to-Point (MP2P) and Point-to-multipoint (P2MP) traffic
          flows from nodes within the LLN from and to egress points are very
          common in LLNs. Low power and lossy network Border Router (LBR)
          nodes may typically be at the root of such flows, although such
          flows are not exclusively rooted at LBRs as determined on an
          application-specific basis. In particular, several applications such
          as building or home automation do require P2P (Point-to-Point)
          communication.</t>

          <t>As required by the aforementioned routing requirements documents,
          RPL supports the installation of multiple paths. The use of multiple
          paths include sending duplicated traffic along diverse paths, as
          well as to support advanced features such as Class of Service (CoS)
          based routing, or simple load balancing among a set of paths (which
          could be useful for the LLN to spread traffic load and avoid fast
          energy depletion on some, e.g. battery powered, nodes).
          Conceptually, multiple instances of RPL can be used to send traffic
          along different topology instances, the construction of which is
          governed by different Objective Functions (OF). Details of RPL
          operation in support of multiple instances are beyond the scope of
          the present specification.</t>
        </section>

        <section title="Constraint Based Routing">
          <t>The RPL design supports constraint based routing, based on a set
          of routing metrics and constraints. The routing metrics and
          constraints for links and nodes with capabilities supported by RPL
          are specified in a companion document to this specification, <xref
          target="I-D.ietf-roll-routing-metrics"></xref>. RPL signals the
          metrics, constraints, and related Objective Functions (OFs) in use
          in a particular implementation by means of an Objective Code Point
          (OCP). Both the routing metrics, constraints, and the OF help
          determine the construction of the Directed Acyclic Graphs (DAG)
          using a distributed path computation algorithm.</t>
        </section>
      </section>

      <section title="Deferred Requirements">
        <t>NOTE: RPL is still a work in progress. At this time there remain
        several unsatisfied application requirements, but these are to be
        addressed as RPL is further specified.</t>
      </section>
    </section>

    <section anchor="Examples" title="Examples">
      <t>Consider the example LLN physical topology in <xref
      target="LLNExample"></xref>. In this example the links depicted are all
      usable L2 links. Suppose that all links are equally usable, and that the
      implementation specific policy function is simply to minimize hops. This
      LLN physical topology then yields the DAG depicted in <xref
      target="DAGExample"></xref>, where the links depicted are the edges
      toward DAG parents. This topology includes one DAG, rooted by an LBR
      node (LBR) at rank 1. The LBR node will issue DIO messages, as governed
      by a trickle timer. Nodes (11), (12), (13), have selected (LBR) as their
      only parent, attached to the DAG at rank 2, and periodically multicast
      DIOs. Node (22) has selected (11) and (12) in its DAG parent set, and
      advertises itself at rank 3. Node (22) thus has a set of DAG parents
      {(11), (12)} and siblings {((21), (23)}.</t>

      <figure anchor="LLNExample" title="Example LLN Topology">
        <artwork><![CDATA[
                                                                     
                                  (LBR)                              
                                  / | \                              
                             .---`  |  `----.                        
                            /       |        \                       
                         (11)------(12)------(13)                    
                          | \       | \       | \                    
                          |  `----. |  `----. |  `----.              
                          |        \|        \|        \             
                         (21)------(22)------(23)      (24)          
                          |        /|        /|         |            
                          |  .----` |  .----` |         |            
                          | /       | /       |         |            
                         (31)------(32)------(33)------(34)          
                          |        /| \       | \       | \          
                          |  .----` |  `----. |  `----. |  `----.    
                          | /       |        \|        \|        \   
                .--------(41)      (42)      (43)------(44)------(45)
               /         /         /| \       | \                    
         .----`    .----`    .----` |  `----. |  `----.              
        /         /         /       |        \|        \             
     (51)------(52)------(53)------(54)------(55)------(56)          
                                                                     
]]></artwork>

        <postamble>Note that the links depicted represent the usable L2
        connectivity available in the LLN. For example, Node (31) can
        communicate directly with its neighbors, Nodes (21), (22), (32), and
        (41). Node (31) cannot communicate directly with any other nodes, e.g.
        (33), (23), (42). In this example these links offer bidirectional
        communication, and `bad' links are not depicted.</postamble>
      </figure>

      <figure anchor="DAGExample" title="Example DAG">
        <artwork><![CDATA[
                                                                     
                                  (LBR)                              
                                  / | \                              
                             .---`  |  `----.                        
                            /       |        \                       
                         (11)      (12)      (13)                    
                          | \       | \       | \                    
                          |  `----. |  `----. |  `----.              
                          |        \|        \|        \             
                         (21)      (22)      (23)      (24)          
                          |        /|        /|         |            
                          |  .----` |  .----` |         |            
                          | /       | /       |         |            
                         (31)      (32)      (33)      (34)          
                          |        /| \       | \       | \          
                          |  .----` |  `----. |  `----. |  `----.    
                          | /       |        \|        \|        \   
                .--------(41)      (42)      (43)      (44)      (45)
               /         /         /| \       | \                    
         .----`    .----`    .----` |  `----. |  `----.              
        /         /         /       |        \|        \             
     (51)      (52)      (53)      (54)      (55)      (56)          
                                                                     
]]></artwork>

        <postamble>Note that the links depicted represent directed links in
        the DAG overlaid on top of the physical topology depicted in <xref
        target="LLNExample"></xref>. As such, the depicted edges represent the
        relationship between nodes and their DAG parents, wherein all depicted
        edges are directed and oriented `up' on the page toward the DAG root
        (LBR). The DAG may provide default routes within the LLN, and serves
        as the foundation on which RPL builds further routing structure, e.g.
        through the destination advertisement mechanism.</postamble>
      </figure>

      <!--
      <section title="Link Removed">
        <t>Consider the example of <xref target="LLNExample"></xref> when link
        (13)-(24) goes down.</t>

        <t><list style="symbols">
            <t>Node (24) will detach / expose infinite rank</t>

            <t>Node (34) will learn that its DAG parent is now part of its own
            floating DAG, will consider that it can remain a part of the DAG
            rooted at node (LBR) via node (33), and will initiate procedures
            to detach from DAG (LBR) in order to re-attach at a lower
            rank.</t>

            <t>Node (45) will similarly make preparations to remain attached
            to the DAG rooted at (LBR) by detaching from Node (34) and
            re-attaching at a lower rank to node (44).</t>

            <t>Node (34) will complete re-attachment to Node (33) first, since
            it is able to attach closer to the root of the DAG.</t>

            <t>Node (45) will cancel plans to detach/reattach, keep node (34)
            as a DAG parent, and update its dependent rank accordingly.</t>

            <t>Node (45) may now anyway add node (44) to its set of DAG
            parents, as such an addition does not require any modification to
            its own rank.</t>

            <t>Node (24) will observe that it may reattach to the DAG rooted
            at node (LBR) by selecting node (34) as its DAG parent, thus
            reversing the relationship that existed in the initial state.</t>
          </list></t>
      </section>
-->

      <!--
      <section title="Link Added">
        <t>Consider the example of <xref target="LLNExample"></xref> when link
        (12)-(42) appears.</t>

        <t><list style="symbols">
            <t>Node (42) will see a chance to get closer to the LBR by adding
            (12) to its set of DAG parents, {(32), (12)}</t>

            <t>Node (42) may be content to leave its advertised rank at 5,
            reflecting a rank deeper than its deepest parent (32).</t>

            <t>Node (42) may now choose to remain where it is, with two
            parents {(12), (32)}. Should there be a reason for Node (42) to
            evict Node (32) from its set of DAG parents, Node (42) would then
            advertise itself at rank 2, thus moving up the DAG. In this case,
            Node (53), (54), and (55) may similarly follow and advertise
            themselves at rank 3.</t>
          </list></t>
      </section>
-->

      <!--
      <section title="Node Removed">
        <t>Consider the example of <xref target="LLNExample"></xref> when node
        (41) disappears.</t>

        <t><list style="symbols">
            <t>Node (51) and (52) will now have empty DAG parent sets and be
            detached from the DAG rooted by (LBR), advertising themselves as
            the root of their own floating DAGs.</t>

            <t>Node (52) would observe a chance to reattach to the DAG rooted
            at (LBR) by adding Node (53) to its set of DAG parents, after an
            appropriate delay to avoid creating loops. Node (52) will then
            advertise itself in the DAG rooted at (LBR) at rank 7.</t>

            <t>Node (51) will then be able to reattach to the DAG rooted at
            (LBR) by adding Node (52) to its set of DAG parents and
            advertising itself at rank 8.</t>
          </list></t>
      </section>
-->

      <!--
      <section title="New LBR Added">
        <t>Consider the example of <xref target="LLNExample"></xref> when a
        new LBR, (LBR2) appears, with connectivity (LBR2)-(52),
        (LBR2)-(53).</t>

        <t><list style="symbols">
            <t>Nodes (52) and Node (53) will see a chance to join a new DAG
            rooted at (LBR2) with a rank of 2. Node (52) and (53) may take
            this chance immediately, as there is no risk of forming loops when
            joining a DAG that has never before been encountered. Note that
            the nodes may choose to join the new DAG rooted at (LBR2) if and
            only if (LBR2) offers more optimum properties in line with the
            implementation specific local policy.</t>

            <t>Nodes (52) and (53) begin to send DIO messages advertising
            themselves at rank 2 in the DAGID (LBR2).</t>

            <t>Nodes (51), (41), (42), and (54) may then choose to join the
            new DAG at rank 3, possibly to get closer to the DAG root. Note
            that in a more advanced case, these nodes also remain members of
            the DAG rooted at (LBR), for example in support of different
            constraints for different types of traffic.</t>

            <t>Node (55) may then join the new DAG at rank 4, possibly to get
            closer to the DAG root.</t>

            <t>The remaining nodes may choose to remain in their current
            positions within the DAG rooted at node (LBR), since there is no
            clear advantage to be gained by moving to DAG (LBR2).</t>
          </list></t>
      </section>
-->

      <section anchor="DestinationAdvertisementExample"
               title="Destination Advertisement">
        <t>Consider the example DAG depicted in <xref
        target="DAGExample"></xref>. Suppose that Nodes (22) and (32) are
        unable to record routing state. Suppose that Node (42) is able to
        perform prefix aggregation on behalf of Nodes (53), (54), and
        (55).</t>

        <t><list style="symbols">
            <t>Node (53) would send a DAO message to Node (42), indicating the
            availability of destination (53).</t>

            <t>Node (54) and Node (55) would similarly send DAO messages to
            Node (42) indicating their own destinations.</t>

            <t>Node (42) would collect and store the routing state for
            destinations (53), (54), and (55).</t>

            <t>In this example, Node (42) may then be capable of representing
            destinations (42), (53), (54), and (55) in the aggregation
            (42').</t>

            <t>Node (42) sends a DAO message advertising destination (42') to
            Node 32.</t>

            <t>Node (32) does not want to maintain any routing state, so it
            adds onto to the Reverse Route Stack in the DAO message and passes
            it on to Node (22) as (42'):[(42)]. It may send a separate DAO
            message to indicate destination (32).</t>

            <t>Node (22) does not want to maintain any routing state, so it
            adds on to the Reverse Route Stack in the DAO message and passes
            it on to Node (12) as (42'):[(42), (32)]. It also relays the DAO
            message containing destination (32) to Node 12 as (32):[(32)], and
            finally may send a DAO message for itself indicating destination
            (22).</t>

            <t>Node (12) is capable to maintain routing state again, and
            receives the DAO messages from Node (22). Node (12) then
            learns:</t>

            <?rfc subcompact="yes"?>

            <list style="symbols">
              <t>Destination (22) is available via Node (22)</t>

              <t>Destination (32) is available via Node (22) and the piecewise
              source route to (32)</t>

              <t>Destination (42') is available via Node (22) and the
              piecewise source route to (32), (42').</t>
            </list>

            <?rfc subcompact="no"?>

            <t>Node (12) sends DAO messages to (LBR), allowing (LBR) to learn
            routes to the destinations (12), (22), (32), and (42'). (42),
            (53), (54), and (55) are available via the aggregation (42'). It
            is not necessary for Node (12) to propagate the piecewise source
            routes to (LBR).</t>
          </list></t>
      </section>

      <section anchor="ExDAGParentSelection"
               title="Example: DAG Parent Selection">
        <t>For example, suppose that a node (N) is not attached to any DAG,
        and that it is in range of nodes (A), (B), (C), (D), and (E). Let all
        nodes be configured to use an OCP which defines a policy such that ETX
        is to be minimized and paths with the attribute `Blue' should be
        avoided. Let the rank computation indicated by the OCP simply reflect
        the ETX aggregated along the path. Let the links between node (N) and
        its neighbors (A-E) all have an ETX of 1 (which is learned by node (N)
        through some implementation specific method). Let node (N) be
        configured to send RPL DIS messages to probe for nearby DAGs.</t>

        <t><list style="symbols">
            <t>Node (N) transmits a RPL DIS message.</t>

            <t>Node (B) responds. Node (N) investigates the DIO message, and
            learns that Node (B) is a member of DAGID 1 at rank 4, and not
            `Blue'. Node (N) takes note of this, but is not yet confident.</t>

            <t>Similarly, Node (N) hears from Node (A) at rank 9, Node (C) at
            rank 5, and Node (E) at rank 4.</t>

            <t>Node (D) responds. Node (D) has a DIO message that indicates
            that it is a member of DAGID 1 at rank 2, but it carries the
            attribute `Blue'. Node (N)'s policy function rejects Node (D), and
            no further consideration is given.</t>

            <t>This process continues until Node (N), based on implementation
            specific policy, builds up enough confidence to trigger a decision
            to join DAGID 1. Let Node (N) determine its most preferred parent
            to be Node (E).</t>

            <t>Node (N) adds Node (E) (rank 4) to its set of DAG parents for
            DAGID 1. Following the mechanisms specified by the OCP, and given
            that the ETX is 1 for the link between (N) and (E), Node (N) is
            now at rank 5 in DAGID 1.</t>

            <t>Node (N) adds Node (B) (rank 4) to its set of DAG parents for
            DAGID 1.</t>

            <t>Node (N) is a sibling of Node (C), both are at rank 5.</t>

            <t>Node (N) may now forward traffic intended for the default
            destination inward along DAGID 1 via nodes (B) and (E). In some
            cases, e.g. if nodes (B) and (E) are tried and fail, node (N) may
            also choose to forward traffic to its sibling node (C), without
            making inward progress but with the intention that node (C) or a
            following successor can make inward progress. Should Node (C) not
            have a viable parent, it should never send the packet back to Node
            (N) (to avoid a 2-node loop).</t>
          </list></t>
      </section>

      <section anchor="ExDAGMaintenance" title="Example: DAG Maintenance">
        <figure anchor="DAGMaintenance" title="DAG Maintenance">
          <artwork><![CDATA[
                                                                     
       :                      :                      :               
       :                      :                      :               
      (A)                    (A)                    (A)              
       |\                     |                      |               
       | `-----.              |                      |               
       |        \             |                      |               
      (B)       (C)          (B)       (C)          (B)              
                 |                      |             \              
                 |                      |              `-----.       
                 |                      |                     \      
                (D)                    (D)                    (C)    
                                                               |     
                                                               |     
                                                               |     
                                                              (D)    
                                                                     
           -1-                    -2-                    -3-         
                                                                     
]]></artwork>
        </figure>

        <t>Consider the example depicted in <xref
        target="DAGMaintenance"></xref>-1. In this example, Node (A) is
        attached to a DAG at some rank d. Node (A) is a DAG parent of Nodes
        (B) and (C). Node (C) is a DAG parent of Node (D). There is also an
        undirected sibling link between Nodes (B) and (C).</t>

        <t>In this example, Node (C) may safely forward to Node (A) without
        creating a loop. Node (C) may not safely forward to Node (D),
        contained within it's own sub-DAG, without creating a loop. Node (C)
        may forward to Node (B) in some cases, e.g. the link (C)-&gt;(A) is
        temporarily unavailable, but with some chance of creating a loop (e.g.
        if multiple nodes in a set of siblings start forwarding `sideways' in
        a cycle) and requiring the intervention of additional mechanisms to
        detect and break the loop.</t>

        <t>Consider the case where Node (C) hears a DIO message from a Node
        (Z) at a lesser rank and superior position in the DAG than node (A).
        Node (C) may safely undergo the process to evict node (A) from its DAG
        parent set and attach directly to Node (Z) without creating a loop,
        because its rank will decrease.</t>

        <t>Now consider the case where the link (C)-&gt;(A) becomes nonviable,
        and node (C) must move to a deeper rank within the DAG:</t>

        <t><list style="symbols">
            <t>Node (C) must first detach from the DAG by removing Node (A)
            from its DAG parent set, leaving an empty DAG parent set. Node (C)
            may become the root of its own floating, less preferred, DAG.</t>

            <t>Node (D), hearing a modified DIO message from Node (C), follows
            Node (C) into the floating DAG. This is depicted in <xref
            target="DAGMaintenance"></xref>-2. In general, any node with no
            other options in the sub-DAG of Node (C) will follow Node (C) into
            the floating DAG, maintaining the structure of the sub-DAG.</t>

            <t>Node (C) hears a DIO message with an incremented
            DAGSequenceNumber from Node (B) and determines it is able to
            rejoin the grounded DAG by reattaching at a deeper rank to Node
            (B). Node (C) adds Node (B) to its DAG parent set. Node (C) has
            now safely moved deeper within the grounded DAG without creating
            any loops.</t>

            <t>Node (D), and any other sub-DAG of Node (C), will hear the
            modified DIO message sourced from Node (C) and follow Node (C) in
            a coordinated manner to reattach to the grounded DAG. The final
            DAG is depicted in <xref target="DAGMaintenance"></xref>-3</t>
          </list></t>
      </section>

      <section anchor="ExGreedyExample"
               title="Example: Greedy Parent Selection and Instability">
        <figure anchor="Greedy" title="Greedy DAG Parent Selection">
          <artwork><![CDATA[
                                                                     
      (A)                    (A)                    (A)              
       |\                     |\                     |\              
       | `-----.              | `-----.              | `-----.       
       |        \             |        \             |        \      
      (B)       (C)          (B)        \            |        (C)    
                               \        |            |        /      
                                `-----. |            | .-----`       
                                       \|            |/              
                                       (C)          (B)              
                                                                     
           -1-                    -2-                    -3-         
                                                                     
]]></artwork>
        </figure>

        <t>Consider the example depicted in <xref target="Greedy"></xref>. A
        DAG is depicted in 3 different configurations. A usable link between
        (B) and (C) exists in all 3 configurations. In <xref
        target="Greedy"></xref>-1, Node (A) is a DAG parent for Nodes (B) and
        (C), and (B)--(C) is a sibling link. In <xref
        target="Greedy"></xref>-2, Node (A) is a DAG parent for Nodes (B) and
        (C), and Node (B) is also a DAG parent for Node (C). In <xref
        target="Greedy"></xref>-3, Node (A) is a DAG parent for Nodes (B) and
        (C), and Node (C) is also a DAG parent for Node (B).</t>

        <t>If a RPL node is too greedy, in that it attempts to optimize for an
        additional number of parents beyond its preferred parent, then an
        instability can result. Consider the DAG illustrated in <xref
        target="Greedy"></xref>-1. In this example, Nodes (B) and (C) may most
        prefer Node (A) as a DAG parent, but are operating under the greedy
        condition that will try to optimize for 2 parents.</t>

        <t>When the preferred parent selection causes a node to have only one
        parent and no siblings, the node may decide to insert itself at a
        slightly higher rank in order to have at least one sibling and thus an
        alternate forwarding solution. This does not deprive other nodes of a
        forwarding solution and this is considered acceptable greediness.</t>

        <t><list style="symbols">
            <t>Let <xref target="Greedy"></xref>-1 be the initial
            condition.</t>

            <t>Suppose Node (C) first is able to leave the DAG and rejoin at a
            lower rank, taking both Nodes (A) and (B) as DAG parents as
            depicted in <xref target="Greedy"></xref>-2. Now Node (C) is
            deeper than both Nodes (A) and (B), and Node (C) is satisfied to
            have 2 DAG parents.</t>

            <t>Suppose Node (B), in its greediness, is willing to receive and
            process a DIO message from Node (C) (against the rules of RPL),
            and then Node (B) leaves the DAG and rejoins at a lower rank,
            taking both Nodes (A) and (C) as DAG parents. Now Node (B) is
            deeper than both Nodes (A) and (C) and is satisfied with 2 DAG
            parents.</t>

            <t>Then Node (C), because it is also greedy, will leave and rejoin
            deeper, to again get 2 parents and have a lower rank then both of
            them.</t>

            <t>Next Node (B) will again leave and rejoin deeper, to again get
            2 parents</t>

            <t>And again Node (C) leaves and rejoins deeper...</t>

            <t>The process will repeat, and the DAG will oscillate between
            <xref target="Greedy"></xref>-2 and <xref
            target="Greedy"></xref>-3 until the nodes count to infinity and
            restart the cycle again.</t>

            <t>This cycle can be averted through mechanisms in RPL: <list>
                <t>Nodes (B) and (C) stay at a rank sufficient to attach to
                their most preferred parent (A) and don't go for any deeper
                (worse) alternate parents (Nodes are not greedy)</t>

                <t>Nodes (B) and (C) do not process DIO messages from nodes
                deeper than themselves (because such nodes are possibly in
                their own sub-DAGs)</t>
              </list></t>
          </list></t>
      </section>
    </section>

    <section anchor="TODO" title="Outstanding Issues">
      <t>This section enumerates some outstanding issues that are to be
      addressed in future revisions of the RPL specification.</t>

      <section title="Additional Support for P2P Routing">
        <t>In some situations the baseline mechanism to support arbitrary P2P
        traffic, by flowing inward along the DAG until a common parent is
        reached and then flowing outward, may not be suitable for all
        application scenarios. A related scenario may occur when the outward
        paths setup along the DAG by the destination advertisement mechanism
        are not be the most desirable outward paths for the specific
        application scenario (in part because the DAG links may not be
        symmetric). It may be desired to support within RPL the discovery and
        installation of more direct routes `across' the DAG. Such mechanisms
        need to be investigated.</t>
      </section>

      <section title="Loop Detection">
        <t>It is under investigation to complement the loop avoidance
        strategies provided by RPL with a loop detection mechanism that may be
        employed when traffic is forwarded.</t>
      </section>

      <section title="Destination Advertisement / DAO Fan-out">
        <t>When DAO messages are relayed to more than one DAG parent, in some
        cases a situation may be created where a large number of DAO messages
        conveying information about the same destination flow inward along the
        DAG. It is desirable to bound/limit the multiplication/fan-out of DAO
        messages in this manner. Some aspects of the Destination Advertisement
        mechanism remain under investigation, such as behavior in the face of
        links that may not be symmetric.</t>

        <t>In general, the utility of providing redundancy along outwards
        routes by sending DAO messages to more than one parent is under
        investigation.</t>

        <t>The use of suitable triggers, such as the `D' bit, to trigger DA
        operation within an affected sub-DAG, is under investigation. Further,
        the ability to limit scope of the affected depth within the sub-DAG is
        under investigation (e.g. if a stateful node can proxy for all nodes
        `behind' it, then there may be no need to propagate the triggered `D'
        bit further).</t>
      </section>

      <section title="Source Routing">
        <t>In support of nodes that maintain minimal routing state, and to
        make use of the collection of piecewise source routes from the
        destination advertisement mechanism, there needs to be some
        investigation of a mechanism to specify, attach, and follow source
        routes for packets traversing the LLN.</t>
      </section>

      <section title="Address / Header Compression">
        <t>In order to minimize overhead within the LLN it is desirable to
        perform some sort of address and/or header compression, perhaps via
        labels, addresses aggregation, or some other means. This is still
        under investigation.</t>
      </section>
    </section>
  </back>
</rfc>
