


Network Working Group                                           M. Jones
Internet-Draft                                                 Microsoft
Intended status: Standards Track                              D. Balfanz
Expires: September 29, 2011                                       Google
                                                              J. Bradley
                                                             independent
                                                               Y. Goland
                                                               Microsoft
                                                               J. Panzer
                                                                  Google
                                                             N. Sakimura
                                               Nomura Research Institute
                                                               P. Tarjan
                                                                Facebook
                                                          March 28, 2011


                          JSON Web Token (JWT)
                     draft-jones-json-web-token-03

Abstract

   JSON Web Token (JWT) is a means of representing claims to be
   transferred between two parties.  The claims in a JWT are encoded as
   a JSON object that is digitally signed using a JSON Web Signature
   (JWS) and optionally encrypted using JSON Web Encryption (JWE).

   The suggested pronunciation of JWT is the same as the English word
   "jot".

Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any



Jones, et al.          Expires September 29, 2011               [Page 1]

Internet-Draft            JSON Web Token (JWT)                March 2011


   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on September 29, 2011.

Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.
































Jones, et al.          Expires September 29, 2011               [Page 2]

Internet-Draft            JSON Web Token (JWT)                March 2011


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  4
   3.  JSON Web Token (JWT) Overview  . . . . . . . . . . . . . . . .  5
     3.1.  Example JWT  . . . . . . . . . . . . . . . . . . . . . . .  5
   4.  JWT Claims . . . . . . . . . . . . . . . . . . . . . . . . . .  6
     4.1.  Reserved Claim Names . . . . . . . . . . . . . . . . . . .  7
     4.2.  Public Claim Names . . . . . . . . . . . . . . . . . . . .  9
     4.3.  Private Claim Names  . . . . . . . . . . . . . . . . . . .  9
   5.  JWT Header . . . . . . . . . . . . . . . . . . . . . . . . . .  9
   6.  Rules for Creating and Validating a JWT  . . . . . . . . . . . 10
   7.  Base64url encoding as used by JWTs . . . . . . . . . . . . . . 12
   8.  Signing JWTs with Cryptographic Algorithms . . . . . . . . . . 12
   9.  Unsigned JWTs  . . . . . . . . . . . . . . . . . . . . . . . . 13
   10. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 13
   11. Security Considerations  . . . . . . . . . . . . . . . . . . . 13
     11.1. Unicode Comparison Security Issues . . . . . . . . . . . . 14
   12. Open Issues and Things To Be Done (TBD)  . . . . . . . . . . . 14
   13. References . . . . . . . . . . . . . . . . . . . . . . . . . . 15
     13.1. Normative References . . . . . . . . . . . . . . . . . . . 15
     13.2. Informative References . . . . . . . . . . . . . . . . . . 16
   Appendix A.  JWT Examples  . . . . . . . . . . . . . . . . . . . . 16
     A.1.  JWT using HMAC SHA-256 . . . . . . . . . . . . . . . . . . 16
     A.2.  JWT using RSA SHA-256  . . . . . . . . . . . . . . . . . . 18
     A.3.  JWT using ECDSA P-256 SHA-256  . . . . . . . . . . . . . . 20
   Appendix B.  Notes on implementing base64url encoding without
                padding . . . . . . . . . . . . . . . . . . . . . . . 22
   Appendix C.  Relationship of JWTs to SAML Tokens . . . . . . . . . 23
   Appendix D.  Relationship of JWTs to Simple Web Tokens (SWTs)  . . 23
   Appendix E.  Acknowledgements  . . . . . . . . . . . . . . . . . . 23
   Appendix F.  Document History  . . . . . . . . . . . . . . . . . . 23
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 24


















Jones, et al.          Expires September 29, 2011               [Page 3]

Internet-Draft            JSON Web Token (JWT)                March 2011


1.  Introduction

   JSON Web Token (JWT) is a compact token format intended for space
   constrained environments such as HTTP Authorization headers and URI
   query parameters.  JWTs encode claims to be transmitted as a JSON
   object (as defined in RFC 4627 [RFC4627]) that is base64url encoded
   and digitally signed.  Signing is accomplished using a JSON Web
   Signature (JWS) [JWS].  JWTs may also be optionally encrypted using
   JSON Web Encryption (JWE) [JWE].

   The suggested pronunciation of JWT is the same as the English word
   "jot".


2.  Terminology

   JSON Web Token (JWT)  A string consisting of three JWT Token
      Segments: the JWT Header Segment, the JWT Claim Segment, and the
      JWT Crypto Segment, in that order, with the segments being
      separated by period ('.') characters.

   JWT Token Segment  One of the three parts that make up a JSON Web
      Token (JWT).  JWT Token Segments are always base64url encoded
      values.

   JWT Header Segment  A JWT Token Segment containing a base64url
      encoded JSON object that describes the cryptographic operations
      applied to the JWT Header Segment and the JWT Claim Segment.  The
      JWT Header Segment is the JWS Header Input for creating a JSON Web
      Signature (JWS) [JWS] for the JWT.

   JWT Claim Segment  A JWT Token Segment containing a base64url encoded
      JSON object that encodes the claims contained in the JWT.  The JWT
      Claim Segment is the JWS Payload Input for creating a JSON Web
      Signature (JWS) [JWS] for the JWT.

   JWT Crypto Segment  A JWT Token Segment containing base64url encoded
      cryptographic material that secures the contents of the JWT Header
      Segment and the JWT Claim Segment.  The JWT Crypto Segment is the
      JWS Crypto Output for a JSON Web Signature (JWS) [JWS] created for
      the JWT.

   Decoded JWT Header Segment  A JWT Header Segment that has been
      base64url decoded back into a JSON object.







Jones, et al.          Expires September 29, 2011               [Page 4]

Internet-Draft            JSON Web Token (JWT)                March 2011


   Decoded JWT Claim Segment  A JWT Claim Segment that has been
      base64url decoded back into a JSON object.

   Decoded JWT Crypto Segment  A JWT Crypto Segment that has been
      base64url decoded back into cryptographic material.

   Claim Names  The names of the members of the JSON object represented
      in a JWT Claim Segment.

   Claim Values  The values of the members of the JSON object
      represented in a JWT Claim Segment.

   Base64url Encoding  For the purposes of this specification, this term
      always refers to the he URL- and filename-safe Base64 encoding
      described in RFC 4648 [RFC4648], Section 5, with the '=' padding
      characters omitted, as permitted by Section 3.2.


3.  JSON Web Token (JWT) Overview

   JWTs represent a set of claims as a JSON object that is base64url
   encoded and digitally signed and optionally encrypted.  As per RFC
   4627 [RFC4627] Section 2.2, the JSON object consists of zero or more
   name/value pairs (or members), where the names are strings and the
   values are arbitrary JSON values.  These members are the claims
   represented by the JWT.  The JSON object is base64url encoded to
   produce the JWT Claim Segment.

   The member names within the Decoded JWT Claim Segment are referred to
   as Claim Names.  These names MUST be unique.  The corresponding
   values are referred to as Claim Values.

   The JWT Claim Object is signed in the manner described in JSON Web
   Signature (JWS) [JWS] and optionally encrypted in the manner
   described in JSON Web Encryption (JWE) [JWE].  The JWT Claim Object
   is the JWS Payload Input.  The JWT Header Object is the JWS Header
   Input.  The JWT Crypto Segment is the corresponding JWS Crypto
   Output.

   A JWT is represented as the concatenation of the JWT Header Segment,
   the JWT Claim Segment, and the JWT Crypto Segment, in that order,
   with the segments being separated by period ('.') characters.

3.1.  Example JWT

   The following is an example of a JSON object that can be encoded to
   produce a JWT Claim Segment:




Jones, et al.          Expires September 29, 2011               [Page 5]

Internet-Draft            JSON Web Token (JWT)                March 2011


   {"iss":"joe",
    "exp":1300819380,
    "http://example.com/is_root":true}

   Base64url encoding the UTF-8 representation of the JSON object yields
   this JWT Claim Segment:
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ

   The following example JSON header object declares that the encoded
   object is a JSON Web Token (JWT) and the JWT Header Segment and the
   JWT Claim Segment are signed using the HMAC SHA-256 algorithm:
   {"typ":"JWT",
    "alg":"HS256"}

   Base64url encoding the UTF-8 representation of the JSON header object
   yields this JWT Header Segment value:
   eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9

   Signing the UTF-8 representation of the JWT Header Segment and JWT
   Claim Segment with the HMAC SHA-256 algorithm and base64url encoding
   the result, as per Appendix A.1, in the manner specified in [JWS],
   yields this JWT Crypto Segment value:
   dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

   Concatenating these segments in the order Header.Claims.Signature
   with period characters between the segments yields this complete JWT
   (with line breaks for display purposes only):
eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

   This computation is illustrated in more detail in Appendix A.1.


4.  JWT Claims

   A JWT contains a set of claims represented as a base64url encoded
   JSON object.  Note however, that the set of claims a JWT must contain
   to be considered valid is context-dependent and is outside the scope
   of this specification.  When used in a security-related context,
   implementations MUST understand and support all of the claims
   present; otherwise, the JWT MUST be rejected for processing.

   There are three classes of JWT Claim Names: Reserved Claim Names,
   Public Claim Names, and Private Claim Names.




Jones, et al.          Expires September 29, 2011               [Page 6]

Internet-Draft            JSON Web Token (JWT)                March 2011


4.1.  Reserved Claim Names

   The following claim names are reserved.  None of the claims defined
   in the table below are intended to be mandatory, but rather, provide
   a starting point for a set of useful, interoperable claims.  All the
   names are short because a core goal of JWTs is for the tokens to be
   compact.

   +-------+---------+--------------+----------------------------------+
   | Claim | JSON    | Claim Syntax | Claim Semantics                  |
   | Name  | Value   |              |                                  |
   |       | Type    |              |                                  |
   +-------+---------+--------------+----------------------------------+
   | exp   | integer | IntDate      | The "exp" (expiration time)      |
   |       |         |              | claim identifies the expiration  |
   |       |         |              | time on or after which the token |
   |       |         |              | MUST NOT be accepted for         |
   |       |         |              | processing.  The processing of   |
   |       |         |              | the "exp" claim requires that    |
   |       |         |              | the current date/time MUST be    |
   |       |         |              | before the expiration date/time  |
   |       |         |              | listed in the "exp" claim.       |
   |       |         |              | Implementers MAY provide for     |
   |       |         |              | some small leeway, usually no    |
   |       |         |              | more than a few minutes, to      |
   |       |         |              | account for clock skew.  This    |
   |       |         |              | claim is OPTIONAL.               |
   | iat   | integer | IntDate      | The "iat" (issued at) claim      |
   |       |         |              | identifies the UTC time at which |
   |       |         |              | the JWT was issued.  The         |
   |       |         |              | processing of the "iat" claim    |
   |       |         |              | requires that the current        |
   |       |         |              | date/time MUST be after the      |
   |       |         |              | issued date/time listed in the   |
   |       |         |              | "iat" claim.  Implementers MAY   |
   |       |         |              | provide for some small leeway,   |
   |       |         |              | usually no more than a few       |
   |       |         |              | minutes, to account for clock    |
   |       |         |              | skew.  This claim is OPTIONAL.   |
   | iss   | string  | StringAndURI | The "iss" (issuer) claim         |
   |       |         |              | identifies the principal that    |
   |       |         |              | issued the JWT.  The processing  |
   |       |         |              | of this claim is generally       |
   |       |         |              | application specific.  The "iss" |
   |       |         |              | value is case sensitive.  This   |
   |       |         |              | claim is OPTIONAL.               |





Jones, et al.          Expires September 29, 2011               [Page 7]

Internet-Draft            JSON Web Token (JWT)                March 2011


   | aud   | string  | StringAndURI | The "aud" (audience) claim       |
   |       |         |              | identifies the audience that the |
   |       |         |              | JWT is intended for.  The        |
   |       |         |              | principal intended to process    |
   |       |         |              | the JWT MUST be identified by    |
   |       |         |              | the value of the audience claim. |
   |       |         |              | If the principal processing the  |
   |       |         |              | claim does not identify itself   |
   |       |         |              | with the identifier in the "aud" |
   |       |         |              | claim value then the JWT MUST be |
   |       |         |              | rejected.  The interpretation of |
   |       |         |              | the contents of the audience     |
   |       |         |              | value is generally application   |
   |       |         |              | specific.  The "aud" value is    |
   |       |         |              | case sensitive.  This claim is   |
   |       |         |              | OPTIONAL.                        |
   | typ   | string  | String       | The "typ" (type) claim is used   |
   |       |         |              | to declare a type for the        |
   |       |         |              | contents of this JWT.  The "typ" |
   |       |         |              | value is case sensitive.  This   |
   |       |         |              | claim is OPTIONAL.               |
   +-------+---------+--------------+----------------------------------+

                    Table 1: Reserved Claim Definitions

   Additional reserved claim names MAY be defined via the IANA JSON Web
   Token Claims registry, as per Section 10.  The syntax values used
   above are defined as follows:

   +--------------+----------------------------------------------------+
   | Syntax Name  | Syntax Definition                                  |
   +--------------+----------------------------------------------------+
   | IntDate      | The number of seconds from 1970-01-01T0:0:0Z as    |
   |              | measured in UTC until the desired date/time.  See  |
   |              | RFC 3339 [RFC3339] for details regarding           |
   |              | date/times in general and UTC in particular.       |
   | String       | Any string value MAY be used.                      |
   | StringAndURI | Any string value MAY be used but a value           |
   |              | containing a ":" character MUST be a URI as        |
   |              | defined in RFC 3986 [RFC3986].                     |
   +--------------+----------------------------------------------------+

                     Table 2: Claim Syntax Definitions








Jones, et al.          Expires September 29, 2011               [Page 8]

Internet-Draft            JSON Web Token (JWT)                March 2011


4.2.  Public Claim Names

   Claim names can be defined at will by those using JWTs.  However, in
   order to prevent collisions, any new claim name SHOULD either be
   defined in the IANA JSON Web Token Claims registry or be defined as a
   URI that contains a collision resistant namespace.  Examples of
   collision resistant namespaces include:

   o  Domain Names,

   o  Object Identifiers (OIDs) as defined in the ITU-T X 660 and X 670
      Recommendation series or

   o  Universally Unique IDentifier (UUID) as defined in RFC 4122
      [RFC4122].

   In each case, the definer of the name or value MUST take reasonable
   precautions to make sure they are in control of the part of the
   namespace they use to define the claim name.

4.3.  Private Claim Names

   A producer and consumer of a JWT may agree to any claim name that is
   not a Reserved Name Section 4.1 or a Public Name Section 4.2.  Unlike
   Public Names, these private names are subject to collision and should
   be used with caution.


5.  JWT Header

   The members of the JSON object represented by the Decoded JWT Header
   Segment describe the cryptographic operations applied to the JWT
   Header Segment and the JWT Claim Segment and optionally, additional
   properties of the JWT.  The JWT Header Segment is used as the JWS
   Header Input for signing.  The format of the header and the
   cryptographic operations applied MUST be as specified in JSON Web
   Signature (JWS) [JWS] and JSON Web Encryption (JWE) [JWE].

   Implementations MUST understand the entire contents of the header;
   otherwise, the JWT MUST be rejected for processing.

   JWS Header Parameters are defined by [JWS].  This specification
   further specifies the use of the following header parameters when the
   JWS Header Input is a JWT Header Segment.







Jones, et al.          Expires September 29, 2011               [Page 9]

Internet-Draft            JSON Web Token (JWT)                March 2011


   +----------+--------+-----------+-----------------------------------+
   | Header   | JSON   | Header    | Header Parameter Semantics        |
   | Paramete | Value  | Parameter |                                   |
   | rName    | Type   | Syntax    |                                   |
   +----------+--------+-----------+-----------------------------------+
   | typ      | string | String    | The "typ" (type) header parameter |
   |          |        |           | MAY be used to declare that this  |
   |          |        |           | data structure is a JWT.  If a    |
   |          |        |           | "typ" parameter is present, it is |
   |          |        |           | RECOMMENDED that its value be     |
   |          |        |           | either "JWT" or                   |
   |          |        |           | "http://openid.net/specs/jwt/1.0" |
   |          |        |           | .Use of this header parameter is  |
   |          |        |           |  OPTIONAL.                        |
   +----------+--------+-----------+-----------------------------------+

                 Table 3: Reserved Header Parameter Usage


6.  Rules for Creating and Validating a JWT

   To create a JWT, one MUST follow these steps:

   1.  Create a JSON object containing the desired claims.  Note that
       white space is explicitly allowed in the representation and no
       canonicalization is performed before encoding.

   2.  Translate this JSON object's Unicode code points into UTF-8, as
       defined in RFC 3629 [RFC3629].  This is the Decoded JWT Claim
       Segment.

   3.  Base64url encode the Decoded JWT Claim Segment.  This encoding
       becomes the JWT Claim Segment.

   4.  Create a JSON object containing a set of desired header
       parameters that conform to the [JWS] and [JWE] specifications.
       Note that white space is explicitly allowed in the representation
       and no canonicalization is performed before encoding.

   5.  Translate this JSON object's Unicode code points into UTF-8, as
       defined in RFC 3629 [RFC3629].  This is the Decoded JWT Header
       Segment.

   6.  Base64url encode the UTF-8 representation of this JSON object as
       defined in this specification (without padding).  This encoding
       becomes a JWT Header Segment.





Jones, et al.          Expires September 29, 2011              [Page 10]

Internet-Draft            JSON Web Token (JWT)                March 2011


   7.  Unless the "alg" value is ""none"", sign and optionally encrypt
       the JWT Header Segment and JWT Claim Segment values in the manner
       described in the [JWS] and [JWE] specifications; the JWT Header
       Segment is used as the JWS Header Input and the JWT Claim Segment
       is used as the JWS Payload Input; the resulting JWS Crypto Output
       is used as the JWT Claim Segment.  Otherwise, if the "alg" value
       is ""none"", the JWT Claim Segment is the empty string.

   8.  Concatenate the JWT Header Segment, the JWT Claim Segment, and
       the JWT Crypto Segment in that order, separating each by period
       characters, to create the JWT.

   When validating a JWT the following steps MUST be taken.  If any of
   the listed steps fails then the token MUST be rejected for
   processing.

   1.   The JWT MUST contain two period characters.

   2.   The JWT MUST be split on the two period characters resulting in
        three segment strings.  The first segment is the JWT Header
        Segment; the second is the JWT Claim Segment; the third is the
        JWT Crypto Segment.

   3.   The JWT Claim Segment MUST be successfully base64url decoded
        following the restriction given in this specification that no
        padding characters have been used.

   4.   The Decoded JWT Claim Segment MUST be completely valid JSON
        syntax conforming to RFC 4627 [RFC4627].

   5.   When used in a security-related context, the Decoded JWT Claim
        Segment MUST be validated to only include claims whose syntax
        and semantics are both understood and supported.

   6.   The JWT Header Segment MUST be successfully base64url decoded
        following the restriction given in this specification that no
        padding characters have been used.

   7.   The Decoded JWT Header Segment MUST be completely valid JSON
        syntax conforming to RFC 4627 [RFC4627].

   8.   The JWT Crypto Segment MUST be successfully base64url decoded
        following the restriction given in this specification that no
        padding characters have been used.

   9.   The JWT Header Segment MUST be validated to only include
        parameters and values whose syntax and semantics are both
        understood and supported.



Jones, et al.          Expires September 29, 2011              [Page 11]

Internet-Draft            JSON Web Token (JWT)                March 2011


   10.  Unless the "alg" value is ""none"", the JWT Crypto Segment MUST
        be successfully validated against the JWT Header Segment and JWT
        Claim Segment in the manner defined by the [JWS] and [JWE]
        specifications; otherwise the JWT Crypto Segment MUST be the
        empty string.

   Processing a JWT inevitably requires comparing known strings to
   values in the token.  For example, in checking what the algorithm is,
   the Unicode string encoding "alg" will be checked against the member
   names in the Decoded JWT Header Segment to see if there is a matching
   header parameter name.  A similar process occurs when determining if
   the value of the "alg" header parameter represents a supported
   algorithm.  Comparing Unicode strings, however, has significant
   security implications, as per Section 11.

   Comparisons between JSON strings and other Unicode strings MUST be
   performed as specified below:

   1.  Remove any JSON applied escaping to produce an array of Unicode
       code points.

   2.  Unicode Normalization [USA15] MUST NOT be applied at any point to
       either the JSON string or to the string it is to be compared
       against.

   3.  Comparisons between the two strings MUST be performed as a
       Unicode code point to code point equality comparison.


7.  Base64url encoding as used by JWTs

   JWTs make use of the base64url encoding as defined in RFC 4648
   [RFC4648].  As allowed by Section 3.2 of the RFC, this specification
   mandates that base64url encoding when used with JWTs MUST NOT use
   padding.  The reason for this restriction is that the padding
   character ('=') is not URL safe.

   For notes on implementing base64url encoding without padding, see
   Appendix B.


8.  Signing JWTs with Cryptographic Algorithms

   JWTs use JSON Web Signatures (JWSs) [JWS] and JSON Web Encryption
   (JWE) [JWE] to sign and optionally encrypt the contents of the JWT
   Header Segment and the JWT Claim Segment to produce the JWT Crypto
   Segment Value.




Jones, et al.          Expires September 29, 2011              [Page 12]

Internet-Draft            JSON Web Token (JWT)                March 2011


   Of the JWS signing algorithms, only HMAC SHA-256 MUST be implemented
   by conforming JWT implementations.  It is RECOMMENDED that
   implementations also support the RSA SHA-256 and ECDSA P-256 SHA-256
   algorithms.  Support for other algorithms is OPTIONAL.


9.  Unsigned JWTs

   To support use cases where the JWT content is secured by a means
   other than a signature contained within the token (such as signature
   on a data structure containing the token), JWTs MAY also be created
   without a signature.  Unsigned JWTs MUST use the "alg" value ""none""
   and use the empty string as the JWT Crypto Segment value.


10.  IANA Considerations

   This specification calls for:

   o  A new IANA registry entitled "JSON Web Token Claims" for reserved
      claim names is defined in Section 4.1.  Inclusion in the registry
      is RFC Required in the RFC 5226 [RFC5226] sense for reserved JWT
      claim names that are intended to be interoperable between
      implementations.  The registry will just record the reserved claim
      name and a pointer to the RFC that defines it.  This specification
      defines inclusion of the claim names defined in Table 1.


11.  Security Considerations

   TBD: Lots of work to do here.  We need to remember to look into any
   issues relating to security and JSON parsing.  One wonders just how
   secure most JSON parsing libraries are.  Were they ever hardened for
   security scenarios?  If not, what kind of holes does that open up?
   Also, we need to walk through the JSON standard and see what kind of
   issues we have especially around comparison of names.  For instance,
   comparisons of claim names and other parameters must occur after they
   are unescaped.  Need to also put in text about: Importance of keeping
   secrets secret.  Rotating keys.  Strengths and weaknesses of the
   different algorithms.

   TBD: Need to put in text about why strict JSON validation is
   necessary.  Basically, that if malformed JSON is received then the
   intent of the sender is impossible to reliably discern.  While in
   non-security contexts it's o.k. to be generous in what one accepts,
   in security contexts this can lead to serious security holes.  For
   example, malformed JSON might indicate that someone has managed to
   find a security hole in the issuer's code and is leveraging it to get



Jones, et al.          Expires September 29, 2011              [Page 13]

Internet-Draft            JSON Web Token (JWT)                March 2011


   the issuer to issue "bad" tokens whose content the attacker can
   control.

   TBD: Write about need to secure token content if a signature is not
   contained in the JWT itself.

11.1.  Unicode Comparison Security Issues

   Claim names in JWTs are Unicode strings.  For security reasons, the
   representations of these names must be compared verbatim after
   performing any escape processing (as per RFC 4627 [RFC4627], Section
   2.5).

   This means, for instance, that these JSON strings must compare as
   being equal ("JWT", "\u004aWT"), whereas these must all compare as
   being not equal to the first set or to each other ("jwt", "Jwt",
   "JW\u0074").

   JSON strings MAY contain characters outside the Unicode Basic
   Multilingual Plane.  For instance, the G clef character (U+1D11E) may
   be represented in a JSON string as "\uD834\uDD1E".  Ideally, JWT
   implementations SHOULD ensure that characters outside the Basic
   Multilingual Plane are preserved and compared correctly;
   alternatively, if this is not possible due to these characters
   exercising limitations present in the underlying JSON implementation,
   then input containing them MUST be rejected.


12.  Open Issues and Things To Be Done (TBD)

   The following items remain to be done in this draft (and related
   drafts):

   o  Consider whether we really want to allow private claim names and
      that are not registered with IANA and are not in collision-
      resistant namespaces.  Eventually this could result in interop
      nightmares where you need to have different code to talk to
      different endpoints that "knows" about each endpoints' private
      parameters.

   o  Clarify the optional ability to provide type information for JWTs
      and/or their segments.  Specifically, clarify the intended use of
      the "typ" Header Parameter and the "typ" claim, whether they
      convey syntax or semantics, and indeed, whether this is the right
      approach.  Also clarify the relationship between these type values
      and MIME [RFC2045] types.





Jones, et al.          Expires September 29, 2011              [Page 14]

Internet-Draft            JSON Web Token (JWT)                March 2011


   o  Finish the Security Considerations section.

   o  Sort out what to do with the IANA registries if this is first
      standardized as an OpenID specification.

   o  Write a companion specification that contains the former JWT JSON
      Serialization.


13.  References

13.1.  Normative References

   [JWS]      Jones, M., Balfanz, D., Bradley, J., Goland, Y., Panzer,
              J., Sakimura, N., and P. Tarjan, "JSON Web Signature
              (JWS)", March 2011.

   [RFC2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", RFC 2045, November 1996.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC3339]  Klyne, G., Ed. and C. Newman, "Date and Time on the
              Internet: Timestamps", RFC 3339, July 2002.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, November 2003.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, January 2005.

   [RFC4627]  Crockford, D., "The application/json Media Type for
              JavaScript Object Notation (JSON)", RFC 4627, July 2006.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, October 2006.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008.

   [USA15]    Davis, M., Whistler, K., and M. Duerst, "Unicode
              Normalization Forms", Unicode Standard Annex 15, 09 2009.





Jones, et al.          Expires September 29, 2011              [Page 15]

Internet-Draft            JSON Web Token (JWT)                March 2011


13.2.  Informative References

   [CanvasApp]
              Facebook, "Canvas Applications", 2010.

   [JSS]      Bradley, J. and N. Sakimura (editor), "JSON Simple Sign",
              September 2010.

   [JWE]      Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Encryption (JWE)", March 2011.

   [MagicSignatures]
              Panzer (editor), J., Laurie, B., and D. Balfanz, "Magic
              Signatures", August 2010.

   [OASIS.saml-core-2.0-os]
              Cantor, S., Kemp, J., Philpott, R., and E. Maler,
              "Assertions and Protocol for the OASIS Security Assertion
              Markup Language (SAML) V2.0", OASIS Standard saml-core-
              2.0-os, March 2005.

   [RFC3275]  Eastlake, D., Reagle, J., and D. Solo, "(Extensible Markup
              Language) XML-Signature Syntax and Processing", RFC 3275,
              March 2002.

   [RFC4122]  Leach, P., Mealling, M., and R. Salz, "A Universally
              Unique IDentifier (UUID) URN Namespace", RFC 4122,
              July 2005.

   [SWT]      Hardt, D. and Y. Goland, "Simple Web Token (SWT)",
              Version 0.9.5.1, November 2009.

   [W3C.CR-xml11-20021015]
              Cowan, J., "Extensible Markup Language (XML) 1.1", W3C
              CR CR-xml11-20021015, October 2002.


Appendix A.  JWT Examples

   This section provides several examples of JWTs.  The cryptographic
   operations for these examples are detailed in the JSON Web Signature
   (JWS) [JWS] specification.

A.1.  JWT using HMAC SHA-256

   The Decoded JWT Claim Segment used in this example is:





Jones, et al.          Expires September 29, 2011              [Page 16]

Internet-Draft            JSON Web Token (JWT)                March 2011


   {"iss":"joe",
    "exp":1300819380,
    "http://example.com/is_root":true}

   Note that white space is explicitly allowed in Decoded JWT Claim
   Segments and no canonicalization is performed before encoding.  The
   following byte array contains the UTF-8 characters for the Decoded
   JWT Claim Segment:

   [123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10,
   32, 34, 101, 120, 112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56,
   48, 44, 13, 10, 32, 34, 104, 116, 116, 112, 58, 47, 47, 101, 120, 97,
   109, 112, 108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111,
   111, 116, 34, 58, 116, 114, 117, 101, 125]

   Base64url encoding the above yields the JWT Claim Segment value:
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ

   The following example JSON header object declares that the data
   structure is a JSON Web Token (JWT) and the JWT Header Segment and
   JWT Crypto Segment are signed using the HMAC SHA-256 algorithm:
   {"typ":"JWT",
    "alg":"HS256"}

   The following byte array contains the UTF-8 characters for the
   Decoded JWT Header Segment:

   [123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34, 44, 13, 10, 32,
   34, 97, 108, 103, 34, 58, 34, 72, 83, 50, 53, 54, 34, 125]

   Base64url encoding this UTF-8 representation yields this JWT Header
   Segment value:
   eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9

   This example uses the key represented by the following byte array:

   [3, 35, 53, 75, 43, 15, 165, 188, 131, 126, 6, 101, 119, 123, 166,
   143, 90, 179, 40, 230, 240, 84, 201, 40, 169, 15, 132, 178, 210, 80,
   46, 191, 211, 251, 90, 146, 210, 6, 71, 239, 150, 138, 180, 195, 119,
   98, 61, 34, 61, 46, 33, 114, 5, 46, 79, 8, 192, 205, 154, 245, 103,
   208, 128, 163]

   Signing the JWT Header Segment and JWT Claim Segment with this key in
   the manner specified by [JWS] yields this JWT Crypto Segment value:
   dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

   Combining these segments in the order Header.Claims.Signature with
   period characters between the segments yields this complete JWT (with



Jones, et al.          Expires September 29, 2011              [Page 17]

Internet-Draft            JSON Web Token (JWT)                March 2011


   line breaks for display purposes only):
eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

A.2.  JWT using RSA SHA-256

   The Decoded JWT Claim Segment used in this example is the same as in
   the previous example:
   {"iss":"joe",
    "exp":1300819380,
    "http://example.com/is_root":true}

   Since the JWT Claim Segment will therefore be the same, its
   computation is not repeated here.  However, the Decoded JWT Header
   Segment is different in two ways: First, because a different
   algorithm is being used, the "alg" value is different.  Second, for
   illustration purposes only, the optional "typ" parameter is not used.
   (This difference is not related to the signature algorithm employed.)
   The Decoded JWT Header Segment used is:
   {"alg":"RS256"}

   The following byte array contains the UTF-8 characters for the
   Decoded JWT Header Segment:

   [123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125]

   Base64url encoding this UTF-8 representation yields this JWT Header
   Segment value:
   eyJhbGciOiJSUzI1NiJ9

   The RSA key consists of a public part (n, e), and a private exponent
   d.  The values of the RSA key used in this example, presented as the
   byte arrays representing big endian integers are:















Jones, et al.          Expires September 29, 2011              [Page 18]

Internet-Draft            JSON Web Token (JWT)                March 2011


   +-----------+-------------------------------------------------------+
   | Parameter | Value                                                 |
   | Name      |                                                       |
   +-----------+-------------------------------------------------------+
   | n         | [161, 248, 22, 10, 226, 227, 201, 180, 101, 206, 141, |
   |           | 45, 101, 98, 99, 54, 43, 146, 125, 190, 41, 225, 240, |
   |           | 36, 119, 252, 22, 37, 204, 144, 161, 54, 227, 139,    |
   |           | 217, 52, 151, 197, 182, 234, 99, 221, 119, 17, 230,   |
   |           | 124, 116, 41, 249, 86, 176, 251, 138, 143, 8, 154,    |
   |           | 220, 75, 105, 137, 60, 193, 51, 63, 83, 237, 208, 25, |
   |           | 184, 119, 132, 37, 47, 236, 145, 79, 228, 133, 119,   |
   |           | 105, 89, 75, 234, 66, 128, 211, 44, 15, 85, 191, 98,  |
   |           | 148, 79, 19, 3, 150, 188, 110, 155, 223, 110, 189,    |
   |           | 210, 189, 163, 103, 142, 236, 160, 198, 104, 247, 1,  |
   |           | 179, 141, 191, 251, 56, 200, 52, 44, 226, 254, 109,   |
   |           | 39, 250, 222, 74, 90, 72, 116, 151, 157, 212, 185,    |
   |           | 207, 154, 222, 196, 199, 91, 5, 133, 44, 44, 15, 94,  |
   |           | 248, 165, 193, 117, 3, 146, 249, 68, 232, 237, 100,   |
   |           | 193, 16, 198, 182, 71, 96, 154, 164, 120, 58, 235,    |
   |           | 156, 108, 154, 215, 85, 49, 48, 80, 99, 139, 131,     |
   |           | 102, 92, 111, 111, 122, 130, 163, 150, 112, 42, 31,   |
   |           | 100, 27, 130, 211, 235, 242, 57, 34, 25, 73, 31, 182, |
   |           | 134, 135, 44, 87, 22, 245, 10, 248, 53, 141, 154,     |
   |           | 139, 157, 23, 195, 64, 114, 143, 127, 135, 216, 154,  |
   |           | 24, 216, 252, 171, 103, 173, 132, 89, 12, 46, 207,    |
   |           | 117, 147, 57, 54, 60, 7, 3, 77, 111, 96, 111, 158,    |
   |           | 33, 224, 84, 86, 202, 229, 233, 161]                  |
   | e         | [1, 0, 1]                                             |























Jones, et al.          Expires September 29, 2011              [Page 19]

Internet-Draft            JSON Web Token (JWT)                March 2011


   | d         | [18, 174, 113, 164, 105, 205, 10, 43, 195, 126, 82,   |
   |           | 108, 69, 0, 87, 31, 29, 97, 117, 29, 100, 233, 73,    |
   |           | 112, 123, 98, 89, 15, 157, 11, 165, 124, 150, 60, 64, |
   |           | 30, 63, 207, 47, 44, 211, 189, 236, 136, 229, 3, 191, |
   |           | 198, 67, 155, 11, 40, 200, 47, 125, 55, 151, 103, 31, |
   |           | 82, 19, 238, 216, 193, 90, 37, 216, 213, 206, 160, 2, |
   |           | 94, 227, 171, 46, 139, 127, 121, 33, 111, 198, 59,    |
   |           | 234, 86, 39, 83, 180, 6, 68, 198, 161, 81, 39, 217,   |
   |           | 178, 149, 69, 64, 160, 187, 225, 163, 5, 86, 152, 45, |
   |           | 78, 159, 222, 95, 100, 37, 241, 77, 75, 113, 52, 65,  |
   |           | 181, 93, 199, 59, 155, 74, 237, 204, 146, 172, 227,   |
   |           | 146, 126, 55, 245, 125, 12, 253, 94, 117, 129, 250,   |
   |           | 81, 44, 143, 73, 97, 169, 235, 11, 128, 248, 168, 7,  |
   |           | 70, 114, 138, 85, 255, 70, 71, 31, 52, 37, 6, 59,     |
   |           | 157, 83, 100, 47, 94, 222, 30, 132, 214, 19, 8, 26,   |
   |           | 250, 92, 34, 208, 81, 40, 91, 214, 59, 148, 59, 86,   |
   |           | 93, 137, 138, 5, 104, 84, 19, 229, 60, 60, 108, 101,  |
   |           | 37, 255, 31, 227, 78, 61, 220, 112, 240, 213, 100,    |
   |           | 80, 253, 164, 139, 161, 46, 16, 78, 157, 235, 159,    |
   |           | 184, 24, 129, 225, 196, 189, 242, 93, 146, 71, 244,   |
   |           | 80, 200, 101, 146, 121, 104, 231, 115, 52, 244, 65,   |
   |           | 79, 117, 167, 80, 225, 57, 84, 110, 58, 138, 115,     |
   |           | 157]                                                  |
   +-----------+-------------------------------------------------------+

   Signing the JWT Header Segment and JWT Claim Segment with this key in
   the manner specified by [JWS] yields this JWT Crypto Segment value:
cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw

   Combining these segments in the order Header.Claims.Signature with
   period characters between the segments yields this complete JWT (with
   line breaks for display purposes only):
eyJhbGciOiJSUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw

A.3.  JWT using ECDSA P-256 SHA-256

   The Decoded JWT Claim Segment used in this example is the same as in
   the previous examples:
   {"iss":"joe",
    "exp":1300819380,
    "http://example.com/is_root":true}

   Since the JWT Claim Segment will therefore be the same, its
   computation is not repeated here.  However, the Decoded JWT Header



Jones, et al.          Expires September 29, 2011              [Page 20]

Internet-Draft            JSON Web Token (JWT)                March 2011


   Segment is differs from the previous example because a different
   algorithm is being used.  The Decoded JWT Header Segment used is:
   {"alg":"ES256"}

   The following byte array contains the UTF-8 characters for the
   Decoded JWT Header Segment:

   [123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54, 34, 125]

   Base64url encoding this UTF-8 representation yields this JWT Header
   Segment value:
   eyJhbGciOiJFUzI1NiJ9

   The ECDSA key consists of a public part, the EC point (x, y), and a
   private part d.  The values of the ECDSA key used in this example,
   presented as the byte arrays representing big endian integers are:

   +-----------+-------------------------------------------------------+
   | Parameter | Value                                                 |
   | Name      |                                                       |
   +-----------+-------------------------------------------------------+
   | x         | [127, 205, 206, 39, 112, 246, 196, 93, 65, 131, 203,  |
   |           | 238, 111, 219, 75, 123, 88, 7, 51, 53, 123, 233, 239, |
   |           | 19, 186, 207, 110, 60, 123, 209, 84, 69]              |
   | y         | [199, 241, 68, 205, 27, 189, 155, 126, 135, 44, 223,  |
   |           | 237, 185, 238, 185, 244, 179, 105, 93, 110, 169, 11,  |
   |           | 36, 173, 138, 70, 35, 40, 133, 136, 229, 173]         |
   | d         | [142, 155, 16, 158, 113, 144, 152, 191, 152, 4, 135,  |
   |           | 223, 31, 93, 119, 233, 203, 41, 96, 110, 190, 210,    |
   |           | 38, 59, 95, 87, 194, 19, 223, 132, 244, 178]          |
   +-----------+-------------------------------------------------------+

   Signing the JWT Header Segment and JWT Claim Segment with this key in
   the manner specified by [JWS] yields this JWT Crypto Segment value:
DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSApmWQxfKTUJqPP3-Kg6NU1Q

   Combining these segments in the order Header.Claims.Signature with
   period characters between the segments yields this complete JWT (with
   line breaks for display purposes only):
eyJhbGciOiJFUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSApmWQxfKTUJqPP3-Kg6NU1Q







Jones, et al.          Expires September 29, 2011              [Page 21]

Internet-Draft            JSON Web Token (JWT)                March 2011


Appendix B.  Notes on implementing base64url encoding without padding

   This appendix describes how to implement base64url encoding and
   decoding functions without padding based upon standard base64
   encoding and decoding functions that do use padding.

   To be concrete, example C# code implementing these functions is shown
   below.  Similar code could be used in other languages.
   static string base64urlencode(byte [] arg)
   {
     string s = Convert.ToBase64String(arg); // Standard base64 encoder
     s = s.Split('=')[0]; // Remove any trailing '='s
     s = s.Replace('+', '-'); // 62nd char of encoding
     s = s.Replace('/', '_'); // 63rd char of encoding
     return s;
   }

   static byte [] base64urldecode(string arg)
   {
     string s = arg;
     s = s.Replace('-', '+'); // 62nd char of encoding
     s = s.Replace('_', '/'); // 63rd char of encoding
     switch (s.Length % 4) // Pad with trailing '='s
     {
       case 0: break; // No pad chars in this case
       case 2: s += "=="; break; // Two pad chars
       case 3: s += "="; break; // One pad char
       default: throw new System.Exception(
         "Illegal base64url string!");
     }
     return Convert.FromBase64String(s); // Standard base64 decoder
   }

   As per the example code above, the number of '=' padding characters
   that needs to be added to the end of a base64url encoded string
   without padding to turn it into one with padding is a deterministic
   function of the length of the encoded string.  Specifically, if the
   length mod 4 is 0, no padding is added; if the length mod 4 is 2, two
   '=' padding characters are added; if the length mod 4 is 3, one '='
   padding character is added; if the length mod 4 is 1, the input is
   malformed.

   An example correspondence between unencoded and encoded values
   follows.  The byte sequence below encodes into the string below,
   which when decoded, reproduces the byte sequence.
   3 236 255 224 193
   A-z_4ME




Jones, et al.          Expires September 29, 2011              [Page 22]

Internet-Draft            JSON Web Token (JWT)                March 2011


Appendix C.  Relationship of JWTs to SAML Tokens

   SAML 2.0 [OASIS.saml-core-2.0-os] provides a standard for creating
   tokens with much greater expressivity and more security options than
   supported by JWTs.  However, the cost of this flexibility and
   expressiveness is both size and complexity.  In addition, SAML's use
   of XML [W3C.CR-xml11-20021015] and XML DSIG [RFC3275] only
   contributes to the size of SAML tokens.

   JWTs are intended to provide a simple token format that is small
   enough to fit into HTTP headers and query arguments in URIs.  It does
   this by supporting a much simpler token model than SAML and using the
   JSON [RFC4627] object encoding syntax.  It also supports securing
   tokens using Hash-based Message Authentication Codes (HMACs) and
   digital signatures using a smaller (and less flexible) format than
   XML DSIG.

   Therefore, while JWTs can do some of the things SAML tokens do, JWTs
   are not intended as a full replacement for SAML tokens, but rather as
   a compromise token format to be used when space is at a premium.


Appendix D.  Relationship of JWTs to Simple Web Tokens (SWTs)

   Both JWTs and Simple Web Tokens SWT [SWT], at their core, enable sets
   of claims to be communicated between applications.  For SWTs, both
   the claim names and claim values are strings.  For JWTs, while claim
   names are strings, claim values can be any JSON type.  Both token
   types offer cryptographic protection of their content: SWTs with HMAC
   SHA-256 and JWTs with a choice of algorithms, including HMAC SHA-256,
   RSA SHA-256, and ECDSA P-256 SHA-256.


Appendix E.  Acknowledgements

   The authors acknowledge that the design of JWTs was intentionally
   influenced by the design and simplicity of Simple Web Tokens [SWT]
   and ideas for JSON tokens that Dick Hardt discussed within the OpenID
   community.

   Solutions for signing JSON content were previously explored by Magic
   Signatures [MagicSignatures], JSON Simple Sign [JSS], and Canvas
   Applications [CanvasApp], all of which influenced this draft.


Appendix F.  Document History

   -03



Jones, et al.          Expires September 29, 2011              [Page 23]

Internet-Draft            JSON Web Token (JWT)                March 2011


   o  Added "http://openid.net/specs/jwt/1.0" as a token type identifier
      URI for JWTs.

   o  Added "iat" (issued at) claim.

   o  Changed RSA SHA-256 from MUST be supported to RECOMMENDED that it
      be supported.  Rationale: Several people have objected to the
      requirement for implementing RSA SHA-256, some because they will
      only be using HMACs and symmetric keys, and others because they
      only want to use ECDSA when using asymmetric keys, either for
      security or key length reasons, or both.

   o  Defined "alg" value ""none"" to represent unsigned JWTs.

   -02

   o  Split signature specification out into separate
      draft-jones-json-web-signature-00.  This split introduced no
      semantic changes.

   o  The JWT Compact Serialization is now the only token serialization
      format specified in this draft.  The JWT JSON Serialization can
      continue to be defined in a companion specification.

   -01

   o  Draft incorporating consensus decisions reached at IIW.

   -00

   o  Public draft published before November 2010 IIW based upon the
      JSON token convergence proposal incorporating input from several
      implementers of related specifications.


Authors' Addresses

   Michael B. Jones
   Microsoft

   Email: mbj@microsoft.com
   URI:   http://self-issued.info/









Jones, et al.          Expires September 29, 2011              [Page 24]

Internet-Draft            JSON Web Token (JWT)                March 2011


   Dirk Balfanz
   Google

   Email: balfanz@google.com


   John Bradley
   independent

   Email: ve7jtb@ve7jtb.com


   Yaron Y. Goland
   Microsoft

   Email: yarong@microsoft.com


   John Panzer
   Google

   Email: jpanzer@google.com


   Nat Sakimura
   Nomura Research Institute

   Email: n-sakimura@nri.co.jp


   Paul Tarjan
   Facebook

   Email: pt@fb.com

















Jones, et al.          Expires September 29, 2011              [Page 25]

