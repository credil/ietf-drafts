


N/A                                                            T. Keiser
Internet-Draft                                                S. Jenkins
Intended status: BCP                                         Sine Nomine
Expires: October 8, 2010                                   April 6, 2010


        AFSVol Tag-Length-Value Remote Procedure Call Extensions
                    draft-tkeiser-afs3-volser-tlv-01

Abstract

   AFS-3 is a distributed file system based upon prototypes developed at
   Carnegie Mellon University during the 1980s.  AFS-3 heavily leverages
   Remote Procedure Calls (RPCs) as the foundation for its distributed
   architecture.  In 2003, new RPCs were introduced into AFS-3 that
   provide for capability introspection between file servers and cache
   managers.  This memo introduces equivalent functionality to the
   volume server RPC interface, thus making the volume management
   interface more extensible.

   Furthermore, this memo extends the volume management interface to
   support getting and setting of AFS volume attributes via an
   extensible Tag-Length-Value (TLV) encoding, which is based upon XDR
   discriminated unions.  TLV-based get and set RPCs are specified,
   along with a tag enumeration RPC.  The TLV encoding side-steps the
   typical XDR union decode problem, whereby failure to decode a union
   leg causes the entire RPC payload decode to fail, by mandating an XDR
   opaque default leg for the union, along with a standard mechanism for
   encoding new leg types inside the XDR opaque blob.

   Finally, tags are allocated for existing volume and transaction
   metadata, and implementation-private tags are allocated for metadata
   related to the OpenAFS Demand Attach File Server and RxOSD protocol.

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."



Keiser & Jenkins         Expires October 8, 2010                [Page 1]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   This Internet-Draft will expire on October 8, 2010.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.



































Keiser & Jenkins         Expires October 8, 2010                [Page 2]

Internet-Draft               AFSVol TLV RPCs                  April 2010


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  5
     1.1.  Motivations  . . . . . . . . . . . . . . . . . . . . . . .  6
     1.2.  Goals  . . . . . . . . . . . . . . . . . . . . . . . . . .  6
     1.3.  Abbreviations  . . . . . . . . . . . . . . . . . . . . . .  6
   2.  Conventions  . . . . . . . . . . . . . . . . . . . . . . . . .  7
   3.  AFSVol Capability Introspection Interface  . . . . . . . . . .  7
     3.1.  Capability Bit Allocations . . . . . . . . . . . . . . . .  8
     3.2.  Capabilities Cache Coherence . . . . . . . . . . . . . . .  8
   4.  TLV Interface  . . . . . . . . . . . . . . . . . . . . . . . .  9
     4.1.  Encoding . . . . . . . . . . . . . . . . . . . . . . . . .  9
     4.2.  Qualifiers . . . . . . . . . . . . . . . . . . . . . . . . 10
   5.  AFSVol TLV Interface . . . . . . . . . . . . . . . . . . . . . 11
     5.1.  Tag Introspection  . . . . . . . . . . . . . . . . . . . . 11
     5.2.  TLV Get  . . . . . . . . . . . . . . . . . . . . . . . . . 11
     5.3.  TLV Streaming Get  . . . . . . . . . . . . . . . . . . . . 12
       5.3.1.  Split call stream encoding . . . . . . . . . . . . . . 13
     5.4.  TLV Set  . . . . . . . . . . . . . . . . . . . . . . . . . 13
       5.4.1.  Call preprocessing . . . . . . . . . . . . . . . . . . 14
         5.4.1.1.  Verify tag is supported  . . . . . . . . . . . . . 14
         5.4.1.2.  Verify tag is writeable  . . . . . . . . . . . . . 15
         5.4.1.3.  Verify value encoding is supported . . . . . . . . 15
         5.4.1.4.  Verify value can be decoded  . . . . . . . . . . . 15
         5.4.1.5.  Verify qualifier is supported  . . . . . . . . . . 15
       5.4.2.  Call processing  . . . . . . . . . . . . . . . . . . . 15
   6.  Mapping of existing metadata onto TLV namespace  . . . . . . . 16
     6.1.  volintXInfo  . . . . . . . . . . . . . . . . . . . . . . . 16
     6.2.  transDebugInfo . . . . . . . . . . . . . . . . . . . . . . 19
     6.3.  Additional de facto-standardized fields  . . . . . . . . . 20
   7.  Extended volume state exportation  . . . . . . . . . . . . . . 21
     7.1.  Volume state explanations  . . . . . . . . . . . . . . . . 21
     7.2.  Mapped process types . . . . . . . . . . . . . . . . . . . 22
     7.3.  TLV tuples . . . . . . . . . . . . . . . . . . . . . . . . 23
   8.  AFS-3 Object Storage Extensions Policy Attributes  . . . . . . 24
   9.  Backward Compatibility . . . . . . . . . . . . . . . . . . . . 24
   10. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 24
   11. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 25
   12. AFS Assign Numbers Registrar Considerations  . . . . . . . . . 25
     12.1. Namespace allocations  . . . . . . . . . . . . . . . . . . 25
       12.1.1. AFSVol capabilities  . . . . . . . . . . . . . . . . . 25
       12.1.2. AFSVol TLV Payload Types . . . . . . . . . . . . . . . 26
       12.1.3. AFSVol TLV Tags  . . . . . . . . . . . . . . . . . . . 26
       12.1.4. AFSVol Volume State Explanations . . . . . . . . . . . 26
       12.1.5. AFS-3 Program Types  . . . . . . . . . . . . . . . . . 26
     12.2. Assigned numbers allocations . . . . . . . . . . . . . . . 26
       12.2.1. VICED capability bits  . . . . . . . . . . . . . . . . 27
       12.2.2. AFSVol capability bits . . . . . . . . . . . . . . . . 27



Keiser & Jenkins         Expires October 8, 2010                [Page 3]

Internet-Draft               AFSVol TLV RPCs                  April 2010


       12.2.3. AFS-3 TLV payload types  . . . . . . . . . . . . . . . 27
       12.2.4. AFSVol TLV tags  . . . . . . . . . . . . . . . . . . . 27
       12.2.5. VOLS error table . . . . . . . . . . . . . . . . . . . 30
       12.2.6. AFSVol volume state explanations . . . . . . . . . . . 30
       12.2.7. AFS-3 program types  . . . . . . . . . . . . . . . . . 31
   13. Security Considerations  . . . . . . . . . . . . . . . . . . . 31
   14. References . . . . . . . . . . . . . . . . . . . . . . . . . . 31
     14.1. Normative References . . . . . . . . . . . . . . . . . . . 31
     14.2. Informative References . . . . . . . . . . . . . . . . . . 31
   Appendix A.  XDR Grammar for FS-CM Capabilities Mechanism  . . . . 33
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 33








































Keiser & Jenkins         Expires October 8, 2010                [Page 4]

Internet-Draft               AFSVol TLV RPCs                  April 2010


1.  Introduction

   AFS-3 [AFS1] [AFS2] is a distributed file system that has its origins
   in the VICE project [CMU-ITC-84-020] [VICE1] at the Carnegie Mellon
   University Information Technology Center [CMU-ITC-83-025], a joint
   venture between CMU and IBM.  VICE later became AFS when CMU moved
   development to a new commercial venture called Transarc Corporation,
   which later became IBM Pittsburgh Labs.  AFS-3 is a suite of un-
   standardized network protocols based on a remote procedure call (RPC)
   suite known as Rx.  While de jure standards for AFS-3 fail to exist,
   the various AFS-3 implementations have agreed upon certain de facto
   standards, largely helped by the existence of an open source fork
   called OpenAFS that has served the role of reference implementation.
   In addition to using OpenAFS as a reference, IBM wrote and donated
   developer documentation that contains somewhat outdated
   specifications for the Rx protocol and all AFS-3 remote procedure
   calls, as well as a detailed description of the AFS-3 system
   architecture.

   The AFS-3 architecture consists of many administrative domains called
   "cells" [CMU-ITC-88-070] which are glued together to form a globally
   distributed file system.  Each cell consists of: client nodes, which
   run cache manager daemons; file servers, which run file server
   daemons and volume server daemons; and database server nodes, which
   can run volume location database servers, protection database
   servers, backup database servers, or several other obscure and/or
   deprecated database services.

   This memo focuses on the volume server component of AFS-3.  The
   volume server provides an RPC interface for managing AFS volumes.
   Volumes are the unit of storage administration in AFS-3.  Each volume
   contains a subtree of the file system, along with special directory
   entries called mount points, which are used to link volumes together
   into a (potentially cyclic) directed graph.  Mount points can cross
   cell boundaries, thus permitting construction of a cross-
   organizational, globally distributed, location-transparent file
   system.  The file system is location-transparent because mount points
   contain volume names and cell names (which are resolved to locations
   by contacting the appropriate cell's volume location database),
   rather than encoding location directly in the pointer.

   This memo extends the AFS-3 volume server RPC interface with an RPC
   in support of server capability introspection, and a suite of new
   RPCs that provide extensible volume metadata get and set operations.







Keiser & Jenkins         Expires October 8, 2010                [Page 5]

Internet-Draft               AFSVol TLV RPCs                  April 2010


1.1.  Motivations

   The current AFSVol volume metadata introspection routines use hard-
   coded XDR [RFC4506] structure definitions.  This significantly limits
   protocol extensibility because new remote procedure calls and
   structure definitions must be defined during each protocol revision.
   To some degree, this has been due to the lack of protocol standards
   documents: certain sites coopted unused protocol fields for private
   uses, thus eliminating the ability for the standards process to
   reclaim these fields without breaking existing deployments.  Hence,
   each time new functionality needs to be added, a new RPC, and
   typically a new XDR data structure, need to be defined.  This is a
   rather expensive process both in terms of standardization and
   implementation.  Frequently, this leads to a desire to postpone
   protocol feature enhancements until many changes can be aggregated
   into a major protocol upgrade.

   This memo introduces a new tag-length-value (TLV) encoding mechanism
   based upon XDR discriminated unions.  This TLV encoding is utilized
   for getting and setting AFS-3 volume metadata.  The key advantage of
   this design is that new TLV tuples can be allocated without defining
   a new RPC.  Furthermore, because TLV tuples allocated after this
   draft are enocoded inside an XDR opaque blob, Rx endpoints will never
   fail to decode the XDR call or reply payload; they may only fail to
   decode the contents of the opaque.

1.2.  Goals

   This memo aims to standardize a new TLV encoding mechanism for volume
   metadata.  In addition, this memo will standardize the TLV encoding
   of volume metadata which is currently available via several AFSVol
   XDR structures, as well as specify the encoding of several new pieces
   of AFS-3 volume metadata that are not currently available via the
   AFSVol interface.  For example, metadata specific to the OpenAFS
   Demand Attach File Server will be made available via the AFSVol
   service, whereas in the past it was only available locally on the
   file server machine via a proprietary interprocess communication
   mechanism.

1.3.  Abbreviations

   AFS    -  Historically, AFS stood for the Andrew File System; AFS no
           longer stands for anything

   AFSINT -  AFS-3 File Server / Cache Manager RPC Interface






Keiser & Jenkins         Expires October 8, 2010                [Page 6]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   AFSVol -  AFS-3 Volume Server RPC Interface

   CM     -  AFS-3 Cache Manager

   DAFS   -  OpenAFS Demand Attach File Server

   FS     -  AFS-3 File Server

   RPC    -  Remote Procedure Call

   RX     -  AFS-3 Remote Procedure Call Mechanism

   RXAFS  -  AFS-3 File Server Rx RPC Interface

   RXAFSCB-  AFS-3 Cache Manager Rx RPC Interface

   TLV    -  Tag-Length-Value encoding

   TTL    -  Time to Live for cached data

   VOLSER -  AFS-3 Volume Server

   XDR    -  eXternal Data Representation


2.  Conventions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].


3.  AFSVol Capability Introspection Interface

   This memo introduces a capabilities namespace, and GetCapabilities
   interface to the AFSVol service.  The AFSVol GetCapabilities
   interface will be be identical to the previously-defined AFSINT
   interface, and its Rx interface specification will be:

   proc GetCapabilities(
       OUT Capabilities * capabilities
   ) = XXX;

                                 Figure 1

   The "Capabilities" type is defined by the existing AFSINT interface,
   which is included here for reference:




Keiser & Jenkins         Expires October 8, 2010                [Page 7]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   const AFSCAPABILITIESMAX = 192;

   typedef afs_int32 Capabilities<AFSCAPABILITIESMAX>;

                                 Figure 2

3.1.  Capability Bit Allocations

   Three new capability bit allocations will need to be processed by the
   Grand Central Registrar:

   VICED_CAPABILITY_DAFS  Announce that this file server supports the
       OpenAFS Demand Attach File Server version 1 semantics

   AFSVOL_CAPABILITY_DAFS  Announce that this volume server supports the
       OpenAFS Demand Attach File Server version 1 semantics

   AFSVOL_CAPABILITY_TLV  Announce that this volume server supports the
       Tag-Length-Value RPC

3.2.  Capabilities Cache Coherence

   One important distinction between this capability introspection
   interface and the ones utilized by AFSINT is: AFSINT is a stateful
   circuit -- file servers can reset the cached state across themselves
   and clients via the RXAFSCB_InitCallBackState,
   RXAFSCB_InitCallBackSTate2, and RXAFSCB_InitCallBackSTate3 RPCs.
   Because AFSVol is a stateless (with the exception of rxkad security
   state) client/server protocol, there is no means of maintaining
   AFSVol capabilities cache coherence.  It is RECOMMENDED that clients
   receiving RPC error codes, or critical tags which they cannot decode,
   perform a new AFSVol_GetCapabilities invocation to ensure that
   capabilities cache incoherence is detected.

   Clearly, the above technique is open to races; AFSVol clients SHOULD
   try to limit race probability by minimizing the time window between
   GetCapabilities calls, and invocation of capabilities-dependent RPCs
   (such as the TLV suite defined in Section 4).  All AFSVol clients
   MUST flush cached capabilities data at most two hours after
   retrieving them via AFSVol_GetCapabilities.  Additionally, if the
   implementation permits querying the epoch field of Rx RPC responses,
   the client MAY wish to use this as a means of detecting volume server
   restarts, and thus as means of detecting when to invalidate cached
   volume server capabilities.  However, an AFSVol client MUST NOT use
   the epoch field as a means to circumvent the two hour AFSVol
   capabilities TTL, as AFSVol servers are not required to keep the
   capability vector static throughout their operation.




Keiser & Jenkins         Expires October 8, 2010                [Page 8]

Internet-Draft               AFSVol TLV RPCs                  April 2010


4.  TLV Interface

   A new suite of RPCs will be standardized to get/set tag-length-value
   tuples, and to enumerate supported tags.  The tag namespace will be
   controlled by the Grand Central Registrar as an assigned numbers
   namespace.

4.1.  Encoding

   The TLV data will be encoded using the following XDR specification:

    /* registrar-controlled tag namespace */

    enum AFSVol_TLV_tag {
        ...
    };

    const AFSINT_TLV_TAG_MAX = 1024;         /* upper-bound on number of
                                              * TLV tuples per RPC */
    const AFSINT_TLV_OPAQUE_MAX = 262144;    /* upper-bound on size of
                                              * value payload */

    enum afsint_TLV_type {
        AFSINT_TLV_TYPE_NULL     = 0,
        AFSINT_TLV_TYPE_TRUE     = 1,
        AFSINT_TLV_TYPE_FALSE    = 2,
        AFSINT_TLV_TYPE_UINT64   = 3,
        AFSINT_TLV_TYPE_UUID     = 4,
        AFSINT_TLV_TYPE_STRING   = 5,
        AFSINT_TLV_TYPE_OPAQUE   = 6
    };

    union afsint_TLV_value switch(afsint_TLV_type type) {
     case AFSINT_TLV_TYPE_NULL:
     case AFSINT_TLV_TYPE_TRUE:
     case AFSINT_TLV_TYPE_FALSE:
      void;

     case AFSINT_TLV_TYPE_UINT64:
        afs_uint64 u_64;

     case AFSINT_TLV_TYPE_UUID:
        afsUUID u_uuid;

     case AFSINT_TLV_TYPE_STRING:
        string u_string<AFSINT_TLV_OPAQUE_MAX>;

     case AFSINT_TLV_TYPE_OPAQUE:



Keiser & Jenkins         Expires October 8, 2010                [Page 9]

Internet-Draft               AFSVol TLV RPCs                  April 2010


     default:
        opaque u_opaque<AFSINT_TLV_OPAQUE_MAX>;
    };

    const AFSINT_TLV_FLAG_UNSUPPORTED = 0x1;
    const AFSINT_TLV_FLAG_READ_ERROR = 0x2;
    const AFSINT_TLV_FLAG_CRITICAL = 0x4;

    struct afsint_TLV {
        afs_uint32 tlv_tag;
        afs_uint32 tlv_flags;
        afsint_TLV_value tlv_value;
    };

                           TLV XDR specification

                                 Figure 3

   In order to solve the XDR discriminated union decoding problem, all
   future afsint_TLV_type allocations will map to opaque.  All
   implementations MUST support all arms in the afsint_TLV_value XDR
   union, as defined above.

   When possible, future protocol augmentations requiring the definition
   of new data types should request allocation of a new standards-track
   payload type code.  Allocation of a type code should coincide with
   standardization of the payload encoding associated with the type code
   allocation.  However, in limited circumstances where:

   1.  it is known a priori that there will never be any encoding
       ambiguity, and

   2.  the cost of type code allocation and encoding standardization are
       deemed too high

   use of the type code AFSINT_TLV_TYPE_OPAQUE may be an acceptable
   alternative.

4.2.  Qualifiers

   In some cases the value associated with a tag will be large,
   structured data.  A qualifier is a tag-specific parameter which
   allows a caller to address a subset of the value stored in a tag.
   For TLV get interfaces, specifying a qualifer can reduce the amount
   of data sent over the wire.  For TLV set interfaces, specifying a
   qualifier permits a client to modify a subset of a structured value
   without endangering cache coherence.  Qualifiers are marshalled over
   the wire as type afsint_TLV_value.  Unless otherwise noted, it should



Keiser & Jenkins         Expires October 8, 2010               [Page 10]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   be assumed that a tag only supports the null qualifier (XDR union
   discriminator set to AFSINT_TLV_TYPE_NULL).  The null qualifier
   always references the entire value for a given tag.


5.  AFSVol TLV Interface

5.1.  Tag Introspection

   The Rx procedure specification for the tag support RPC will be as
   follows:

   proc GetVolumeTLVTags(
       IN AFSVol_TLV_tag offset,
       OUT AFSVol_TLV_tag * tags<AFSINT_TLV_TAG_MAX>
   ) = XXX;

                                 Figure 4

   The call parameters are defined as follows:

   offset  The offset IN parameter specifies the numeric offset of the
       first tag to return.  A value of zero indicates that the client
       wants to start the enumeration at the beginning of the tag list.

   tags  The tags OUT parameter contains a sorted list of supported
       tags, beginning with the first supported tag greater than or
       equal to the offset IN parameter.

5.2.  TLV Get

   The Rx procedure specification for the TLV get interface will be as
   follows:

            struct AFSVol_TLV_query {
                AFSVol_TLV_tag tq_tag;
                afsint_TLV_value tq_qualifier;
            };

            proc GetOneVolumeTLV(
                IN afs_uint32 partId,
                IN afs_uint64 volId,
                IN AFSVol_TLV_query queries<AFSINT_TLV_TAG_MAX>,
                OUT afsint_TLV * tuples<AFSINT_TLV_TAG_MAX>
            ) = XXX;

                                 Figure 5




Keiser & Jenkins         Expires October 8, 2010               [Page 11]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   The call parameters are defined as follows:

   partId  The partId IN parameter specifies the disk partition on which
       the volume is located.

   volId  The volId IN parameter specifies the volume for which TLV
       tuples are being requested.

   queries  The queries IN parameter specifies an optional list of tags
       for which TLV tuples are desired.  If this parameter is zero-
       length, then the server will return up to AFSINT_TLV_TAG_MAX TLV
       tuples.  If an unknown tag identifier is passed in the tags
       parameter, then the server will return a tuple with the
       AFSINT_TLV_FLAG_UNSUPPORTED bit asserted in afsint_TLV.tlv_flags,
       and the tlv type set to AFSINT_TLV_TYPE_NULL.  Similarly, if the
       server is unable to retrieve the value for a supported tag, then
       a tuple will be returned with AFSINT_TLV_FLAG_READ_ERROR set in
       the afsint_TLV.tlv_flags field, and the tlv type set to
       AFSINT_TLV_TYPE_NULL.  The AFSVol_TLV_query.tq_qualifier field
       contains optional tag-specific qualifiers which would allow the
       implementation to return a subset of the data for a specific tag.

   tuples  The tuples OUT parameter contains up to AFSINT_TLV_TAG_MAX
       TLV tuples for this volume.

5.3.  TLV Streaming Get

   This call is similar to the call described in the previous section,
   with the exception that TLV tuples will be returned for multiple
   volumes at once using an Rx split call interface.  The Rx procedure
   specification is as follows:

           const AFSVOL_BULK_GETVOLUME_MAX = 1024;

           proc GetVolumesTLV(
               IN afs_uint32 partIds<AFSVOL_BULK_GETVOLUME_MAX>,
               IN afs_uint64 volIds<AFSVOL_BULK_GETVOLUME_MAX>,
               IN AFSVol_TLV_query queries<AFSINT_TLV_TAG_MAX>
           ) split = XXX;

                                 Figure 6

   The call parameters are defined as follows:

   partIds  The partIds IN parameter specifies as list of vice
       partitions.  If this list is zero-length, then TLV information is
       requested for all volumes on all vice partitions.  If this list
       is non-zero length, then TLV information is requested only for



Keiser & Jenkins         Expires October 8, 2010               [Page 12]

Internet-Draft               AFSVol TLV RPCs                  April 2010


       volumes on specific vice partitions.

   volIds  The volIds IN parameter specifies a list of volume IDs.  If
       this list is zero-length, then TLV information is requested for
       all volumes on the vice partitions specified in partIds.

       If the volIds array is non-zero length, then its length MUST
       match the length of the partIds array.  In this case, each
       matching index in the partIds and volIds arrays together form a
       tuple which uniquely addresses a volume on a given vice
       partition.

   queries  The queries IN parameter specifies an optional list of tags
       for which TLV tuples are desired.  If this parameter is zero-
       length, then the server will return up to AFSINT_TLV_TAG_MAX TLV
       tuples.  If an unknown tag identifier is passed in the tags
       parameter, then the server will return a tuple with the
       AFSINT_TLV_FLAG_UNSUPPORTED bit asserted in afsint_TLV.tlv_flags,
       and the tlv type set to AFSINT_TLV_TYPE_NULL.  Similarly, if the
       server is unable to retrieve the value for a supported tag, then
       a tuple will be returned with AFSINT_TLV_FLAG_READ_ERROR set in
       the afsint_TLV.tlv_flags field, and the tlv type set to
       AFSINT_TLV_TYPE_NULL.  The AFSVol_TLV_query.tq_qualifier field
       contains optional tag-specific qualifiers which would allow the
       implementation to return a subset of the data for a specific tag.

5.3.1.  Split call stream encoding

   The contents of the split call stream shall be an xdrrec stream
   containing a finite sequence of XDR-encoded afsint_TLV structures,
   each of which shall be marked as a separate record (typically by
   calling xdrrec_endofrecord).  End of sequence will be annotated by a
   dummy tuple containing the special tag type AFSVOL_TLV_TAG_EOS.

5.4.  TLV Set

   The Rx procedure specification for the TLV set interface will be as
   follows:













Keiser & Jenkins         Expires October 8, 2010               [Page 13]

Internet-Draft               AFSVol TLV RPCs                  April 2010


            struct AFSVol_TLV_store {
                afsint_TLV ts_tuple;
                afsint_TLV_value ts_qualifier;
            };

            proc SetVolumeTLV(
                IN afs_int32 trans,
                IN AFSVol_TLV_store tuples<AFSINT_TLV_TAG_MAX>,
                OUT afs_int32 * results<AFSINT_TLV_TAG_MAX>
            ) = XXX;

                                 Figure 7

   The call parameters are defined as follows:

   trans  The trans IN parameter specifies the transaction ID returned
       by a previous invocation of AFSVolTransCreate.

   tuples  The tuples IN parameter contains the list of TLV tuples to be
       set by the server.

   results  The results OUT parameter contains a list of error codes,
       one per tuple.  These error codes provide specific information
       regarding the success/failure of each TLV set operation.  Valid
       error codes include: VOLSERTAGUNSUPPORTED, VOLSERTAGREADONLY,
       VOLSERTAGWRITEFAILED, VOLSERTAGDECODEFAILED,
       VOLSERTAGUNSUPPORTEDENCODING, VOLSERTAGINVALIDQUALIFIER, and
       VOLSERFAILEDOP.

5.4.1.  Call preprocessing

   The SetVolumeTLV begins by scanning all elements within the tuples
   array.  If any elements have the AFSINT_TLV_FLAG_CRITICAL bit
   asserted in tuples[i].ts_tuple.ts_flags, then preprocessing of the
   tuple must occur.  For each tuple with the critical bit set, several
   preprocessing validation steps will be taken.

5.4.1.1.  Verify tag is supported

   The tag stored in tuples[i].ts_tuple.tlv_tag is checked to ensure
   that the server supports it.  In the event that the tag is not
   supported, then the corresponding array index in the results array
   will be set to VOLSERTAGUNSUPPORTED, and the RPC call abort at the
   conclusion of critical tuple preprocessing with error code
   VOLSERFAILEDOP.






Keiser & Jenkins         Expires October 8, 2010               [Page 14]

Internet-Draft               AFSVol TLV RPCs                  April 2010


5.4.1.2.  Verify tag is writeable

   The tag stored in tuples[i].ts_tuple.tlv_flag is checked to ensure
   that it is a writeable property.  In the event that the tag is read-
   only, then the corresponding array index in the results array will be
   set to VOLSERTAGREADONLY, and the RPC call will abort at the
   conclusion of critical tuple preprocessing with error code
   VOLSERFAILEDOP.

5.4.1.3.  Verify value encoding is supported

   The XDR union discriminator in tuples[i].ts_tuple.tlv_value is
   checked to make sure that it is a supported type.  If the
   discriminator is not a supported type, then the corresponding array
   index in the results array will be set to
   VOLSERTAGUNSUPPORTEDENCODING, and the RPC call will abort at the
   conclusion of critical tuple preprocessing with error code
   VOLSERFAILEDOP.

5.4.1.4.  Verify value can be decoded

   The value stored in tuples[i].ts_tuple.tlv_value is checked to make
   sure that it can be decoded.  If the wire-encoded data cannot be
   decoded, then the corresponding array index in the results array will
   be set to VOLSERTAGDECODEFAILED, and the RPC call will abort at the
   conclusion of critical tuple preprocessing with error code
   VOLSERFAILEDOP.

5.4.1.5.  Verify qualifier is supported

   Qualifiers are specific to a given tag.  If for any reason the tag-
   specific validation logic determines that the qualifier is invalid,
   it may set the corresponding array index in the results array to one
   of VOLSERTLVQUALIFIERUNSUPPORTEDENCODING,
   VOLSERTLVQUALIFIERDECODEFAILED, or VOLSERTLVQUALIFIERINVALID.  As
   with the other validation steps, if a critical tuple fails qualifier
   validation, then the RPC call will abort at the conclusion of
   critical tuple preprocessing with error code VOLSERFAILEDOP.

5.4.2.  Call processing

   Once the necessary validation steps have been performed, the call
   will perform the set operations for each tuple.  Errors encountered
   during the processing of each tuple will be recorded in the
   appropriate array index of the results array.  At the conclusion the
   RPC will either return 0 if all set operations succeeded, or
   VOLSERFAILEDOP if any failed.




Keiser & Jenkins         Expires October 8, 2010               [Page 15]

Internet-Draft               AFSVol TLV RPCs                  April 2010


6.  Mapping of existing metadata onto TLV namespace

   Existing metadata available from several interfaces will also be
   exported as TLV tuples.  This is being done not only for
   completeness, but also to prevent data races between
   AFSVolGetOneVolumeTLV, and the various legacy introspection
   interfaces.

6.1.  volintXInfo

   All metadata exported via the volintXInfo XDR structure will now be
   exported as TLV tuples.  Unless otherwise specified, the values
   associated with each tag shall be identical to that returned for the
   associated field in volintXInfo by the AFSVolXListOneVolume
   interface.  The following tuples will be allocated to export existing
   members of volintXInfo:

   AFSVOL_TLV_TAG_VOL_NAME  This is the TLV analogue of
       volintXInfo.name.  This tuple MUST have a payload of type
       AFSINT_TLV_TYPE_STRING.  The u_string payload field MUST contain
       a null-terminated string.

   AFSVOL_TLV_TAG_VOL_STATUS  This is the TLV analogue of
       volintXInfo.status.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_IN_USE  This is the TLV analogue of
       volintXInfo.inUse.  This tuple will contain a boolean value, and
       therefore MUST have a payload type of either:
       AFSINT_TLV_TYPE_TRUE, or AFSINT_TLV_TYPE_FALSE.

   AFSVOL_TLV_TAG_VOL_ID  This is the TLV analogue of volintXInfo.volid.
       This tuple MUST have a payload of type AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_TYPE  This is the TLV analogue of
       volintXInfo.type.  This tuple MUST have a payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_CLONE_ID  This is the TLV analogue of
       volintXInfo.cloneID.  This tuple MUST have a payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_BACKUP_ID  This is the TLV analogue of
       volintXInfo.backupID.  This tuple MUST have a payload of type
       AFSINT_TLV_TYPE_UINT64.






Keiser & Jenkins         Expires October 8, 2010               [Page 16]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   AFSVOL_TLV_TAG_VOL_PARENT_ID  This is the TLV analogue of
       volintXInfo.parentID.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_COPY_DATE  This is the TLV analogue of
       volintXInfo.copyDate.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.  This timestamp shall be encoded using
       the rules specified in the forthcoming afs3 RPC refresh document.

   AFSVOL_TLV_TAG_VOL_CREATE_DATE  This is the TLV analogue of
       volintXInfo.creationDate.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.  This timestamp shall be encoded using
       the rules specified in the forthcoming afs3 RPC refresh document.

   AFSVOL_TLV_TAG_VOL_ACCESS_DATE  This is the TLV analogue of
       volintXInfo.accessDate.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.  This timestamp shall be encoded using
       the rules specified in the forthcoming afs3 RPC refresh document.

   AFSVOL_TLV_TAG_VOL_UPDATE_DATE  This is the TLV analogue of
       volintXInfo.updateDate.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.  This timestamp shall be encoded using
       the rules specified in the forthcoming afs3 RPC refresh document.

   AFSVOL_TLV_TAG_VOL_BACKUP_DATE  This is the TLV analogue of
       volintXInfo.backupDate.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.  This timestamp shall be encoded using
       the rules specified in the forthcoming afs3 RPC refresh document.

   AFSVOL_TLV_TAG_VOL_SIZE  This is the TLV analogue of
       volintXInfo.size.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_FILE_COUNT  This is the TLV analogue of
       volintXInfo.filecount.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_QUOTA_BLOCKS  This is the TLV analogue of
       volintXInfo.maxquota.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_DAY_USE  This is the TLV analogue of
       volintXInfo.dayUse.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.







Keiser & Jenkins         Expires October 8, 2010               [Page 17]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   AFSVOL_TLV_TAG_VOL_STAT_READS  This is the TLV analogue of
       volintXInfo.stat_reads.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_OPAQUE.  The opaque contents shall be an XDR-
       encoded structure defined as follows:

          const VOLINT_STATS_NUM_RWINFO_FIELDS = 4;

          struct AFSVol_stat_rw {
              afs_uint64 stat_rw[VOLINT_STATS_NUM_RWINFO_FIELDS];
          };

                                   Figure 8

   AFSVOL_TLV_TAG_VOL_STAT_WRITES  This is the TLV analogue of
       volintXInfo.stat_reads.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_OPAQUE.  The opaque contents shall be an XDR-
       encoded structure as defined for AFSVOL_TLV_TAG_VOL_STAT_READS.

   AFSVOL_TLV_TAG_VOL_STAT_FILE_SAME_AUTHOR  This is the TLV analogue of
       volintXInfo.stat_fileSameAuthor.  This tuple MUST have payload of
       type AFSINT_TLV_TYPE_OPAQUE.  The opaque contents shall be an
       XDR-encoded structure defined as follows:

           const VOLINT_STATS_NUM_TIME_FIELDS = 6;

           struct AFSVol_stat_time {
               afs_uint64 stat_rw[VOLINT_STATS_NUM_TIME_FIELDS];
           };

                                   Figure 9

   AFSVOL_TLV_TAG_VOL_STAT_FILE_DIFFERENT_AUTHOR  This is the TLV
       analogue of volintXInfo.stat_fileDiffAuthor.  This tuple MUST
       have payload of type AFSINT_TLV_TYPE_OPAQUE.  The opaque contents
       shall be the XDR-encoded structure AFSVol_stat_time, as defined
       for AFSVOL_TLV_TAG_VOL_STAT_FILE_SAME_AUTHOR.

   AFSVOL_TLV_TAG_VOL_STAT_DIR_SAME_AUTHOR  This is the TLV analogue of
       volintXInfo.stat_dirSameAuthor.  This tuple MUST have payload of
       type AFSINT_TLV_TYPE_OPAQUE.  The opaque contents shall be the
       XDR-encoded structure AFSVol_stat_time, as defined for
       AFSVOL_TLV_TAG_VOL_STAT_FILE_SAME_AUTHOR.

   AFSVOL_TLV_TAG_VOL_STAT_DIR_DIFFERENT_AUTHOR  This is the TLV
       analogue of volintXInfo.stat_dirDiffAuthor.  This tuple MUST have
       payload of type AFSINT_TLV_TYPE_OPAQUE.  The opaque contents
       shall be the XDR-encoded structure AFSVol_stat_time, as defined
       for AFSVOL_TLV_TAG_VOL_STAT_FILE_SAME_AUTHOR.



Keiser & Jenkins         Expires October 8, 2010               [Page 18]

Internet-Draft               AFSVol TLV RPCs                  April 2010


6.2.  transDebugInfo

   All metadata exported via the transDebugInfo XDR structure will now
   be exported as TLV tuples.  Unless otherwise specified, the values
   associated with each tag shall be identical to that returned for the
   associated field in transDebugInfo by the AFSVolMonitor interface.
   The following tuples will be allocated to export existing members of
   transDebugInfo:

   AFSVOL_TLV_TAG_VOL_TRANS_TID  This is the TLV analogue of
       transDebugInfo.tid.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_TRANS_TIME  This is the TLV analogue of
       transDebugInfo.time.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.  This timestamp shall be encoded using
       the rules specified in the forthcoming afs3 RPC refresh document.

   AFSVOL_TLV_TAG_VOL_TRANS_CREATE_TIME  This is the TLV analogue of
       transDebugInfo.creationTime.  This tuple MUST have payload of
       type AFSINT_TLV_TYPE_UINT64.  This timestamp shall be encoded
       using the rules specified in the forthcoming afs3 RPC refresh
       document.

   AFSVOL_TLV_TAG_VOL_TRANS_RETURN_CODE  This is the TLV analogue of
       transDebugInfo.returnCode.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_TRANS_ATTACH_MODE  This is the TLV analogue of
       transDebugInfo.iflags.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_TRANS_STATUS  This is the TLV analogue of
       transDebugInfo.vflags This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_TRANS_FLAGS  This is the TLV analogue of
       transDebugInfo.tflags.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_TRANS_LAST_PROC_NAME  This is the TLV analogue of
       transDebugInfo.lastProcName.  This tuple MUST have payload of
       type AFSINT_TLV_TYPE_STRING.  The u_string payload field MUST
       contain a null-terminated string.







Keiser & Jenkins         Expires October 8, 2010               [Page 19]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   AFSVOL_TLV_TAG_VOL_TRANS_CALL_VALID  This is the TLV analogue of
       transDebugInfo.callValid.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_TRANS_READ_NEXT  This is the TLV analogue of
       transDebugInfo.readNext.  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_TRANS_XMIT_NEXT  This is the TLV analogue of
       transDebugInfo.transmitNext.  This tuple MUST have payload of
       type AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_VOL_TRANS_LAST_RECV_TIME  This is the TLV analogue of
       transDebugInfo.lastReceiveTime.  This tuple MUST have payload of
       type AFSINT_TLV_TYPE_UINT64.  This timestamp shall be encoded
       using the rules specified in the forthcoming afs3 RPC refresh
       document.

   AFSVOL_TLV_TAG_VOL_TRANS_LAST_SEND_TIME  This is the TLV analogue of
       transDebugInfo.lastSendTime.  This tuple MUST have payload of
       type AFSINT_TLV_TYPE_UINT64.  This timestamp shall be encoded
       using the rules specified in the forthcoming afs3 RPC refresh
       document.

6.3.  Additional de facto-standardized fields

   Certain fields from the IBM AFS and OpenAFS file server's
   VolumeDiskData header are generally useful.  In particular, several
   fields exported via the AFSVolGetFlags and AFSVolSetFlags RPCs should
   be exported via the TLV interface.  The full list of supported TLV
   tuples are:

   AFSVOL_TLV_TAG_VOL_IN_SERVICE  This tuple will contain a boolean
       value, and therefore MUST have a payload type of either:
       AFSINT_TLV_TYPE_TRUE, or AFSINT_TLV_TYPE_FALSE.  When this bit is
       not asserted, the volume is administratively prohibited from
       coming online.

   AFSVOL_TLV_TAG_VOL_BLESSED  This tuple will contain a boolean value,
       and therefore MUST have a payload type of either:
       AFSINT_TLV_TYPE_TRUE, or AFSINT_TLV_TYPE_FALSE.  When this bit is
       not asserted, the volume is administratively prohibited from
       coming online.

   AFSVOL_TLV_TAG_VOL_RESTORED_FROM_ID  This tuple MUST have payload of
       type AFSINT_TLV_TYPE_UINT64.  When this field is non-zero, it
       contains the volume ID contained in the dump from which it was
       restored.



Keiser & Jenkins         Expires October 8, 2010               [Page 20]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   AFSVOL_TLV_TAG_VOL_DESTROYED  This tuple will contain a boolean
       value, and therefore MUST have a payload type of either:
       AFSINT_TLV_TYPE_TRUE, or AFSINT_TLV_TYPE_FALSE.  When this bit is
       asserted, this volume is flagged for deletion.

   AFSVOL_TLV_TAG_VOL_NEEDS_SALVAGE  This tuple will contain a boolean
       value, and therefore MUST have a payload type of either:
       AFSINT_TLV_TYPE_TRUE, or AFSINT_TLV_TYPE_FALSE.  When this bit is
       asserted, this volume requires a salvage.

   AFSVOL_TLV_TAG_VOL_OFFLINE_MESSAGE  This tuple MUST have payload of
       type AFSINT_TLV_TYPE_STRING.  The u_string payload field MUST
       contain a null-terminated string.  This field stores an
       administrative message to indicate why the volume is offline.

   AFSVOL_TLV_TAG_VOL_EXPIRATION_DATE  This tuple MUST have payload of
       type AFSINT_TLV_TYPE_UINT64.  This timestamp shall be encoded
       using the rules specified in the forthcoming afs3 RPC refresh
       document.  To the best knowledge of the authors, this field is
       not standardized by any implementation.

   AFSVOL_TLV_TAG_VOL_RESERVATION  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.  This field, otherwise known as minquota,
       specifies the amount of storage (in units of 1024 octets) that
       are reserved on the underlying storage for use by this volume.


7.  Extended volume state exportation

   In addition to exporting the existing volser state, DAFS state
   metadata will also be exported via the TLV interface.  Specifically,
   an extended volume state field, and a raw DAFS state debugging tag,
   will be exported.

7.1.  Volume state explanations

   Given that volume state information is useful across all server
   implementations, a collection of generic state explanations shall be
   standardized.  The following states are initially defined in the
   namespace:

   AFSVOL_VOL_STATE_EXPL_NONE  No further explanation is deemed
       necessary.

   AFSVOL_VOL_STATE_EXPL_UNKNOWN  This volume is in its current state
       for unknown reasons.





Keiser & Jenkins         Expires October 8, 2010               [Page 21]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   AFSVOL_VOL_STATE_EXPL_OUT_OF_SERVICE  This volume is administratively
       out of service.  For example, the IBM AFS and OpenAFS
       implementations both permit an administrator to force a volume
       offline by mutating the blessed or inService disk header bits.

   AFSVOL_VOL_STATE_EXPL_DELETED  This volume no longer exists on-disk.
       This record merely serves as a pointer to tell clients that the
       volume has moved to a new location.

   AFSVOL_VOL_STATE_EXPL_READY  This volume is ready to service
       requests.  If the primary volume state is offline, this means the
       volume is ready to be brought online as soon as a remote
       procedure call needs to access this volume.

   AFSVOL_VOL_STATE_EXPL_ATTACHING  This volume is busy attaching.
       Assuming the process completes successfully, the volume will be
       brought online.

   AFSVOL_VOL_STATE_EXPL_DETACHING  This volume is busy detaching.

   AFSVOL_VOL_STATE_EXPL_BUSY  This volume is busy performing some
       ancillary operation which requires exclusive access.

   AFSVOL_VOL_STATE_EXPL_IO_BUSY  This volume is busy performing an I/O
       operation which requires exclusive access.

   AFSVOL_VOL_STATE_EXPL_SALVAGING  This volume is currently being
       salvaged in the background.

   AFSVOL_VOL_STATE_EXPL_SALVAGE_NEEDED  This volume is offline, and
       will require a salvage before it can be brought online.

   AFSVOL_VOL_STATE_EXPL_ERROR  This volume has been forced offline due
       to a non-recoverable error.  Manual intervention by an
       administrator will be necessary to bring this volume back to an
       operable state.

   AFSVOL_VOL_STATE_EXPL_VOLUME_OPERATION  This volume is currently
       offline because a volume transaction requires exclusive access.

7.2.  Mapped process types

   It is useful to be able to track volume ownership by process type.
   In order to do this, a new program type namespace must be defined.
   The following types are initially defined in the program type
   namespace:





Keiser & Jenkins         Expires October 8, 2010               [Page 22]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   AFSINT_PROGRAM_TYPE_FILE_SERVER  Refers to an afs file server process
       (Rx service ID 1).

   AFSINT_PROGRAM_TYPE_VOLUME_SERVER  Refers to an afs volume server
       process (Rx service ID 4).

   AFSINT_PROGRAM_TYPE_SALVAGER  Refers to an afs stand-alone salvager
       process.

   AFSINT_PROGRAM_TYPE_SALVAGE_SERVER  Refers to an OpenAFS DAFS salvage
       server process.

   AFSINT_PROGRAM_TYPE_VOLUME_UTILITY  Refers to any ancillary stand-
       alone volume utility process.

7.3.  TLV tuples

   Volume state will be exported via five new TLV tuples:

   AFSVOL_TLV_TAG_VOL_STATE_ONLINE  This tuple MUST have payload of
       either type AFSINT_TLV_TYPE_TRUE, or AFSINT_TLV_TYPE_FALSE.  This
       value SHALL tell the caller whether or not the volume is fully
       online.

   AFSVOL_TLV_TAG_VOL_STATE_AVAILABLE  This tuple MUST have payload of
       either type AFSINT_TLV_TYPE_TRUE, or AFSINT_TLV_TYPE_FALSE.  This
       tuple shall tell the caller whether or not the volume is
       available.  This SHOULD be asserted either when the volume is
       fully online, or when the volume can be brought online on-demand
       within a reasonable length of time following receipt of an RPC
       call to Rx service id 1 requesting access to the volume.

   AFSVOL_TLV_TAG_VOL_STATE_EXPL  This tuple MUST have payload of type
       AFSINT_TLV_TYPE_UINT64.  The u_64 payload shall contain a volume
       state explanation enumeration value, as defined in Section 7.1.

   AFSVOL_TLV_TAG_VOL_STATE_DAFS_RAW  For servers exporting capability
       AFSVOL_CAPABILITY_DAFS, this payload MUST be of type
       AFSINT_TLV_TYPE_OPAQUE.  Encoding of raw state is unspecified and
       implementation-private.

   AFSVOL_TLV_TAG_VOL_STATE_OWNING_PROCESS  This tag should only be
       advertised as available on server implementations which support
       tracking volume ownership by process type.  When available, this
       payload MUST be of type AFSINT_TLV_TYPE_UINT64.  The u_64 payload
       shall contain a program type enumeration value, as defined in
       Section 7.2.




Keiser & Jenkins         Expires October 8, 2010               [Page 23]

Internet-Draft               AFSVol TLV RPCs                  April 2010


8.  AFS-3 Object Storage Extensions Policy Attributes

   RxOSD requires two TLV tuples to encode new quota types:

   AFSVOL_TLV_TAG_QUOTA_BLOCKS_STORED_LOCALLY  The value in this tuple
       defines the maximum allowable storage, in units of blocks, that
       may be stored on the local file server partition.  When storage
       is required beyond this limit, some data must be migrated to
       object storage devices (OSDs).  This tuple MUST have a payload of
       type AFSINT_TLV_TYPE_UINT64.

   AFSVOL_TLV_TAG_QUOTA_FILES  The value in this tuple defines the
       maximum allowable file count for this volume.  This tuple MUST
       have a payload of type AFSINT_TLV_TYPE_UINT64.


9.  Backward Compatibility

   AFSVol services providing extended Tag-Length-Value RPCs MUST provide
   backwards compatible interfaces to both legacy clients and servers.
   Additionally, interoperability between TLV versions must also be
   specified if they do not comply with the following requirements:

   1.  AFSVol TLV servers replying to legacy AFSVol clients MUST provide
       the identical response to an AFSVol server.

   2.  AFSVol TLV clients communicating with AFSVol servers MUST fall
       back to using non-TLV AFSVol RPCs.

   3.  AFSVol TLV clients to AFSVol TLV servers:

       A.  Where capabilities match or the server can provide
           capabilities including those which the client requests, the
           server MUST reply with exactly the capabilities requested.

       B.  Where the client requests capabilities that the server does
           not provide it MUST either return an 'unknown tag' error
           code, or (OPTIONAL) fall back to an non-TLV AFSVol response.


10.  Acknowledgements

   We would like to thank all of the participants at the 2009 Edinburgh
   AFS hackathon for their input into the design of this TLV mechanism.
   Alistair Ferguson has provided much useful feedback, especially with
   regard to backwards compatibility and discriminated union type
   identifier namespace allocations.  Andrew Deason and Michael Meffie
   have provided considerable input with regard to the discriminated



Keiser & Jenkins         Expires October 8, 2010               [Page 24]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   union XDR decoding problem, AFS registrar and namespace allocation
   concerns, what metadata should be exported in the initial revision,
   the notion of data qualifiers, as well as commentary about how they
   envision this extension being used to support future protocol
   extensions.  Derrick Brashear has provided helpful feedback with
   regard to restructuring the volume state reporting tags.  Thanks to
   Christof Hanke and Hartmut Reuter for collaborating to make this memo
   compatible with their RxOSD protocol enhancments, and, furthermore,
   for providing helpful feedback regarding the language in this draft.
   Finally, special thanks to Jeffrey Hutzelman for providing
   considerable help with restructuring this memo to improve readability
   and limit its scope to something tractable.


11.  IANA Considerations

   This memo includes no request to IANA.


12.  AFS Assign Numbers Registrar Considerations

   The AFS Assigned Numbers Registrar will need to consider several
   assigned numbers requests.

12.1.  Namespace allocations

   First and foremost, this memo requests that the AFS Registrar assume
   control over several new registries:

   1.  AFSVol capability bit namespace

   2.  AFS-3 TLV payload type namespace

   3.  AFSVol TLV tag namespace

   4.  AFSVol mapped volume state namespace

   5.  AFS-3 program type namespace

12.1.1.  AFSVol capabilities

   This memo requests the allocation of a new registry with the formal
   name "AFSVol Capabilities".  This registry will be used to track
   allocations of AFSVol capability bits.  The capability bit namespace
   contains 6272 bits, subdivided into 196 32-bit buckets.  Allocation
   requests for this namespace MUST be in the form of an RFC.
   Furthermore, final approval for allocations SHALL be made by a
   Designated Expert [RFC5226] to be nominated by the AFS-3 Working



Keiser & Jenkins         Expires October 8, 2010               [Page 25]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   Group.  Should the AFS-3 Working Group be unable to assign a
   Designated Expert, the AFS Assigned Numbers Registrar will be free to
   appoint one or more Designated Experts to aid the registrar in the
   process of vetting requests for this namespace.  All allocation
   requests for this registry MUST include the following information:

   o  capability name

   o  RFC section reference to definition of how this capability bit
      alters AFSVol protocol semantics

   In addition, an allocation request MAY include the following optional
   elements:

   o  capability description

   o  desired capability bucket number and bit position

   o  RFC section reference to discussion regarding backwards
      compatibility

   o  RFC section reference to relevant security considerations

12.1.2.  AFSVol TLV Payload Types

   ##$# TODO

12.1.3.  AFSVol TLV Tags

   ##$# TODO

12.1.4.  AFSVol Volume State Explanations

   ##$# TODO

12.1.5.  AFS-3 Program Types

   ##$# TODO

12.2.  Assigned numbers allocations

   In addition to requesting the allocation of new registries, this memo
   also requests several new allocations within existing assigned
   numbers registries.







Keiser & Jenkins         Expires October 8, 2010               [Page 26]

Internet-Draft               AFSVol TLV RPCs                  April 2010


12.2.1.  VICED capability bits

   One new capability bit is requested:

   o  VICED_CAPABILITY_DAFS

12.2.2.  AFSVol capability bits

   Two new capability bits are requested:

   o  AFSVOL_CAPABILITY_DAFS

   o  AFSVOL_CAPABILITY_TLV

12.2.3.  AFS-3 TLV payload types

   The following payload type allocations are requested:

   o  AFSINT_TLV_TYPE_NULL

   o  AFSINT_TLV_TYPE_TRUE

   o  AFSINT_TLV_TYPE_FALSE

   o  AFSINT_TLV_TYPE_UINT64

   o  AFSINT_TLV_TYPE_UUID

   o  AFSINT_TLV_TYPE_STRING

   o  AFSINT_TLV_TYPE_OPAQUE

12.2.4.  AFSVol TLV tags

   The following tag allocations are requested:

   o  AFSVOL_TLV_TAG_VOL_NAME

   o  AFSVOL_TLV_TAG_VOL_STATUS

   o  AFSVOL_TLV_TAG_VOL_IN_USE

   o  AFSVOL_TLV_TAG_VOL_ID

   o  AFSVOL_TLV_TAG_VOL_TYPE

   o  AFSVOL_TLV_TAG_VOL_CLONE_ID




Keiser & Jenkins         Expires October 8, 2010               [Page 27]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   o  AFSVOL_TLV_TAG_VOL_BACKUP_ID

   o  AFSVOL_TLV_TAG_VOL_PARENT_ID

   o  AFSVOL_TLV_TAG_VOL_COPY_DATE

   o  AFSVOL_TLV_TAG_VOL_CREATE_DATE

   o  AFSVOL_TLV_TAG_VOL_ACCESS_DATE

   o  AFSVOL_TLV_TAG_VOL_UPDATE_DATE

   o  AFSVOL_TLV_TAG_VOL_BACKUP_DATE

   o  AFSVOL_TLV_TAG_VOL_SIZE

   o  AFSVOL_TLV_TAG_VOL_FILE_COUNT

   o  AFSVOL_TLV_TAG_VOL_QUOTA_BLOCKS

   o  AFSVOL_TLV_TAG_VOL_DAY_USE

   o  AFSVOL_TLV_TAG_VOL_STAT_READS

   o  AFSVOL_TLV_TAG_VOL_STAT_WRITES

   o  AFSVOL_TLV_TAG_VOL_STAT_FILE_SAME_AUTHOR

   o  AFSVOL_TLV_TAG_VOL_STAT_FILE_DIFFERENT_AUTHOR

   o  AFSVOL_TLV_TAG_VOL_STAT_DIR_SAME_AUTHOR

   o  AFSVOL_TLV_TAG_VOL_STAT_DIR_DIFFERENT_AUTHOR

   o  AFSVOL_TLV_TAG_VOL_TRANS_ID

   o  AFSVOL_TLV_TAG_VOL_TRANS_TIME

   o  AFSVOL_TLV_TAG_VOL_TRANS_CREATE_TIME

   o  AFSVOL_TLV_TAG_VOL_TRANS_RETURN_CODE

   o  AFSVOL_TLV_TAG_VOL_TRANS_ATTACH_MODE

   o  AFSVOL_TLV_TAG_VOL_TRANS_STATUS

   o  AFSVOL_TLV_TAG_VOL_TRANS_FLAGS




Keiser & Jenkins         Expires October 8, 2010               [Page 28]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   o  AFSVOL_TLV_TAG_VOL_TRANS_LAST_PROC_NAME

   o  AFSVOL_TLV_TAG_VOL_TRANS_CALL_VALID

   o  AFSVOL_TLV_TAG_VOL_TRANS_READ_NEXT

   o  AFSVOL_TLV_TAG_VOL_TRANS_XMIT_NEXT

   o  AFSVOL_TLV_TAG_VOL_TRANS_LAST_RECV_TIME

   o  AFSVOL_TLV_TAG_VOL_TRANS_LAST_SEND_TIME

   o  AFSVOL_TLV_TAG_VOL_IN_SERVICE

   o  AFSVOL_TLV_TAG_VOL_BLESSED

   o  AFSVOL_TLV_TAG_VOL_RESTORED_FROM_ID

   o  AFSVOL_TLV_TAG_VOL_DESTROYED

   o  AFSVOL_TLV_TAG_VOL_NEEDS_SALVAGE

   o  AFSVOL_TLV_TAG_VOL_OFFLINE_MESSAGE

   o  AFSVOL_TLV_TAG_VOL_EXPIRATION_DATE

   o  AFSVOL_TLV_TAG_VOL_RESERVATION

   o  AFSVOL_TLV_TAG_VOL_STATE_ONLINE

   o  AFSVOL_TLV_TAG_VOL_STATE_AVAILABLE

   o  AFSVOL_TLV_TAG_VOL_STATE_EXPL

   o  AFSVOL_TLV_TAG_VOL_STATE_DAFS_RAW

   o  AFSVOL_TLV_TAG_VOL_STATE_OWNING_PROCESS

   o  AFSVOL_TLV_TAG_VOL_QUOTA_BLOCKS_STORED_LOCALLY

   o  AFSVOL_TLV_TAG_VOL_QUOTA_FILES

   o  AFSVOL_TLV_TAG_EOS








Keiser & Jenkins         Expires October 8, 2010               [Page 29]

Internet-Draft               AFSVol TLV RPCs                  April 2010


12.2.5.  VOLS error table

   Within the VOLS error table (offset 1492325120), several new codes
   need to be allocated:

   o  VOLSERTAGUNSUPPORTED

   o  VOLSERTAGREADONLY

   o  VOLSERTAGWRITEFAILED

   o  VOLSERTAGDECODEFAILED

   o  VOLSERTAGUNSUPPORTEDENCODING

   o  VOLSERTLVQUALIFIERUNSUPPORTEDENCODING

   o  VOLSERTLVQUALIFIERDECODEFAILED

   o  VOLSERTLVQUALIFIERINVALID

12.2.6.  AFSVol volume state explanations

   Within the new AFSVol mapped volume state explanation namespace, the
   following initial allocations are requested:

   o  AFSVOL_VOL_STATE_EXPL_NONE

   o  AFSVOL_VOL_STATE_EXPL_UNKNOWN

   o  AFSVOL_VOL_STATE_EXPL_OUT_OF_SERVICE

   o  AFSVOL_VOL_STATE_EXPL_DELETED

   o  AFSVOL_VOL_STATE_EXPL_READY

   o  AFSVOL_VOL_STATE_EXPL_ATTACHING

   o  AFSVOL_VOL_STATE_EXPL_DETACHING

   o  AFSVOL_VOL_STATE_EXPL_BUSY

   o  AFSVOL_VOL_STATE_EXPL_IO_BUSY

   o  AFSVOL_VOL_STATE_EXPL_SALVAGING

   o  AFSVOL_VOL_STATE_EXPL_SALVAGE_NEEDED




Keiser & Jenkins         Expires October 8, 2010               [Page 30]

Internet-Draft               AFSVol TLV RPCs                  April 2010


   o  AFSVOL_VOL_STATE_EXPL_ERROR

   o  AFSVOL_VOL_STATE_EXPL_VOLUME_OPERATION

12.2.7.  AFS-3 program types

   Within the new AFS program type namespace, the following allocations
   are requested:

   o  AFSINT_PROGRAM_TYPE_FILE_SERVER

   o  AFSINT_PROGRAM_TYPE_VOLUME_SERVER

   o  AFSINT_PROGRAM_TYPE_SALVAGER

   o  AFSINT_PROGRAM_TYPE_SALVAGE_SERVER

   o  AFSINT_PROGRAM_TYPE_VOLUME_UTILITY


13.  Security Considerations

   Security and authorization issues are tag-specific.  The legacy
   AFSVol RPCs permitted rxnull connections to perform the four
   ListVolume RPCs, and AFSVolMonitor.  Arguably, it is time to re-
   evaluate this decision, and restrict access to certain tags, as they
   do permit potentially sensitive volume or operational metadata to
   leak onto public networks.


14.  References

14.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008.

14.2.  Informative References

   [AFS1]     Howard, J., "An Overview of the Andrew File System"",
              Proc. 1988 USENIX Winter Tech. Conf. pp. 23-26,
              February 1988.

   [AFS2]     Howard, J., Kazar, M., Menees, S., Nichols, D.,



Keiser & Jenkins         Expires October 8, 2010               [Page 31]

Internet-Draft               AFSVol TLV RPCs                  April 2010


              Satyanarayanan, M., Sidebotham, R., and M. West, "Scale
              and Performance in a Distributed File System", ACM Trans.
              Comp. Sys. Vol. 6, No. 1, pp. 51-81, February 1988.

   [AFS3-FSCM]
              Zayas, E., "AFS-3 Programmer's Reference: File Server/
              Cache Manager Interface", Transarc Corp. Tech. Rep. FS-00-
              D162, August 1991.

   [AFS3-VVL]
              Zayas, E., "AFS-3 Programmer's Reference: Volume Server/
              Volume Location Server Interface", Transarc Corp. Tech.
              Rep. FS-00-D165, August 1991.

   [CMU-ITC-83-025]
              Morris, J., Van Houweling, D., and K. Slack, "The
              Information Technology Center", CMU ITC Tech. Rep. CMU-
              ITC-83-025, 1983.

   [CMU-ITC-84-020]
              West, M., "VICE File System Services", CMU ITC Tech.
              Rep. CMU-ITC-84-020, August 1984.

   [CMU-ITC-88-070]
              Zayas, E. and C. Everhart, "Design and Specification of
              the Cellular Andrew Environment", CMU ITC Tech. Rep. CMU-
              ITC-88-070, August 1988.

   [RFC4506]  Eisler, M., "XDR: External Data Representation Standard",
              STD 67, RFC 4506, May 2006.

   [VICE1]    Satyanarayanan, M., Howard, J., Nichols, D., Sidebotham,
              R., Spector, A., and M. West, "The ITC Distributed File
              System: Principles and Design", Proc. 10th ACM Symp.
              Operating Sys. Princ. Vol. 19, No. 5, December 1985.
















Keiser & Jenkins         Expires October 8, 2010               [Page 32]

Internet-Draft               AFSVol TLV RPCs                  April 2010


Appendix A.  XDR Grammar for FS-CM Capabilities Mechanism

            const AFSCAPABILITIESMAX = 196;

            typedef afs_uint32 Capabilities<AFSCAPABILITIESMAX>;

            /* Viced Capability Flags */
            const VICED_CAPABILITY_ERRORTRANS   = 0x0001;
            const VICED_CAPABILITY_64BITFILES   = 0x0002;
            const VICED_CAPABILITY_WRITELOCKACL = 0x0004;
            const VICED_CAPABILITY_SANEACLS     = 0x0008;

            /* Cache Manager Capability Flags */
            const CLIENT_CAPABILITY_ERRORTRANS  = 0x0001;

                                 Figure 10


Authors' Addresses

   Thomas Keiser
   Sine Nomine Associates
   43596 Blacksmith Square
   Ashburn, VA  20147
   USA

   Phone: +1 703 723 6673
   Email: tkeiser@sinenomine.net


   Steven Jenkins
   Sine Nomine Associates
   43596 Blacksmith Square
   Ashburn, VA  20147
   USA

   Phone: +1 703 723 6673
   Email: sjenkins@sinenomine.net













Keiser & Jenkins         Expires October 8, 2010               [Page 33]


