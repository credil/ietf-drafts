<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="no" ?>
<?rfc subcompact="no" ?>
<rfc category="exp" docName="draft-teint-xidna-base-00" ipr="trust200902">
<front>   <!-- 0123456789012345678901234567890123456789 -->
<title abbrev="Extending IDNA to Other Protocols">

	Extending Internationalised Domain Names in Applications
	to Other Protocols (X-IDNA)

</title>

<author fullname="Nick Teint" initials="N." surname="Teint">
<organization></organization>

<address>
<email>nick.teint@googlemail.com</email>
</address>
</author>

<date year="2010" />
<area>Applications</area>
<workgroup>Internet Engineering Task Force</workgroup>
<keyword>internationalisation</keyword>

<abstract>

<t>Prior to Internationalised Domain Names in Applications (IDNA), there has
been no standard method for domains, names, addresses and similar identifiers
to use characters outside the ASCII repertoire.  This still applies to many
identifiers that are no domain names, such as email addresses (local-part),
newsgroup names, etc.</t>

<t>This document extends the mechanism defined in IDNA to other protocols and
their identifiers. As with IDNA, these identifiers may be drawn from a large
repertoire (Unicode) and are mapped to backward-compatible identifiers using
only ASCII characters.</t>

<t>For valid domain names, X-IDNA produces the same encoding as IDNA, even when
these domain names are embedded in other addresses.</t>

    </abstract>
  </front>

  <middle>

<section title="Introduction">

<section title="Overview">

<t>X-IDNA works by extracting anything from the address that fits the syntax of
a valid domain name "label", i.e. strings that roughly match the "LDH" syntax
for "A-labels" and "U-labels".

<vspace/>These extracted, putative labels are then put through a conversion the
normative part of which is identical to the normative part of IDNA2008.</t>

<t>The characters that do not form labels, the separators, are solely drawn
from the ASCII repertoire (potentially mapped from Unicode lookalikes) and thus
need no internationalisation.</t>

<t>Special processing, called address normalisation, ensures that addresses
considered equivalent in a protocol that allows arbitrary "quoting" or
"escaping" produce the same "labels".</t>

<t>X-IDNA Profiles state to which (part of) address specifications X-IDNA is
applied and what steps have to be taken for address normalisation.</t>

</section>

<section title="Rationale">

<t>Unlike other methods for address internationalisation (such as
allowing UTF-8), using X-IDNA, as IDNA, allows the graceful
introduction of internationalised addresses not only by avoiding
upgrades to existing infrastructure (such as DNS servers and mail
transport agents), but also by allowing some limited use of
internationalised addresses in applications by using the
ASCII-encoded representation of the labels containing non-ASCII
characters.  While such names are user-unfriendly to read and type,
and hence not optimal for user input, they can be used as a last
resort to allow rudimentary usage of internationalised addresses.
For example, they might be the best choice for display if it were
known that relevant fonts were not available on the user's
computer.</t>

<t>For protocols that have been extended to allow Unicode addresses
to be used directly, X-IDNA also provides a way to "downgrade" the
addresses that does not require lookups in a database or
transmission of alternative ASCII addresses.</t>

<t>When strings covered by one profile of X-IDNA end up in places
that are covered by a different profile, it does not matter whether
the labels are converted to a A-Labels first and then put into the
other string or vice-versa, provided that due care has been taken in
defining these profiles.</t>

<t>The same is true for IDNA and X-IDNA as long as the domain name is
valid, i.e. as long as it consists entirely of LDH-Labels.  For
example, if a valid domain name is put into the local-part of an
email address, the conversion of the domain's U-Labels to A-Labels
will be identical in IDNA and X-IDNA.</t>

<t>This property is best demonstrated by the examples in <xref
target="I-D.teint-xidna-zonefile"/>.</t>

</section>

<section title="Requirements Language">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document
are to be interpreted as described in <xref target="RFC2119" />.</t>

</section>

<section title="IDNA 2008">
 
<t>As X-IDNA essentially piggy-backs on IDNA 2008, the reader ought to be
familiar with the following specifications: 
<xref target="I-D.ietf-idnabis-defs" />, 
<xref target="I-D.ietf-idnabis-protocol" />, 
<xref target="I-D.ietf-idnabis-mappings" />, 
<xref target="I-D.ietf-idnabis-tables" />, 
<xref target="I-D.ietf-idnabis-bidi" /> and 
<xref target="I-D.ietf-idnabis-rationale" /></t>

</section>
</section>

<section title="Definitions">

<section title="Addresses, Normalised Addresses and Labels" anchor="labeldef">

<t>An "address" is defined in this document to be a protocol element
used in addressing network ressources, such as domain names, names,
addresses and similar identifiers. An address is in a
protocol-dependent format.  An X-IDNA profile is required to specify
which protocol elements constitute an address and how to map
addresses  to normalised addresses.

<vspace/>For the purposes of this specification, the definition of
an address need not contain the complete "address field" defined in
the other protocol.

For example, a protocol that has strings consisting of
locally-assigned names, domain names and numeric addresses may
specify that the locally-assigned names are covered by X-IDNA
whereas the domain names are covered by IDNA and the numeric
addresses are not internationalised.  A different protocol that
allows address specifications containing both strings used for
ressource identification and free-form text intended for human
consumption may specify that X-IDNA applies to the the ressource
identification part of the address specification whereas the
human-readable text is covered by a different internationalisation
protocol.</t>


<t>A "normalised address" is defined in this document to be an address that is
in a format suitable as input to the generic X-IDNA protocol defined in this
document. A normalised address consists of one or more labels, each separated
by one or more separators.  It is produced in the normalisation steps (see
<xref target="toascii-normalise" /> to <xref target="toascii-nfc" />) of the
X-IDNA protocol defined in this document.

<vspace/> For the purposes of this document, a normalised address
need not be suitable for equivalence comparision.</t>

<t>A "label" is defined in this document to be a part of a normalised address
that does not contain a separator. It is produced in the label extraction step
(see <xref target="toascii-extract" />) of the X-IDNA protocol defined in this
document.

<vspace />This definition of "label" is a generalisation of that
found in <xref target="I-D.ietf-idnabis-defs" />: the term is applied to strings that are not
part of a domain name.</t>

<t>The definition of "A-Label", "fake A-Label", "U-Label",
"LDH-Label", "R-LDH-Label" and "NR-LDH-Label" is taken from
<xref target="I-D.ietf-idnabis-defs" /> but applied to strings that are not part of a domain
name.</t>

<t>A "separator" is a (base) character that appears between labels
and is passed through the X-IDNA process as-is.  Separators are also
extracted in the label extraction step (see <xref
target="toascii-extract" />)
of the X-IDNA protocol defined in this document.</t>

<t>An "ASCII address" is an address that consists entirely of base
characters. It can contain A-Labels, fake A-Labels, R-LDH-Labels and
NR-LDH-Labels and separators.</t>

<t>A "Unicode address" may consist of both base and extended characters.
It can contain A-Labels, fake A-Labels, R-LDH-Labels, NR-LDH-Labels,
U-Labels and separators.</t>

<t>An "internationalised address" is either an ASCII address or a
Unicode address.</t>

</section>

<section title="ACE Prefix">

<t>The "ACE prefix" is defined in this document to be a string of
ASCII characters "xn--" that appears at the beginning of every
A-Label. "ACE" stands for "ASCII-Compatible Encoding".</t>

</section>

<section title="Address slots" anchor="addressslots">

<t>An "address slot" is defined in this document to be a protocol element or a
function argument or a return value (and so on) explicitly designated for
carrying an "address".

Examples of address name slots include the email address following in the
parameter to the SMTP MAIL or RCPT commands or the "From:" field of an email
message header; the newsgroup name appearing in Netnews; and the domain name in
the QNAME field of a DNS query.

A string that has the syntax of an address but that appears in general text is
not in a address slot.  For example, an email address appearing in the plain
text body of an email message is not occupying an address name slot.</t>

<t>An "X-IDNA-aware address slot" is defined to be an address slot explicitly
designated for carrying an internationalised  address as defined in profiles
based on this document.

The designation may be static (for example, in the specification of the
protocol or interface) or dynamic (for example, as a result of negotiation in
an interactive session).</t>

<t>An "X-IDNA-unaware address slot" is defined for this set of documents to be
any address slot that is not an X-IDNA-aware address slot.  Obviously, this
includes any address slot whose specification predates X-IDNA or a profile
defined for these types of addresses. For domain names, it includes any domain
name slot (as defined in <xref target="I-D.ietf-idnabis-defs" />, Section 2.3.2.6) that predates IDNA.</t>

<t>These definitions are generalisations of the "domain name slots"
defined in <xref target="I-D.ietf-idnabis-defs" />, Section 2.3.2.6.</t>
</section>


<section title="Characters">

<t>A "base character" is a Unicode character in the range
U+0000..U+007F.  (These Unicode characters correspond to the "ASCII"
character set and are also known as "ASCII characters".)</t>

<t>An "extended character" is a Unicode character that is not a base
character, i.e. a character in the range U+0080 up to the maximum
Unicode codepoint (U+10FFFF as of <xref target="Unicode"/>).</t>

</section>

</section>

<section title="Requirements and Applicability">

<section title="Requirements">
<t>X-IDNA makes the following requirements:

<list style="numbers">

<t>Whenever an address is put into an X-IDNA-unaware address slot (see <xref
target="addressslots"/>), it MUST contain only base characters and follow the
syntax mandated by the specification defining the address type.
<vspace blankLines="1"/>
If the address type is case-sensitive, any A-Label within the address MUST be
converted to lowercase.</t>

<t>A-Labels and U-Labels <xref target="labeldef"/> within an address MUST be
compared using equivalent forms: either both A-Label forms or both U-Label
forms.  Because A-Labels and U-Labels can be transformed into each other
without loss of information, these comparisons are equivalent.

A pair of A-Labels MUST be compared as case-insensitive ASCII.  U-Labels MUST
be compared as-is, without case-folding or other intermediate steps.  Note that
it is not necessary to validate labels in order to compare them and that
successful comparison does not imply validity.  In many cases, not limited to
comparison, validation may be important for other reasons and SHOULD be
performed.

<vspace blankLines="1"/>
Separators and labels that are neither A-Labels nor U-Labels (e.g., fake
A-Labels and NR-LDH-Labels) MUST not match any A-Label or U-Label; other than
that, X-IDNA does not make requirements for these (e.g., NR-LDH-Labels may be
compared with or without case-folding, depending on the address slot type.)</t>

<t>When addresses are not validated, they MUST conform to the requirements of
<xref target="lookup"/>. When addresses are validated, they MUST conform to the
requirements of <xref target="registration"/>.
</t>

</list>
</t>

</section>

<section title="Applicability and X-IDNA Profiles">

<t>The application of X-IDNA to any type of address depends on an additional
specification that provides the details.  These other specifications are
referred to as X-IDNA Profiles.</t>

<t>Each definition of an X-IDNA Profile MUST include all of the following:

<list style="numbers">

<t>The protocol or protocols to which X-IDNA is applied and the syntax elements
of these protocols that represent an X-IDNA-unaware address slot.</t>

<!-- <t>A statement whether the mixed-case variant (as described in
<xref target="mixcase" />) is used.</t> -->

<t>The steps necessary to map any syntactically valid address to a normalised
address (as described in <xref target="toascii-normalise" />)</t>

<t>The parts of the protocol that require checking the address for validity (as
described in <xref target="registration" />).</t>

</list>

</t>

<t>A specification MAY also include:

<list style="symbols">

<t>Syntax extensions for X-IDNA-aware address slots.</t>

<t>Methods for interoperation with other ways of address
internationalisation.</t>

</list>
</t>

</section>
</section>

<section title="Address Conversion" anchor="lookup">

<t>Before an Internationalised Address is put into a X-IDNA-unaware slot, it
MUST be converted to an ASCII Address using the following procedure.</t>

<t>Although some validity checks are necessary to avoid serious problems with
the protocol, the tests are permissive and rely on the assumption that names
that can be successfully used are valid.  That assumption is, however, a weak
one because the presence of wild cards in the receiving system might cause a
string that has not been explicitly defined and validated to be successfully
used as an address.</t>

<t>This procedure in a generalisation of the Domain Name Lookup Protocol
defined in <xref target="I-D.ietf-idnabis-protocol" />, Section 5.</t>

<section title="Address Input" anchor="toascii-input">

<t>The user supplies a string in the local character set, for example by typing
it or clicking on, or copying and pasting, a resource identifier, e.g., a URI
(<xref target="RFC3986"/>) or IRI (<xref target="RFC3987"/>) from which the
address is extracted.  Alternately, some process not directly involving the
user may read the string from a file or obtain it in some other way.</t>

<t>Processing in this step and that specified in 
<xref target="toascii-tounicode" />,
<xref target="toascii-normalise" /> and
<xref target="toascii-nfc" />
 are local matters, to be accomplished prior
to actual invocation of X-IDNA.</t>

</section>

<section title="Conversion To Unicode" anchor="toascii-tounicode">

<t>The string is converted from the local character set into Unicode, if it is
not already in Unicode.</t>

<t>Depending on local needs, this conversion may involve mapping some
characters into other characters as well as coding conversions.  This section
defines a general algorithm that applications ought to implement in order to
produce Unicode code points that will be valid under the IDNA protocol.</t>

<t>An application might implement the full mapping as described below, or can
choose a different mapping.  In fact, an application might want to implement a
full mapping that is substantially compatible with the original IDNA protocol
instead of the algorithm given here.</t>

<t>The general algorithm that an application (or the input method provided by
an operating system) ought to use is relatively straightforward:

<list style="numbers">

<t>Upper case characters are mapped to their lower case equivalents
by using the algorithm for mapping case in Unicode characters<!-- ,
unless the X-IDNA Profile uses the mixed-case variant and the upper
case characters are X-PVALID -->.</t>

<t>Full-width and half-width characters (those defined with Decomposition Types
&lt;wide&gt; and &lt;narrow&gt;) are mapped to their decomposition mappings as
shown in the Unicode character database.</t>

<t>The application can also choose to map  some or all of the
following separator characters to ASCII characters which are
roughly equivalent:

<list style="symbols">

<t>mapped to U+0020 (SPACE):<list style="symbols">
<t>all characters having a canonical or compatibility
decomposition to U+0020</t></list></t>

<t>mapped to U+0022 (QUOTATION MARK):<list style="symbols">
<t>U+201C (LEFT DOUBLE QUOTATION MARK)</t>
<t>U+201D (RIGHT DOUBLE QUOTATION MARK)</t>
<t>U+201E (DOUBLE LOW-9 QUOTATION MARK)</t>
<t>U+201F (DOUBLE HIGH-REVERSED-9 QUOTATION MARK)</t>
<t>U+2033 (DOUBLE PRIME)</t>
<t>U+301D (REVERSED DOUBLE PRIME QUOTATION MARK)</t>
<t>U+301E (DOUBLE PRIME QUOTATION MARK)</t>
<t>U+301F (LOW DOUBLE PRIME QUOTATION MARK)</t>
</list></t>

<t>mapped to U+0027 (APOSTROPHE):<list style="symbols">
<t>U+2018 (LEFT SINGLE QUOTATION MARK)</t>
<t>U+2019 (RIGHT SINGLE QUOTATION MARK)</t>
<t>U+201B (SINGLE HIGH-REVERSED-9 QUOTATION MARK)</t>
<t>U+2032 (PRIME)</t>
</list></t>

<t>mapped to U+002C (COMMA):<list style="symbols">
<t>U+201A (SINGLE LOW-9 QUOTATION MARK)</t>
<t>U+3001 (IDEOGRAPHIC COMMA)</t>
</list></t>

<t>mapped to U+002E (FULL STOP):<list style="symbols">
<t>U+3002 (IDEOGRAPHIC FULL STOP)</t>
</list></t>

<t>mapped to U+003C (LESS-THAN SIGN):<list style="symbols">
<t>U+2039 (SINGLE LEFT-POINTING ANGLE QUOTATION MARK)</t></list></t>

<t>mapped to U+003E (GREATER-THAN SIGN):<list style="symbols">
<t>U+203A (SINGLE RIGHT-POINTING ANGLE QUOTATION MARK)</t></list></t>

<t>mapped to U+007C (VERTICAL LINE):<list style="symbols">
<t>U+00A6 (BROKEN BAR)</t></list></t>

<t>mapped to U+007E (TILDE):<list style="symbols">
<t>U+301C (WAVE DASH)</t></list></t>

</list></t>
</list></t>

<t>Unicode Normalisation ought to be deferred until after the Address
Normalisation defined in the following section.</t>

</section>

<section title="Address Normalisation" anchor="toascii-normalise">

<t>The string is then normalised as specified in the X-IDNA Profile applicable
for the type of address slot into which the string is intented to be put. This
step maps a syntactically valid address to a normalised address, from which
labels can be extracted.  It is defined by the X-IDNA Profile.</t>


<t>The rules for normalisations defined by X-IDNA Profiles are:

<list style="symbols"> 

<t>If the protocol to which the X-IDNA profile applies
considers two addresses as equivalent, the normalisation procedure MUST produce
strings that produces exactly the same labels in the following step, the label
extraction.  (However, the X-IDNA Profile may specify a normalisation that does
not produce output directly suitable for equivalence comparision.)</t>

<t>The runs of label characters produced by the normalisation SHOULD
be as long as possible.  Especially, the normalisation SHOULD treat
extended characters as "unreserved", "text", etc. It SHOULD NOT
mechanically insert "quote" or "escape" characters between
characters that can be part of a label.

<vspace blankLines="1"/>These two requirements are usually met if the
normalisation removes all optional separators ("quotes" or "escape"
characters), especially those appearing between characters that can be part of
a label.

<vspace blankLines="1"/>For example, if a protocols allows all characters to be
"quoted" by preceeding it with an optional U+002F (SOLIDUS), this
character needs to be removed if it is followed by any letter, digit,
hyphen or extended character; if a protocol allows non-significant
DOUBLE QUOTEs (U+0034) anywhere in the string, these need to be removed
if they appear within a label; and so on.</t>

<t>Extended characters SHOULD be either mapped to ASCII characters
or treated as belonging to the character class that needs no
"quoting" or "escaping" otherwise defined by the protocol.

<vspace blankLines="1"/>This requires special care for extended
characters in implementations. Leagacy code may mechanically escape
or quote them because they have traditionally not been in the
category defined as "unreserved", "text", etc.

<vspace blankLines="1"/>For example, an extended character may be
assigned to the character class "atext" defined in &RFC5322; for the
purposes of the normalisation.</t>

</list>
</t>


<t>An application MAY also choose to map invalid addresses to syntactically
valid addresses, for example by "escaping" or "quoting" problematic base
characters; or it MAY reject invalid addresses in this step.</t>

</section>

<section title="Unicode Normalisation" anchor="toascii-nfc">

<t>Depending on local needs, the string can then be mapped using
Unicode Normalization Form C (NFC).</t>

</section>

<section title="Extraction of Labels and Delimiters" anchor="toascii-extract">

<t>The normalised address is then split into putative labels and separators.
The labels extracted in this step have not been checked for conformance, are
therefore referred to as "putative".</t>

<t>The putative labels will start with a letter, digit or extended character,
which may be followed by a string that consists of zero or more letters,
digits, extended characters or the HYPHEN-MINUS, and ends in a letter, digit or
extended character.<vspace/>
The delimiters will be base characters that are not digits or letters.</t>

<t>The label extraction differs significantly from the procedure specified in
<xref target="I-D.ietf-idnabis-mappings" /> by adding a number of additional
separators in addition to U+002E (FULL STOP).</t>

<t>The purpose of this procedure is to ensure that all labels are IDNA-valid
(as defined in <xref target="I-D.ietf-idnabis-defs" />) regardless of the range
of non-LDH characters allowed in the address.</t>

<t>
<list style="symbols">
<t>The following Unicode codepoints are always part of a label:
<list style="symbols">
<t>U+0030 to U+0039 (DIGIT ZERO to DIGIT NINE)</t>
<t>U+0041 to U+005A (LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z)</t>
<t>U+0061 to U+007A (LATIN SMALL LETTER A to LATIN SMALL LETTER Z)</t>
<t>all above U+0080, inclusive</t>
</list>
That is, all ASCII digits and letters and all non-ASCII codepoints.
</t>

<t>The following Unicode codepoints are always separators:
<list style="symbols">
<t>U+0000 to U+002C (&lt;control&gt; NULL to COMMA)</t>
<t>U+002E to U+002F (FULL STOP to SOLIDUS)</t>
<t>U+002A to U+0040 (COLON to COMMERCIAL AT)</t>
<t>U+005B to U+0060 (LEFT SQUARE BRACKET to GRAVE ACCENT)</t>
<t>U+007B to U+007F (LEFT CURLY BRACKET to &lt;control&gt;DELETE)</t>
</list>
That is, all ASCII codepoints except for the hyphen, digits and letters.
</t>

<t>The following Unicode codepoint is part of a label or a separator, depending
on context:
<list style="symbols">
<t>U+002D (HYPHEN-MINUS)</t>
</list>

A sequence of one or more HYPHEN-MINUS characters is composed of separators exactly if the run
<list style="symbols">
<t>appears at the beginning or end of the address, OR</t>
<t>is preceeded or followed by a separator.</t>
</list>

That is, hyphens that would start or end a label (and thus violate the syntax
for LDH-Labels), are separators; other hyphens are part of a label.
</t>

</list>
</t>

</section>

<section title="A-Label Input" anchor="toascii-alabel-input">

<t>If a putative label extracted in the previous step appears to be an A-Label
(i.e., it starts in "xn--", interpreted case-insensitively and does not contain
extended characters), the application MAY attempt to convert it to a U-Label,
first ensuring that the A-Label is entirely in lower case (converting it to
lower case if necessary), and apply the tests of <xref
target="toascii-validation" /> and the conversion of <xref
target="toascii-punycode" /> to that form.  </t>

<t>If the label is converted to Unicode (i.e., to U-Label form) using the
Punycode decoding algorithm, then the processing specified in those two
sections MUST be performed.</t>

<t>If any of these steps fails or rejects the label (i.e., it's a fake
A-Label), the putative label MUST be used as-is.

<list style="symbols">
<t>the original MUST be used if the X-IDNA profile allows R-LDH-Labels, and</t>
<t>it MAY be rejected if the X-IDNA profile does not allow R-LDH-Labels.</t>
</list>
</t>

<t>If a label consists entirely of base characters, the following two steps
(<xref target="toascii-validation" /> and <xref target="toascii-punycode" />)
are skipped for this label.</t>

</section>

<section title="Validation and Character List Testing" anchor="toascii-validation">

<t>The putative labels extracted in the previous step are checked to verify
that all characters that appear in it are valid as input to X-IDNA processing.
As discussed above, this check is liberal in order to allow for compatibility
with future extensions.</t>

<t>Putative labels with any of the following characteristics MUST be rejected
in this step:

<list style="symbols">
<t>Labels that are not in NFC (<xref target="UAX15"/>)</t>

<t>Labels containing "--" (two consecutive hyphens) in the third and
fourth character positions</t>

<t>Labels whose first character is a combining mark (see Section 2.11 of <xref target="Unicode" />)</t>

<t>Labels containing prohibited code points, i.e., those that are
assigned to the "DISALLOWED" category of <xref target="I-D.ietf-idnabis-tables" />

<!--, and which have not been assigned to the "X-PVALID" category by the X-IDNA
Profile-->

</t>

<t>Labels containing code points that are identified in <xref target="I-D.ietf-idnabis-tables" /> as
"CONTEXTJ", i.e., requiring exceptional contextual rule processing on lookup,
but that do not conform to those rules.  Note that this implies that a rule
needs to be defined, not null: a character that requires a contextual rule but for
which the rule is null is treated in this step as having failed to conform to
the rule</t>

<t>Labels containing code points that are identified in <xref target="I-D.ietf-idnabis-tables" /> as
"CONTEXTO", but for which no such rule appears in the table of rules.
Applications resolving DNS names or carrying out equivalent operations are not
required to test contextual rules for "CONTEXTO" characters, only to verify
that a rule is defined (although they MAY make such tests to provide better
protection or give better information to the user)</t>

<t>Labels containing code points that are unassigned in the version of Unicode
being used by the application, i.e., in the "UNASSIGNED" category of
<xref target="I-D.ietf-idnabis-tables" />
<vspace />
This requirement means that the application needs to use a list of unassigned
characters that is matched to the version of Unicode that is being used for the
other requirements in this section.  It is not required that the application
know which version of Unicode is being used; that information might be part of
the operating environment in which the application is running.</t>
</list>
</t>

<t>In addition, the application SHOULD apply the following test:

<list style="symbols">
<t>Verification that the string is compliant with the requirements
for right to left characters, specified in <xref target="I-D.ietf-idnabis-bidi" />.</t>
</list>
</t>

<t>This test may be omitted in special circumstances, such as when the lookup
application knows that the conditions are enforced elsewhere, because an
attempt to use such strings as an address will almost certainly lead to an
error except when wild cards are present on a receiving system.  However,
applying the test is likely to give an earlier detection and much better
information about the reason for a failure -- information that may be usefully
passed to the user when that is feasible -- than later failure alone.</t>

<t>For all other strings, the lookup application MUST rely on the protocol
using the address to determine the validity of the address and the characters
they contain.  If they can successfully be used, they are presumed to be valid;
if they are not, their possible validity is not relevant.  While an application
may reasonably issue warnings about strings it believes may be problematic,
applications that decline to process a string that conforms to the rules above
(i.e., does not allow putting it into an address slot) are not in conformance
with this protocol.</t>

</section>

<section title="Punycode Conversion" anchor="toascii-punycode">

<t>The string that has now been validated is converted to ACE form by applying
the Punycode algorithm to the string and then adding the ACE prefix.</t>

</section>

<section title="Re-Assembly" anchor="toascii-reassembly">

<t>The A-Labels resulting from the conversion in <xref
target="toascii-punycode" /> or supplied directly (see <xref
target="toascii-alabel-input" />) is combined with the delimiters (see <xref
target="toascii-extract" />), in the original order, to form an A-Adress.</t>

<t>The ASCII Address can then be put into an X-IDNA-unaware address
slot and be used as a normal address.  The use of this address can
obviously either succees or fail (resulting in a lookup failure,
bounce message, etc.).</t>

</section>
</section>

<section title="Address Validation" anchor="registration">

<t>Whenever an X-IDNA Profile mandates that the addresses be validated, the
following procedure MUST be followed.</t>

<t>Addresses ought to be validated whenever an address is defined, registered,
etc.

An X-IDNA Profiles defines when and by whom addresses are validated.</t>


<section title="Label Validation" anchor="valid-label">

<t>In order to validate individual labels embedded in the address, it is
normalised as specified in <xref target="toascii-normalise" /> and then the
labels are extracted as specified in <xref target="toascii-extract" />.</t>

<t>The following validation steps apply to the extracted labels.

The labels (in the form of a Unicode string, i.e., a string that at least
superficially appears to be a U-label) are then examined, performing tests that
require examination of more than one character.  Character order is considered
to be the on-the-wire order, not the display order.</t>

<section title="Hyphen Restrictions">

<t>If the Unicode string contains non-base characters, it MUST NOT contain "--"
(two consecutive HYPHEN-MINUS characters) in the third and fourth character
positions.</t>

<t>Note: The Unicode string will not start or end with a "-" (HYPHEN-MINUS) at this
point.</t>

</section>

<section title="Leading Combining Marks">
<t>The Unicode string MUST NOT begin with a combining mark or combining
character (see Section 2.11 of <xref target="Unicode"/> for an exact
definition).</t>
</section>

<section title="Contextual Rules">
<t>The Unicode string MUST NOT contain any characters whose validity is
context-dependent, unless the validity is positively confirmed by a contextual
rule.  To check this, each code-point marked as CONTEXTJ or CONTEXTO in <xref
target="I-D.ietf-idnabis-tables"/> MUST have a non-null rule.  If such a
code-point is missing a rule, it is invalid.  If the rule exists but the result
of applying the rule is negative or inconclusive, the proposed label is
invalid.</t>
</section>

<section title="Labels Containing Characters Written Right to Left">
<t>
   If the proposed label contains any characters that are written from
   right to left it MUST meet the BIDI criteria <xref target="I-D.ietf-idnabis-bidi" />
</t>
</section>

<section title="Successful Punycode Encoding">

<t>The Unicode string MUST be convertible to ACE form using the Punycode
algorithm (<xref target="RFC3492"/>), i.e., it MUST NOT cause an overflow.</t>

</section>
</section>

<section title="Other Syntax Restrictions">

<t>In A-Address form, the address MUST conform to the syntax defined by the
X-IDNA-unaware specification for the address type.

This MAY include length restrictions, syntax restrictions regarding separators,
etc.</t>

</section>

<section title="Local Restrictions">

<t>In addition to the rules and tests above, there are many reasons why a
site, registry, or administrators could reject an address.</t>

<t>The responsible entity is expected to establish or follow policies about
addresses they wish to define or register.  Policies are likely to be informed
by the local languages and the scripts that are used to write them and may
depend on many factors including what characters are in the label (for example,
an address may be rejected based on other addresses already registered).</t>

<t>The same considerations as for IDNA registrations apply; see Section 3.2 of
<xref target="I-D.ietf-idnabis-rationale" />
for a discussion
   and recommendations about registry policies.
</t>

<t>While X-IDNA, unlike IDNA 2008, allows addresses that contain fake A-Labels
and R-LDH-Labels, responsible entities ought to avoid such addresses except
when backwards-compatibility requires them.</t>

</section>
</section>

<!--
<section title="Mixed-case variant" anchor="mixcase">

<t>If an X-IDNA Profile specifies the mixed-case variant, the modifications
defined in the following sections apply.</t>

<section title="Additional IDN Property">

<t>The following IDN property is defined in addition to those defined in
<xref target="I-D.ietf-idnabis-protocol" /> and <xref target="I-D.ietf-idnabis-tables" />:<list style="symbols">
<t>X-PVALID</t>
</list></t>

</section>

<section title="Additional category definitions">

<t>The following cetegories are defined in addition to those defined in
<xref target="I-D.ietf-idnabis-tables" />, Section 2:</t>

<section title="X-UpperCase (K)">

<figure><artwork>
K: cp == toNFKC(cp) == toNFC(cp) and 
   Lowercase_Mapping(cp)
    == toNFKC(Lowercase_Mapping(cp)) 
    == toNFC(Lowercase_Mapping(cp)) and      
   Uppercase_Mapping(Lowercase_Mapping(cp))
    == toNFKC(Uppercase_Mapping(Lowercase_Mapping(cp)))
    == toNFC(Uppercase_Mapping(Lowercase_Mapping(cp)))
</artwork></figure>

<t>This category is used to group uppercase characters that can be
used in mixed-case X-IDNA because they are sufficiently stable in
case transformations and normalisation.</t>

<t>The toNFKC() operation returns the code point in normalization form KC.  For
more information, see Section 5 of &UAX15;.</t>

<t>The Uppercase_Mapping() and Lowercase_Mapping() operations return the single-character
case mappings from UnicodeData.txt, as speficied in &Unicode5;, Section 4.2.</t>

</section>

<section title="X-LDH (L)">

<figure>
<artwork>
L: cp is in {0041..005A}
</artwork>
</figure>

<t>This category is used to preserve the traditional uppercase LDH characters
('A'..'Z'). In general, these code points are suitable for mixed-case X-IDNA.</t>

</section>

</section>

<section title="Modified Calculation of the Derived Property">

<t>The modfied algorithm to calculate the value of the derived property is 
   follows:</t>

<figure>
<artwork>
   If .cp. .in.  Exceptions Then Exceptions(cp);
   Else If .cp. .in.  BackwardCompatible Then BackwardCompatible(cp);
   Else If .cp. .in.  Unassigned Then UNASSIGNED;
   Else If .cp. .in.  LDH Then PVALID;
   Else If .cp. .in.  X-LDH Then X-PVALID;
   Else If .cp. .in.  JoinControl Then CONTEXTJ;
   Else If .cp. .in.  IgnorableProperties Then DISALLOWED;
   Else If .cp. .in.  IgnorableBlocks Then DISALLOWED;
   Else If .cp. .in.  OldHangulJamo Then DISALLOWED;
   Else If .cp. .in.  Unstable Then 
     If .cp. .in. LetterDigits and .cp. .in. X-UpperCase Then X-PVALID;
     Else DISALLOWED;
   If .cp. .in. LetterDigits Then PVALID;
   Else DISALLOWED;
</artwork>
</figure>

<t>Informally, this assigns uppercase letters that are stable in round-trip
case mapping the property X-PVALID instead of DISALLOWED.</t>

</section>

</section>

<section title="Mixed-case Punycode">

<t>When an X-IDNA Profile specifies the mixed-case variant, the
following procedures MUST be used in the place of the procedures
defined in &Punycode;, Sections 6.2 and 6.3.</t>

<t>This is similar to the "mixed-case annotation" defined in
&Punycode;, Appendix A.  However, these annotations have been
purely advisory and lacked the exact definition of what
constitutes an "upper" and "lower case" character.<vspace/>
Further, as the mixed-case variant is mandatory in this
specification, it can be made part of the Punycode algorithm,
which eases implementation.</t>

<section title="Modified decoding procedure">

<figure><artwork>
let n = initial_n
let i = 0
let bias = initial_bias
let output = an empty string indexed from 0
consume all code points before the last delimiter (if there is one)
  and copy them to output, fail on any non-basic code point
if more than zero code points were consumed then consume one more
  (which will be the last delimiter)
while the input is not exhausted do begin
  let oldi = i
  let w = 1
  for k = base to infinity in steps of base do begin
    consume a code point, or fail if there was none to consume
    let digit = the code point's digit-value, fail if it has none
    let uppercase flag = True if the code point's digit was an
      uppercase character, False otherwise

    let i = i + digit * w, fail on overflow
    let t = tmin if k &lt;= bias {+ tmin}, or
            tmax if k &gt;= bias + tmax, or k - bias otherwise
    if digit < t then break
    let w = w * (base - t), fail on overflow
  end
  let bias = adapt(i - oldi, length(output) + 1, test oldi is 0?)
  let n = n + i div (length(output) + 1), fail on overflow
  let i = i mod (length(output) + 1)
  {if n is a basic code point then fail}

  if uppercase flag == True and n has a single-character
  Uppercase_Mapping, then insert Uppercase_Mapping(n) into output
  at position i, else insert n into output at position i

  increment i
end
</artwork></figure>

<section title="Modified encoding procedure">

<figure><artwork>
let n = initial_n
let delta = 0
let bias = initial_bias
let h = b = the number of basic code points in the input
copy them to the output in order, followed by a delimiter if b > 0
{if the input contains a non-basic code point < n then fail}

for each code point c in the input do begin
  if c has a single-character Lowercase_Mapping then begin
    store a uppercase flag for the position of c
    replace c in the input with Lowercase_Mapping(c)
  end
end

while h < length(input) do begin
  let m = the minimum {non-basic} code point >= n in the input
  let delta = delta + (m - n) * (h + 1), fail on overflow
  let n = m
  for each code point c in the input (in order) do begin
    if c < n {or c is basic} then increment delta, fail on overflow
    if c == n then begin
      let q = delta
      for k = base to infinity in steps of base do begin
        let t = tmin if k &lt;= bias {+ tmin}, or
                tmax if k &gt;= bias + tmax, or k - bias otherwise
        if q < t then break
        output the code point for digit t + ((q - t) mod (base - t))
        let q = (q - t) div (base - t)
      end

	 if an uppercase flag has been stored for the position of
	 c, then output the uppercased code point for digit q, else
	 output the code point for digit q

      let bias = adapt(delta, h + 1, test h equals b?)
      let delta = 0
      increment h
    end
  end
  increment delta and n
end
</artwork></figure>

</section>
</section>

</section>
-->


<section anchor="Acknowledgements" title="Acknowledgements">

<t>The larger part of this specifications was directly lifted from IDNA 2008,
and would not have been possible without the excellent work that went into
these specifications.</t>

</section>

    <!-- Possibly a 'Contributors' section ... -->

<section anchor="IANA" title="IANA Considerations">

<t>This memo includes no request to IANA.</t>

<t>The definition of an X-IDNA Profiles ought to be coordinated with the entity
that controls the specification of the address slot type to which X-IDNA is
applied, instead.</t>

</section>

    <section anchor="Security" title="Security Considerations">

<t>X-IDNA shares the Security Considerations for IDNA, which are described
in <xref target="I-D.ietf-idnabis-defs" />, except for the special issues
associated with right to left scripts and characters.  The latter are discussed
in <xref target="I-D.ietf-idnabis-bidi" />.</t>

<t>In addition, each X-IDNA Profile will require additional Security Considerations,
which MUST be discussed in the document defining the Profile.</t>

    </section>

</middle>

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml" ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3492.xml" ?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-idnabis-bidi.xml" ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-idnabis-defs.xml" ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-idnabis-mappings.xml" ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-idnabis-protocol.xml" ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-idnabis-tables.xml" ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-idnabis-rationale.xml" ?>

      <reference anchor="Unicode" target="http://www.unicode.org/versions/Unicode5.2.0/">
        <front>
            <title>Unicode Standard, Version 5.2</title>
            <author>
                <organization>Unicode Consortium</organization>
            </author>
            <date month="December" year="2009" />
        </front>
      </reference>

      <reference anchor="UAX15" target="http://unicode.org/reports/tr15/tr15-31.html">
	<front>
	  <title>Unicode Normalization Forms, Revision 31</title>
	  <author initials="M." surname="Davis"><organization>Google, Inc.</organization></author>
	  <author initials="K." surname="Whistler"><organization>Unicode Consortium</organization></author>
	  <author initials="M." surname="Duerst"><organization/></author>
	  <date month="September" year="2009" />
	</front>
	<seriesInfo name="UAX" value="#15" />
      </reference>
    </references>

    <references title="Informative References">
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3987.xml"?>

      <reference anchor="I-D.teint-xidna-zonefile">
	<front><title> An X-IDNA Profile for DNS Zone Master Files</title>
	<author initials="N" surname="Teint"><organization/></author>
	<date month="March" year="2010"/></front>
	<seriesInfo name='Internet-Draft' value='draft-teint-xidna-zonefile-00'/>
      </reference>


    </references>

  </back>
</rfc>



