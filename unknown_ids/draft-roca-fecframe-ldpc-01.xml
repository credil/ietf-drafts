<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<rfc category="exp" ipr="trust200902">

<?xml-stylesheet type='text/xsl'
                 href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>


	<front>
		<title abbrev='Simple LDPC-Staircase FEC Scheme'>
			Simple LDPC-Staircase Forward Error Correction (FEC) Scheme for FECFRAME
		</title>

		<author initials='V' surname="Roca" fullname='Vincent Roca'>
			<organization>INRIA</organization>
			<address>
				<postal>
					<street>655, av. de l'Europe</street>
					<street>Inovallee; Montbonnot</street>
					<city>ST ISMIER cedex</city>
					<code>38334</code>
					<country>France</country>
				</postal>
				<email>vincent.roca@inria.fr</email>
				<uri>http://planete.inrialpes.fr/people/roca/</uri>
			</address>
		</author>
		<author initials='M' surname="Cunche" fullname='Mathieu Cunche'>
			<organization>NICTA</organization>
			<address>
				<postal>
					<street></street>
					<city></city>
					<code></code>
					<country>Australia</country>
				</postal>
				<email>mathieu.cunche@nicta.com.au</email>
				<uri>http://mathieu.cunche.free.fr/</uri>
			</address>
		</author>
		<author initials="J" surname="Lacan" fullname="Jerome Lacan">
			<organization>ISAE/LAAS-CNRS</organization>
			<address>
				<postal>
					<street>1, place Emile Blouin</street>
					<city>Toulouse</city>
					<code>31056</code>
					<country>France</country>
				</postal>
				<email>jerome.lacan@isae.fr</email>
				<uri>http://dmi.ensica.fr/auteur.php3?id_auteur=5</uri>
				
			</address>
		</author>

		<date day="22" month="October" year="2010"/>
		<area>Transport</area>
		<workgroup>FecFrame</workgroup>
		<keyword>I-D</keyword>
		<keyword>Internet-Draft</keyword>
		<keyword>Forward Error Correction</keyword>
		<keyword>LDPC-Staircase</keyword>

		<abstract>
<t>
This document describes a fully-specified simple FEC scheme for LDPC-staircase codes
that can be used to protect media streams along the lines defined by the FECFRAME framework.
<!-- These codes belong to the well-known class of "Low Density Parity Check" codes. -->
These codes have many interesting properties: 
they are systematic codes, they perform close to ideal codes in many use-cases and they also
feature very high encoding and decoding throughputs.
LDPC-Staircase codes are therefore a good solution to protect a single high bitrate source
flow, or to protect globally several mid-rate flows within a single FECFRAME instance.
They are also a good solution whenever the processing load of a software encoder or
decoder must be kept to a minimum.
</t>
		</abstract>
	</front>

	<middle>

		<section anchor="Introduction" title="Introduction">
		<!-- =========================================== -->

<t>The use of Forward Error Correction (FEC) codes is a classic solution to improve the reliability
of unicast, multicast and broadcast Content Delivery Protocols (CDP) and applications
<xref target="RFC3453"/>.
The <xref target="FECFRAME-FRAMEWORK"/> document describes a generic framework to use FEC schemes
with media delivery applications, and for instance with real-time streaming media applications based
on the RTP real-time protocol.
Similarly the <xref target="RFC5052"/> document describes a generic framework to use FEC schemes
with with objects (e.g., files) delivery applications based on the ALC  <xref target="RFC5775"/>
and NORM <xref target="RFC5740"/> reliable multicast transport protocols.
</t>

<t>More specifically, the <xref target="RFC5053"/> (Raptor) and <xref target="RFC5170"/> (LDPC-Staircase
and LDPC-Triangle) FEC schemes introduce erasure codes based on sparse parity check matrices for object
delivery protocols like ALC and NORM.
Similarly, the <xref target="RFC5510"/> document introduces Reed-Solomon codes based on Vandermonde
matrices for the same object delivery protocols.
All these codes are systematic codes, meaning that the k source symbols are part of the n encoding symbols.
Additionally, the Reed-Solomon FEC codes belong to the class of Maximum Distance Separable (MDS) codes that
are optimal in terms of erasure recovery capabilities.
It means that a receiver can recover the k source symbols from any set of exactly k encoding symbols out of n.
This is not the case with either Raptor or LDPC-Staircase codes, and these codes require a certain
number of encoding symbols in excess to k.
However, this number is small in practice when an appropriate decoding scheme is used at the
receiver <xref target="SPSC08"/>.
Another key difference is the high encoding/decoding complexity of Reed-Solomon codecs compared to
Raptor or LDPC-Staircase codes.
A difference of one or more orders of magnitude or more in terms of encoding/decoding speed exists between
the Reed-Solomon and LDPC-Staircase software codecs <xref target="SPSC08"/><xref target="CunchePHD10"/>.
Finally, Raptor and LDPC-Staircase codes are large block FEC codes, in the sense of <xref target="RFC3453"/>,
since they can efficiently deal with a large number of source symbols. 
</t>

<t>
The present document focuses on LDPC-Staircase codes, that belong to the well-known class of
"Low Density Parity Check" codes.
Because of their key features, these codes are a good solution to protect a single high bitrate source
flow as in <xref target="LCN10"/>, or to protect globally several mid-rate source flows within a single
FECFRAME instance.
They are also a good solution whenever processing requirements at a software encoder or decoder must be
kept to a minimum, independently of the ADU flow(s) bitrate.
</t>

<t>
This documents inherits from <xref target="RFC5170"/> the specifications of the core LDPC-Staircase codes.
Therefore this document specifies only the information specific to the FECFRAME context and
refers to <xref target="RFC5170"/> for the core specifications of the codes.
To that purpose, the present document introduces:
<list style="symbols">
	<t> the Fully-Specified FEC Scheme with FEC Encoding ID XXX that specifies a simple way 
	of using LDPC-Staircase codes in order to protect arbitrary ADU flows. </t>
</list>
</t>

<t>
Finally, a publicly available reference implementation of these codes is available and distributed
under a GNU/LGPL (Lesser General Public License) <xref target="LDPC-codec"/>.
</t>
		</section>


		<section anchor="Terminology" title="Terminology">
		<!-- =========================================== -->

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>
		</section>


		<section anchor="DefinitionsNotationsandAbbreviations" title="Definitions Notations and Abbreviations">
		<!-- =========================================== -->


			<section anchor="Definitions" title="Definitions">
			<!-- =========================================== -->

<t>This document uses the following terms and definitions.
Some of them are FEC scheme specific and are in line with <xref target="RFC5052"/>:
<list style="hanging">
<t hangText="Source symbol:">	unit of data used during the encoding process.
				In this specification, there is always one source symbol per ADU.</t>

<t hangText="Encoding symbol:">	unit of data generated by the encoding process.
				With systematic codes, source symbols are part
				of the encoding symbols.</t>

<t hangText="Repair symbol:">	encoding symbol that is not a source symbol.</t>

<t hangText="Code rate:">	the k/n ratio, i.e., the ratio between the number
				of source symbols and the number of encoding symbols.
				By definition, the code rate is such that: 0 &lt; code rate &le; 1.
				A code rate close to 1 indicates that a small number of repair
				symbols have been produced during the encoding process.</t>

<t hangText="Systematic code:">	FEC code in which the source symbols are part
				of the encoding symbols. The Reed-Solomon codes
				introduced in this document are systematic.</t>

<t hangText="Source block:">	a block of k source symbols that are considered
				together for the encoding.</t>

<t hangText="Packet Erasure Channel:"> 
				a communication path where packets are either
				dropped (e.g., by a congested router, or because the
				number of transmission errors exceeds the correction
				capabilities of the physical layer codes) or
				received. When a packet is received, it is assumed
				that this packet is not corrupted.</t>
</list>
</t>

<t>
Some of them are FECFRAME framework specific and are in line with
<xref target="FECFRAME-FRAMEWORK"/>:
<list style="hanging">
<t hangText="Application Data Unit (ADU):">
				a unit of data coming from (sender) or given to (receiver)
				the media delivery application.
				Depending on the use-case, an ADU can use an RTP encapsulation.
				In this specification, there is always one source symbol per ADU.</t>

<t hangText="(Source) ADU Flow:">
				a flow of ADUs from a media delivery application
				and to which FEC protection is applied.
				Depending on the use-case, several ADU flows can be protected
				together by the FECFRAME framework.</t>

<t hangText="ADU Block:">	a set of ADUs that are considered together by the FECFRAME
				instance for the purpose of the FEC scheme. 
				Along with the F[], L[], and Pad[] fields, they form the set
				of source symbols over which FEC encoding will be performed.</t>

<t hangText="ADU Information (ADUI):">
				a unit of data constituted by the ADU and the associated
				Flow ID, Length and Padding fields
				(<xref target="CommonProc_src_block_creation"/>).
				This is the unit of data that is used as source symbol.</t>

<t hangText="FEC Framework Configuration Information:">
				the FEC scheme specific information that enables the synchronization
				of the FECFRAME sender and receiver instances.</t>

<t hangText="FEC Source Packet:">
				a data packet submitted to (sender) or received from
				(receiver) the transport protocol.
				It contains an ADU along with its optional Explicit Source
				FEC Payload ID.</t>

<t hangText="FEC Repair Packet:">
				a repair packet submitted to (sender) or received from
				(receiver) the transport protocol.
				It contains a repair symbol along with its Repair
				FEC Payload ID.</t>
</list>
</t>


<t>
The above terminology is illustrated in <xref target="fig_terminology"/>
(sender's point of view):
</t>

<figure anchor="fig_terminology" title="Terminology used in this document (sender).">
  <artwork>
+----------------------+
|     Application      |
+----------------------+
           |
 ADU flow  | (1) Application Data Unit (ADU)
           v
+----------------------+                           +----------------+
|    FEC Framework     |                           |                |
|                      |------------------------- >|  FEC Scheme    |
|(2) Construct an ADU  | (4) Source Symbols for    |                |
|    block             |     this Source Block     |(5) Perform FEC |
|(3) Construct ADU Info|                           |    Encoding    |
|(7) Construct FEC Src |< -------------------------|                |
|    Packets and FEC   |(6) Ex src FEC Payload Ids,|                |
|    Repair Packets    |    Repair FEC Payload Ids,|                |
+----------------------+    Repair Symbols         +----------------+
    |             |
    |(8) FEC Src  |(8') FEC Repair
    |    packets  |     packets
    v             v
+----------------------+
|   Transport Layer    |
|    (e.g., UDP )      |
+----------------------+
  </artwork>
</figure>

			</section>


			<section anchor="Notations" title="Notations">
			<!-- =========================================== -->

<t>This document uses the following notations:
Some of them are FEC scheme specific:
<list style="hanging" hangIndent="7">
<t hangText="k">	denotes the number of source symbols in a source block.</t>
<t hangText="max_k">	denotes the maximum number of source symbols for any source block.</t>
<!-- <t hangText="n_r">	denotes the number of repair symbols generated for a source block.</t> -->
<t hangText="n">	denotes the number of encoding symbols generated for a source block.</t>
<!--			Therefore: n = k + n_r.</t> -->
<!--
<t hangText="max_n">	denotes the maximum number of encoding symbols generated for any source block.</t> -->
<t hangText="E">	denotes the encoding symbol length in bytes.</t>
<t hangText="CR">	denotes the "code rate", i.e., the k/n ratio.</t>
<t hangText="N1">	denotes the target number of "1s" per column in the left side of
			the parity check matrix.</t>
<t hangText="N1m3">	denotes the value N1 - 3.</t>
<!-- <t hangText="G">	denotes the number of Repair Symbols in a given FEC Repair Packet.
			This value may differ between different FEC Repair Packets.</t> -->
<t hangText="a^^b">	denotes a raised to the power b.</t>
</list>
</t>

<t>
Some of them are FECFRAME framework specific:
<list style="hanging" hangIndent="7">
<t hangText="B">	denotes the number of ADUs per ADU block.</t>
<t hangText="max_B">	denotes the maximum number of ADUs for any ADU block.</t>
</list>
</t>
			</section>


			<section anchor="Abbreviations" title="Abbreviations">
			<!-- =========================================== -->

<t>This document uses the following abbreviations:
<list style="hanging" hangIndent="7">
<t hangText="ADU">	stands for Application Data Unit.</t>
<t hangText="ESI">	stands for Encoding Symbol ID.</t>
<t hangText="FEC">	stands for Forward Error (or Erasure) Correction code.</t>
<t hangText="FFCI">	stands for FEC Framework Configuration Information.</t>
<t hangText="LDPC">	stands for Low Density Parity Check.</t>
<t hangText="RS">	stands for Reed-Solomon.</t>
<t hangText="MDS">	stands for Maximum Distance Separable code.</t>
</list>
</t>
			</section>

		</section>



<section anchor="CommonProcedures" title="Common Procedures Related to the ADU Block and
Source Block Creation">
<!-- ================ -->
<t>
This section introduces the procedures that are used during the ADU block and the related
source block creation, for the FEC scheme considered.
</t>

	<section anchor="Requirements" title="Restrictions">
	<!-- ==================================== -->

<t>
This specification has the following restrictions:
<list style="symbols">
	<t> there MUST be exactly one source symbol per ADUI, and therefore per ADU;</t>
	<t> there MUST be exactly one repair symbol per FEC Repair Packet;</t>
	<t> there MUST be exactly one source block per ADU block;</t>
	<t> the use of the LDPC-Staircase scheme is such that there MUST be exactly one encoding symbol per group,
		i.e., G MUST be equal to 1 <xref target="RFC5170"/>;</t>
</list>
</t>
	</section>

	<section anchor="CommonProc_problem" title="ADU Block Creation">
	<!-- ==================================== -->

<t>
Several aspects must be considered, that impact the ADU block creation:
<list style="symbols">
<t> the maximum source block size (max_k parameter);</t>
<t> the potential real-time constraints, that impact the maximum ADU block size,
	since the larger the block size, the larger the decoding delay;</t>
</list>
We now detail each of these aspects.
</t>

<t>
The maximum source block length in symbols, max_k, depends on several parameters:
the code rate (CR), the Encoding Symbol ID (ESI) field length in the Explicit
Source/Repair FEC Payload ID (16 bits), as well as possible internal codec limitations.

More specifically, max_k cannot be larger than the following values, derived
from the ESI field size limitation, for a given code rate:
      <list style="empty">
        <t>max1_k = 2^^(16 - ceil(Log2(1/CR)))</t>
      </list> 
Some common max1_k values are:
<list style="symbols">
        <t>CR == 1 (no repair symbol): max1_k = 2^^16 = 65536 symbols</t>
        <t>1/2 &le; CR &lt; 1: max1_k = 2^^15 = 32,768 symbols</t>
        <t>1/4 &le; CR &lt; 1/2: max1_k = 2^^14 = 16,384 symbols</t>
</list>
</t>

<t>Additionally, a codec MAY impose other limitations on the maximum
block size, for instance, because of a limited working memory size.
This decision MUST be clarified at implementation time, when the target
use-case is known. This results in a max2_k limitation.</t>

<t> 
Then, max_k is given by: 
      <list style="empty">
        <t>max_k = min(max1_k, max2_k)</t>
      </list>
Note that this calculation is only required at the encoder (sender), since the
actual k parameter (k &le; max_k) is communicated to the decoder (receiver) through 
the Explicit Source/Repair FEC Payload ID.
</t>

<t>
The source ADU flows usually have real-time constraints. 
It means that the maximum number of ADUs of an ADU block must not exceed a certain
threshold since it directly impacts the decoding delay.
It is the role of the developer, who knows the flow real-time features, to define an
appropriate upper bound to the ADU block size, max_rt.
</t>

<t>
If we take into account these constraints, we find: max_B = min(max_k, max_rt).
Then max_B gives an upper bound to the number of ADUs that can constitute an ADU block.
</t>

	</section>


	<section anchor="CommonProc_src_block_creation"
		title="Source Block Creation">
	<!-- ==================================== -->


<t>
In its most general form the FECFRAME framework and the LDPC-Staircase FEC scheme
are meant to protect a set of independent flows.
Since the flows have no relationship to one another, the ADU size of each
flow can potentially vary significantly.
Even in the special case of a single flow, the ADU sizes can largely
vary (e.g., the various frames of a "Group of Pictures (GOP) of an H.264 flow).
This diversity must be addressed since the RS FEC scheme requires a constant
encoding symbol size (E parameter) per source block.
Since this specification requires that there is only one source symbol per ADU,
E must be large enough to contain all the ADUs of an ADU block along
with their prepended 3 bytes (see below).
</t>

<t>
In situations where E is determined per source block
(default, specified by the FCCI/FSSI with S = 0, <xref target="RSover2mArbitraryGE_fssi"/>),
E is equal to the size of the largest ADU of this source block plus three (for the
prepended 3 bytes, see below).
In this case, upon receiving the first FEC Repair Packet for this source block,
since this packet MUST contain a single repair symbol (<xref target="RSover2mArbitraryGE_repair_fpi"/>),
a receiver determines the E parameter used for this source block.
</t>

<t>
In situations where E is fixed 
(specified by the FCCI/FSSI with S = 1, <xref target="RSover2mArbitraryGE_fssi"/>),
then E must be greater or equal to the size of the largest ADU of this source block
plus three (for the prepended 3 bytes, see below).
If this is not the case, an error is returned.
How to handle this error is use-case specific (e.g., a larger E parameter may be 
communicated to the receivers in an updated FFCI message, using an appropriate
mechanism) and is not considered by this specification.
</t>

<t>
The ADU block is always encoded as a single source block.
There are a total of B &le; max_B ADUs in this ADU block.
For the ADU i, with 0 &le; i &le; B-1, 3 bytes are prepended
(<xref target="fig_src_block_creation_global_enc"/>):
<list style="symbols">
	<t>The first byte, FID[i] (Flow ID), contains the integer identifier
		associated to the source ADU flow to which this ADU
		belongs to.
		It is assumed that a single byte is sufficient, or said
		differently, that no more than 256 flows will be protected by
		a single instance of the FECFRAME framework.
	</t>
	<t>The following two bytes, L[i] (Length), contain the length of this
		ADU, in network byte order (i.e., big endian).
		This length is for the ADU itself and does not include the 
		FID[i], L[i], or Pad[i] fields.
	</t>
</list>
</t>

<t>
Then zero padding is added to ADU i (if needed) in field Pad[i], for alignment purposes
up to a size of exactly E bytes.
The data unit resulting from the ADU i and the F[i], L[i] and Pad[i] fields, is called
ADU Information (or ADUI).
Each ADUI contributes to exactly one source symbol to the source block.
</t>

<figure anchor="fig_src_block_creation_global_enc" title="Source block creation,
for code rate 1/2 (equal number of source and repair symbols, 4 in this example), and S = 0.">
  <artwork>
                     Encoding Symbol Length (E)
< -------------------------------------------------------------- >
+----+----+-----------------------+------------------------------+
|F[0]|L[0]|        ADU[0]         |            Pad[0]            |
+----+----+----------+------------+------------------------------+
|F[1]|L[1]| ADU[1]   |                         Pad[1]            |
+----+----+----------+-------------------------------------------+
|F[2]|L[2]|                    ADU[2]                            |
+----+----+------+-----------------------------------------------+
|F[3]|L[3]|ADU[3]|                             Pad[3]            |
+----+----+------+-----------------------------------------------+
\_______________________________  _______________________________/
                                \/
                       simple FEC encoding

+----------------------------------------------------------------+
|                            Repair 4                            |
+----------------------------------------------------------------+
.                                                                .
.                                                                .
+----------------------------------------------------------------+
|                            Repair 7                            |
+----------------------------------------------------------------+
  </artwork>
</figure>

<t>
Note that neither the initial 3 bytes nor the optional padding
are sent over the network.
However, they are considered during FEC encoding.
It means that a receiver who lost a certain FEC source packet (e.g., the
UDP datagram containing this FEC source packet) will be able to recover the ADUI
if FEC decoding succeeds.
Thanks to the initial 3 bytes, this receiver will get rid of the padding (if any)
and identify the corresponding ADU flow.
</t>

	</section>

</section>


<section anchor="RSover2mArbitraryGE" title="LDPC-Staircase FEC Scheme for Arbitrary ADU Flows">
<!-- ==================================== -->

	<section anchor="RSover2mArbitraryGE_formatsAndCodes" title="Formats and Codes">
	<!-- ==================================== -->

		<section title="FEC Framework Configuration Information">
		<!-- ================ -->
<t>
The FEC Framework Configuration Information (or FFCI) includes information
that MUST be communicated between the sender and receiver(s).
More specifically, it enables the synchronization of the FECFRAME sender
and receiver instances.
It includes both mandatory elements and scheme-specific elements,
as detailed below.
</t>
			<section title="Mandatory Information">
			<!-- ================ -->
<t>
<list style="hanging">
<t hangText="FEC Encoding ID:">
	the value assigned to this fully-specified FEC scheme MUST be XXX,
	as assigned by IANA (<xref target="iana-cons"/>).</t>
</list>
When SDP is used to communicate the FFCI, this FEC Encoding ID is carried in
the 'encoding-id' parameter.
</t>
			</section>

			<section title="FEC Scheme-Specific Information"
				 anchor="RSover2mArbitraryGE_fssi">
			<!-- ================ -->
<t>
The FEC Scheme Specific Information (FSSI) includes elements that are specific
to the present FEC scheme. More precisely:
<list style="hanging">
<t hangText="PRNG seed (seed):">
	a non-negative 32 bit integer used as the seed of the Pseudo Random Number
	Generator, as defined in <xref target="RFC5170"/>.</t>
<t hangText="Encoding symbol length (E):">
	a non-negative integer that indicates
	either the length of each encoding symbol in bytes (strict mode, i.e., if S = 1),
	or the maximum length of any encoding symbol (i.e., if S = 0).</t>
<t hangText="Strict (S) flag:">
	when set to 1 this flag indicates that the E parameter is valid for the whole session,
	unless otherwise notified.
	When set to 0 this flag indicates that the E parameter is only the maximum length of each
	encoding symbol, for the whole session, unless otherwise notified.</t>
<t hangText="N1 minus 3 (n1m3):">
	an integer between 0 (default) and 7, inclusive.
	The number of "1s" per column in the left side of the parity check matrix, N1, is then
	equal to N1m3 + 3, as specified in <xref target="RFC5170"/>.</t>
</list>
These elements are required both by the sender (LDPC-Staircase encoder) and the receiver(s) (LDPC-Staircase decoder).
</t>

<t>
When SDP is used to communicate the FFCI, this FEC scheme-specific information is carried in
the 'fssi' parameter in textual representation as specified in <xref target="SDP_ELEMENTS"/>.
For instance:
</t>
<t>
fssi = seed:1234,E:1400,S:0,n1m3:0
</t>

<t>
If another mechanism requires the FSSI to be carried as an opaque octet string
(for instance after a Base64 encoding), the encoding format consists of the following 7 octets:
<list style="symbols">
    <t> PRNG seed (seed): 32 bit field.</t>
    <t> Encoding symbol length (E): 16 bit field.</t>
    <t> Strict (S) flag: 1 bit field.</t>
    <t> N1m3 parameter (n1m3): 7 bit field.</t>
</list>
</t>
<figure anchor="fig_RSover2mArbitraryGE_fssi_binary" title="FSSI encoding format."> 
  <artwork>
 0                   1                   2       
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      PRNG seed (seed)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  |S|    n1m3     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

			</section>

		</section>


		<section title="Explicit Source FEC Payload ID"
			 anchor="RSover2mArbitraryGE_src_fpi">
		<!-- ================ -->

<t>
A FEC source packet MUST contain an Explicit Source FEC Payload ID that is appended to the
end of the packet as illustrated in <xref target="fig_src_pkt_format"/>.
</t>

<figure anchor="fig_src_pkt_format" title="Structure of a FEC Source Packet with the
Explicit Source FEC Payload ID."> 
  <artwork>
+--------------------------------+
|           IP Header            |
+--------------------------------+
|        Transport Header        |
+--------------------------------+
|              ADU               |
+--------------------------------+
| Explicit Source FEC Payload ID |
+--------------------------------+
  </artwork>
</figure>

<t>
More precisely, the Explicit Source FEC Payload ID is composed of the following fields
(<xref target="fig_src_fpi"/>):
<list style="hanging">
<t hangText="Source Block Number (SBN) (16 bit field):">
   this field identifies the source block to which this FEC source packet belongs.</t>
<t hangText="Encoding Symbol ID (ESI) (16 bit field):">
   this field identifies the source symbol contained in this FEC source packet.
   This value is such that 0 &le; ESI &le; k - 1 for source symbols.</t>
<t hangText="Source Block Length (k) (16 bit field):">
   this field provides the number of source symbols for this source block, i.e., the k parameter.</t>
</list>
</t>

<figure anchor="fig_src_fpi" title="Source FEC Payload ID encoding format."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Source Block Number (SBN)   |   Encoding Symbol ID (ESI)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Source Block Length (k)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

		</section>

		<section title="Repair FEC Payload ID" anchor="RSover2mArbitraryGE_repair_fpi">
		<!-- ================ -->

<t>
A FEC repair packet MUST contain a Repair FEC Payload ID that is prepended to the
repair symbol(s) as illustrated in <xref target="fig_repair_pkt_format"/>.
There MUST be a single repair symbol per FEC repair packet.
</t>

<figure anchor="fig_repair_pkt_format" title="Structure of a FEC Repair Packet with the
Repair FEC Payload ID."> 
  <artwork>
+--------------------------------+
|           IP Header            |
+--------------------------------+
|        Transport Header        |
+--------------------------------+
|      Repair FEC Payload ID     |
+--------------------------------+
|         Repair Symbol          |
+--------------------------------+
  </artwork>
</figure>

<t>
More precisely, the Repair FEC Payload ID is composed of the following fields:
(<xref target="fig_repair_fpi"/>):
<list style="hanging">
<t hangText="Source Block Number (SBN) (16 bit field):">
   this field identifies the source block to which the FEC repair packet belongs.</t>
<t hangText="Encoding Symbol ID (ESI) (16 bit field)">
   this field identifies the repair symbol contained in this FEC repair packet.
   This value is such that k &le; ESI &le; n - 1 for repair symbols.</t>
<t hangText="Source Block Length (k) (16 bit field):">
   this field provides the number of source symbols for this source block,
   i.e., the k parameter.</t>
<t hangText="Number of Encoding Symbols (n) (16 bit field):">
   this field provides the number of encoding symbols for this source block,
   i.e., the n parameter.</t>
</list>
</t>

<figure anchor="fig_repair_fpi" title="Repair FEC Payload ID encoding format."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Source Block Number (SBN)   |   Encoding Symbol ID (ESI)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Source Block Length (k)    |  Number Encoding Symbols (n)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

		</section>


	</section> <!-- RSover2mArbitraryGE_formatsAndCodes -->


	<section anchor="RSover2mArbitraryGE_Procedures" title="Procedures">
	<!-- ================ -->
<t>
The following procedures apply:
<list style="symbols">
	<t>
	The source block creation procedures are specified in
	<xref target="CommonProc_src_block_creation"/>.
	</t>
	<t>
	The SBN value is incremented for each new source block, starting at
	0 for the first block of the ADU flow. 
	Wrapping to zero will happen for long sessions, after value 2^^16 - 1.
	</t>
	<t>
	The ESI of encoding symbols is managed sequentially, starting at
	0 for the first symbol.
	The first k values (0 &le; ESI &le; k - 1) identify source symbols, whereas
	the last n-k values (k &le; ESI &le; n - 1) identify repair symbols.
	</t>
	<t>
	The FEC repair packet creation procedures are specified in
	<xref target="RSover2mArbitraryGE_repair_fpi"/>.
	</t>
</list>
</t>

	</section>


	<section anchor="RSover2mArbitraryGE_FECCodeSpecification" title="FEC Code Specification">
	<!-- ================ -->
<t>
The present document inherits from <xref target="RFC5170"/> the specification of the
core LDPC-Staircase codes for a packet erasure transmission channel.
</t>
<t>
Because of the requirement to have exactly one encoding symbol per group,
i.e., because G MUST be equal to 1 (<xref target="Requirements"/>),
several parts of <xref target="RFC5170"/> are useless.
In particular, this is the case of Section 5.6. "Identifying the G Symbols of an Encoding Symbol Group". 
</t>
	</section>

</section> <!-- RSover2mArbitraryGE -->


<section anchor="SecurityConsiderations" title="Security Considerations">
<!-- ==================================== -->


  <section title="Problem Statement">
  <!-- ================ -->

<t>
A content delivery system is potentially subject to many attacks.
Some of them target the network (e.g., to compromise the routing infrastructure,
by compromising the congestion control component), others target
the Content Delivery Protocol (CDP) (e.g., to compromise its normal behavior),
and finally some attacks target the content itself.
Since this document focuses on various FEC schemes, this
section only discusses the additional threats that their use within the
FECFRAME framework can create to an arbitrary CDP.
</t>

<t>
More specifically, these attacks may have several goals:
<list style="symbols">
	<t> those that are meant to give access to a confidential content (e.g., in
	  case of a non-free content),</t>
	<t> those that try to corrupt the ADU Flows being transmitted (e.g., to
	  prevent a receiver from using it),</t>
	<t> and those that try to compromise the receiver's behavior (e.g., by
	  making the decoding of an object computationally expensive).</t>
</list>
These attacks can be launched either against the data flow itself (e.g.,
by sending forged FEC Source/Repair Packets) or against the FEC parameters that are
sent either in-band (e.g., in the Repair FEC Payload ID) or out-of-band (e.g., in
a session description).
</t>

  </section>

  <section title="Attacks Against the Data Flow">
  <!-- ================ -->

<t>
First of all, let us consider the attacks against the data flow.
</t>


	<section title="Access to Confidential Contents">
	<!-- ================ -->

<t>
Access control to the ADU Flow being transmitted is typically provided by means
of encryption.
This encryption can be done within the content provider itself, by the
application (for instance by using the Secure Real-time Transport Protocol (SRTP)
<xref target="RFC3711"/>), or at the Network Layer, on a packet per packet basis
when IPSec/ESP is used <xref target="RFC4303"/>.
If confidentiality is a concern, it is RECOMMENDED that one of these solutions be used.
Even if we mention these attacks here, they are not related nor facilitated by
the use of FEC.
</t>

	</section>

	<section anchor="ContentCorruption" title="Content Corruption">
	<!-- ================ -->

<t>
Protection against corruptions (e.g., after sending forged FEC Source/Repair Packets)
is achieved by means of a content integrity verification/sender authentication scheme.
This service is usually provided at the packet level. In this case, after 
removing all forged packets, the ADU Flow may be sometimes recovered.
Several techniques can provide this source authentication/content integrity
service:
<list style="symbols">
<!--
<t> at the packet level, each packet can be digitally signed. A major limitation is
  the high computational and transmission overheads that this solution requires (unless
  perhaps if Elliptic Curve Cryptography (ECC) is used).
  To avoid this problem, the signature may span a set of symbols (instead of a
  single one) in order to amortize the signature calculation.
  But if a single symbol is missing, the integrity of the whole set cannot be checked;</t>

<t> at the packet level, a Group Message Authentication Code (MAC) <xref target="RFC2104"/>
  scheme can be used, for instance by using HMAC-SHA-1 with a secret key shared by all
  the group members, senders and receivers.
  This technique creates a cryptographically secured (thanks to the secret key)
  digest of a packet that is sent along with the packet.
  The Group MAC scheme  does not create prohibitive processing load nor transmission
  overhead, but it has a major limitation: it only provides a group authentication/integrity
  service since all group members share the same secret group key, which means that each
  member can send a forged packet. It is therefore restricted to situations where
  group members are fully trusted (or in association with another technique as a
  pre-check);</t>

<t> at the packet level, Timed Efficient Stream Loss-Tolerant Authentication (TESLA)
  <xref target="RFC4082"/> is an attractive solution that is robust to losses, provides
  a true authentication/integrity service, and does not create any prohibitive processing
  load or transmission overhead.
  Yet, checking a packet requires a small delay (a second or more) after its reception.
  For instance, <xref target="RFC4383"/> details the use of TESLA within SRTP.XXXXXXXX</t>

-->
<t>	at the application level, the Secure Real-time Transport Protocol (SRTP)
	<xref target="RFC3711"/> provides several solutions to authenticate the source and
	check the integrity of RTP and RTCP messages, among other services.
	For instance, associated to the Timed Efficient Stream Loss-Tolerant Authentication (TESLA)
	<xref target="RFC4383"/>, SRTP is an attractive solution that is robust to losses, provides
	a true authentication/integrity service, and does not create any prohibitive processing
	load or transmission overhead.
	Yet, checking a packet requires a small delay (a second or more) after its reception with
	TESLA.
	Other building blocks can be used within SRTP to provide authentication/content
	integrity services.
</t>
<t>	at the Network Layer, IPSec/ESP offers (among other services) an integrity verification mechanism that
	can be used to provide authentication/content integrity services.
</t>
</list>
</t>

<t>
It is up to the developer and the person in charge of deployment, who know the security
requirements and features of the target application area, to define which solution is
the most appropriate.
Nonetheless it is RECOMMENDED that at least one of these techniques be used.
</t>
	</section>

  </section>

  <section title="Attacks Against the FEC Parameters">
  <!-- ================ -->

<t>
Let us now consider attacks against the FEC parameters included in the FFCI that
are usually sent out-of-band (e.g., in a session description).
Attacks on these FEC parameters can prevent the decoding of the associated object.
For instance modifying the PRNG seed or N1m3 fields will lead a receiver to consider a different
parity check matrix, i.e., a different code.
Modifying the E parameter will lead a receiver to consider bad Repair Symbols for
a received FEC Repair Packet.
</t>

<t>
It is therefore RECOMMENDED that security measures be taken to guarantee the
FFCI integrity.
When the FFCI is sent out-of-band in a session description,
this latter SHOULD be protected, for instance by digitally signing it.
</t>

<t>
Attacks are also possible against some FEC parameters included in the
Explicit Source FEC Payload ID and Repair FEC Payload ID.
For instance modifying the Source Block Number of a FEC Source of Repair	 		
Packet will lead a receiver to assign this packet to a wrong block.	 		
</t>

<t>
It is therefore RECOMMENDED that security measures be taken to
guarantee the Explicit Source FEC Payload ID and Repair FEC Payload	 		
ID integrity.
To that purpose, one of the packet-level source authentication/content integrity
techniques of <xref target="ContentCorruption"/> can be used.
</t>

  </section>
</section>


<section anchor="iana-cons" title="IANA Considerations">
<!-- =============================================== -->
<t>
The FEC Encoding ID value is subject to IANA registration.
</t>
<t>
TBD
</t>
</section>


<section anchor="Acknowledgments" title="Acknowledgments">
<!-- =============================================== -->
<t>
TBD
</t>

</section>

	</middle>

	<back>

		<references title="Normative References">
		<!-- ==================================== -->
			<reference anchor="RFC2119">
				<front>
					<title>Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials="S." surname="Bradner" fullname="Scott Bradner">
						<organization/>
					</author>
					<date year=""/>
				</front>
				<seriesInfo name="RFC" value="2119"/>
			</reference>

			<reference anchor="RFC5170">
				<front>
					<title>Low Density Parity Check (LDPC) Forward Error Correction</title>
					<author initials="V." surname="Roca"> <organization/> </author>
					<author initials="C." surname="Neumann"> <organization /> </author>
					<author initials="D." surname="Furodet"> <organization /> </author>
					<date month="June" year="2008"/>
				</front>
				<seriesInfo name="RFC" value="5170"/>
			</reference>

			<reference anchor="FECFRAME-FRAMEWORK">
				<front>
				<title>Forward Error Correction (FEC) Framework</title>
					<author initials="M." surname="Watson" fullname="Mark Watson"> <organization/> </author>
					<date month="September" year="2010" />
				</front>
				<seriesInfo name="draft-ietf-fecframe-framework-10" value="(Work in Progress)" />
			</reference>

			<reference anchor="SDP_ELEMENTS">
				<front>
				<title>SDP Elements for FEC Framework</title>
					<author initials="A." surname="Begen" fullname="Ali Begen"> <organization/> </author>
					<date month="October" year="2010" />
				</front>
				<seriesInfo name="draft-ietf-fecframe-sdp-elements-10" value="(Work in Progress)" />
			</reference>

		</references>

		<references title="Informative References">
		<!-- ==================================== -->

			<reference anchor="RFC3453">
				<front>
					<title>The Use of Forward Error Correction (FEC) in Reliable Multicast</title>
					<author initials="M." surname="Luby" fullname="M. Luby"> <organization/> </author>
					<author initials="L." surname="Vicisano" fullname="L. Vicisano"> <organization/> </author>
						<author initials="J." surname="Gemmell" fullname="J. Gemmell"> <organization/> </author>
						<author initials="L." surname="Rizzo" fullname="L. Rizzo"> <organization/> </author>
						<author initials="M." surname="Handley" fullname="M. Handley"> <organization/> </author>
						<author initials="J." surname="Crowcroft" fullname="J. Crowcroft"> <organization/> </author>
					<date month="December" year="2002"/>
				</front>
				<seriesInfo name="RFC" value="3453"/>
			</reference>

			<reference anchor="RFC5052">
				<front>
					<title>Forward Error Correction (FEC) Building Block</title>
					<author initials="M." surname="Watson"> <organization/> </author>
					<author initials='M.' surname='Luby'> <organization /> </author>
					<author initials='L.' surname='Vicisano'> <organization /> </author>
					<date month="August" year="2007"/>
				</front>
				<seriesInfo name="RFC" value="5052"/>
			</reference>

			<reference anchor="RFC5510">
				<front>
				<title>Reed-Solomon Forward Error Correction (FEC) Schemes</title>
					<author initials="J." surname="Lacan" fullname="Jerome Lacan">
						<organization></organization> </author>
					<author initials="V." surname="Roca" fullname="Vincent Roca">
						<organization></organization> </author>
					<author initials="J." surname="Peltotalo" fullname="Jani Peltotalo">
						<organization></organization> </author>
					<author initials="S." surname="Peltotalo" fullname="Sami Peltotalo">
						<organization></organization> </author>
					<date month="April" year="2009" />
				</front>
				<seriesInfo name="RFC" value="5510" />
			</reference>

			<reference anchor="RFC5053">
				<front>
					<title>Raptor Forward Error Correction Scheme</title>
					<author initials="M." surname="Luby" fullname="M. Luby"> <organization/> </author>
					<author initials="A" surname="Shokrollahi" fullname="A. Shokrollahi"> <organization/> </author>
					<author initials="M" surname="Watson" fullname="M.  Watson"> <organization/> </author>
					<author initials="T" surname="Stockhammer" fullname="T. Stockhammer"> <organization/> </author>
					<date month="June" year="2007"/>
				</front>
				<seriesInfo name="RFC" value="5053"/>
			</reference>

			<?rfc include='reference.RFC.5740'?> 	<!-- NORM -->

			<?rfc include='reference.RFC.5775'?> 	<!-- ALC -->

			<reference anchor="SPSC08">
				<front>
					<title>Optimizing the Error Recovery Capabilities of LDPC-staircase Codes
					Featuring a Gaussian Elimination Decoding Scheme</title>
					<author initials="M." surname="Cunche"><organization /></author>
					<author initials="V." surname="Roca"><organization /></author>
					<date month="October" year="2008" />
				</front>
				<seriesInfo name="" value="10th IEEE International Workshop on Signal Processing for Space Communications (SPSC’08)"/>
			</reference>

			<reference anchor="CunchePHD10">
				<front>
					<title>High performances AL-FEC codes for the erasure channel : variation around LDPC codes</title>
					<author initials="M." surname="Cunche"><organization /></author>
					<date month="June" year="2010" />
				</front>

				<seriesInfo name="PhD dissertation (in French)" value="(http://tel.archives-ouvertes.fr/tel-00451336/en/)"/>
			</reference>

			<reference anchor="LCN10">
				<front>
					<title>Performance Analysis of a High-Performance Real-Time Application with Several AL-FEC Schemes</title>
					<author initials="K." surname="Matsuzono"><organization /></author>
					<author initials="J." surname="Detchart"><organization /></author>
					<author initials="M." surname="Cunche"><organization /></author>
					<author initials="V." surname="Roca"><organization /></author>
					<author initials="H." surname="Asaeda"><organization /></author>
					<date month="October" year="2010" />
				</front>
				<seriesInfo name="" value="35th Annual IEEE Conference on Local Computer Networks 2010 (LCN 2010)"/>
			</reference>

			<reference anchor="LDPC-codec" target="http://planete-bcast.inrialpes.fr/">
				<front>
					<title>LDPC-Staircase/LDPC-Triangle Codec Reference Implementation</title>
					<author initials="M." surname="Cunche"> <organization /></author>
					<author initials="V." surname="Roca"> <organization /></author>
					<author initials="C." surname="Neumann"> <organization /></author>
					<author initials="J." surname="Laboure"> <organization /></author>
					<date month="" year="" />
				</front>
				<seriesInfo name="INRIA" value="Rhone-Alpes and STMicroelectronics" />
			</reference>

			<!-- =================================================== -->

<!--
			<reference anchor="RFC3447">
				<front>
					<title>Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</title>
					<author initials="J." surname="Jonsson" fullname="J. Jonsson"> <organization/> </author>
					<author initials="B." surname="Kaliski" fullname="B. Kaliski"> <organization/> </author>
					<date year="2003" month="February"/>
				</front>
				<seriesInfo name="RFC" value="3447"/>
				<format type="TXT" octets="143173" target="ftp://ftp.isi.edu/in-notes/rfc3447.txt"/>
			</reference>
-->

			<reference anchor="RFC4303">
				<front>
					<title>IP Encapsulating Security Payload (ESP)</title>
					<author initials="S." surname="Kent" fullname="S. Kent"> <organization/> </author>
					<date year="2005" month="December"/>
				</front>
				<seriesInfo name="RFC" value="4303"/>
				<format type="TXT" octets="114315" target="ftp://ftp.isi.edu/in-notes/rfc4303.txt"/>
			</reference>

<!--
			<reference anchor="RFC2104">
				<front>
					<title>HMAC: Keyed-Hashing for Message Authentication</title>
					<author fullname="H. Krawczyk"> <organization/> </author>
					<author fullname="M. Bellare"> <organization/> </author>
					<author fullname="R. Canetti"> <organization/> </author>
					<date month="February" year="1997"/>
				</front>
				<seriesInfo name="RFC" value="2104"/>
			</reference>
-->

			<reference anchor='RFC3711'>
				<front>
					<title>The Secure Real-time Transport Protocol (SRTP)</title>
					<author initials='M.' surname='Baugher' fullname='M. Baugher'><organization /></author>
					<author initials='D.' surname='McGrew' fullname='D. McGrew'><organization /></author>
					<author initials='M.' surname='Naslund' fullname='M. Naslund'><organization /></author>
					<author initials='E.' surname='Carrara' fullname='E. Carrara'><organization /></author>
					<author initials='K.' surname='Norrman' fullname='K. Norrman'><organization /></author>
					<date year='2004' month='March' />
				</front>
				<seriesInfo name='RFC' value='3711' />
				<format type='TXT' octets='134270' target='ftp://ftp.isi.edu/in-notes/rfc3711.txt' />
			</reference>


<!--
			<reference anchor="RFC4082">
				<front>
					<title>Timed Efficient Stream Loss-Tolerant Authentication (TESLA):
						Multicast Source Authentication Transform Introduction</title>
					<author fullname="A. Perrig"> <organization/> </author>
					<author fullname="D. Song"> <organization/> </author>
					<author fullname="R. Canetti"> <organization/> </author>
					<author fullname="J.D. Tygar"> <organization/> </author>
					<author fullname="B. Briscoe"> <organization/> </author>
					<date month="June" year="2005"/>
				</front>
				<seriesInfo name="RFC" value="4082"/>
			</reference>
-->

			<reference anchor="RFC4383">
				<front>
					<title>
					The Use of Timed Efficient Stream Loss-Tolerant Authentication (TESLA) in the Secure Real-time Transport Protocol (SRTP)
					</title>
					<author initials="M." surname="Baugher" fullname="M. Baugher"><organization/></author>
					<author initials="E." surname="Carrara" fullname="E. Carrara"><organization/></author>
					<date year="2006" month="February"/>
				</front>
				<seriesInfo name="RFC" value="4383"/>
				<format type="TXT" octets="41766" target="ftp://ftp.isi.edu/in-notes/rfc4383.txt"/>
			</reference>


<!--
			<reference anchor="RFC3275">
				<front>
					<title>(Extensible Markup Language) XML-Signature Syntax and Processing</title>
					<author initials="D." surname="Eastlake" fullname="D. Eastlake"> <organization/>
					</author>
					<author initials="J." surname="Reagle" fullname="J. Reagle"> <organization/>
					</author>
					<author initials="D." surname="Solo" fullname="D. Solo"> <organization/>
					</author>
					<date year="2002" month="March"/>
				</front>
				<seriesInfo name="RFC" value="3275"/>
				<format type="TXT" octets="164198" target="ftp://ftp.isi.edu/in-notes/rfc3275.txt"/>
			</reference>
-->

		</references>
	</back>
</rfc>
