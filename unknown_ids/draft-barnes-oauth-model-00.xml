<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="no"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-barnes-oauth-model-00" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="OAuth Model">The OAuth Security Model for Delegated Authorization</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Richard Barnes" initials="R.L." surname="Barnes">
      <organization>BBN Technologies</organization>
      <address>
        <postal>
          <street>9861 Broken Land Parkway</street>
          <city>Columbia</city>
          <region>MD</region>
          <code>21046</code>
          <country>US</country>
        </postal>
        <phone>+1 410 290 6169</phone>
        <email>rbarnes@bbn.com</email>
      </address>
    </author>

    <author fullname="Matthew Lepinski" initials="M.B." surname="Lepinski">
      <organization>BBN Technologies</organization>
      <address>
        <postal>
          <street>10 Moulton St</street>
          <city>Cambridge</city>
          <region>MA</region>
          <code>02138</code>
          <country>US</country>
        </postal>
        <phone>+1 617 873 5939</phone>
        <email>mlepinski@bbn.com</email>
      </address>
    </author>

    <date month="July" year="2009" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>RAI</area>

    <workgroup>OAuth</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>oauth, authorization, www</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>This document describes the security model for the OAuth authorization system, which allows a party that holds some authorization to delegate a subset of that authorization to another party, without requiring either party to disclose its credentials to the other.  In this document, we describe a set of design constraints, a high-level work flow for establishing authorizations subject to those constraints, and set of security requirements for protocols that implement this model.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro-sec" title="Introduction">

      <t>It is an almost universal situation in the Internet today that users make use of many Internet applications, some of which store data for the user and some of which consume user data.  There is increasing interest in bringing these two types of application together, i.e., in allowing certain applications that consume user data to access data that is stored by other applications.</t>
      
      <t>However, in order to maintain the security of user data, applications that store data typically require an entity requesting private resources to authenticate that they own those resources (i.e., to authenticate as the owner of the resources).  Enabling a second application to access private resources would thus require the user who ones the resources to enable that application to authenticate as the user.  This situation is clearly undesirable, since it allows the consuming application to impersonate the user: To access any and all data the user owns, or to take actions as the user.</t>
      
      <t>This situation has created a need for a mechanism for delegating authorization.  In such a system, the owner of a set of resources can delegate access to some of those resources to a designated client application, without enabling the client application to impersonate the user.</t>  
      
      <t>There are two basic prerequisites of such a delegation mechanism: First, applications that store user data must have separate notions of ownership and access permissions; this, of course, is not subject to standardization.  Second, there must be a way for client applications to request access, and for users to instruct servers to grant such access.  This second aspect is the subject of this document.</t>
      
      <t>This document describes a security model for the OAuth delegated authorization system.  In particular, we provide an abstract message flow that defines how parameters are exchanged between OAuth entities, and what the security requirements are for these exchanges.  The definition of protocol mechanisms for conveying parameters in compliance with these requirements is left to future documents.</t>

      <t>[[ Editor's note: This document is essentially an abstraction and security analysis of the OAuth Core protocol, defined in <xref target="I-D.hammer-oauth"></xref>.  While the current OAuth protocol should map more or less directly to this model, there may be slight difference, e.g., in where authentication is required. ]]</t>

    </section>

    <section anchor="def-sec" title="Definitions">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>
 
      <t>The focus of this document is the secure delegation of access to resources.  In this document, we use the term "resources" broadly, to include actual data (e.g., files, streams) as well as permissions to take particular actions.</t>
      
      <t>There are three roles involved in the OAuth process.  These roles are not mutually exclusive; a single party may act in more than one role.
        <list style="hanging">
          <t hangText="Resource Owner (RO): ">The entity that has authorization at the beginning of the OAuth process, who delegates authorization to the Client </t>
          <t hangText="Client: ">The entity to which authorization is delegated by the Resource Owner</t>
          <t hangText="Server: ">The entity that enforces the authorizations in question (e.g., the server that stores a protected resource)</t>
        </list>
      </t>
      
      <t>An OAuth Server issues three types of opaque tokens in the course of the authorization process.  These values are random values that are unique within a defined scope. 
        <list style="hanging">
          <t hangText="Request token: ">A request token is associated with a Client and Server, and is valid for a single transaction.</t>
          <t hangText="Verification token: ">A verification token is associated with a Client, a Server, a Resource Owner, and a set of resources</t>
          <t hangText="Access token: ">An access token is associated with a current authorization, i.e., a Server, a Client, and a set of resources to which that Client has access.</t>
        </list>
        Many of the security properties of the OAuth process require protocol participants to associate, or "bind", certain other data to tokens, then subsequently verify these associations/bindings.  In the below, when an entity is required to use the value "bound to a token" or "associated with a token", it is implied that the value in question is the one associated by the entity at hand.
      </t>
    </section>
    
    <section anchor="req-sec" title="Requirements and design goals">
      <t>The fundamental goal of the OAuth model is to allow the Resource Owner to grant the Client authorization to access selected resources on the Server, while maintaining strict authentication and access control.  The requirement for strict authentication means that no party should be able to authenticate as any other, whether a protocol participant (e.g., the Client authenticating as the RO) or a third party.  The requirement for access control means that the delegation process should not grant the Client (or any other party) access to anything other than the resources designated for access by the Resource Owner.</t>
      <t>The OAuth model must also ensure that the authorization process is followed: In order for an authorization to be delegated by a Resource Owner to a Client, it must be requested by the Client and authorized by the Resource Owner.  In particular, the RO cannot unilaterally grant authorization to a Client without a request (since the Client may not be able to use that authorization), and of course, no authorization can be granted without the approval of the RO.  In addition, the security model should prevent the Client from further delegating access without going through the same OAuth process.</t>
     <t>It should be clear that these requirements already rule out the simplest models for delegating authorization.  For example, a model in which the RO simply provides its authentication credentials to the Client is unacceptable for several reasons: It allows the Client to access all resources (not only any selected subset), and it requires the Client to authenticate as the RO. </t>
     <t>Note also that this document defines only the security model for OAuth, i.e., how security-relevant data flow through the system, and what the security requirements are for these flows.  In particular, this document does not define protocol mechanisms for carrying data (e.g., tokens) or providing security features (e.g., authentication, confidentiality).  Such mechanisms should be defined in protocol-specific documents (e.g., a realization of OAuth in HTTP or XMPP).</t>

      <section anchor="trust-sec" title="Trust assumptions">
        <t>In the OAuth architecture, the Server is a trusted entity, in the sense of RFC 4949 <xref target="RFC4949"></xref>: Since the Server is clearly capable of providing anyone access to the protected resources, no further analysis of the risks it presents is necessary; we assume it behaves as specified.</t>  
	<t>The Resource Owner for a set of protected resources is also trusted in the sense that it can authorize any request from a Consumer; we assume that genuine ROs will only tell the server to authorize requests from Clients that it genuinely intends to authorize.  We do not assume that any entity acting as an RO is the genuine RO for the protected resources.  This assurance will need to be provided by the authorization system.</t>  
	<t>All parties are assumed to maintain the security of their private authentication keys (the long-lived credentials that enable to authenticate to other protocol entities).  Beyond that minimal assumption, we make no security assumptions about the behavior of the Client.</t>
      </section>

      <section anchor="threat-sec" title="Threat model">
        <t>The authorization system here is designed to protect against four classes of threats:
	  <list style="numbers">
	    <t>Outside intervention in an otherwise honest transaction</t>
	    <t>Malicious actors within the authorization process</t>
	    <t>Collusion among actors within the authorization process</t>
	    <t>Denial of service against the authorization process</t>
	  </list>
	</t>
	<t>The basic goal of the authorization system is to allow an honest Client, Server, and RO to delegate authorization even in the presence of external bad actors.  This goal is mainly accomplished by requiring authentication at critical points of the protocol to assure that the parties are always talking among themselves, and not to some outside actor.</t>
	<t>OAuth is also intended to prevent the abuse of the authorization process by legitimate participants in it, especially Clients.  This goal is addressed by a set of mechanisms that allow the Server and the Resource Owner to validate that the authorization process is conducted faithfully.</t>
	<t>A more advanced class of attack is when two or more participants collude in order to gain false access.  The primary example of this sort of attack is when two Clients collude so that the one more trusted by the RO can obtain access on behalf of the other.  This class of attack is addressed by assuring that the Client is consistently identified throughout the OAuth process.</t>
	<t>Finally, there are several points in the OAuth process where the injection of false information would cause the process to fail, even in the absence of other problems.  This threat can be minimized by ensuring that only authentic protocol participants can contribute information to the process.</t>
      </section>

    </section>
    
    <section anchor="authz-flow-sec" title="Authorization flow">
      <t>The OAuth authorization process is the process by which a Resource Owner can grant a Client permission to access resources protected by a Server.  This process occurs in four high-level steps, illustrated in <xref target="proc-flow-fig"></xref>: 
        <list style="numbers">
          <t>The Client obtains a Request Token from the Server</t>
          <t>The Client requests authorization from the Resource Owner</t>
          <t>The Resource Owner validates the request and grants authorization</t> 
          <t>The Client exchanges the Request Token for an Access Token</t>
        </list>
      If the process fails at any point, no authorization is granted.
      </t>
      
      <figure anchor="proc-flow-fig" title="High-level OAuth process flow">
        <artwork><![CDATA[
   Client                   Server               Resource Owner
     |                        |                        |
     |    Issue Req. Token    |                        |
     |<---------------------->|                        |
     |                        |                        |
     |                        | Request authorization  |
     |------------------------------------------------>|
     |                        |                        |
     |                        |    Issue Ver. Token    |
     |                        |<---------------------->|
     |                        |                        |
     |   Grant authorization  |                        |
     |<------------------------------------------------|
     |                        |                        |
     |    Issue Acc. Token    |                        |
     |<---------------------->|                        |
     |                        |                        |
     ~                        ~                        ~
     |    Access Resources    |                        |
     |<---------------------->|                        |
     |                        |                        |
]]>
        </artwork>
      </figure>
      
      <section anchor="req-assm-sec" title="General Requirements and Assumptions">
        <t>There are a number of authentication relationships that need to be in place before OAuth can be used to delegate authorization.  Client authentication is critical for preventing unauthorized parties from gaining access: The Client MUST be able to authenticate to both the Server and the Resource Owner.  Moreover, the Client MUST be able to authenticate the same identifier to both parties (e.g., using the same certificate in the context of HTTPS), so that the Server and the Resource Owner can verify that the Client that the RO authorizes is the same one that the Server will enable to access the protected resources.</t>
        
	<t>Likewise the Resource Owner MUST be able to authenticate both to Server and to the Client, and it MUST be able to authenticate the same identifier to both (it may have other identifiers with each).  The Server MUST be able to authenticate both to the Client and the RO, but may use different identities for each.</t>

	<t>[[ Editor's note: The requirements that the Client and RO use the same identifiers across multiple relationships can be onerous, but is required to combat the Client and RO collusion attacks discussed in <xref target="col-act-sec"></xref>, as are the identity checks by the RO and the Client that take advantage of these identifiers (in <xref target="not-authz-sec"></xref> and <xref target="acc-t-iss-sec"></xref>).  If WG discussions indicate that either or both of these attacks are not to be addressed by this model, then the identity requirements and the corresponding checks can be removed; for now, they are listed as MUST-level requirements. ]]</t>

        <t>All messages in this process SHOULD be integrity- and confidentiality-protected; ones that MUST be so protected are noted below.  The security of the authorization process relies only on the authentication relationships above, but access to some parameters passed between OAuth entities could allow third parties to disrupt the OAuth process.</t>
      </section>
      <section anchor="req-t-iss-sec" title="Request token issuance"> 
      <figure>
        <artwork><![CDATA[
   Client                   Server               Resource Owner
     |                        |                        |
     |   req-token-request    |                        |
1.   |----------------------->|                        |
     |                        |                        |
     |   req-token-issue      |                        |
     |       (req-t)          |                        |
2.   |<-----------------------|                        |
     |                        |                        |
]]>
        </artwork>
      </figure>

        <t>The OAUth process is initiated by a Client that wishes to access a given set of resources on the Server.  The authorization flow begins when the Client sends a request for a Request Token to the Server.  In response to this request, the Server MUST authenticate the Client.  If authentication is unsuccessful, the process fails.  If authentication succeeds, the Server MUST generate a random request token and store a binding between the request token and authenticated identity of the Client (denoted Cl-ID below).  During this transaction, the Client and the Server MAY negotiate the resources to which access is to be granted.</t>
	<t>Upon receiving a request token from the Server, the Client MUST authenticate the Server and store a binding between the Server's authenticated identity and the request token.</t>
        <t>The Request Token identifies a Client's request for authorization to access resources on the Server.  At issuance, the token is bound to a Client identity and a Server identity.  To uniquely identify an authorization transaction, the Server MUST ensure that each Request Token is unique within the set of such tokens that it issues.  Token values SHOULD be difficult for an outside entity to guess.  In order to avoid resource exhaustion at the Server, it is RECOMMENDED that Request Tokens have a limited lifetime.</t>
      </section>
      <section anchor="authz-req-sec" title="Authorization of the request">
        <t>Before the Client can access protected resources, it must be authorized to access those resources: The Client must request authorization, the Resource Owner must notify the Server that it intends to grant access, and then the Resource Owner must actually grant access to the Client.  In addition, before the Resource Owner grants access, it must assure that the Client's request is authentic by validating it with the Server.</t>
        <section anchor="req-authz-sec" title="Request for authorization">
          <figure>
            <artwork><![CDATA[
   Client                   Server               Resource Owner
     |                        |                        |
     |                        |     request-authz      |
     |                        |        (req-t)         |
3.   |------------------------------------------------>|
     |                        |                        |
]]>
            </artwork>
          </figure>
	  <t>The Client requests authorization to access resources by sending a message to the Resource Owner that contains an unused request token.  After sending a request token in an authorization request, the Client MUST mark that request token as used, and MUST NOT use the request token in any subsequent authorization request.</t> 
	  <t>If the Client wishes to verify that the RO that it interacts with on this step is the same entity that it interacts with later, then it MUST authenticate the RO and store a binding between the request token and the RO's authenticated identity (in addition to the binding to the Server's identity recorded earlier).  It should be noted however, that these steps are purely optional.  They provide no additional security guarantees with respect to the authorizations granted; they only allow the Client to track which request tokens have been used. (In the presence of session continuity mechanisms, such as HTTP cookies, this authentication may be used as the basis for the authentication required at the time of notification of authorization, described in <xref target="not-authz-sec"></xref>.)</t>
	  <t>Note that this transaction does not require the RO to authenticate the Client.  The Client will be authenticated in a later step, after the RO is told by the Server which Client identity is bound to the request token.</t>
        </section>
        <section anchor="ver-t-iss-sec" title="Verification token issuance">
          <figure>
            <artwork><![CDATA[
   Client                   Server               Resource Owner
     |                        |                        |
     |                        |   ver-token-request    |
     |                        |        (req-t)         |
4.   |                        |<-----------------------|
     |                        |                        |
     |                        |    ver-token-issue     |
     |                        |  (ver-t,cl-id,scope)   |
5.   |                        |----------------------->|
     |                        |                        |
]]>
            </artwork>
          </figure>
          <t>The Resource Owner validates the request for authorization and obtains the ability to grant authorization by requesting a verification token from the Server.  This request MUST include the request token provided by the Client.  Before sending this request, the RO SHOULD authenticate the Server, since a false Server can disrupt the authorization process (but not cause unintended authorization to be granted).</t>
	  <t>When the Server receives a request for a verification token, it MUST take the following actions, in order:
	    <list style="numbers">
	      <t>Authenticate the Resource Owner and verify that the RO owns the resources subject to authorization</t>
	      <t>Verify that the request token has not been used in a prior request.  If so, the process fails; if not, the request token is marked as used.</t>
	      <t>Generate a random verification token that is unique in the scope of such tokens</t>
	      <t>Store a binding between the verification token, the Client identity bound to the request token, and the RO's authenticated identity</t>
	      <t>Establish an integrity- and confidentiality-protected channel to the RO</t>
	      <t>Send a message to the RO containing the following information:
	        <list style="symbols">
		  <t>The verification token</t>
		  <t>The Client identity bound to the request token</t>
		  <t>The scope of the authorization to be provided (i.e., the set of resources)</t>
		</list>
	      </t>
	    </list>
	    The Server and the RO MAY also perform further negotiation of the scope of the authorization at this point.
	  </t>
	  <t>It should be emphasized that the Server MUST NOT transmit the verification token over any channel that is not authenticated, integrity-protected, and confidentiality-protected, since the verification token is highly sensitive information: Any third party that intercepts the verification token is capable of granting the Client access to the protected resources, and any party that can inject or modify a verification token can cause the RO to grant unintended accesses.</t>
	  <t>Upon receiving the Server's message (authenticating the Server again, if necessary), the RO stores a binding between the verification token and the Client identity provided by the Server.</t>
	  <t>Note that at this point in the process, no authorization has been granted.  The Server has only issued the Resource Owner a verification token so that the RO can grant authorization if desired.  The Server MUST NOT provide the Client access to protected resources until the RO has provided the verification token to the Client, and Client has exchanged the verification token for an access token, as described below.</t>
        </section>
        <section anchor="not-authz-sec" title="Notification of authorization">
          <figure>
            <artwork><![CDATA[
   Client                   Server               Resource Owner
     |                        |                        |
     |    authz-notify        |                        |
     |    (ver-t,req-t)       |                        |
6.   |<------------------------------------------------|
     |                        |                        |
]]>
            </artwork>
          </figure>
          <t>If the Resource Owner decides to authorize the Client to access protected resources (the set bound to the verification token), then it signals this by sending a message to the Client containing the verification token.  Before sending such a message, the RO MUST authenticate the Client and establish an integrity- and confidentiality-protected (i.e., encrypted) channel to the authenticated Client.  If the authenticated identity of the Client does not match the Client identity bound to the verification token, or if the authentication fails, then the process fails and the RO MUST NOT send the verification token to the Client.  As above, the RO MUST NOT transmit the verification token over any channel that is not authenticated, integrity-protected, and confidentiality-protected.</t>
	  <t>Upon receipt of an authorization notification message, the Client MUST authenticate the RO and store a binding between the RO's authenticated identity and the verification token.  The Client MUST also store a binding between the verification token and the Server identity bound to the request token.   The Client MAY verify that the RO's authenticated identity matches the one bound earlier to the request token.</t>
        </section>
      </section>
      <section anchor="acc-t-iss-sec" title="Access token issuance">
        <figure>
          <artwork><![CDATA[
   Client                   Server               Resource Owner
     |                        |                        |
     |   acc-token-request    |                        |
     |        (ver-t)         |                        |
7.   |----------------------->|                        |
     |                        |                        |
     |    acc-token-issue     |                        |
     |     (acc-t,ro-id)      |                        |
8.   |<-----------------------|                        |
     |                        |                        |
]]>
          </artwork>
        </figure>
        <t>The Client obtains access to the designated resources by exchanging a verification token that it has received for an access token.  To request an access token, the Client sends the verification token to the Server.  Before sending this message, the Client MUST authenticate the Server and verify that the authenticated Server identity is the one bound to the verification token (i.e., the Server identity that the Client originally bound to the request token).</t>
	<t>Upon receiving a request for an access token, the Server MUST authenticate the Client and verify (1) that the verification token provided is one that it issued, and (2) that the Client's authenticated identity matches the identity bound to the verification token.  If both criteria are satisfied, then the Server MUST generate a random access token (unique within the scope of such tokens) and store a binding between the access token, the Client's authenticated identity, the RO identity bound to the verification token, and the resources bound to the verification token.</t>
	<t>The Server completes the authorization process by sending to the Client a message containing (1) the access token and (2) an identifier for the RO to which the verification token was issued. The Client MUST authenticate the Server prior to accepting such a message and verify that the Server's identity matches that bound to the request token and verification token.  The Client MUST also verify that the RO identity returned by the Server matches the RO identity bound to the verification token.  If both verifications succeed, then the Client stores a binding between the access token and the protected resources.</t>  
	<t>Note that because the Client received the verification token over a confidentiality-protected channel, the Server's acceptance of the verification token provides the Client assurance that the entity that provided the verification token was authorized (at the Server) to grant the specified authorization.</t>
      </section>
      <section anchor="acc-res-sec" title="Accessing protected resources">
        <figure>
          <artwork><![CDATA[
   Client                   Server               Resource Owner
     |                        |                        |
     |    acc-res-request     |                        |
     |        (acc-t)         |                        |
9.   |----------------------->|                        |
     |                        |                        |
     |       resources        |                        |
     |<-----------------------|                        |
     |                        |                        |
]]>
          </artwork>
        </figure>
        <t>Finally, once a Client is authorized to access resources on the Server, it accesses them using the corresponding access token.  When a Client wishes to access resources, it sends a request to the Server containing the access token.  The Server MUST authenticate the Client and verify that the access token presented belongs to the authenticated Client before responding with the requested resources.</t>
      </section>
      <section anchor="authz-sum-sec" title="Summary">
        <t>All of the interactions above are summarized in <xref target="msg-flow-fig"></xref>, below.</t>
        <figure anchor="msg-flow-fig" title="OAuth message flow">
          <artwork><![CDATA[
   Client                   Server               Resource Owner
     |                        |                        |
     |   req-token-request    |                        |
1.   |----------------------->|                        |
     |                        |                        |
     |   req-token-issue      |                        |
     |       (req-t)          |                        |
2.   |<-----------------------|                        |
     |                        |                        |
     |                        |     request-authz      |
     |                        |        (req-t)         |
3.   |------------------------------------------------>|
     |                        |                        |
     |                        |   ver-token-request    |
     |                        |        (req-t)         |
4.   |                        |<-----------------------|
     |                        |                        |
     |                        |    ver-token-issue     |
     |                        |  (ver-t,cl-id,scope)   |
5.   |                        |----------------------->|
     |                        |                        |
     |     authz-notify       |                        |
     |     (ver-t,req-t)      |                        |
6.   |<------------------------------------------------|
     |                        |                        |
     |   acc-token-request    |                        |
     |        (ver-t)         |                        |
7.   |----------------------->|                        |
     |                        |                        |
     |    acc-token-issue     |                        |
     |     (acc-t,ro-id)      |                        |
8.   |<-----------------------|                        |
     |                        |                        |
     ~                        ~                        ~
     |    acc-res-request     |                        |
     |        (acc-t)         |                        |
9.   |----------------------->|                        |
     |                        |                        |
     |       resources        |                        |
     |<-----------------------|                        |
     |                        |                        |
]]>
          </artwork>
        </figure>
      </section>
    </section>
    
    <section anchor="sec-anal-sec" title="Security analysis">
      <t>As described in the design goals above, the OAuth model aims to protect against four general classes of threat:
	  <list style="numbers">
	    <t>Outside intervention in an otherwise honest transaction</t>
	    <t>Malicious actors within the authorization process</t>
	    <t>Collusion among actors within the authorization process</t>
	    <t>Denial of service against the authorization process</t>
	  </list>
      In this section, we discuss how the model described above addresses each class of threat.</t>
      <section anchor="out-int-sec" title="Protection from outside interference">
        <t>The authentication requirements of the OAuth process prevent outside entities from interfering with the process.  This property means that if each party assumes that the other authenticated parties behave as the process specifies, all three parties are assured that the genuine RO has authorized the Client to access the specified resources on the Server, i.e., that no outside actors have corrupted the process.  (The next section discusses how the parties can be sure that misbehaving actors cannot create unintended authorizations.)</t>
	<t>The Server's assurance comes from its knowledge of the token bindings and its confidence in the authenticated identities of the Client and the RO.  The Server is assured of the Client's identity because the Client authenticated that identity when it requested the request token and when it exchanged the verification token for the access token.  The Server is assured that the genuine RO authorized the Client because it received the verification token from the Client, and because it knows that it only issued the verification token to the genuine RO (and because it trusts that the RO only gives the verification token to parties it intends to authorize).</t>
	<t>The RO is assured that it knows the real identity of the authorized Client because it has verified that the identity that the Server will provide access to (provided by the server with the verification token) is the same as the authenticated identity of the Client that the RO gave the verification token to.  The RO is also assured that no other Client has received the verification token because it transmitted that token only over an authenticated, confidentiality-protected channel.  (Of course, the RO knows that it is the genuine owner of the subject resources.)</t>
	<t>The Client is assured that the Server from which it will receive resources is the same as the Server it requested authorization from by the persistence of the Server's identity between the requests for the request token and the access token (and subsequent requests for resources).  The Client knows that the Client is the genuine RO because it has verified that the authenticated identity of the RO matches the genuine RO identity provided by the Server.  The Client knows that it is the intended recipient of the authorization because the Server accepts the verification token in a request authenticated with the Client's identity (i.e., because the Server only accepts verification tokens submitted with the identity bound to the verification token).</t>
      </section>
      <section anchor="mal-act-sec" title="Protection from malicious actors within the model">
        <t>The OAuth model ensures that the process fails (i.e., no authorization is granted) if any actor in the process acts improperly.  Here we consider the avenues for misbehavior available to each role, and discuss how the model prevents them from having ill effects.  Of course, since the Server is trusted, it can subvert the process by granting access to any party, so we do not consider its behavior in any further detail.</t>
	<t>The RO performs two actions in the protocol that it might attempt to exploit to create unauthorized accesses: First it sends request tokens to the server to obtain verification tokens, and second, it sends verification tokens to the Client to grant access.  Because the Server verifies that the RO owns the subject resources before it issues a verification token, a RO cannot obtain a verification token for resources it does not own.  Moreover, once an RO has obtained a verification token for resources, that token can only be used by the Client that requested the request token; the RO cannot use it to grant access to any other Client.  So a malicious RO cannot use the OAuth process to grant access beyond its ownership, or beyond the intended Client.</t>
	<t>In order to obtain access to protected resources, a Client needs to obtain a verification token bound to its identity and the protected resources.  However, verification tokens are only issued to the genuine RO, and only bound to the Client identity that the Server associates with a request token.  So the only way for a Client to obtain access without violating the authentication constraints of the model (i.e., forging an authentication or obtaining another Client's private authentication key) is to obtain a request token with its own Client identity, and convince the genuine RO to authorize this request token -- namely, to go through the proper OAuth procedure.  So the only risk from misbehaving Clients is from social engineering attacks against the RO (e.g., phishing).</t>
      </section>
      <section anchor="col-act-sec" title="Protection from colluding actors">
        <t>It is possible for multiple actors within the OAuth process to collude in order to subvert the process.  There are six possible combinations of roles, including multiple actors in the same role:
	  <list style="numbers">
	    <t>Server -- Server</t>
	    <t>Server -- Client</t>
	    <t>Server -- RO</t>
	    <t>Client -- RO</t>
	    <t>Client -- Client</t>
	    <t>RO -- RO</t>
	  </list>
	Of these, we need only consider the latter three, since collusion with the Server is irrelevant (the Server can simply provide the desired accesses or resources). </t>
	<t>Since a legitimate Client and RO can already allow the Client access to the RO's resources, the only remaining objective for such a collusion would be to convince the Server that access was really being granted to another Client.  This attack, however, is prevented by the requirement that the Client authenticate all its interactions with the Server: The RO can only grant access to a Client identity bound to a request token, and that binding is established by a transaction in which the Client's identity is authenticated.</t>
	<t>Two Clients cannot by themselves obtain any access, so two colluding, unauthorized Clients do no damage (neither can present a request token that will result in an authorization).  However, if one Client is authorized (say C1), the other (C2) might try to use it to gain access, in the following way: C2 could register a token for itself, pass that token to C1, and have C1 request authorization.  If the RO fails to verify that the Client identity bound to the request token (provided by the Server) matches the identity of the requesting Client, then the RO will return the verification token to C1.  C1 can then pass the verification token to C2, who can then obtain an access token and access resources.  On the other hand, if the Client does perform the specified verification that the two identities match, then the risk that this collusion will result in unintended access is removed.</t>
	<t>In a similar vein, the major risk from colluding ROs is that they convince the Client that any given colluding RO is the proper owner of resources than any other colluding RO owns. (It is a given that they can grant access to their own resources, and there are no attacks available against the Server, since it has authoritative knowledge.)  To accomplish this attack, when the Client requests authorization from one RO (say RO1), that RO passes the request token to another RO (RO2).  RO2 then acquires a verification token and passes it back to RO1, who uses it to notify the Client.  If the Client fails to compare RO1's authenticated identity to the identity bound to the verification token (provided by the Server), then the Client will think that RO1 is the owner of resources that actually belong to RO2.  On the other hand, if the client does perform this check (as required), then this risk is eliminated.</t>
      </section>
      <section anchor="dos-sec" title="Protection from denial of service">
        <t>The successful completion of the OAuth process is dependent on using tokens to communicate bindings between identities and authorizations.  Entities that can inject false tokens of any type can therefore cause the process to fail (false in the sense that they are not bound to any identity at the server).  The model is secured against this type of denial of service attack because senders of information are authenticated where necessary, and because messages are integrity-protected to prevent tampering en route.</t>
	<t>The OAuth process allows the Client and the RO to force the Server to maintain state, in the form of bindings between request and verification tokens and other information.  The requirement for the server to maintain this state information makes it vulnerable to resource exhaustion attacks.  The Server can mitigate this risk by imposing a limited life-time on request tokens and verification tokens, at the risk that an OAuth process that is not completed within the life-time of the appropriate tokens will fail.</t>
      </section>
    </section>

    <section anchor="ack-sec" title="Acknowledgements">
      <t>This document is essentially an abstraction and security analysis of the current OAuth protocol <xref target="I-D.hammer-oauth"></xref>.  We are thus deeply in debt to the authors of that protocol, especially Eran Hammer-Lahav, who provided several helpful explanations of the current OAuth protocol specification as this document was being developed.</t>
    </section>
    
    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="iana-sec" title="IANA Considerations">
      <t>This memo makes no request to IANA.</t>
    </section>

    <section anchor="sec-cons-sec" title="Security Considerations">
      <t>This document describes a security model for delegated authorization, especially in the World Wide Web context.  As such, security considerations are discussed in detail throughout.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <references title="Normative References">
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hammer-oauth.xml"?>
    </references>

<!--
    <references title="Informative References">
    </references>
-->

  </back>
</rfc>
