<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
 <!ENTITY rfc4861  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4861.xml'>
 <!ENTITY rfc4862  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4862.xml'>
 <!ENTITY rfc3971  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3971.xml'>
 <!ENTITY rfc3972  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3972.xml'>
]> 
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="6"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<rfc ipr="trust200902" category="std" docName="<draft-levy-abegnoli-savi-plbt-00.txt>">

<front>
  <title abbrev="Preference Level based Binding Table">
        Preference Level based Binding Table
  </title>

<author fullname="Eric Levy-Abegnoli" initials="E.L.A."
 surname="Levy-Abegnoli">
    <organization> Cisco Systems</organization>
    <address>
      <postal>
        <street>Village d'Entreprises Green Side -
	  400, Avenue Roumanille </street>
        <city>Biot-Sophia Antipolis - 06410</city>
        <country>France</country>
      </postal>
      <email>elevyabe@cisco.com</email>
    </address>
  </author>

 <date/>

<abstract>
<t>
A trusted database located on the first switch, storing the binding between end-nodes
 Link-Layer-Addresses (LLA) and their IPv6 addresses would be an essential part of source
 address validation. To build such a database, one must:
<list style="numbers">
 <t>Describe the source of information</t>
 <t>How the information is maintained</t>
 <t>How the collisions are resolved.</t>
</list>
and solutions would differ by one or more of these elements. 
</t>
<t>While also getting its binding data from NDP, this draft proposes an alternate to
  "first-come-first-serve" basis <xref target="fcfs"/>), by specifying a preference algorithm
  to deal with collisions. Instead of the simplistic first-come first serve collision
  handling, the proposed algorithm relies on the following criterias to choose between two
  coliding entries:
<list style="symbols">
<t>Where the entries were learnt from (access port, trunk port, etc)</t>
<t>Credential carried by the entries (CGA proof, certificate, mac/lla match, etc.)</t>
<t>State of the current entry</t>
<t>Age of the entry</t>
</list>
</t>

<t>Since the state of the entry is one of the element of the algorithm, this draft also
  describes a tracking mechanism to maintain entries in states where the preference algorithm
  can enable end-nodes movement.
</t>
</abstract>
</front>

<middle>

<!---------------------------------------------------------------->

<section anchor="intro" title="Introduction">
<t>To populate the first-switch binding table, this document propose a scheme based on NDP snooping, and
  introduces a preference level algorithm to deal with collisions. It is organized as follows:
<list style="symbols">
<t><xref target="sinfo"/>) describes the source of information and <xref target="dmodel"/> the binding
  table data model. While the proposed approach would fit multiple sources of bindings, such as Neighbor
  Discovery Protocol (NDP)  snooping, DHCP (snooping), MLD (snooping) and static entries, this document
  focuses on NDP.
  <xref target="bridging"/>) details how an L2-switch can leverage NDP DAD messages to populate it
  table </t>
<t>Entries lifecycle must be fully controlled by the switch. <xref target="fsm"/> details how this
  is achieved. This include some mechanism to test entries reachability, described in 
  <xref target="tracking"/>.</t>
<t>The resolution of collisions is detailed in <xref target="prefalgo"/>.</t>
</list>
</t>
</section>

<section anchor="goals" title="Goals and assumptions">
<t>
  The primary goal of the proposed approach is for the layer2 switch to maintain an accurate view
  of the nodes attached to it, directly or via another layer2 switch. This view is referred to as
  the switch "binding table". The following goals are also looked at:
  <list style="symbols">
    <t>Enable nodes (slow) movement</t>
    <t>Prevent binding address spoofing</t>
  </list>
</t>
<t>The binding table includes the nodes IPv6 address, link-layer address, switch port
  they were leanrt from, whether an access port or a trunk port (port to another switch).
</t>
<t>
  This binding table is the keystone to detect and arbitrage in case of collisions. It also brings a
  couple of interesting by-products: it can provide some address spoofing mitigation, and it can be
  used to limit multicast traffic forwarding.
</t>

<section title="Definitions and Terminology">
<t>The following teminology is being used:
<vspace blankLines="1" /> 
<list style="hanging">
<t hangText="plb-switch:">
A switch that implement the algorithms described in this draft
<vspace blankLines="1" /> </t>
</list>
</t>
</section>

<section anchor="scenarios" title="Scenarios considered">
<t>
Three main scenarios are considered in this document: 
<list style="numbers">
<t>Scenario A: a plb-switch connected to a set of L3-nodes, whether hosts of routers
<figure><artwork align="left"><![CDATA[

  +------+
  |HostA +-----------------+
  +------+                 |
                           |
                     +-----+------+                 
  +------+           |            |
  |HostB +-----------+ SWITCHA    +
  +------+           |            |
                     +-----+------+
                           |
  +------+                 |
  |HostC +-----------------+
  +------+

]]></artwork></figure>
</t>
<t>Scenario B: a plb-switch SWITCH_A connected to L3-nodes and to another plb-switch switch_B
<figure><artwork align="left"><![CDATA[
  +------+                                                   +------+
  |HostA +-----------------+                  +--------------+HostD |
  +------+                 |                  |              +------+ 
                           |                  |
                     +-----+------+     +-----+------+              
  +------+           |            |     |            |       +------+ 
  |HostB +-----------+ SWITCHA    +-----+ SWITCHB    +-------|HostE |
  +------+           |            |     |            |       +------+ 
                     +-----+------+     +-----+------+
                           |                  |             
  +------+                 |                  |              +------+ 
  |HostC +-----------------+                  +--------------+HostF | 
  +------+                                                   +------+                 
]]></artwork></figure>
</t>
<t>  Scenario C: a plb-switch switch_A connected to L3-nodes and to a non plb-switch
  switch_B
</t>
</list>
</t>
</section>
</section>

<section anchor="sinfo" title="Source of information">
<t> Basically, there should be the following source of data for filling the table:
<list style="symbols">
  <t>Neighbor Discovery, address initialization: when a node performs address initialization,
    it sends a DAD (Duplicate Address Detection) Neighbor Solicitation (NS) message. The
    procedure is described in RFC4861 <xref target="RFC4861"/> and RFC4862 <xref target="RFC4862"/>.
    This message does not contain a link-layer address
    option.  However, the switch can find out the MAC address the DAD NS was sent from,
    as well as the port it was received on, and use that to create an entry in the binding
    table. It can also issue its own DAD NS to the sender to trigger it to send a Neighbor
    Advertisement (NA) carrying the binding information needed. Note that even nodes which
    get their address from DHCPv6 should perform DAD to validate it.  Quite commonly, upon
    finishing address initialization, a node will send an unsolicited NA (to all-nodes) to
    announce the address.  The switch can learn the binding from this message as well.</t>
  <t>Neighbor Discovery, address resolution: during the address resolution exchange, the
    owner of an address is going to announce the binding with its link-layer address.
    This information could be seen by the switch, and used to fill the binding table.</t>
  <t>Neighbor Discovery, other messages: there are plenty of NDP messages that carry the
    binding between the IPv6 layer3 address, and the link-layer address in a Source
    Link-Layer Address option (SLLA).These messages can also be snooped by the layer2 switch
    to learn the binding.</t>
</list>
</t>
<t>
   Note that the binding information can also be learnt from other protocol sources such
   as DHCP or even be configured statically on the switch. This is outside the scope
   of this document to detail how this would be performed. However, binding table entries
   learnt by non-NDP methods might collide with entries leant via NDP snooping, and section
   [address collision resolution] describes how to prefer one entry over another one.
</t>
</section>
<section anchor="binding-table" title="Binding table">
<t>
A table is maintained on the switch(es) that binds layer3 (IPv6) address and
 link-layer address (MAC).  
</t>
<section anchor="dmodel" title="Data model">
<t>
A record of the binding table should contain the following information:
<list style="symbols">
<t>v6addr: Layer 3 address</t>
<t>zoneid : the zone id</t>
<t>port: layer2 interface from which the entry was learn </t>
<t>vlanid : LAN identifier the address belong to. </t>
<t>lla: Link-Layer Address (mac)</t>
<t>preflevel: Preference level for this entry </t>
<t>state: entry state </t>
<t>lifetime:  Lifetime of the entry</t>
<t>timestamp: Time of last update</t>
</list>
</t>
<t>
A global scope address should be unique across ports and vlans. A link-local scope
 address is unique within a vlan. Therefore, the database is a collection of l3-entries,
 keyed by ipv6-address and zoneid. A zoneid is a function of the scope of the address
 (LINK-LOCAL, GLOBAL) and the vlanid: 
<list style="symbols">
<t>for scope GLOBAL, zoneid = 0</t>
<t>for scope LINK-LOCAL, zoneid = vlanid</t>
</list>
</t>
<t>A collision between an existing entry and a candidate entry would occur if the two entries 
have the same v6addr and zoneid.These field are referred to as the "key"</t>
<t>
The fields of an entry other than the key (port, vlanid, lla, etc) will the referred
 to as attributes. Changing attributes of an entry require complying with the Entry update
 algorithm described in <xref target="prefalgo"/>.
</t>
</section>

<section anchor="prefalgo" title="Entry preference algorithm">
<section anchor="preflevel" title="Preference Level">
<t>
The preference level (preflevel) is an attribute of an entry in the binding table. It is setup
 when the entry is learnt, based on where it is learnt from, the credentials associated with it
 and other criterias to-be-defined. The preflevel is used to arbitrage between two candidate
 entries (with identical key) in the binding table. The higher the preference level is, the more
 preferred the entry.
</t>
<t> 
One of the key elements of the preflevel associated to an entry is the port is was learnt from.
 For example, an entry would have different preflevels if it is learnt from:
<list style="symbols">
<t>	An access port: it typically attaches to end-nodes</t>
<t>	A trunk port: it attaches to a non plb-switch</t>
<t>	A trusted access port: it attaches to trusted end-nodes</t>
<t>     A trusted trunk: it attaches to another plb-switch</t>
</list>
</t>
<t>
Another important element is the credentials associated with this learning. An entry could be
 associated with cryptographic proof (CGA), and/or the LLA learnt could match the source MAC of the
 frame from which it was learnt. 
</t>
<t>
The following preflevel values have been identified (from lowest to highest):
<list style="symbols">
<t>	LLA_MAC_MATCH: LLA  (found in NDP option) and MAC (found at layer2) are identical;</t>
<t>	TRUNK_PORT: the entry was learnt from a trunk port (connected to another switch)</t>
<t>	ACCESS_PORT: the entry was leant from an access port (connected to a host)</t>
<t>	TRUSTED_ACCESS: The entry was learnt from a trusted port</t>
<t>	TRUSTED_TRUNK: The entry was learnt from a trusted trunk</t>
<t>	DHCP_ASSIGNED: the entry is assigned by DHCP</t>
<t>	CGA_AUTHENTICATED: The entry is CGA authenticated, per <xref target="RFC3972"/></t>
<t>	CERT_AUTHENTICATED: the entry is authenticated with a certificate</t>
<t>	STATIC: this is a statically configured entry per <xref target="RFC3971"/>.</t>
</list>
</t>
<t>
An entry can sum up preference values, for instance it could be TRUNK_PORT + LLA_MAC_MATCH. However,
 the preference level value should be encoded in such a way that the sum of preferences 1 to N-1
 is smaller that preference N.  For example:
<list style="symbols">
<t>An entry learnt from a trunk port with matching lla/mac would have a bigger preflevel than one
 simply matching lla/mac.</t>
<t>However an entry learnt from an access port with matching mac/lla would have a smaller preflevel
 than an entry learnt from a trusted port.</t>
</list>
</t>
</section>
<section anchor="repalgo" title="Entry update algorithm">
<t>
Once an entry is installed in the binding table, its attributes cannot be changed without complying
with this “entry update algorithm”.
</t>
<t>
The algorithm is as follows, starting with rule_1, up to rule_5, in that order until one rule is satisfied: 
<list style="numbers">
<t>	Updating of an entry is allowed when the preflevel carried by the change is bigger than the
 preflevel stored in the entry. </t>
<t>	Updating of an entry is denied if the preflevel carried by the change is smaller than the 
preflevel stored in the entry</t>
<t>	Updating of an entry in state INCOMPLETE is denied if the change is not associated with the
 port where this entry was first learnt from.</t>
<t>	Updating of an entry is denied if the preflevel carried by the change is equal to the preflevel
 stored in the entry, and the entry is in state REACHABLE or VERIFY (see <xref target="fsm"/>)</t>
<t>	Updating an entry is allowed otherwise.</t>
</list>
</t>
</section>
<section anchor="movement" title="Enabling slow movement">
<t>
It is quite a common scenario that an end-node is moving from one port of the switch to another one, or to
a different switch. It is also possible that the end-node is updating its hardware and start using a different
MAC address. There are two paradoxical goals with the trusted binding table: insure entry ownership and enable
movement. The former drives the locking of the address, mac, and port alltogether, and prevent updates other than
on the base of preference. It also works a lot better when entry lifetime is very long or infinite.
The latter requires that a node can easily move from one port to another one, from one mac to another one.
Enforcing address ownership will tend to lead to rejection of any movement and classify it as an attack.
</t>
<t>
The algorithm described in <xref target="repalgo"/>, conbined with the capability to manage entry states
reviewed in <xref target="fsm"/> enables end-nodes to move from on switch port to another port (or one mac to
another) under three scenarios:
<list style="numbers">
<t>	The node disconnect from its original port at least for T1  (T1 is configurable as described in
 <xref target="config"/>. and the move does not lead to a less preferred entry</t>
<t>     The node disconnect at least for T3 (T3 is also configurable).</t>
<t>	The entry seen after the node moves is “prefered”, for instance because the node moved from an ACCESS_PORT to a
TRUSTED_PORT.</t>
</list>
</t>
<t>Note that movement driven bu T1 is tied up to the accuracy of the REACHABILIY state. Maintaining this state with some
entry tracking mechanism as described in <xref target="tracking"/> is going to it a lot more efficient.
</t>
</section>
</section>

<section anchor="tracking" title="Binding entry tracking">
<t>
In order to maintain an accurate view of the devices location and device state, which is a key element of the
 binding table entry preference algorithm, an entry tracking mechanism can be enabled. The tracking of entries 
is performed on a per-port basis, per IPv6 address basis, by “layer-2 unicasting” DAD NS on the port the address
 was first learnt from, to the Destination MAC (DMAC) known to be bound to that address. 
</t>
<t>
The DMAC can be learnt from the LLA option carried in some NDP messages, configured statically, or, in last
 resort, from the source mac (SMAC) address of NDP messages referring to that address.  In the case of NDP
 messages not sourced with UNSPECIFIED address, that would be the source address of the messages. In the case
 of DAD NS, that would be the target address
</t>
</section>

<section anchor="fsm" title="Binding table state machine">
<t>
The entry lifecycle is driven by the switch, not by NDP: this is especially important to insure that entries
 are kept as long as needed in the table rather than following the rule of the ND cache, dictated by other
 requirements.
</t>
<t>
Typically, an entry will be created INCOMPLETE, move to REACHABLE when binding is known,  move back and forth
 from REACHABLE to  VERIFY if tracking is enabled, at some point move to STALE when the device (the address owner)
 stop talking on the link. The entry could stay in that state for very long, sometime forever depending on
 the configuration (see “configuration” section.
</t>
<t>
Four states are defined:
<list style="numbers">
<t>	INCOMPLETE: an entry is set in this state when it does not have the L3/L2 binding yet. This happens
 when an entry is created without the LLA. Typically, such entry is created when an end-node coming up sends
 a DAD NS to verify address uniqueness (DAD NS don’t carry SLLA option).  Creating an entry in that state 
still requires an L3 address, found in the target field of the NS DAD, or in the source field for any other
 message. While the entry is created INCOMPLETE, the switch waits T0 to avoid collision. Then it unicast a 
DAD NS on the port were the first message was seen,  to the SMAC address found in the received frame.  In the
 absence of a response, the DAD NS is retried every T0 up to R0 times.  There are two ways to get out of that state
<list style="symbols">
<t>	After R0 retries without seeing a response, the entry is deleted</t>
<t>	A response is received, carrying an SLLA option. The entry moves into REACHABLE.</t>
<t>	The LLA is received in any other message seen on that port. The entry moves into REACHABLE.</t>
</list></t>
<t>	REACHABLE: As soon as the LLA is learnt, the entry moves to REACHABLE and, if tracking is enabled, a timer
 T1 is started (“configuration” <xref target="config"/>). Upon T1 expiration, the entry moves into VERIFY state. If tracking
 is not enabled, the entry remains T6 at most in that state without any reachability hint (obtain with NDP
 inspection or other features, before moving to STALE. </t>
<t>	VERIFY: In this state, a binding is known (L3/L2) but must be verified. A DAD NS is unicast to the L3/L2
 destinations and a timer T2 is started. There are two ways to get out of that state:
<list style="symbols">
<t>	T2 expires: the entry is moved to STALE after R2 retries.</t>
<t>	NA is received: the binding can move back to REACHABLE</t>
</list></t>
<t>	STALE: when getting into that state; a timer T3 is started based on the configuration (see “configuration”
 section). Upon expiry, the entry is deleted. </t>
</list>
</t>
<t> The binding table state machine is as follows:

<figure><artwork align="left"><![CDATA[
      T0                                                  E1
    +------+ send DAD-NS                             +----------+
    |      | increment r0                            |          |
    |      V                                         |          |
+---+--------------+                  +--------------+---+      |
|                  |      E1          |                  |<-----+
|  INCOMPLETE      +----------------->|  REACHABLE       |
|                  |           T1     |                  |
|                  |   /--------------+                  |
+-----+------------+  /               +------+-----------+
      |R0            /                  A    |     A
      |             /                  /     |     |
      V            /                  /      |T1   |E1
    delete        /                  /       |     |
                 V                  /        V     |
+------------------+         E1    /  +------------+-----+
|                  +---------------   |                  |T3
|   VERIFY         |         R2       |   STALE          +---> delete
|                  +----------------->|                  |
|                  |                  |                  |
+---+--------------+                  +------------------+
    |      A
    |      | send DAD-NS
    +------+ increment r2
       T2
]]></artwork></figure>
</t>
<t>
The following events are driving the state transitions:
<list style="symbols">
<t>	E1: A link-layer –address (LLA) was received, for the L3 address</t>
<t>	T0: Timer expired. Time an entry wait for any binding message (NA, etc.) in INCOMPLETE
 state before another NS is sent, up to INCOMPLETE_MAX_RETRIES </t>
<t>	T1: Timer expired. Time an entry stays in REACHABLE state until we start verifying
 (polling) it or moving to STALE. </t>
<t>	T2: Timer expired. Time an entry wait for any binding message (NA, etc.) in VERIFY state
 before another NS is sent, up to VERIFY_MAX_RETRIES </t>
<t>	T3: Timer expired. Time an entry is left in STALE state until it is deleted or a binding
 message is received.</t>
<t>	R0: Exhaustion of INCOMPLETE_MAX_RETRIES</t>
<t>	R2: Exhaustion of VERIFY_MAX_RETRIES</t>
</list>
</t>
<t>
Default values are as follows:
<list style="symbols">
<t>	T0:  3 seconds</t>
<t>	T1:  300 seconds</t>
<t>	T2 : 10 seconds</t>
<t>	T3 : 24 hours</t>
<t>	INCOMPLETE_MAX_RETRIES: 3</t>
<t>	VERIFY_MAX_RETRIES: 3</t>
</list>
</t>
<t>
All the default values should be overridden-able by configuration. 
</t>
 
</section>
</section>

<section anchor="config" title="Configuration">
<section anchor="swport" title="Switch port configuration">
<t>
Qualifying a port of the switch is of primary importance to influence the “entry update algorithm”
(see <xref target="prefalgo"/>). The switch configuration should allow the following values to be configured on a
 per-port basis:
<list style="symbols">
<t>TRUNK_PORT: the port of the switch is connected to another switch port, that is not a plb-switch.</t>
<t>ACCESS_PORT: the port of the switch is connect to an end-node.</t>
<t>TRUSTED_PORT: the port of the switch is connected to a trusted end-node.</t>
<t>TRUSTED_TRUNK: the port of the switch is connected to another plb-switch.</t>
</list>
</t>
</section>
<section anchor="bthconf" title="Binding table configuration">
<t>
The following elements, acting on the binding table behavior, should be configurable, globally or
on a per-port basis:
<list style="numbers">
<t>T0: (global) frequency at which the switch is unicast DAD NS to obtain an INCOMPLETE entry link-layer
    address. Default is three seconds. Associated configuration elements are:
   <list style="symbols">
      <t>INCOMPLETE_MAX_RETRIES (R0), which is the maximum number of NS sent by the switch before
	deleting the entry. Default is 3.</t>
   </list>
</t>
<t>T1: (per-port) maximum reachable lifetime is the time an entry is kept in REACHABLE without sign of
    activity, before transitioning to VERIFY (if “tracking on”) or STALE otherwise. T1 may be
    set to “infinite”. Default value is 300 seconds. </t>
<t> Tracking on/off:  (per-port) when turned on, it enables the tracking of entries in the binding table.
    Reachability of entries is then tested every T1 by unicasting (at layer2) DAD NS (unless
    reachability is established indirectly by NDP inspection). Associated configuration elements are:
   <list style="symbols">
       <t>T2: (global) verify-interval is the waiting time between re-sending the DAD NS up to R2 times.
	  Default value for T2 is 10 seconds</t>
      <t>VERIFY_MAX_RETRIES (R2), is the maximum number of DAD NS the switch will unicast to
         the entry owner before moving the entry to STALE. Default value for R2 is three times.</t>
   </list>
</t>
<t>T3: (per-port= maximum stale lifetime is the time an entry is kept in STALE without sign of activity,
    before being deleted from the binding table. T3 may be set to “infinite”. Default value is 24 hours.</t>
</list>
</t>
</section>
</section>

<section anchor="bridging" title="Bridging NDP traffic">
<t>
One important aspect of an “NDP-aware” switch is to efficiently bridge the NDP traffic to destinations.
  In some areas, the switch might have a behavior different from a regular non plb-switch:
<list style="numbers">
<t>When intercepting an NDP message carrying binding information, the switch can lookup its binding
 table, decide the message is not worth bridging and drop it. This may be the case when a binding
 entry already exist and is not consistent with the one being received.</t> 
<t>When the received message is a DAD NS for a target the switch has a pending (incomplete) entry,
 received from a different port, the switch may decide to drop it. If it came “second”, in the (small)
 window during which the switch is attempting to track the entry, it suggest this might be an attack. </t>
<t>When intercepting a multicast NDP message, such as a DAD NS, for which it already has an entry
 in its binding table,  the switch may decide to forward it only to the target owner.</t>  
<t>When receiving a DAD NS or other multicast NDP messages, a switch enable for MLD snooping might
 decide to prevent the bridging of the message on trunk ports to other switches (based on MLD report
 received on these port). The plb-switch however may decide to force a copy of these messages
 on these trunks, to insure the other switch is able to populate its own binding table.
 This behavior should be configurable on a per-port basis.</t>
</list> 
</t>

<t>
The general bridging algorithm is as follows. When an NDP message is received by the layer2 switch,
 the switch extracts the link-layer information, if any. If no LLA is provided, the switch should
 bridge normally the message to destination. If LLA is provided, the switch can lookup its binding
 table for this entry. If no entry is found, it creates one, and bridges the message normally.
 If an entry is found with attributes consistent with the ones received (port, zoneid, etc),
 it should bridge the message normally. If the attribute are not consistent, and a change is allowed
 (see <xref target="prefalgo"/>), it should update the attributes and bridge the message. 
 If the change is disallowed, it should drop the message.
</t>

<section anchor="brdad" title="Bridging DAD NS">
<t>
Bridging DAD NS is critical to both security and binding table distribution. Flows below study
 some relevant cases.
</t>
<t>In scenario A, the switch SWITCH_A has only end-nodes connected to it.

<figure><artwork align="left"><![CDATA[
Scenario A:

+--------+          +--------+          +--------+         +--------+
| host 1 +          |SWITCH_A|          |host 2  |         | host 3 |
+--------+          +--------+          +--------+         +--------+
    |                   |                   |                  |
    |                switch up              |                  |
    |                   |    DAD NS tgt=X   |                  |
    |                   |<------------------+                  |
    |                no hit                 |                  |
    |                X stored, pref=ACCESS  |                  |
    |                   |                   |                  |
    |  DAD NS tgt=X conditional forward (1) |                  |
    |<------------------O------------------------------------->|
    |  NA               |                   |                  |
    |------------------>|                   |                  |
    |                 hit, newpref=ACCESS   |                  |
    |                 do not replace        |                  |
    |                 drop                  |                  |
    |                   |                   |                  |
    |                   |   ...             |                  |
    |                   |                   |    DAD NS tgt=X  |
    |                   |<-------------------------------------|
    |                 hit, newpref=ACCESS   |                  |
    |                 forward to owner      |                  |
    |                   |------------------>|                  |
    |                   |                   |                  |
    |   DAD NS tgt=X conditional forward (1)|                  |
    |<------------------|                   |                  |
    |                replace                |                  |
    |  NA               |                   |                  |
    |<------------------|                   |                  |
    |                   |                   |                  |
    |                   |                   |                  |
]]></artwork></figure>
</t>
<t>When nodes come up, the switch is assumed to be already up.  As the result of it, since the
switch stores entries for all addresses it snoops, it is going to have a fairly accurate view of
the nodes (addresses).
Host 2 comes up, and sends a DAD NS for target X, intercepted by the switch. Switch_A does not have X
in its binding table, stores it (INCOMPLETE), and bridges it to other nodes host1 and host3. If MLD
snooping is in effect, the switch might decide not to forward it at all (no other known group listener
for the solicited-node multicast group), or only to a few hosts. Regardless of MLD snooping, flow (1)
is not absolutely "useful" and could even be harmful. If we assume the switch knows all addresses
of the link/vlan, then it knows nobody owns yet this address. In that case, sending it to other
hosts would be an invite for an attack. There is a tradeoff between two issues which are not
equally probable: a risk to break DAD and a risk to be vulnerable to a DoS on address resolution.
</t>

<t>The latter is well understood: should the switch broadcast DAD NS, an attacker can immediately
claim ownership with an NA. As far as the former, it would happen if following conditions are met: 

<list style="numbers">
<t>The initial DAD NS for X, and any subsequent NDP packets (NA to all-nodes, etc) were missed by
the switch.</t>
<t> In addition:
<list style="symbols">
<t>the newly received NS carries a duplicate address.</t>
<t>or host2 is the attacker, however he could not have seen X yet, since the switch has not. So he would
have to know it from non-trivial means.</t>
</list>
</t>
</list>
</t>

<t>In scenario B, SWICTH_A is also connected to a second switch SWITCH_B, which runs the same logic to
populate its own binding table.

<figure><artwork align="left"><![CDATA[
Scenario B:

+--------+          +--------+          +--------+         +--------+
| host 1 +          |SWITCH_A|          |SWITCH_B|         | host 2 |
+--------+          +--------+          +--------+         +--------+
    |                   |                switch up             |
    |                   |                   |    DAD NS tgt=X  |
    |                   |                   |<-----------------|
    |                   |             No hit, no trunk up      |
    |               switch up         X stored in Bt, pref= ACCESS
    |                   |                   |                  |
    |  DAD NS tgt=X     |                   |                  |
    |------------------>|                   |                  |
    |               no hit                  |                  |
    |               X stored, pref=ACCESS   |                  |
    |               forward on trunk (2)    |                  |
    |                   |------------------>|                  |
    |                   |                 hit (host2)          |
    |                   |                   | forward to owner |
    |                   |                   |----------------->|
    |                   |                   |    NA            |
    |                   |                   |<-----------------|
    |                   |                  hit, owner          |
    |                   |     NA           forward on trunk    |
    |                   |<------------------|                  |
    |                hit, newpref=TRUSTED_TRUNK                |
    |                replace                |                  |
    |  NA               |                   |                  |
    |<------------------|                   |                  |
    |                   |                   |                  |
    |                   |                   |                  |
]]></artwork></figure>
</t>

<t>When SWITCH_A comes up, it may come after SWITCH_B. In this case, it is unaware
about end-nodes attached to SWITCH_B. SWITCH_B however knows all of them, with the same
assumptions as in scenario A. Upon receiving a DAD NS for target X, and in the 
absence of a hit, SWITCH_A creates an INCOMPLETE entry and forwards it to SWITCH_B.
<list style="numbers">
<t>If SWITCH_B has it in its table, then it can forward it only on the interface of X's
owner (host2). Host2 responds, and response reaches SWITCH_A. SWITCH_A has already an
entry for X associate with interface to host1, while this one is received from the trunk.
The trunk is a TRUSTED_TRUNK, hence entries received over it are preferred.
SWITCH_A updates its binding table and propagate to host1.
This is the case of a valid address duplication.</t>
<t>If  SWITCH_B receiving the DAD NS over the trunk, does not have X
in its table, it can drop the NS, while creating an INCOMPLETE entry for X. Or it
can broadcast locally (with the same reasoning as for the previous scenario).
</t>
</list> 
</t>

<t>Scenario C connects SWITCH_A to a SWITCH_B that does not run the same binding
table alrorigthm (referred to as a non plb-switch). In this scenario, SWITCH_A forwarding
on the trunk a DAD NS for target X. Configuration should tell whether any response coming
from SWITCH_B is to be trusted (in the lack of better credential such as CGA/RSA proof). If
SWITCH_B is fully trusted, then the trunk is configured as "TRUSTED_TRUNK" and scenario B applies.
Otherwise, the trunk is configured as "TRUNK" and response is ignored.

<figure><artwork align="left"><![CDATA[
Scenario C:

+--------+          +--------+          +--------+         +--------+
| host 1 +          |SWITCH_A|          |SWITCH_B|         | host 2 |
+--------+          +--------+          +--------+         +--------+
    |                   |                switch up             |
    |                   |                   |   DAD NS tgt=X   |
    |                   |                   |<-----------------|
    |                   |                   |                  |
    |               switch up               |                  |
    |                   |                   |                  |
    |  DAD NS tgt=X     |                   |                  |
    |------------------>|                   |                  |
    |               no hit                  |                  |
    |               X stored, pref=ACCESS   |                  |
    |                   |------------------>|                  |
    |                   |                   |   to group       |
    |                   |                   |----------------->|
    |                   |                   |   NA             |
    |                   |                   |<-----------------|
    |                   |     NA            |                  |
    |                   |<------------------|                  |
    |                hit, newpref=TRUNK     |                  |
    |                do not replace         |                  |
    |                drop NA                |                  |
    |                   |                   |                  | 
    |                   |                   |                  |
    |                   |                   |                  |

]]></artwork></figure>
</t>

</section>
<section anchor="brother" title="Bridging other NDP messages">
<t>When running the proposed binding table populate algorithm, switches are expected to have
an accurate view of end-nodes attached to them. While scenario C is problematic, scenario A and
B are clearer. If a switch has an entry in its table that conflicts with binding observed in an
NDP message just received, it should drop the message (if new data has a smaller preflevel) or
update its entry and bridge the message.</t> 
<t>
If the switch does not have such entry, it should create the entry and bridge the message, including
to trunks. 
</t>
<t>
In the case of multicast messages, it should bridge it on trunks regardless of group
registration, to give a chance to other switch to buildup a more accurate binding table.
</t>
</section>
</section>
</middle>
<!---------------------------------------------------------------->

<back>
<references title='Normative References'>

&rfc4861;
&rfc4862;
&rfc3971;
&rfc3972;
<reference anchor="fcfs">
  <front>
 <title>
 First-Come First-Serve Source-Address Validation Implementation
 </title>
 <author surname="Nordmark" initials="E">
<organization>Sun</organization></author>
 <author surname="Bagnulo" initials="M">
<organization>UC3M</organization></author>
 <date month="March" year="2009" />
  </front>
<seriesInfo name="draft-ietf-savi-fcfs-01" value="I-D"/>
</reference>
</references>

<section title="Contributors and Acknowledgments">
<t>
This draft benefited from the input from: Pascal Thubert.
</t>
</section>

</back>

</rfc>
