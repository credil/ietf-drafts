


Networking Working Group                                  T. Winter, Ed.
Internet-Draft
Intended status: Standards Track                         P. Thubert, Ed.
Expires: June 10, 2010                                     Cisco Systems
                                                        ROLL Design Team
                                                            IETF ROLL WG
                                                        December 7, 2009


      RPL: IPv6 Routing Protocol for Low power and Lossy Networks
                         draft-ietf-roll-rpl-05

Abstract

   Low power and Lossy Networks (LLNs) are a class of network in which
   both the routers and their interconnect are constrained: LLN routers
   typically operate with constraints on (any subset of) processing
   power, memory and energy (battery), and their interconnects are
   characterized by (any subset of) high loss rates, low data rates and
   instability.  LLNs are comprised of anything from a few dozen and up
   to thousands of LLN routers, and support point-to-point traffic
   (between devices inside the LLN), point-to-multipoint traffic (from a
   central control point to a subset of devices inside the LLN) and
   multipoint-to-point traffic (from devices inside the LLN towards a
   central control point).  This document specifies the IPv6 Routing
   Protocol for LLNs (RPL), which provides a mechanism whereby
   multipoint-to-point traffic from devices inside the LLN towards a
   central control point, as well as point-to-multipoint traffic from
   the central control point to the devices inside the LLN, is
   supported.  Support for point-to-point traffic is also available.

Status of this Memo

   This Internet-Draft is submitted to IETF in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.



Winter, et al.            Expires June 10, 2010                 [Page 1]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on June 10, 2010.

Copyright Notice

   Copyright (c) 2009 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the BSD License.
































Winter, et al.            Expires June 10, 2010                 [Page 2]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  5
     1.1.  Design Principles  . . . . . . . . . . . . . . . . . . . .  5
     1.2.  Expectations of Link Layer Type  . . . . . . . . . . . . .  6
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  6
   3.  Protocol Model . . . . . . . . . . . . . . . . . . . . . . . .  8
     3.1.  Instances, DODAGs, and DODAG Iterations  . . . . . . . . .  8
     3.2.  Traffic Flows  . . . . . . . . . . . . . . . . . . . . . . 10
       3.2.1.  Multipoint-to-Point Traffic  . . . . . . . . . . . . . 10
       3.2.2.  Point-to-Multipoint Traffic  . . . . . . . . . . . . . 10
       3.2.3.  Point-to-Point Traffic . . . . . . . . . . . . . . . . 10
     3.3.  DODAG Construction . . . . . . . . . . . . . . . . . . . . 11
       3.3.1.  DAG Information Object (DIO) . . . . . . . . . . . . . 11
       3.3.2.  DAG Repair . . . . . . . . . . . . . . . . . . . . . . 11
       3.3.3.  Grounded and Floating DODAGs . . . . . . . . . . . . . 12
       3.3.4.  Administrative Preference  . . . . . . . . . . . . . . 12
       3.3.5.  Objective Function (OF)  . . . . . . . . . . . . . . . 12
       3.3.6.  Distributed Algorithm Operation  . . . . . . . . . . . 13
     3.4.  Destination Advertisement  . . . . . . . . . . . . . . . . 13
       3.4.1.  Destination Advertisement Object (DAO) . . . . . . . . 13
   4.  Routing Metrics and Constraints Used By RPL  . . . . . . . . . 14
   5.  Rank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
     5.1.  Loop Avoidance . . . . . . . . . . . . . . . . . . . . . . 15
       5.1.1.  Greediness and Rank-based Instabilities  . . . . . . . 15
       5.1.2.  DODAG Loops  . . . . . . . . . . . . . . . . . . . . . 16
       5.1.3.  DAO Loops  . . . . . . . . . . . . . . . . . . . . . . 16
       5.1.4.  Sibling Loops  . . . . . . . . . . . . . . . . . . . . 16
     5.2.  Rank Properties  . . . . . . . . . . . . . . . . . . . . . 16
   6.  RPL Protocol Specification . . . . . . . . . . . . . . . . . . 18
     6.1.  RPL Messages . . . . . . . . . . . . . . . . . . . . . . . 18
       6.1.1.  ICMPv6 RPL Control Message . . . . . . . . . . . . . . 18
       6.1.2.  DAG Information Solicitation (DIS) . . . . . . . . . . 19
       6.1.3.  DAG Information Object (DIO) . . . . . . . . . . . . . 19
       6.1.4.  Destination Advertisement Object (DAO) . . . . . . . . 26
     6.2.  Protocol Elements  . . . . . . . . . . . . . . . . . . . . 28
       6.2.1.  Topological Elements . . . . . . . . . . . . . . . . . 28
       6.2.2.  Neighbors, Parents, and Siblings . . . . . . . . . . . 28
       6.2.3.  DODAG Information  . . . . . . . . . . . . . . . . . . 29
     6.3.  DAG Discovery and Maintenance  . . . . . . . . . . . . . . 30
       6.3.1.  DAG Discovery Rules  . . . . . . . . . . . . . . . . . 31
       6.3.2.  DIO Message Communication  . . . . . . . . . . . . . . 35
       6.3.3.  DIO Transmission . . . . . . . . . . . . . . . . . . . 36
       6.3.4.  Trickle Timer for DIO Transmission . . . . . . . . . . 37
     6.4.  DAG Selection  . . . . . . . . . . . . . . . . . . . . . . 38
     6.5.  Operation as a Leaf Node . . . . . . . . . . . . . . . . . 39
     6.6.  Administrative rank  . . . . . . . . . . . . . . . . . . . 39
     6.7.  Collision  . . . . . . . . . . . . . . . . . . . . . . . . 39



Winter, et al.            Expires June 10, 2010                 [Page 3]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


     6.8.  Establishing Routing State Down the DODAG  . . . . . . . . 40
       6.8.1.  Destination Advertisement Operation  . . . . . . . . . 41
     6.9.  Loop Detection . . . . . . . . . . . . . . . . . . . . . . 48
       6.9.1.  Source Node Operation  . . . . . . . . . . . . . . . . 49
       6.9.2.  Router Operation . . . . . . . . . . . . . . . . . . . 49
     6.10. Multicast Operation  . . . . . . . . . . . . . . . . . . . 51
     6.11. Maintenance of Routing Adjacency . . . . . . . . . . . . . 52
   7.  Suggestions for Packet Forwarding  . . . . . . . . . . . . . . 53
   8.  Guidelines for Objective Functions . . . . . . . . . . . . . . 54
   9.  RPL Constants and Variables  . . . . . . . . . . . . . . . . . 56
   10. Manageability Considerations . . . . . . . . . . . . . . . . . 58
     10.1. Control of Function and Policy . . . . . . . . . . . . . . 58
       10.1.1. Initialization Mode  . . . . . . . . . . . . . . . . . 58
       10.1.2. DIO Base option  . . . . . . . . . . . . . . . . . . . 58
       10.1.3. Trickle Timers . . . . . . . . . . . . . . . . . . . . 59
       10.1.4. DAG Sequence Number Increment  . . . . . . . . . . . . 59
       10.1.5. Destination Advertisement Timers . . . . . . . . . . . 59
       10.1.6. Policy Control . . . . . . . . . . . . . . . . . . . . 59
       10.1.7. Data Structures  . . . . . . . . . . . . . . . . . . . 60
     10.2. Information and Data Models  . . . . . . . . . . . . . . . 60
     10.3. Liveness Detection and Monitoring  . . . . . . . . . . . . 60
       10.3.1. Candidate Neighbor Data Structure  . . . . . . . . . . 61
       10.3.2. Directed Acyclic Graph (DAG) Table . . . . . . . . . . 61
       10.3.3. Routing Table  . . . . . . . . . . . . . . . . . . . . 61
       10.3.4. Other RPL Monitoring Parameters  . . . . . . . . . . . 62
       10.3.5. RPL Trickle Timers . . . . . . . . . . . . . . . . . . 62
     10.4. Verifying Correct Operation  . . . . . . . . . . . . . . . 62
     10.5. Requirements on Other Protocols and Functional
           Components . . . . . . . . . . . . . . . . . . . . . . . . 63
     10.6. Impact on Network Operation  . . . . . . . . . . . . . . . 63
   11. Security Considerations  . . . . . . . . . . . . . . . . . . . 63
   12. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 63
     12.1. RPL Control Message  . . . . . . . . . . . . . . . . . . . 63
     12.2. New Registry for RPL Control Codes . . . . . . . . . . . . 63
     12.3. New Registry for the Control Field of the DIO Base . . . . 64
     12.4. DAG Information Object (DIO) Suboption . . . . . . . . . . 64
   13. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 65
   14. Contributors . . . . . . . . . . . . . . . . . . . . . . . . . 65
   15. References . . . . . . . . . . . . . . . . . . . . . . . . . . 67
     15.1. Normative References . . . . . . . . . . . . . . . . . . . 67
     15.2. Informative References . . . . . . . . . . . . . . . . . . 67
   Appendix A.  Requirements  . . . . . . . . . . . . . . . . . . . . 69
     A.1.  Protocol Properties Overview . . . . . . . . . . . . . . . 69
       A.1.1.  IPv6 Architecture  . . . . . . . . . . . . . . . . . . 69
       A.1.2.  Typical LLN Traffic Patterns . . . . . . . . . . . . . 69
       A.1.3.  Constraint Based Routing . . . . . . . . . . . . . . . 70
     A.2.  Deferred Requirements  . . . . . . . . . . . . . . . . . . 70
   Appendix B.  Examples  . . . . . . . . . . . . . . . . . . . . . . 70



Winter, et al.            Expires June 10, 2010                 [Page 4]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


     B.1.  Destination Advertisement  . . . . . . . . . . . . . . . . 72
     B.2.  Example: DAG Parent Selection  . . . . . . . . . . . . . . 73
     B.3.  Example: DAG Maintenance . . . . . . . . . . . . . . . . . 75
     B.4.  Example: Greedy Parent Selection and Instability . . . . . 76
   Appendix C.  Outstanding Issues  . . . . . . . . . . . . . . . . . 78
     C.1.  Additional Support for P2P Routing . . . . . . . . . . . . 78
     C.2.  Loop Detection . . . . . . . . . . . . . . . . . . . . . . 78
     C.3.  Destination Advertisement / DAO Fan-out  . . . . . . . . . 78
     C.4.  Source Routing . . . . . . . . . . . . . . . . . . . . . . 79
     C.5.  Address / Header Compression . . . . . . . . . . . . . . . 79
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 79








































Winter, et al.            Expires June 10, 2010                 [Page 5]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


1.  Introduction

   Low power and Lossy Networks (LLNs) are made largely of constrained
   nodes (with limited processing power, memory, and sometimes energy
   when they are battery operated).  These routers are interconnected by
   lossy links, typically supporting only low data rates, that are
   usually unstable with relatively low packet delivery rates.  Another
   characteristic of such networks is that the traffic patterns are not
   simply unicast, but in many cases point-to-multipoint or multipoint-
   to-point.  Furthermore such networks may potentially comprise up to
   thousands of nodes.  These characteristics offer unique challenges to
   a routing solution: the IETF ROLL Working Group has defined
   application-specific routing requirements for a Low power and Lossy
   Network (LLN) routing protocol, specified in
   [I-D.ietf-roll-building-routing-reqs],
   [I-D.ietf-roll-home-routing-reqs], [RFC5673], and [RFC5548].  This
   document specifies the IPv6 Routing Protocol for Low power and Lossy
   Networks (RPL).

1.1.  Design Principles

   RPL was designed with the objective to meet the requirements spelled
   out in [I-D.ietf-roll-building-routing-reqs],
   [I-D.ietf-roll-home-routing-reqs], [RFC5673], and [RFC5548].  Because
   those requirements are heterogeneous and sometimes incompatible in
   nature, the approach is first taken to design a protocol capable of
   supporting a core set of functionalities corresponding to the
   intersection of the requirements.  As the RPL design evolves optional
   features may be added to address some application specific
   requirements.  This is a key protocol design decision providing a
   granular approach in order to restrict the core of the protocol to a
   minimal set of functionalities, and to allow each implementation of
   the protocol to be optimized differently.  All "MUST" application
   requirements that cannot be satisfied by RPL will be specifically
   listed in the Appendix A, accompanied by a justification.

   A network may run multiple instances of RPL concurrently.  Each such
   instance may serve different and potentially antagonistic constraints
   or performance criteria.  This document defines how a single instance
   operates.

   RPL is a generic protocol that is to be deployed by instantiating the
   generic operation described in this document with a specific
   objective function (OF) (which ties together metrics, constraints,
   and an optimization objective) to realize a desired objective in a
   given environment.

   A set of companion documents to this specification will provide



Winter, et al.            Expires June 10, 2010                 [Page 6]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   further guidance in the form of applicability statements specifying a
   set of operating points appropriate to the Building Automation, Home
   Automation, Industrial, and Urban application scenarios.

1.2.  Expectations of Link Layer Type

   As RPL is a routing protocol, it of course does not rely on any
   particular features of a specific link layer technology.  RPL should
   be able to operate over a variety of different link layers, including
   but not limited to low power wireless or PLC (Power Line
   Communication) technologies.

   Implementers may find RFC 3819 [RFC3819] a useful reference when
   designing a link layer interface between RPL and a particular link
   layer technology.


2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in RFC
   2119 [RFC2119].

   This document requires readers to be familiar with the terminology
   described in `Terminology in Low power And Lossy Networks'
   [I-D.ietf-roll-terminology].

   DAG:  Directed Acyclic Graph.  A directed graph having the property
         that all edges are oriented in such a way that no cycles exist.
         All edges are contained in paths oriented toward and
         terminating at one or more root nodes.

   DAG Instance:  A DAG Instance is a set of possibly multiple
         Destination Oriented DAGs.  A network may have more than one
         DAG Instance, and a RPL router can participate to multiple DAG
         instances.  Each DAG Instance operates independently of other
         DAG Instances.  This document describes operation within a
         single DAG instance.

   InstanceID:  Unique identifier of a DAG Instance.

   Destination Oriented DAG (DODAG):  A DAG rooted at a single
         destination, which is a node with no outgoing edges.  The tuple
         (InstanceID, DAGID) uniquely identifies a Destination Oriented
         DAG (DODAG).  In the RPL context, a router can can belong to at
         most one DODAG per DAG Instance.




Winter, et al.            Expires June 10, 2010                 [Page 7]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   DAGID:  The identifier of a DODAG root.  The DAGID must be unique
         within the scope of a DAG Instance in the LLN.

   DODAG Iteration:  A specific sequence number iteration of a DODAG.

   DAGSequenceNumber:  A sequential counter that is incremented by the
         root to form a new Iteration of a DODAG.  A DODAG Iteration is
         identified uniquely by the (InstanceID, DAGID,
         DAGSequenceNumber) tuple.

   DAG parent:  A parent of a node within a DAG is one of the immediate
         successors of the node on a path towards the DAG root.

   DAG sibling:  A sibling of a node within a DAG is defined in this
         specification to be any neighboring node which is located at
         the same rank within a DAG.  Note that siblings defined in this
         manner do not necessarily share a common parent.

   DAG root:  A DAG root is a node within the DAG that has no outgoing
         edges.  Because the graph is acyclic, by definition all DAGs
         must have at least one DAG root and all paths terminate at a
         DAG root.

   Sub-DAG  The sub-DAG of a node is the set of other nodes in the DAG
         that might use a path towards the DAG root that contains the
         node.  Nodes in the sub-DAG of a node have a greater rank
         (although not all nodes of greater rank are in the sub-DAG).

   Up:   Up refers to the direction from leaf nodes towards DODAG roots,
         following the orientation of the edges within the DODAG.

   Down: Down refers to the direction from DODAG roots towards leaf
         nodes, going against the orientation of the edges within the
         DODAG.

   OCP:  Objective Code Point.  The Objective Code Point is used to
         indicate which Objective Function is in use in a DODAG.  The
         Objective Code Point is further described in
         [I-D.ietf-roll-routing-metrics].

   OF:   Objective Function.  The Objective Function (OF) defines which
         routing metrics, optimization objectives, and related functions
         are in use in a DODAG.  The Objective Function is further
         described in [I-D.ietf-roll-routing-metrics].







Winter, et al.            Expires June 10, 2010                 [Page 8]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   Goal: The Goal is a host or set of hosts that satisfy a particular
         application objective / OF.  Whether or not a DODAG can provide
         connectivity to a goal is a property of the DODAG.  For
         example, a goal might be a host serving as a data collection
         point, or a gateway providing connectivity to an external
         infrastructure.

   Grounded:  A DAG is grounded when the root can reach the Goal of the
         objective function.

   Floating:  A DAG is floating if is not Grounded.  A floating DAG is
         not expected to reach the Goal defined for the OF.

   As they form networks, LLN devices often mix the roles of `host' and
   `router' when compared to traditional IP networks.  In this document,
   `host' refers to an LLN device that can generate but does not forward
   RPL traffic, `router' refers to an LLN device that can forward as
   well as generate RPL traffic, and `node' refers to any RPL device,
   either a host or a router.


3.  Protocol Model

   The aim of this section is to describe RPL in the spirit of
   [RFC4101].  Protocol details can be found in further sections.

3.1.  Instances, DODAGs, and DODAG Iterations

   Each DAG instance constructs a routing topology optimized for a
   certain Objective Function (OF).  A DAG instance may provide routes
   to certain destination prefixes.  A single DAG instance contains one
   or more Destination Oriented DAG (DODAG) roots.  These roots may
   operate independently, or may coordinate over a non-LLN backchannel.

   Each root has a unique identifier, the DAGID, such that nodes can
   identify the DODAG root.

   A DAG instance may comprise:

   o  a single DODAG with a single root

      *  For example, a DODAG optimized to minimize latency rooted at a
         single centralized lighting controller in a home automation
         application.

   o  multiple uncoordinated DODAGs with independent roots (differing
      DAGIDs)




Winter, et al.            Expires June 10, 2010                 [Page 9]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


      *  For example, multiple data collection points in an urban data
         collection application that do not have an always-on backbone
         suitable to coordinate to form a single DODAG, and further use
         the formation of multiple DODAGs as a means to dynamically and
         autonomously partition the network.

   o  a single DODAG with a single virtual root coordinating LLN sinks
      (with the same DAGID) over some non-LLN backbone

      *  For example, multiple border routers operating with a reliable
         backbone, e.g. in support of a 6LowPAN application, that are
         capable to act as logically equivalent sinks to the same DODAG.

   o  a combination of one of the above as suited to some application
      scenario.

   Traffic is bound to a specific DODAG Instance by a marking in the
   flow label of the IPv6 header.  Traffic originating in support of a
   particular application may be tagged to follow an appropriate DAG
   instance, for example to follow paths optimized for low latency or
   low energy.  The provisioning or automated discovery of a mapping
   between an InstanceID and a type or service of application traffic is
   beyond the scope of this specification.

   An example of a DAG Instance comprising a number of DODAGs is
   depicted in Figure 1.  A DODAG Iteration is depicted in Figure 2.


     +----------------------------------------------------------------+
     |                                                                |
     | +--------------+                                               |
     | |              |                                               |
     | |     (R1)     |            (R2)                   (Rn)        |
     | |     /  \     |            /| \                  / |  \       |
     | |    /    \    |           / |  \                /  |   \      |
     | |  (A)    (B)  |         (C) |  (D)     ...    (F) (G)  (H)    |
     | |  /|\     |\  |         /   |   |\             |   |    |     |
     | | : : :    : : |        :   (E)  : :            :   :    :     |
     | |              |            / \                                |
     | +--------------+           :   :                               |
     |      DODAG                                                     |
     |                                                                |
     +----------------------------------------------------------------+
                                DAG Instance

                          Figure 1: DAG Instance





Winter, et al.            Expires June 10, 2010                [Page 10]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


            +----------------+                +----------------+
            |                |                |                |
            |      (R1)      |                |      (R1)      |
            |      /  \      |                |      /         |
            |     /    \     |                |     /          |
            |   (A)    (B)   |         \      |   (A)          |
            |   /|\     |\   |    ------\     |   /|\          |
            |  : : (C)  : :  |           \    |  : : (C)       |
            |                |           /    |        \       |
            |                |    ------/     |         \      |
            |                |         /      |         (B)    |
            |                |                |          |\    |
            |                |                |          : :   |
            |                |                |                |
            +----------------+                +----------------+
                Sequence N                       Sequence N+1


                         Figure 2: DODAG Iteration

3.2.  Traffic Flows

3.2.1.  Multipoint-to-Point Traffic

   Multipoint-to-Point (MP2P) is a dominant traffic flow in many LLN
   applications ([I-D.ietf-roll-building-routing-reqs],
   [I-D.ietf-roll-home-routing-reqs], [RFC5673], [RFC5548]).  The
   destinations of MP2P flows are designated nodes that have some
   application significance, such as providing connectivity to the
   larger Internet or core private IP network.  RPL supports MP2P
   traffic by allowing MP2P destinations to be reached via DODAG roots.

3.2.2.  Point-to-Multipoint Traffic

   Point-to-multipoint (P2MP) is a traffic pattern required by several
   LLN applications ([I-D.ietf-roll-building-routing-reqs],
   [I-D.ietf-roll-home-routing-reqs], [RFC5673], [RFC5548]).  RPL
   supports P2MP traffic by using a destination advertisement mechanism
   that provisions routes toward destination prefixes and away from
   roots.  Destination advertisements can update routing tables as the
   underlying DODAG topology changes.

3.2.3.  Point-to-Point Traffic

   RPL DODAGs provide a basic structure for point-to-point (P2P)
   traffic.  For a RPL network to support P2P traffic, a root must be
   able to route packets to a destination.  Nodes within the network may
   also have routing tables to destinations.  A packet flows towards a



Winter, et al.            Expires June 10, 2010                [Page 11]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   root until it reaches an ancestor that has a known route to the
   destination.

   RPL also supports the case where a P2P destination is a `one-hop'
   neighbor.

   RPL neither specifies nor precludes additional mechanisms for
   computing and installing more optimal routes to support arbitrary P2P
   traffic.

3.3.  DODAG Construction

   RPL provisions routes up towards DODAG roots, forming a DODAG
   optimized according to the Objective Function (OF) in use.  RPL nodes
   construct and maintain these DODAGs through exchange of DAG
   Information Object (DIO) messages.  Undirected links between siblings
   are also identified during this process, which are used to provide
   additional diversity.

3.3.1.  DAG Information Object (DIO)

   A DIO identifies the DAG Instance, the DAGID, the values used to
   compute the DAG Instance's objective function, and the present DODAG
   Sequence Number.  It can also include additional routing and
   configuration information.  The DIO includes a measure derived from
   the position of the node within the DODAG, the rank, which is used
   for nodes to determine their positions relative to each other and to
   inform loop avoidance/detection procedures.  RPL exchanges DIO
   messages to establish and maintain routes.

   RPL adapts the rate at which nodes send DIO messages.  When a DODAG
   is detected to be inconsistent or needs repair, RPL sends DIO
   messages more frequently.  As the DODAG stabilizes, the DIO message
   rate tapers off, reducing the maintenance cost of a steady and well-
   working DODAG.

   This document defines an ICMPv6 Message Type RPL Control Message,
   which is capable of carrying a DIO.

3.3.2.  DAG Repair

   RPL supports global repair over the DODAG.  A DODAG Root may
   increment the DODAG Sequence Number to institute a global repair,
   revising the DODAG and allowing nodes to choose an arbitrary new
   position within the new DODAG iteration.

   RPL may support mechanisms for local repair within the DODAG
   iteration.  The DIO message will specify the necessary parameters as



Winter, et al.            Expires June 10, 2010                [Page 12]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   configured from the DODAG root.  Local repair options include the
   allowing a node, upon detecting a loss of connectivity to a DODAG it
   is a member of, to:

   o  Poison its sub-DAG by advertising an effective rank of INFINITY,
      OR detach and form a floating DODAG in order to preserve inner
      connectivity within its sub-DAG.

   o  Move down the DODAG iteration in a limited manner, no further than
      a bound configured via the DIO so as not to count all the way to
      infinity.  Such a move may be undertaken after waiting an
      appropriate poisoning interval, and should allow the node to
      restore connectivity to the DODAG Iteration if possible.

3.3.3.  Grounded and Floating DODAGs

   DODAGs can be grounded or floating.  A grounded DODAG offers
   connectivity to to a goal.  A floating DODAG offers no such
   connectivity, and provides routes only to nodes within the DODAG.
   Floating DODAGs may be used, for example, to preserve inner
   connectivity during repair.

3.3.4.  Administrative Preference

   An implementation/deployment may specify that some DODAG roots should
   be used over others through an administrative preference.
   Administrative preference offers a way to control traffic and
   engineer DODAG formation in order to better support application
   requirements or needs.

3.3.5.  Objective Function (OF)

   The Objective Function (OF) implements the optimization objectives of
   route selection within the DAG Instance.  The OF is identified by an
   Objective Code Point (OCP) within the DIO, and its specification also
   indicates the metrics and constraints in use.  The OF also specifies
   the procedure used to compute rank within a DODAG iteration.  Further
   details may be found in [I-D.ietf-roll-routing-metrics] and related
   companion specifications.

   By using defined OFs that are understood by all nodes in a particular
   implementation, and by referencing them in the DIO message, RPL nodes
   may work to build optimized LLN routes using a variety of application
   and implementation specific metrics and goals.

   In the case where a node is unable to encounter a suitable DAG
   Instance using a known Objective Function, it may be configured to
   join DAG Instance using and unknown Objective Function but only



Winter, et al.            Expires June 10, 2010                [Page 13]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   acting as a leaf node.

3.3.6.  Distributed Algorithm Operation

   A high level overview of the distributed algorithm which constructs
   the DODAG is as follows:

   o  Some nodes are configured to be DODAG roots, with associated DODAG
      configuration.

   o  Nodes advertise their presence, affiliation with a DODAG, routing
      cost, and related metrics by sending link-local multicast DIO
      messages.

   o  Nodes may adjust the rate at which DIO messages are sent in
      response to stability or detection of routing inconsistencies.

   o  Nodes listen for DIOs and use their information to join a new
      DODAG, or to maintain an existing DODAG, as according to the
      specified Objective Function and rank-based loop avoidance rules.

   o  The nodes provision routing table entries for the destinations
      specified by the DIO towards their parents in the DODAG iteration.
      Nodes may provision a parent as a default gateway.

   o  Nodes may identify siblings within the DODAG iteration to increase
      path diversity.

   o  Using both DIOs and possibly information in data packets, RPL
      nodes detect possible routing loops.  When a RPL node detects a
      possible routing loop, it may adapt its DIO transmission rate to
      apply a local repair to the topology.  This process and its
      limitations is discussed in greater detail in 3.4.

3.4.  Destination Advertisement

   As RPL constructs and maintains DODAGs with DIO messages to establish
   upward routes, it may use Destination Advertisement Object (DAO)
   messages to establish downward routes along the DODAG.  DAO messages
   and support for downward routes are an optional feature for
   applications that require P2MP or P2P traffic.  DIO messages
   advertise whether the destination advertisement mechanism is enabled.

3.4.1.  Destination Advertisement Object (DAO)

   A Destination Advertisement Object (DAO) conveys destination
   information upwards along the DODAG so that a DODAG root (an other
   intermediate nodes) can provision downward routes.  A DAO message



Winter, et al.            Expires June 10, 2010                [Page 14]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   includes prefix information to identify destinations, a capability to
   record routes in support of source routing, and information to
   determine the freshness of a particular advertisement.

   Nodes that are capable of maintaining routing state may aggregate
   routes from DAO messages that they receive before transmitting a DAO
   message.  Nodes that are not capable to maintain routing state may
   attach a next-hop address to the Reverse Route Stack contained within
   the DAO message.  The Reverse Route Stack is subsequently used to
   generate piecewise source routes over regions of the LLN that are
   incapable of storing downward routing state.

   A special case of the DAO message, termed a no-DAO, is used to clear
   downward routing state that has been provisioned through DAO
   operation.

   This document defines an ICMPv6 Message Type RPL Control Message,
   which is capable to carry the DAO.

3.4.1.1.  `One-Hop' Neighbors

   In addition to sending DAOs toward DODAG roots, RPL nodes may
   occasionally emit a link-local multicast DAO message advertising
   available destination prefixes.  This mechanism allow provisioning a
   trivial `one-hop' route to local neighbors.


4.  Routing Metrics and Constraints Used By RPL

   Routing metrics are used by routing protocols to compute the shortest
   paths.  Interior Gateway Protocols (IGPs) such as IS-IS ([RFC5120])
   and OSPF ([RFC4915]) use static link metrics.  Such link metrics can
   simply reflect the bandwidth or can also be computed according to a
   polynomial function of several metrics defining different link
   characteristics; in all cases they are static metrics.  Some routing
   protocols support more than one metric: in the vast majority of the
   cases, one metric is used per (sub)topology.  Less often, a second
   metric may be used as a tie-breaker in the presence of Equal Cost
   Multiple Paths (ECMP).  The optimization of multiple metrics is known
   as an NP complete problem and is sometimes supported by some
   centralized path computation engine.

   In contrast, LLNs do require the support of both static and dynamic
   metrics.  Furthermore, both link and node metrics are required.  In
   the case of RPL, it is virtually impossible to define one metric, or
   even a composite, that will satisfy all use cases.

   In addition, RPL supports constrained-based routing where constraints



Winter, et al.            Expires June 10, 2010                [Page 15]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   may be applied to link and nodes.  If a link or a node does not
   satisfy a required constraint, it is `pruned' from the candidate list
   thus leading to a constrained shortest path.

   The set of supported link/node constraints and metrics is specified
   in [I-D.ietf-roll-routing-metrics].

   The role of the Objective Function is to advertise routing metrics
   and constraints in addition to the objectives used to compute the
   (constrained) shortest path.

   Example 1: Shortest path: path offering the shortest end-to-end delay

   Example 2: Constrained shortest path: the path that does not traverse
              any battery-operated node and that optimizes the path
              reliability


5.  Rank

5.1.  Loop Avoidance

   RPL guarantees neither loop free path selection nor strong global
   convergence.  In order to reduce control overhead, however, such as
   the cost of the count-to-infinity problem, RPL avoids creating loops
   when undergoing topology changes.  Furthermore, RPL includes rank-
   based mechanisms for detecting loops when they do occur.  RPL uses
   this loop detection to ensure that packets make forward progress
   within the DODAG iteration and trigger repairs when necessary.

5.1.1.  Greediness and Rank-based Instabilities

   Once a node has joined a DODAG, RPL disallows certain behaviors,
   including greediness, in order to prevent resulting instabilities in
   the DODAG.

   If a node is allowed to be greedy and attempts to move deeper in the
   DODAG, beyond its most preferred parent, in order to increase the
   size of the parent set, then an instability can result.  This is
   illustrated in Figure 16.

   Suppose a node is willing to receive and process a DIO messages from
   a node in its own sub-DAG, and in general a node deeper than it.  In
   such cases a chance exists to create a feedback loop, wherein two or
   more nodes continue to try and move in the DODAG in order to optimize
   against each other.  In some cases this will result in an
   instability.  It is for this reason that RPL limits the cases where a
   node may process DIO messages from deeper nodes to some forms of



Winter, et al.            Expires June 10, 2010                [Page 16]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   local repair.  This approach creates an `event horizon', whereby a
   node cannot be influenced beyond some limit into an instability by
   the action of nodes that may be in its own sub-DAG.

   A further example of the consequences of greedy operation, and
   instability related to processing DIO messages from nodes of greater
   rank, may be found in Appendix B.4

5.1.2.  DODAG Loops

   A DODAG loop may occur when a node detaches from the DODAG and
   reattaches to a device in its prior sub-DAG.  This may happen in
   particular when DIO messages are missed.  Strict use of the DAG
   sequence number can eliminate this type of loop, but this type of
   loop may possibly be encountered when using some local repair
   mechanisms.

5.1.3.  DAO Loops

   A DAO loop may occur when the parent has a route installed upon
   receiving and processing a DAO message from a child, but the child
   has subsequently cleaned up the state.  This loop happens when a no-
   DAO was missed until a heartbeat cleans up all states.  RPL includes
   loop detection mechanisms that may mitigate the impact of DAO loops
   and trigger their repair.

   In the case where stateless DAO operation is used, i.e. source
   routing specifies the down routes, then DAO Loops should not occur on
   the stateless portions of the path.

5.1.4.  Sibling Loops

   Sibling loops could occur if a group of siblings kept choosing
   amongst themselves as successors such that a packet does not make
   forward progress.  This specification limits the number of times that
   sibling forwarding may be used at a given rank to prevent sibling
   loops.

5.2.  Rank Properties

   The rank of a node is a scalar representation of the location of that
   node within a DODAG iteration.  The rank is used to avoid and detect
   loops, and as such must demonstrate certain properties.  The exact
   calculation of the rank is left to the Objective Function, and may
   depend on parents, link metrics, and the node configuration and
   policies.

   The rank is not a cost metric, although its value can be derived from



Winter, et al.            Expires June 10, 2010                [Page 17]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   and influenced by metrics.  The rank has properties of its own that
   are not necessarily that of all metrics:

   Type:   Rank is an abstract scalar.  Some metrics are boolean (e.g.
           grounded), others are statistical and better expressed as a
           tuple like an expected value and a variance.  Some OCPs use
           not one but a set of metrics bound by a piece of logic.

   Function:  Rank is the expression of a relative position within a
           DODAG iteration with regard to neighbors and, not necessarily
           a good indication or a proper expression of a distance or a
           cost to the root.

   Stability:  The stability of the rank determines that of the routing
           topology.  Some dampening or filtering might be applied to
           keep the topology stable and the rank does not necessarily
           change as fast as some physical metrics would.  A new
           iteration is a good opportunity to reconcile the
           discrepancies that might form over time between the metrics
           and the ranks.

   Granularity:  Rank is coarse grained.  A fine granularity would
           prevent the selection of siblings.

   Properties:  Rank is strictly monotonic and can be used to validate a
           progression from or towards the root.  A metric like
           bandwidth or jitter does not necessarily exhibit such
           property.

   Abstract:  Rank does not have a physical unit, but rather a range of
           increment per hop that varies from 1 (best) to 16 (worst),
           where the assignment of each value is to be determined by the
           implementation.

   The rank value feeds back into the DAG parent selection according to
   the RPL loop-avoidance strategy.  Once a parent has been added, and a
   rank value for the node within the DODAG has been advertised, the
   nodes further options with regard to DAG parent selection and
   movement within the DODAG are restricted in favor of loop avoidance.

   The computation of the DAG rank MUST be done in such a way so as to
   maintain the following properties for any nodes M and N that are
   neighbors in the LLN:








Winter, et al.            Expires June 10, 2010                [Page 18]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   DAGRank(M) is less than DAGRank(N):  In this case, M is probably
           located in a more preferred position than N in the DODAG with
           respect to the metrics and optimizations defined by the
           objective code point.  In any fashion, Node M may safely be a
           DAG parent for Node N without risk of creating a loop.
           Further, for a node N, all parents in the DAG parent set must
           be of rank less than self's DAGRank(N).  In other words, the
           rank presented by a node N MUST be greater (deeper) than that
           presented by any of its parents.

   DAGRank(M) equals DAGRank(N):  In this case M and N are located
           positions of relatively the same optimality within the DODAG.
           In some cases, Node M may be used as a successor by Node N,
           but with related chance of creating a loop that must be
           detected and broken by some other means.

   DAGRank(M) is greater than DAGRank(N):  In this case, then node M is
           located in a less preferred position than N in the DODAG with
           respect to the metrics and optimizations defined by the
           objective code point.  Further, Node (M) may in fact be in
           Node (N)'s sub-DAG.  There is a higher risk to Node (N)
           selecting Node (M) as a DAG parent, as such a selection may
           create a loop.

   As an example, the DAG rank could be computed in such a way so as to
   closely track ETX when the objective function is to minimize ETX, or
   latency when the objective function is to minimize latency, or in a
   more complicated way as appropriate to the objective code point being
   used within the DODAG.


6.  RPL Protocol Specification

6.1.  RPL Messages

6.1.1.  ICMPv6 RPL Control Message

   This document defines the RPL Control Message, a new ICMPv6 message.
   The RPL Control Message has the following general format, in
   accordance with [RFC4443]:











Winter, et al.            Expires June 10, 2010                [Page 19]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     Type      |     Code      |          Checksum             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               |
       +                         Message Body                          +
       |                                                               |

                       Figure 3: RPL Control Message

   The RPL Control message is an ICMPv6 information message with a
   requested Type of 155.

   The Code will be used to identify RPL Control Messages as follows:

   o  0x01: DAG Information Solicitation (Section 6.1.2)

   o  0x02: DAG Information Object (Section 6.1.3)

   o  0x04: Destination Advertisement Object (Section 6.1.4)

6.1.2.  DAG Information Solicitation (DIS)

   The DAG Information Solicitation (DIS) message may be used to solicit
   a DAG Information Object from a RPL node.  Its use is analogous to
   that of a Router Solicitation; a node may use DIS to probe its
   neighborhood for nearby DAGs.  The DAG Information Solicitation
   carries no additional message body.

6.1.3.  DAG Information Object (DIO)

   The DAG Information Object carries a number of metrics and other
   information that allows a node to discover a DAG Instance, select its
   DAG parents, and identify its siblings while employing loop avoidance
   strategies.

6.1.3.1.  DIO Base

   The DIO Base is a container option, which is always present, and
   might contain a number of suboptions.  The base option regroups the
   minimum information set that is mandatory in all cases.









Winter, et al.            Expires June 10, 2010                [Page 20]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |G|D|A|0|0| Prf |   Sequence    |  InstanceID   |    DAGRank    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               |
       +                                                               +
       |                            DAGID                              |
       +                                                               +
       |                                                               |
       +                                                               +
       |                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   sub-option(s)...
       +-+-+-+-+-+-+-+-+-+-+-+-+-+

                            Figure 4: DIO Base

   Control Field:  The DAG Control Field is currently allocated as
         follows:

         Grounded (G):  The Grounded (G) flag is set when the DODAG root
               is a Goal for the OF.

         Destination Advertisement Trigger (D):  The Destination
               Advertisement Trigger (D) flag is set when the DODAG root
               or another node in the successor chain decides to trigger
               the sending of destination advertisements in order to
               update routing state for the down direction along the
               DODAG, as further detailed in Section 6.8.  Note that the
               use and semantics of this flag are still under
               investigation.

         Destination Advertisement Supported (A):  The Destination
               Supported (A) bit is set when the DODAG root is capable
               to support the collection of destination advertisement
               related routing state and enables the operation of the
               destination advertisement mechanism within the DODAG.

         DAGPreference (Prf):  3-bit unsigned integer set by the DODAG
               root to its preference and unchanged at propagation.
               DAGPreference ranges from 0x00 (least preferred) to 0x07
               (most preferred).  The default is 0 (least preferred).
               The DAG preference provides an administrative mechanism
               to engineer the self-organization of the LLN, for example
               indicating the most preferred LBR.  If a node has the
               option to join a more preferred DODAG while still meeting
               other optimization objectives, then the node will



Winter, et al.            Expires June 10, 2010                [Page 21]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


               generally seek to join the more preferred DODAG as
               determined by the OF.

         Unassigned bits of the Control Field are considered as
         reserved.  They MUST be set to zero on transmission and MUST be
         ignored on receipt.

   Sequence Number:  8-bit unsigned integer set by the DODAG root,
         incremented according to a policy provisioned at the DODAG
         root, and propagated with no change down the DODAG.  Each
         increment SHOULD have a value of 1 and may cause a wrap back to
         zero.

   InstanceID:  8-bit field indicating the topology instance associated
         with the DODAG, as provisioned at the DODAG root.

   DAGRank:  8-bit unsigned integer indicating the DAG rank of the node
         sending the DIO message.  The DAGRank of the DODAG root is
         ROOT_RANK.  DAGRank is further described in Section 6.3.

   DAGID:  128-bit unsigned integer which uniquely identify a DODAG.
         This value is set by the DODAG root.  The global IPv6 address
         of the DODAG root can be used. the DAGID MUST be unique per DAG
         Instance within the scope of the LLN.

   The following values MUST NOT change during the propagation of DIO
   messages down the DAG:
      Grounded (G)
      Destination Advertisement Supported (A)
      DAGPreference (Prf)
      Sequence
      InstanceID
      DAGID
   All other fields of the DIO message may be updated at each hop of the
   propagation.

6.1.3.1.1.  DIO Suboptions

   In addition to the minimum options presented in the base option,
   several suboptions are defined for the DIO message:

6.1.3.1.1.1.  Format









Winter, et al.            Expires June 10, 2010                [Page 22]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


        0                   1                   2
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
       |  Subopt. Type |         Subopt Length         | Subopt Data
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -

                  Figure 5: DIO Suboption Generic Format

   Suboption Type:  8-bit identifier of the type of suboption.  When
         processing a DIO message containing a suboption for which the
         Suboption Type value is not recognized by the receiver, the
         receiver MUST silently ignore the unrecognized option, continue
         to process the following suboption, correctly handling any
         remaining options in the message.

   Suboption Length:  16-bit unsigned integer, representing the length
         in octets of the suboption, not including the suboption Type
         and Length fields.

   Suboption Data:  A variable length field that contains data specific
         to the option.

   The following subsections specify the DIO message suboptions which
   are currently defined for use in the DAG Information Object.

   Implementations MUST silently ignore any DIO message suboptions
   options that they do not understand.

   DIO message suboptions may have alignment requirements.  Following
   the convention in IPv6, these options are aligned in a packet such
   that multi-octet values within the Option Data field of each option
   fall on natural boundaries (i.e., fields of width n octets are placed
   at an integer multiple of n octets from the start of the header, for
   n = 1, 2, 4, or 8).

6.1.3.1.1.2.  Pad1

   The Pad1 suboption does not have any alignment requirements.  Its
   format is as follows:


        0
        0 1 2 3 4 5 6 7
       +-+-+-+-+-+-+-+-+
       |   Type = 0    |
       +-+-+-+-+-+-+-+-+

                              Figure 6: Pad 1



Winter, et al.            Expires June 10, 2010                [Page 23]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   NOTE! the format of the Pad1 option is a special case - it has
   neither Option Length nor Option Data fields.

   The Pad1 option is used to insert one or two octets of padding in the
   DIO message to enable suboptions alignment.  If more than two octets
   of padding is required, the PadN option, described next, should be
   used rather than multiple Pad1 options.

6.1.3.1.1.3.  PadN

   The PadN option does not have any alignment requirements.  Its format
   is as follows:


        0                   1                   2
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
       |   Type = 1    |         Subopt Length         | Subopt Data
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -

                              Figure 7: Pad N

   The PadN option is used to insert three or more octets of padding in
   the DIO message to enable suboptions alignment.  For N (N > 2) octets
   of padding, the Option Length field contains the value N-3, and the
   Option Data consists of N-3 zero-valued octets.  PadN Option data
   MUST be ignored by the receiver.

6.1.3.1.1.4.  DAG Metric Container

   The DAG Metric Container suboption may be aligned as necessary to
   support its contents.  Its format is as follows:


        0                   1                   2
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
       |   Type = 2    |       Container Length        | DAG Metric Data
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -

                      Figure 8: DAG Metric Container

   The DAG Metric Container is used to report aggregated path metrics
   along the DODAG.  The DAG Metric Container may contain a number of
   discrete node, link, and aggregate path metrics as chosen by the
   implementer.  The Container Length field contains the length in
   octets of the DAG Metric Data.  The order, content, and coding of the
   DAG Metric Container data is as specified in



Winter, et al.            Expires June 10, 2010                [Page 24]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   [I-D.ietf-roll-routing-metrics].

   The DAG Metric Container MUST include the value for the DAG Objective
   Code Point.

   The processing and propagation of the DAG Metric Container is
   governed by implementation specific policy functions.

6.1.3.1.1.5.  Destination Prefix

   The Destination Prefix suboption does not have any alignment
   requirements.  Its format is as follows:


        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 3    |            Length             |Resvd|Prf|Resvd|
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        Prefix Lifetime                        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | Prefix Length |                                               |
       +-+-+-+-+-+-+-+-+                                               |
       |             Destination Prefix (Variable Length)              |
       .                                                               .
       .                                                               .
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 9: DAG Destination Prefix

   The Destination Prefix suboption is used when the DODAG root, or
   another node located upwards along the DODAG on the path to the DODAG
   root, needs to indicate that it offers connectivity to destination
   prefixes other than the default.  This may be useful in cases where
   more than one LBR is operating within the LLN and offering
   connectivity to different administrative domains, e.g. a home network
   and a utility network.  In such cases, upon observing the Destination
   Prefixes offered by a particular DODAG, a node MAY decide to join
   multiple DODAGs in support of a particular application.

   The Length is coded as the length of the suboption in octets,
   excluding the Type and Length fields.

   Prf is the Route Preference as in [RFC4191].  The reserved fields
   MUST be set to zero on transmission and MUST be ignored on receipt.

   The Prefix Lifetime is a 32-bit unsigned integer representing the
   length of time in seconds (relative to the time the packet is sent)



Winter, et al.            Expires June 10, 2010                [Page 25]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   that the Destination Prefix is valid for route determination.  The
   lifetime is initially set by the node that owns the prefix and
   denotes the valid lifetime for that prefix (similar to
   AdvValidLifetime [RFC4861]).  The value might be reduced by the
   originator and/or en-route nodes that will not provide connectivity
   for the whole valid lifetime.  A value of all one bits (0xFFFFFFFF)
   represents infinity.  A value of all zero bits (0x00000000) indicates
   a loss of reachability.

   The Prefix Length is an 8-bit unsigned integer that indicates the
   number of leading bits in the destination prefix.

   The Destination Prefix contains Prefix Length significant bits of the
   destination prefix.  The remaining bits of the Destination Prefix, as
   required to complete the trailing octet, are set to 0.

   In the event that a DIO message may need to specify connectivity to
   more than one destination, the Destination Prefix suboption may be
   repeated.

6.1.3.1.1.6.  DAG Configuration

   The DAG Configuration suboption does not have any alignment
   requirements.  Its format is as follows:


        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 4    |            Length             | DIOIntDoubl.  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  DIOIntMin.   |   DIORedun.   |  MaxRankInc   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Figure 10: DAG Configuration

   The DAG Configuration suboption is used to distribute configuration
   information for DAG Operation through the DODAG.  The information
   communicated in this suboption is generally static and unchanging
   within the DODAG, therefore it is not necessary to include in every
   DIO.  This suboption MAY be included occasionally by the DODAG Root,
   and MUST be included in response to a unicast request, e.g. a DAG
   Information Solicitation (DIS) message.

   The Length is coded as 5.

   DIOIntervalDoublings is an 8-bit unsigned integer, configured on the
   DODAG root and used to configure the trickle timer governing when DIO



Winter, et al.            Expires June 10, 2010                [Page 26]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   message should be sent within the DODAG.  DIOIntervalDoublings is the
   number of times that the DIOIntervalMin is allowed to be doubled
   during the trickle timer operation.

   DIOIntervalMin is an 8-bit unsigned integer, configured on the DODAG
   root and used to configure the trickle timer governing when DIO
   message should be sent within the DODAG.  The minimum configured
   interval for the DIO trickle timer in units of ms is
   2^DIOIntervalMin.  For example, a DIOIntervalMin value of 16ms is
   expressed as 4.

   DIORedundancyConstant is an 8-bit unsigned integer used to configure
   suppression of DIO transmissions.  DIORedundancyConstant is the
   minimum number of relevant incoming DIOs required to suppress a DIO
   transmission.  If the value is 0xFF then the suppression mechanism is
   disabled.

   MaxRankInc, 8-bit unsigned integer, is the DAGMaxRankIncrease.  This
   is the allowable increase in rank in support of local repair.  If
   DAGMaxRankIncrease is 0 then this mechanism is disabled.

6.1.4.  Destination Advertisement Object (DAO)

   The Destination Advertisement Object (DAO) is used to propagate
   destination information upwards along the DODAG.  The RPL use of the
   DAO allows the nodes in the DODAG to provision routing state for
   nodes contained in the sub-DAG in support of traffic flowing down
   along the DODAG.























Winter, et al.            Expires June 10, 2010                [Page 27]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |         DAO Sequence          |  InstanceID   |   DAO Rank    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                          DAO Lifetime                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           Route Tag                           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | Prefix Length |    RRCount    |                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
       |                   Prefix (Variable Length)                    |
       .                                                               .
       .                                                               .
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |             Reverse Route Stack (Variable Length)             |
       .                                                               .
       .                                                               .
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

           Figure 11: The Destination Advertisement Object (DAO)

   DAO Sequence:  Incremented by the node that owns the prefix for each
         new DAO message for that prefix.

   InstanceID:  8-bit field indicating the topology instance associated
         with the DODAG, as learned from the DIO.

   DAO Rank:  Set by the node that owns the prefix and first issues the
         DAO message to its rank.

   DAO Lifetime:  32-bit unsigned integer.  The length of time in
         seconds (relative to the time the packet is sent) that the
         prefix is valid for route determination.  A value of all one
         bits (0xFFFFFFFF) represents infinity.  A value of all zero
         bits (0x00000000) indicates a loss of reachability.

   Route Tag:  32-bit unsigned integer.  The Route Tag may be used to
         give a priority to prefixes that should be stored.  This may be
         useful in cases where intermediate nodes are capable of storing
         a limited amount of routing state.  The further specification
         of this field and its use is under investigation.

   Prefix Length:  8-bit unsigned integer.  Number of valid leading bits
         in the IPv6 Prefix.






Winter, et al.            Expires June 10, 2010                [Page 28]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   RRCount:  8-bit unsigned integer.  This counter is used to count the
         number of entries in the Reverse Route Stack.  A value of `0'
         indicates that no Reverse Route Stack is present.

   Prefix:  Variable-length field containing an IPv6 address or a prefix
         of an IPv6 address.  The Prefix Length field contains the
         number of valid leading bits in the prefix.  The bits in the
         prefix after the prefix length (if any) are reserved and MUST
         be set to zero on transmission and MUST be ignored on receipt.

   Reverse Route Stack:  Variable-length field containing a sequence of
         RRCount (possibly compressed) IPv6 addresses.  A node that adds
         on to the Reverse Route Stack will append to the list and
         increment the RRCount.

6.2.  Protocol Elements

6.2.1.  Topological Elements

   RPL uses four identifiers to track and control the routing topology

   o  The first is an InstanceID.  An InstanceID defines what OF a DAG
      uses and may also indicate what destinations are offered.  A
      network may have multiple InstanceIDs, each of which defines an
      independent DAG optimized for a different OF and/or application.
      The DAG defined by an InstanceID is called a DAG Instance.

   o  The second is a DAGID.  The scope of a DAGID is a DAG Instance.  A
      combination of InstanceID and DAGID defines a DODAG.  A DAG
      Instance may have multiple DODAGs.

   o  The third value is a DAG Sequence Number.  The scope of a DAG
      Sequence Number is a DODAG.  A DODAG is sometimes reconstructed
      from the root, by incrementing the DAGSequenceNumber.  A
      combination of InstanceID, DAGID, and DAG Sequence Number defines
      a DODAG Iteration.

   o  The fourth value is rank.  The scope of rank is a DODAG Iteration.
      Rank establishes a partial order over a DODAG Iteration, defining
      individual node positions.

6.2.2.  Neighbors, Parents, and Siblings

   1.  A node that is not a DODAG root MAY maintain multiple DAG parents
       for a single DAG Instance.

   2.  The set of DAG parents MUST be a conceptual subset of the set of
       candidate neighbors.  (This does not dictate implementation,



Winter, et al.            Expires June 10, 2010                [Page 29]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


       e.g., to use a certain data structure).

   3.  If Neighbor Unreachability Detection (NUD), or an equivalent
       mechanism, determines that a neighbor is no longer reachable,
       then a RPL node MUST NOT consider this node in the neighbor set
       when calculating and advertising routes until the node determines
       it is reachable again.

   4.  Routes via that unreachable neighbor MUST be eliminated from the
       routing table, and the node SHOULD poison using no-DAO all DAO
       routes that it has advertised via DAO and that it can reach only
       via that neighbor.

   A node's neighbor set is an unconstrained subset of the nodes that it
   can reach with a link-local multicast.

   The OF guides in the selection and maintains a number of neighbors to
   interact with, which neighbors being qualified as statistically
   stable and presenting adequate properties as per the the OF logic,
   for instance following mechanisms discussed in
   [I-D.ietf-roll-routing-metrics].  Those neighbors are referred to as
   candidate neighbors.

   Candidate neighbors may take the role of Parent or Siblings, in part
   as determined by rank.

   For the purpose of inheriting metrics and computing rank, the OF
   might select one preferred parent.  In that case, the rank of this
   node is computed as the rank of the preferred parent plus a rank
   increment as determined by the OF.

6.2.3.  DODAG Information

   For each DODAG that a node is, or may become, a member of, the
   implementation should conceptually keep track of the following
   information for each DODAG.  The data structures described in this
   section are intended to illustrate a possible implementation to aid
   in the description of the protocol, but are not intended to be
   normative.

   o  InstanceID

   o  DAGID

   o  DAGSequenceNumber

   o  DAG Metric Container, including DAGObjectiveCodePoint




Winter, et al.            Expires June 10, 2010                [Page 30]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   o  A set of Destination Prefixes offered upwards along the DODAG

   o  A set of DAG parents

   o  A set of DAG siblings

   o  A timer to govern the sending of DIO messages

   When the DAG parent set is depleted on a node that is not a root,
   (i.e. the last parent is removed), then the DAG information should
   not be suppressed until after the expiration of an implementation-
   specific local timer in order to observe that the DAGSequenceNumber
   has incremented should any new parents appear for the DODAG.

6.2.3.1.  DAG Parents/Siblings Structure

   When the DODAG is self-rooted, the set of DAG parents is empty.

   For each node in a DAG parent/sibling set, the implementation should
   conceptually keep track of:

   o  a reference to the neighboring device which is the DAG parent/
      sibling

   o  a record of most recent information taken from the DAG Information
      Object last processed in the case where the neighboring device is
      a DAG parent

   DAG parents may be ordered, according to the OF.  When ordering DAG
   parents, in consultation with the OF, the most preferred DAG parent
   may be identified.  All current DAG parents must have a rank less
   than self.  All current DAG siblings must have a rank equal to self.

   When nodes are added to or removed from the DAG parent/sibling sets
   the most preferred DAG parent may have changed.  The role of all the
   nodes in the list should be reevaluated.  In particular, any nodes
   having a rank greater than self after such a change must be evicted
   from the set.

6.3.  DAG Discovery and Maintenance

   DAG discovery allows a node to join a DODAG rooted at a DODAG root by
   discovering neighbors that are members of the DODAG, and identifying
   a set of parents.  DAG discovery also identifies siblings, which may
   be used later to provide additional path diversity towards the DODAG
   root.

   DODAG discovery may avoid loops by constraining how and when nodes



Winter, et al.            Expires June 10, 2010                [Page 31]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   can increase their rank, and by statistically poisoning the nodes
   that present the highest risk.

   DAG discovery enables nodes to implement different policies for
   selecting their DAG parents in the DODAG by using implementation
   specific policy functions.  DAG discovery specifies a set of rules to
   be followed by all implementations to enable interoperation.

6.3.1.  DAG Discovery Rules

   The following rules define the RPL DAG Discovery procedures:

6.3.1.1.  DODAG Iteration

   1.   An InstanceID SHOULD be administratively provisioned on a DODAG
        root that is significant RPL objective.  The InstanceID MUST be
        unique to that purpose across the scope of the LLN.

   2.   A DAGID MUST be unique within the scope of the InstanceID.  It
        MAY be derived from the IPv6 address of the DODAG root.

   3.   A node MAY belong to multiple DAG instances.  The related
        details of operation are outside the scope of this
        specification.

   4.   DODAG roots MAY increment the DAGSequenceNumber that they
        advertise.

   5.   When a DODAG root increments its DAGSequenceNumber, it MUST
        follow the conventions of Serial Number Arithmetic as described
        in [RFC1982].

   6.   The tuple (InstanceID, DAGID, DAGSequenceNumber) uniquely
        defines a DODAG Iteration.  All of a node's parents within a
        DODAG MUST belong to the same DODAG iteration, as conveyed by
        the last heard DIO from each parent.

   7.   A node MUST NOT propagate DIOs for a DODAG Iteration unless it
        is the DODAG root of the DODAG iteration or has selected DODAG
        parents in that DODAG iteration.

   8.   A node acting as a leaf SHOULD NOT propagate DIOs for a DODAG
        Iteration.

   9.   A node MUST belong at most to one DODAG Iteration per
        InstanceID.





Winter, et al.            Expires June 10, 2010                [Page 32]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   10.  Within a given DODAG, a node that is a not a root MUST NOT
        advertise a DAGSequenceNumber higher than the highest
        DAGSequenceNumber it has heard.

   Within a particular implementation, a DODAG root may increment the
   DAGSequenceNumber periodically, at a rate that depends on the
   deployment.  In other implementations loop detection may be
   considered sufficient to solve the routing issues, and the DODAG root
   may increment the DAGSequenceNumber only upon administrative
   intervention.  Another possibility is that nodes within the LLN have
   some means to signal the DODAG root in order to request an on-demand
   increment when routing issues are detected.

   As the DAGSequenceNumber is incremented, a new DODAG Iteration
   spreads outward from the DODAG root.  Thus a parent that advertises
   the new DAGSequenceNumber can not possibly belong to the sub-DAG of a
   node that still advertises an older DAGSequenceNumber.  A node may
   safely add such a parent, without risk of forming a loop, without
   regard to its relative rank in the prior DODAG Iteration.  This is
   equivalent to jumping to a different DODAG.

   As a node transitions to new DODAG Iterations as a consequence of
   following these rules, the node will be unable to advertise the
   previous DODAG Iteration (prior DAGSequenceNumber) once it has
   committed to advertising the new DODAG Iteration.

   During a transition to a new DODAG Iteration, a node may decide to
   forward packets via 'future parents' that belong to the same DODAG
   (same InstanceID and DAGID), but are observed to advertise a more
   recent (incremented) DAGSequenceNumber.

6.3.1.2.  DODAG Roots

   1.  A DODAG root that does not have connectivity to a network outside
       of the LLN MUST NOT set the Grounded bit.

   2.  A DODAG root MUST advertise a rank of ROOT_RANK.

   3.  A node that does not have any DODAG parent MAY become the DODAG
       root of a floating DODAG.  It MAY also set its DAGPreference such
       that it is less preferred.  This behavior may be a desired
       alternate to poisoning.

   An LLN node that is a Goal for the Objective Function is the root of
   its own grounded DODAG, at rank ROOT_RANK.

   In a deployment that uses a backbone link to federate a number of LLN
   roots, it is possible to run RPL over the backbone and use one router



Winter, et al.            Expires June 10, 2010                [Page 33]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   as a backbone root.  The backbone root is the virtual root of the
   DODAG and exposes a rank of BASE_RANK over the backbone.  All the LLN
   roots that are parented to that backbone root, including the backbone
   root if it also serves as LLN root, expose a rank of ROOT_RANK over
   the LLN and are part of the same DODAG, coordinated with the virtual
   root over the backbone.

6.3.1.3.  Rank and Movement within a DODAG Iteration

   1.  A node MUST NOT advertise a rank less than or equal to any member
       of its parent set within the DODAG Iteration.

   2.  A node MAY advertise a rank lower than its prior advertisement
       within the DODAG Iteration.  (This corresponds to a node moving
       up within the DODAG Iteration).

   3.  Let L be the lowest rank within a DODAG iteration that a given
       node has advertised.  Within a DODAG Iteration, that node MUST
       NOT advertise an effective rank deeper than L +
       DAGMaxRankIncrease.  INFINITE_RANK is an exception to this rule:
       a node MAY advertise an INFINITE_RANK at any time.  (This
       corresponds to a limited rank increase for the purpose of local
       repair within the DODAG Iteration.)

   4.  A node MAY, at any time, choose to join a different DODAG within
       a DAG Instance.  Such a join has no rank restrictions, unless
       that different DODAG is a DODAG Iteration that the node has been
       a prior member of, in which case the rule of the previous bullet
       (3) must be observed.  Until a node transmits a DIO indicating
       its new DODAG membership, it MUST forward packets along the
       previous DODAG.

   5.  A node MAY, at any time after hearing the next DAGSequenceNumber
       Iteration advertised from suitable parents, choose to migrate up
       to the next DODAG Iteration within the DODAG.

   Conceptually, an implementation is maintaining a parent set within
   the DODAG Iteration.  Movement entails changes to the parent set.
   Moving up does not present the risk to create a loop but moving down
   might, so that operation is subject to additional constraints.

   When a node migrates into the next DODAG Iteration, the parent and
   sibling sets need to be rebuilt for the new iteration.  An
   implementation could defer to migrate until for some reasonable time
   to see if some other neighbors with potentially better metrics but
   higher rank announce themselves.  Similarly, when a node jumps into a
   new DODAG it needs to construct new parent/sibling sets for the new
   DODAG.



Winter, et al.            Expires June 10, 2010                [Page 34]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   When a node moves to improve its position, it must conceptually
   abandon all parents and siblings with a rank larger than itself.  As
   a consequence of the movement it may also add new siblings.  Such a
   movement may occur at any time to decrease the rank, as per the
   calculation indicated by the OF.  Maintenance of the parent and
   sibling sets occurs as the rank of candidate neighbors is observed as
   reported in their DIOs.

   If a node needs to move down a DODAG that it is attached to, causing
   the DAG rank to increase, then it MAY poison its routes and delay
   before moving as described in Section 6.3.1.4.

6.3.1.4.  Poisoning a Broken Path

   1.  A node MAY poison, in order to avoid being used as an ancestor by
       the nodes in its sub-DAG, by advertising an effective rank of
       INFINITE_RANK and resetting the associated DIO trickle timer to
       cause the INFINITE_RANK to be announced promptly.

   2.  The node MAY advertise an effective rank of INFINITE_RANK for an
       arbitrary number of DIO timer events before announcing a new
       rank.

   3.  As per Section 6.3.1.3, the node MUST advertise INFINITE_RANK
       within the DODAG iteration if its revised rank would exceed the
       maximum DAG rank increase.

   An implementation may choose to employ this poisoning mechanism when
   a node that loses all of its current parents, i.e. the set of DAG
   parents becomes depleted, and it can not jump onto an alternate DODAG
   An alternate mechanism is to form a floating DODAG.

   The motivation for delaying announcement of the revised route through
   multiple DIO events is to (i) increase tolerance to DIO loss, (ii)
   allow time for the poisoning action to propagate, and (iii) to
   develop an accurate assessment of its new rank.  Such gains are
   obtained at the expense of potentially increasing the delay before
   lower portions of the network are able to re-establish up routes.
   Path redundancy in the DAG reduces the significance of either effect,
   since children with alternate parents should be able to utilize those
   alternates and retain rank while the detached parent re-establishes
   its rank.

   Although an implementation may advertise INFINITE_RANK for the
   purposes of poisoning, it is not expected to be equivalent to setting
   the rank to INFINITE_RANK, and an implementation would likely retain
   its rank value prior to the poisoning in some form, for purpose of
   maintaining its effective position within (L + DAGMaxRankIncrease).



Winter, et al.            Expires June 10, 2010                [Page 35]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


6.3.1.5.  Detaching

   1.  A node that does not have a solution to stay connected to a DODAG
       within a given iteration MAY detach from its current DODAG
       iteration.  A node that detaches becomes root of its own floating
       DODAG and SHOULD immediately advertise its new situation in a DIO
       as an alternate to poisoning.

6.3.1.6.  Following a Parent

   1.  If a node receives a DIO from one of its parents indicating that
       the parent has left the DODAG, it SHOULD stay in its current
       DODAG through an alternate DAG parent if that is possible.  It
       MAY follow that parent.

   A DAG parent may have moved, migrated forward into the next DODAG
   Iteration, or jumped to a different DODAG.  A node should give some
   preference to remaining in the current DODAG if possible, but ought
   to follow the parent if there are no other options.

6.3.2.  DIO Message Communication

   When an DIO message is received from a source device named SRC, the
   receiving node must first determine whether or not the DIO message
   should be accepted for further processing, and subsequently present
   the DIO message for further processing if eligible.

   1.  If the DIO message is malformed, then the DIO message is not
       eligible for further processing and is silently discarded.  A RPL
       implementation MAY log the reception of a malformed DIO message.

   2.  If SRC is a member of the candidate neighbor set, then the DIO is
       eligible for further processing.

6.3.2.1.  DIO Message Processing

      If the node has sent an DIO message within the risk window as
      described in Section 6.7 then a collision has occurred; do not
      process the DIO message any further.

      Process the DIO message as per the rules in Section 6.3

   As DIO messages are received from candidate neighbors, the neighbors
   may be promoted to DAG parents by following the rules of DAG
   discovery as described in Section 6.3.  When a node places a neighbor
   into the DAG Parent set, the node becomes attached to the DODAG
   through the new parent node.




Winter, et al.            Expires June 10, 2010                [Page 36]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   In the DAG discovery implementation, the most preferred parent should
   be used to restrict which other nodes may become DAG parents.  Some
   nodes in the DAG parent set may be of a rank less than or equal to
   the most preferred DAG parent.  (This case may occur, for example, if
   an energy constrained device is at a lesser rank but should be
   avoided as per an optimization objective, resulting in a more
   preferred parent at a greater rank).

6.3.3.  DIO Transmission

   Each node maintains a timer that governs when to multicast DIO
   messages.  This timer is a trickle timer, as detailed in
   Section 6.3.4.  The DIO Configuration Option includes the
   configuration of a DAG Instance's trickle timer.

   o  When a node detects or causes an inconsistency, it MUST reset the
      interval of the trickle timer to a minimum value.

   o  When a node migrates to a new DODAG Iteration it MUST reset the
      trickle timer to its minimum value

   o  When a node detects an inconsistency when forwarding a packet, as
      detailed in Section 6.9, the node MUST reset the trickle timer to
      its minimum value.

   o  When a node receives a multicast DIS message, it MUST reset the
      trickle timer to the minimum value.

   o  When a node receives a unicast DIS message, it MUST unicast a DIO
      message in response, and include the DAG Configuration Object.  In
      this case the node SHOULD NOT reset the trickle timer.

   o  If a node is not a member of a DODAG, it MUST suppress
      transmitting DIO messages.

   o  When a node is initialized, it MAY be configured to remain silent
      and not multicast any DIO messages until it has encountered and
      joined a DODAG (perhaps initially probing for a nearby DODAG with
      an DIS message).  Alternately, it may choose to root its own
      floating DODAG and begin multicasting DIO messages using a default
      trickle configuration.  The second case may be advantageous if it
      is desired for independent nodes to begin aggregating into
      scattered floating DODAGs in the absence of a grounded node, for
      example in support of LLN installation and commissioning.







Winter, et al.            Expires June 10, 2010                [Page 37]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


6.3.4.  Trickle Timer for DIO Transmission

   RPL treats the construction of a DODAG as a consistency problem, and
   uses a trickle timer [Levis08] to control the rate of control
   broadcasts.

   For each DODAG that a node is part of, the node must maintain a
   single trickle timer.  The required state contains the following
   conceptual items:

   I:    The current length of the communication interval

   T:    A timer with a duration set to a random value in the range
         [I/2, I]

   C:    Redundancy Counter

   I_min:  The smallest communication interval in milliseconds.  This
         value is learned from the DIO message as (2^DIOIntervalMin)ms.
         The default value is DEFAULT_DIO_INTERVAL_MIN.

   I_doublings:  The number of times I_min should be doubled before
         maintaining a constant rate, i.e.  I_max = I_min *
         2^I_doublings.  This value is learned from the DIO message as
         DIOIntervalDoublings.  The default value is
         DEFAULT_DIO_INTERVAL_DOUBLINGS.

6.3.4.1.  Resetting the Trickle Timer

   The trickle timer for a DODAG is reset by:

   1.  Setting I_min and I_doublings to the values learned from the DIO
       message.

   2.  Setting C to zero.

   3.  Setting I to I_min.

   4.  Setting T to a random value as described above.

   5.  Restarting the trickle timer to expire after a duration T

   When a node learns about a DODAG through a DIO message and makes the
   decision to join it, it initializes the state of the trickle timer by
   resetting the trickle timer and listening.  Each time it hears a
   redundant DIO message for this DODAG, it MAY increment C. The exact
   determination of redundant is left to an implementation; it could
   include DIOs that advertise the same rank.



Winter, et al.            Expires June 10, 2010                [Page 38]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   When the timer fires at time T, the node compares C to the redundancy
   constant, DIORedundancyConstant.  If C is less than that value, or if
   the DIORedundancyConstant value is 0xFF, the node generates a new DIO
   message and multicasts it.  When the communication interval I
   expires, the node doubles the interval I so long as it has previously
   doubled it fewer than I_doubling times, resets C, and chooses a new T
   value.

6.3.4.2.  Determination of Inconsistency

   The trickle timer is reset whenever an inconsistency is detected
   within the DODAG, for example:

   o  The node joins a new DODAG

   o  The node moves within a DODAG

   o  The node receives a modified DIO message from a DAG parent

   o  A DAG parent forwards a packet intended to move up, indicating an
      inconsistency and possible loop.

   o  A metric communicated in the DIO message is determined to be
      inconsistent, as according to a implementation specific path
      metric selection engine.

   o  The rank of a DAG parent has changed.

6.4.  DAG Selection

   The DAG selection is implementation and algorithm dependent.  Nodes
   SHOULD prefer to join DODAGs for InstanceIDs advertising OCPs and
   destinations compatible with their implementation specific
   objectives.  In order to limit erratic movements, and all metrics
   being equal, nodes SHOULD keep their previous selection.  Also, nodes
   SHOULD provide a means to filter out a parent whose availability is
   detected as fluctuating, at least when more stable choices are
   available.

   When connection to a fixed network is not possible or preferable for
   security or other reasons, scattered DODAGs MAY aggregate as much as
   possible into larger DODAGs in order to allow connectivity within the
   LLN.

   A node SHOULD verify that bidirectional connectivity and adequate
   link quality is available with a candidate neighbor before it
   considers that candidate as a DAG parent.




Winter, et al.            Expires June 10, 2010                [Page 39]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


6.5.  Operation as a Leaf Node

   In some cases it a RPL node may attach to a DODAG for DAG Instance as
   a leaf node only; the node in this case is not to extend connectivity
   to the DODAG to other nodes under any circumstances.  Such a case may
   occur, for example, when a node is attaching to a DODAG that is using
   an unknown Objective Function.  When operating as a leaf node, a
   node:

   1.  MAY receive and process DIOs for that DODAG

   2.  SHOULD NOT transmit DIOs for that DODAG

   3.  MUST NOT transmit DIOs containing the DAG Metric Container for
       that DODAG

   4.  MAY transmit unicast DAOs to the chosen parents for that DODAG

   5.  MAY transmit multicast DAOs to the `1 hop' neighborhood.

6.6.  Administrative rank

   When the DODAG is formed under a common administration, or when a
   node performs a certain role within a community, it might be
   beneficial to associate a range of acceptable rank with that node.
   For instance, a node that has limited battery should be a leaf unless
   there is no other choice, and may then augment the rank computation
   specified by the OF in order to expose an exaggerated rank.

6.7.  Collision

   A race condition occurs if 2 nodes send DIO messages at the same time
   and then attempt to join each other.  This might happen, for example,
   between nodes which act as DAG root of their own DODAGs.  In order to
   detect the situation, LLN Nodes time stamp the sending of DIO
   message.  Any DIO message received within a short link-layer-
   dependent period introduces a risk.  It left to the implementation to
   define the duration of the risk window.

   There is risk of a collision when a node receives and processes a DIO
   within the risk window.  For example, it may occur that two nodes are
   associated with different DODAGs and near-simultaneously send DIO
   messages, which are received and processed by both, and possibly
   result in both nodes simultaneously deciding to attach to each other.
   As a remedy, in the face of a potential collision, as determined by
   receiving a DIO within the risk window, the DIO message is not
   processed.  It is expected that subsequent DIOs would not cross.




Winter, et al.            Expires June 10, 2010                [Page 40]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


6.8.  Establishing Routing State Down the DODAG

   The destination advertisement mechanism supports the dissemination of
   routing state required to support traffic flows down along the DODAG,
   from the DODAG root toward nodes.

   As a result of destination advertisement operation:

   o  Destination advertisement establishes down routes along the DODAG.
      Such paths consist of:
      *  Hop-By-Hop routing state within islands of `stateful' nodes.
      *  Source Routing `bridges' across nodes that do not retain state.

   Destinations disseminated with the destination advertisement
   mechanism may be prefixes, individual hosts, or multicast listeners.
   The mechanism supports nodes of varying capabilities as follows:

   o  When nodes are capable of storing routing state, they may inspect
      destination advertisements and learn hop-by-hop routing state
      toward destinations by populating their routing tables with the
      routes learned from nodes in their sub-DAG.  In this process they
      may also learn necessary piecewise source routes to traverse
      regions of the LLN that do not maintain routing state.  They may
      perform route aggregation on known destinations before emitting
      Destination Advertisements.

   o  When nodes are incapable of storing routing state, they may
      forward destination advertisements, recording the reverse route as
      the go in order to support the construction of piecewise source
      routes.

   Nodes that are capable of storing routing state, and finally the
   DODAG roots, are able to learn which destinations are contained in
   the sub-DAG below the node, and via which next-hop neighbors.  The
   dissemination and installation of this routing state into nodes
   allows for Hop-By-Hop routing from the DODAG root down the DODAG.
   The mechanism is further enhance by supporting the construction of
   source routes across stateless `gaps' in the DODAG, where nodes are
   incapable of storing additional routing state.  An adaptation of this
   mechanism allows for the implementation of loose-source routing.

   A special case, the reception of a destination advertisement
   addressed to a link-local multicast address, allows for a node to
   learn destinations directly available from its one-hop neighbors.

   A design choice behind advertising routes via destination
   advertisements is not to synchronize the parent and children
   databases along the DODAG, but instead to update them regularly to



Winter, et al.            Expires June 10, 2010                [Page 41]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   recover from the loss of packets.  The rationale for that choice is
   time variations in connectivity across unreliable links.  If the
   topology can be expected to change frequently, synchronization might
   be an excessive goal in terms of exchanges and protocol complexity.
   The approach used here results in a simple protocol with no real
   peering.  The destination advertisement mechanism hence provides for
   periodic updates of the routing state, similarly to other protocols
   such as RIP [RFC2453].

6.8.1.  Destination Advertisement Operation

6.8.1.1.  Overview

   According to implementation specific policy, a subset or all of the
   feasible parents in the DODAG may be selected to receive prefix
   information from the destination advertisement mechanism.  This
   subset of DAG parents shall be designated the set of DA parents.

   As DAO messages for particular destinations move up the DODAG, a
   sequence counter is used to guarantee their freshness.  The sequence
   counter is incremented by the source of the DAO message (the node
   that owns the prefix, or learned the prefix via some other means),
   each time it issues a DAO message for its prefix.  Nodes that receive
   the DAO message and, if scope allows, will be forwarding a DAO
   message for the unmodified destination up the DODAG, will leave the
   sequence number unchanged.  Intermediate nodes will check the
   sequence counter before processing a DAO message, and if the DAO is
   unchanged (the sequence counter has not changed), then the DAO
   message will be discarded without additional processing.  Further, if
   the DAO message appears to be out of synch (the sequence counter is 2
   or more behind the present value) then the DAO state is considered to
   be stale and may be purged, and the DAO message is discarded.  The
   rank is also added for tracking purposes; nodes that are storing
   routing state may use it to determine which possible next-hops for
   the destination are more optimal.

   If destination advertisements are activated in the DIO message as
   indicated by the `D' bit, the node sends unicast destination
   advertisements to one of its DA parents, that is selected as most
   favored for incoming down traffic.  The node only accepts unicast
   destination advertisements from any nodes but those contained in the
   DA parent subset.

   Receiving a DIO message with the `D' destination advertisement bit
   set from a DAG parent stimulates the sending of a delayed destination
   advertisement back, with the collection of all known prefixes (that
   is the prefixes learned via destination advertisements for nodes
   lower in the DODAG, and any connected prefixes).  If the Destination



Winter, et al.            Expires June 10, 2010                [Page 42]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   Advertisement Supported (A) bit is set in the DIO message for the
   DODAG, then a destination advertisement is also sent to a DAG parent
   once it has been added to the DA parent set after a movement, or when
   the list of advertised prefixes has changed.

   A node that modifies its DAG Parent set may set the `D' bit in
   subsequent DIO propagation in order to trigger destination
   advertisements to be updated to its DAG Parents and other ancestors
   on the DODAG.  Additional recommendations and guidelines regarding
   the use of this mechanism are still under consideration and will be
   elaborated in a future revision of this specification.

   Destination advertisements may advertise positive (prefix is present)
   or negative (removed) DAO messages, termed as no-DAOs.  A no-DAO is
   stimulated by the disappearance of a prefix below.  This is
   discovered by timing out after a request (a DIO message) or by
   receiving a no-DAO.  A no-DAO is a conveyed as a DAO message with a
   DAO Lifetime of ZERO_LIFETIME.

   A node that is capable of recording the state information conveyed in
   a unicast DAO message will do so upon receiving and processing the
   DAO message, thus provisioning routing state concerning destinations
   located downwards along the DODAG.  If a node capable of recording
   state information receives a DAO message containing a Reverse Route
   Stack, then the node knows that the DAO message has traversed one or
   more nodes that did not retain any routing state as it traversed the
   path from the DAO source to the node.  The node may then extract the
   Reverse Route Stack and retain the included state in order to specify
   Source Routing instructions along the return path towards the
   destination.  The node MUST set the RRCount back to zero and clear
   the Reverse Route Stack prior to passing the DAO message information
   on.

   A node that is unable to record the state information conveyed in the
   DAO message will append the next-hop address to the Reverse Route
   Stack, increment the RRCount, and then pass the destination
   advertisement on without recording any additional state.  In this way
   the Reverse Route Stack will contain a vector of next hops that must
   be traversed along the reverse path that the DAO message has
   traveled.  The vector will be ordered such that the node closest to
   the destination will appear first in the list.  In such cases, if it
   is useful to the implementation to try and provision redundant paths,
   the node may choose to convey the destination advertisement to one or
   more DAG parents in order of preference as guided by an
   implementation specific policy.

   In certain cases (called hybrid cases), some nodes along the path a
   destination advertisement follows up the DODAG may store state and



Winter, et al.            Expires June 10, 2010                [Page 43]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   some may not.  The destination advertisement mechanism allows for the
   provisioning of routing state such that when a packet is traversing
   down the DODAG, some nodes may be able to directly forward to the
   next hop, and other nodes may be able to specify a piecewise source
   route in order to bridge spans of stateless nodes within the path on
   the way to the desired destination.

   In the case where no node is able to store any routing state as
   destination advertisements pass by, and the DAG root ends up with DAO
   messages that contain a completely specified route back to the
   originating node in the form of the inverted Reverse Route Stack.  A
   DAG root should not request (Destination Advertisement Trigger) nor
   indicate support (Destination Advertisement Supported) for
   destination advertisements if it is not able to store the Reverse
   Route Stack information in this case.

   The destination advertisement mechanism requires stateful nodes to
   maintain lists of known prefixes.  A prefix entry contains the
   following abstract information:

   o  A reference to the ND entry that was created for the advertising
      neighbor.

   o  The IPv6 address and interface for the advertising neighbor.

   o  The logical equivalent of the full destination advertisement
      information (including the prefixes, depth, and Reverse Route
      Stack, if any).

   o  A 'reported' Boolean to keep track whether this prefix was
      reported already, and to which of the DA parents.

   o  A counter of retries to count how many DIO messages were sent on
      the interface to the advertising neighbor without reachability
      confirmation for the prefix.

   Note that nodes may receive multiple information from different
   neighbors for a specific destination, as different paths through the
   DODAG may be propagating information up the DODAG for the same
   destination.  A node that is recording routing state will keep track
   of the information from each neighbor independently, and when it
   comes time to propagate the DAO message for a particular prefix to
   the DA parents, then the DAO information will be selected from among
   the advertising neighbors who offer the least depth to the
   destination.

   When a node loses connectivity to a child that is used as next hop
   for a route learned from a DAO, the node should cleanup all routes



Winter, et al.            Expires June 10, 2010                [Page 44]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   and DAO states that are related to that child.  If the lost child was
   the only adjacency leading to the DAO prefix, the node should poison
   the route by sending no-DAOs to the parents to which it has
   advertised the DAO prefixes.

   The destination advertisement mechanism stores the prefix entries in
   one of 3 abstract lists; the Connected, the Reachable and the
   Unreachable lists.

   The Connected list corresponds to the prefixes owned and managed by
   the local node.

   The Reachable list contains prefixes for which the node keeps
   receiving DAO messages, and for those prefixes which have not yet
   timed out.

   The Unreachable list keeps track of prefixes which are no longer
   valid and in the process of being deleted, in order to send DAO
   messages with zero lifetime (also called no-DAO) to the DA parents.

6.8.1.1.1.  Destination Advertisement Timers

   The destination advertisement mechanism requires 2 timers; the
   DelayDAO timer and the RemoveTimer.

   o  The DelayDAO timer is armed upon a stimulation to send a
      destination advertisement (such as a DIO message from a DA
      parent).  When the timer is armed, all entries in the Reachable
      list as well as all entries for Connected list are set to not be
      reported yet for that particular DA parent.

   o  For a root, the DIO timer has a duration of DEF_DAO_LATENCY.  For
      a node in a DODAG iteration, the DelayDAO timer has a duration
      that is randomized between (DEF_DAO_LATENCY divided by the Rank of
      the node) and (DEF_DAO_LATENCY divided by the Rank of the parent).
      The intention is that nodes located deeper in the DODAG iteration
      should have a shorter DelayDAO timer, allowing DAO messages a
      chance to be reported from deeper in the DODAG and potentially
      aggregated along sub-DAGs before propagating further up.

   o  The RemoveTimer is used to clean up entries for which DAO messages
      are no longer being received from the sub-DAG.

      *  When a DIO message is sent that is requesting destination
         advertisements, a flag is set for all DAO entries in the
         routing table.





Winter, et al.            Expires June 10, 2010                [Page 45]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


      *  If the flag has already been set for a DAO entry, the retry
         count is incremented.

      *  If a DAO message is received to confirm the entry, the entry is
         refreshed and the flag and count may be cleared.

      *  If at least one entry has reached a threshold value and the
         RemoveTimer is not running, the entry is considered to be
         probably gone and the RemoveTimer is started.

      *  When the RemoveTimer elapse, DAO messages with lifetime 0, i.e.
         no-DAOs, are sent to explicitly inform DA parents that the
         entries which have reached the threshold are no longer
         available, and the related routing states may be propagated and
         cleaned up.

   o  The RemoveTimer has a duration of min (MAX_DESTROY_INTERVAL,
      TBD(DIO Trickle Timer Interval)).

6.8.1.2.  Multicast Destination Advertisement Messages

   It is also possible for a node to multicast a DAO message to the
   link-local scope all-nodes multicast address FF02::1.  This message
   will be received by all node listening in range of the emitting node.
   The objective is to enable direct P2P communication, between
   destinations directly supported by neighboring nodes, without needing
   the RPL routing structure to relay the packets.

   A multicast DAO message MUST be used only to advertise information
   about self, i.e. prefixes in the Connected list or addresses owned by
   this node.  This would typically be a multicast group that this node
   is listening to or a global address owned by this node, though it can
   be used to advertise any prefix owned by this node as well.  A
   multicast DAO message is not used for routing and does not presume
   any DODAG relationship between the emitter and the receiver; it MUST
   NOT be used to relay information learned (e.g. information in the
   Reachable list) from another node; information obtained from a
   multicast DAO MAY be installed in the routing table and MAY be
   propagated by a router in unicast DAOs.

   A node receiving a multicast DAO message addressed to FF02::1 MAY
   install prefixes contained in the DAO message in the routing table
   for local use.  Such a node MUST NOT perform any other processing on
   the DAO message (i.e. such a node does not presume it is a DA
   parent).






Winter, et al.            Expires June 10, 2010                [Page 46]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


6.8.1.3.  Unicast Destination Advertisement Messages from Child to
          Parent

   When sending a destination advertisement to a DA parent, a node
   includes the DAOs for prefix entries not already reported (since the
   last DA Trigger from an DIO message) in the Reachable and Connected
   lists, as well as no-DAOs for all the entries in the Unreachable
   list.  Depending on its policy and ability to retain routing state,
   the receiving node SHOULD keep a record of the reported DAO message.
   If the DAO message offers the best route to the prefix as determined
   by policy and other prefix records, the node SHOULD install a route
   to the prefix reported in the DAO message via the link local address
   of the reporting neighbor and it SHOULD further propagate the
   information in a DAO message.

   The DIO message from the DODAG root is used to synchronize the whole
   DODAG iteration, including the periodic reporting of destination
   advertisements back up the DODAG.  Its period is expected to vary,
   depending on the configuration of the DIO trickle timer.

   When a node receives a DIO message over an LLN interface from a DA
   parent, the DelayDAO is armed to force a full update.

   When the node broadcasts a DIO message on an LLN interface, for all
   entries on that interface:

   o  If the entry is CONFIRMED, it goes PENDING with the retry count
      set to 0.

   o  If the entry is PENDING, the retry count is incremented.  If it
      reaches a maximum threshold, the entry goes ELAPSED If at least
      one entry is ELAPSED at the end of the process: if the RemoveTimer
      is not running then it is armed with a jitter.

   Since the DelayDAO timer has a duration that decreases with the
   depth, it is expected to receive all DAO messages from all children
   before the timer elapses and the full update is sent to the DA
   parents.

   Once the RemoveTimer is elapsed, the prefix entry is scheduled to be
   removed and moved to the Unreachable list if there are any DA parents
   that need to be informed of the change in status for the prefix,
   otherwise the prefix entry is cleaned up right away.  The prefix
   entry is removed from the Unreachable list when no more DA parents
   need to be informed.  This condition may be satisfied when a no-DAO
   is sent to all current DA parents indicating the loss of the prefix,
   and noting that in some cases parents may have been removed from the
   set of DA parents.



Winter, et al.            Expires June 10, 2010                [Page 47]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


6.8.1.4.  Other Events

   Finally, the destination advertisement mechanism responds to a series
   of events, such as:

   o  Destination advertisement operation stopped: All entries in the
      abstract lists are freed.  All the routes learned from DAO
      messages are removed.

   o  Interface going down: for all entries in the Reachable list on
      that interface, the associated route is removed, and the entry is
      scheduled to be removed.

   o  Loss of routing adjacency: When the routing adjacency for a
      neighbor is lost, as per the procedures described in Section 6.11,
      and if the associated entries are in the Reachable list, the
      associated routes are removed, and the entries are scheduled to be
      destroyed.

   o  Changes to DA parent set: all entries in the Reachable list are
      set to not 'reported' and DelayDAO is armed.

6.8.1.5.  Aggregation of Prefixes by a Node

   There may be number of cases where a aggregation may be shared within
   a group of nodes.  In such a case, it is possible to use aggregation
   techniques with destination advertisements and improve scalability.

   Other cases might occur for which additional support is required:

   1.  The aggregating node is attached within the sub-DAG of the nodes
       it is aggregating for.

   2.  A node that is to be aggregated for is located somewhere else
       within the DODAG iteration, not in the sub-DAG of the aggregating
       node.

   3.  A node that is to be aggregated for is located somewhere else in
       the LLN.

   Consider a node M that is performing an aggregation, and a node N
   that is to be a member of the aggregation group.  A node Z situated
   above the node M in the DODAG, but not above node N, will see the
   advertisements for the aggregation owned by M but not that of the
   individual prefix for N. Such a node Z will route all the packets for
   node N towards node M, but node M will have no route to the node N
   and will fail to forward.




Winter, et al.            Expires June 10, 2010                [Page 48]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   Additional protocols may be applied beyond the scope of this
   specification to dynamically elect/provision an aggregating node and
   groups of nodes eligible to be aggregated in order to provide route
   summarization for a sub-DAG.

6.9.  Loop Detection

   RPL loop avoidance mechanisms are kept simple and designed to
   minimize churn and states.  Loops may form for a number of reasons,
   from control packet loss to sibling forwarding.  RPL includes a
   reactive loop detection technique that protects from meltdown and
   triggers repair of broken paths.

   RPL loop detection uses information that is placed into the packet in
   the IPv6 flow label.  The IPv6 flow label is defined in [RFC2460] and
   its operation is further specified in [RFC3697].  For the purpose of
   RPL operations, the flow label is constructed as follows:


        0                   1                   2
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
               |O|S|R|F|  SenderRank   |  InstanceID   |
               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 12: RPL Flow Label

   Down 'O' bit:  1-bit flag indicating whether the packet is expected
         to progress up or down.  A router sets the 'O' bit when the
         packet is expect to progress down (using DAO routes), and
         resets it when forwarding towards the root of the DODAG
         iteration.  A host MUST set the bit to 0.

   Sibling 'S' bit:  1-bit flag indicating whether the packet has been
         forwarded via a sibling at the present rank, and denotes a risk
         of a sibling loop.  A host sets the bit to 0.

   Rank-Error 'R' bit:  1-bit flag indicating whether a rank error was
         detected.  A rank error is detected when there is a mismatch in
         the relative ranks and the direction as indicated in the 'O'
         bit.  A host MUST set the bit to 0.

   Forwarding-Error 'F' bit:  1-bit flag indicating that this node can
         not forward the packet further towards the destination.  The
         'F' bit might be set by sibling that can not forward to a
         parent a packet with the Sibling 'S' bit set, or by a child
         node that does not have a route to destination for a packet
         with the down 'O' bit set.  A host MUST set the bit to 0.



Winter, et al.            Expires June 10, 2010                [Page 49]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   SenderRank:  8-bit field set to zero by the source and to its rank by
         a router that forwards inside the RPL network.

   InstanceID:  8-bit field indicating the DODAG instance along which
         the packet is sent.

6.9.1.  Source Node Operation

   A packet that is sourced at a node connected to a RPL network or
   destined to a node connected to a RPL network MUST be issued with the
   flow label zeroed out, but for the InstanceID field.

   If the source is aware of the InstanceID that is preferred for the
   flow, then it MUST set the InstanceID field in the flow label
   accordingly, otherwise it MUST set it to the RPL_DEFAULT_INSTANCE.

   If a compression mechanism such as 6LoWPAN is applied to the packet,
   the flow label MUST NOT be compressed even if it is set to all
   zeroes.

6.9.2.  Router Operation

6.9.2.1.  Conformance to RFC 3697

   [RFC3697] mandates that the Flow Label value set by the source MUST
   be delivered unchanged to the destination node(s).

   In order to restore the flow label to its original value, an RPL
   router that delivers a packet to a destination connected to a RPL
   network or that routes a packet outside the RPL network MUST zero out
   all the fields but the InstanceID field that must be delivered
   without a change.

6.9.2.2.  Instance Forwarding

   Instance IDs are used to avoid loops between DODAGs from different
   origins.  DODAGs that constructed for antagonistic constraints might
   contain paths that, if mixed together, would yield loops.  Those
   loops are avoided by forwarding a packet along the DODAG that is
   associated to a given instance.

   The InstanceID is placed by the source in the flow label.  This
   InstanceID MUST match the DODAG instance onto which the packet is
   placed by any node, be it a host or router.

   When a router receives a packet that is flagged with a given
   InstanceID and the node can forward the packet along the DODAG
   associated to that instance, then the router MUST do so and leave the



Winter, et al.            Expires June 10, 2010                [Page 50]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   InstanceID flag unchanged.

   If any node can not forward a packet along the DODAG associated to
   the InstanceID in the flow label, then the node SHOULD discard the
   packet.

6.9.2.3.  DAG Inconsistency Loop Detection

   The DODAG is inconsistent if the direction of a packet does not match
   the rank relationship.  A receiver detects an inconsistency if it
   receives a packet with either:

      the 'O' bit set (to down) from a node of a higher rank.

      the 'O' bit reset (for up) from a node of a lesser rank.

      the 'S' bit set (to sibling) from a node of a different rank.

   When the DODAG root increments the DAG Sequence Number a temporary
   rank discontinuity may form between the next iteration and the prior
   iteration, in particular if nodes are adjusting their rank in the
   next iteration and deferring their migration into the next iteration.
   A router that is still a member of the prior iteration may choose to
   forward a packet to a (future) parent that is in the next iteration.
   In some cases this could cause the parent to detect an inconsistency
   because the rank-ordering in the prior iteration is not necessarily
   the same as in the next iteration and the packet may be judged to not
   be making forward progress.  If the sending router is aware that the
   chosen successor has already joined the next iteration, then the
   sending router MUST update the SenderRank to INFINITE_RANK as it
   forwards the packets across the discontinuity into the next DODAG
   iteration in order to avoid a false detection of rank inconsistency.

   One inconsistency along the path is not considered as a critical
   error and the packet may continue.  But a second detection along the
   path of a same packet should not occur and the packet is dropped.

   This process is controlled by the Rank-Error bit in the Flow Label.
   When an inconsistency, is detected on a packet, if the Rank-Error bit
   was not set then the Rank-Error bit is set.  If it was set the packet
   is discarded and the trickle timer is reset.

6.9.2.4.  Sibling Loop Avoidance

   When a packet is forwarded along siblings, it cannot be checked for
   forward progress and may loop between siblings.  Experimental
   evidence has shown that one sibling hop can be very useful but is
   generally sufficient to avoid loops.  Based on that evidence, this



Winter, et al.            Expires June 10, 2010                [Page 51]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   specification enforces the simple rule that a packet may not make 2
   sibling hops in a row.

   When a host issues a packet or when a router forwards a packet to a
   non-sibling, the Sibling bit in the packet must be reset.  When a
   router forwards to a sibling: if the Sibling bit was not set then the
   Sibling bit is set.  If the Sibling bit was set then then the router
   SHOULD return the packet to the sibling that that passed it with the
   Forwarding-Error 'F' bit set.

6.9.2.5.  DAO Inconsistency Loop Detection and Recovery

   A DAO inconsistency happens when router that has an down DAO route
   via a child that is a remnant from an obsolete state that is not
   matched in the child.  With DAO inconsistency loop recovery, a packet
   can be used to recursively explore and cleanup the obsolete DAO
   states along a sub-DAG.

   In a general manner, a packet that goes down should never go up
   again.  So rather than routing up a packet with the down bit set, the
   router MUST discard the packet.  If DAO inconsistency loop recovery
   is applied, then the router SHOULD send the packet to the parent that
   passed it with the Forwarding-Error 'F' bit set.

6.9.2.6.  Forward Path Recovery

   Upon receiving a packet with a Forwarding-Error bit set, the node
   MUST remove the routing states that caused forwarding to that
   neighbor, clear the Forwarding-Error bit and attempt to send the
   packet again.  The packet may its way to an alternate neighbor.  If
   that alternate neighbor still has an inconsistent DAO state via this
   node, the process will recurse, this node will set the Forwarding-
   Error 'F' bit and the routing state in the alternate neighbor will be
   cleaned up as well.

6.10.  Multicast Operation

   This section describes further the multicast routing operations over
   an IPv6 RPL network, and specifically how unicast DAOs can be used to
   relay group registrations up.  Wherever the following text mentions
   MLD, one can read MLDv2 or v3.

   As is traditional, a listener uses a protocol such as MLD with a
   router to register to a multicast group.

   Along the path between the router and the DODAG root, MLD requests
   are mapped and transported as DAO messages within the RPL protocol;
   each hop coalesces the multiple requests for a same group as a single



Winter, et al.            Expires June 10, 2010                [Page 52]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   DAO message to the parent(s), in a fashion similar to proxy IGMP, but
   recursively between child router and parent up to the root.

   A router might select to pass a listener registration DAO message to
   its preferred parent only, in which case multicast packets coming
   back might be lost for all of its sub-DAG if the transmission fails
   over that link.  Alternatively the router might select to copy
   additional parents as it would do for DAO messages advertising
   unicast destinations, in which case there might be duplicates that
   the router will need to prune.

   As a result, multicast routing states are installed in each router on
   the way from the listeners to the root, enabling the root to copy a
   multicast packet to all its children routers that had issued a DAO
   message including a DAO for that multicast group, as well as all the
   attached nodes that registered over MLD.

   For unicast traffic, it is expected that the grounded root of an
   DODAG terminates RPL and MAY redistribute the RPL routes over the
   external infrastructure using whatever routing protocol is used
   there.  For multicast traffic, the root MAY proxy MLD for all the
   nodes attached to the RPL routers (this would be needed if the
   multicast source is located in the external infrastructure).  For
   such a source, the packet will be replicated as it flows down the
   DODAG based on the multicast routing table entries installed from the
   DAO message.

   For a source inside the DODAG, the packet is passed to the preferred
   parents, and if that fails then to the alternates in the DODAG.  The
   packet is also copied to all the registered children, except for the
   one that passed the packet.  Finally, if there is a listener in the
   external infrastructure then the DODAG root has to further propagate
   the packet into the external infrastructure.

   As a result, the DODAG Root acts as an automatic proxy Rendezvous
   Point for the RPL network, and as source towards the Internet for all
   multicast flows started in the RPL LLN.  So regardless of whether the
   root is actually attached to the Internet, and regardless of whether
   the DODAG is grounded or floating, the root can serve inner multicast
   streams at all times.

6.11.  Maintenance of Routing Adjacency

   The selection of successors, along the default paths up along the
   DODAG, or along the paths learned from destination advertisements
   down along the DODAG, leads to the formation of routing adjacencies
   that require maintenance.




Winter, et al.            Expires June 10, 2010                [Page 53]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   In IGPs such as OSPF [RFC4915] or IS-IS [RFC5120], the maintenance of
   a routing adjacency involves the use of Keepalive mechanisms (Hellos)
   or other protocols such as BFD ([I-D.ietf-bfd-base]) and MANET
   Neighborhood Discovery Protocol (NHDP [I-D.ietf-manet-nhdp]).
   Unfortunately, such an approach is not desirable in constrained
   environments such as LLN and would lead to excessive control traffic
   in light of the data traffic with a negative impact on both link
   loads and nodes resources.  Overhead to maintain the routing
   adjacency should be minimized.  Furthermore, it is not always
   possible to rely on the link or transport layer to provide
   information of the associated link state.  The network layer needs to
   fall back on its own mechanism.

   Thus RPL makes use of a different approach consisting of probing the
   neighbor using a Neighbor Solicitation message (see [RFC4861]).  The
   reception of a Neighbor Advertisement (NA) message with the
   "Solicited Flag" set is used to verify the validity of the routing
   adjacency.  Such mechanism MAY be used prior to sending a data
   packet.  This allows for detecting whether or not the routing
   adjacency is still valid, and should it not be the case, select
   another feasible successor to forward the packet.


7.  Suggestions for Packet Forwarding

   When forwarding a packet to a destination, precedence is given to
   selection of a next-hop successor as follows:

   1.  In the scope of this specification, it is preferred to select a
       successor from a DODAG iteration that matches the InstanceID
       marked in the IPv6 header of the packet being forwarded.

   2.  If a local administrative preference favors a route that has been
       learned from a different routing protocol than RPL, then use that
       successor.

   3.  If there is an entry in the routing table matching the
       destination that has been learned from a multicast destination
       advertisement (e.g. the destination is a one-hop neighbor), then
       use that successor.

   4.  If there is an entry in the routing table matching the
       destination that has been learned from a unicast destination
       advertisement (e.g. the destination is located down the sub-DAG),
       then use that successor.

   5.  If there is a DODAG iteration offering a route to a prefix
       matching the destination, then select one of those DODAG parents



Winter, et al.            Expires June 10, 2010                [Page 54]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


       as a successor.

   6.  If there is a DAG parent offering a default route then select
       that DAG parent as a successor.

   7.  If there is a DODAG iteration offering a route to a prefix
       matching the destination, but all DAG parents have been tried and
       are temporarily unavailable (as determined by the forwarding
       procedure), then select a DAG sibling as a successor.

   8.  Finally, if no DAG siblings are available, the packet is dropped.
       ICMP Destination Unreachable may be invoked.  An inconsistency is
       detected.

   TTL MUST be decremented when forwarding.  If the packet is being
   forwarded via a sibling, then the TTL MAY be decremented more
   aggressively (by more than one) to limit the impact of possible
   loops.

   Note that the chosen successor MUST NOT be the neighbor that was the
   predecessor of the packet (split horizon), except in the case where
   it is intended for the packet to change from an up to an down flow,
   such as switching from DIO routes to DAO routes as the destination is
   neared.


8.  Guidelines for Objective Functions

   An Objective Function (OF) allows for the selection of a DODAG to
   join, and a number of peers in that DAG as parents.  The OF is used
   to compute an ordered list of parents.  The OF is also responsible to
   compute the rank of the device within the DODAG iteration.

   The Objective Function is indicated in the DIO message using an
   Objective Code Point (OCP), as specified in
   [I-D.ietf-roll-routing-metrics], and indicates the method that must
   be used to compute the DODAG (e.g. "minimize the path cost using the
   ETX metric and avoid `Blue' links").  The Objective Code Points are
   specified in [I-D.ietf-roll-routing-metrics] and related companion
   specifications.

   Most Objective Functions are expected to follow the same abstract
   behavior:

   o  The parent selection is triggered each time an event indicates
      that a potential next hop information is updated.  This might
      happen upon the reception of a DIO message, a timer elapse, or a
      trigger indicating that the state of a candidate neighbor has



Winter, et al.            Expires June 10, 2010                [Page 55]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


      changed.

   o  An OF scans all the interfaces on the device.  Although there may
      typically be only one interface in most application scenarios,
      there might be multiple of them and an interface might be
      configured to be usable or not for RPL operation.  An interface
      can also be configured with a preference or dynamically learned to
      be better than another by some heuristics that might be link-layer
      dependent and are out of scope.  Finally an interface might or not
      match a required criterion for an Objective Function, for instance
      a degree of security.  As a result some interfaces might be
      completely excluded from the computation, while others might be
      more or less preferred.

   o  An OF scans all the candidate neighbors on the possible interfaces
      to check whether they can act as a router for a DODAG.  There
      might be multiple of them and a candidate neighbor might need to
      pass some validation tests before it can be used.  In particular,
      some link layers require experience on the activity with a router
      to enable the router as a next hop.

   o  An OF computes self's rank by adding the step of rank to that
      candidate to the rank of that candidate.  The step of rank is
      computed by estimating the link as follows:

      *  The step of rank might vary from 1 to 16.

         +  1 indicates a unusually good link, for instance a link
            between powered devices in a mostly battery operated
            environment.

         +  4 indicates a `normal'/typical link, as qualified by the
            implementation.

         +  16 indicates a link that can hardly be used to forward any
            packet, for instance a radio link with quality indicator or
            expected transmission count that is close to the acceptable
            threshold.

      *  Candidate neighbors that would cause self's rank to increase
         are ignored

   o  Candidate neighbors that advertise an OF incompatible with the set
      of OF specified by the policy functions are ignored.

   o  As it scans all the candidate neighbors, the OF keeps the current
      best parent and compares its capabilities with the current
      candidate neighbor.  The OF defines a number of tests that are



Winter, et al.            Expires June 10, 2010                [Page 56]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


      critical to reach the objective.  A test between the routers
      determines an order relation.

      *  If the routers are roughly equal for that relation then the
         next test is attempted between the routers,

      *  Else the best of the 2 becomes the current best parent and the
         scan continues with the next candidate neighbor

      *  Some OFs may include a test to compare the ranks that would
         result if the node joined either router

   o  When the scan is complete, the preferred parent is elected and
      self's rank is computed as the preferred parent rank plus the step
      in rank with that parent.

   o  Other rounds of scans might be necessary to elect alternate
      parents and siblings.  In the next rounds:

      *  Candidate neighbors that are not in the same DODAG are ignored

      *  Candidate neighbors that are of greater rank than self are
         ignored

      *  Candidate neighbors of an equal rank to self (siblings) are
         ignored

      *  Candidate neighbors of a lesser rank than self (non-siblings)
         are preferred


9.  RPL Constants and Variables

   Following is a summary of RPL constants and variables.  Some default
   values are to be determined in companion applicability statements.

   ZERO_LIFETIME  This is the special value of a lifetime that indicates
         immediate death and removal.  ZERO_LIFETIME has a value of 0.

   BASE_RANK  This is the rank for a virtual root that might be used to
         coordinate multiple roots.  BASE_RANK has a value of 0.

   ROOT_RANK  This is the rank for a DAG root.  ROOT_RANK has a value of
         1.







Winter, et al.            Expires June 10, 2010                [Page 57]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   INFINITE_RANK  This is the constant maximum for the rank.
         INFINITE_RANK has a value of 0xFF.

   RPL_DEFAULT_INSTANCE  This is the InstanceID that is used by this
         protocol by a node without any overriding policy.
         RPL_DEFAULT_INSTANCE has a value of 0.

   DEFAULT_DIO_INTERVAL_MIN  To be determined

   DEFAULT_DIO_INTERVAL_DOUBLINGS  To be determined

   DEFAULT_DIO_REDUNDANCY_CONSTANT  To be determined

   DEF_DAO_LATENCY  To be determined

   MAX_DESTROY_INTERVAL  To be determined

   DIO Timer  One instance per DODAG that a node is a member of.  Expiry
         triggers DIO message transmission.  Trickle timer with variable
         interval in [0, DIOIntervalMin..2^DIOIntervalDoublings].  See
         Section 6.3.4

   DAG Sequence Number Increment Timer  Up to one instance per DODAG
         that the node is acting as DAG root of.  May not be supported
         in all implementations.  Expiry triggers revision of
         DAGSequenceNumber, causing a new series of updated DIO message
         to be sent.  Interval should be chosen appropriate to
         propagation time of DODAG and as appropriate to application
         requirements (e.g. response time vs. overhead).

   DelayDAO Timer  Up to one instance per DA parent (the subset of DAG
         parents chosen to receive destination advertisements) per
         DODAG.  Expiry triggers sending of DAO message to the DA
         parent.  The interval is to be proportional to DEF_DAO_LATENCY/
         (node rank), such that nodes of greater rank (further down
         along the DODAG) expire first, coordinating the sending of DAO
         messages to allow for a chance of aggregation.  See
         Section 6.8.1.1.1

   RemoveTimer  Up to one instance per DA entry per neighbor (i.e. those
         neighbors that have given DAO messages to this node as a DAG
         parent) Expiry triggers a change in state for the DA entry,
         setting up to do unreachable (No-DAO) advertisements or
         immediately deallocating the DA entry if there are no DA
         parents.  The interval is min(MAX_DESTROY_INTERVAL, TBD(DIO
         Trickle Timer Interval)).  See Section 6.8.1.1.1





Winter, et al.            Expires June 10, 2010                [Page 58]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


10.  Manageability Considerations

   The aim of this section is to give consideration to the manageability
   of RPL, and how RPL will be operated in LLN beyond the use of a MIB
   module.  The scope of this section is to consider the following
   aspects of manageability: fault management, configuration, accounting
   and performance.

10.1.  Control of Function and Policy

10.1.1.  Initialization Mode

   When a node is first powered up, it may either choose to stay silent
   and not send any multicast DIO message until it has joined a DODAG,
   or to immediately root a transient DODAG and start sending multicast
   DIO messages.  A RPL implementation SHOULD allow configuring whether
   the node should stay silent or should start advertising DIO messages.

   Furthermore, the implementation SHOULD to allow configuring whether
   or not the node should start sending an DIS message as an initial
   probe for nearby DODAGs, or should simply wait until it received DIO
   messages from other nodes that are part of existing DODAGs.

10.1.2.  DIO Base option

   RPL specifies a number of protocol parameters.

   A RPL implementation SHOULD allow configuring the following routing
   protocol parameters, which are further described in Section 6.1.3.1:

   DAGPreference
   InstanceID
   DAGObjectiveCodePoint
   DAGID
   Destination Prefixes
   DIOIntervalDoublings
   DIOIntervalMin
   DIORedundancyConstant

   DAG Root behavior:  In some cases, a node may not want to permanently
         act as a DAG root if it cannot join a grounded DODAG.  For
         example a battery-operated node may not want to act as a DAG
         root for a long period of time.  Thus a RPL implementation MAY
         support the ability to configure whether or not a node could
         act as a DAG root for a configured period of time.






Winter, et al.            Expires June 10, 2010                [Page 59]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009



   DAG Table Entry Suppression  A RPL implementation SHOULD provide the
         ability to configure a timer after the expiration of which the
         DAG table that contains all the records about a DAG is
         suppressed, to be invoked if the DAG parent set becomes empty.

10.1.3.  Trickle Timers

   A RPL implementation makes use of trickle timer to govern the sending
   of DIO message.  Such an algorithm is determined a by a set of
   configurable parameters that are then advertised by the DAG root
   along the DODAG in DIO messages.

   For each DODAG, a RPL implementation MUST allow for the monitoring of
   the following parameters, further described in Section 6.3.4:

   I
   T
   C
   I_min
   I_doublings

   A RPL implementation SHOULD provide a command (for example via API,
   CLI, or SNMP MIB) whereby any procedure that detects an inconsistency
   may cause the trickle timer to reset.

10.1.4.  DAG Sequence Number Increment

   A RPL implementation may allow by configuration at the DAG root to
   refresh the DODAG states by updating the DAGSequenceNumber.  A RPL
   implementation SHOULD allow configuring whether or not periodic or
   event triggered mechanism are used by the DAG root to control
   DAGSequenceNumber change.

10.1.5.  Destination Advertisement Timers

   The following set of parameters of the DAO messages SHOULD be
   configurable:

   o  The DelayDAO timer

   o  The Remove timer

10.1.6.  Policy Control

   DAG discovery enables nodes to implement different policies for
   selecting their DAG parents.




Winter, et al.            Expires June 10, 2010                [Page 60]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   A RPL implementation SHOULD allow configuring the set of acceptable
   or preferred Objective Functions (OF) referenced by their Objective
   Codepoints (OCPs) for a node to join a DODAG, and what action should
   be taken if none of a node's candidate neighbors advertise one of the
   configured allowable Objective Functions.

   A node in an LLN may learn routing information from different routing
   protocols including RPL.  It is in this case desirable to control via
   administrative preference which route should be favored.  An
   implementation SHOULD allow for specifying an administrative
   preference for the routing protocol from which the route was learned.

   A RPL implementation SHOULD allow for the configuration of the "Route
   Tag" field of the DAO messages according to a set of rules defined by
   policy.

10.1.7.  Data Structures

   Some RPL implementation may limit the size of the candidate neighbor
   list in order to bound the memory usage, in which case some otherwise
   viable candidate neighbors may not be considered and simply dropped
   from the candidate neighbor list.

   A RPL implementation MAY provide an indicator on the size of the
   candidate neighbor list.

10.2.  Information and Data Models

   The information and data models necessary for the operation of RPL
   will be defined in a separate document specifying the RPL SNMP MIB.

10.3.  Liveness Detection and Monitoring

   The aim of this section is to describe the various RPL mechanisms
   specified to monitor the protocol.

   As specified in Section 6.2, an implementation is expected to
   maintain a set of data structures in support of DAG discovery:

   o  The candidate neighbors data structure

   o  For each DODAG:

      *  A set of DAG parents







Winter, et al.            Expires June 10, 2010                [Page 61]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


10.3.1.  Candidate Neighbor Data Structure

   A node in the candidate neighbor list is a node discovered by the
   some means and qualified to potentially become of neighbor or a
   sibling (with high enough local confidence).  A RPL implementation
   SHOULD provide a way monitor the candidate neighbors list with some
   metric reflecting local confidence (the degree of stability of the
   neighbors) measured by some metrics.

   A RPL implementation MAY provide a counter reporting the number of
   times a candidate neighbor has been ignored, should the number of
   candidate neighbors exceeds the maximum authorized value.

10.3.2.  Directed Acyclic Graph (DAG) Table

   For each DAG, a RPL implementation is expected to keep track of the
   following DODAG table values:

   o  DAGID

   o  DAGObjectiveCodePoint

   o  A set of Destination Prefixes offered upwards along the DODAG

   o  A set of DAG Parents

   o  timer to govern the sending of DIO messages for the DODAG

   o  DAGSequenceNumber

   The set of DAG parents structure is itself a table with the following
   entries:

   o  A reference to the neighboring device which is the DAG parent

   o  A record of most recent information taken from the DAG Information
      Object last processed from the DAG Parent

   o  A flag reporting if the Parent is a DA Parent as described in
      Section 6.8

10.3.3.  Routing Table

   For each route provisioned by RPL operation, a RPL implementation
   MUST keep track of the following:






Winter, et al.            Expires June 10, 2010                [Page 62]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   o  Destination Prefix

   o  Destination Prefix Length

   o  Lifetime Timer

   o  Next Hop

   o  Next Hop Interface

   o  Flag indicating that the route was provisioned from one of:

      *  Unicast DAO message

      *  DIO message

      *  Multicast DAO message

10.3.4.  Other RPL Monitoring Parameters

   A RPL implementation SHOULD provide a counter reporting the number of
   a times the node has detected an inconsistency with respect to a DAG
   parent, e.g. if the DAGID has changed.

   A RPL implementation MAY log the reception of a malformed DIO message
   along with the neighbor identification if avialable.

10.3.5.  RPL Trickle Timers

   A RPL implementation operating on a DAG root MUST allow for the
   configuration of the following trickle parameters:

   o  The DIOIntervalMin expressed in ms

   o  The DIOIntervalDoublings

   o  The DIORedundancyConstant

   A RPL implementation MAY provide a counter reporting the number of
   times an inconsistency (and thus the trickle timer has been reset).

10.4.  Verifying Correct Operation

   This section has to be completed in further revision of this document
   to list potential Operations and Management (OAM) tools that could be
   used for verifying the correct operation of RPL.





Winter, et al.            Expires June 10, 2010                [Page 63]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


10.5.  Requirements on Other Protocols and Functional Components

   RPL does not have any impact on the operation of existing protocols.

10.6.  Impact on Network Operation

   To be completed.


11.  Security Considerations

   Security Considerations for RPL are to be developed in accordance
   with recommendations laid out in, for example,
   [I-D.tsao-roll-security-framework].


12.  IANA Considerations

12.1.  RPL Control Message

   The RPL Control Message is an ICMP information message type that is
   to be used carry DAG Information Objects, DAG Information
   Solicitations, and Destination Advertisement Objects in support of
   RPL operation.

   IANA has defined a ICMPv6 Type Number Registry.  The suggested type
   value for the RPL Control Message is 155, to be confirmed by IANA.

12.2.  New Registry for RPL Control Codes

   IANA is requested to create a registry, RPL Control Codes, for the
   Code field of the ICMPv6 RPL Control Message.

   New codes may be allocated only by an IETF Consensus action.  Each
   code should be tracked with the following qualities:

   o  Code

   o  Description

   o  Defining RFC

   Three codes are currently defined:








Winter, et al.            Expires June 10, 2010                [Page 64]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


        +------+----------------------------------+---------------+
        | Code | Description                      | Reference     |
        +------+----------------------------------+---------------+
        | 0x01 | DAG Information Solicitation     | This document |
        | 0x02 | DAG Information Object           | This document |
        | 0x04 | Destination Advertisement Object | This document |
        +------+----------------------------------+---------------+

                             RPL Control Codes

12.3.  New Registry for the Control Field of the DIO Base

   IANA is requested to create a registry for the Control field of the
   DIO Base.

   New bit numbers may be allocated only by an IETF Consensus action.
   Each bit should be tracked with the following qualities:

   o  Bit number (counting from bit 0 as the most significant bit)

   o  Capability description

   o  Defining RFC

   Four groups are currently defined:

      +-------+-------------------------------------+---------------+
      |  Bit  | Description                         | Reference     |
      +-------+-------------------------------------+---------------+
      |   0   | Grounded DODAG                      | This document |
      |   1   | Destination Advertisement Trigger   | This document |
      |   2   | Destination Advertisement Supported | This document |
      | 5,6,7 | DAG Preference                      | This document |
      +-------+-------------------------------------+---------------+

                              DIO Base Flags

12.4.  DAG Information Object (DIO) Suboption

   IANA is requested to create a registry for the DIO Base Suboptions











Winter, et al.            Expires June 10, 2010                [Page 65]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


         +-------+------------------------------+---------------+
         | Value | Meaning                      | Reference     |
         +-------+------------------------------+---------------+
         |   0   | Pad1 - DIO Padding           | This document |
         |   1   | PadN - DIO suboption padding | This document |
         |   2   | DAG Metric Container         | This Document |
         |   3   | Destination Prefix           | This Document |
         |   4   | DAG Timer Configuration      | This Document |
         +-------+------------------------------+---------------+

               DAG Information Option (DIO) Base Suboptions


13.  Acknowledgements

   The authors would like to acknowledge the review, feedback, and
   comments from Emmanuel Baccelli, Dominique Barthel, Yusuf Bashir,
   Mathilde Durvy, Manhar Goindi, Mukul Goyal, Anders Jagd, Quentin
   Lampin, Jerry Martocci, Alexandru Petrescu, and Don Sturek.

   The authors would like to acknowledge the guidance and input provided
   by the ROLL Chairs, David Culler and JP Vasseur.

   The authors would like to acknowledge prior contributions of Robert
   Assimiti, Mischa Dohler, Julien Abeille, Ryuji Wakikawa, Teco Boot,
   Patrick Wetterwald, Bryan Mclaughlin, Carlos J. Bernardos, Thomas
   Watteyne, Zach Shelby, Caroline Bontoux, Marco Molteni, Billy Moon,
   and Arsalan Tavakoli, which have provided useful design
   considerations to RPL.


14.  Contributors

   RPL is the result of the contribution of the following members of the
   ROLL Design Team, including the editors, and additional contributors
   as listed below:

   JP Vasseur
   Cisco Systems, Inc
   11, Rue Camille Desmoulins
   Issy Les Moulineaux,   92782
   France

   Email: jpv@cisco.com


   Jonathan W. Hui
   Arch Rock Corporation



Winter, et al.            Expires June 10, 2010                [Page 66]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   501 2nd St. Ste. 410
   San Francisco, CA  94107
   USA

   Email: jhui@archrock.com


   Thomas Heide Clausen
   LIX, Ecole Polytechnique, France

   Phone: +33 6 6058 9349
   EMail: T.Clausen@computer.org
   URI:   http://www.ThomasClausen.org/


   Philip Levis
   Stanford University
   358 Gates Hall, Stanford University
   Stanford, CA  94305-9030
   USA

   Email: pal@cs.stanford.edu


   Richard Kelsey
   Ember Corporation
   Boston, MA
   USA

   Phone: +1 617 951 1225
   Email: kelsey@ember.com


   Stephen Dawson-Haggerty
   UC Berkeley
   Soda Hall, UC Berkeley
   Berkeley, CA  94720
   USA

   Email: stevedh@cs.berkeley.edu


   Kris Pister
   Dust Networks
   30695 Huntwood Ave.
   Hayward,   94544
   USA




Winter, et al.            Expires June 10, 2010                [Page 67]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   Email: kpister@dustnetworks.com


   Anders Brandt
   Zensys, Inc.
   Emdrupvej 26
   Copenhagen, DK-2100
   Denmark

   Email: abr@zen-sys.com


15.  References

15.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 2460, December 1998.

15.2.  Informative References

   [I-D.ietf-bfd-base]
              Katz, D. and D. Ward, "Bidirectional Forwarding
              Detection", draft-ietf-bfd-base-09 (work in progress),
              February 2009.

   [I-D.ietf-manet-nhdp]
              Clausen, T., Dearlove, C., and J. Dean, "Mobile Ad Hoc
              Network (MANET) Neighborhood Discovery Protocol (NHDP)",
              draft-ietf-manet-nhdp-11 (work in progress), October 2009.

   [I-D.ietf-roll-building-routing-reqs]
              Martocci, J., Riou, N., Mil, P., and W. Vermeylen,
              "Building Automation Routing Requirements in Low Power and
              Lossy Networks", draft-ietf-roll-building-routing-reqs-08
              (work in progress), December 2009.

   [I-D.ietf-roll-home-routing-reqs]
              Brandt, A. and J. Buron, "Home Automation Routing
              Requirements in Low Power and Lossy Networks",
              draft-ietf-roll-home-routing-reqs-09 (work in progress),
              November 2009.

   [I-D.ietf-roll-routing-metrics]
              Vasseur, J. and D. Networks, "Routing Metrics used for



Winter, et al.            Expires June 10, 2010                [Page 68]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


              Path Calculation in Low Power and Lossy Networks",
              draft-ietf-roll-routing-metrics-04 (work in progress),
              December 2009.

   [I-D.ietf-roll-terminology]
              Vasseur, J., "Terminology in Low power And Lossy
              Networks", draft-ietf-roll-terminology-02 (work in
              progress), October 2009.

   [I-D.tsao-roll-security-framework]
              Tsao, T., Alexander, R., Dohler, M., Daza, V., and A.
              Lozano, "A Security Framework for Routing over Low Power
              and Lossy Networks", draft-tsao-roll-security-framework-01
              (work in progress), September 2009.

   [Levis08]  Levis, P., Brewer, E., Culler, D., Gay, D., Madden, S.,
              Patel, N., Polastre, J., Shenker, S., Szewczyk, R., and A.
              Woo, "The Emergence of a Networking Primitive in Wireless
              Sensor Networks", Communications of the ACM, v.51 n.7,
              July 2008,
              <http://portal.acm.org/citation.cfm?id=1364804>.

   [RFC1982]  Elz, R. and R. Bush, "Serial Number Arithmetic", RFC 1982,
              August 1996.

   [RFC2453]  Malkin, G., "RIP Version 2", STD 56, RFC 2453,
              November 1998.

   [RFC3697]  Rajahalme, J., Conta, A., Carpenter, B., and S. Deering,
              "IPv6 Flow Label Specification", RFC 3697, March 2004.

   [RFC3819]  Karn, P., Bormann, C., Fairhurst, G., Grossman, D.,
              Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L.
              Wood, "Advice for Internet Subnetwork Designers", BCP 89,
              RFC 3819, July 2004.

   [RFC4101]  Rescorla, E. and IAB, "Writing Protocol Models", RFC 4101,
              June 2005.

   [RFC4191]  Draves, R. and D. Thaler, "Default Router Preferences and
              More-Specific Routes", RFC 4191, November 2005.

   [RFC4443]  Conta, A., Deering, S., and M. Gupta, "Internet Control
              Message Protocol (ICMPv6) for the Internet Protocol
              Version 6 (IPv6) Specification", RFC 4443, March 2006.

   [RFC4861]  Narten, T., Nordmark, E., Simpson, W., and H. Soliman,
              "Neighbor Discovery for IP version 6 (IPv6)", RFC 4861,



Winter, et al.            Expires June 10, 2010                [Page 69]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


              September 2007.

   [RFC4915]  Psenak, P., Mirtorabi, S., Roy, A., Nguyen, L., and P.
              Pillay-Esnault, "Multi-Topology (MT) Routing in OSPF",
              RFC 4915, June 2007.

   [RFC5120]  Przygienda, T., Shen, N., and N. Sheth, "M-ISIS: Multi
              Topology (MT) Routing in Intermediate System to
              Intermediate Systems (IS-ISs)", RFC 5120, February 2008.

   [RFC5548]  Dohler, M., Watteyne, T., Winter, T., and D. Barthel,
              "Routing Requirements for Urban Low-Power and Lossy
              Networks", RFC 5548, May 2009.

   [RFC5673]  Pister, K., Thubert, P., Dwars, S., and T. Phinney,
              "Industrial Routing Requirements in Low-Power and Lossy
              Networks", RFC 5673, October 2009.


Appendix A.  Requirements

A.1.  Protocol Properties Overview

   RPL demonstrates the following properties, consistent with the
   requirements specified by the application-specific requirements
   documents.

A.1.1.  IPv6 Architecture

   RPL is strictly compliant with layered IPv6 architecture.

   Further, RPL is designed with consideration to the practical support
   and implementation of IPv6 architecture on devices which may operate
   under severe resource constraints, including but not limited to
   memory, processing power, energy, and communication.  The RPL design
   does not presume high quality reliable links, and operates over lossy
   links (usually low bandwidth with low packet delivery success rate).

A.1.2.  Typical LLN Traffic Patterns

   Multipoint-to-Point (MP2P) and Point-to-multipoint (P2MP) traffic
   flows from nodes within the LLN from and to egress points are very
   common in LLNs.  Low power and lossy network Border Router (LBR)
   nodes may typically be at the root of such flows, although such flows
   are not exclusively rooted at LBRs as determined on an application-
   specific basis.  In particular, several applications such as building
   or home automation do require P2P (Point-to-Point) communication.




Winter, et al.            Expires June 10, 2010                [Page 70]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   As required by the aforementioned routing requirements documents, RPL
   supports the installation of multiple paths.  The use of multiple
   paths include sending duplicated traffic along diverse paths, as well
   as to support advanced features such as Class of Service (CoS) based
   routing, or simple load balancing among a set of paths (which could
   be useful for the LLN to spread traffic load and avoid fast energy
   depletion on some, e.g. battery powered, nodes).  Conceptually,
   multiple instances of RPL can be used to send traffic along different
   topology instances, the construction of which is governed by
   different Objective Functions (OF).  Details of RPL operation in
   support of multiple instances are beyond the scope of the present
   specification.

A.1.3.  Constraint Based Routing

   The RPL design supports constraint based routing, based on a set of
   routing metrics and constraints.  The routing metrics and constraints
   for links and nodes with capabilities supported by RPL are specified
   in a companion document to this specification,
   [I-D.ietf-roll-routing-metrics].  RPL signals the metrics,
   constraints, and related Objective Functions (OFs) in use in a
   particular implementation by means of an Objective Code Point (OCP).
   Both the routing metrics, constraints, and the OF help determine the
   construction of the Directed Acyclic Graphs (DAG) using a distributed
   path computation algorithm.

A.2.  Deferred Requirements

   NOTE: RPL is still a work in progress.  At this time there remain
   several unsatisfied application requirements, but these are to be
   addressed as RPL is further specified.


Appendix B.  Examples

   Consider the example LLN physical topology in Figure 13.  In this
   example the links depicted are all usable L2 links.  Suppose that all
   links are equally usable, and that the implementation specific policy
   function is simply to minimize hops.  This LLN physical topology then
   yields the DAG depicted in Figure 14, where the links depicted are
   the edges toward DAG parents.  This topology includes one DAG, rooted
   by an LBR node (LBR) at rank 1.  The LBR node will issue DIO
   messages, as governed by a trickle timer.  Nodes (11), (12), (13),
   have selected (LBR) as their only parent, attached to the DAG at rank
   2, and periodically multicast DIOs.  Node (22) has selected (11) and
   (12) in its DAG parent set, and advertises itself at rank 3.  Node
   (22) thus has a set of DAG parents {(11), (12)} and siblings {((21),
   (23)}.



Winter, et al.            Expires June 10, 2010                [Page 71]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


                                     (LBR)
                                     / | \
                                .---`  |  `----.
                               /       |        \
                            (11)------(12)------(13)
                             | \       | \       | \
                             |  `----. |  `----. |  `----.
                             |        \|        \|        \
                            (21)------(22)------(23)      (24)
                             |        /|        /|         |
                             |  .----` |  .----` |         |
                             | /       | /       |         |
                            (31)------(32)------(33)------(34)
                             |        /| \       | \       | \
                             |  .----` |  `----. |  `----. |  `----.
                             | /       |        \|        \|        \
                   .--------(41)      (42)      (43)------(44)------(45)
                  /         /         /| \       | \
            .----`    .----`    .----` |  `----. |  `----.
           /         /         /       |        \|        \
        (51)------(52)------(53)------(54)------(55)------(56)


   Note that the links depicted represent the usable L2 connectivity
   available in the LLN.  For example, Node (31) can communicate
   directly with its neighbors, Nodes (21), (22), (32), and (41).  Node
   (31) cannot communicate directly with any other nodes, e.g. (33),
   (23), (42).  In this example these links offer bidirectional
   communication, and `bad' links are not depicted.

                      Figure 13: Example LLN Topology




















Winter, et al.            Expires June 10, 2010                [Page 72]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


                                     (LBR)
                                     / | \
                                .---`  |  `----.
                               /       |        \
                            (11)      (12)      (13)
                             | \       | \       | \
                             |  `----. |  `----. |  `----.
                             |        \|        \|        \
                            (21)      (22)      (23)      (24)
                             |        /|        /|         |
                             |  .----` |  .----` |         |
                             | /       | /       |         |
                            (31)      (32)      (33)      (34)
                             |        /| \       | \       | \
                             |  .----` |  `----. |  `----. |  `----.
                             | /       |        \|        \|        \
                   .--------(41)      (42)      (43)      (44)      (45)
                  /         /         /| \       | \
            .----`    .----`    .----` |  `----. |  `----.
           /         /         /       |        \|        \
        (51)      (52)      (53)      (54)      (55)      (56)


   Note that the links depicted represent directed links in the DAG
   overlaid on top of the physical topology depicted in Figure 13.  As
   such, the depicted edges represent the relationship between nodes and
   their DAG parents, wherein all depicted edges are directed and
   oriented `up' on the page toward the DAG root (LBR).  The DAG may
   provide default routes within the LLN, and serves as the foundation
   on which RPL builds further routing structure, e.g. through the
   destination advertisement mechanism.

                          Figure 14: Example DAG

B.1.  Destination Advertisement

   Consider the example DAG depicted in Figure 14.  Suppose that Nodes
   (22) and (32) are unable to record routing state.  Suppose that Node
   (42) is able to perform prefix aggregation on behalf of Nodes (53),
   (54), and (55).

   o  Node (53) would send a DAO message to Node (42), indicating the
      availability of destination (53).

   o  Node (54) and Node (55) would similarly send DAO messages to Node
      (42) indicating their own destinations.





Winter, et al.            Expires June 10, 2010                [Page 73]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   o  Node (42) would collect and store the routing state for
      destinations (53), (54), and (55).

   o  In this example, Node (42) may then be capable of representing
      destinations (42), (53), (54), and (55) in the aggregation (42').

   o  Node (42) sends a DAO message advertising destination (42') to
      Node 32.

   o  Node (32) does not want to maintain any routing state, so it adds
      onto to the Reverse Route Stack in the DAO message and passes it
      on to Node (22) as (42'):[(42)].  It may send a separate DAO
      message to indicate destination (32).

   o  Node (22) does not want to maintain any routing state, so it adds
      on to the Reverse Route Stack in the DAO message and passes it on
      to Node (12) as (42'):[(42), (32)].  It also relays the DAO
      message containing destination (32) to Node 12 as (32):[(32)], and
      finally may send a DAO message for itself indicating destination
      (22).

   o  Node (12) is capable to maintain routing state again, and receives
      the DAO messages from Node (22).  Node (12) then learns:
      *  Destination (22) is available via Node (22)
      *  Destination (32) is available via Node (22) and the piecewise
         source route to (32)
      *  Destination (42') is available via Node (22) and the piecewise
         source route to (32), (42').

   o  Node (12) sends DAO messages to (LBR), allowing (LBR) to learn
      routes to the destinations (12), (22), (32), and (42'). (42),
      (53), (54), and (55) are available via the aggregation (42').  It
      is not necessary for Node (12) to propagate the piecewise source
      routes to (LBR).

B.2.  Example: DAG Parent Selection

   For example, suppose that a node (N) is not attached to any DAG, and
   that it is in range of nodes (A), (B), (C), (D), and (E).  Let all
   nodes be configured to use an OCP which defines a policy such that
   ETX is to be minimized and paths with the attribute `Blue' should be
   avoided.  Let the rank computation indicated by the OCP simply
   reflect the ETX aggregated along the path.  Let the links between
   node (N) and its neighbors (A-E) all have an ETX of 1 (which is
   learned by node (N) through some implementation specific method).
   Let node (N) be configured to send RPL DIS messages to probe for
   nearby DAGs.




Winter, et al.            Expires June 10, 2010                [Page 74]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   o  Node (N) transmits a RPL DIS message.

   o  Node (B) responds.  Node (N) investigates the DIO message, and
      learns that Node (B) is a member of DAGID 1 at rank 4, and not
      `Blue'.  Node (N) takes note of this, but is not yet confident.

   o  Similarly, Node (N) hears from Node (A) at rank 9, Node (C) at
      rank 5, and Node (E) at rank 4.

   o  Node (D) responds.  Node (D) has a DIO message that indicates that
      it is a member of DAGID 1 at rank 2, but it carries the attribute
      `Blue'.  Node (N)'s policy function rejects Node (D), and no
      further consideration is given.

   o  This process continues until Node (N), based on implementation
      specific policy, builds enough confidence to trigger a decision to
      join DAGID 1.  Let Node (N) determine its most preferred parent to
      be Node (E).

   o  Node (N) adds Node (E) (rank 4) to its set of DAG parents for
      DAGID 1.  Following the mechanisms specified by the OCP, and given
      that the ETX is 1 for the link between (N) and (E), Node (N) is
      now at rank 5 in DAGID 1.

   o  Node (N) adds Node (B) (rank 4) to its set of DAG parents for
      DAGID 1.

   o  Node (N) is a sibling of Node (C), both are at rank 5.

   o  Node (N) may now forward traffic intended for the default
      destination upwards along DAGID 1 via nodes (B) and (E).  In some
      cases, e.g. if nodes (B) and (E) are tried and fail, node (N) may
      also choose to forward traffic to its sibling node (C), without
      making upwards progress but with the intention that node (C) or a
      following successor can make upwards progress.  Should Node (C)
      not have a viable parent, it should never send the packet back to
      Node (N) (to avoid a 2-node loop).














Winter, et al.            Expires June 10, 2010                [Page 75]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


B.3.  Example: DAG Maintenance


          :                      :                      :
          :                      :                      :
         (A)                    (A)                    (A)
          |\                     |                      |
          | `-----.              |                      |
          |        \             |                      |
         (B)       (C)          (B)       (C)          (B)
                    |                      |             \
                    |                      |              `-----.
                    |                      |                     \
                   (D)                    (D)                    (C)
                                                                  |
                                                                  |
                                                                  |
                                                                 (D)

              -1-                    -2-                    -3-


                        Figure 15: DAG Maintenance

   Consider the example depicted in Figure 15-1.  In this example, Node
   (A) is attached to a DAG at some rank d.  Node (A) is a DAG parent of
   Nodes (B) and (C).  Node (C) is a DAG parent of Node (D).  There is
   also an undirected sibling link between Nodes (B) and (C).

   In this example, Node (C) may safely forward to Node (A) without
   creating a loop.  Node (C) may not safely forward to Node (D),
   contained within it's own sub-DAG, without creating a loop.  Node (C)
   may forward to Node (B) in some cases, e.g. the link (C)->(A) is
   temporarily unavailable, but with some chance of creating a loop
   (e.g. if multiple nodes in a set of siblings start forwarding
   `sideways' in a cycle) and requiring the intervention of additional
   mechanisms to detect and break the loop.

   Consider the case where Node (C) hears a DIO message from a Node (Z)
   at a lesser rank and superior position in the DAG than node (A).
   Node (C) may safely undergo the process to evict node (A) from its
   DAG parent set and attach directly to Node (Z) without creating a
   loop, because its rank will decrease.

   Now consider the case where the link (C)->(A) becomes nonviable, and
   node (C) must move to a deeper rank within the DAG:





Winter, et al.            Expires June 10, 2010                [Page 76]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   o  Node (C) must first detach from the DAG by removing Node (A) from
      its DAG parent set, leaving an empty DAG parent set.  Node (C) may
      become the root of its own floating, less preferred, DAG.

   o  Node (D), hearing a modified DIO message from Node (C), follows
      Node (C) into the floating DAG.  This is depicted in Figure 15-2.
      In general, any node with no other options in the sub-DAG of Node
      (C) will follow Node (C) into the floating DAG, maintaining the
      structure of the sub-DAG.

   o  Node (C) hears a DIO message with an incremented DAGSequenceNumber
      from Node (B) and determines it is able to rejoin the grounded DAG
      by reattaching at a deeper rank to Node (B).  Node (C) adds Node
      (B) to its DAG parent set.  Node (C) has now safely moved deeper
      within the grounded DAG without creating any loops.

   o  Node (D), and any other sub-DAG of Node (C), will hear the
      modified DIO message sourced from Node (C) and follow Node (C) in
      a coordinated manner to reattach to the grounded DAG.  The final
      DAG is depicted in Figure 15-3

B.4.  Example: Greedy Parent Selection and Instability


         (A)                    (A)                    (A)
          |\                     |\                     |\
          | `-----.              | `-----.              | `-----.
          |        \             |        \             |        \
         (B)       (C)          (B)        \            |        (C)
                                  \        |            |        /
                                   `-----. |            | .-----`
                                          \|            |/
                                          (C)          (B)

              -1-                    -2-                    -3-


                  Figure 16: Greedy DAG Parent Selection

   Consider the example depicted in Figure 16.  A DAG is depicted in 3
   different configurations.  A usable link between (B) and (C) exists
   in all 3 configurations.  In Figure 16-1, Node (A) is a DAG parent
   for Nodes (B) and (C), and (B)--(C) is a sibling link.  In
   Figure 16-2, Node (A) is a DAG parent for Nodes (B) and (C), and Node
   (B) is also a DAG parent for Node (C).  In Figure 16-3, Node (A) is a
   DAG parent for Nodes (B) and (C), and Node (C) is also a DAG parent
   for Node (B).




Winter, et al.            Expires June 10, 2010                [Page 77]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   If a RPL node is too greedy, in that it attempts to optimize for an
   additional number of parents beyond its preferred parent, then an
   instability can result.  Consider the DAG illustrated in Figure 16-1.
   In this example, Nodes (B) and (C) may most prefer Node (A) as a DAG
   parent, but are operating under the greedy condition that will try to
   optimize for 2 parents.

   When the preferred parent selection causes a node to have only one
   parent and no siblings, the node may decide to insert itself at a
   slightly higher rank in order to have at least one sibling and thus
   an alternate forwarding solution.  This does not deprive other nodes
   of a forwarding solution and this is considered acceptable
   greediness.

   o  Let Figure 16-1 be the initial condition.

   o  Suppose Node (C) first is able to leave the DAG and rejoin at a
      lower rank, taking both Nodes (A) and (B) as DAG parents as
      depicted in Figure 16-2.  Now Node (C) is deeper than both Nodes
      (A) and (B), and Node (C) is satisfied to have 2 DAG parents.

   o  Suppose Node (B), in its greediness, is willing to receive and
      process a DIO message from Node (C) (against the rules of RPL),
      and then Node (B) leaves the DAG and rejoins at a lower rank,
      taking both Nodes (A) and (C) as DAG parents.  Now Node (B) is
      deeper than both Nodes (A) and (C) and is satisfied with 2 DAG
      parents.

   o  Then Node (C), because it is also greedy, will leave and rejoin
      deeper, to again get 2 parents and have a lower rank then both of
      them.

   o  Next Node (B) will again leave and rejoin deeper, to again get 2
      parents

   o  And again Node (C) leaves and rejoins deeper...

   o  The process will repeat, and the DAG will oscillate between
      Figure 16-2 and Figure 16-3 until the nodes count to infinity and
      restart the cycle again.

   o  This cycle can be averted through mechanisms in RPL:

      *  Nodes (B) and (C) stay at a rank sufficient to attach to their
         most preferred parent (A) and don't go for any deeper (worse)
         alternate parents (Nodes are not greedy)





Winter, et al.            Expires June 10, 2010                [Page 78]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


      *  Nodes (B) and (C) do not process DIO messages from nodes deeper
         than themselves (because such nodes are possibly in their own
         sub-DAGs)


Appendix C.  Outstanding Issues

   This section enumerates some outstanding issues that are to be
   addressed in future revisions of the RPL specification.

C.1.  Additional Support for P2P Routing

   In some situations the baseline mechanism to support arbitrary P2P
   traffic, by flowing upwards along the DAG until a common ancestor is
   reached and then flowing down, may not be suitable for all
   application scenarios.  A related scenario may occur when the down
   paths setup along the DAG by the destination advertisement mechanism
   are not be the most desirable downward paths for the specific
   application scenario (in part because the DAG links may not be
   symmetric).  It may be desired to support within RPL the discovery
   and installation of more direct routes `across' the DAG.  Such
   mechanisms need to be investigated.

C.2.  Loop Detection

   It is under investigation to complement the loop avoidance strategies
   provided by RPL with a loop detection mechanism that may be employed
   when traffic is forwarded.

C.3.  Destination Advertisement / DAO Fan-out

   When DAO messages are relayed to more than one DAG parent, in some
   cases a situation may be created where a large number of DAO messages
   conveying information about the same destination flow upwards along
   the DAG.  It is desirable to bound/limit the multiplication/fan-out
   of DAO messages in this manner.  Some aspects of the Destination
   Advertisement mechanism remain under investigation, such as behavior
   in the face of links that may not be symmetric.

   In general, the utility of providing redundancy along downwards
   routes by sending DAO messages to more than one parent is under
   investigation.

   The use of suitable triggers, such as the `D' bit, to trigger DA
   operation within an affected sub-DAG, is under investigation.
   Further, the ability to limit scope of the affected depth within the
   sub-DAG is under investigation (e.g. if a stateful node can proxy for
   all nodes `behind' it, then there may be no need to propagate the



Winter, et al.            Expires June 10, 2010                [Page 79]

Internet-Draft           draft-ietf-roll-rpl-05            December 2009


   triggered `D' bit further).

C.4.  Source Routing

   In support of nodes that maintain minimal routing state, and to make
   use of the collection of piecewise source routes from the destination
   advertisement mechanism, there needs to be some investigation of a
   mechanism to specify, attach, and follow source routes for packets
   traversing the LLN.

C.5.  Address / Header Compression

   In order to minimize overhead within the LLN it is desirable to
   perform some sort of address and/or header compression, perhaps via
   labels, addresses aggregation, or some other means.  This is still
   under investigation.


Authors' Addresses

   Tim Winter (editor)

   Email: wintert@acm.org


   Pascal Thubert (editor)
   Cisco Systems
   Village d'Entreprises Green Side
   400, Avenue de Roumanille
   Batiment T3
   Biot - Sophia Antipolis  06410
   FRANCE

   Phone: +33 497 23 26 34
   Email: pthubert@cisco.com


   ROLL Design Team
   IETF ROLL WG

   Email: rpl-authors@external.cisco.com










Winter, et al.            Expires June 10, 2010                [Page 80]

