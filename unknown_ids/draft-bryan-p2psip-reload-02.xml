<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="no" ?>
<?rfc colonspace="yes" ?>
<rfc category="std" docName="draft-bryan-p2psip-reload-02" ipr="full3978">
  <front>
    <title abbrev="RELOAD">REsource LOcation And Discovery (RELOAD)</title>

    <author fullname="Cullen Jennings" initials="C." surname="Jennings">
      <organization>Cisco</organization>

      <address>
        <postal>
          <street>170 West Tasman Drive</street>

          <street>MS: SJC-21/2</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <phone>+1 408 421-9990</phone>

        <email>fluffy@cisco.com</email>
      </address>
    </author>

    <author fullname="Bruce B. Lowekamp" initials="B. B." surname="Lowekamp">
      <organization>SIPeerior; William &amp; Mary</organization>

      <address>
        <postal>
          <street>3000 Easter Circle</street>

          <city>Williamsburg</city>

          <region>VA</region>

          <code>23188</code>

          <country>USA</country>
        </postal>

        <phone>+1 757 565 0101</phone>

        <email>lowekamp@sipeerior.com</email>
      </address>
    </author>

    <author fullname="Eric Rescorla" initials="E.K." surname="Rescorla">
      <organization>Network Resonance</organization>

      <address>
        <postal>
          <street>2064 Edgewood Drive</street>

          <city>Palo Alto</city>

          <region>CA</region>

          <code>94303</code>

          <country>USA</country>
        </postal>

        <phone>+1 650 320-8549</phone>

        <email>ekr@networkresonance.com</email>
      </address>
    </author>

    <author fullname="Jonathan Rosenberg" initials="J.D." surname="Rosenberg">
      <organization>Cisco</organization>

      <address>
        <postal>
          <street></street>

          <city>Edison</city>

          <region>NJ</region>

          <country>USA</country>
        </postal>

        <email>jdrosen@cisco.com</email>
      </address>
    </author>

    <date day="18" month="November" year="2007" />

    <area>RAI</area>

    <workgroup>P2PSIP</workgroup>

    <abstract>
      <t>This document defines REsource LOcation And Discovery (RELOAD), a
      peer-to-peer (P2P) binary signaling protocol for usage on the Internet.
      A P2P signaling protocol provides its clients with an abstract hash
      table service between a set of cooperating peers that form the overlay
      network. RELOAD is designed to support a P2P Session Initiation Protocol
      (P2PSIP) network, but it can be utilized by other applications with
      similar requirements by defining new usages that specify the data types
      that must be stored for a particular application, such as location for
      SIP. RELOAD defines a security model based on a certificate enrollment
      service that provides unique identities. NAT traversal is a fundamental
      service of the protocol.</t>

      <t>This draft represents a concrete proposal for the P2PSIP Peer
      Protocol. The protocol described here builds on the lessons and
      experiences from designing and implementing the dSIP, ASP, and RELOAD
      protocols and is a merge of features from RELOAD-01 and ASP.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>This document defines REsource LOcation And Discovery (RELOAD), a
      peer-to-peer (P2P) signaling protocol for usage on the Internet. It
      provides a Distributed Hash Table (DHT) service, which allows
      participating nodes to read and write entries into a hash table that is
      stored collectively among the participants. RELOAD is a lightweight,
      binary protocol. It provides several functions that are critical for a
      successful P2P protocol for the Internet. These are:</t>

      <t><list style="hanging">
          <t hangText="Security Framework:">Security is one of the most
          challenging problems in a P2P protocol. A P2P network will often be
          established among a set of peers none of which trust each other.
          Yet, despite this lack of trust, the network must operate reliably
          to allow storage and retrieval of data. RELOAD defines an abstract
          enrollment server, which all entities trust to generate unique
          identifiers for each user. Using that small amount of trust as an
          anchor, RELOAD defines a security framework that allows for
          authorization of P2P protocol functions and authentication of data
          stored in the overlay.</t>

          <t hangText="Usage Model:">RELOAD is designed to support a variety
          of applications, including P2P multimedia communications with the
          Session Initiation Protocol <xref
          target="I-D.ietf-p2psip-concepts"></xref>. Consequently, RELOAD has
          the notion of a usage, one of which is defined to support each
          application (this document also defines the SIP usage for multimedia
          communications). Each usage identifies a set of data types that need
          to be stored and retrieved from the DHT (the SIP usage defines data
          types for registrations, certificates, and Traversal Using Relay NAT
          (TURN) <xref target="I-D.ietf-behave-turn"></xref> servers). Each
          type defines a data structure, authorization policies, size quota,
          and information required for storage and retrieval in the DHT. The
          usage concept allows RELOAD to be used with new applications through
          a simple documentation process that supplies the details for each
          application.</t>

          <t hangText="NAT Traversal:">Operations for NAT traversal are part
          of the base design, including establishing new RELOAD connections
          and tunneling SIP or other application protocols required by P2PSIP.
          RELOAD makes use of Interactive Connectivity Establishment (ICE)
          <xref target="I-D.ietf-mmusic-ice"></xref> to facilitate the
          creation of the P2P network and the establishment of links for use
          by the application protocol (SIP and RTP, for example). RELOAD also
          defines how peers in the P2P network act as STUN and TURN servers
          and how those resources can be discovered through the DHT. With
          these features, RELOAD can run in modes in which all the peers are
          behind NATs, yet are able to fully participate without imposing any
          constraints on the actual DHT algorithm or routing topology.</t>

          <t hangText="High Performance Routing:">The very nature of DHT
          algorithms introduces a requirement that peers participating in the
          P2P network route requests on behalf of other peers in the network.
          This introduces a load on those other peers, in the form of
          bandwidth and processing power. RELOAD has been defined to reduce
          the amount of bandwidth and processing required of peers. It does so
          by using a very lightweight binary protocol, and furthermore, by
          defining a packet structure that facilitates low-complexity
          forwarding, including hardware-based forwarding. In particular, a
          fixed-length header is used for routing the message through the
          overlay without the contents needing to be parsed by (or even
          visible to) intermediate peers. The header includes no information
          about specific IP addresses because none are needed to route along
          an overlay. The header only includes lists of peers which the
          message should be routed through/too, as well as some minor options
          and version flags. Clearly separating the header components
          necessary for routing from the message contents simplifies
          processing and increases security.</t>

          <t hangText="Transport Flexibility:">RELOAD has native support for
          both DTLS and TLS for the underlying transport protocol, with
          support for DTLS over UDP as mandatory to implement. TLS over TCP is
          preferred because it has better bulk performance and connection
          stability, but UDP is more likely to provide direct connections
          between peers in the presence of NATs. Explicit support for
          fragmentation is provided and required when using UDP. Because there
          is no single universally available and suitable transport protocol,
          the peer protocol must be flexible in this regard. New transports
          can be supported trivially.</t>

          <t hangText="Pluggable DHT Algorithms:">RELOAD has been designed
          with an abstract interface to the DHT layer to simplify implementing
          a variety of DHT algorithms. This specification also defines how
          RELOAD is used with Chord, which is mandatory to implement.
          Specifying a default "must implement" DHT will allow
          interoperability, while the extensibility allows selection of DHTs
          optimized for a particular application.</t>
        </list></t>

      <t>These properties were designed specifically to meet the requirements
      for a P2P protocol to support SIP. However, RELOAD is not limited to
      usage by SIP and could serve as a tool for supporting other P2P
      applications with similar needs. RELOAD is also based on the concepts
      introduced in <xref target="I-D.ietf-p2psip-concepts"></xref>.</t>

      <section title="Architecture">
        <t>Architecturally this specification splits into several layers, as
        shown in the following figure.</t>

        <figure>
          <artwork><![CDATA[
                 Application

          -------------------------------------- Usage-defined API
            +-------+  +-------+               
Usage       | SIP   |  | XMPP  |  ...                
Layer       | Usage |  | Usage |              
            +-------+  +-------+
          -------------------------------------- Distributed Storage API
                                 
Overlay     Overlay              +-------------+                 
Routing &   Routing &    +----+  | +-----+     |                 
Storage     Replication  | DB |  | |Chord| ... | Topology       
Layer       Logic        +----+  | |     |     | Plugins       
                                 | +-----+     |             
                                 +-------------+             
          --------------------------------------
                               +------+ +-----+
Forwarding     Forwarding &    | STUN | | ICE |         
Layer          Encoding Logic  +------+ +-----+
          -------------------------------------- Common Packet Encoding
Transport     +-------+  +------+                              
Layer         |TLS    |  |DTLS  |                           
              +-------+  +------+  
              ]]></artwork>
        </figure>

        <t>The three layers defined by RELOAD include: <list style="hanging">
            <t hangText="Usage Layer:">Provides an application-specific
            interface that maps an application's requirements onto the generic
            services of the DHT.</t>

            <t hangText="Overlay Routing &amp; Storage Layer:">Implements the
            DHT. Chooses what links to establish to form the DHT's overlay
            network, manages the storage and migration of data for this peer
            and on behalf of other peers, and performs searches for requested
            data across the DHT.</t>

            <t hangText="Forwarding Layer:">Provides services analogous to the
            Link Layer in the IP model. Also handles setting up connections
            across NATs using ICE.</t>
          </list></t>

        <section title="Usage Layer">
          <t>The top layer, called the Usage Layer, has application usages,
          such as the SIP Location Usage, that use the abstract distributed
          storage API to store and retrieve data from the DHT. The goal of
          this layer is to implement application-specific usages of the
          Overlay Routing and Storage Layer below it. The Usage defines how a
          specific application maps its data into something that can be stored
          in the DHT, where to store the data, how to secure the data, and
          finally how applications can retrieve and use the data.</t>

          <t>The architecture diagram shows both a SIP usage and an XMPP
          usage. A single application may require multiple usages. A usage may
          define multiple types of data that are stored in the overlay and may
          also rely on types originally defined by other usages. A usage is
          not itself encoded on the wire --- only the types are --- but is
          rather a specification of the functionality that is required for a
          given application.</t>

          <t>One usage may depend on another. For example, the SIP usage
          depends on a Certificate Store usage (not shown in the diagram) to
          obtain the certificates required to authenticate messages. Because
          certificates are stored in standard X.509 form, there is no reason
          for each usage to specify this service independently.</t>
        </section>

        <section title="Overlay Routing and Storage Layer">
          <t>The Overlay Routing and Storage Layer stores and retrieves
          information, performs maintenance of the DHT as peers join and leave
          the DHT, and routes messages on the overlay. The DHT implementation
          is provided by a pluggable component so that each overlay can select
          an appropriate DHT that relies on the common RELOAD core code.</t>

          <t>The Overlay Routing and Replication Logic provides a fairly
          generic interface that allows the DHT implementation to control the
          overlay and resource operations and messages. Since each DHT is
          defined and functions differently, we generically refer to the table
          of other peers that the DHT maintains and uses to route requests
          (neighbors) as a Routing Table. The Logic component makes queries to
          the DHT's Routing Table to determine the next hop, then encodes and
          sends the message itself. Similarly, the DHT issues periodic update
          requests through the logic component to maintain and update its
          Routing Table.</t>

          <t>The DHT shown in the illustration is Chord, but a variety of DHT
          algorithms are possible through a pluggable interface. A single node
          could be functioning in multiple overlays simultaneously, each using
          its own DHT algorithm. Each peer is identified by and its location
          in the overlay determined by its Peer-ID that is assigned by the
          enrollment server when the user or peer first enrolls in the
          overlay. The Peer-ID also determines the range of Resource-IDs for
          which it will be responsible. The exact mapping between these is
          determined by the DHT algorithm used by the overlay, therefore the
          logic component always queries the DHT to determine where a
          particular resource should be stored.</t>

          <t>As peers enter and leave, resources may be stored on different
          peers, so the information related to them is exchanged as peers
          enter and leave. Redundancy is used to protect against loss of
          information in the event of a peer failure and to protect against
          compromised or subversive peers. The Logic component notifies the
          DHT as neighbors join and leave, and the DHT updates its Routing
          Table and issues resource migration requests as appropriate.</t>
        </section>

        <section title="Forwarding Layer">
          <t>This layer is responsible for getting a packet to the next peer,
          as determined by the Routing and Storage Layer. The Forwarding Layer
          establishes and maintains the network connections required by the
          DHT's Routing Table. This layer is also responsible for setting up
          connections to other peers through NATs and firewalls using ICE, and
          it can elect to forward traffic using relays for NAT and firewall
          traversal.</t>
        </section>
      </section>

      <section title="Security">
        <t>RELOAD's security framework is built upon an enrollment server. The
        enrollment server issues each new peer a certificate that assigns it a
        Peer-ID. By generating the Peer-IDs randomly and controlling what
        peers are issued certificates, the enrollment server protects against
        many of the attacks on the overlay network. Similarly, all users are
        issued certificates for their identities by the enrollment server. All
        resources stored on the overlay must be signed by their creator, thus
        ensuring that an attacker cannot forge data belonging to another user.
        The enrollment process is a one-time-only procedure. The peer or user
        do not have to communicate further with it once they have obtained
        their certificates.</t>

        <t>TLS or DTLS are used for communication between peers. In
        combination with the certificates, this provides both confidentiality
        and authentication for communication across the overlay. Applications
        such as P2PSIP can also make use of the users' certificates to achieve
        secure end-to-end connections at the application layer.</t>

        <!-- <t>Further security is provided by replicating the resources stored
             on the overlay.  Even if an attacker can compromise a single peer
             (either directly or through the routing), by locating replicas
             randomly around the overlay, a valid copy of the data is likely to
             be obtained.  </t>-->

        <t>In addition to the enrollment server model, RELOAD offers a
        security model using a pre-shared-key. Although this provides
        significantly less security than is provided through an enrollment
        server, it allows ad hoc or ephemeral overlays to be set up with
        minimal effort on the part of the users.</t>
      </section>
    </section>

    <section title="Terminology">
      <t></t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>

      <t>We use the terminology and definitions from the <xref
      target="I-D.ietf-p2psip-concepts">Concepts and Terminology for Peer to
      Peer SIP</xref> draft extensively in this document. Other terms used in
      this document are defined inline when used and are also defined below
      for reference.</t>

      <t>The following important terms from the Concepts document are defined
      below for reference.</t>

      <t><list style="hanging">
          <t hangText="DHT:" />

          <t>A distributed hash table. A DHT is an abstract hash table service
          realized by storing the contents of the hash table across a set of
          peers.</t>

          <t hangText="DHT Algorithm:">An algorithm that defines the rules for
          determining which peers in a DHT store a particular piece of data
          and for determining a topology of interconnections amongst peers in
          order to find a piece of data. Examples of DHT algorithms are Chord,
          Bamboo and Tapestry.</t>

          <t hangText="DHT Instance:">A specific hash table and the collection
          of peers that are collaborating to provide read and write access to
          it. There can be any number of DHT instances running in an IP
          network at a time, and each operates in isolation of the others.</t>

          <t hangText="P2P Network:">Another name for a DHT instance.</t>

          <t hangText="P2P Network Name:">A string that identifies a unique
          P2P network. P2P network names look like DNS names - for example,
          "example.org". Lookup of such a name in DNS would typically return
          services associated with the DHT, such as enrollment servers,
          bootstrap peers, or gateways (for example, a SIP gateway between a
          traditional SIP and a P2P SIP network called "example.com").</t>

          <t hangText="Resource-ID:">A non-human-friendly value that
          identifies some resources and which is used as a key for storing and
          retrieving the resource. One way to generate a Resource-ID is by
          applying a mapping function to some other unique name (e.g., User
          Name or Service Name) for the resource. The Resource-ID is used by
          the distributed database algorithm to determine the peer or peers
          that are responsible for storing the data for the overlay.</t>

          <t hangText="Peer:">A host that is participating in the DHT. By
          virtue of its participation it can store data and is responsible for
          some portion of the overlay.</t>

          <t hangText="Peer-ID:">A Resource-ID that uniquely identifies a
          peer. Peer-IDs 0 and 2^N - 1 are reserved and are invalid peer-IDs.
          A value of zero is not used in the wire protocol but can be used to
          indicate an invalid peer in implementations and APIs. The peer-id of
          2^N-1 is used on the wire protocol as a wildcard.</t>

          <t hangText="Resource:">An object associated with an identifier. The
          identifier for the object is a string that can be mapped into a
          Resource-ID by using the string as a seed to the hash function. A
          SIP resource, for example, is identified by its AOR.</t>

          <t hangText="User:">A human being.</t>
        </list> <t>We also introduce the following important new terms.</t>
      <list style="hanging">
          <t hangText="Connection Table:">The set of peers to which a peer is
          directly connected. This includes peers with which CONNECT
          handshakes have been done but which have not sent any UPDATEs.</t>

          <t hangText="Routing Table:">The set of peers which a peer can use
          to route DHT messages. In general, these peers will all be on the
          connection table but not vice versa, because some peers will have
          CONNECTed but not sent updates. Peers may send messages directly to
          peers which are on the connection table but may only route messages
          to other peers through peers which are on the routing table.</t>

          <t hangText="Seed:">A seed is a string used as an input to a hash
          function, the result of which is a Resource-ID.</t>

          <t hangText="Usage:">A usage is an application that wishes to use
          the DHT for some purpose. Each application wishing to use the DHT
          defines a set of data types that it wishes to use. The SIP usage
          defines the location, certificate, STUN server and TURN server data
          types.</t>
        </list></t>
    </section>

    <section title="Overview">
      <section title="Distributed Storage Layer">
        <t>Each logical address in the DHT where data can be stored is
        referred to as a Resource-ID. A given peer will be responsible for
        storing data from many Resource-ID locations. Typically literature on
        DHTs uses the term "key" to refer to a location in the DHT; however,
        in this specification the term key is used to refer to public or
        private keys used for cryptographic operations and the term
        Resource-ID is used to refer to a location for storage in the DHT.</t>

        <section title="DHT Concepts">
          <t>While very early P2P systems used flood based techniques, most
          newer P2P systems locate resources using a Distributed Hash Table,
          or DHT to improve efficiency. Peers are organized using a
          Distributed Hash Table (DHT) structure. In such a system, every
          resource has a Resource-ID, which is obtained by hashing some
          keyword or value that uniquely identifies the resource. Resources
          can be thought of as being stored in a hash table at the entry
          corresponding to their Resource-ID. The peers that make up the
          overlay network are also assigned an ID, called a Peer-ID, in the
          same hash space as the Resource-IDs. A peer is responsible for
          storing all resources that have Resource-IDs near the peer's
          Peer-ID. The hash space is divided up so that all of the hash space
          is always the responsibility of some particular peer, although as
          peers enter and leave the system a particular peer's area may
          change. Messages are exchanged between the peers in the DHT as the
          peers enter and leave to preserve the structure of the DHT and
          exchange stored entries. Various DHT implementations may visualize
          the hash space as a grid, circle, or line.</t>

          <t>Peers keep information about the location of other peers in the
          hash space and typically know about many peers nearby in the hash
          space, and progressively fewer more distant peers. We refer to this
          table of other peers as a Routing Table. When a peer wishes to
          search, it consults the list of peers it is aware of and contacts
          the peer with the Peer-ID nearest the desired Resource-ID. If that
          peer does not know how to find the resource, it either returns
          information about a closer peer it knows about, or forwards the
          request to a closer peer. In this fashion, the request eventually
          reaches the peer responsible for the resource, which then replies to
          the requester.</t>
        </section>

        <section title="DHT Topology">
          <t>Each DHT will have a somewhat different structure, but many of
          the concepts are common. The DHT defines a large space of
          Resource-IDs, which can be thought of as addresses. In many DHTs,
          the Resource-IDs are simply 128- or 160-bit integers. Each DHT also
          has a distance metric such that we can say that Resource-ID A is
          closer to Resource-ID B than to Resource-ID C. When the Resource-IDs
          are n-bit integers, they are often considered to be arranged in a
          ring so that (2^n)-1 and (0) are consecutive and distance is simply
          distance around the ring.</t>

          <t>Each peer in the DHT is assigned a Peer-ID and is "responsible"
          for the nearby space of Resource-IDs. So, for instance, if we have a
          peer P, then it could also be responsible for storing data
          associated with Resource-ID P+epsilon as long as no other peer P was
          closer. The DHT Resource-ID space is divided so that some peer is
          responsible for each Resource-ID.</t>
        </section>

        <section anchor="sec.routing" title="Routing">
          <t>The way routing works in a DHT is specified by the specific DHT
          algorithm but the basic concepts are common to most systems. Each
          peer maintains connections to some other set of peers N. There need
          not be anything special about the peers in N, except that the peer
          has a direct connection to them: it can reach them without going
          through any other peer. When it wishes to deliver a message to some
          peer P, it selects some member of N, N_i that is closer to P than
          itself (as a degenerate case, P may be in N). The peer sends message
          to message to N_i. At this point two things can happen:</t>

          <t><list style="hanging">
              <t hangText="Recursive Routing">N_i repeats the same process as
              P, sending the message to one of its peers N_j. This same
              process repeats until the message is delivered to N.</t>

              <t hangText="Iterative Routing">N_i consults its table of direct
              connections and selects a new peer N_j which is closer to N. It
              responds to the original sending peer with a redirect to N_j.
              The original peer then sends the message to N_j, where the
              process repeats until the sending peer is redirected to N.</t>
            </list></t>

          <t>The advantage of iterative routing is that it consumes less
          resources for the intermediate peers; they only have to send
          redirect messages rather than forwarding requests and responses. The
          advantage of recursive routing is that it does not require the
          sending or receiving peer to have a rich set of connections to other
          nodes in the overlay. Thus, iterative routing is problematic in
          NATed networks because there is no way to guarantee that a peer will
          be able to form a connection to whatever peer it is redirected
          to.</t>

          <t>[[TODO: The details of which routing strategy are to be used and
          how they are selected are kind of unclear. This needs WG
          discussion.]]</t>

          <t>In most DHTs, the peers in N are selected in a particular way.
          One common strategy is to have them arranged exponentially further
          away from yourself so that any message can be routed in a O(log(N))
          steps. The details of the routing structure depend on the DHT
          algorithm, however, since it defines the distance metric and the
          structure of the connection table.</t>

          <t>In RELOAD, messages may either be REQUESTS or RESPONSES to
          REQUESTS. Requests are routed as described above. In principle,
          responses could be routed the same way. This is called "Asymmetric"
          routing because requests and responses will generally follow
          different paths through the network. Asymmetric routing makes
          diagnosis of errors difficult because you need to be able to acquire
          debugging information at multiple locations. In the alternative
          strategy, called "Symmetric" routing, as requests travel through the
          network they accumulate a history of the peers they passed through
          and responses are routed in the opposite direction so that they
          follow the same path in reverse. RELOAD supports both flavors of
          routing.</t>

          <t>Symmetric routing is easier to debug. Symmetric routing is also
          required when the overlay topology is changing. For example, when a
          new peer is joining the overlay, asymmetric routing cannot work
          because the response would not be able to reach the new peer until
          it has completed the joining process. Symmetric routing solves this
          situation because the response is routed from the admitting peer
          through the bootstrap peer, thus relying on a path that is already
          known and established. In order to implement symmetric routing,
          RELOAD provides the Via List (<xref target="sec-via-list"></xref>)
          feature. Asymmetric routing, however, requires no state to be stored
          in the message (as a Via List) or in on-path peers.</t>

          <t>[[TODO: again, this is a topic that needs WG discussion. It seems
          like there are situations where symmetric is very desirable (e.g.,
          startup). It's less clear that asymmetric will have a
          performance/state difference that will be significant.]]</t>
        </section>

        <section anchor="sec-typed-data"
                 title="Storing and Retrieving Typed Data">
          <t>The Data Storage Layer provides operations to STORE, FETCH, and
          REMOVE data. Each location in the DHT is referenced by a single
          integer Resource-ID. However, each location may contain data
          elements of multiple types. Furthermore, there may be multiple
          values of each type, as shown below.</t>

          <figure>
            <artwork><![CDATA[
                    +--------------------------------+
                    |            Resource-ID         |
                    |                                |
                    | +------------+  +------------+ | 
                    | |   Type 1   |  |   Type 2   | |
                    | |            |  |            | |
                    | | +--------+ |  | +--------+ | |
                    | | | Value  | |  | | Value  | | |
                    | | +--------+ |  | +--------+ | |
                    | |            |  |            | |
                    | | +--------+ |  | +--------+ | |
                    | | | Value  | |  | | Value  | | |
                    | | +--------+ |  | +--------+ | |
                    | |            |  +------------+ |
                    | | +--------+ |                 |
                    | | | Value  | |                 |
                    | | +--------+ |                 |
                    | +------------+                 |
                    +--------------------------------+
              ]]></artwork>
          </figure>

          <t>Each type-id is a code point assigned by IANA. Note that a
          type-id may be employed by multiple usages and new usages are
          encouraged to use previously defined types where possible. As part
          of the type definition, protocol designers may define constraints,
          such as limits on size, on the values which may be stored. For many
          types, the set may be restricted to a single item; some sets may be
          allowed to contain multiple identical items while others may only
          have unique items. Some typical types of sets that a type definition
          would use include:</t>

          <t><list style="hanging">
              <t hangText="single value:">There can be at most one item in the
              set and any value overwrites the previous item.</t>

              <t hangText="array:">Many values can be stored and addressed by
              index.</t>

              <t hangText="dictionary:">The values stored are indexed by a
              key. Often this key is one of the values from the certificate of
              the peer sending the STORE request.</t>
            </list></t>

          <!--
	  EKR REMOVED 

          <t>Application usages define the types and any enforceable
          constraints. These are implemented by a STORE, FETCH, and REMOVE
          methods that are routed to the correct peer by the underling DHT
          instance. The STORE and REMOVE requests can affect a single member of
          the set or multiple members. The FETCH request returns the complete
          set. The security around who can STORE or REMOVE data is defined by
          the application's usage, but typically only a specific user can modify
          the data at a specific location and the request to modify the data
          will be accompanied by a signature that is signed with the appropriate
          user's certificate authorizing the request. All data stored in the DHT
          has an expiry date after which point it may be discarded.</t>

          <t>It is possible to discover whether a specific peer is storing any
          records of a particular type using the FIND operation. This operation only
          looks on a single peer and does not require the underlying DHT
          implementation to provide search functionality. The FIND request
          also returns various statistics about the peer that is storing the
          data. These statistics include the portion of the Resource-ID space the
          peer is responsible for and the number of items it is storing. These
          can be used to estimate the number of unique Resource-ID and peers in the
          DHT.</t>
-->
        </section>

        <section anchor="sec-join-leave-maint"
                 title="Joining, Leaving, and Maintenance">
          <t>When a new peer wishes to join the DHT, it must have a peer-id
          that it is allowed to use. It uses one of the peer-ids in the
          certificate it received from the enrollment server. The main steps
          in joining the DHT are:</t>

          <t><list style="symbols">
              <t>Forming connections to some other peers.</t>

              <t>Acquiring the data values this peer is responsible for
              storing.</t>

              <t>Informing the other peers which were previously responsible
              for that data that this peer has taken over responsibility.</t>
            </list></t>

          <t>First, the peer ("JP," for Joining Peer) uses the bootstrap
          procedures to find some (any) peer in the DHT. It then typically
          contacts the peer which would have formerly been responsible for the
          peer's Resource-ID (since that is where in the DHT the peer will be
          joining), the Admitting Peer (AP). It copies the other peer's state,
          including the data values it is now responsible for and the
          identities of the peers with which the other peer has direct
          connections.</t>

          <t>The details of this operation depend mostly on the DHT involved,
          but a typical case would be:</t>

          <t><list style="numbers">
              <t>JP sends a JOIN request to AP announcing its intention to
              join.</t>

              <t>AP sends an OK response.</t>

              <t>AP does a sequence of STOREs to JP to give it the data it
              will need.</t>

              <t>AP does UPDATEs to JP and to other peers to tell it about its
              own routing table. At this point, both JP and AP consider JP
              responsible for some section of the DHT.</t>

              <t>JP makes its own connections to the appropriate peers in the
              DHT.</t>
            </list></t>

          <t>After this process is completed, JP is a full member of the DHT
          and can process STORE/FETCH requests.</t>
        </section>
      </section>

      <section title="Forwarding Layer">
        <t>The forwarding layer is responsible for looking at message and
        doing one of three things: <list style="symbols">
            <t>Deciding the message was destined for this peer and passing the
            message up to the layer above this.</t>

            <t>Looking at the peer-id that represents the next peer to send
            the message too and if there is an existing connection, sending
            the message over the connection.</t>

            <t>Requesting the DHT Routing logic to tell the forwarding layer
            which peer the message needs to be forwarded to, and then sending
            the message.</t>
          </list></t>

        <section anchor="direct.connect" title="Forming Direct Connections">
          <t>As described in <xref target="sec.routing"></xref>, a peer
          maintains a set of direct connections to other peers in the DHT.
          Consider the case of a peer JP just joining the DHT. It communicates
          with the admitting peer AP and gets the list of the peers in AP's
          routing table. Naively, it could simply connect to the IP address
          listed for each peer, but this works poorly if some of those peers
          are behind a NAT or firewall. Instead, we use the CONNECT request to
          establish a connection.</t>

          <t>Say that peer A wishes to form a direct connection to peer B. It
          gathers ICE candidates and packages them up in a CONNECT request
          which it sends to B through usual DHT routing procedures. B does its
          own candidate gathering and sends back an OK response with its
          candidates. A and B then do ICE connectivity checks on the candidate
          pairs. The result is a connection between A and B. At this point, A
          and B can add each other to their routing tables and send messages
          directly between themselves without going through other DHT
          peers.</t>

          <t>In general, a peer needs to maintain connections to all of the
          peers near it in the DHT and to enough other peers to have efficient
          routing (the details depend on the specific DHT). If a peer cannot
          form a connection to some other peer, this isn't necessarily a
          disaster; DHTs can route correctly even with not fully connected
          links. However, a peer should try to maintain the specified link set
          and if it detects that it has fewer direct connections, should form
          more as required.</t>
        </section>

        <section anchor="sec-via-list" title="Via Lists">
          <t>In a general messaging system, messages need a source and a
          destination and peers need to be able to send a response to the peer
          that sent the request. This can be particularly tricky in overlay
          networks when a new peer is joining, or the overlay network is
          stabilizing and different peers have different ideas on what the
          overlay topology is. A simple and reliable way to make sure that a
          response can reach the node that sent the request in these
          situations is to have the response traverse the reverse path of the
          request.</t>

          <t>The approach used to do this is to have each node the request
          traverses add its peer-id to the "via list" in the request. Then the
          response is routed by looking at the list and using it as list of
          peers that the response will be routed thorough. To support this,
          each message has a route list of nodes it needs to be routed through
          as well as a via list of what nodes it has traversed.</t>

          <t>When a peer receives a message from the Transport Layer, it adds
          the peer-id of the node it received the message from to the end of
          the via list. When a peer goes to transmit a message to the
          Transport Layer, it looks at the first entry on the route list. If
          the entry is this peer, it removes this entry from the list and
          looks at the next entry and if the entry is not this peer, it sends
          the message to the first peer on the route list.</t>

          <t>When a peer goes to send a response to a request, it can simply
          copy the via list in reverse to form the route list for the response
          if it wishes to route the response along the reverse path as the
          request. [Discussion is need about if all responses are routed this
          way or not]</t>

          <t>Peers that are willing to maintain state may do list compression
          for privacy reason and to reduce the message size. They do this by
          taking some number of entries off the via list and replacing them
          with a unique entry that this peer can later identify. Later, if the
          peer sees the unique entry in a route list, it removes the unique
          entry and replaces it with the all the entries removed from the
          original via list (and reverses the order of these entries). Note
          that this technique will generally require storing some per-message
          state on the intermediate peer, so this is a bandwidth/per-peer
          state tradeoff. The exception is if the list is not compressed but
          rather the peer-ids are simply encrypted.</t>

          <t>The via list approach provides several features. First it allows
          a response to follow the same path as the request. This is
          particularly important for peers that are sending requests while
          they are joining and before other peers can route to them as well as
          situations where message are being exchanged to stabilize the
          overlay network. It also makes it easier to diagnose and manage the
          system when all peers see the response to any request they
          forward.</t>
        </section>

        <section title="Clients">
          <t>RELOAD also allows for the possibility of Client nodes. A client
          is a node which connects to an admitting peer (or peers) like an
          ordinary peer but never sends a JOIN or an UPDATE. It is therefore
          in the AP's connection table but not routing table and never is used
          to store any DHT data. However, because it is reachable through the
          AP, it can still send and receive messages. The client MUST still
          have the usual credentials.</t>

          <t>Because the client may only have a connection to a single AP,
          which, due to topology shifts may no longer be the responsible peer,
          clients SHOULD use symmetric routing and should advertise route
          lists that contain both the AP to which they are connected and
          themselves. E.g., if the client has peer-id X and the AP has peer-id
          Y, the client should advertise the route list (Y, X). This
          guarantees reachability.</t>

          <t>Note that clients MAY also contact APs which are not in fact
          responsible for the client's peer-id.</t>
        </section>
      </section>

      <section title="Transport Layer">
        <t>This layer sends and receives messages over TLS and DTLS. For TLS
        it simply pushes the messages into the stream. For DTLS it takes care
        of fragmentation issues. The reason for including TLS is the improved
        performance it can offer for bulk transport of data. The reason for
        including DTLS is that the percentage of the time that two devices
        behind NATs can form a direct connection without a relay is much
        higher for DTLS than for TLS.</t>
      </section>

      <section title="Enrollment">
        <t>Before a new user can join the DHT for the first time, they must
        enroll in the P2P Network for the DHT they want to join. Enrollment
        will typically be done by contacting a centralized enrollment server.
        Other approaches (for instance static out of band configuration) are
        possible but are outside the scope of this specification. During
        enrollment a new node learns about a particular overlay, sets up a
        names and credentials, and discovers the bootstrap nodes. This would
        typically be done when a new peer joined an overlay for the very first
        time. Bootstrap is the process that happens each time a node boots and
        is how the peer finds an node that can be used to join the
        overlay.</t>

        <t>Before a node can join an overlay, it needs to be provided with a
        name for the overlay. Some examples are "example.com", "example", and
        "example.local". An DNS SRV lookup is done on this name for the
        service name p2p_enroll and a proto of tcp. If the TLD for the name is
        .local, then this DNS SRV lookup is done using <xref
        target="I-D.cheshire-dnsext-multicastdns"></xref> and the service name
        p2p_menroll. The intention here is to support ad hoc/local overlays.
        The resulting DNS lookup will provide the address of a enrollment
        server. Once this server is found, HTTPS is used to retrieve a XML
        file that contains the parameters for the overlay. These include
        things such as: what algorithms the overlay uses, overlay parameters,
        what usages are a peer on this overlay is required to support, the
        type of credentials required, addresses of credentials servers, the
        root certificate for the DHT, information about the DHT algorithm that
        is being used, a P2P-Network-Id that uniquely identifies this ring,
        and any other parameters it may need to connect to the DHT. The DHT
        also informs the peers what Usages it is required to support to be a
        peer on this P2P Network. An initial list of bootstrap nodes that
        consist of multiple bootstrap entries that each have the IP address
        and port for contacting a bootstrap server. Some of the address may be
        multicast addresses. In the case of multicast DNS, every peer may also
        act as an enrollment server.</t>

        <t>If shared-key security (<xref target="sec-shared-key"></xref>) is
        being used, then the peer can proceed directly to bootstrap. If
        certificate-based security (<xref target="sec-cert-security"></xref>
        is being used, the peer MUST contact the credential server to obtain a
        certificate.</t>

        <section title="Certificate Issuance">
          <t>Once the peer has the XML file that identifies if credentials are
          needed, it can contact the credential server. The user establishes
          his identity to the server's satisfaction and provides the server
          with its public key. The centralized server then returns a
          certificate binding the user's user name to their public key. The
          properties of the certificate are discussed more in <xref
          target="sec-security-intro"></xref>. The amount of authentication
          performed here can vary radically depending on the DHT network being
          joined. Some networks may do no verification at all and some may
          require extensive identity verification. The only invariant that the
          enrollment server needs to ensure is that no two users may have the
          same identity.</t>
        </section>

        <section title="Bootstrap">
          <t>The above steps are only done the first time a peer joins a new
          overlay or when the overlay parameters are close to expiring and
          need to be refreshed. The next step is the bootstrap step which is
          done every time the peer boots.</t>

          <t>Bootstrapping consists of looking at the list of cached nodes and
          bootstraps nodes and sending a RELOAD PING to them to see if they
          respond. Once a node responds, it can be used to join the overlay.
          After a node has joined, it keeps track of a small number of peers
          to which it could directly connect. Theses are saved as the cached
          nodes and used next time the peer boots. The point of the cached
          nodes is to reduce the load on the bootstrap nodes.</t>
        </section>
      </section>

      <section anchor="sec-security-intro" title="Security">
        <section anchor="sec-cert-security" title="Certificate-Based Security">
          <t>The certificate-based security model revolves around the
          enrollment process allocating a unique name to the user and issuing
          a certificate <xref target="RFC3280"></xref> for a public/private
          key pair for the user. All peers in a particular DHT can verify
          these certificates. A given peer acts on behalf of a user, and that
          user is somewhat responsible for its operation.</t>

          <t>The certificate serves two purposes:</t>

          <t><list style="symbols">
              <t>It entitles the user to store data at specific locations in
              the DHT.</t>

              <t>It entitles the user to operate a peer that has a peer-id
              found in the certificate. When the peer is acting as a DTLS or
              TLS server, it can use this certificate so that a client
              connecting to it knows it is connected to the correct
              server.</t>
            </list></t>

          <t>When a user enrolls, or enrolls a new device, the user is given a
          certificate. This certificate contains information that identifies
          the user and the device they are using. If a user has more than one
          device, typically they would get one certificate for each device.
          This allows each device to act as a separate peer.</t>

          <t>The contents of the certificate include:</t>

          <t><list style="symbols">
              <t>A public key provided by the user.</t>

              <t>Zero, one, or more user names that the DHT is allowing this
              user to use. For example, "alice@example.org". Typically a
              certificate will have one name. In the SIP usage, this name
              corresponds to the AOR.</t>

              <t>Zero, one, or more peer-ids. Typically there will be one
              peer-id. Each device will use a different peer-id, even if two
              devices belong to the same user. Peer-IDs should be chosen
              randomly by the enrollment server.</t>

              <t>A serial number that is unique to this certificate across all
              the certificates issued for this DHT.</t>

              <t>An expiration time for the certificate.</t>
            </list></t>

          <t>Note that because peer-IDs are chosen randomly, they will be
          randomly distributed with respect to the user name. This has the
          result that any given peer is highly unlikely to be responsible for
          storing data corresponding to its own user, which promotes high
          availability.</t>

          <section title="Storage Permissions">
            <t>When a peer uses a STORE request to place data at a particular
            location X, it must sign with the private key that corresponds to
            a certificate that is suitable for storing at location X. Each
            data type in a usage defines the exact rules for determining what
            certificate is appropriate. However, the most natural rule is that
            a certificate for a user name or peer-id X is a permission to
            store data at the same resource id that would be found by an
            attempt to look up X.</t>

            <t>The digital signature over the data serves two purposes. First,
            it allows the peer responsible for storing the data to verify that
            this STORE is authorized. Second, it provides integrity for the
            data. The signature is saved along with the data value (or values)
            so that any reader can verify the integrity of the data. Of
            course, the responsible peer can "lose" the value but it cannot
            undetectably modify it.</t>
          </section>

          <section title="Peer Permissions">
            <t>The second purpose of a certificate is to allow the device to
            act as a peer with the specified peer-ID. When a peer wishes to
            connect to peer X, it forms a TLS/DTLS connection to the peer and
            then performs TLS mutual authentication and verifies that the
            presented certificate contains peer-ID X.</t>

            <t>Note that because the formation of a connection between two
            nodes generally requires traversing other nodes in the DHT, as
            specified in <xref target="direct.connect"></xref>, those nodes
            can interfere with connection initiation. However, if they attempt
            to impersonate the target peer they will be unable to complete the
            TLS mutual authentication: therefore such attacks can be
            detected.</t>
          </section>

          <section title="Expiry and Renewal">
            <t>At some point before the certificate expires, the user will
            need to get a new certificate from the enrollment server.</t>
          </section>
        </section>

        <section anchor="sec-shared-key" title="Shared-Key Security">
          <t>RELOAD also defines a shared-key security model which can be used
          in closed networks where the peers are not mutually suspicious. In
          this model, the peers all share a single key which is used to
          authenticate the peer-to-peer DTLS connections via TLS-PSK. If
          shared-key security mode is in use, a TLS-PSK cipher suite MUST be
          used. This is useful for admission control, but is completely unsafe
          in any setting where peers are not mutually trusted, since it allows
          any peer to impersonate any other peer.</t>
        </section>
      </section>

      <section title="Migration">
        <t>At some point in time, a given P2P Network may want to migrate from
        one underlying DHT algorithm to another or update to a later extension
        of the protocol. This can also be used for crypto agility issues. The
        migration approach is done by basically having peers initializing
        algorithm A. When the clients go to periodically renew their
        credentials, they find out that the P2P Network now requires them to
        use algorithm A but also to store all the data with algorithm B. At
        this point there are effectively two DHT rings in use, rings A and B.
        All data is written to both but queries only go to A. At some point
        when the clients periodically renew their credentials, they learn that
        the P2P Network has moved to storing to both A and B but that FETCH
        requests are done with P2P Network B and that any SEND should first be
        attempted on P2P Network B and if that fails, retried on P2P Network
        A. In the final stage when clients renew credentials, they find out
        that P2P Network A is no longer required and only P2P Network B is in
        use. Some types of usages and environments may be able to migrate very
        quickly and do all of these steps in under a week, depending on how
        quickly software that supports both A and B is deployed and how often
        credentials are renewed. On the other hand, some very ad-hoc
        environments involving software from many different providers may take
        years to migrate.</t>
      </section>

      <section title="Usages Layer">
        <t>By itself, the distributed storage layer just provides
        infrastructure on which applications are built. In order to do
        anything useful, a usage must be defined. Each Usage needs to specify
        several things:</t>

        <t><list style="symbols">
            <t>Register code points for any type that the Usage defines.</t>

            <t>Define the data structure for each of the types.</t>

            <t>Define access control rules for each type.</t>

            <t>Provide a size limit for each type.</t>

            <t>Define how the seed is formed that is hashed to form the
            Resource-ID where each type is stored.</t>

            <t>Describe how values will be merged after a network partition.
            Unless otherwise specified, the default merging rule is to act as
            if all the values that need to be merged were stored and that the
            order they were stored in corresponds to the storing times
            associated with (and carried in) their values.</t>
          </list></t>

        <t>The types defined by a usage may also be applied to other usages.
        However, a need for different parameters, such as different size
        limits, would imply the need to create a new type.</t>

        <section anchor="sec-sip-usage" title="SIP Usage">
          <t>From the perspective of P2PSIP, the most important usage is the
          SIP Usage. The basic function of the SIP usage is to allow Alice to
          start with a SIP URI (e.g., "bob@dht.example.com") and end up with a
          connection which Bob's SIP UA can use to pass SIP messages back and
          forth to Alice's SIP UA.</t>

          <!--
          <t>This operation can take a number of forms, but in the simplest
          case, Bob's SIP UA has peer-ID "B". When Bob joins the DHT (i.e.,
          turns on his phone), he stores the following mapping in the DHT:</t>

          <t><list style="symbols">
              <t>sip:bob@dht.example.com -&gt; B</t>
            </list></t>

          <t>When Alice wants to call Bob, she starts with his URI and her UA
          uses the DHT to look up his peer-ID B. She then routes a message
          through the DHT to B requesting a direct connection. Once this
          connection is established she can send SIP messages over it, which
          allows her to set up the phone call.</t>
-->

          <t>This is done using three key operations that are provided by the
          SIP Usage. They are:</t>

          <t><list style="symbols">
              <t>Mapping SIP URIs that are not GRUUs to other SIP URIs or to
              the DHT peer responsible for the SIP UA.</t>

              <t>Mapping SIP GRUUs to the DHT peer responsible for the SIP
              UA.</t>

              <t>Forming a connection directly to a DHT peer that is used to
              send SIP messages to the SIP UA.</t>
            </list></t>

          <t>All SIP URIs for a given overlay MUST be constructed so that they
          terminate in the domain name of the overlay. For instance, if the
          overlay name is "example.com", then all AORs must be of the form
          {sip,sips}:username@example.com. Accordingly, to dereference a URI,
          a P2PSIP implementation MUST check to see if the domain matches an
          overlay which it is a member of. If so, it uses the following
          procedures. Otherwise, it MUST follow <xref target="RFC3263"></xref>
          procedures. Note that unless the P2PSIP overlay provides some kind
          of SIP gateway, this is likely to be only partially successful,
          since, for instance, the callee may not be able to call back.</t>

          <section title="SIP Location">
            <t>A peer acting as a SIP UA stores their registration information
            in the DHT by storing either another URI (for retargeting) or a
            route lists to reach them at a Resource-ID in the DHT formed from
            the user's SIP AOR. When another peer wishes to find a peer that
            is registered for a SIP URI, the lookup of the user's name is done
            by taking the user's SIP Address or Record (AOR) and using it as
            the seed that is hashed to get a Resource-ID. When the seed is
            dereferenced, the result is a set of values. Each value is either
            another SIP URI or a route list. If the value is a SIP URI, the
            calling peer looks up that URI and continues the process until he
            gets a route list.</t>

            <t>If the value is a route list, then it is used to reach a peer
            that represents a SIP UA registered for that AOR. Typically this
            route list will have just one entry but in the case of peers or
            clients that can not be directly reached, a route list with more
            than one entry may need to be used.</t>

            <t>The seed for this usage is a user's SIP AOR, such as
            "sip:alice@example.com". This allows the set to store many values
            but only one for each peer. The authorization policy is that STORE
            requests are only allowed if the user name in the signing
            certificate, when turned into a SIP URL and hashed, matches the
            Resource-ID. This policy ensures that only a user with the
            certificate with the user name "alice@example.com" can write to
            the Resource-ID that will be used to look up calls to
            "sip:alice@example.com".</t>

            <t>Open Issue: Should the seed be "sip:alice@example.com",
            "alice@example.com", or a string that includes the code point
            defined for the type? The issue here is determining whether
            different usages that store data at a seed that is primarily
            formed from "alice@example.com" should hash to the same
            Resource-ID as the SIP Usage. For example, if a buddy list had a
            seed that was roughly the same, would we want the buddy list
            information to end up on the same peers that stored the SIP
            location data or on different peers?</t>
          </section>

          <section title="SIP GRUUs">
            <t>GRUUs that refer to peers in the P2P network are constructed by
            simply forming a GRUU, where the value of gr URI parameter
            contains a base64 encoded version of the route list that will
            reach the peer. Typically the route list is just a single entry
            with the peer-id of peer.</t>
          </section>

          <section title="SIP Connect">
            <t>This usage allows two clients to form a new TLS or DTLS
            connection between them and then use this connection for sending
            SIP messages to one another. This does not store any information
            in the DHT, but it allows the CONNECT request to be used to set up
            a TLS or DTLS connection between two peers and then use that
            connection to send SIP messages back and forth.</t>

            <t>The CONNECT request will ensure that the connection is formed
            to a peer that has a certificate which includes the user that the
            connection is being formed to.</t>
          </section>

          <section title="SIP Tunnel">
            <!-- EKRTODO:  remove?-->

            <t>This TUNNEL request allows two peers to exchange SIP messages
            across the overlay using the TUNNEL method without first setting
            up a direct connection using CONNECT. This allows a SIP message to
            be sent immediately, without the delay associated with CONNECT and
            for a simple SIP exchange, it may result in fewer messages being
            sent.</t>
          </section>
        </section>

        <section title="Certificate Store Usage">
          <t>This usage allows each user to store their certificate in the DHT
          so that it can be retrieved to be checked by various peers and
          applications. Peers acting on behalf of a particular user store that
          user's certificate in the DHT, and any peer that needs the
          certificate can do a FETCH to retrieve the certificate. Typically it
          is retrieved to check a signature on a request or the signature on a
          chunk of data that the DHT has received.</t>
        </section>

        <section title="TURN Usage">
          <t>This usage defines a new type for finding STUN-Relay servers. Any
          peer that supports this usage saves a pointer to the IP address and
          port of the TURN server in the DHT. When a peer wishes to discover a
          TURN server, it picks a random Resource-ID and performs a FIND at
          that Resource-ID for the appropriate type for the service. If
          nothing is found, this can be repeated until an appropriate set of
          servers are found.</t>
        </section>

        <section title="Other Usages">
          <t>This will likely be left out of scope of the initial system but
          just to give people a flavor of how these issues might be dealt
          with....</t>

          <section title="Storing Buddy Lists">
            <t>Buddy lists with reciprocal subscribes - when see indication
            buddy might be online, such as SUBSCRIBE from buddy, retry
            SUBSCRIBE to buddy. Subscriber ends up doing composition.</t>

            <t>Single users with different devices can synchronize buddy lists
            when both are online</t>
          </section>

          <section title="Storing Users' VCards"></section>

          <section title="Finding Voicemail Message Recorder">
            <t>Voicemail is a complicated problem because the amount of
            storage required to store a voicemail message can be large. Some
            proposed designs may require peers to store voicemail and others
            may require users to provide their own storage and delivery
            systems. Accordingly, this is being left out of the base
            protocol.</t>
          </section>

          <!--   <section title="ID/Locator Mappings"></section> -->
        </section>
      </section>

      <figure>
        <!-- begin-prologue -->

        <artwork><![CDATA[
primitive uint8 8;
primitive uint16 16;
primitive uint24 24;
primitive uint32 32;
primitive int32 32;
primitive uint64 64;
primitive uint128 128;
primitive char 8;
primitive opaque 8;
primitive blob 0;
typedef char string<65000>;

primitive peer_id 128;
primitive resource_id 128;
typedef uint32 overlay;
typedef uint64 transaction_id;
typedef uint24 type_id;
typedef uint64 generation_counter;

	  struct  {
		 uint32 addr;
		 uint16 port;
	  } ip4_addr_port;

	  struct  {
		 uint128 addr;
		 uint16 port;
	  } ip6_addr_port;

	  enum {ip4_address_type (1), ip6_address_type (2)} address_type;
	  
	  select {
	    case ip4_address_type:
	      ip4_addr_port v4;
	    case ip6_address_type:
              ip6_addr_port v6;	  
	  } ip_address_and_port;


              ]]></artwork>

        <!-- end-prologue -->
      </figure>
    </section>

    <section anchor="sec-base-protocol" title="Base Protocol">
      <t>RELOAD is a message-oriented request/response protocol. The messages
      are encoded using binary fields. All integers are represented in network
      byte order. The general philosophy behind the design was to use Type,
      Length, Value fields to allow for extensibility. However, for the parts
      of a structure that were required in all messages, just define theses in
      a fixed position as adding a type and length for them is unnecessary and
      would simply increases bandwidth and introduces new potentials for
      interoperability issues.</t>

      <t>Each message has three parts:</t>

      <t><list style="hanging">
          <t hangText="Forwarding Header:">Each message has a generic header
          which is used to forward the message between peers and to its final
          destination. This header is the only information that an
          intermediate peer (i.e., one that is not the target of a message)
          needs to examine.</t>

          <t hangText="Message Contents:">The message being delivered between
          the peers. From the perspective of the forwarding layer, the
          contents is opaque, however, it is interpreted by the higher
          layers.</t>

          <t hangText="Signature:">A digital signature over the message
          contents and parts of the header of the message. Note that this
          signature can be computed without parsing the message contents.</t>
        </list></t>

      <t>The following sections describe the format of each part of the
      message.</t>

      <section anchor="sec-forwarding-header" title="Forwarding Header">
        <t>The layout of the forwarding header is shown below</t>

        <t><artwork><![CDATA[
    0                   1                   2                   3 
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       R       |       E       |       L       |       O       |
4  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Overlay                             |
8  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |               |F|L|                           |
   |      TTL      |    Routing    |R|F|      Fragment Offset      |
   |               |               |A|R|                           |
   |               |               |G|G|                           |
12 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E|             |                                               |
   |X|  Version    |                    Length                     |
   |P|             |                                               | 
16 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Transaction ID                         |
   +                                                               +
   |                                                               |
24 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Route     |      Via      |                               |
   |     List      |      List     |            Flags              |
   |     Length    |     Length    |                               |
28 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   //                          Route List                         //
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   //                           Via List                          //
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   //                          Route Log                          //
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   
]]></artwork></t>

        <t>The first four bytes identify this message as a RELOAD message.</t>

        <t>The Overlay field is the 32bit checksum/hash of the overlay being
        used. The CRC-32 checksum MUST be used to convert the variable length
        string representing the overlay name into a 32bit value. The purpose
        of this field is to allow nodes to participate in multiple overlays
        and to detect accidental misconfiguration.</t>

        <t>TTL (time-to-live) is an 8 bit field indicating the number of
        iterations, or hops, a message can experience before it is discarded.
        The TTL u_int8 number MUST be stored in network byte order and MUST be
        decremented by one at every hop along the route the message traverses.
        If the TTL is 0, the message MUST NOT be propagated further and MUST
        be discarded. The initial value of the TTL should be TBD.</t>

        <t>Routing is an 8 bit field that specifies the type of routing the
        requester would like for the message. The following Routing options
        MUST be understood:</t>

        <t><list style="empty">
            <artwork><![CDATA[
UNSPECIFIED  : 0x00
RECURSIVE    : 0x01          
ITERATIVE    : 0x02
          ]]></artwork>
          </list></t>

        <t>If a peer is unable or unwilling to perform the type of routing
        requested, the peer MUST respond with a 499 error message that
        indicates its unwillingness to process the message.</t>

        <!--
	<t>[[Open Issue: It is possible to indicate what type of routing
	using the TTL field.  If TTL is 0, assume iterative, otherwise
	assume recursive.  Do we want to do this?]] </t>
	-->

        <t>FRAG is a 1 bit field used to specify if this message is a
        fragment.</t>

        <t><list style="empty">
            <artwork><![CDATA[
NOT-FRAGMENT    : 0x0          
FRAGMENT        : 0x1
          ]]></artwork>
          </list></t>

        <t>LFRG is a 1 bit field used to specify whether this is the last
        fragment in a complete message.</t>

        <t><list style="empty">
            <artwork><![CDATA[
NOT-LAST-FRAGMENT    : 0x0          
LAST-FRAGMENT        : 0x1
          ]]></artwork>
          </list></t>

        <t>[[Open Issue: How should the fragment offset and total length be
        encoded in the header? Right now we have 14 bits reserved with the
        intention that they be used for fragmenting, though additional bytes
        in the header might be needed for fragmentation.]]</t>

        <t>EXP is a 1 bit field that specifies if this protocol is
        experimental or not. The EXP bit can be set to denote that this
        version of the protocol is private, in-house. This makes it possible
        to have private protocol versions that don't collide with IETF
        standards.</t>

        <t>Version is a 7 bit field that indicates the version of the RELOAD
        protocol being used.</t>

        <t><list style="empty">
            <artwork><![CDATA[
Version1.0       : 0x1
          ]]></artwork>
          </list></t>

        <t>The message Length is the count in bytes of the size of the
        message, including the header.</t>

        <t>The Transaction ID is a unique 64 bit number that identifies this
        transaction and also serves as a salt to randomize the request and the
        response. Responses use the same Transaction ID as the request they
        correspond to. Transaction IDs are also used for fragment
        reassembly.</t>

        <t>The Route List Length and the Via List Length contain the lengths
        of the route and via lists respectively, in the number of
        peer-ids.</t>

        <t>[[Open Issue: How should we handle peer-id lengths? This basically
        assumes they're fixed length per DHT algorithm (but not fixed-length
        for RELOAD) so that you can unambiguously parse things. Should we have
        a length byte?]]</t>

        <t>The flags word contains control flags. There is one currently
        defined flag.</t>

        <t><list style="empty">
            <artwork><![CDATA[
ROUTE-LOG       : 0x1
          ]]></artwork>
          </list></t>

        <t>The ROUTE-LOG flag indicates that the route log should be included
        (see <xref target="sec-route-log"></xref></t>

        <t>The Route List contains a sequence of peer-ids which the message
        should pass through. The route list is constructed by the message
        originator. The route list shrinks as the message traverses each
        listed peer.</t>

        <t>The Via List contains the sequence of peer-ids through which the
        message has passed. The via list starts out empty and grows as the
        message traverses each peer.</t>

        <section anchor="sec-reload-diffs"
                 title="Changes to Forwarding Header">
          <t>The RELOAD-01 forwarding header was completely fixed, whereas
          this header includes lists that change en-route. However, this type
          of operation is easily accomplished in both software and hardware,
          therefore we still view it as a low-overhead header. The changes
          include the following.</t>

          <list style="symbols">
            <t>Rearranged fields to have a cleaner separation between payload
            and header.</t>

            <t>Removed DHT, Hash, and Security parameters. These are now in
            the overlay bootstrap system rather than per-message.</t>

            <t>Source and destination IDs are now route lists to accommodate
            source routing and recursion without state on intermediate
            peers.</t>

            <t>Added route log to header to allow payload/header
            separation.</t>
          </list>
        </section>

        <section anchor="sec-transport-routing" title="Message Routing">
          <section anchor="sec-request-origination"
                   title="Request Origination">
            <t>In order to send a message to a given peer-id or resource-id, a
            peer must construct an appropriate route list. The most common
            such route list is a single entry containing the peer/resource-id.
            This simply uses the normal DHT routing mechanisms to forward the
            message to that destination.</t>

            <t>Messages can also be source routed. In order to construct a
            source route, the originator provides a route list containing a
            sequence of resource-ids. The semantics of this route list are
            that the message is to traverse in order (potentially with
            intermediate hops) each entry on the route list. As each peer is
            traversed, that entry is removed from the route list. This makes
            it possible to address a peer which is potentially behind a NAT or
            a firewall in such a way that it cannot be connected to directly
            under any circumstances.</t>
          </section>

          <section anchor="sec-response-origination"
                   title="Response Origination">
            <t>When a peer sends a response to a request, it SHOULD construct
            the route list by reversing the order of the entries on the via
            list. This has the result that the response traverses (at least)
            the same peers as the request traversed, except in reverse order
            (symmetric routing). For asymmetric routing, the peer MAY simply
            use the first entry on the via list.</t>
          </section>

          <section anchor="sec-message-forwarding"
                   title="Message Receipt and Forwarding">
            <t>When a peer receives a message, it first examines the overlay,
            version, and other header fields to determine whether the message
            is one it can process. If any of these are incorrect (e.g., the
            message is for an overlay in which the peer does not participate)
            it is an error. The peer SHOULD generate an appropriate error but
            MAY simply drop the message.</t>

            <t>Once the peer has determined that the message is correctly
            formatted, it examines the first entry on the route list. There
            are three possible cases here:</t>

            <t><list style="symbols">
                <t>The first entry on the route list is a private id which is
                being used for route list compression.</t>

                <t>The first entry on the route list is an id for which the
                peer is responsible.</t>

                <t>The first entry on the route list is for which another peer
                is responsible.</t>
              </list></t>

            <t>These cases are handled separately.</t>

            <section anchor="sec-private-peer-id" title="Private ID">
              <t>If the first entry on the route list is a private id, the
              peer replaces that entry with the store local value that it
              indexes and then re-examines the route list to determine which
              case now applies.</t>
            </section>

            <section anchor="sec-responsible-id" title="Responsible ID">
              <t>If the first entry on the route list is a id for which the
              peer is responsible, the peer strips the entry off the route
              list. If there are remaining entries on the route list, the peer
              then re-examines the route list to determine which case now
              applies. If the route list is now empty, then the message was
              destined for this peer and it MUST pass it to the next layer
              up.</t>
            </section>

            <section anchor="sec-other-id" title="Other ID">
              <t>If neither of the other two cases applies, then the peer MUST
              forward the message towards the first entry on the route list.
              This means that it MUST select one of the peers in its route
              table which is closer to the first entry than to itself and send
              the message to that peer. If the first entry on the route list
              is in the peer's connection table, then it SHOULD forward the
              message to that peer directly.</t>

              <t>When forwarding a message, the peer MUST:</t>

              <t><list style="symbols">
                  <t>Decrement the TTL value</t>

                  <t>Update the via list.</t>
                </list></t>

              <t>The natural way to update the via list is simply to add the
              peer-id of the peer from which the message was received to the
              end of the list. However, peers may use any algorithm of their
              choice provided that if the peer received a route list
              constructed by reversing the via list it would be able to route
              the outgoing message correctly, enabling symmetric routing.</t>

              <t>For instance, if node D receives a message from node C with
              via list (A, B), the simple approach is simply to forward to the
              next node (E) with via list (A, B, C). Now, if E wants to
              respond to the message, it reverses the via list to produce the
              route list, resulting in (D, C, B, A). When D forwards the
              response to C, the route list will contain (B, A). However, node
              D could also list compression and send E the via list (X). E
              would then use the route list (D, X). When D processes this
              route list, it MUST detect that X is a compressed entry, recover
              the via list (A, B, C), and reverse that to produce the correct
              route list (C, B, A) before sending it to C.</t>

              <t>Note that if a peer is using list compression and then exits
              the overlay, the message cannot be forwarded and will be
              dropped. The ordinary timeout and retransmission networks
              provide stability over this type of failure.</t>
            </section>
          </section>
        </section>

        <section anchor="sec-frag-reass" title="Fragmentation and Reassembly">
          <t>In order to allow transport over datagram protocols, RELOAD
          messages may be fragmented. If a message is too large for a peer to
          transmit to the next peer it MUST fragment the message. Note that
          this implies that intermediate peers may re-fragment messages if the
          incoming and outgoing paths have different maximum datagram sizes.
          Intermediate peers SHOULD NOT reassemble fragments.</t>

          <t>Upon receipt of a fragmented message by the intended peer, the
          peer holds the fragments in a holding buffer until the entire
          message has been received. The message is then reassembled into a
          single unfragmented message and processed. In order to prevent
          denial of service attacks, receivers SHOULD time out incomplete
          fragments. [[TODO: Describe algorithm]]</t>
        </section>

        <section anchor="sec-route-log" title="Route Logging">
          <t>The route logging feature provides diagnostic information about
          the path taken by the request so far and in this manner it is
          similar in function to <xref target="RFC3261">SIP's</xref> Via
          header field. If the ROUTE-LOG flag is set in the Flags word, at
          each hop peers MUST append a route log entry to the route log
          element in the header. The order of the route log entry elements in
          the message is determined by the order of the peers were traversed
          along the path. The first route log entry corresponds to the peer at
          the first hop along the path, and each subsequent entry corresponds
          to the peer at the next hop along the path. If the ROUTE-LOG flag is
          set in a request, the route log MUST be copied into the response and
          the ROUTE-LOG flag set so that the originator receives the ROUTE-LOG
          data.</t>

          <figure>
            <!-- begin-pdu-->

            <artwork><![CDATA[
	    public struct {
	      route_log_entry entries<65000>;
	    } route_log;	
              ]]></artwork>
          </figure>

          <t>The route log is simply a variable length list of route log
          entries. The first two bytes are the length, followed by a sequence
          of route leg entries, each of which may be individually parsed.</t>

          <figure>
            <!-- begin-pdu-->

            <artwork><![CDATA[
	    struct {
	      peer_id id; 
	      uint32 uptime;
	      opaque certificate<65000>;
	      ip_address_and_port address;
	    } peer_info_data;

	    public struct {
	      string version;
	      uint8 transport;
	      peer_info_data peer_info;
           } route_log_entry;
              ]]></artwork>
          </figure>

          <t>Each route log entry consists of the following values:</t>

          <list style="hanging">
            <t hangText="Version -">A textual representation of the software
            version</t>

            <t hangText="Transport -">The transport type, 1 for TLS, 2 for
            DTLS</t>

            <t hangText="Id -">The peer-id of the peer.</t>

            <t hangText="Uptime -">The uptime of the peer in seconds.</t>

            <t hangText="Certificate -">The peer's certificate. Note that this
            may be omitted by setting the length to zero.</t>

            <t hangText="Address -">The address and port of the peer.</t>
          </list>

          <!--	    
  route-log = uint16 ; number of route-log-entries
              *route-log-entry

  route-log-entry = route-log-p2psip-version 
                    route-log-entry-transport
                    route-log-entry-peer-info

  route-log-version = string 

  route-log-entry-transport =   route-log-transport-tcp /
                                route-log-transport-udp /
                                route-log-transport-tls /
                                route-log-transport-dtls / uint8

  route-log-transport-tcp       = 1
  route-log-transport-udp       = 2
  route-log-transport-tls       = 3
  route-log-transport-dtls      = 4
  
  route-log-entry-peer-info = peer-id
                              peer-name
                              peer-uptime
                              peer-ip-port
                              peer-certificate
   
   peer-name =      string   ; a textual representation of the peer name
   peer-ip-port =   string   ; a textual representation of the IP/port
   peer-uptime = uint32      ; time in seconds since peer start
   peer-certificate = data-value ; the peer's certificate -->
        </section>
    </section>

        <section anchor="sec-contents" title="Message Contents Format">
          <t>Although from the perspective of the forwarding layer the content
          is opaque, all RELOAD messages share a common content structure
          consisting of two parts:</t>

          <t><list style="hanging">
              <t hangText="Common Header:">A common header containing the
              request method/response code, and a transaction ID.</t>

              <t hangText="Payload:">The actual body of the request/response.
              These are dependent on whether this is a request or response and
              the type of request being carried.</t>
            </list></t>

          <section anchor="sec-contents-common-header" title="Common Header">
            <t>The layout of the common header is shown below:</t>

            <t><artwork><![CDATA[
    0                   1                   2                   3 
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |R|                               |                             |
   |/|              Code             |           Reserved          |
   |r|                               |                             |
 4 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork></t>

            <t>R/r is a one bit field used to specify if this is a request or
            a response.</t>

            <t><list style="empty">
                <artwork><![CDATA[
REQUEST       : 0x0          
RESPONSE      : 0x1
          ]]></artwork>
              </list></t>

            <t>Code is a 15 bit field that indicates either the message method
            or the response code (depending on the value of the R/r bit)</t>
          </section>

          <section anchor="sec-payload" title="Payload">
            <t>Payload is a simple string of uninterpreted bytes preceded by a
            length field indicating the length of the data. The bytes
            themselves are dependent on the code value.</t>

            <t><artwork><![CDATA[
    0                   1                   2                   3 
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   |                             Length                            |
   |                                                               |
 4 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   //                     Length bytes of data                    //
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
]]></artwork></t>
          </section>

          <section anchor="sec-signature" title="Signature">
            <t>The Signature element is used to attach signatures to messages
            and or stored data elements. All signatures are formatted using
            this element. However, the input structure to the signature
            computation varies depending on the data element being signed.</t>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
  public struct  {
    uint8 algorithm;
    opaque signature_value<65000>;
    signature_identity identity;
  } signature;
]]></artwork>
            </figure>

            <t>The signature construct is just a container for the signature.
            It contains the following values:</t>

            <list style="hanging">
              <t hangText="Algorithm -">The signature algorithm in use. This
              may have the values RSA-SHA1 (0x01) or RSA-SHA-256 (0x02).</t>

              <t hangText="Value - ">The signature value itself. This is just
              the string of bytes emitted by the signature algorithm.</t>

              <t hangText="Identity -">The identity or certificate used to
              form the signature</t>
            </list>

            <t>A number of possible identity formats are permitted, as shown
            below. The peer may indicate any of:</t>

            <t>
              <list style="symbols">
                <t>Peer-id</t>

                <t>User name</t>

                <t>The certificate itself.</t>
              </list>
            </t>

            <t>The first byte of the identity field is a type indicating the
            type of identity in use.</t>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
  enum {signer_identity_peer (1), signer_identity_name (2),
       signer_identity_certificate (3)} signer_identity_type;

  select {
    case signer_identity_peer:
      peer_id id;
    case signer_identity_name:
      string signer_name;
    case signer_identity_certificate:
      opaque certificate<65000>;
  } signer_identity;
]]></artwork>
            </figure>

            <!--
  signature = signature-algorithm    
              signer-identity
              signature-value

  signature-algorithm = rsa-sha1-id / rsa-sha-256-id / uint16
  rsa-sha1-id = 0x01
  rsa-sha256-id = 0x02

  signer-identity = signer-identity-type 
                    peer-id / signer-name / certificate / *byte

  signer-identity-type = signer-identity-peer / signer-identity-name /
                         signer-identity-certificate / uint8

  signer-identity-peer = 0x01
  signer-identity-name = 0x02
  signer-identity-certificate = 0x03

  signer-name = string
  certificate = data-value
  signature = data-value
-->

            <t>For signatures over messages the input to the signature
            function is:</t>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
	  public struct {
	    overlay overlay;
	    transaction_id xid;
	    blob signer_identity;
	    blob message_contents;
          } message_signature_input;
              ]]></artwork>
            </figure>

            <t>The contents of this structure are as follows:</t>

            <t>
              <list style="hanging">
                <t hangText="Overlay -">The overlay identifier from the
                message.</t>

                <t hangText="Xid -">The transaction id from the message.</t>

                <t hangText="Signer Identity -">The identify of the signer
                (from the signature structure.)</t>

                <t hangText="Message Contents -">The contents section of the
                message.</t>
              </list>
            </t>

            <!--	

   message-signature-input = overlay         ; from forwarding header
                             transaction-id  ; from forwarding header
                             signer-identity
                             message-contents
-->

            <t>[[TODO: Check the inputs to this carefully.]]</t>

            <t>The input to signatures over data values is different, and is
            decribed in <xref target="sec-data-sig" />.</t>
          </section>
        </section>

        <section anchor="sec-response-code"
                 title="Response Codes and Response Errors">
          <t>A peer processing a request returns its status in the Code field
          of the common header. If the request was a success, the code should
          be 200 (OK) and the payload should be as specified above. If the
          request failed, then the response code should be as defined
          below.</t>

          <t>
            <list style="hanging">
              <t hangText="200 (OK):">Indicates a successful request. The
              information returned in the response will depend on the request
              method.</t>

              <t hangText="302 (Moved Temporarily):">The requesting peer
              SHOULD retry the request at the new address specified in the 302
              response message.</t>

              <t hangText="401 (Unauthorized):">The requesting peer needs to
              sign and provide a certificate. [[TODO: The semantics here don't
              seem quite right.]]</t>

              <t hangText="403 (Forbidden):">The requesting peer does not have
              permission to make this request.</t>

              <t hangText="404 (Not Found):">The resource or peer cannot be
              found or does not exist.</t>

              <t hangText="408 (Request Timeout):">A response to the request
              has not been received in a suitable amount of time. The
              requesting peer MAY resend the request at a later time.</t>

              <t hangText="412 (Precondition Failed):">A request can't be
              completed because some precondition was incorrect. For instance,
              the wrong generation counter was provided</t>

              <t hangText="498 (Incompatible with Overlay)">A peer receiving
              the request is using a different overlay, DHT algorithm, or hash
              algorithm. [[Open Issue: What is the best error number and
              reason phrase to use?]]</t>

              <t hangText="499 (UnWilling To Proxy)">A peer receiving the
              request is unwilling to support the Routing mechanism specified
              in the Routing field of the message header. [[Open Issue: What
              is the best error number and reason phrase to use?]]</t>
            </list>
          </t>

          <t>For any code other than 200, the payload should be as defined
          below:</t>

          <figure>
            <!--begin-pdu-->

            <artwork><![CDATA[
	      public struct {
	        string reason_phrase;
		opaque error_info<65000>;		       
	      } error_response;
              ]]></artwork>
          </figure>

          <!--	  
  error-payload = string   ; reason phrase
                  error-payload-rest

  error-payload-rest = error-payload-302 / *byte

  error-payload-302 = peer-id -->

          <t>The contents of this payload are:</t>

          <list style="hanging">
            <t hangText="Reason Phrase -">A freeform text string indicating
            the reason for the response. The reason phrase SHOULD BE as
            indicated in the above list (e.g., "Moved Temporarily).</t>

            <t hangText="Error Info -">Payload specific error information.
            This MUST be empty except as specified below.</t>
          </list>

          <t>For the response code 302, the error-payload-rest is the peer-id
          of the peer to which the request SHOULD be redirected. This error
          code is used for iterative routing.</t>
        </section>

        <section anchor="sec-timeout" title="Timeout and Retransmission">
          <t>Timeout and retransmission are handled on an end-to-end basis.
          The requesting node retransmits requests until it receives a
          response or a timeout. The retransmit algorithm defined in Section
          17.1.2.1 of <xref target="RFC3261"></xref> SHOULD be used.
          Retransmissions MUST use the same transaction ID.</t>
        </section>
      </section>

    <section anchor="sec-requests" title="Method Definitions">
      <t>In this section, we define the initial set of methods supported by
      RELOAD. New methods are defined by adding new method codes. Each method
      defines the contents of the payload element (see <xref
      target="sec-payload"></xref>).</t>

      <section title="Connection Management">
        <section title="PING">
          <t>PING is used to test connectivity along a path. A ping can be
          addressed to a specific peer-id or to the anycast peer-id (all 1s).
          In either case, the target peer-ids respond with a simple response
          containing some status information.</t>

          <section title="Request Definition">
            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
	      public struct {
	         uint8 ping_info<255>;
	      } ping_request;
]]></artwork>
            </figure>

            <!--
   ping-request      = [ping-request-info-responsible]
                       [ping-request-info-num_resources] (uint8)*
   
   ping-request-info-responsible        = 0x01
   ping-request-info-num_resource       = 0x02

-->

            <t>The PING request contains a list (potentially empty) of the
            pieces of status information that the requester would like the
            responder to provide. The two currently defined types are:</t>

            <t><list style="empty">
                <artwork><![CDATA[
RESPONSIBLE-SET : 0x01
NUM-RESOURCES   : 0x02
          ]]></artwork>
              </list></t>

            <t>RESPONSIBLE-SET indicates that the peer should Respond with the
            fraction of the overlay for which the responding peer is
            responsible (in parts per billion).</t>

            <t>NUM-RESOURCES indicates that the peer should Respond with the
            number of resources currently being stored by the peer.</t>
          </section>

          <section title="Response Definition">
            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
	      public struct {
	        uint64 response_id;
		ping_info_data infos<65000>;
	      } ping_response;
]]></artwork>
            </figure>

            <t>The ping response contains the following elements: <list
                style="hanging">
                <t hangText="Response ID -">A randomly generated 64-bit
                response ID. This is used to distinguish PING responses in
                cases where the PING request is multicast.</t>

                <t hangText="Infos -">A sequence of ping info data structures,
                as shown below.</t>
              </list></t>

            <t><figure>
                <!--begin-pdu-->

                <artwork><![CDATA[
	      enum {info_responsible_type(1),
		   info_num_resources_type(2)}
		   ping_info_types;

              select {
	        case info_responsible_type:
		  uint32 responsible_ppb;
		case info_num_resources_type:
		  uint32 num_resources;			
	      } ping_info_select;

	      public struct {
		ping_info_select info;
	      } ping_info_data;
]]></artwork>
              </figure></t>

            <t>The ping info data elements are simple typed elements, with a
            type identifier as the leading 16 bits and then arbitrary
            (type-specific) text following. In the case of the two defined
            types, the responses are 32-bit integers.</t>

            <!--
   ping-response      = ping-response-id (ping-response-value)*
   
   ping-response-value = ping-response-info-responsible /
                         ping-response-info-num-resources /
                         ping-response-info-any

   ping-response-info-responsible = ping-request-info-responsible
                                    0x04
                                    uint32 ; parts per billion

   ping-response-info-num-resources = ping-request-info-num-resources
                                    0x04
                                    uint32 ; count

   ping-response-info-any = uint8
                            uint8
                            *byte
-->

            <t>The responding peer SHOULD include any values that the
            requesting peer requested and that it recognizes. They SHOULD be
            returned in the requested order.</t>
          </section>
        </section>

        <section anchor="sec-connect-details" title="CONNECT">
          <t>A node sends a CONNECT request when it wishes to establish a
          direct TCP or UDP connection to another node for the purposes of
          sending RELOAD messages or application layer protocol messages, such
          as SIP. Detailed procedures for the CONNECT and its response are
          described in <xref target="sec-connect-ice" />.</t>

          <note title="Note">
            <t>A CONNECT does not result in updating the routing table of
            either node. That function is performed by UPDATEs. If node A has
            CONNECTed to node B, it MAY route messages which are directly
            addressed to B through that channel but MUST NOT route messages
            through B to other peers via that channel.</t>
          </note>

          <section anchor="sec-connect-request" title="Request Definition">
            <t>
              <figure>
                <!--begin-pdu-->

                <artwork><![CDATA[

   public struct  {
       string ufrag;
       string password;
       uint16 application;
       string fingerprint;
       string role;
       candidate candidate_list<65000>;
   } connect_data;

   public struct {
	  string candidate_string; 
   } candidate;
		

]]></artwork>
              </figure>

              <!--
   connect-data = connect-ufrag 
                     connect-password 
                     connect-application 
                     connect-fingerprint
                     connect-actpass 
                     1*connect-attribute

   connect-ufrag =    string     ; ICE "password"
   connect-password = string     ; ICE "ufrag"
   connect-application = uint16  ; an IANA registered port number 
   connect-fingerprint = string  ; RFC 4572 "fingerprint"
   connect-actpass = string      ; RFC 4145 "role"
                                          ;
   connect-attribute = string    ; ICE candidate

-->
            </t>

            <t>The values contained in connect-request are:</t>

            <t>
              <list style="hanging">
                <t hangText="Ufrag -">The username fragment (from ICE)</t>

                <t hangText="Password -">The ICE password.</t>

                <t hangText="Application -">A 16-bit port number. This port
                number represents the IANA registered port of the protocol
                that is going to be sent on this connection. For SIP, this is
                5060 or 5061, and for RELOAD is TBD. By using the IANA
                registered port, we avoid the need for an additional registry
                and allow RELOAD to be used to set up connections for any
                existing or future application protocol.</t>

                <t hangText="Fingerprint -">One fingerprint attribute (from
                RFC 4572 <xref target="RFC4572" />.</t>

                <t hangText="Role -">An active/passive/actpass attribute from
                RFC 4145 <xref target="RFC4145" />.</t>

                <t hangText="Candidate -">One or more ICE candidate values.
                Each candidate has an IP address, IP address family, port,
                transport protocol, priority, foundation, component ID, STUN
                type and related address. The candidate_list is a list of
                string candidate values.</t>
              </list>
            </t>

            <t>These values should be generated using the procedures of <xref
            target="sec-connect-ice" />.</t>
          </section>

          <section anchor="sec-connect-response" title="Response Definition">
            <t>If a peer receives a CONNECT request, it SHOULD follow the
            procedures of <xref target="sec-connect-ice" /> to process the
            request and generate its own response, containing a connect-data
            production. It should then begin ICE checks. When a peer receives
            a CONNECT response, it SHOULD parse the response and begin its own
            ICE checks.</t>
          </section>
        </section>

        <section anchor="sec-tunnel-details" title="TUNNEL">
          <t>A node sends a TUNNEL request when it wishes to exchange
          application-layer protocol messages without the expense of
          establishing a direct connection via CONNECT or when ICE is unable
          to establish a direct connection via CONNECT and a TURN relay is not
          available. The application-level protocols that are routed via the
          TUNNEL request are defined by that application's usage.</t>

          <note title="Note">
            <t>The decision of whether to route application-level traffic
            across the overlay or to open a direct connection requires careful
            consideration of the overhead involved in each transaction.
            Establishing a direct connection requires greater initial setup
            costs, but after setup, communication is faster and imposes no
            overhead on the overlay. For example, for the SIP usage, an INVITE
            to establish a voice call might be routed over the overlay, a
            SUBSCRIBE with regular updates would be better used with a
            CONNECT, and media would both impose too great a load on the
            overlay and likely receive unacceptable performance. However,
            there may be a tradeoff between locating TURN servers and relying
            on TUNNEL for packet routing.</t>
          </note>

          <t>When a usage requires the TUNNEL method, it must specify the
          specific application protocol(s) that will be TUNNELed and for each
          protocol, specify: <list style="symbols">
              <t>An application attribute that indicates the protocol being
              tunneled. This the IANA-registered port of the application
              protocol.</t>

              <t>The conditions under which the application will be TUNNELed
              over the overlay rather than using a direct CONNECT.</t>

              <t>A mechanism for moving future application-level communication
              from TUNNELing on the overlay to a direct CONNECTion, or an
              explanation why this is unnecessary.</t>

              <t>A means of associating messages together as required for
              dialog-oriented or request/response-oriented protocols.</t>

              <t>How the TUNNELed message (and associated responses) will be
              delivered to the correct application. This is particularly
              important if there might be multiple instances of the
              application on or behind a single peer.</t>
            </list></t>

          <section anchor="sec-tunnel-request" title="Request Definition">
            <t>
              <figure>
                <!--begin-pdu-->

                <artwork><![CDATA[

   public struct  {
       uint16 application;
       string dialog_id;
       string application_pdu;
   } tunnel_data;

]]></artwork>
              </figure>
            </t>

            <t>For each of the values indicated here which were originally
            text, they are preceded by a length field of either one or two
            bytes.</t>

            <t>The values contained in connect-request are:</t>

            <t>
              <list style="hanging">
                <t hangText="Application -">A 16-bit port number. This port
                number represents the IANA registered port of the protocol
                that is going to be sent on this connection. For SIP, this is
                5060 or 5061, and for RELOAD is TBD. By using the IANA
                registered port, we avoid the need for an additional registry
                and allow RELOAD to be used to set up connections for any
                existing or future application protocol.</t>

                <t hangText="Dialog ID -">An arbitrary string providing an
                application-defined way of associating related TUNNELed
                messages. This attribute may also encode sequence information
                as required by the application protocol.</t>

                <t hangText="Application PDU -">An application PDU in the
                format specified by the application.</t>
              </list>
            </t>
          </section>

          <section anchor="sec-tunnel-response" title="Response Definition">
            <t>A TUNNEL response serves as confirmation that the message was
            received by the destination peer. It implies nothing about the
            processing of the application. If the application protocol
            specifies an acknowledgement or confirmation, that must be sent
            with a separate TUNNEL request</t>
          </section>
        </section>
      </section>

      <section title="Data Storage and Retrieval">
        <t>The STORE, FETCH, and REMOVE methods are used to manipulate
        information in the DHT. They form an instantiation of the abstract GET
        and PUT operations described in <xref
        target="I-D.ietf-p2psip-concepts"></xref>.</t>

        <section anchor="sec-store" title="STORE">
          <t>The STORE method is used to store data in the overlay. As
          described in <xref target="sec-typed-data"></xref> each location may
          contain data of multiple types. Each type-id is a code point
          assigned to a specific application usage by IANA. As part of the
          Usage definition, protocol designers may define constraints, such as
          limits on size, on the values which may be stored. For many types,
          the set may be restricted to a single item; some sets may be allowed
          to contain multiple identical items while others may only have
          unique items. The protocol currently defines the following data
          models:</t>

          <t><list style="symbols">
              <t>single value</t>

              <t>array</t>

              <t>dictionary</t>
            </list></t>

          <t>Each type-id MUST specify the appropriate data model for that
          type. The format of the STORE request depends on the data model.</t>

          <section anchor="sec-store-req" title="Request Definition">
            <t>A STORE production is a sequence of type-data pairs, each of
            which represents a sequence of stored values for a given type-id.
            The same type-id MUST NOT be used twice in a given store request.
            Each value is then processed in turn. These operations MUST be
            atomic. If any operation fails, the state MUST be rolled back to
            before the request was received.</t>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
public struct {
	resource_id resource;
	store_type_data store_data<65000>;
} store_request;
              ]]></artwork>
            </figure>

            <t>A single STORE request stores data of a number of types to a
            single resource location. The contents of the request are:</t>

            <list style="hanging">
              <t hangText="Resource -">The resource to store at.</t>

              <t hangText="Store Type Data -">A series of elements, one for
              each type of data to be stored.</t>
            </list>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
public struct {
	type_id type;
	generation_counter generation;
	stored_data values<65000>;
} store_type_data;
              ]]></artwork>
            </figure>

            <t>Each store type data element represents the data to be stored
            for a single type-id. The contents of the element are:</t>

            <list style="hanging">
              <t hangText="Type -">The type-id</t>

              <t hangText="Generation -">The expected current state of the
              generation counter.</t>

              <t hangText="Values -">The value or values to be stored. This
              may contain one or more stored_data values depending on the data
              model associated with each type-id.</t>
            </list>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
public struct {
       uint32 length;
       uint32 storage_time;
       uint32 lifetime;
       blob data-value;
       blob signature;
} stored_data;
              ]]></artwork>
            </figure>

            <t>Each stored_data element represents a single stored data value.
            These elements are individually signed. The contents of the
            element are as follows:</t>

            <list style="hanging">
              <t hangText="Length -">The length of the stored data
              element.</t>

              <t hangText="Storage Time -">The time when the data was stored
              in absolute time, represented in seconds since the Unix epoch.
              Any attempt to store a data value with a storage time before
              that of a value known to the receiving peer MUST generate a 412
              error. This prevents rollback attacks. Note that this does not
              require synchronized clocks: the receiving peer uses the storage
              time in the previous store, not its own clock.</t>

              <t hangText="Lifetime -">The validity period for the data, in
              seconds, starting from the time of store.</t>

              <t hangText="Signature -">A signature over the data value. <xref
              target="sec-data-sig" /> describes the signature computation.
              The element is formatted as described in <xref
              target="sec-signature" /></t>

              <t hangText="Data Value -">The data value itself, as described
              below.</t>
            </list>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
  
public struct {
	opaque value<65000>;
} single_value_entry;

public struct {
	int32 index;
	opaque value<65000>;
} array_entry;		

public struct {
	opaque key<65000>;
	opaque value<65000>;
} dictionary_entry;		
              ]]></artwork>
            </figure>

            <!--   store-request = resource-id 1*store-type-data
   
   store-type-data = type-id
                     generation-counter
                     uint16        ; number of stored data elements
                     1*stored-data 

   generation-counter = uint64

   stored-data = uint32 ; length of the rest of the production
                 stored-data-expiry-time
                 stored-data-value
                 signature

   stored-data-value = single-value / array-entry / dictionary-entry /
                       *byte

   single-value = data-value
		       
   data-value =   uint32 ; length
                  *byte  ; data

   array-entry  = int32  ; index
                  data-value

   dictionary-entry = data-value ; key
                      data-value ; value
-->

            <t>The responsible peer MUST perform the following checks:</t>

            <t>
              <list style="symbols">
                <t>The type-id is known.</t>

                <t>The signature over the message is valid or (depending on
                overlay policy) no signature is required.</t>

                <t>The signatures over each individual data element (if any)
                are valid.</t>

                <t>Each element is signed by a credential which is authorized
                to write this type at this resource-id</t>

                <t>If the generation-counter is non-zero, it must equal the
                current value of the generation-counter for this type. This
                feature allows the generation counter to be used in a way
                similar to the HTTP Etag feature.</t>

                <t>The storage time values are greater than that of any value
                which would be replaced by this STORE. [[OPEN ISSUE: do peers
                need to save the storage time of REMOVEs to prevent
                reinsertion?]]</t>
              </list>
            </t>

            <t>If all these checks succeed, the peer MUST attempt to store the
            data values. If the store succeeds and the data is changed, then
            the peer must increase the generation counter by at least one. If
            there are multiple stored values in a single store-type-data, it
            is permissible for the peer to increase the generation counter by
            only 1 for the entire type-id, or by 1 or more than one for each
            value.</t>

            <t>We now discuss each type of value.</t>

            <section title="Single Value">
              <t>There may be only one single-value element for each
              resource-id, type pair. A store of a new single-value element
              MUST overwrite the current value.</t>
            </section>

            <section title="Array">
              <t>A store of an array entry replaces (or inserts) the given
              value at the location specified by the index. Arrays are
              zero-based. Note that arrays can be sparse. Thus, a store of "X"
              at index 2 in an empty array produces an array with the values [
              NA, NA, "X"]. Future attempts to fetch elements at index 0 or 1
              will return empty strings. If the index value is -1, then the
              value is placed at the end of the array.</t>
            </section>

            <section title="Dictionary">
              <t>A stored dictionary entry has a dictionary-key used as a
              lookup key and a dictionary-value containing the data. There may
              be only one value any given dictionary-key and therefore a write
              to a dictionary-key overwrites whatever is there.</t>
            </section>
          </section>

          <section title="Response Definition">
            <t>In response to a successful STORE request the peer MUST return
            a series of store_type_response elements containing the current
            value of the generation counter for each type-id.</t>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
	      public struct {
	        type_id type;
		generation_counter generation;
	      } store_type_response;
              ]]></artwork>
            </figure>

            <!--
   store-response = 1*store-type-response

   store-type-response = type-id generation-counter
-->

            <t>The contents of each element are:</t>

            <list style="hanging">
              <t hangText="Type -">The type-id being represented.</t>

              <t hangText="Generation -">The current value of the generation
              counter for that type-id.</t>
            </list>

            <t>The response itself is just the store_type_response values
            packed end-to-end.</t>

            <t>If the request was rejected because of an invalid generation
            counter, then the store-response MUST also be returned, but with a
            response code of 412. Otherwise, the response MAY contain a
            response-error-reason production or MAY be empty. [[TODO: The
            generation counter may need more thinking for uniqueness.]]</t>
          </section>

          <section anchor="sec-data-sig" title="Data Signature Computation">
            <t>Each stored-data element is individually signed. However, the
            signature also must be self-contained and cover the type-id and
            resource-id even though they are not present in the stored value.
            The data signed is defined as:</t>

            <t>
              <figure>
                <!--begin-pdu-->

                <artwork><![CDATA[
		public struct {
		   resource_id resource;
		   type_id type;
		   blob stored_data;
		} stored_data_to_be_signed;

              ]]></artwork>
              </figure>
            </t>

            <!--   stored-data-to-be-signed = resource-id type-id stored-data -->

            <t>The contents of this value are as follows:</t>

            <list style="hanging">
              <t hangText="Resource -">The resource ID where this data is
              stored.</t>

              <t hangText="Type -">The type-id for this data.</t>

              <t hangText="Stored Data -">The contents of the stored data
              value, as described in the stored_data PDU of <xref
              target="sec-store-req" /></t>
            </list>

            <t>[[TODO: Should we include the identity?.]]</t>

            <t>Once the signature has been computed, the signature is
            represented using a signature element, as described in <xref
            target="sec-signature" />.</t>
          </section>
        </section>

        <section title="FETCH">
          <t>The FETCH request retrieves one or more data elements stored at a
          given resource-id.</t>

          <section title="Request Definition">
            <t>The request consists of a single fetch_request element followed
            by a series of fetch_type_data elements. <figure>
                <!--begin-pdu-->

                <artwork><![CDATA[
		public struct {
		       resource_id resource;
		       fetch_type_data fetch_data<65000>;
		} fetch_request;
              ]]></artwork>
              </figure> <t> The contents of the request are as follows: </t>
            <list style="hanging">
                <t hangText="Resource -">The resource ID to fetch from.</t>

                <t hangText="Fetch Data -">A sequence of data specifiers, one
                for each desired type ID.</t>
              </list> <t> Each fetch_type_data element is specified as
            follows. </t> <figure>
                <!--begin-pdu-->

                <artwork><![CDATA[
		public struct {
		  type_id type;
		  generation_counter generation;
		  fetch_data_reference reference;
		} fetch_type_data;
              ]]></artwork>
              </figure></t>

            <list style="hanging">
              <t hangText="Type -">The type of the data being fetched.</t>

              <t hangText="Generation -">The last generation counter that the
              requesting peer saw. This is used to avoid unnecessary
              fetches.</t>

              <t hangText="Reference -">A reference to the data value being
              requested within the data model specified for the type, as
              specified below.</t>
            </list>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
		public struct {
		  int32 first;
		  int32 last;				
		} fetch_array_reference;		

		public struct {
		  dictionary_key dictionary_keys<65000>;		  
		} fetch_dictionary_reference;

		public struct {
		  string key_value<65000>;
                } dictionary_key;
              ]]></artwork>
            </figure>

            <!--
		enum {fetch_single_type(1), fetch_array_type(2), fetch_dictionary_type(3)} fetch_type;

		select {
		  case fetch_array_type:
		    fetch_array_reference array_ref;
                  case fetch_dictionary_type:
                    fetch_dictionary_reference dictionary_ref;
		} fetch_data_reference;
-->

            <!--   fetch-request = resource-id 1*fetch-type-data
   
   fetch-type-data = type-id
                     generation-counter
                     fetch-data-reference
  
   fetch-data-reference = array-reference / dictionary-reference / *byte

   array-reference = int32 int32

   dictionary-reference = uint32        ; number of keys
                          *data-value  ; list of dictionary keys-->

            <t>As with STORE, the fetch request contains a list of type-ids
            and associated references. The reference encoding depends on the
            type of value being stored.</t>

            <list style="symbols">
              <t>If the data is of type single value, the reference is
              empty.</t>

              <t>If the data is of type array, the reference contains two
              integers. The first integer is the beginning of the range and
              the second is the end of the range. 0 is used to indicate the
              first element and -1 is used to indicate the final element. The
              beginning of the range MUST be earlier in the array then the
              end.</t>

              <t>If the data is of type dictionary then the reference contains
              a list of the dictionary keys being requested. If no keys are
              specified, than this is a wildcard fetch and all key-value pairs
              should be returned.</t>
            </list>

            <t>The generation-counter is used to indicate the requester's
            expected state of the storing peer. If the generation-counter in
            the request matches the stored counter, then the storing peer
            returns a cache hit indicator rather than the stored data.</t>

            <t>Note that because the certificate for a user is typically
            stored at the same location as any data stored for that user, a
            requesting peer which does not already have the user's certificate
            should request the certificate in the FETCH as an
            optimization.</t>
          </section>

          <section title="Response Definition">
            <t><figure>
                <!--begin-pdu-->

                <artwork><![CDATA[
	      public struct {
	        type_id type;
		generation_counter generation;
		opaque stored_data<65000>;
	      } fetch_response;
              ]]></artwork>
              </figure></t>

            <!--
   fetch-response = 1*fetch-type-value 
 
   fetch-type-value = type-id
                      generation-counter
                      uint16        ; number of stored data elements
                      1*stored-data
-->

            <t>There MUST be one fetch_type_data element for each type-id in
            the request. If the generation-counter in the request matches the
            generation-counter in the stored data, then the count of stored
            data elements MUST be zero. Otherwise, all relevant data values
            MUST be returned. A nonexistent value is represented as a value
            with an empty data value portion and no signature. In particular,
            if a dictionary key that does not exist is requested, then there
            must be a dictionary entry with that key but an empty value.</t>
          </section>
        </section>

        <section title="REMOVE">
          <t>The REMOVE request is used to remove a stored element or elements
          from the storing peer. Although each type-id defines its own access
          control requirements, in general only the original signer of the
          data should be allowed to remove it. Any successful remove of an
          existing element for a given type-id MUST increment the generation
          counter by at least one.</t>

          <t>A remove-request has exactly the same syntax as a FETCH request
          except that each entry represents a set of values to be removed
          rather than returned. The same type-id MUST NOT be used twice in a
          given remove-request. Each fetch-type-data is then processed in
          turn. These operations MUST be atomic. If any operation fails, the
          state MUST be rolled back to before the request was received.</t>

          <t>Before processing the REMOVE request, the peer MUST perform the
          following checks.</t>

          <t><list style="symbols">
              <t>The type-id is known.</t>

              <t>The signature over the message is valid or (depending on
              overlay policy) no signature is required.</t>

              <t>The signer of the message has permissions which permit him to
              remove this type of data.</t>

              <t>If the generation-counter is non-zero, it must equal the
              current value of the generation-counter for this type. This
              feature allows the generation counter to be used in a way
              similar to the HTTP Etag feature.</t>
            </list></t>

          <t>Assuming that the request is permitted, the operations proceed as
          follows.</t>

          <section title="Single Value">
            <t>A REMOVE of a single value element simple causes it not to
            exist. If no such element exists, then this simply is a silent
            success.</t>
          </section>

          <section title="Array">
            <t>A REMOVE of an array element (or element range) replaces those
            elements with empty elements. Note that this does not cause the
            array to be packed. An array which contains ["A", "B", "C"] and
            then has element 0 removed produces an array containing [NA, "B",
            "C"]. Note, however, that the removal of the final element of the
            array shortens the array, so in the above case, the removal of
            element 2 makes the array ["A", "B"].</t>
          </section>

          <section title="Dictionary">
            <t>A REMOVE of a dictionary element (or elements) replaces those
            elements with empty elements. If no such elements exist, then this
            is a silent success.</t>
          </section>

          <section title="Response Definition">
            <t>The response to a successful REMOVE simply contains a list of
            the new generation counters for each type-id, using the same
            syntax as the response to a STORE request. Note that if the
            generation counter does not change, that means that the requested
            items did not exist. However, if the generation counter does
            change, that does not mean that the items existed.</t>
          </section>
        </section>

        <section title="FIND">
          <t>The FIND request is used to explore the DHT. A FIND request for a
          resource-id R and a type-id T retrieves the resource-id (if any) of
          the resource of type T known to the target peer which is closes to
          R. This method can be used to walk the DHT by interactively fetching
          R_n+1=nearest(1 + R_n).</t>

          <section title="Request Definition">
            <t>
              <figure>
                <!--begin-pdu-->

                <artwork><![CDATA[
		public struct {
		  resource_id resource;
		  type_id ids<255>;
		} find_request;
              ]]></artwork>
              </figure>
            </t>

            <!-- find-request = resource-id 1*type-id -->
          </section>

          <t>The request contains a list of type-ids which the FIND is for, as
          indicated below.</t>

          <list style="hanging">
            <t hangText="Resource -">The desired resource-id</t>

            <t hangText="Ids -">The desired type-ids. Each value MUST only
            appear once.</t>
          </list>

          <section title="Response Definition">
            <t>
              <figure>
                <!--begin-pdu-->

                <artwork><![CDATA[
		public struct {
		  type_id type;
		  resource_id closest_resource;
                } find_type_data;
              ]]></artwork>
              </figure>
            </t>

            <t>If the processing peer is not responsible for the specified
            resource-id, it SHOULD return a 404 error.</t>

            <t>When each type is defined, it can indicate if the type is not
            allowed to be used in a FIND request. This would be done to help
            achieve some types of security properties for the data stored in
            that type.</t>

            <t>For each type-id in the request the response MUST contain a
            find-response-value indicating the closest resource-id for that
            type-id unless the type is not allowed to be used with FIND in
            which case a find_type_data for that type_id MUST NOT be included
            in the response. If a type-id is not known, then the corresponding
            resource-id MUST be 0. Note that different type-ids may have
            different closest resource-ids.</t>

            <t>The response is simply a series of find_type_data elements, one
            per type, concatenated end-to-end. The contents of each element
            are:</t>

            <list style="hanging">
              <t hangText="Type -">The type-id.</t>

              <t hangText="Closest Resource -">The closest resource ID to the
              specified resource ID. This is 0 if no resource ID is known.</t>
            </list>

            <t>Note that the response does not contain the contents of the
            data stored at these resource-ids. If the requester wants this, it
            must retrieve it using FETCH.</t>
          </section>
        </section>
      </section>

      <section anchor="sec-dht-maint" title="DHT Maintenance">
        <t>This section describes methods that are expected to be useful for
        all DHTs. These methods have generic semantics (join, leave, update)
        and some common fields, but where appropriate allow room for
        DHT-specific data.</t>

        <section title="JOIN">
          <t>A new peer (but which already has credentials) uses the JOIN
          message to join the DHT. The JOIN is sent to the peer which
          previously was responsible for the resource-id corresponding to the
          peer-id which the new peer has. This notifies the responsible peer
          that the new peer is taking over some of the overlay and it needs to
          synchronize its state.</t>

          <t><figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
	      public struct {
		peer_id desired_peer_id;
		blob dht_specific_data;
	      } join_request;
              ]]></artwork>
            </figure></t>

          <!--    join-request = peer-id -->

          <t>The default JOIN request contains only the peer-id which the
          sending peer wishes to assume. DHTs MAY specific other data to
          appear in this request.</t>

          <t>By default, responding peer simply responds with success or
          failure. However, if it is success it MUST follow up by executing
          the right sequence of STOREs and UPDATEs to transfer the appropriate
          section of the overlay space to the joining peer. In addition, DHTs
          MAY define data to appear in the response payload.</t>
        </section>

        <section title="LEAVE">
          <t>The LEAVE message is used to indicate that a peer is exiting the
          overlay. The peer SHOULD send this message to each peer with which
          it is directly connected prior to exiting the overlay.</t>

          <t><figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
	      public struct {
		peer_id leaving_peer_id;
		blob dht_specific_data;
	      } leave_request;

              ]]></artwork>
            </figure></t>

          <!--    leave-request = peer-id -->

          <t>The default LEAVE request contains only the peer-id of the
          leaving peer. DHTs MAY specific other data to appear in this
          request.</t>

          <t>Upon receiving LEAVE, a peer MUST update its own routing and
          routing table, and send the appropriate STORE/UPDATE sequences to
          restabilize the overlay.</t>
        </section>

        <section title="UPDATE">
          <t>Update is the primary DHT-specific maintenance message. It is
          used by the sender to notify the recipient of the sender's view of
          the current state of the overlay and it is up to the recipient to
          take whatever actions are appropriate to deal with the state
          change.</t>

          <t>The contents of the UPDATE request are completely DHT-specific.
          The UPDATE response is expected to be either success or an
          error.</t>
        </section>
      </section>
    </section>

    <section anchor="sec-connect-ice" title="ICE and Connection Formation">
      <t>At numerous times during the operation of RELOAD, a node will need to
      establish a connection to another node. This may be for the purposes of
      building finger tables when the node joins the P2P network, or when the
      node learns of a new neighbor through an UPDATE and needs to establish a
      connection to that neighbor.</t>

      <t>In addition, a node may need to connect to another node for the
      purposes of an application connection. In the case of SIP, when a node
      has looked up the target AOR in the DHT, it will obtain a Node-ID that
      identifies that peer. The next step will be to establish a "direct"
      connection for the purposes of performing SIP signaling.</t>

      <t>In both of these cases, the node starts with a destination Node-ID,
      and its objective is to create a connection (ideally using TCP, but
      falling back to UDP when it is not available) to the node with that
      given Node-ID. The establishment of this connection is done using the
      CONNECT request in conjunction with ICE. It is assumed that the reader
      has familiarity with ICE.</t>

      <t>RELOAD implementations MUST implement full ICE. Because RELOAD always
      tries to use TCP and then UDP as a fallback, there will be multiple
      candidates of the same IP version, which requires full ICE.</t>

      <section title="Overview">
        <t>To utilize ICE, the CONNECT method provides a basic offer/answer
        operation that exchanges a set of candidates for a single "stream". In
        this case, the "stream" refers not to RTP or other types of media, but
        rather to a connection for RELOAD itself or for SIP signaling. The
        CONNECT request contains the candidates for this stream, and the
        CONNECT response contains the corresponding answer with candidates for
        that stream. Though CONNECT provides an offer/answer exchange, it does
        not actually carry or utilize Session Description Protocol (SDP)
        messages. Rather, it carries the raw ICE parameters required for ICE
        operation, and the ICE spec is utilized as if these parameters had
        actually been used in an SDP offer or answer. In essence, ICE is
        utilized by mapping the CONNECT parameters into an SDP for the
        purposes of following the details of ICE itself. That avoids the need
        for RELOAD to respecify ICE, yet allows it to operate without the
        baggage that SDP would bring.</t>

        <t>In addition, RELOAD only allows for a single offer/answer exchange.
        Unlike the usage of ICE within SIP, there is never a need to send a
        subsequent offer to update the default candidates to match the ones
        selected by ICE.</t>

        <t>RELOAD and SIP always run over TLS for TCP connections and DTLS
        <xref target="RFC4347"></xref> for UDP "connections". Consequently,
        once ICE processing has completed, both agents will begin TLS and DTLS
        procedures to establish a secure link. Its important to note that, had
        a TURN server been utilized for the TCP or UDP stream, the TURN server
        will transparently relay the TLS messaging and the encrypted TLS
        content, and thus will not have access to the contents of the
        connection once it is established. Any attack by the TURN server to
        insert itself as a man-in-the-middle are thwarted by the usage of the
        fingerprint mechanism of RFC 4572 <xref target="RFC4572"></xref>,
        which will reveal that the TLS and DTLS certificates are not a match
        for the ones used to sign the RELOAD messages.</t>

        <t>An agent follows the ICE specification as described in <xref
        target="I-D.ietf-mmusic-ice"></xref> and <xref
        target="I-D.ietf-mmusic-ice-tcp"></xref> with the changes and
        additional procedures described in the subsections below.</t>
      </section>

      <section anchor="sec-collect" title="Collecting STUN Servers">
        <t>ICE relies on the node having one or more STUN servers to use. In
        conventional ICE, it is assumed that nodes are configured with one or
        more STUN servers through some out-of-band mechanism. This is still
        possible in RELOAD but RELOAD also learns STUN servers as it connects
        to other peers. Because all RELOAD peers implement ICE and use STUN
        keepalives, every peer is a STUN server<xref
        target="I-D.ietf-behave-rfc3489bis"></xref>. Accordingly, any peer you
        know about will be willing to be a STUN server for you -- though of
        course it may be behind a NAT.</t>

        <t>A peer on a well-provisioned wide-area overlay will be configured
        with one or more bootstrap peers. These peers make an initial list of
        STUN servers. However, as the peer forms connections with additional
        peers, it builds more peers it can use as STUN servers.</t>

        <t>Because complicated NAT topologies are possible, a peer may need
        more than one STUN server. Specifically, a peer that is behind a
        single NAT will typically observe only two IP addresses in its STUN
        checks: its local address and its server reflexive address from a STUN
        server outside its NAT. However, if there are more NATs involved, it
        may discover that it learns additional server reflexive addresses
        (which vary based on where in the topology the STUN server is). To
        maximize the chance of achieving a direct connection, A peer SHOULD
        group other peers by the peer-reflexive addresses it discovers through
        them. It SHOULD then select one peer from each group to use as a STUN
        server for future connections.</t>

        <t>Only peers to which the peer currently has connections may be used.
        If the connection to that host is lost, it MUST be removed from the
        list of stun servers and a new server from the same group SHOULD be
        selected.</t>

        <t>OPEN ISSUE: should the peer try to keep at least one peer in each
        group, even if it has no other reason for the connection? Need to
        specify when to stop adding new groups if the peer is behind a really
        bad NAT.</t>

        <t>OPEN ISSUE: RELOAD-01 had a Peer-Info structure that allowed peers
        to exchange information such as a "default" IP-port pair in UPDATEs.
        This structure could be expanded to include the candidate list for a
        peer, thus allowing ICE negotiation to begin or even direct
        communication before a CONNECT request has been received. (The
        candidate pairs for the P2P port are fixed because the same source
        port is used for all connections.) However, because this would require
        significant changes to the ICE algorithm, we have not introduced such
        an extension at this point.</t>
      </section>

      <section anchor="sec-gather" title="Gathering Candidates">
        <t>When a node wishes to establish a connection for the purposes of
        RELOAD signaling or SIP signaling (or any other application protocol
        for that matter), it follows the process of gathering candidates as
        described in Section 4 of ICE <xref
        target="I-D.ietf-mmusic-ice"></xref>. RELOAD utilizes a single
        component, as does SIP. Consequently, gathering for these "streams"
        requires a single component.</t>

        <t>An agent MUST implement ICE-tcp <xref
        target="I-D.ietf-mmusic-ice"></xref>, and MUST gather at least one UDP
        and one TCP host candidate for RELOAD and for SIP.</t>

        <t>The ICE specification assumes that an ICE agent is configured with,
        or somehow knows of, TURN and STUN servers. RELOAD provides a way for
        an agent to learn these by querying the ring, as described in <xref
        target="sec-collect"></xref> and <xref
        target="sec-stun-turn-usage"></xref>.</t>

        <t>The agent SHOULD prioritize its TCP-based candidates over its
        UDP-based candidates in the prioritization described in Section 4.1.2
        of ICE <xref target="I-D.ietf-mmusic-ice"></xref>.</t>

        <t>The default candidate selection described in Section 4.1.3 of ICE
        is ignored; defaults are not signaled or utilized by RELOAD.</t>
      </section>

      <section title="Encoding the CONNECT Message">
        <t>Section 4.3 of ICE describes procedures for encoding the SDP.
        Instead of actually encoding an SDP, the candidate information (IP
        address and port and transport protocol, priority, foundation,
        component ID, type and related address) is carried within the
        attributes of the CONNECT request or its response. Similarly, the
        username fragment and password are carried in the CONNECT message or
        its response. <xref target="sec-connect-details"></xref> describes the
        detailed attribute encoding for CONNECT. The CONNECT request and its
        response do not contain any default candidates or the ice-lite
        attribute, as these features of ICE are not used by RELOAD. The
        CONNECT request and its response also contain a Next-Protocol
        attribute, with a value of SIP or RELOAD, which indicates what
        protocol is to be run over the connection. The RELOAD CONNECT request
        MUST only be utilized to set up connections for application protocols
        that can be multiplexed with STUN and RELOAD itself.</t>

        <t>Since the CONNECT request contains the candidate information and
        short term credentials, it is considered as an offer for a single
        media stream that happens to be encoded in a format different than
        SDP, but is otherwise considered a valid offer for the purposes of
        following the ICE specification. Similarly, the CONNECT response is
        considered a valid answer for the purposes of following the ICE
        specification.</t>

        <t>Since all messages with RELOAD are secured between nodes, the node
        MUST implement the fingerprint attribute of RFC 4572 <xref
        target="RFC4572"></xref>, and encode it into the CONNECT request and
        response as described in <xref target="sec-connect-details"></xref>.
        This fingerprint will be matched with the certificates utilized to
        authenticate the RELOAD CONNECT request and its response.</t>

        <t>Similarly, the node MUST implement the active, passive, and actpass
        attributes from RFC 4145 <xref target="RFC4145"></xref>. However, here
        they refer strictly to the role of active or passive for the purposes
        of TLS handshaking. The TCP connection directions are signaled as part
        of the ICE candidate attribute.</t>
      </section>

      <section title="Verifying ICE Support">
        <t>An agent MUST skip the verification procedures in Section 5.1 and
        6.1 of ICE. Since RELOAD requires full ICE from all agents, this check
        is not required.</t>
      </section>

      <section title="Role Determination">
        <t>The roles of controlling and controlled as described in Section 5.2
        of ICE are still utilized with RELOAD. However, the offerer (the
        entity sending the CONNECT request) will always be controlling, and
        the answerer (the entity sending the CONNECT response) will always be
        controlled. The connectivity checks MUST still contain the
        ICE-CONTROLLED and ICE-CONTROLLING attributes, however, even though
        the role reversal capability for which they are defined will never be
        needed with RELOAD. This is to allow for a common codebase between ICE
        for RELOAD and ICE for SDP.</t>
      </section>

      <section title="Connectivity Checks">
        <t>The processes of forming check lists in Section 5.7 of ICE,
        scheduling checks in Section 5.8, and checking connectivity checks in
        Section 7 are used with RELOAD without change.</t>
      </section>

      <section title="Concluding ICE">
        <t>The controlling agent MUST utilize regular nomination. This is to
        ensure consistent state on the final selected pairs without the need
        for an updated offer, as RELOAD does not generate additional
        offer/answer exchanges.</t>

        <t>The procedures in Section 8 of ICE are followed to conclude ICE,
        with the following exceptions:</t>

        <t><list style="symbols">
            <t>The controlling agent MUST NOT attempt to send an updated offer
            once the state of its single media stream reaches Completed.</t>

            <t>Once the state of ICE reaches Completed, the agent can
            immediately free all unused candidates. This is because RELOAD
            does not have the concept of forking, and thus the three second
            delay in Section 8.3 of ICE does not apply.</t>
          </list></t>
      </section>

      <section title="Subsequent Offers and Answers">
        <t>An agent MUST NOT send a subsequent offer or answer. Thus, the
        procedures in Section 9 of ICE MUST be ignored.</t>
      </section>

      <section title="Media Keepalives">
        <t>STUN MUST be utilized for the keepalives described in Section 10 of
        ICE.</t>
      </section>

      <section title="Sending Media">
        <t>The procedures of Section 11 apply to RELOAD as well. However, in
        this case, the "media" takes the form of application layer protocols
        (RELOAD or SIP for example) over TLS or DTLS. Consequently, once ICE
        processing completes, the agent will begin TLS or DTLS procedures to
        establish a secure connection. The fingerprint from the CONNECT
        request and its response are used as described in RFC 4572 <xref
        target="RFC4572"></xref>, to ensure that another node in the P2P
        network, acting as a TURN server, has not inserted itself as a
        man-in-the-middle. Once the TLS or DTLS signaling is complete, the
        application protocol is free to use the connection.</t>

        <t>The concept of a previous selected pair for a component does not
        apply to RELOAD, since ICE restarts are not possible with RELOAD.</t>
      </section>

      <section title="Receiving Media">
        <t>An agent MUST be prepared to receive packets for the application
        protocol (TLS or DTLS carrying RELOAD, SIP or anything else) at any
        time. The jitter and RTP considerations in Section 11 of ICE do not
        apply to RELOAD or SIP.</t>
      </section>
    </section>

    <!--    <section title="DHT Algorithms">
      <t>This section describes what needs to be specified when specifying a
      new DHT Algorithm.</t>

      <t>Describe this from point of view of event driven system. Events
      include a user deciding to join, leave, etc. and protocol events such as
      receive update, join, etc. When an event is received, DHT defines a
      series of things to send and things to store - the DHT algorithm
      specifies what message gets sent on each event and what gets stored.</t>

      <section title="Generic Algorithm Requirements">
        <t>TODO</t>

        <t><list style="symbols">
            <t>How to store redundant encoding</t>

            <t>Algorithm to go from a seed, such as a user name, to a
            Resource-ID</t>

            <t>Joining procedures</t>

            <t>Stabilization procedures</t>

            <t>Exit procedures</t>

            <t>Keep alive procedures</t>

            <t>Routing and loops</t>

            <t>Merging procedures to recovering from network partitions</t>

            <t>Detecting disconnection from rest of peers</t>
          </list></t>
      </section>
    </section>
-->

    <section title="Chord Algorithm ">
      <t></t>

      <t>This algorithm is assigned the name chord-128-2-8 to indicate it is
      based on Chord, uses a 128 bit hash function, stores 2 redundant copies
      of all data, and has finger tables with 8 entries.</t>

      <section title="Overview">
        <t>The algorithm described here is a modified version of the Chord
        algorithm. Each peer keeps track of a finger table of 8 entries and a
        neighborhood table of 6 entries. The neighborhood table contains the 3
        peers before this peer and the 3 peers after it in the DHT ring. The
        first entry in the finger table contains the peer half-way around the
        ring from this peer; the second entry contains the peer that is 1/4 of
        the way around; the third entry contains the peer that is 1/8th of the
        way around, and so on. Fundamentally, the chord data structure can be
        thought of a doubly-linked list formed by knowing the successors and
        predecessor peers in the neighborhood table, sorted by the peer-id. As
        long as the successor peers are correct, the DHT will return the
        correct result. The pointers to the prior peers are kept to enable
        inserting of new peers into the list structure. Keeping multiple
        predecessor and successor pointers makes it possible to maintain the
        integrity of the data structure even when consecutive peers
        simultaneously fail. The finger table forms a skip list, so that
        entries in the linked list can rapidly be found - it needs to be there
        so that peers can be found in O(log(N)) time instead of the typical
        O(N) time that a linked list would provide.</t>

        <t>A peer, n, is responsible for a particular Resource-ID k if k is
        less than or equal to n and k is greater than p, where p is the peer
        id of the previous peer in the neighborhood table. Care must be taken
        when computing to note that all math is modulo 2^128.</t>
      </section>

      <section title="Routing">
        <t>If a peer is not responsible for a Resource-ID k, then it routes a
        request to that location by routing it to the peer in either the
        neighborhood or finger table that has the largest peer-id that is
        still less than or equal to k.</t>
      </section>

      <section title="Redundancy ">
        <t>When a peer receives a STORE request for Resource-ID k, and it is
        responsible for Resource-ID k, it stores the data and returns a
        SUCCESS response. [[Open Issue: should it delay sending this SUCCESS
        until it has successfully stored the redundant copies?]]. It then
        sends a STORE request to its successor in the neighborhood table and
        to that peers successor. Note that these STORE requests are addressed
        to those specific peers, even though the Resource-ID they are being
        asked to store is outside the range that they are responsible for. The
        peers receiving these check they came from an appropriate predecessor
        in their neighborhood table and that they are in a range that this
        predecessor is responsible for, and then they store the data.</t>

        <note title="Note: ">
          <t>This redundancy algorithm breaks if the storing node is malicious
          and does not store the data in the replica set. Applications which
          wish to have defenses against that must explicitly store multiple
          copies of the data with separate peers. [[OPEN ISSUE: Where should a
          replication algorithm of this type be described? The DHT? The
          storage layer? The usage?]]</t>
        </note>
      </section>

      <section title="Joining">
        <t>The join process for a joining party (JP) with peer-id n is as
        follows.</t>

        <list style="numbers">
          <t>JP connects to its chosen bootstrap node.</t>

          <t>JP uses a series of PINGs to populate its routing table.</t>

          <t>JP sends CONNECT requests to initiate connections to each of the
          peers in the connection table as well as to the desired finger table
          entries. Note that this does not populate their routing tables, but
          only their connection tables, so JP will not get messages that it is
          expected to route to other nodes.</t>

          <t>JP enters all the peers it contacted into its routing table.</t>

          <t>JP sends a JOIN to its immediate successor, the admitting peer
          (AP) for peer-id n. The AP sends the response to the JOIN.</t>

          <t>AP does a series of STORE requests to JP to store the data that
          JP will be responsible for.</t>

          <t>AP sends JP an UPDATE explicitly labelling JP as its predecessor.
          At this point, JP is part of the ring and responsible for a section
          of the overlay. AP can now forget any data which is assigned to JP
          and not AP.</t>

          <t>AP sends an UPDATE to all of its neighbors with the new values of
          its neighbor set (including JP).</t>

          <t>JP sends UPDATES to all the peers in its routing table.</t>
        </list>

        <t>In order to populate its routing table, JP sends a PING via the
        bootstrap node directed at resource-id n+1 (directly after its own
        resource-id). This allows it to discover its own successor. Call that
        node p0. It then sends a ping to p0+1 to discover its successor (p1).
        This process can be repeated to discover as many successors as
        desired. The values for the two peers before p will be found at a
        later stage when n receives an UPDATE.</t>

        <t>In order to set up its neighbor table entry for peer i, JP simply
        sends a CONNECT to peer (n+2^(numBitsInPeerId-i). This will be routed
        to a peer in approximately the right location around the ring.</t>
      </section>

      <section title="UPDATEs">
        <t>An UPDATE is defined as</t>

        <t>
          <figure>
            <!--begin-pdu-->

            <artwork><![CDATA[
	    public struct {
              peer_id predecessors<255>;		   
              peer_id successors<255>;		   
	    } chord_update;
              ]]></artwork>
          </figure>
        </t>

        <!--
  chord-update = uint8    ; number of predecessors
                 *peer-id ; predecessor set
                 uint8    ; number of successors
                 *peer-id ; successor set
-->

        <t>The contents of this message are:</t>

        <list style="hanging">
          <t hangText="Predecessors -">The predecessor set of the UPDATEing
          peer.</t>

          <t hangText="Successors -">The successor set of the UPDATEing
          peer.</t>
        </list>

        <t>A peer MUST maintain an association (via CONNECT) to every member
        of its neighbor set. A peer MUST attempt to maintain at least three
        predecessors and three successors. However, it MUST send its entire
        set in any UPDATE message.</t>

        <section title="Sending UPDATEs">
          <t>Every time a connection to a peer in the neighborhood set is lost
          (as determined by connectivity pings), the peer should remove the
          entry from its neighborhood table and send an UPDATE to all the
          remaining neighbors. The update will contain all the peer-ids of the
          current entries of the table (after the failed one has been
          removed).</t>

          <t>If connectivity is lost to all three of the peers that succeed
          this peer in the ring, then this peer should behave as if it is
          joining the network and use PINGs to find a peer and send it a JOIN.
          If connectivity is lost to all the peers in the finger table, this
          peer should assume that it has been disconnected from the rest of
          the network, and it should periodically try to join the DHT.</t>
        </section>

        <section title="Receiving UPDATEs">
          <t>When a peer, N, receives an UPDATE request, it examines the
          peer-ids in the UPDATE and at its neighborhood table and decides if
          this UPDATE would change its neighborhood table. This is done by
          taking the set of peers currently in the neighborhood table and
          comparing them to the peers in the update request. There are three
          major cases:</t>

          <list style="symbols">
            <t>The UPDATE contains peers that would not change the neighbor
            set because they match the neighborhood table.</t>

            <t>The UPDATE contains peers closer to N than those in its
            neighborhood table.</t>

            <t>The UPDATE defines peers that indicate a neighborhood table
            further away from N than some of its neighborhood table. Note that
            merely receiving peers further away does not demonstrate this,
            since the update could be from a node far away from N. Rather, the
            peers would need to bracket N.</t>
          </list>

          <t>In the first case, no change is needed.</t>

          <t>In the second case, N MUST attempt to CONNECT to the new peers
          and if it is successful it MUST adjust its neighbor set accordingly.
          Note that it can maintain the now inferior peers as neighbors, but
          it MUST remember the closer ones.</t>

          <t>The third case implies that a neighbor has disappeared, most
          likely because it has simply been disconnected but perhaps because
          of overlay instability. N MUST PING the questionable peers to
          discover if they are indeed missing and if so, remove them from its
          neighborhood table.</t>

          <t>After any PINGs and CONNECTs are done, if the neighborhood table
          changes, the peer sends an UPDATE request to each of its neighbors
          that was in either the old table or the new table. These UPDATEs are
          what ends up filling in the predecessor/successor tables of peers
          that this peer is a neighbor to. A peer MUST NOT enter itself in
          its successor or predecessor table and instead should leave the
          entries empty.</t>

          <t>A peer N which is responsible for a resource-id R discovers that
          the replica set for R (the next two nodes in its successor set) has
          changed, it MUST send a STORE for any data associated with R to any
          new node in the replica set. It SHOULD not delete data from peers
          which have left the replica set.</t>

          <t>When a peer N detects that it is no longer in the replica set for
          a resource R (i.e., there are three predecessors between N and R),
          it SHOULD delete all data associated with R from its local
          store.</t>
        </section>

        <section title="Stabilization">
          <t>A peer MUST periodically send an UPDATE to every peer in its
          routing table. The purpose of this is to keep the predecessor and
          successor lists up to date and to detect connection failures. The
          default time is about every ten minutes, but the enrollment server
          SHOULD set this in the configuration document using the
          "chord-128-2-8-update-frequency" element (denominated in seconds.) A
          peer SHOULD randomly offset these UPDATEs so they do not occur all
          at once. If an UPDATE fails or times out, the peer MUST mark that
          entry in the neighbor table invalid and attempt to reestablish a
          connection. If no connection can be established, the peer MUST
          attempt to establish a new peer as its neighbor and do whatever
          replica set adjustments are required.</t>

          <t>Periodically a peer should select a random entry i from the
          finger table and do a PING to peer (n+2^(numBitsInPeerId-i). The
          purpose of this is to find a more accurate finger table entry if
          there is one. This is done less frequently than the connectivity
          checks in the previous section because forming new connections is
          somewhat expensive and the cost needs to be balanced against the
          cost of not having the most optimal finger table entries. The
          default time is about every hour, but the enrollment server SHOULD
          set this in the configuration document using the
          "chord-128-2-8-ping-frequency" element (denominated in seconds). If
          this returns a different peer than the one currently in this entry
          of the peer table, then a new connection should be formed to this
          peer and it should replace the old peer in the finger table.</t>
        </section>
      </section>

      <section title="Leaving">
        <t>Peers SHOULD send a LEAVE request prior to exiting the DHT. Any
        peer which receives a LEAVE for a peer n in its neighbor set must
        remove it from the neighbor set, update its replica sets as
        appropriate (including STOREs of data to new members of the replica
        set) and send UPDATEs containing its new predecessor and successor
        tables.</t>
      </section>
    </section>

    <section anchor="secEnrollment" title="Enrollment and Bootstrap">
      <section title="Discovery">
        <t>When a peer first joins a new overlay, it starts with a discovery
        process to find an enrollment server. Related work to the approach
        used here is described in <xref
        target="I-D.garcia-p2psip-dns-sd-bootstrapping"></xref> and <xref
        target="I-D.matthews-p2psip-bootstrap-mechanisms"></xref>. The peer
        first determines the overlay name. This value is provided by the user
        or some other out of band provisioning mechanism. If the name is an IP
        address, that is directly used otherwise the peer MUST do a DNS SRV
        query using a Service name of "p2p_enroll" and a proto of tcp to find
        an enrollment server.</t>

        <t>If the overlay name ends in .local, then the DNS SRV lookup is done
        using implement <xref target="I-D.cheshire-dnsext-dns-sd"></xref> with
        a Service name of "p2p_menroll" can also be tried to find an
        enrollment server. If they implement this, the user name can be used
        as the Instance Identifier label.</t>

        <t>Once an address for the enrollment servers is determined, the peer
        forms an HTTPS connection to that IP address. The certificate MUST
        match the overlay name as described in <xref target="RFC2818"></xref>.
        The peer then performs a GET to the URL formed by appending a path of
        "/p2psip/enroll" to the overlay name. For example, if the overlay name
        was example.com, the URL would be
        "https://example.com/p2psip/enroll".</t>

        <t>The result is an XML configuration file with the syntax described
        in the following section.</t>
      </section>

      <section anchor="sec-configuration" title="Overlay Configuration">
        <t>This specification defines a new content type
        "application/p2p-overlay+xml" for an MIME entity that contains overlay
        information. An example document is shown below.</t>

        <t>
          <figure>
            <artwork><![CDATA[
   <?xml version="1.0" encoding="US-ASCII"?>
     <overlay name="chord.example.com" expiration="86400">
       <dht name="chord-128-2-8"/>
       <root-cert>[DER here]</root-cert>
       <required-usage name="SIP"/>
       <credential-server url="https://www.example.com/csr"/>
       <bootstrap-peer address="192.0.2.2" port="5678"/>
       <bootstrap-peer address="192.0.2.3" port="5678"/>
       <bootstrap-peer address="192.0.2.4" port="5678"/>
       <multicast-bootstrap="192.0.2.99" port="5678"/>
     </overlay>
              ]]></artwork>
          </figure>
        </t>

        <t>The file MUST be a well formed XML document and it SHOULD contain
        an encoding declaration in the XML declaration. If the charset
        parameter of the MIME content type declaration is present and it is
        different from the encoding declaration, the charset parameter takes
        precedence. Every application conferment to this specification MUST
        accept the UTF-8 character encoding to ensure the minimal
        interoperability. The namespace for the elements defined in this
        specification is urn:ietf:params:xml:ns:p2p:overlay.</t>

        <t>The file can contain multiple "overlay" elements where each one
        contains the configuration information for a different overlay. Each
        "overlay" has the following attributes:</t>

        <t>
          <list style="hanging">
            <t hangText="name:">name of the overlay</t>

            <t hangText="expiration:">time in future at which this overlay
            configuration is not longer valid and need to be retrieved again.
            This is expressed in seconds from the current time.</t>
          </list>
        </t>

        <t>Inside each overlay element, the following elements can occur:</t>

        <list style="hanging">
          <t hangText="dht -">This element has an attribute called name that
          describes which dht algorithm is being used.</t>

          <t hangText="root-cert -">This element contains a DER encoded
          X.509v3 certificate that is the root trust store used to sign all
          certificates in this overlay. There can be more than one of
          these.</t>

          <t hangText="required-usage -">This element has an attribute called
          "name" that describes a usage that peers in this overlay are
          required to support. More than one required-usage element may be
          present.</t>

          <t hangText="credential-server -">This element contains the URL at
          which the credential server can be reached in a "url" element. This
          URL MUST be of type "https:". More than one credential-server
          element may be present.</t>

          <t hangText="bootstrap-peer -">This elements represents the address
          of one of the bootstrap peers. It has an attribute called "address"
          that represents the IP address and an attribute called "port" that
          represents the port. More than one bootstrap-peer element may be
          present.</t>

          <t hangText="multicast-bootstrap -">This element represents the
          address of a multicast address and port that may be used for
          bootstrap and that peers SHOULD listen on to enable bootstrap. It
          has an attributed called "address" that represents the IP address
          and an attribute called "port" that represents the port. More than
          one "multicast-bootstrap" element may be present.</t>
        </list>

        <t>[[TODO: Do a RelaxNG grammar.]]</t>
      </section>

      <section title="Credentials">
        <t>If a credential-server element is provided in the configuration
        document, that means that credentials are required to use the DHT. A
        peer which does not yet have credentials MUST contact the credential
        server to acquire them.</t>

        <t>In order to acquire credentials, the peer generates an asymmetric
        key pair and then generates a "Simple Enrollment Request" (as defined
        in <xref target="I-D.ietf-pkix-2797-bis"></xref>) and sends this over
        HTTPS as defined in <xref target="I-D.ietf-pkix-cmc-trans"></xref> to
        the URL in the credential-server element. The subjectAltName in the
        request MUST contain the required user name(s).</t>

        <t>The credential server MUST authenticate the request using HTTP
        digest <xref target="RFC2617"></xref>. If the authentication succeeds
        and the requested user name(s) is acceptable, the server and returns a
        certificate. The SubjectAltName field in the certificate contains the
        following values:</t>

        <t><list style="symbols">
            <t>One or more Peer-IDs which MUST be cryptographically random
            <xref target="RFC4086"></xref>. These MUST be chosen by the
            credential server in such a way that they are unpredictable to the
            requesting user.</t>

            <t>The names this user is allowed to use in the overlay</t>
          </list></t>

        <t>The certificate is returned in a "Simple Enrollment Response".</t>

        <t>The client MUST check that the certificate returned was signed by
        one of the certificates received in the "root-cert" list of the
        overlay configuration data. The peer then reads the certificate to
        find the Peer-IDs it can use.</t>
      </section>

      <section title="Locating a Peer">
        <t>In order to join the overlay, the peer MUST contact a bootstrap
        peer. If the peer has cached bootstrap peers it SHOULD contact them
        first by sending a PING to the known peer address with the destination
        peer-id set to that peer's peer-id.</t>

        <t>If no cached peers are available, then the peer SHOULD send a PING
        to the address and port found in the broadcast-peers element in the
        configuration document. This MAY be a multicast or anycast address.
        The PING should use the wildcard peer-id as the destination
        peer-id.</t>

        <t>The responder peer that receives the PING SHOULD check that the
        overlay name is correct and that the requester peer sending the
        request has appropriate credentials for the overlay before responding
        to the PING even if the response is only an error.</t>

        <t>When the requester peer finally does receive a response from some
        responding peer, it can note the peer-id in the response and use this
        peer-id to start sending requests to join the DHT as described in
        <xref target="sec-join-leave-maint"></xref> and <xref
        target="sec-dht-maint"></xref>.</t>

        <t>After a peer has successfully joined the overlay network, it SHOULD
        periodically look at any peers to which it has managed to form direct
        connections. Some of these peers MAY be added to the cached-peers list
        and used in future boots. Peers that are not directly connected MUST
        not be cached. The RECOMMENDED number of peers to cache is 10.</t>
      </section>
    </section>

    <section title="Usages ">
      <section title="Generic Usage Requirements">
        <t>A new usage MUST specify the following information:</t>

        <list style="symbols">
          <t>The type-ids which the usage defines and what each type
          means.</t>

          <t>The data model for the data being stored (single value, array,
          dictionary, etc.) for each type-id</t>

          <t>Access control rules for each type-id.</t>

          <t>The minimum amounts of data of each type that a conformant
          implementation MUST store.</t>
        </list>

        <t>While each type-id MUST define what data model is used for its
        data, that does not mean that it must define new data models. Where
        useful, type-ids SHOULD use the build-in data models. However, they
        MAY define any new required data models. The intention is that the
        basic data model set be sufficient for most applications/usages.</t>

        <note title="Note:">
          <t>New usages MAY (and where useful SHOULD) reuse existing type-ids.
          New type-ids only need to be defined where different data is stored
          or different behavior is required.</t>
        </note>
      </section>

      <section title="SIP Usage">
        <t>The SIP usage allows a RELOAD overlay to be used as a distributed
        SIP registrar/proxy network. The basic function of the SIP usage is to
        allow Alice to start with a SIP URI (e.g., "bob@dht.example.com") and
        end up with a connection which Bob's SIP UA can use to pass SIP
        messages back and forth to Alice's SIP UA. Provides the following
        three functions:</t>

        <t><list style="symbols">
            <t>Mapping SIP URIs that are not GRUUs to the overlay peer
            responsible for the SIP UA.</t>

            <t>Mapping SIP GRUUs to the DHT peer responsible for the SIP
            UA.</t>

            <t>Forming a connection directly to a DHT peer that is used to
            send SIP messages to the SIP UA.</t>
          </list></t>

        <t><xref target="sec-sip-usage"></xref> provides an overview of how
        these fit together.</t>

        <section title="SIP-REGISTRATION type">
          <t>The first mapping is provided using the SIP-REGISTRATION
          type:</t>

          <t><list style="hanging">
              <t hangText="Type IDs">The seed for the SIP-REGISTRATION type is
              a URI, typically the AOR for the user. The data stored is a
              sip-registration-data, which can contain either another URI or a
              route-list to the peer which is acting for the user. [[TODO: we
              want to somehow put caller-prefs in here along with the route
              list, but I'm not sure how to do it yet.]]</t>

              <t hangText="Data Model">The data model for the SIP-REGISTRATION
              type is dictionary. The dictionary key is the peer-id of the
              storing peer. This allows each peer (presumably corresponding to
              a single device) to store a single route mapping.</t>

              <t hangText="Access Control">If certificate-based access control
              is being used, stored data of type SIP-REGISTRATION must be
              signed by a certificate which (1) contains user name matching
              the storing URI used as the seed for the resource-id and (2)
              contains a peer-id matching the storing dictionary key.</t>

              <t hangText="Data Sizes">Peers MUST be prepared to store
              SIP-REGISTRATION values of up to 10K and must be prepared to
              store up to 10 values for each user name.</t>
            </list></t>

          <t>The contents of the SIP-REGISTRATION type are</t>

          <figure>
            <!--begin-pdu-->

            <artwork><![CDATA[
	    typedef string sip_registration_uri;
	    
	    struct  {
	       string contact_prefs;
	       peer_id route_list<65000>;
	    } sip_registration_route;

	    enum {sip_registration_uri_type(1), sip_registration_route_type(2)} sip_registration_type;

	    select {
	      case sip_registration_uri_type:
	        sip_registration_uri registration_uri;
              case sip_registration_route_type:
                sip_registration_route registration_route;
            } sip_registration_data_;
           
            public struct {
              sip_registration_data_ registration_data;
	    } sip_registration;
                ]]></artwork>
          </figure>

          <t>A registration may contain either a URI (type code 0x01) or a
          contact preferences structure and a route list (type code 0x01). The
          leading byte indicates the type.</t>
        </section>

        <section title="GRUUs">
          <t>GRUUs do not require storing data in the DHT. Rather, they are
          constructed by embedding a base64-encoded route list in the gr URI
          parameter of the GRUU. The base64 encoding is done with the alphabet
          specified in table 1 of RFC 4648 with the exception that ~ is used
          in place of =. An example GRUU is
          "sip:alice@example.com;gr=MDEyMzQ1Njc4OTAxMjM0NTY3ODk~". When a peer
          needs to route a message to a GRUU in the same P2P network, it
          simply uses the route list and connects to that peer.</t>

          <t>Anonymous GRUUs are done in roughly the same way but require
          either that the enrollment server issue a different peer-id for each
          anonymous GRUU required or that a route list be used that includes a
          peer that compresses the route list to stop the peer-id from being
          revealed.</t>
        </section>

        <section title="SIP Connect">
          <t>Once the route list for a user has been identified, the calling
          peer uses the CONNECT request to form a connection to the peer
          identified by the route list. The CONNECT request MUST contain the
          connect-application value of 5160 (SIP). If certificate-based
          authentication is in use, the responding peer MUST present a
          certificate with a peer-id matching the terminal entry in the route
          list.</t>

          <t>[[TODO: Note that this constrains route lists from hiding the
          last peer-id when used here. I think that's OK, but we should take a
          look]]</t>

          <t>Once the association has been formed, the calling peer sends
          generic SIP messages down the new association and ordinary SIP
          procedures are followed.</t>
        </section>

        <section title="SIP Tunnel">
          <t>This usage allows two peers to exchange SIP messages across the
          overlay using the TUNNEL method. TUNNEL is provided as an
          alternative to using CONNECT because it allows a SIP message to be
          sent immediately, without the delay associated with CONNECT. For a
          simple SIP exchange, it may result in fewer messages being sent, as
          well.</t>

          <t>An implementation MUST use CONNECT for a dialog that is expected
          to endure for sufficient time and exchange significant numbers of
          messages. An implementation MAY establish an initial dialog using
          TUNNELing and then migrate it to a direct dialog opened with CONNECT
          once that negotiation is complete.</t>

          <t>As an application of TUNNEL, this usage defines the following
          items: <list style="symbols">
              <t>For SIP, the application attribute is 5060.</t>

              <t>The application MAY establish any dialog using TUNNEL if it
              expects to replace it once a CONNECT request completes. The
              application SHOULD NOT exchange messages with another SIP UA
              repeatedly using a TUNNEL unless it is unable to complete a
              CONNECT.</t>

              <t>The Replaces header should be used to migrate dialogs
              established via TUNNEL to a direct connection.</t>

              <t>The dialogid is the GRUU of the destination of the
              request.</t>

              <t>By using the GRUU of the destination as the dialogid, the
              receiving peer is able to deliver the message to the appropriate
              process without parsing the SIP message.</t>
            </list></t>

          <t>In constructing the message, the SIP UA forms the message as if
          it were being routed directly to the GRUU of the destination. The
          SIP stack hands the message to RELOAD for delivery. Although the
          message is passed through a sequence of untrusted peers, it is not
          subject to modification by those peers because of the message's
          signature.</t>

          <t>OPEN ISSUE: should specify how to request encryption of the
          message end-to-end.</t>

          <note title="Note:">
            <t>The easiest implementation of TUNNEL is likely to default to
            sending all messages across a TUNNEL when the first message is
            sent to a new destination GRUU and simultaneously issuing a
            CONNECT. Messages then continue through the TUNNEL until the
            CONNECT completes, at which point they are delivered via the new
            connection.</t>
          </note>

          <t>OPEN ISSUE: If the tunneling vs direct decision can be made
          equivalently to a link-layer decision, it may not be necessary to
          modify the dialog or inform the SIP UA in any way that it has now
          obtained a direct route.</t>
        </section>
      </section>

      <section anchor="sec-stun-turn-usage" title="TURN Usage">
        <t>When a node starts up, it joins the overlay network and forms
        several connection in the process. If the ICE stage in any of these
        connection return a reflexive address that is not the same as the
        peers perceived address, then the peers is behind a NAT and not an
        candidate for a TURN server. Additionally, if the peers IP address is
        in the private address space range, then it is not a candidate for a
        TURN server. Otherwise, the peer SHOULD assume it is a potential TURN
        server and follow the procedures below.</t>

        <t>If the node is a candidate for a TURN server it will insert some
        pointers in the overlay so that other peers can find it. The overlay
        configuration file specifies a turnDensity parameter that indicates
        how many times each TURN server should record itself in the overlay.
        Typically this should be set to the reciprocal of the estimate of what
        percentage of peers will act as TURN servers. For each value, called
        d, between 1 and turnDensity, the peer forms a seed by concatenating
        its peer-ID and the value d. This seed is hashed to form a
        Resource-ID. The address of the peer is stored at that Resource-ID
        using type TURN-SERVICE and the turn-server production:</t>

        <note title="Note:">
          <t>Correct functioning of this algorithm depends critically on
          having turnDensity be an accurate estimate of the true density of
          TURN servers. If turnDensity is too high, then the process of
          finding TURN servers becomes extremely expensive as multiple
          candidate resource-ids must be probed.</t>
        </note>

        <t>Peers peers that provide the STUN-Relay server type need to support
        the TURN extensions to STUN for media relay of both UDP and TCP
        traffic as defined in <xref target="I-D.ietf-behave-turn" /> and [Add
        REF for TURN-TCP].</t>

        <figure>
          <!--begin-pdu-->

          <artwork><![CDATA[
	  public struct {
                 uint8 iteration;
		 ip_address_and_port address;
	  } turn_server;
         ]]></artwork>

          <t>[[OPEN ISSUE: This structure only works for TURN servers that
          have public addresses. It may be possible to use TURN servers that
          are behind well-behaved NATs by first ICE connecting to them. If we
          decide we want to enable that, this structure will need to change to
          either be a peer-id or include that as an option.]]</t>

          <!--
  turn-server = ip-address-and-port

  ip-address-and-port = ip-address
                        ip-port
  
  ip-address = ip-address-type 
               ip4-address / ip6-address

  ip-address-type = ip4-address-type / ip6-address-type  ; uint8
  ip4-address-type = 0x01
  ip6-address-type = 0x02
  
  ip4-address      = uint32
  ip6-address      = uint128

  ip-port = uint16
  iteration = uint8
-->
        </figure>

        <t>
          <list style="hanging">
            <t hangText="Type IDs">This usage defines the TURN-SERVICE type-id
            to indicate that a peer is willing to act as a TURN server. The
            FIND command MUST return results for the TURN-SERVICE type-id.</t>

            <t hangText="Data Model">The TURN-SERVICE stores a single value
            for each resource-id.</t>

            <t hangText="Access Control">If certificate-based access control
            is being used, stored data of type TURN-SERVICE MUST be
            authenticated by a certificate which contains a peer-id which when
            hashed with the iteration counter produces the resource-id being
            stored at.</t>

            <t hangText="Data Sizes">TURN-SERVICE values are of fixed size.
            Peers MUST be prepared to store values with iteration counter of
            up to 100.</t>
          </list>
        </t>

        <t>The data is stored in a data structure with the IP address of the
        server and an indication whether the address is an IPv4 or IPv6
        address. The seed used to form the storage Resource-ID is simply the
        peer-id. The access control rule is that the certificate used to sign
        the request must contain a peer-id that when hashed would match the
        Resource-ID where the data is being stored.</t>

        <t>Peers can find other servers by selecting a random Resource-ID and
        then doing a FIND request for the appropriate server type with that
        Resource-ID. The FIND request gets routed to a random peer based on
        the Resource-ID. If that peer knows of any servers, they will be
        returned. The returned response may be empty if the peer does not know
        of any servers, in which case the process gets repeated with some
        other random Resource-ID. As long as the ratio of servers relative to
        peers is not too low, this approach will result in finding a server
        relatively quickly.</t>

        <t>Open issues: Should there be low and high bandwidth version of
        STUN-Relay one can find? Low would be usable for signaling type things
        and high would be usable for audio, video, and others.</t>
      </section>

      <section title="Certificate Store Usages">
        <t>The Certificate Store usage allows a peer to store its certificate
        in the overlay, thus avoiding the need to send a certificate in each
        message - a reference may be sent instead.</t>

        <t>A user/peer SHOULD store its certificate at resource-ids derived
        from two seeds:</t>

        <t><list style="symbols">
            <t>The user names in the certificate.</t>

            <t>The peer-ids in the certificate.</t>
          </list></t>

        <t>Note that in the second case the certificate is not stored at the
        peer's peer-id but rather at a hash of the peer's peer-id. The
        intention here (as is common throughout RELOAD) is to avoid making a
        peer responsible for its own data.</t>

        <t>A peer should ensure that the user's certificates are stored in the
        DHT when joining and redo the check about every 24 hours after that.
        Certificate data should be stored with an expiry time of 60 days. When
        a client is checking the existence of data, if the expiry is less than
        30 days, it should be refreshed to have an expiry of 60 days. The
        certificate information is frequently used for many operations, and
        peers should cache it for 8 hours.</t>

        <t><list style="hanging">
            <t hangText="Type IDs">This usage defines the CERTIFICATE type-id
            to store a peer or user's certificate.</t>

            <t hangText="Data Model">The data model for CERTIFICATE data is of
            type array.</t>

            <t hangText="Access Control">The CERTIFICATE MUST contain a
            peer-id or user name which, when hashed, maps the resource-id at
            which the value is being stored.</t>

            <t hangText="Data Sizes">Peers MUST be prepared to store at least
            10 certificates of sizes up to 1K each.</t>
          </list></t>
      </section>
    </section>

    <section title="Security Considerations">
      <section title="Overview">
        <t>RELOAD provides a somewhat generic DHT storage service, albeit one
        designed to be useful for P2P SIP. In this section we discuss security
        issues that are likely to be relevant to any usage of RELOAD. In the
        subsequent section we describe issues that are specific to SIP.</t>

        <t>In any DHT, any given user depends on a number of peers with which
        they have no well-defined relationship except that they are fellow
        members of the DHT. In practice, these other nodes may be friendly,
        lazy, curious, or outright malicious. No security system can provide
        complete protection in an environment where most nodes are malicious.
        The goal of security in RELOAD is to provide strong security
        guarantees of some properties even in the face of a large number of
        malicious nodes and to allow the DHT to function correctly in the face
        of a modest number of malicious nodes.</t>

        <t>P2PSIP deployments require the ability to authenticate both peers
        and resources (users) without the active presence of a trusted entity
        in the system. We describe two mechanisms. The first mechanism is
        based on public key certificates and is suitable for general
        deployments. The second is based on an overlay-wide shared symmetric
        key and is suitable only for limited deployments in which the
        relationship between admitted peers is not adversarial.</t>
      </section>

      <section title="Attacks on P2P Overlays">
        <t>The two basic functions provided by DHT nodes are storage and
        routing: some node is responsible for storing your data and for
        allowing you to fetch data from others. Some other set of nodes are
        responsible for routing messages to and from the storing nodes. Each
        of these issues is covered in the following sections.</t>

        <t>P2P overlays are subject to attacks by subversive nodes that may
        attempt to disrupt routing, corrupt or remove user registrations, or
        eavesdrop on signaling. The certificate-based security algorithms we
        describe in this draft are intended to protect DHT routing and user
        registration information in RELOAD messages.</t>

        <t>To protect the signaling, the first requirement is to ensure that
        all messages are received from authorized members of the overlay. For
        this reason, RELOAD transports all messages over DTLS or TLS, which
        provides message integrity and authentication of the directly
        communicating peer. In addition, when the certificate-based security
        system is used, messages and data are digitally signed with the
        sender's private key, providing end-to-end security for
        communications.</t>

        <t>In order to protect data storage, in the certificate-based security
        scheme, all stored data is signed by the owner of the data. This
        allows the storing peer to verify that the storer is authorized to
        perform a store at that resource-id and also allows any consumer of
        the data to verify the provenance and integrity of the data when it
        retrieves it.</t>
      </section>

      <section title="Certificate-based Security">
        <t>This specification stores users' registrations and possibly other
        data in a Distributed Hash table (DHT). This requires a solution to
        securing this data as well as securing, as well as possible, the
        routing in the DHT. Both types of security are based on requiring that
        every entity in the system (whether user or peer) authenticate
        cryptographically using an asymmetric key pair tied to a
        certificate.</t>

        <t>When a user enrolls in the DHT, they request or are assigned a
        unique name, such as "alice@dht.example.net". These names are unique
        and are meant to be chosen and used by humans much like a SIP Address
        of Record (AOR) or an email address. The user is also assigned one or
        more peer-IDs by the central enrollment authority. Both the name and
        the peer ID are placed in the certificate, along with the user's
        public key.</t>

        <t>Each certificate enables an entity to act in two sorts of
        roles:</t>

        <t><list>
            <t>As a user, storing data at specific Resource-IDs in the DHT
            corresponding to the user name.</t>

            <t>As a DHT peer with the peer ID(s) listed in the
            certificate.</t>
          </list></t>

        <t>Note that since only users of this DHT need to validate a
        certificate, this usage does not require a global PKI. It does,
        however, require a central enrollment authority which acts as the
        certificate authority for the DHT. This authority signs each peer's
        certificate. Because each peer possesses the CA's certificate (which
        they receive on enrollment) they can verify the certificates of the
        other entities in the overlay without further communication. Because
        the certificates contain the user/peer's public key, communications
        from the user/peer can be verified in turn.</t>

        <t>All implementations MUST implement certificate-based security.</t>
      </section>

      <section title="Shared-Secret Security">
        <t>For small environments where deployment of the PKI necessary to use
        a certificate-based model is impractical, RELOAD supports a shared
        secret security that relies on a single key that is shared among all
        members of the overlay. It is appropriate for small groups that wish
        to form a private network without complexity. In shared secret mode,
        all the peers share a single symmetric key which is used to key
        TLS-PSK <xref target="RFC4279"></xref> or TLS-SRP <xref
        target="I-D.ietf-tls-srp"></xref> mode. A peer which does not know the
        key cannot form TLS connections with any other peer and therefore
        cannot join the overlay.</t>

        <t>The shared-secret scheme prohibits unauthorized peers from joining
        the overlay, but it provides no protection from a compromised peer
        inserting arbitrary resource registrations, performing a Sybil
        attack<xref target="Sybil"></xref>, or performing other attacks on the
        resources or routing. Thus, it is only safe to use in limited settings
        in which peers are not adversarial. In addition, because the messages
        and data are not authenticated, each intermediate peer MUST take care
        to use TLS and check the other peer's knowledge of the shared secret,
        or message insertion is possible.</t>

        <t>If the shared secret key for the shared-key security scheme is
        discovered by an attacker, then most of the security of the scheme is
        lost: an attacker can impersonate any peer to any other peer. Thus,
        the shared-secret scheme is only appropriate for small deployments,
        such as a small office or ad hoc overlay set up among participants in
        a meeting.</t>

        <t>One natural approach to a shared-secret scheme is to use a
        user-entered password as the key. The difficulty with this is that in
        TLS-PSK mode, such keys are highly subject to dictionary attacks. If
        passwords are used as the source of shared-keys, then TLS-SRP is a
        superior choice because it is not subject to dictionary attacks.</t>
      </section>

      <section title="Storage Security">
        <t>When certificate-based security is used in RELOAD, any given
        Resource-ID/type code pair (a slot) is deterministically bound to some
        small set of certificates. In order to write data in a slot, the
        writer must prove possession of the private key for one of those
        certificates. Moreover, all data is stored signed by the certificate
        which authorized its storage. This set of rules makes questions of
        authorization and data integrity - which have historically been thorny
        for DHTs - relatively simple.</t>

        <t>When shared-secret security is used, then all peers trust all other
        peers, provided that they have demonstrated that they have the
        credentials to join the overlay at all. The following text therefore
        applies only to certificate-based security.</t>

        <section title="Authorization">
          <t>When a client wants to store some value in a slot, it first
          digitally signs the value with its own private key. It then sends a
          STORE request that contains both the value and the signature towards
          the storing peer (which is defined by the seed construction
          algorithm for that particular type of value).</t>

          <t>When the storing peer receives the request, it must determine
          whether the storing client is authorized to store in this slot. In
          order to do so, it executes the seed construction algorithm for the
          specified type based on the user's certificate information. It then
          computes the Resource-ID from the seed and verifies that it matches
          the slot which the user is requesting to write to. If it does, the
          user is authorized to write to this slot, pending quota checks as
          described in the next section.</t>

          <t>For example, consider the certificate with the following
          properties:</t>

          <figure>
            <artwork><![CDATA[
        User name: alice@dht.example.com
        Peer-Id:   013456789abcdef
        Serial:    1234
        ]]></artwork>
          </figure>

          <t>If Alice wishes to STORE a value of the "SIP Location" type, the
          seed will be the SIP AOR "sip:alice@dht.example.com". The
          Resource-ID will be determined by hashing the seed. When a peer
          receives a request to store a record at Resource-ID X, it takes the
          signing certificate and recomputes the seed, in this case
          "alice@dht.example.com". If H("alice@dht.example.com")=X then the
          STORE is authorized. Otherwise it is not. Note that the seed
          construction algorithm may be different for other types.</t>
        </section>

        <section title="Distributed Quota">
          <t>Being a peer in a DHT carries with it the responsibility to store
          data for a given region of the DHT. However, if clients were allowed
          to store unlimited amounts of data, this would create unacceptable
          burdens on peers, as well as enabling trivial denial of service
          attacks. RELOAD addresses this issue by requiring each usage to
          define maximum sizes for each type of stored data. Attempts to store
          values exceeding this size SHOULD be rejected. Because each slot is
          bound to a small set of certificates, these size restrictions also
          create a distributed quota mechanism, with the quotas administered
          by the central enrollment server.</t>

          <t>Allowing different types of data to have different size
          restrictions allows new usages the flexibility to define limits that
          fit their needs without requiring all usages to have expansive
          limits. Because peers know at joining time what usages they must
          support (see <xref target="sec-configuration"></xref>), peers can to
          some extent predict their storage requirements.</t>
        </section>

        <section title="Correctness">
          <t>Because each stored value is signed, it is trivial for any
          retrieving peer to verify the integrity of the stored value. Some
          more care needs to be taken to prevent version rollback attacks.
          Rollback attacks on storage are prevented by the use of store times
          and lifetime values in each store. A lifetime represents the latest
          time at which the data is valid and thus limits (though does not
          completely prevent) the ability of the storing node to perform a
          rollback attack on retrievers. In order to prevent a rollback attack
          at the time of the STORE request, we require that storage times be
          monotonically increasing. Storing peers MUST reject STORE requests
          with storage times smaller than or equal to those they are currently
          storing. In addition, a fetching node which receives a data value
          with a storage time older than the result of the previous fetch
          knows a rollback has occurred.</t>
        </section>

        <section title="Residual Attacks">
          <t>The mechanisms described here provide a high degree of security,
          but some attacks remain possible. Most simply, it is possible for
          storing nodes to refuse to store a value (reject any request). In
          addition, a storing node can deny knowledge of values which it
          previously accepted. To some extent these attacks can be ameliorated
          by attempting to store to/retrieve from replicas, but a retrieving
          client has trouble knowing whether it should try this or not (since
          there is a cost to doing so.)</t>

          <t>Although the certificate-based authentication scheme compromising
          a single peer from being able to forge data owned by other peers.
          Furthermore, although a subversive peer can refuse to return data
          resources for which it is responsible it cannot return forged data
          because it cannot provide authentication for such registrations.
          Therefore parallel searches for redundant registrations can mitigate
          most of the affects of a compromised peer. The ultimate reliability
          of such an overlay is a statistical question based on the
          replication factor and the percentage of compromised peers.</t>

          <t>In addition, when a type is multivalued (e.g., an array), the
          storing node can return only some subset of the values, thus biasing
          its responses. This can be countered by using single values rather
          than sets, but that makes coordination between multiple storing
          agents much more difficult. This is a tradeoff that must be made
          when designing any usage.</t>
        </section>
      </section>

      <section title="Routing Security">
        <t>Because the storage security system guarantees (within limits) the
        integrity of the stored data, routing security focuses on stopping the
        attacker from performing a DOS attack on the system by mis-routing
        requests in the DHT. There are a few obvious observations to make
        about this. First, it is easy to ensure that an attacker is at least a
        valid peer in the DHT. Second, this is a DOS attack only. Third, if a
        large percentage of the peers on the DHT are controlled by the
        attacker, it is probably impossible to perfectly secure against
        this.</t>

        <section title="Background">
          <t>In general, attacks on DHT routing are mounted by the attacker
          arranging to route traffic through or two nodes it controls. In the
          Eclipse attack <xref target="Eclipse"></xref> the attacker tampers
          with messages to and from nodes for which it is on-path with respect
          to a given victim node. This allows it to pretend to be all the
          nodes that are reachable through it. In the Sybil attack <xref
          target="Sybil"></xref>, the attacker registers a large number of
          nodes and is therefore able to capture a large amount of the traffic
          through the DHT.</t>

          <t>Both the Eclipse and Sybil attacks require the attacker to be
          able to exercise control over her peer IDs. The Sybil attack
          requires the creation of a large number of peers. The Eclipse attack
          requires that the attacker be able to impersonate specific peers. In
          both cases, these attacks are limited by the use of centralized,
          certificate-based admission control.</t>
        </section>

        <section title="Admissions Control">
          <t>Admission to an RELOAD DHT is controlled by requiring that each
          peer have a certificate containing its peer ID. The requirement to
          have a certificate is enforced by using TLS mutual authentication on
          each connection. Thus, whenever a peer connects to another peer,
          each side automatically checks that the other has a suitable
          certificate. These peer IDs are randomly assigned by the central
          enrollment server. This has two benefits:</t>

          <t><list style="symbols">
              <t>It allows the enrollment server to limit the number of peer
              IDs issued to any individual user.</t>

              <t>It prevents the attacker from choosing specific peer IDs.</t>
            </list></t>

          <t>The first property allows protection against Sybil attacks
          (provided the enrollment server uses strict rate limiting policies).
          The second property deters but does not completely prevent Eclipse
          attacks. Because an Eclipse attacker must impersonate peers on the
          other side of the attacker, he must have a certificate for suitable
          peer IDs, which requires him to repeatedly query the enrollment
          server for new certificates which only will match by chance. From
          the attacker's perspective, the difficulty is that if he only has a
          small number of certificates the region of the DHT he is
          impersonating appears to be very sparsely populated by comparison to
          the victim's local region.</t>
        </section>

        <section title="Peer Identification and Authentication">
          <t>In general, whenever a peer engages in DHT activity that might
          affect the routing table it must establish its identity. This
          happens in two ways. First, whenever a peer establishes a direct
          connection to another peer it authenticates via TLS mutual
          authentication. All messages between peers are sent over this
          protected channel and therefore the peers can verify the data origin
          of the last hop peer for requests and responses without further
          cryptography.</t>

          <t>In some situations, however, it is desirable to be able to
          establish the identity of a peer with whom one is not directly
          connected. The most natural case is when a peer UPDATEs its state.
          At this point, other peers may need to update their view of the DHT
          structure, but they need to verify that the UPDATE message came from
          the actual peer rather than from an attacker. To prevent this, all
          DHT routing messages are signed by the peer that generated them.</t>

          <t>[TODO: this allows for replay attacks on requests. There are two
          basic defenses here. The first is global clocks and loose
          anti-replay. The second is to refuse to take any action unless you
          verify the data with the relevant node. This issue is
          undecided.]</t>

          <t>[TODO: I think we are probably going to end up with generic
          signatures or at least optional signatures on all DHT messages.]</t>
        </section>

        <section title="Protecting the Signaling">
          <t>The goal here is to stop an attacker from knowing who is
          signaling what to whom. An attacker being able to observe the
          activities of a specific individual is unlikely given the
          randomization of IDs and routing based on the present peers
          discussed above. Furthermore, because messages can be routed using
          only the header information, the actual body of the RELOAD message
          can be encrypted during transmission.</t>

          <t>There are two lines of defense here. The first is the use of TLS
          or DTLS for each communications link between peers. This provides
          protection against attackers who are not members of the overlay. The
          second line of defense, if certificate-based security is used, is to
          digitally sign each message. This prevents adversarial peers from
          modifying messages in flight, even if they are on the routing
          path.</t>
        </section>

        <section title="Residual Attacks">
          <t>The routing security mechanisms in RELOAD are designed to contain
          rather than eliminate attacks on routing. It is still possible for
          an attacker to mount a variety of attacks. In particular, if an
          attacker is able to take up a position on the DHT routing between A
          and B it can make it appear as if B does not exist or is
          disconnected. It can also advertise false network metrics in attempt
          to reroute traffic. However, these are primarily DoS attacks.</t>

          <t>The certificate-based security scheme secures the namespace, but
          if an individual peer is compromised or if an attacker obtains a
          certificate from the CA, then a number of subversive peers can still
          appear in the overlay. While these peers cannot falsify responses to
          resource queries, they can respond with 404 error messages,
          effecting a DoS attack on the resource registration. They can also
          subvert routing to other compromised peers. To defend against such
          attacks, a resource search must still consist of parallel searches
          for replicated registrations.</t>
        </section>
      </section>

      <section title="SIP-Specific Issues">
        <section title="Fork Explosion">
          <t>Because SIP includes a forking capability (the ability to
          retarget to multiple recipients), fork bombs are a potential DoS
          concern. However, in the SIP usage of RELOAD, fork bombs are a much
          lower concern because the calling party is involved in each
          retargeting event and can therefore directly measure the number of
          forks and throttle at some reasonable number.</t>
        </section>

        <section title="Malicious Retargeting">
          <t>Another potential DoS attack is for the owner of an attractive
          number to retarget all calls to some victim. This attack is
          difficult to ameliorate without requiring the target of a SIP
          registration to authorize all stores. The overhead of that
          requirement would be excessive and in addition there are good use
          cases for ratargeting to a peer without there explicit
          cooperation.</t>
        </section>

        <section title="Privacy Issues">
          <t>All RELOAD SIP registration data is public. Methods of providing
          location and identity privacy are still being studied.</t>
        </section>
      </section>
    </section>

    <!--
    <section title="Operations and Management Considerations"></section>

    <section title="IANA Considerations">
      <section title="DHT Types"></section>

      <section title="Stored Data Types"></section>

      <section title="Request &amp; Responses Types"></section>

      <section title="Parameter Types">
        <t></t>
      </section>

      <t>TODO - add IANA registration for p2p_enroll SRV</t>
    </section>
    -->

    <section title="Examples">
      <t>See draft [TODO add ref] for message flow examples.</t>
    </section>

    <section title="Acknowledgments">
      <t>This draft is a merge of the "REsource LOcation And Discovery
      (RELOAD)" draft by David A. Bryan, Marcia Zangrilli and Bruce B.
      Lowekamp, the "Address Settlement by Peer to Peer" draft by Cullen
      Jennings, Jonathan Rosenberg, and Eric Rescorla, the "Security
      Extensions for RELOAD" draft by Bruce B. Lowekamp and James Deverick,
      and the "A Chord-based DHT for Resource Lookup in P2PSIP" by Marcia
      Zangrilli and David A. Bryan.</t>
    </section>

    <section title="Appendix: Operation with SIP clients outside the DHT domain"></section>

    <section title="Appendix: Notes on DHT Algorithm Selection">
      <t>An important point: if you assume NATs are doing ICE to set up
      connections, you want a lot fewer connections than you might have on a
      very open network - this might push towards something like Chord with
      fewer connections than, say, bamboo.</t>

      <t>TODO - ref draft-irtf-p2prg-survey-search</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate
          Requirement Levels</title>

          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>

            <address>
              <postal>
                <street>1350 Mass. Ave.</street>

                <street>Cambridge</street>

                <street>MA 02138</street>
              </postal>

              <phone>- +1 617 495 3864</phone>

              <email>sob@harvard.edu</email>
            </address>
          </author>

          <date month="March" year="1997" />

          <area>General</area>

          <keyword>keyword</keyword>
        </front>

        <seriesInfo name="BCP" value="14" />

        <seriesInfo name="RFC" value="2119" />

        <format octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"
                type="TXT" />

        <format octets="15905"
                target="http://xml.resource.org/public/rfc/html/rfc2119.html"
                type="HTML" />

        <format octets="5661"
                target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"
                type="XML" />
      </reference>

      <reference anchor="I-D.ietf-mmusic-ice">
        <front>
          <title>Interactive Connectivity Establishment (ICE): A Protocol for
          Network Address Translator (NAT) Traversal for Offer/Answer
          Protocols</title>

          <author fullname="Jonathan Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <date day="12" month="June" year="2007" />

          <abstract>
            <t>This document describes a protocol for Network Address
            Translator (NAT) traversal for multimedia sessions established
            with the offer/ answer model. This protocol is called Interactive
            Connectivity Establishment (ICE). ICE makes use of the Session
            Traversal Utilities for NAT (STUN) protocol, applying its binding
            discovery and relay usages, in addition to defining a new usage
            for checking connectivity between peers. ICE can be used by any
            protocol utilizing the offer/answer model, such as the Session
            Initiation Protocol (SIP).</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-mmusic-ice-16" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-16.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-behave-rfc3489bis">
        <front>
          <title>Session Traversal Utilities for (NAT) (STUN)</title>

          <author fullname="Jonathan Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <date day="8" month="March" year="2007" />

          <abstract>
            <t>Session Traversal Utilities for NAT (STUN) is a lightweight
            protocol that serves as a tool for application protocols in
            dealing with NAT traversal. It allows a client to determine the IP
            address and port allocated to them by a NAT and to keep NAT
            bindings open. It can also serve as a check for connectivity
            between a client and a server in the presence of NAT, and for the
            client to detect failure of the server. STUN works with many
            existing NATs, and does not require any special behavior from
            them. As a result, it allows a wide variety of applications to
            work through existing NAT infrastructure.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-ietf-behave-rfc3489bis-06" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-behave-rfc3489bis-06.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-behave-turn">
        <front>
          <title>Obtaining Relay Addresses from Simple Traversal Underneath
          NAT (STUN)</title>

          <author fullname="Jonathan Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <date day="7" month="March" year="2007" />

          <abstract>
            <t>This specification defines a usage of the Simple Traversal
            Underneath NAT (STUN) Protocol for asking the STUN server to relay
            packets towards a client. This usage is useful for elements behind
            NATs whose mapping behavior is address and port dependent. The
            extension purposefully restricts the ways in which the relayed
            address can be used. In particular, it prevents users from running
            general purpose servers from ports obtained from the STUN
            server.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-behave-turn-03" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-behave-turn-03.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-pkix-cmc-trans">
        <front>
          <title>Certificate Management over CMS (CMC) Transport
          Protocols</title>

          <author fullname="Jim Schaad" initials="J" surname="Schaad">
            <organization></organization>
          </author>

          <author fullname="Michael Myers" initials="M" surname="Myers">
            <organization></organization>
          </author>

          <date day="16" month="May" year="2006" />

          <abstract>
            <t>This document defines a number of transport mechanisms that are
            used to move CMC (Certificate Management over CMS (Cryptographic
            Message Syntax)) messages. The transport mechanisms described in
            this document are: HTTP, file, mail and TCP.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-pkix-cmc-trans-05" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-pkix-cmc-trans-05.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-pkix-2797-bis">
        <front>
          <title>Certificate Management Messages over CMS</title>

          <author fullname="Michael Myers" initials="M" surname="Myers">
            <organization></organization>
          </author>

          <author fullname="Jim Schaad" initials="J" surname="Schaad">
            <organization></organization>
          </author>

          <date day="3" month="March" year="2006" />

          <abstract>
            <t>This document defines the base syntax for CMC, a Certificate
            Management protocol using CMS (Cryptographic Message Syntax). This
            protocol addresses two immediate needs within the Internet PKI
            community: 1. The need for an interface to public key
            certification products and services based on CMS and PKCS #10
            (Public Key Cryptography 2. The need in S/MIME (Secure MIME) for a
            certificate enrollment protocol for DSA-signed certificates with
            Diffie-Hellman public keys. CMC also requires the use of the
            transport document and the requirements usage document along with
            this document for a full definition.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-pkix-2797-bis-04" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-pkix-2797-bis-04.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4279">
        <front>
          <title>Pre-Shared Key Ciphersuites for Transport Layer Security
          (TLS)</title>

          <author fullname="P. Eronen" initials="P." surname="Eronen">
            <organization></organization>
          </author>

          <author fullname="H. Tschofenig" initials="H." surname="Tschofenig">
            <organization></organization>
          </author>

          <date month="December" year="2005" />

          <abstract>
            <t>This document specifies three sets of new ciphersuites for the
            Transport Layer Security (TLS) protocol to support authentication
            based on pre-shared keys (PSKs). These pre-shared keys are
            symmetric keys, shared in advance among the communicating parties.
            The first set of ciphersuites uses only symmetric key operations
            for authentication. The second set uses a Diffie-Hellman exchange
            authenticated with a pre-shared key, and the third set combines
            public key authentication of the server with pre-shared key
            authentication of the client. [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4279" />

        <format octets="32160" target="ftp://ftp.isi.edu/in-notes/rfc4279.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-tls-srp">
        <front>
          <title>Using SRP for TLS Authentication</title>

          <author fullname="Dave Taylor" initials="D" surname="Taylor">
            <organization></organization>
          </author>

          <date day="14" month="June" year="2007" />

          <abstract>
            <t>This memo presents a technique for using the Secure Remote
            Password protocol as an authentication method for the Transport
            Layer Security protocol.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-tls-srp-14" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-tls-srp-14.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.ietf-mmusic-ice-tcp">
        <front>
          <title>TCP Candidates with Interactive Connectivity Establishment
          (ICE</title>

          <author fullname="Jonathan  Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <date day="8" month="March" year="2007" />

          <abstract>
            <t>Interactive Connectivity Establishment (ICE) defines a
            mechanism for NAT traversal for multimedia communication protocols
            based on the offer/answer model of session negotiation. ICE works
            by providing a set of candidate transport addresses for each media
            stream, which are then validated with peer-to-peer connectivity
            checks based on Simple Traversal of UDP over NAT (STUN). ICE
            provides a general framework for describing alternates, but only
            defines UDP-based transport protocols. This specification extends
            ICE to TCP-based media, including the ability to offer a mix of
            TCP and UDP-based candidates for a single stream.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-mmusic-ice-tcp-03" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-tcp-03.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC3261">
        <front>
          <title>SIP: Session Initiation Protocol</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="H. Schulzrinne" initials="H."
                  surname="Schulzrinne">
            <organization></organization>
          </author>

          <author fullname="G. Camarillo" initials="G." surname="Camarillo">
            <organization></organization>
          </author>

          <author fullname="A. Johnston" initials="A." surname="Johnston">
            <organization></organization>
          </author>

          <author fullname="J. Peterson" initials="J." surname="Peterson">
            <organization></organization>
          </author>

          <author fullname="R. Sparks" initials="R." surname="Sparks">
            <organization></organization>
          </author>

          <author fullname="M. Handley" initials="M." surname="Handley">
            <organization></organization>
          </author>

          <author fullname="E. Schooler" initials="E." surname="Schooler">
            <organization></organization>
          </author>

          <date month="June" year="2002" />
        </front>

        <seriesInfo name="RFC" value="3261" />

        <format octets="647976"
                target="ftp://ftp.isi.edu/in-notes/rfc3261.txt" type="TXT" />
      </reference>

      <reference anchor="RFC3263">
        <front>
          <title>Session Initiation Protocol (SIP): Locating SIP
          Servers</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="H. Schulzrinne" initials="H."
                  surname="Schulzrinne">
            <organization></organization>
          </author>

          <date month="June" year="2002" />

          <abstract>
            <t>The Session Initiation Protocol (SIP) uses DNS procedures to
            allow a client to resolve a SIP Uniform Resource Identifier (URI)
            into the IP address, port, and transport protocol of the next hop
            to contact. It also uses DNS to allow a server to send a response
            to a backup client if the primary client has failed. This document
            describes those DNS procedures in detail. [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="3263" />

        <format octets="42310" target="ftp://ftp.isi.edu/in-notes/rfc3263.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4347">
        <front>
          <title>Datagram Transport Layer Security</title>

          <author fullname="E. Rescorla" initials="E." surname="Rescorla">
            <organization></organization>
          </author>

          <author fullname="N. Modadugu" initials="N." surname="Modadugu">
            <organization></organization>
          </author>

          <date month="April" year="2006" />

          <abstract>
            <t>This document specifies Version 1.0 of the Datagram Transport
            Layer Security (DTLS) protocol. The DTLS protocol provides
            communications privacy for datagram protocols. The protocol allows
            client/server applications to communicate in a way that is
            designed to prevent eavesdropping, tampering, or message forgery.
            The DTLS protocol is based on the Transport Layer Security (TLS)
            protocol and provides equivalent security guarantees. Datagram
            semantics of the underlying transport are preserved by the DTLS
            protocol. [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4347" />

        <format octets="56014" target="ftp://ftp.isi.edu/in-notes/rfc4347.txt"
                type="TXT" />
      </reference>
    </references>

    <references title="Informative References">
      <reference anchor="I-D.ietf-p2psip-concepts">
        <front>
          <title>Concepts and Terminology for Peer to Peer SIP</title>

          <author fullname="David Bryan" initials="D" surname="Bryan">
            <organization></organization>
          </author>

          <date day="3" month="July" year="2007" />

          <abstract>
            <t>This document defines concepts and terminology for use of the
            Session Initiation Protocol in a peer-to-peer environment where
            the traditional proxy-registrar and message routing functions are
            replaced by a distributed mechanism that might be implemented
            using a distributed hash table or other distributed data mechanism
            with similar external properties. This document includes a
            high-level view of the functional relationships between the
            network elements defined herein, a conceptual model of operations,
            and an outline of the related open problems being addressed by the
            P2PSIP working group. As this document matures, it is expected to
            define the general framework for P2PSIP.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-ietf-p2psip-concepts-00" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-p2psip-concepts-00.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4145">
        <front>
          <title>TCP-Based Media Transport in the Session Description Protocol
          (SDP)</title>

          <author fullname="D. Yon" initials="D." surname="Yon">
            <organization></organization>
          </author>

          <author fullname="G. Camarillo" initials="G." surname="Camarillo">
            <organization></organization>
          </author>

          <date month="September" year="2005" />

          <abstract>
            <t>This document describes how to express media transport over TCP
            using the Session Description Protocol (SDP). It defines the SDP
            'TCP' protocol identifier, the SDP 'setup' attribute, which
            describes the connection setup procedure, and the SDP 'connection'
            attribute, which handles connection reestablishment. [STANDARDS
            TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4145" />

        <format octets="30225" target="ftp://ftp.isi.edu/in-notes/rfc4145.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4572">
        <front>
          <title>Connection-Oriented Media Transport over the Transport Layer
          Security (TLS) Protocol in the Session Description Protocol
          (SDP)</title>

          <author fullname="J. Lennox" initials="J." surname="Lennox">
            <organization></organization>
          </author>

          <date month="July" year="2006" />

          <abstract>
            <t>This document specifies how to establish secure
            connection-oriented media transport sessions over the Transport
            Layer Security (TLS) protocol using the Session Description
            Protocol (SDP). It defines a new SDP protocol identifier,
            'TCP/TLS'. It also defines the syntax and semantics for an SDP
            'fingerprint' attribute that identifies the certificate that will
            be presented for the TLS session. This mechanism allows media
            transport over TLS connections to be established securely, so long
            as the integrity of session descriptions is
            assured.&lt;/t&gt;&lt;t&gt; This document extends and updates RFC
            4145. [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4572" />

        <format octets="38658" target="ftp://ftp.isi.edu/in-notes/rfc4572.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC2617">
        <front>
          <title abbrev="HTTP Authentication">HTTP Authentication: Basic and
          Digest Access Authentication</title>

          <author fullname="John Franks" initials="J." surname="Franks">
            <organization>Northwestern University, Department of
            Mathematics</organization>

            <address>
              <postal>
                <street>Northwestern University</street>

                <city>Evanston</city>

                <region>IL</region>

                <code>60208-2730</code>

                <country>USA</country>
              </postal>

              <email>john@math.nwu.edu</email>
            </address>
          </author>

          <author fullname="Phillip M. Hallam-Baker" initials="P.M."
                  surname="Hallam-Baker">
            <organization>Verisign Inc.</organization>

            <address>
              <postal>
                <street>301 Edgewater Place</street>

                <street>Suite 210</street>

                <city>Wakefield</city>

                <region>MA</region>

                <code>01880</code>

                <country>USA</country>
              </postal>

              <email>pbaker@verisign.com</email>
            </address>
          </author>

          <author fullname="Jeffery L. Hostetler" initials="J.L."
                  surname="Hostetler">
            <organization>AbiSource, Inc.</organization>

            <address>
              <postal>
                <street>6 Dunlap Court</street>

                <city>Savoy</city>

                <region>IL</region>

                <code>61874</code>

                <country>USA</country>
              </postal>

              <email>jeff@AbiSource.com</email>
            </address>
          </author>

          <author fullname="Scott D. Lawrence" initials="S.D."
                  surname="Lawrence">
            <organization>Agranat Systems, Inc.</organization>

            <address>
              <postal>
                <street>5 Clocktower Place</street>

                <street>Suite 400</street>

                <city>Maynard</city>

                <region>MA</region>

                <code>01754</code>

                <country>USA</country>
              </postal>

              <email>lawrence@agranat.com</email>
            </address>
          </author>

          <author fullname="Paul J. Leach" initials="P.J." surname="Leach">
            <organization>Microsoft Corporation</organization>

            <address>
              <postal>
                <street>1 Microsoft Way</street>

                <city>Redmond</city>

                <region>WA</region>

                <code>98052</code>

                <country>USA</country>
              </postal>

              <email>paulle@microsoft.com</email>
            </address>
          </author>

          <author fullname="Ari Luotonen" initials="A." surname="Luotonen">
            <organization>Netscape Communications Corporation</organization>

            <address>
              <postal>
                <street>501 East Middlefield Road</street>

                <city>Mountain View</city>

                <region>CA</region>

                <code>94043</code>

                <country>USA</country>
              </postal>
            </address>
          </author>

          <author fullname="Lawrence C. Stewart" initials="L."
                  surname="Stewart">
            <organization>Open Market, Inc.</organization>

            <address>
              <postal>
                <street>215 First Street</street>

                <city>Cambridge</city>

                <region>MA</region>

                <code>02142</code>

                <country>USA</country>
              </postal>

              <email>stewart@OpenMarket.com</email>
            </address>
          </author>

          <date month="June" year="1999" />

          <abstract>
            <t>"HTTP/1.0", includes the specification for a Basic Access
            Authentication scheme. This scheme is not considered to be a
            secure method of user authentication (unless used in conjunction
            with some external secure system such as SSL ), as the user name
            and password are passed over the network as cleartext.</t>

            <t>This document also provides the specification for HTTP's
            authentication framework, the original Basic authentication scheme
            and a scheme based on cryptographic hashes, referred to as "Digest
            Access Authentication". It is therefore also intended to serve as
            a replacement for RFC 2069 . Some optional elements specified by
            RFC 2069 have been removed from this specification due to problems
            found since its publication; other new elements have been added
            for compatibility, those new elements have been made optional, but
            are strongly recommended.</t>

            <t>Like Basic, Digest access authentication verifies that both
            parties to a communication know a shared secret (a password);
            unlike Basic, this verification can be done without sending the
            password in the clear, which is Basic's biggest weakness. As with
            most other authentication protocols, the greatest sources of risks
            are usually found not in the core protocol itself but in policies
            and procedures surrounding its use.</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="2617" />

        <format octets="77638" target="ftp://ftp.isi.edu/in-notes/rfc2617.txt"
                type="TXT" />

        <format octets="114842"
                target="http://xml.resource.org/public/rfc/html/rfc2617.html"
                type="HTML" />

        <format octets="87592"
                target="http://xml.resource.org/public/rfc/xml/rfc2617.xml"
                type="XML" />
      </reference>

      <reference anchor="RFC2818">
        <front>
          <title>HTTP Over TLS</title>

          <author fullname="E. Rescorla" initials="E." surname="Rescorla">
            <organization></organization>
          </author>

          <date month="May" year="2000" />

          <abstract>
            <t>This memo describes how to use Transport Layer Security (TLS)
            to secure Hypertext Transfer Protocol (HTTP) connections over the
            Internet. This memo provides information for the Internet
            community.</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="2818" />

        <format octets="15170" target="ftp://ftp.isi.edu/in-notes/rfc2818.txt"
                type="TXT" />
      </reference>

      <reference anchor="RFC4086">
        <front>
          <title>Randomness Requirements for Security</title>

          <author fullname="D. Eastlake" initials="D." surname="Eastlake">
            <organization></organization>
          </author>

          <author fullname="J. Schiller" initials="J." surname="Schiller">
            <organization></organization>
          </author>

          <author fullname="S. Crocker" initials="S." surname="Crocker">
            <organization></organization>
          </author>

          <date month="June" year="2005" />

          <abstract>
            <t>Security systems are built on strong cryptographic algorithms
            that foil pattern analysis attempts. However, the security of
            these systems is dependent on generating secret quantities for
            passwords, cryptographic keys, and similar quantities. The use of
            pseudo-random processes to generate secret quantities can result
            in pseudo-security. A sophisticated attacker may find it easier to
            reproduce the environment that produced the secret quantities and
            to search the resulting small set of possibilities than to locate
            the quantities in the whole of the potential number
            space.&lt;/t&gt;&lt;t&gt; Choosing random quantities to foil a
            resourceful and motivated adversary is surprisingly difficult.
            This document points out many pitfalls in using poor entropy
            sources or traditional pseudo-random number generation techniques
            for generating such quantities. It recommends the use of truly
            random hardware techniques and shows that the existing hardware on
            many systems can be used for this purpose. It provides suggestions
            to ameliorate the problem when a hardware solution is not
            available, and it gives examples of how large such quantities need
            to be for some applications. This document specifies an Internet
            Best Current Practices for the Internet Community, and requests
            discussion and suggestions for improvements.</t>
          </abstract>
        </front>

        <seriesInfo name="BCP" value="106" />

        <seriesInfo name="RFC" value="4086" />

        <format octets="114321"
                target="ftp://ftp.isi.edu/in-notes/rfc4086.txt" type="TXT" />
      </reference>

      <reference anchor="RFC3280">
        <front>
          <title>Internet X.509 Public Key Infrastructure Certificate and
          Certificate Revocation List (CRL) Profile</title>

          <author fullname="R. Housley" initials="R." surname="Housley">
            <organization></organization>
          </author>

          <author fullname="W. Polk" initials="W." surname="Polk">
            <organization></organization>
          </author>

          <author fullname="W. Ford" initials="W." surname="Ford">
            <organization></organization>
          </author>

          <author fullname="D. Solo" initials="D." surname="Solo">
            <organization></organization>
          </author>

          <date month="April" year="2002" />

          <abstract>
            <t>This memo profiles the X.509 v3 certificate and X.509 v2
            Certificate Revocation List (CRL) for use in the Internet.
            [STANDARDS TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="3280" />

        <format octets="295556"
                target="ftp://ftp.isi.edu/in-notes/rfc3280.txt" type="TXT" />
      </reference>

      <!--
      <reference anchor="sosimple">
        <front>
          <title>SOSIMPLE: A Serverless, Standards-based, P2P SIP
          Communication System</title>

          <author fullname="David A. Bryan" initials="D. A." surname="Bryan">
            <organization>College of William and Mary</organization>
          </author>

          <author fullname="Cullen Jennings" initials="C." surname="Jennings">
            <organization>Cisco Systems</organization>
          </author>

          <author fullname="Bruce B. Lowekamp" initials="B. B."
                  surname="Lowekamp">
            <organization>College of William and Mary</organization>
          </author>

          <date month="June" year="2005" />
        </front>

        <seriesInfo name="Proceedings of the 2005 International Workshop on Advanced Architectures and Algorithms for Internet Delivery and Applications (AAA-IDEA)"
                    value="'05" />

        <format target="http://www.cs.wm.edu/~bryan/pubs/bryan-AAA-IDEA2005.pdf"
                type="PDF" />
      </reference>

      <reference anchor="I-D.bryan-p2psip-dsip">
        <front>
          <title>dSIP: A P2P Approach to SIP Registration and Resource
          Location</title>

          <author fullname="D. Bryan" initials="D." surname="Bryan">
            <organization></organization>
          </author>

          <author fullname="B. Lowekamp" initials="B." surname="Lowekamp">
            <organization></organization>
          </author>

          <author fullname="C. Jennings" initials="C." surname="Jennings">
            <organization></organization>
          </author>

          <date month="February" year="2007" />
        </front>

        <seriesInfo name="Internet Draft" value="draft-bryan-p2psip-dsip-00" />
      </reference>
-->

      <reference anchor="Sybil">
        <front>
          <title>The Sybil Attack</title>

          <author fullname="John R. Douceur" initials="J. R."
                  surname="Douceur">
            <organization>Microsoft Research</organization>
          </author>

          <date month="March" year="2002" />
        </front>

        <seriesInfo name="IPTPS" value="'02" />

        <format target="http://www.cs.rice.edu/Conferences/IPTPS02/101.pdf"
                type="PDF" />
      </reference>

      <reference anchor="Eclipse">
        <front>
          <title>"Eclipse Attacks on Overlay Networks: Threats and
          Defenses"</title>

          <author fullname="Atul Singh" initials="A." surname="Singh" />

          <author fullname="Tsuen-Wan Ngan" initials="T. W." surname="Ngan" />

          <author fullname="Peter Druschel" initials="T." surname="Druschel" />

          <author fullname="Dan S. Wallach" initials="D. S." surname="Wallach" />

          <seriesInfo name="INFOCOM" value="2006" />
        </front>
      </reference>

      <reference anchor="I-D.cheshire-dnsext-multicastdns">
        <front>
          <title>Multicast DNS</title>

          <author fullname="Stuart Cheshire" initials="S" surname="Cheshire">
            <organization></organization>
          </author>

          <author fullname="Marc Krochmal" initials="M" surname="Krochmal">
            <organization></organization>
          </author>

          <date day="25" month="August" year="2006" />

          <abstract>
            <t>As networked devices become smaller, more portable, and more
            ubiquitous, the ability to operate with less configured
            infrastructure is increasingly important. In particular, the
            ability to look up DNS resource record data types (including, but
            not limited to, host names) in the absence of a conventional
            managed DNS server, is becoming essential. Multicast DNS (mDNS)
            provides the ability to do DNS-like operations on the local link
            in the absence of any conventional unicast DNS server. In
            addition, mDNS designates a portion of the DNS namespace to be
            free for local use, without the need to pay any annual fee, and
            without the need to set up delegations or otherwise configure a
            conventional DNS server to answer for those names. The primary
            benefits of mDNS names are that (i) they require little or no
            administration or configuration to set them up, (ii) they work
            when no infrastructure is present, and (iii) they work during
            infrastructure failures.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-cheshire-dnsext-multicastdns-06" />

        <format target="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-multicastdns-06.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.cheshire-dnsext-dns-sd">
        <front>
          <title>DNS-Based Service Discovery</title>

          <author fullname="Marc Krochmal" initials="M" surname="Krochmal">
            <organization></organization>
          </author>

          <author fullname="Stuart Cheshire" initials="S" surname="Cheshire">
            <organization></organization>
          </author>

          <date day="28" month="August" year="2006" />

          <abstract>
            <t>This document describes a convention for naming and structuring
            DNS resource records. Given a type of service that a client is
            looking for, and a domain in which the client is looking for that
            service, this convention allows clients to discover a list of
            named instances of that desired service, using only standard DNS
            queries. In short, this is referred to as DNS-based Service
            Discovery, or DNS-SD.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-cheshire-dnsext-dns-sd-04" />

        <format target="http://www.ietf.org/internet-drafts/draft-cheshire-dnsext-dns-sd-04.txt"
                type="TXT" />
      </reference>

      <!--
<reference anchor='I-D.jennings-p2psip-security'>
<front>
<title>Security Mechanisms for Peer to Peer SIP</title>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<date month='February' day='27' year='2007' />

<abstract><t>This document describes an overview of some security mechanisms for P2P SIP. Specifically it discusses mechanisms that can be used to secure the stored data and the routing in the distributed storage. This draft is an very early draft to outline the possible solution space and far more details would be needed. This work is being discussed on the p2psip@ietf.org mailing list.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-jennings-p2psip-security-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-jennings-p2psip-security-00.txt' />
</reference>
-->

      <reference anchor="I-D.matthews-p2psip-bootstrap-mechanisms">
        <front>
          <title>Bootstrap Mechanisms for P2PSIP</title>

          <author fullname="Eric Cooper" initials="E" surname="Cooper">
            <organization></organization>
          </author>

          <date day="26" month="February" year="2007" />

          <abstract>
            <t>This document describes mechanisms that a peer can use to
            locate and establish a Peer Protocol connection to an admitting
            peer in order to join an overlay network. In the first mechanism,
            the joining peer uses multicast to locate a bootstrap peer; in the
            second, the node uses one or more bootstrap servers to locate a
            bootstrap peer; in both cases, the bootstrap peer then proxies the
            request by the joining peer on to the admitting peer. Each
            mechanism has its advantages and disadvantages, and a node can
            utilize both.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-matthews-p2psip-bootstrap-mechanisms-00" />

        <format target="http://www.ietf.org/internet-drafts/draft-matthews-p2psip-bootstrap-mechanisms-00.txt"
                type="TXT" />
      </reference>

      <reference anchor="I-D.garcia-p2psip-dns-sd-bootstrapping">
        <front>
          <title>P2PSIP bootstrapping using DNS-SD</title>

          <author fullname="Gustavo Garcia" initials="G" surname="Garcia">
            <organization></organization>
          </author>

          <date day="25" month="October" year="2007" />

          <abstract>
            <t>This document describes a DNS-based bootstrap mechanism to
            discover the initial peer or peers needed to join a P2PSIP
            Overlay. The document specifies the use of DNS Service Discovery
            (DNS-SD) and the format of the required resource records to
            support the discovery of P2PSIP peers. This mechanism can be
            applied in scenarios with DNS servers or combined with multicast
            DNS to fulfill different proposed P2PSIP use cases.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-garcia-p2psip-dns-sd-bootstrapping-00" />

        <format target="http://www.ietf.org/internet-drafts/draft-garcia-p2psip-dns-sd-bootstrapping-00.txt"
                type="TXT" />
      </reference>
    </references>
  </back>
</rfc>
