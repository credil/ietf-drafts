<?xml version="1.0" encoding="US-ASCII"?>
<!-- $Id: ct-kip-two-pass.xml,v 1.7 2006/10/14 18:52:48 mnystrom Exp $ -->
<!-- Copyright 2006 RSA Security Inc. All rights reserved. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="yes" ?>
<rfc category="std" docName="draft-ietf-keyprov-dskpp-01.txt" ipr="full3978">
  <front>
    <title abbrev="DSKPP">Dynamic Symmetric Key Provisioning Protocol
    (DSKPP)</title>

    <author fullname="Andrea Doherty" initials="A." surname="Doherty">
      <organization>RSA, The Security Division of EMC</organization>

      <address>
        <postal>
          <street>174 Middlesex Tpk.</street>

          <city>Bedford</city>

          <region>MA</region>

          <code>01730</code>

          <country>USA</country>
        </postal>

        <email>adoherty@rsa.com</email>
      </address>
    </author>

    <author fullname="Mingliang Pei" initials="M." surname="Pei">
      <organization>Verisign, Inc.</organization>

      <address>
        <postal>
          <street>487 E. Middlefield Road</street>

          <city>Mountain View</city>

          <region>CA</region>

          <code>94043</code>

          <country>USA</country>
        </postal>

        <email>mpei@verisign.com</email>
      </address>
    </author>

    <author fullname="Salah Machani" initials="S." surname="Machani">
      <organization>Diversinet Corp.</organization>

      <address>
        <postal>
          <street>2225 Sheppard Avenue East, Suite 1801</street>

          <city>Toronto</city>

          <region>Ontario</region>

          <code>M2J 5C2</code>

          <country>Canada</country>
        </postal>

        <email>smachani@diversinet.com</email>
      </address>
    </author>

    <author fullname="Magnus Nystrom" initials="M." surname="Nystrom">
      <organization>RSA, The Security Division of EMC</organization>

      <address>
        <postal>
          <street>Arenavagen 29</street>

          <city>Stockholm</city>

          <region>Stockholm Ln</region>

          <code>121 29</code>

          <country>SE</country>
        </postal>

        <email>mnystrom@rsa.com</email>
      </address>
    </author>

    <date day="29" month="October" year="2007" />

    <area>Security Area</area>

    <workgroup>KEYPROV Working Group</workgroup>

    <abstract>
      <t>DSKPP is a client-server protocol for initialization (and
      configuration) of symmetric keys to locally and remotely accessible
      cryptographic modules. The protocol can be run with or without
      private-key capabilities in the cryptographic modules, and with or
      without an established public-key infrastructure.</t>

      <t>Three variations of the protocol support multiple usage scenarios.
      The four-pass (i.e., two round-trip) variant enables key generation in
      near real-time. With the four-pass variant, keys are mutually generated
      by the provisioning server and cryptographic module; provisioned keys
      are not transferred over-the-wire or over-the-air. Two- and one-pass
      variants enable secure and efficient download and installation of
      symmetric keys to a cryptographic module in environments where near
      real-time communication may not be possible.</t>

      <t>This document builds on information contained in <xref
      target="RFC4758"></xref>, adding specific enhancements in response to
      implementation experience and liaison requests. It is intended,
      therefore, that this document or a successor version thereto will become
      the basis for subsequent progression of a symmetric key provisioning
      protocol specification on the standards track.</t>
    </abstract>
  </front>

  <middle>
    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-Introduction" title="Introduction">
      <section title="Scope">
        <t>This document describes a client-server protocol for initialization
        (and configuration) of symmetric keys to locally and remotely
        accessible cryptographic modules. The protocol can be run with or
        without private-key capabilities in the cryptographic modules, and
        with or without an established public-key infrastructure. The
        objectives of this protocol are to:</t>

        <t><list hangIndent="6" style="symbols">
            <t>Provide a secure method of initializing cryptographic modules
            with symmetric keys without exposing generated, secret material to
            any other entities than the server and the cryptographic module
            itself.</t>

            <t>Provide a secure method of generating and transporting
            symmetric keys to a cryptographic module in environments where
            near real-time communication is not possible.</t>

            <t>Provide a secure method of transporting pre-generated (i.e.,
            legacy) keys to a cryptographic module.</t>

            <t>Provide a solution that is easy to administer and scales
            well.</t>
          </list></t>

        <t>The mechanism is intended for general use within computer and
        communications systems employing symmetric key cryptographic modules
        that are locally (i.e., over-the-wire) or remotely (i.e.,
        over-the-air) accessible.</t>
      </section>

      <section title="Background">
        <t>A locally accessible symmetric key cryptographic module may be
        hosted by, for example, a hardware device connected to a personal
        computer through an electronic interface, such as USB, or a software
        application resident on a personal computer. A remotely accessible
        symmetric key cryptographic module may be hosted by, for example, any
        device that can support over-the-air communication, such as a
        hand-held hardware device (e.g., a mobile phone). The cryptographic
        module itself offers symmetric key cryptographic functionality that
        may be used to authenticate a user towards some service, perform data
        encryption, etc. Increasingly, these modules enable their programmatic
        initialization as well as programmatic retrieval of their output
        values. This document intends to meet the need for an open and
        inter-operable mechanism to programmatically initialize and configure
        symmetric keys to locally and remotely accessible cryptographic
        modules.</t>

        <t>The target mechanism makes use of a symmetric key provisioning
        server. In an ideal deployment scenario, near real-time communication
        is possible between the provisioning server and the cryptographic
        module. In such an environment, it is possible for the cryptographic
        module and provisioning server to mutually generate a symmetric key,
        and to ensure that keys are not transported between them.</t>

        <t>There are, however, several deployment scenarios that make mutual
        key generation less suitable. Specifically, scenarios where near
        real-time communication between the symmetric key provisioning server
        and the cryptographic module is not possible, and scenarios with
        significant design constraints. Examples include work-flow constraints
        (e.g., policies that require incremental administrative approval),
        network design constraints that create network latency, and budget
        constraints that sustain reliance upon legacy systems that already
        have supplies of pre-generated keys. In these situations, the
        cryptographic module is required to download and install a symmetric
        key from the provisioning server in a secure and efficient manner.</t>

        <t>This document tries to meet the needs of these scenarios by
        describing three variations to DSKPP for the provisioning of symmetric
        keys in two round trips or less. The four-pass (i.e., two round-trip)
        variant enables key generation in near real-time. With this variant,
        keys are mutually generated by the provisioning server and
        cryptographic module; provisioned keys are not transferred
        over-the-wire or over-the-air. In contrast, two- and one-pass variants
        enable secure and efficient download and installation of symmetric
        keys to a cryptographic module in environments where near real-time
        communication is not possible.</t>
      </section>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="terms" title="Requirements Notation and Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.<vspace blankLines="1" /></t>

      <t>The following notations are used in this document:</t>

      <t><list hangIndent="16" style="hanging">
          <t hangText="||">String concatenation<vspace blankLines="1" /></t>

          <t hangText="[x]">Optional element x<vspace blankLines="1" /></t>

          <t hangText="A ^ B">Exclusive-OR operation on strings A and B (where
          A and B are of equal length)<vspace blankLines="1" /></t>

          <t hangText="ENC_X(Y)">Encryption of message Y with symmetric key X,
          using a defined block cipher<vspace blankLines="1" /></t>

          <t hangText="ENC_PX(Y)">Encryption using message Y with a public key
          X<vspace blankLines="1" /></t>

          <t hangText="KDF_X(Y)">Key derivation function that generates an
          arbitrary number of octets of output using secret X and seed
          Y<vspace blankLines="1" /></t>

          <t hangText="DSKPP-PRF_X(Y,Z)">Pseudo random function that generates
          a fixed number Z of octets using secret X and seed Y (used in DSKPP
          methods for MAC computations and key derivation)<vspace
          blankLines="1" /></t>

          <t hangText="MAC_X(Y)">Keyed message authentication code computed
          over Y with symmetric key X<vspace blankLines="1" /></t>

          <t hangText="SIGN_x(Y)">Function that provides authentication and
          integrity protection of message content Y using private key x<vspace
          blankLines="1" /></t>

          <t hangText="B64(X)">Base 64 encoding of string X <vspace
          blankLines="1" /></t>

          <t hangText="H(X)">Hash function applied to X<vspace
          blankLines="1" /></t>

          <t hangText="Alg_List">List of encryption and MAC algorithms
          supported by the client<vspace blankLines="1" /></t>

          <t hangText="Alg_Sel">Algorithms list selected by the server for the
          DSKPP protocol run<vspace blankLines="1" /></t>

          <t hangText="DSKPP client">Manages communication between the
          symmetric key cryptographic module and the DSKPP server<vspace
          blankLines="1" /></t>

          <t hangText="DSKPP server">The symmetric key provisioning server
          that participates in the DSKPP protocol run<vspace
          blankLines="1" /></t>

          <t hangText="Issuer">The organization that issues or authorizes
          issuance of the symmetric key to the end user of the symmetric key
          cryptographic module (e.g., a bank who issues one-time password
          authentication tokens to their retail banking users)</t>

          <t hangText="ID_C">Identifier for DSKPP client<vspace
          blankLines="1" /></t>

          <t hangText="ID_S">Identifier for DSKPP server<vspace
          blankLines="1" /></t>

          <t hangText="AUTHCODE">Client Authentication Code comprised of a
          string of numeric characters known to the device and the server and
          containing an identifier and a password (the AUTHCODE may be used to
          derive the AUTHDATA during the DSKPP protocol exchange)<vspace
          blankLines="1" /></t>

          <t hangText="AUTHDATA">Client Authentication Data that may be
          derived from the AUTHCODE or using the client private key,
          k_CLIENT<vspace blankLines="1" /></t>

          <t hangText="K">Key used to encrypt R_C (either K_SERVER or
          K_SHARED)<vspace blankLines="1" /></t>

          <t hangText="K_AUTHCODE">Secret key that is derived from AUTHCODE
          and used for client authentication purposes<vspace
          blankLines="1" /></t>

          <t hangText="k_CLIENT">Private key of the DSKPP client<vspace
          blankLines="1" /></t>

          <t hangText="K_CLIENT">Public key of the DSKPP client<vspace
          blankLines="1" /></t>

          <t hangText="K_DERIVED">Secret key derived from a passphrase that is
          known to both the DSKPP client or user and the DSKPP server<vspace
          blankLines="1" /></t>

          <t hangText="K_MAC">Secret key used for key confirmation and server
          authentication purposes, and generated in DSKPP<vspace
          blankLines="1" /></t>

          <t hangText="K_MAC'">A second secret key used for server
          authentication purposes in 2- and 1-pass DSKPP<vspace
          blankLines="1" /></t>

          <t hangText="K_SERVER">Public key of the DSKPP server<vspace
          blankLines="1" /></t>

          <t hangText="K_SHARED">Secret key shared between the DSKPP client
          and the DSKPP server<vspace blankLines="1" /></t>

          <t hangText="K_TOKEN">Secret key used for cryptographic module
          computations, and generated in DSKPP<vspace blankLines="1" /></t>

          <t hangText="K_CONFDATA">Key configuration data carried within the
          key container<vspace blankLines="1" /></t>

          <t hangText="R">Pseudorandom value chosen by the DSKPP client and
          used for MAC computations, which is mandatory for 2-pass DSKPP and
          optional for 4-pass<vspace blankLines="1" /></t>

          <t hangText="R_C">Pseudorandom value chosen by the DSKPP client and
          used as input to the generation of K_TOKEN<vspace
          blankLines="1" /></t>

          <t hangText="R_S">Pseudorandom value chosen by the DSKPP server and
          used as input to the generation of K_TOKEN<vspace
          blankLines="1" /></t>

          <t hangText="URL_S">Server address as a URL<vspace
          blankLines="1" /></t>

          <t hangText="I">Unsigned integer representing a counter value that
          is monotonically increasing and guaranteed not to be used again by
          the server towards the cryptographic module<vspace
          blankLines="1" /></t>

          <t hangText="I'">Similar to I except I' is always higher than
          I<vspace blankLines="1" /></t>
        </list></t>

      <t>The following typographical convention is used in the body of the
      text: &lt;XMLElement&gt;.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-UseCases" title="Use Cases">
      <t>This section describes typical use cases.</t>

      <section anchor="UC1" title="Single Key Request">
        <t>A cryptographic module hosted by a device, such as a mobile phone,
        makes a request for a symmetric key from a provisioning server.
        Depending upon how the system is deployed, the provisioning server may
        generate a new key on-the-fly or use a pre-generated key, e.g., one
        provided by a legacy back-end issuance server. The provisioning server
        assigns a unique key ID to the symmetric key and provisions it to the
        cryptographic module.</t>
      </section>

      <section title="Multiple Key Requests">
        <t>A cryptographic module makes multiple requests for symmetric keys
        from the same provisioning server. The symmetric keys may or may not
        be of the same type, i.e., the keys may be used with different
        symmetric key cryptographic algorithms, including one-time password
        authentication algorithms, and AES encryption algorithm.</t>
      </section>

      <section title="Session Time-Out Policy">
        <t>Once a cryptographic module initiates a symmetric key request, the
        provisioning server may require that any subsequent actions to
        complete the provisioning cycle occur within a certain time window.
        For example, an issuer may provide a time-limited authentication code
        to a user during registration, which the user will input into the
        cryptographic module to authenticate themselves with the provisioning
        server. If the user inputs a valid authentication code within the
        fixed time period established by the issuer, the server will allow a
        key to be provisioned to the cryptographic module hosted by the user's
        device.</t>
      </section>

      <section title="Outsourced Provisioning">
        <t>A symmetric key issuer outsources its key provisioning to a third
        party key provisioning server provider. The issuer is responsible for
        authenticating and granting rights to users to acquire keys while
        acting as a proxy to the cryptographic module to acquire symmetric
        keys from the provisioning server; the cryptographic module
        communicates with the issuer proxy server, which forwards provisioning
        requests to the provisioning server.</t>
      </section>

      <section title="Key Renewal">
        <t>A cryptographic module requests renewal of a symmetric key using
        the same key ID already associated with the key. Such a need may occur
        in the case when a user wants to upgrade her device that houses the
        cryptographic module or when a key has expired. When a user uses the
        same cryptographic module to, for example, perform strong
        authentication at multiple Web login sites, keeping the same key ID
        removes the need for the user to register a new key ID at each
        site.</t>
      </section>

      <section title="Pre-Loaded Key Replacement">
        <t>This use case represents a special case of symmetric key renewal in
        which a local administrator can authenticate the user procedurally
        before initiating the provisioning process. It also allows for an
        issuer to pre-load a key onto a cryptographic module with a
        restriction that the key is replaced with a new key prior to use of
        the cryptographic module. Another variation of this use case is the
        issuer who recycles devices. In this case, an issuer would provision a
        new symmetric key to a cryptographic module hosted on a device that
        was previously owned by another user.</t>

        <t>Note that this use case is essentially the same as the last use
        case wherein the same key ID is used for renewal.</t>
      </section>

      <section title="Pre-Shared Transport Key">
        <t>A cryptographic module is loaded onto a smart card after the card
        is issued to a user. The symmetric key for the cryptographic module
        will then be provisioned using a secure channel mechanism present in
        many smart card platforms. This allows a direct secure channel to be
        established between the smart card chip and the provisioning server.
        For example, the card commands (i.e., Application Protocol Data Units,
        or APDUs) are encrypted with a pre-shared transport key and sent
        directly to the smart card chip, allowing secure post-issuance
        in-the-field provisioning. This secure flow can pass Transport Layer
        Security (TLS) and other transport security boundaries.</t>

        <t>Note that two pre-conditions for this use case are for the protocol
        to be tunneled and the provisioning server to know the correct
        pre-established transport key.</t>
      </section>

      <section title="SMS-Based Key Transport">
        <t>A mobile device supports Short Message Service (SMS) but is not
        able to support a data service allowing for HTTP or HTTPS transports.
        In addition, an application may use a cryptographic module to enforce
        an acceptable level of protection for download of the symmetric key
        via SMS. In such a case, the cryptographic module hosted by the mobile
        device may initiate a symmetric key request from a desktop computer
        and ask the server to send the key to the mobile device through SMS.
        User authentication is carried out via the online communication
        established between the desktop computer and the provisioning
        server.</t>
      </section>

      <section title="Non-Protected Transport Layer">
        <t>Some devices are not able to support a secure transport channel
        such as SSL or TLS to provide data confidentiality. A cryptographic
        module hosted by such a device requests a symmetric key from the
        provisioning server. It is up to DSKPP to ensure data confidentiality
        over non-secure networks.</t>
      </section>

      <section title="Non-Authenticated Transport Layer">
        <t>Some devices are not able to use a transport protocol that provides
        server authentication such as SSL or TLS. A cryptographic module
        hosted by such a device wants to be sure that it sends a request for a
        symmetric key to a legitimate provisioning server. It is up to DSKPP
        to provide proper client and server authentication.</t>
      </section>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-Protocol" title="DSKPP Overview">
      <section title="Entities">
        <t>In principle, the protocol involves a DSKPP client and a DSKPP
        server. The DSKPP client manages communication between the
        cryptographic module and the provisioning server. The DSKPP server
        herein represents the provisioning server.</t>

        <t>A high-level object model that describes the client-side entities
        and how they relate to each other is shown in <xref
        target="Objects"></xref>.</t>

        <figure anchor="Objects" title="Object Model">
          <artwork><![CDATA[-----------          -------------
| User    |          | Device    | 
|---------|*  owns  *|-----------|
| UserID  |--------->| DeviceID  |
| ...     |          | ...       |
-----------          -------------
                         | 1
                         |
                         | contains
                         | 
                         | *
                         V  
                   -----------------------
                   |Cryptographic Module |
                   |---------------------|
                   |CryptoModuleID
                   |Encryption Algorithms|
                   |MAC Algorithms       |
                   |...                  |
                   -----------------------
                         | 1
                         |
                         | contains
                         |
                         | *
                         V  
                   -----------------------
                   |Key Container        |
                   |---------------------|
                   |KeyID                |
                   |Key Type             |
                   |...                  |
                   -----------------------  
 ]]></artwork>
        </figure>

        <t>Conceptually, each entity represents the following:</t>

        <t><list hangIndent="24" style="hanging">
            <t hangText="User:">The person or client to whom devices are
            issued<vspace blankLines="1" /></t>

            <t hangText="UserID:">A unique identifier for the user or
            client<vspace blankLines="1" /></t>

            <t hangText="Device:">A physical piece of hardware or software
            framework that hosts symmetric key cryptographic modules<vspace
            blankLines="1" /></t>

            <t hangText="DeviceID:">A unique identifier for the device<vspace
            blankLines="1" /></t>

            <t hangText="Cryptographic Module:">A component of an application,
            which enables symmetric key cryptographic functionality<vspace
            blankLines="1" /></t>

            <t hangText="CryptoModuleID:">A unique identifier for an instance
            of the cryptographic module<vspace blankLines="1" /></t>

            <t hangText="Encryption Algorithms:">Encryption algorithms
            supported by the cryptographic module<vspace blankLines="1" /></t>

            <t hangText="MAC Algorithms:">MAC algorithms supported by the
            cryptographic module<vspace blankLines="1" /></t>

            <t hangText="Key Container:">An object that encapsulates a
            symmetric key and its configuration data<vspace
            blankLines="1" /></t>

            <t hangText="KeyID:">A unique identifier for the symmetric
            key<vspace blankLines="1" /></t>

            <t hangText="Key Type:">The type of symmetric key cryptographic
            methods for which the key will be used (e.g., OATH HOTP or RSA
            SecurID authentication, AES encryption, etc.)<vspace
            blankLines="1" /></t>
          </list>It is assumed that a device will host an application layered
        above the cryptographic module, and this application will manage
        communication between the DSKPP client and cryptographic module. The
        manner in which the communicating application will transfer DSKPP
        protocol elements to and from the cryptographic module is transparent
        to the DSKPP server. One method for this transfer is described in
        <xref target="CT-KIP-P11"></xref>.</t>
      </section>

      <section title="Overview of Protocol Usage">
        <t>DSKPP enables symmetric key provisioning between a DSKPP server and
        DSKPP client. The DSKPP protocol supports the following types of
        requests and responses:</t>

        <t><list>
            <t>&lt;KeyProvClientHello&gt;<vspace blankLines="1" /><list
                hangIndent="4">
                <t>With this request, a DSKPP client initiates contact with
                the DSKPP server, indicating what protocol versions and
                variants, key types, encryption and MAC algorithms that it
                supports. In addition, the request may include client
                authentication data that the DSKPP server uses to verify
                proof-of-possession of the device. <vspace
                blankLines="1" /></t>
              </list>&lt;KeyProvServerHello&gt;<vspace blankLines="1" /><list
                hangIndent="4">
                <t>Upon reception of a &lt;KeyProvClientHello&gt; request, the
                DSKPP server uses the &lt;KeyProvServerHello&gt; response to
                specify which protocol version and variant, key type,
                encryption algorithm, and MAC algorithm that will be used by
                the DSKPP server and DSKPP client during the protocol run. The
                decision of which variant, key type, and cryptographic
                algorithms to pick is policy- and implementation-dependent and
                therefore outside the scope of this document.</t>

                <t>The &lt;KeyProvServerHello&gt; response includes the DSKPP
                server's random nonce, R_S. The response also consists of
                information about either a shared secret key, or its own
                public key, that the DSKPP client uses when sending its
                protected random nonce, R_C, in the &lt;KeyProvClientNonce&gt;
                request (see below).</t>

                <t>Optionally, the DSKPP server may provide a MAC that the
                DSKPP client may use for server authentication.</t>

                <t><vspace blankLines="1" /></t>
              </list></t>

            <t>&lt;KeyProvClientNonce&gt;<vspace blankLines="1" /><list
                hangIndent="4">
                <t>With this request, a DSKPP client and DSKPP server securely
                exchange protected data, e.g., the protected random nonce R_C.
                In addition, the request may include client authentication
                data that the DSKPP server uses to verify proof-of-possession
                of the device. <vspace blankLines="1" /></t>
              </list>&lt;KeyProvServerFinished&gt;<vspace
            blankLines="1" /><list hangIndent="4">
                <t>The &lt;KeyProvServerFinished&gt; response is a
                confirmation message that includes a key container that holds
                configuration data, and may also contain protected key
                material (this depends on the protocol variant, as discussed
                below).</t>

                <t>Optionally, the DSKPP server may provide a MAC that the
                DSKPP client may use for server authentication.</t>
              </list></t>
          </list></t>

        <t>To initiate a DSKPP session:<list hangIndent="4" style="format %d.">
            <t>A user may use a browser to connect to a web server that is
            running on some host. The user may then identify (and optionally
            authenticate) herself (through some means that essentially are out
            of scope for this document) and request a symmetric key.</t>

            <t>A client application may request a symmetric key by invoking
            the DSKPP client.</t>

            <t>A DSKPP server may send a trigger message to a client
            application, which would then invoke the DSKPP client.</t>
          </list></t>

        <t>To contact the DSKPP server:<list hangIndent="4" style="format %d.">
            <t>A user may indicate how the DSKPP client is to contact a
            certain DSKPP server during a browsing session.</t>

            <t>A DSKPP client may be pre-configured to contact a certain DSKPP
            server.</t>

            <t>A user may be informed out-of-band about the location of the
            DSKPP server.<vspace blankLines="1" /></t>
          </list>Once the location of the DSKPP server is known, the DSKPP
        client and the DSKPP server engage in a 4-pass, 2-pass, or 1-pass
        protocol. Depending upon the policy and implementation, a DSKPP server
        selects which variant of the protocol to use: 4-pass, 2-pass, or
        1-pass. With the four-pass variant, keys are mutually generated by the
        DSKPP server and DSKPP client; provisioned keys are not transferred
        over-the-wire or over-the-air. Two- and one-pass variants enable
        secure and efficient download and installation of symmetric keys to a
        DSKPP client in environments where near real-time communication may
        not be possible.<xref target="Figure-Overview"> </xref> shows which
        messages get exchanged during each type of protocol run (4-pass,
        2-pass, or 1-pass).</t>

        <figure anchor="Figure-Overview"
                title="The DSKPP protocol (with OPTIONAL preceding trigger)">
          <artwork><![CDATA[+---------------+                            +---------------+
|               |                            |               |
|  DSKPP client |                            |  DSKPP server |
|               |                            |               |
+---------------+                            +---------------+
        |                                            |
        |        [ <---- DSKPP trigger ----- ]       |
        |                                            |
        |        ------- Client Hello ------->       |
        |        (Applicable to 4- and 2-pass)       |
        |                                            |
        |        <------ Server Hello --------       |
        |         (Applicable to 4-pass only)        |
        |                                            |
        |        ------- Client Nonce ------->       |
        |         (Applicable to 4-pass only)        |
        |                                            |
        |        <----- Server Finished ------       |
        |      (Applicable to 4-, 2-, and 1-pass)    |
        |                                            |
              ]]></artwork>
        </figure>

        <t>The table below identifies which protocol variants may be applied
        to the use cases from <xref target="Section-UseCases"></xref>:</t>

        <t><figure anchor="map"
            title="Mapping of protocol variants to use cases">
            <artwork><![CDATA[----------------------------------------------------------
Protocol   Applicable                Applicable
Variant    Use Cases                 Deployment Scenarios
----------------------------------------------------------
4-pass     All but 3.6 and           Near real-time 
           3.8 if mutual key         communication is
           generation is desired;    possible
           none if transport of 
           a pre-generated key 
 
2-pass     All                       Either near real-time
                                     or non real-time
                                     communication may be
                                     possible 
 
1-pass     All but 3.8               Either near real-time
                                     or non real-time
                                     communication may be
                                     possible]]></artwork>
          </figure></t>
      </section>

      <section anchor="Subsection-FourPassUsage"
               title="Four-Pass Protocol Usage">
        <t>The 4-pass protocol flow is suitable for environments wherein there
        is near real-time communication possible between the DSKPP client and
        DSKPP server. It is not suitable for environments wherein
        administrative approval is a required step in the flow, nor for
        provisioning of pre-generated keys.</t>

        <t>The full four-pass protocol exchange is as follows:<vspace
        blankLines="1" />[&lt;Trigger&gt;]:<vspace blankLines="1" /><list>
            <t hangText="6">[ID_Device], [ID_K], [URL_S], [R_S]<vspace
            blankLines="1" /></t>
          </list>&lt;KeyProvClientHello&gt;:<vspace blankLines="1" /><list>
            <t>[ID_Device], [ID_K], [R_S], Alg_List<vspace
            blankLines="1" /></t>
          </list>&lt;KeyProvServerHello&gt;:<vspace blankLines="1" /><list>
            <t>R_S, Alg_Sel, [K_SERVER], [DSKPP-PRF_K_MAC'("MAC 1 Computation"
            || [R] || R_S, len(R_S))<vspace blankLines="1" /></t>
          </list>&lt;KeyProvClientNonce&gt;:<vspace blankLines="1" /><list>
            <t>AUTHDATA, ENC_PK_SERVER(R_C) OR AUTHDATA,
            ENC_K_SHARED(R_C)<vspace blankLines="1" /></t>
          </list>&lt;KeyProvServerFinished&gt;:<vspace blankLines="1" /><list>
            <t>K_CONFDATA, DSKPP-PRF_K_MAC("MAC 2 Computation"||R_C,
            len(R_C))<vspace blankLines="1" /></t>
          </list>The following subsections describe the exchange in more
        detail.</t>

        <section title="Message Flow">
          <t>The 4-pass protocol flow consists of two round trips between the
          DSKPP client and DSKPP server (see <xref
          target="Figure-Overview"></xref>), where each round-trip involves
          two "passes", i.e., one request message and one response
          message:</t>

          <t><list hangIndent="8" style="format Round-trip #%d:">
              <t>Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 =
              &lt;KeyProvServerHello&gt;<vspace blankLines="1" /></t>

              <t>Pass 3 = &lt;KeyProvClientNonce&gt;, Pass 4 =
              &lt;KeyProvServerFinished&gt;</t>
            </list></t>

          <section title="Round-trip #1: &lt;KeyProvClientHello&gt; and &lt;KeyProvServerHello&gt;">
            <t>The DSKPP client sends a &lt;KeyProvClientHello&gt; message to
            the DSKPP server. The message provides information to the DSKPP
            server about the DSKPP versions, protocol variants, key types,
            encryption and MAC algorithms supported by the cryptographic
            module for the purposes of this protocol.</t>

            <t>The DSKPP server responds to the DSKPP client with a
            &lt;KeyProvServerHello&gt; message, whose content includes a
            random nonce, R_S, along with information about the type of key to
            generate, and the encryption algorithm chosen to protect sensitive
            data sent in the protocol. The length of the nonce R_S may depend
            on the selected key type. The &lt;KeyProvServerHello&gt; message
            also provides information about either a shared secret key to use
            for encrypting the cryptographic module's random nonce (see
            description of &lt;KeyProvClientNonce&gt; below), or its own
            public key. Optionally, &lt;KeyProvServerHello&gt; may include a
            MAC that the DSKPP client may use for server authentication during
            key replacement.</t>
          </section>

          <section title="Round-trip #2: &lt;KeyProvClientNonce&gt; and &lt;KeyProvServerFinished&gt;">
            <t>Based on information contained in the
            &lt;KeyProvServerHello&gt; message, the cryptographic module
            generates a random nonce, R_C. The length of the nonce R_C may
            depend on the selected key type. The cryptographic module encrypts
            R_C using the selected encryption algorithm and with a key, K,
            that is either the DSKPP server's public key, K_SERVER, or a
            shared secret key, K_SHARED, as indicated by the DSKPP server. If
            K is equivalent to K_SERVER, then the cryptographic module SHOULD
            verify the server's certificate before using it to encrypt R_C in
            accordance with <xref target="RFC3280"></xref>. The DSKPP client
            then sends the encrypted random nonce to the DSKPP server in a
            &lt;KeyProvClientNonce&gt; message, and may include client
            authentication data, such as a certificate or MAC derived from an
            authentication code and R_C. Finally, the cryptographic module
            calculates a symmetric key, K_TOKEN, of the selected type from the
            combination of the two random nonces R_S and R_C, the encryption
            key K, and possibly some other data, using the DSKPP-PRF function
            defined in <xref target="DSKPP-PRF"></xref>.</t>

            <t>The DSKPP server decrypts R_C, calculates K_TOKEN from the
            combination of the two random nonces R_S and R_C, the encryption
            key K, and possibly some other data, using the DSKPP-PRF function
            defined in <xref target="DSKPP-PRF"></xref>. The server then
            associates K_TOKEN with the cryptographic module in a server-side
            data store. The intent is that the data store later on will be
            used by some service that needs to verify or decrypt data produced
            by the cryptographic module and the key.</t>

            <t>Once the association has been made, the DSKPP server sends a
            confirmation message to the DSKPP client called
            &lt;KeyProvServerFinished&gt;. Optionally,
            &lt;KeyProvServerFinished&gt; may include a MAC that the DSKPP
            client may use for server authentication. The confirmation message
            includes a key container that holds an identifier for the
            generated key (but not the key itself) and additional
            configuration information, e.g., the identity of the DSKPP server.
            The default symmetric key container format that is used in the
            &lt;KeyProvServerFinished&gt; message is based on the Portable
            Symmetric Key Container (PSKC) defined in <xref
            target="PSKC"></xref>. Alternative formats MAY include PKCS#12
            <xref target="PKCS-12"></xref> or PKCS#5 XML <xref
            target="PKCS-5-XML"></xref> format.</t>

            <t>Upon receipt of the DSKPP server's confirmation message, the
            cryptographic module associates the provided key container with
            the generated key K_TOKEN, and stores any provided configuration
            data.<vspace blankLines="1" /></t>
          </section>
        </section>

        <section title="Generation of Symmetric Keys for Cryptographic Modules">
          <t>With 4-pass DSKPP, the symmetric key that is the target of
          provisioning, is generated on-the-fly without being transferred
          between the DSKPP client and DSKPP server. A sample data flow
          depicting how this works followed by computational information are
          provided in the subsections below.</t>

          <section title="Data Flow">
            <t>A sample data flow showing key generation during the 4-pass
            protocol is shown in <xref target="keygen"></xref>.</t>

            <figure anchor="keygen"
                    title="Principal data flow for DSKPP key generation             - using public server key">
              <artwork><![CDATA[+----------------------+    +-------+     +----------------------+
|    +------------+    |    |       |     |                      |
|    | Server key |    |    |       |     |                      |
| +<-|  Public    |------>------------->-------------+---------+ |
| |  |  Private   |    |    |       |     |          |         | |
| |  +------------+    |    |       |     |          |         | |
| |        |           |    |       |     |          |         | |
| V        V           |    |       |     |          V         V |
| |   +---------+      |    |       |     |        +---------+ | |     
| |   | Decrypt |<-------<-------------<-----------| Encrypt | | |
| |   +---------+      |    |       |     |        +---------+ | |
| |      |  +--------+ |    |       |     |            ^       | |
| |      |  | Server | |    |       |     |            |       | |
| |      |  | Random |--->------------->------+  +----------+  | |
| |      |  +--------+ |    |       |     |   |  | Client   |  | |
| |      |      |      |    |       |     |   |  | Random   |  | |
| |      |      |      |    |       |     |   |  +----------+  | |
| |      |      |      |    |       |     |   |        |       | |
| |      V      V      |    |       |     |   V        V       | |
| |   +------------+   |    |       |     | +------------+     | |
| +-->|  DSKPP PRF |   |    |       |     | |  DSKPP PRF |<----+ |
|     +------------+   |    |       |     | +------------+       |
|           |          |    |       |     |       |              |
|           V          |    |       |     |       V              |
|       +-------+      |    |       |     |   +-------+          |
|       |  Key  |      |    |       |     |   |  Key  |          |
|       +-------+      |    |       |     |   +-------+          |
|       +-------+      |    |       |     |   +-------+          |
|       |Key Id |-------->------------->------|Key Id |          |
|       +-------+      |    |       |     |   +-------+          |
+----------------------+    +-------+     +----------------------+
      DSKPP Server         DSKPP Client         DSKPP Client
                            (PC Host)      (cryptographic module)
              ]]></artwork>
            </figure>

            <t>Note: Conceptually, although R_C is one pseudorandom string, it
            may be viewed as consisting of two components, R_C1 and R_C2,
            where R_C1 is generated during the protocol run, and R_C2 can be
            pre-generated and loaded on the cryptographic module before the
            device is issued to the user. In that case, the latter string,
            R_C2, SHOULD be unique for each cryptographic module.</t>

            <t>The inclusion of the two random nonces R_S and R_C in the key
            generation provides assurance to both sides (the cryptographic
            module and the DSKPP server) that they have contributed to the
            key's randomness and that the key is unique. The inclusion of the
            encryption key K ensures that no man-in-the-middle may be present,
            or else the cryptographic module will end up with a key different
            from the one stored by the legitimate DSKPP server.</t>

            <t>Note: A man-in-the-middle (in the form of corrupt client
            software or a mistakenly contacted server) may present his own
            public key to the cryptographic module. This will enable the
            attacker to learn the client's version of K_TOKEN. However, the
            attacker is not able to persuade the legitimate server to derive
            the same value for K_TOKEN, since K_TOKEN is a function of the
            public key involved, and the attacker's public key must be
            different than the correct server's (or else the attacker would
            not be able to decrypt the information received from the client).
            Therefore, once the attacker is no longer "in the middle," the
            client and server will detect that they are "out of sync" when
            they try to use their keys. In the case of encrypting R_C with
            K_SERVER, it is therefore important to verify that K_SERVER really
            is the legitimate server's key. One way to do this is to
            independently validate a newly generated K_TOKEN against some
            validation service at the server (e.g. by using a connection
            independent from the one used for the key generation).</t>
          </section>

          <section title="Computing the Symmetric Key">
            <t>In DSKPP, keys are generated using the DSKPP-PRF function
            defined in <xref target="DSKPP-PRF"></xref>, a secret random value
            R_C chosen by the DSKPP client, a random value R_S chosen by the
            DSKPP server, and the key k used to encrypt R_C. The input
            parameter s of DSKPP-PRF is set to the concatenation of the
            (ASCII) string "Key generation", k, and R_S, and the input
            parameter dsLen is set to the desired length of the key, K_TOKEN
            (the length of K_TOKEN is given by the key's type):</t>

            <t>dsLen = (desired length of K_TOKEN)</t>

            <t>K_TOKEN = DSKPP-PRF (R_C, "Key generation" || k || R_S,
            dsLen)</t>

            <t>When computing K_TOKEN above, the output of DSKPP-PRF MAY be
            subject to an algorithm-dependent transform before being adopted
            as a key of the selected type. One example of this is the need for
            parity in DES keys.<vspace blankLines="1" /></t>
          </section>
        </section>

        <section title="Client Authentication">
          <t>To ensure that a generated key K_TOKEN ends up associated with
          the correct cryptographic module and user, the DSKPP client using
          any of the methods described in <xref
          target="Section-ClientAuthN"></xref>. Whatever the method, the DSKPP
          server MUST ensure that a generated key is associated with the
          correct cryptographic module, and if applicable, the correct
          user.</t>
        </section>

        <section title="Key Confirmation">
          <t>In four-pass DSKPP, the client includes a nonce R_C in the
          &lt;KeyProvClientHello&gt; message. The MAC value in the
          &lt;KeyProvServerFinished&gt; message MUST be computed on the
          (ASCII) string "MAC 2 computation", the client nonce R_C using a MAC
          key K_MAC. This key MUST be generated together with K_TOKEN using
          R_C and R_S.</t>

          <t>The MAC value in &lt;KeyProvServerFinished&gt; MAY be computed by
          using the DSKPP-PRF function of <xref target="DSKPP-PRF"></xref>, in
          which case the input parameter s MUST consist of the concatenation
          of the (ASCII) string "MAC 2 computation", R_C, the parameter dsLen
          MUST be set to the length of R_C:</t>

          <t>dsLen = len(R_C)</t>

          <t>MAC = DSKPP-PRF (K_MAC, "MAC 2 computation" || R_C, dsLen)</t>
        </section>

        <section title="Server Authentication">
          <t>A DSKPP server MUST authenticate itself to avoid a false "Commit"
          of a symmetric key that which could cause the cryptographic module
          to end up in an initialized state for which the server does not know
          the stored key. To do this, the DSKPP server authenticates itself by
          including a MAC value in the &lt;KeyProvServerHello&gt; message when
          replacing a existing key. The MAC value is generated using the
          existing the MAC key K_MAC' (the MAC key that existed before this
          protocol run). The MAC algorithm MUST be the same as the algorithm
          used for key confirmation purposes. In addition, a DSKPP server can
          leverage transport layer authentication if it is available.</t>

          <t>When the MAC value is used for server authentication, the value
          MAY be computed by using the DSKPP-PRF function of <xref
          target="DSKPP-PRF"></xref>, in which case the input parameter s MUST
          be set to the concatenation of the (ASCII) string "MAC 1
          computation", R (if sent by the client), and R_S, and k MUST be set
          to the existing MAC key K_MAC' . The input parameter dsLen MUST be
          set to the length of R_S:</t>

          <t>dsLen = len(R_S)</t>

          <t>MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || [R ||] R_S,
          dsLen)</t>
        </section>
      </section>

      <section anchor="Subsecton-TwoPass" title="Two-Pass Protocol Usage">
        <t>The 2-pass protocol flow is suitable for environments wherein near
        real-time communication between the DSKPP client and server may not be
        possible. It is also suitable for environments wherein administrative
        approval is a required step in the flow, and for provisioning of
        pre-generated keys. In the 2-pass protocol flow, the client's initial
        &lt;KeyProvClientHello&gt; message is directly followed by a
        &lt;KeyProvServerFinished&gt; message. There is no exchange of the
        &lt;KeyProvServerHello&gt; message or the &lt;KeyProvClientNonce&gt;
        message. However, as the two-pass variant of DSKPP consists of one
        round trip to the server, the client is still able to include its
        random nonce, R_C, algorithm preferences and supported key types in
        the &lt;KeyProvClientHello&gt; message. Note that by including R_C in
        &lt;KeyProvClientHello&gt;, the DSKPP client is able to ensure the
        server is alive before "committing" the key. Also note that the DSKPP
        "trigger" message MAY be used to trigger the client's sending of the
        &lt;KeyProvClientHello&gt; message.</t>

        <t>Essentially, two-pass DSKPP is a transport of key material from the
        DSKPP server to the DSKPP client. Two-pass DSKPP supports multiple key
        initialization methods that ensure K_TOKEN is not exposed to any other
        entity than the DSKPP server and the cryptographic module itself.
        Currently, three such key initialization methods are defined (refer to
        <xref target="Section-Profiles"></xref>), each supporting a different
        usage of 2-pass DSKPP:</t>

        <t><list hangIndent="28" style="hanging">
            <t hangText="Key Transport">This profile is intended for
            PKI-capable devices. Key transport is carried out using a public
            key, K_CLIENT, whose private key part resides in the cryptographic
            module as the transport key.</t>

            <t hangText="Key Wrap">This profile is ideal for pre-keyed
            devices, e.g., SIM cards. Key wrap is carried out using a
            symmetric key-wrapping key, K_SHARED, which is known in advance by
            both the cryptographic module and the DSKPP server.</t>

            <t hangText="Passphrase-Based Key Wrap">This profile is a
            variation of the Key Wrap Profile. It is applicable to constrained
            devices with keypads, e.g., mobile phones. Key wrap is carried out
            using a passphrase-derived key-wrapping key, K_DERIVED, which is
            known in advance by both the cryptographic module and DSKPP
            server.</t>
          </list><vspace blankLines="1" />The full 2-pass protocol exchange
        when the key is transported using the client public key is as
        follows:</t>

        <t>[&lt;Trigger&gt;]:<vspace blankLines="1" /><list>
            <t>[ID_Device], [ID_K], [URL_S],[R_S]<vspace blankLines="1" /></t>
          </list>&lt;KeyProvClientHello&gt;:<vspace blankLines="1" /><list>
            <t>[ID_Device], ID_K, R_S, R_C, AUTHDATA, Alg_List<vspace
            blankLines="1" /></t>
          </list>&lt;KeyProvServerFinished&gt;:<vspace blankLines="1" /><list>
            <t>ENC_K_CLIENT ( K_TOKEN || K_MAC)), K_CONFDATA, ID_S,
            DSKPP-PRF_K_MAC("MAC 1 Computation" || ID_S || R_C, len(R_C) ), [
            DSKPP-PRF_K_MAC'("MAC 1 Computation" || ID_S || R_C), 16]<vspace
            blankLines="1" /></t>
          </list></t>

        <t>The full 2-pass protocol exchange when the key is wrapped using a
        shared key is as follows:</t>

        <t>[&lt;Trigger&gt;]:<vspace blankLines="1" /><list>
            <t>[ID_Device], [ID_K], [URL_S],[R_S]<vspace blankLines="1" /></t>
          </list>&lt;KeyProvClientHello&gt;:<vspace blankLines="1" /><list>
            <t>[ID_Device], ID_K, R_S, R_C, AUTHDATA, Alg_List<vspace
            blankLines="1" /></t>
          </list>&lt;KeyProvServerFinished&gt;:<vspace blankLines="1" /><list>
            <t>ENC_K_SHARED(K_TOKEN || K_MAC), K_CONFDATA, ID_S,
            DSKPP-PRF_K_MAC("MAC 1 Computation" || ID_S || R_C), [
            DSKPP-PRF_K_MAC'("MAC 1 Computation "|| ID_S||R_C)]<vspace
            blankLines="1" /></t>
          </list>The full 2-pass protocol when the key is wrapped using a
        passphrase based derived key is as follows:</t>

        <t>[&lt;Trigger&gt;]:<vspace blankLines="1" /><list>
            <t>[ID_Device], [ID_K], [URL_S],[R_S]<vspace blankLines="1" /></t>
          </list>&lt;KeyProvClientHello&gt;:<vspace blankLines="1" /><list>
            <t>[ID_Device], ID_K, R_S, R_C, AUTHDATA, Alg_List<vspace
            blankLines="1" /></t>
          </list>&lt;KeyProvServerFinished&gt;:<vspace blankLines="1" /><list>
            <t>ENC_K_DERIVED(K_TOKEN || K_MAC), K_CONFDATA, ID_S,
            DSKPP-PRF_K_MAC("MAC 1 Computation" || ID_S || R_C), [
            DSKPP-PRF_K_MAC'("MAC 1 Computation" || ID_S || R_C)]<vspace
            blankLines="1" /></t>
          </list>The following subsections describe these exchanges in more
        detail.</t>

        <section title="Message Flow">
          <t>The 2-pass protocol flow consists of one round trip between the
          DSKPP client and DSKPP server, which consists of two "passes", i.e.,
          one request message and one response message:</t>

          <t>Round-trip #1: Pass 1=&lt;KeyProvClientHello&gt;, Pass
          2=&lt;KeyProvServerFinished&gt;</t>

          <t><list hangIndent="4" style="format %c.">
              <t>The DSKPP client sends a &lt;KeyProvClientHello&gt; message
              to the DSKPP server. The message provides the client nonce, R_C,
              and information about the DSKPP versions, protocol variants, key
              types, encryption and MAC algorithms supported by the
              cryptographic module for the purposes of this protocol. The
              message may also include client authentication data, such as
              device certificate or MAC derived from authentication code and
              R_C. Authentication code is sent in clear only when underlying
              transport layer can ensure data confidentiality. Unlike 4-pass
              DSKPP, 2-pass DSKPP client uses the &lt;KeyProvClientHello&gt;
              message to declare which key initialization method it supports,
              providing required payload information, e.g., K_CLIENT for the
              Key Transport Profile.</t>

              <t>The DSKPP server generates a key K from which two keys,
              K_TOKEN and K_MAC are derived. (Alternatively, the key K may
              have been pre-generated as described in <xref
              target="UC1"></xref>. K is either transported or wrapped in
              accordance with the key initialization method specified by the
              DSKPP client in the &lt;KeyProvClientHello&gt; message. The
              server then associates K_TOKEN with the cryptographic module in
              a server-side data store. The intent is that the data store
              later on will be used by some service that needs to verify or
              decrypt data produced by the cryptographic module and the
              key.</t>

              <t>Once the association has been made, the DSKPP server sends a
              confirmation message to the DSKPP client called
              &lt;KeyProvServerFinished&gt;. The confirmation message includes
              a key container that holds an identifier for the key, the key K
              from which K_TOKEN and K_MAC are derived, and additional
              configuration information (note that the latter MUST include the
              identity of the DSKPP server for authentication purposes). In
              addition, &lt;KeyProvServerFinished&gt; MUST include two MACs
              whose values are calculated with contribution from the client
              nonce, R_C, provided in the &lt;KeyProvClientHello&gt; message.
              The data will allow the cryptographic module to perform key
              confirmation and server authentication before "committing" the
              key. Note that the second MAC value that is intended for key
              confirmation MAY only be used for replacing and existing
              key.</t>

              <t>Upon receipt of the DSKPP server's confirmation message, the
              cryptographic module extracts the key data from the provided key
              container, uses the provided MAC values to perform key
              confirmation and server authentication, and stores the key
              material locally.</t>
            </list></t>
        </section>

        <section title="Key Confirmation">
          <t>In two-pass DSKPP, the client is REQUIRED to include a nonce R in
          the &lt;KeyProvClientHello&gt; message. Further, the server is
          REQUIRED to include an identifier, ID_S, for itself (via the key
          container) in the &lt;KeyProvServerFinished&gt; message. The MAC
          value in the &lt;KeyProvServerFinished&gt; message MUST be computed
          on the (ASCII) string "MAC 1 computation", the server identifier
          ID_S, and R using a MAC key K_MAC. This key MUST be provided
          together with K_TOKEN to the cryptographic module.</t>

          <t>If DSKPP-PRF is used as the MAC algorithm, then the input
          parameter s MUST consist of the concatenation of the (ASCII) string
          "MAC 1 computation" and R, and the parameter dsLen MUST be set to
          the length of R:</t>

          <t>dsLen = len(R)</t>

          <t>MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || ID_S || R,
          dsLen)</t>
        </section>

        <section anchor="Subsecton-TwoPass-ServerAuth"
                 title="Server Authentication">
          <t>A server MUST authenticate itself when attempting to replace an
          existing K_TOKEN. In 2-pass DSKPP, servers authenticate themselves
          by including a second MAC value in the AuthenticationDataType
          element of &lt;KeyProvServerFinished&gt;. The MAC value in the
          AuthenticationDataType element MUST be computed on the (ASCII)
          string "MAC 1 computation", the server identifier ID_S, and R, using
          the existing MAC key K_MAC' (the MAC key that existed before this
          protocol run). The MAC algorithm MUST be the same as the algorithm
          used for key confirmation purposes.</t>

          <t>If DSKPP-PRF is used as the MAC algorithm, then the input
          parameter s MUST consist of the concatenation of the (ASCII) string
          "MAC 1 computation" ID_S, and R. The parameter dsLen MUST be set to
          at least 16 (i.e. the length of the MAC MUST be at least 16
          octets):</t>

          <t>dsLen &gt;= 16</t>

          <t>MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || ID_S || R,
          dsLen)</t>
        </section>
      </section>

      <section anchor="Subsection-OnePass" title="One-Pass Protocol Usage">
        <t>The one-pass protocol flow is suitable for environments wherein
        near real-time communication between the DSKPP client and server may
        not be possible. It is also suitable for environments wherein
        administrative approval is a required step in the flow, and for
        provisioning of pre-generated keys. In one-pass DSKPP, the server
        simply sends a &lt;KeyProvServerFinished&gt; message to the DSKPP
        client. In this case, there is no exchange of the
        &lt;KeyProvClientHello&gt;, &lt;KeyProvServerHello&gt;, and
        &lt;KeyProvClientNonce&gt; DSKPP messages, and hence there is no way
        for the client to express supported algorithms or key types. Before
        attempting one-pass DSKPP, the server MUST therefore have prior
        knowledge not only that the client is able and willing to accept this
        variant of DSKPP, but also of algorithms and key types supported by
        the client.</t>

        <t>Essentially, one-pass DSKPP is a transport of key material from the
        DSKPP server to the DSKPP client. As with two-pass DSKPP, the one-pass
        variant relies on key initialization methods that ensure K_TOKEN is
        not exposed to any other entity than the DSKPP server and the
        cryptographic module itself. The same key initialization profiles are
        defined as described in <xref target="Subsecton-TwoPass"></xref> and
        <xref target="Section-Profiles"></xref>.</t>

        <t>Outside the specific cases where one-pass DSKPP is desired, clients
        SHOULD be constructed and configured to only accept DSKPP server
        messages in response to client-initiated transactions.</t>

        <t>The 1-pass protocol when the key is transported using the client
        public Key is as follows:</t>

        <t>&lt;KeyProvServerFinished&gt;:<vspace blankLines="1" /><list>
            <t>ENC_K_CLIENT ( K_TOKEN || K_MAC)), K_CONFDATA, DSKPP-PRF_K_MAC
            ("MAC 1 Computation" || ID_S || I), [ DSKPP-PRF_K_MAC'("MAC 2
            Computation"||ID_S||I')]<vspace blankLines="1" /></t>
          </list> The 1-pass protocol when the key is wrapped using a shared
        key is as follows:</t>

        <t>&lt;KeyProvServerFinished&gt;:<vspace blankLines="1" /><list>
            <t>ENC_K_SHARED (K_TOKEN || K_MAC), K_CONFDATA,
            DSKPP-PRF_K_MAC("MAC 1 Computation" || ID_S || I), [
            PRF_K_MAC'("MAC 2 Computation" || ID_S || I')]<vspace
            blankLines="1" /></t>
          </list>The 1-pass protocol when the key is wrapped using a
        passphrase derived key is as follows:</t>

        <t>&lt;KeyProvServerFinished&gt;:<vspace blankLines="1" /><list>
            <t>ENC_K_DERIVED(K_TOKEN || K_MAC), K_CONFDATA,
            DSKPP-PRF_K_MAC("MAC 1 Computation" || ID_S || I),
            [DSKPP-PRF_K_MAC'("MAC 2 Computation" || ID_S || I')]<vspace
            blankLines="1" /></t>
          </list>The subsections below describe the 1-pass protocol in more
        detail.</t>

        <section title="Message Flow">
          <t>The 1-pass protocol flow consists of one "pass", i.e., a single
          message sent from the DSKPP server to the DSKPP client:</t>

          <t>Pass 1: &lt;KeyProvServerFinished&gt;</t>

          <t><list hangIndent="4" style="format %c.">
              <t>The DSKPP server generates a key K from which two keys,
              K_TOKEN and K_MAC are derived. K is either transported or
              wrapped in accordance with the key initialization method known
              in advance by the DSKPP server. The server then associates
              K_TOKEN with the cryptographic module in a server-side data
              store. The intent is that the data store later on will be used
              by some service that needs to verify or decrypt data produced by
              the cryptographic module and the key.</t>

              <t>Once the association has been made, the DSKPP server sends a
              confirmation message to the DSKPP client called
              &lt;KeyProvServerFinished&gt;. The confirmation message includes
              a key container that holds an identifier for the key, the key K
              from which K_TOKEN and K_MAC are derived, and additional
              configuration information (note that the latter MUST include the
              identity of the DSKPP server for authentication purposes). In
              addition, &lt;KeyProvServerFinished&gt; MUST include two MACs,
              which will allow the cryptographic module to perform key
              confirmation and server authentication before "commuting" the
              key. Note that unlike two-pass DSKPP, in the one-pass variant,
              the server does not have the client nonce, R_C, and therefore
              the MACs values are calculated with contribution from an
              unsigned integer, I, generated by the server during the protocol
              run.</t>

              <t>Upon receipt of the DSKPP server's confirmation message, the
              cryptographic module extracts the key data from the provided key
              container, uses the two MAC values to perform key confirmation
              and server authentication, and stores the key material
              locally.</t>
            </list></t>
        </section>

        <section title="Key Confirmation">
          <t>In one-pass DSKPP, the server MUST include an identifier, ID_S,
          for itself (via the key container) in the
          &lt;KeyProvServerFinished&gt; message. The MAC value in the
          &lt;KeyProvServerFinished&gt; message MUST be computed on the
          (ASCII) string "MAC 1 computation", the server identifier ID_S, and
          an unsigned integer value I, using a MAC key K_MAC. The value I MUST
          be monotonically increasing and guaranteed not to be used again by
          this server towards this cryptographic module. It could for example
          be the number of seconds since some point in time with sufficient
          granularity, a counter value, or a combination of the two where the
          counter value is reset for each new time value. In contrast to the
          MAC calculation in four-pass DSKPP, the MAC key K_MAC MUST be
          provided together with K_TOKEN to the cryptographic module.</t>

          <t>Note: The integer I does not necessarily need to be maintained by
          the DSKPP server on a per cryptographic module basis (it is enough
          if the server can guarantee that the same value is never being sent
          twice to the same cryptographic module).</t>

          <t>If DSKPP-PRF is used as the MAC algorithm, then the input
          parameter s MUST consist of the concatenation of the (ASCII) string
          "MAC 1 computation", ID_S, and I. The parameter dsLen MUST be set to
          at least 16 (i.e. the length of the MAC MUST be at least 16
          octets):</t>

          <t>dsLen &gt;= 16</t>

          <t>MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || ID_S || I,
          dsLen)</t>

          <t>The server MUST provide I to the client in the Nonce attribute of
          the &lt;Mac&gt; element of the &lt;KeyProvServerFinished&gt; message
          using the AuthenticationCodeMacType defined in <xref
          target="Section-AuthNData"></xref>.</t>
        </section>

        <section anchor="Subsecton-OnePass-ServerAuth"
                 title="Server Authentication">
          <t>As discussed in , servers need to authenticate themselves when
          attempting to replace an existing K_TOKEN. In 1-pass DSKPP, servers
          authenticate themselves by including a second MAC value in the
          AuthenticationDataType element of &lt;KeyProvServerFinished&gt;. The
          MAC value in the AuthenticationDataType element MUST be computed on
          the (ASCII) string "MAC 1 computation", the server identifier ID_S,
          and a new value I', I' &gt; I, using the existing MAC key K_MAC'
          (the MAC key that existed before this protocol run). The MAC
          algorithm MUST be the same as the algorithm used for key
          confirmation purposes.</t>

          <t>If DSKPP-PRF is used as the MAC algorithm, then the input
          parameter s MUST consist of the concatenation of the (ASCII) string
          "MAC 1 computation" ID_S, and I'. The parameter dsLen MUST be set to
          at least 16 (i.e. the length of the MAC MUST be at least 16
          octets):</t>

          <t>dsLen &gt;= 16</t>

          <t>MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || ID_S || I',
          dsLen)</t>

          <t>The server MUST provide I' to the client in the Nonce attribute
          of the &lt;Mac&gt; element of the AuthenticationDataType extension.
          If the protocol run is successful, the client stores I' as the new
          value of I for this server.</t>
        </section>
      </section>
    </section>

    <section title="Methods Common to More Than One Protocol Variant">
      <t>The mechanisms contained in this section are used in more than one
      variant of DSKPP.</t>

      <section anchor="DSKPP-PRF"
               title="The DSKPP One-Way Pseudorandom Function, DSKPP-PRF">
        <section title="Introduction">
          <t>All of the protocol variants depend on DSKPP-PRF. The general
          requirements on DSKPP-PRF are the same as on keyed hash functions:
          It MUST take an arbitrary length input, and be one-way and
          collision-free (for a definition of these terms, see, e.g., <xref
          target="FAQ"></xref>). Further, the DSKPP-PRF function MUST be
          capable of generating a variable-length output, and its output MUST
          be unpredictable even if other outputs for the same key are
          known.</t>

          <t>It is assumed that any realization of DSKPP-PRF takes three input
          parameters: A secret key k, some combination of variable data, and
          the desired length of the output. The combination of variable data
          can, without loss of generalization, be considered as a salt value
          (see PKCS#5 Version 2.0 <xref target="PKCS-5"></xref>, Section 4),
          and this characterization of DSKPP-PRF SHOULD fit all actual PRF
          algorithms implemented by cryptographic modules. From the point of
          view of this specification, DSKPP-PRF is a "black-box" function
          that, given the inputs, generates a pseudorandom value.</t>

          <t>Separate specifications MAY define the implementation of
          DSKPP-PRF for various types of cryptographic modules. <xref
          target="Section-PRFRealizations"></xref> contains two example
          realizations of DSKPP-PRF.</t>
        </section>

        <section title="Declaration">
          <t>DSKPP-PRF (k, s, dsLen)</t>

          <t>Input:</t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="k">secret key in octet string format</t>

              <t hangText="s">octet string of varying length consisting of
              variable data distinguishing the particular string being
              derived</t>

              <t hangText="dsLen">desired length of the output</t>
            </list></t>

          <t>Output:</t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="DS">pseudorandom string, dsLen-octets long</t>
            </list>For the purposes of this document, the secret key k MUST be
          at least 16 octets long.</t>
        </section>
      </section>

      <section anchor="Subsection-Enc"
               title="Encryption of Pseudorandom Nonces Sent from the DSKPP Client (Applicable to Four-Pass and Two-Pass DSKPP)">
        <t>During 4- and 2-pass message exchanges, DSKPP client random
        nonce(s) are either encrypted with the public key provided by the
        DSKPP server or by a shared secret key. For example, in the case of a
        public RSA key, an RSA encryption scheme from PKCS #1 <xref
        target="PKCS-1"></xref> MAY be used.</t>

        <t>In the case of a shared secret key, to avoid dependence on other
        algorithms, the DSKPP client MAY use the DSKPP-PRF function described
        herein with the shared secret key K_SHARED as input parameter k (in
        this case, K_SHARED SHOULD be used solely for this purpose), the
        concatenation of the (ASCII) string "Encryption" and the server's
        nonce R_S as input parameter s, and dsLen set to the length of
        R_C:</t>

        <t>dsLen = len(R_C)</t>

        <t>DS = DSKPP-PRF(K_SHARED, "Encryption" || R_S, dsLen)</t>

        <t>This will produce a pseudorandom string DS of length equal to R_C.
        Encryption of R_C MAY then be achieved by XOR-ing DS with R_C:</t>

        <t>Enc-R_C = DS ^ R_C</t>

        <t>The DSKPP server will then perform the reverse operation to extract
        R_C from Enc-R_C.</t>
      </section>

      <section anchor="Section-ClientAuthN"
               title="Client Authentication Mechanisms (Applicable to Four- and Two-Pass DSKPP) ">
        <t>To ensure that a generated K_TOKEN ends up associated with the
        correct cryptographic module and user, the DSKPP server MAY couple an
        initial user authentication to the DSKPP execution in several ways, as
        discussed in the following sub-sections. Whatever the method, the
        DSKPP server MUST ensure that a generated key is associated with the
        correct cryptographic module, and if applicable, the correct user. For
        a further discussion of this, and threats related to man-in-the-middle
        attacks in this context, see <xref
        target="Section-Security"></xref>.</t>

        <section title="Device Certificate">
          <t>Instead of requiring an Authentication Code for in-band
          authentication, a device private key and certificate could be used,
          which was supplied with the cryptographic module by its issuer for
          client authentication at the transport layer e.g TLS/HTTPS. When the
          Device certificate is available and client authentication is not
          provided in the transport layer, the DSKPP client may include a
          device's certificate signed data for the authentication data.</t>
        </section>

        <section title="Device Identifier">
          <t>The DSKPP server could be pre-configured with a unique device
          identifier corresponding to a particular cryptographic module. The
          DSKPP server MAY then include this identifier in the DSKPP
          initialization trigger, and the DSKPP client would include it in its
          message(s) to the DSKPP server for authentication. Note that it is
          also legitimate for a DSKPP client to initiate the DSKPP protocol
          run without having received an initialization message from a server,
          but in this case any provided device identifier MUST NOT be accepted
          by the DSKPP server unless the server has access to a unique key for
          the identified device and that key will be used in the protocol.</t>
        </section>

        <section anchor="Section-AuthCode" title="Authentication Code">
          <t>As shown in <xref target="onetime"></xref>, a key issuer may
          provide a one-time value, called an Authentication Code, to the user
          or device out-of-band and require this value to be used by the DSKPP
          client when contacting the DSKPP server. The DSKPP client MAY
          include the authentication data in its &lt;KeyProvClientHello&gt;
          (and &lt;KeyProvClientNonce&gt; for four-pass) message, and the
          DSKPP server MUST verify the data before continuing with the
          protocol run.</t>

          <t>Note: An alternate method for getting the Authentication Code to
          the client, is for the DSKPP server to place the value in the
          &lt;TriggerNonce&gt; element of the DSKPP initialization trigger (if
          triggers are used; see <xref target="Section-InitDSKPP"></xref>) .
          When this method is used, a transport providing privacy and
          integrity MUST be used to deliver the DSKPP initialization trigger
          from the DSKPP server to the DSKPP client, e.g. HTTPS.</t>

          <figure anchor="onetime"
                  title="User Authentication with One-Time               Code">
            <preamble></preamble>

            <artwork><![CDATA[
+------------+  Get Authentication Code  +------------+ 
|    User    |<------------------------->|   Issuer   |
+------------+                           +------------+
       |                                        |
       |                                        |      
       |                                        |     
       V                                        V      
+--------------+                        +--------------+
|    DSKPP     |   Authentication Data  |    DSKPP     |
|    Client    |----------------------->|    Server    |
+--------------+                        +--------------+
 ]]></artwork>
          </figure>

          <t><vspace blankLines="1" />The Authentication Code, AUTHCODE, may
          be considered as a special form of a shared secret between a User
          and a DSKPP server. The Issuer may generate the Authentication Code
          as follows:<vspace blankLines="1" />AUTHCODE = passwordLen ||
          identifier || password || checksum<vspace blankLines="1" /></t>

          <t>where<vspace blankLines="1" /> <list hangIndent="10"
              style="hanging">
              <t hangText="passwordLen">: 1 digit indicating the 'password'
              length. The maximum length of the password is 10. A passwordLen
              value '0' indicates a password of 10 digits.<vspace
              blankLines="1" /></t>

              <t hangText="identifier">: A globally unique identifier of the
              user&rsquo;s order for token provisioning. The length of the
              identifier may be fixed e.g. 10 digits or variable e.g. 1 to 20
              digits. The identifier may be generated as a sequence
              number.<vspace blankLines="1" /></t>

              <t hangText="password">: 6 to 10 digits. The password should be
              generated by the system as a random number to make the AUTHCODE
              more difficult to guess.<vspace blankLines="1" /></t>

              <t hangText="checksum">: 1 digit calculated from the remaining
              digits in the code.</t>
            </list></t>

          <t>The Authentication Data, AUTHDATA, may be derived from the
          AUTHCODE and other information as follows:<vspace
          blankLines="1" /></t>

          <t>MAC = DSKPP-PRF-AES(K_AUTHCODE, AUTHCODE-&gt;Identifier || URL_S
          || [R_S], 16)<vspace blankLines="1" /></t>

          <t>where <vspace blankLines="1" /><list>
              <t>Refer to <xref target="DSKPP-PRF"></xref> for a description
              of DSKPP-PRF in general and <xref
              target="Section-PRFRealizations"></xref> for a description of
              DSKPP-PRF-AES.<vspace blankLines="1" /></t>

              <t>In four-pass DSKPP, the cryptographic module uses the client
              nonce R_C, the server nonce R_S, and the server URL URL_S to
              calculate the MAC. In two-pass DSKPP, the cryptographic module
              does not have access to the server nonce R_S therefore only the
              client nonce R_C is used in combination with the server URL
              URL_S to produce the MAC.<vspace blankLines="1" /></t>

              <t>The K_AUTHCODE MAY be derived from AUTHCODE&gt;password as
              follows:<list>
                  <t>K_AUTHCODE = truncate( Hash( Hash(...n times...(
                  AUTHCODE-&gt;password ||R_C||[K]) ) ) )</t>
                </list><vspace blankLines="1" />where <vspace
              blankLines="1" /><list>
                  <t>K is optional and MAY be one of the following:<vspace
                  blankLines="1" /><list hangIndent="10">
                      <t>K_CLIENT: The device public key when a device
                      certificate is available and used for key transport in
                      2-pass<vspace blankLines="1" /></t>

                      <t>K_SHARED: The shared key between the Client and the
                      Server when it is used for key wrap in two-pass or for
                      R_C protection in four-pass<vspace blankLines="1" /></t>

                      <t>K_DERIVED: when a passphrase derived key is used for
                      key wrap in two-pass.<vspace blankLines="1" /></t>
                    </list></t>

                  <t>'truncate()' returns the first 16 bytes from the result
                  of the last hash iteration, and n is the number of hash
                  iterations. n may be any number between 10 and 1000.</t>
                </list></t>
            </list></t>

          <t>Notes:<list style="format %d">
              <t>Authentication data MAY be omitted if client certificate
              authentication has been provided by the transport channel such
              as TLS.<vspace blankLines="1" /></t>

              <t>When an issuer delegates symmetric key provisioning to a
              third party provisioning service provider, both client
              authentication and issuer authentication are required by the
              provisioning server. Client authentication to the issuer MAY be
              in-band or out-of-band as described above. The issuer acts as a
              proxy for the provisioning server. The issuer authenticates to
              the provisioning service provider either using a certificate or
              a pre-established secret key.</t>
            </list></t>
        </section>
      </section>

      <section title="Client Authentication Examples">
        <section title="Example Using a MAC from an Authentication Code">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[  <AuthenticationData>
    <ClientID>31300257</ClientID>
    <AuthenticationCodeMac>
      <IterationCount>512</IterationCount>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
              </AuthenticationData>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="Example Using a Device Certificate">
          <figure>
            <preamble></preamble>

            <artwork><![CDATA[  <AuthenticationData>
    <DigitalSignature>
      <ds:SignedInfo>
        <ds:CanonicalizationMethod 
          Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" />
        <ds:SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/> 
        <ds:Reference URI="#Nonce">
          <ds:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
          <ds:DigestValue></ds:DigestValue>
        </ds:Reference>
      </ds:SignedInfo>
      <ds:SignatureValue></ds:SignatureValue>
      <ds:KeyInfo>
        <ds:X509Data>
          <ds:X509Certificate>miib</ds:X509Certificate>
        </ds:X509Data>
      </ds:KeyInfo>
      <ds:Object Id="Nonce">xwQzwEl0CjPAiQeDxwRJdQ==</ds:Object>
              </DigitalSignature>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>
      </section>
    </section>

    <section title="Four-Pass Protocol">
      <t>In this section, example messages are used to describe parameters,
      encoding and semantics in a 4-pass DSKPP exchanges. The examples are
      written using XML. While they are syntactically correct, MAC and cipher
      values are fictitious.</t>

      <section title="XML Basics">
        <t>The DSKPP XML schema can be found in <xref
        target="Section-Schema"></xref>. Some DSKPP elements rely on the
        parties being able to compare received values with stored values.
        Unless otherwise noted, all elements in this document that have the
        XML Schema "xs:string" type, or a type derived from it, MUST be
        compared using an exact binary comparison. In particular, DSKPP
        implementations MUST NOT depend on case-insensitive string
        comparisons, normalization or trimming of white space, or conversion
        of locale-specific formats such as numbers.</t>

        <t>Implementations that compare values that are represented using
        different character encodings MUST use a comparison method that
        returns the same result as converting both values to the Unicode
        character encoding, Normalization Form C <xref
        target="UNICODE"></xref>, and then performing an exact binary
        comparison.</t>

        <t>No collation or sorting order for attributes or element values is
        defined. Therefore, DSKPP implementations MUST NOT depend on specific
        sorting orders for values.</t>
      </section>

      <section title="Round-Trip #1:  &lt;KeyProvClientHello&gt; and &lt;KeyProvServerHello&gt;">
        <t></t>

        <section title="Examples">
          <t></t>

          <section title="Example Without a Preceding Trigger">
            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
    keyprov-dskpp-1.0.xsd">  
  <DeviceIdentifierData>
    <DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </DeviceId>
  </DeviceIdentifierData>
  <SupportedKeyTypes>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:otpalg#HOTP</Algorithm>
    <Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </Algorithm>    
  </SupportedKeyTypes>  
  <SupportedEncryptionAlgorithms>
    <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedEncryptionAlgorithms>
  <SupportedMacAlgorithms>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedMacAlgorithms>  
  <SupportedProtocolVariants><FourPass/></SupportedProtocolVariants>
  <SupportedKeyContainers>
    <KeyContainerFormat>
      urn:ietf:params:xml:schema:keyprov:container#KeyContainer
    </KeyContainerFormat>
  </SupportedKeyContainers>
</dskpp:KeyProvClientHello>]]></artwork>

              <postamble></postamble>
            </figure>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerHello Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol" 
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
  keyprov-dskpp-1.0.xsd">
  <KeyType>
    urn:ietf:params:xml:schema:keyprov:otpalg#SecurID-AES
  </KeyType>
  <EncryptionAlgorithm>
    urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
  </EncryptionAlgorithm>
  <MacAlgorithm>
    urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
  </MacAlgorithm>
  <EncryptionKey>
    <ds:KeyName>KEY-1</ds:KeyName>
  </EncryptionKey>
  <KeyContainerFormat>
    urn:ietf:params:xml:schema:keyprov:container#KeyContainer
  </KeyContainerFormat>
  <Payload>
    <Nonce>qw2ewasde312asder394jw==</Nonce>
  </Payload>
</dskpp:KeyProvServerHello>]]></artwork>

              <postamble></postamble>
            </figure>
          </section>

          <section title="Example Assuming a Preceding Trigger">
            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>

<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
    keyprov-dskpp-1.0.xsd">  
  <DeviceIdentifierData>
    <DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </DeviceId>
  </DeviceIdentifierData>
  <KeyID>SE9UUDAwMDAwMDAx</KeyID>
  <TriggerNonce>112dsdfwf312asder394jw==</TriggerNonce>
  <SupportedKeyTypes>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:otpalg#HOTP</Algorithm>
    <Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </Algorithm>    
  </SupportedKeyTypes>  
  <SupportedEncryptionAlgorithms>
    <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedEncryptionAlgorithms>
  <SupportedMacAlgorithms>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedMacAlgorithms>  
  <SupportedProtocolVariants><FourPass/></SupportedProtocolVariants>
  <SupportedKeyContainers>
    <KeyContainerFormat>
      urn:ietf:params:xml:schema:keyprov:container#KeyContainer
    </KeyContainerFormat>
  </SupportedKeyContainers>
</dskpp:KeyProvClientHello>]]></artwork>

              <postamble></postamble>
            </figure>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerHello Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol" 
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
    keyprov-dskpp-1.0.xsd">
  <KeyType>
    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
  </KeyType>
  <EncryptionAlgorithm>
    urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
  </EncryptionAlgorithm>
  <MacAlgorithm>
    urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
  </MacAlgorithm>
  <EncryptionKey>
    <ds:KeyName>KEY-1</ds:KeyName>
  </EncryptionKey>
  <KeyContainerFormat>
    urn:ietf:params:xml:schema:keyprov:container#KeyContainer
  </KeyContainerFormat>
  <Payload>
    <Nonce>qw2ewasde312asder394jw==</Nonce>
  </Payload>
  <Mac MacAlgorithm=
    "urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    cXcycmFuZG9tMzEyYXNkZXIzOTRqdw==
  </Mac>  
</dskpp:KeyProvServerHello>]]></artwork>

              <postamble></postamble>
            </figure>
          </section>
        </section>

        <section title="Components of the &lt;KeyProvClientHello&gt; Request">
          <t>The components of this message have the following meaning:<list
              style="symbols">
              <t>Version: (attribute inherited from the AbstractRequestType
              type) The highest version of this protocol the client supports.
              Only version one ("1.0") is currently specified.</t>

              <t>&lt;DeviceIdentifierData&gt;: An identifier for the
              cryptographic module as defined in <xref
              target="Section-ClientAuthN"></xref> above. The identifier MUST
              only be present if such shared secrets exist or if the
              identifier was provided by the server in a
              &lt;KeyProvTrigger&gt; element (see <xref
              target="Section-InitDSKPP"></xref> below). In the latter case,
              it MUST have the same value as the identifier provided in that
              element.</t>

              <t>&lt;KeyID&gt;: An identifier for the key that will be
              overwritten if the protocol run is successful. The identifier
              MUST only be present if the key exists or if the identifier was
              provided by the server in a &lt;KeyProvTrigger&gt; element, in
              which case, it MUST have the same value as the identifier
              provided in that element (see <xref
              target="Section-Trigger">a</xref> and <xref
              target="Section-InitDSKPP"></xref> below).</t>

              <t>&lt;KeyProvClientNonce&gt;: This is the nonce R, which, when
              present, MUST be used by the server when calculating MAC values
              (see below). It is RECOMMENDED that clients include this element
              whenever the &lt;KeyID&gt; element is present.</t>

              <t>&lt;TriggerNonce&gt;: This OPTIONAL element MUST be present
              if and only if the DSKPP run was initialized with a
              &lt;KeyProvTrigger&gt; message (see <xref
              target="Section-InitDSKPP"></xref> below), and MUST, in that
              case, have the same value as the &lt;TriggerNonce&gt; child of
              that message. A server using nonces in this way MUST verify that
              the nonce is valid and that any device or key identifier values
              provided in the &lt;KeyProvTrigger&gt; message match the
              corresponding identifier values in the
              &lt;KeyProvClientHello&gt; message.</t>

              <t>&lt;SupportedKeyTypes&gt;: A sequence of URIs indicating the
              key types for which the cryptographic module is willing to
              generate keys through DSKPP.</t>

              <t>&lt;SupportedEncryptionAlgorithms&gt;: A sequence of URIs
              indicating the encryption algorithms supported by the
              cryptographic module for the purposes of DSKPP. The DSKPP client
              MAY indicate the same algorithm both as a supported key type and
              as an encryption algorithm.</t>

              <t>&lt;SupportedMacAlgorithms&gt;: A sequence of URIs indicating
              the MAC algorithms supported by the cryptographic module for the
              purposes of DSKPP. The DSKPP client MAY indicate the same
              algorithm both as an encryption algorithm and as a MAC algorithm
              (e.g., urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
              defined in <xref target="Section-PRFRealizations"></xref>).</t>

              <t>&lt;SupportedProtocolVariants&gt;: This OPTIONAL element is
              used by the DSKPP client to indicate support for four-pass or
              two-pass DSKPP. If two-pass support is specified, then
              &lt;KeyProvClientNonce&gt; MUST be set to nonce R in the
              &lt;KeyProvClientHello&gt; message unless &lt;TriggerNonce&gt;
              is already present.</t>

              <t>&lt;SupportedKeyContainers&gt;: This OPTIONAL element is a
              sequence of URIs indicating the key container formats supported
              by the DSKPP client. If this element is not provided, then the
              DSKPP server MUST proceed with
              "urn:ietf:params:xml:schema:keyprov:container#KeyContainer" (see
              <xref target="PSKC"></xref>).</t>

              <t>&lt;AuthenticationData&gt;: This OPTIONAL element contains
              data that the DSKPP client uses to authenticate the user or
              device to the DSKPP server. The element is set as specified in
              <xref target="Section-ClientAuthN"></xref>.</t>

              <t>&lt;Extensions&gt;: A sequence of extensions. One extension
              is defined for this message in this version of DSKPP: the
              ClientInfoType (see <xref
              target="Section-ProtocolExts"></xref>).</t>
            </list></t>

          <section title="The DSKPP Client:  The DeviceIdentifierDataType Type">
            <t>The DeviceIdentifierDataType type is used to uniquely identify
            the device that houses the cryptographic module, e.g., a mobile
            phone. The device identifier allows the DSKPP server to find,
            e.g., a pre-shared transport key for 2-pass DSKPP and/or the
            correct shared secret for MAC'ing purposes. The default
            DeviceIdentifierDataType is defined in <xref
            target="PSKC"></xref>.</t>
          </section>

          <section title="Selecting a Protocol Variant: The ProtocolVariantsType Type">
            <t>The ProtocolVariantsType type is OPTIONAL for a DSKPP client,
            who MAY use it to indicate the number of passes of the DSKPP
            protocol that it supports. The ProtocolVariantsType MAY be used to
            indicate support for 4-pass or 2-pass DSKPP. Because 1-pass DSKPP
            does not include a client request to the server, the
            ProtocolVariantsType type MAY NOT be used to indicate support for
            1-pass DSKPP. If the ProtocolVariantsType is not used, then the
            DSKPP server will proceed with ordinary 4-pass DSKPP. However, it
            does not support 4-pass DSKPP, then the server MUST find a
            suitable two-pass variant or else the protocol run will fail.</t>

            <t>The TwoPassSupportType type signals client support for the
            2-pass version of DSKPP, informs the server of supported two-pass
            variants, and provides OPTIONAL payload data to the DSKPP server.
            The payload is sent in an opportunistic fashion, and MAY be
            discarded by the DSKPP server if the server does not support the
            two-pass variant the payload is associated with. The elements of
            this type have the following meaning:<list style="symbols">
                <t>&lt;SupportedKeyInitializationMethod&gt;: A two-pass key
                initialization method supported by the DSKPP client. Multiple
                supported methods MAY be present, in which case they MUST be
                listed in order of precedence.</t>

                <t>&lt;Payload&gt;: An OPTIONAL payload associated with each
                supported key initialization method.</t>
              </list>A DSKPP client that indicates support for two-pass DSKPP
            MUST also include the nonce R in its &lt;KeyProvClientHello&gt;
            message (this will enable the client to verify that the DSKPP
            server it is communicating with is alive).</t>
          </section>

          <section title="Selecting a Key Container Format: The KeyContainersFormatType Type">
            <t>The OPTIONAL KeyContainersFormatType type is a list of
            type-value pairs that a DSKPP client or server MAY use to define
            key container formats it supports. Key container formats are
            identified through URIs, e.g., the PSKC KeyContainer URI
            "urn:ietf:params:xml:schema:keyprov:container#KeyContainer" (see
            <xref target="PSKC"></xref>).</t>
          </section>

          <section anchor="Section-AuthNData"
                   title="Selecting a Client and Server Authentication Mechanism: The AuthenticationDataType Type">
            <t>The OPTIONAL AuthenticationDataType type is used by DSKPP
            clients and server to carry authentication values in DSKPP
            messages. The element MAY contain a device certificate or MAC
            derived from an authentication code as follows:<list
                style="format %c.">
                <t>A DSKPP client MAY include a one-time use
                AuthenticationCode that was given by the issuer to the user
                for acquiring a symmetric key. An AuthenticationCode MAY or
                MAY NOT contain alphanumeric characters in addition to numeric
                digits depending on the device type and policy of the issuer.
                For example, if the device is a mobile phone, a code that the
                user enters on the keypad would typically be restricted to
                numeric digits for ease of use. An authentication code MAY be
                sent to the DSKPP server as MAC data calculated according to
                section <xref target="Section-AuthCode"></xref>.</t>

                <t>A DSKPP client MAY contain Authentication Data consisting
                of signed data of client Nonce with a client certificate's
                private key. A service provider may have a policy to issue
                symmetric keys for a device only if it has a trusted device
                certificate. An authentication code isn't required in this
                case.</t>

                <t>A DSKPP server MAY use the AuthenticationDataType element
                AuthenticationCodeMac to carry a MAC for authenticating itself
                to the client. For example, when a successful 1- or 2-pass
                DSKPP protocol run will result in an existing key being
                replaced, then the DSKPP server MUST include a MAC proving to
                the DSKPP client that the server knows the value of the key it
                is about to replace.</t>
              </list></t>

            <t>The element of the AuthenticationDataType type have the
            following meaning:<list style="symbols">
                <t>&lt;ClientID&gt;: A requester's identifier. The value MAY
                be a user ID, a device ID, or a keyID associated with the
                requester's authentication value. When the authentication data
                is based on a certificate, &lt;ClientID&gt; can be omitted, as
                the certificate itself is typically sufficient to identify the
                requester. Also, if a &lt;KeyProvTrigger&gt; message was
                provided by the server to initiate the DSKPP protocol run,
                &lt;ClientID&gt; can be omitted, as the DeviceID, KeyID,
                and/or nonce provided in the &lt;InitializationTriggerType&gt;
                element ought to be sufficient to identify the requester.</t>

                <t>&lt;AuthenticationCodeMac&gt;: An authentication MAC and
                OPTIONAL additional information (e.g., MAC algorithm). The
                value could be a one-time use value sent as a MAC value to the
                DSKPP server; or, it could be a MAC value sent to the DSKPP
                client. Refer to section <xref
                target="Section-AuthCode"></xref> for calculation of MAC with
                an authentication code.</t>

                <t>&lt;DigitalSignature&gt;: Client nonce R_C signed using the
                device certificate and sent in KeyProvClientHello for two-pass
                protocol or in KeyProvClientNonce for four-pass protocol.</t>
              </list></t>
          </section>
        </section>

        <section title="Components of the &lt;KeyProvServerHello&gt; Response">
          <t>This message is the first message sent from the DSKPP server to
          the DSKPP client (assuming a trigger message has not been sent to
          initiate the protocol, in which case, this message is the second
          message sent from the DSKPP server to the DSKPP client). It is sent
          upon reception of a &lt;KeyProvClientHello&gt; message. The
          components of this message have the following meaning:</t>

          <t><list style="symbols">
              <t>Version: (attribute inherited from the AbstractResponseType
              type) The version selected by the DSKPP server. MAY be lower
              than the version indicated by the DSKPP client, in which case,
              local policy at the client MUST determine whether or not to
              continue the session.</t>

              <t>SessionID: (attribute inherited from the AbstractResponseType
              type) An identifier for this session.</t>

              <t>Status: (attribute inherited from the AbstractResponseType
              type) Return code for the &lt;KeyProvClientHello&gt;. If Status
              is not "Continue", only the Status and Version attributes will
              be present; otherwise, all the other element MUST be present as
              well.</t>

              <t>&lt;KeyType&gt;: The type of the key to be generated.</t>

              <t>&lt;EncryptionAlgorithm&gt;: The encryption algorithm to use
              when protecting R_C.</t>

              <t>&lt;MacAlgorithm&gt;: The MAC algorithm to be used by the
              DSKPP server.</t>

              <t>&lt;EncryptionKey&gt;: Information about the key to use when
              encrypting R_C. It will either be the server's public key (the
              &lt;ds:KeyValue&gt; alternative of ds:KeyInfoType) or an
              identifier for a shared secret key (the &lt;ds:KeyName&gt;
              alternative of ds:KeyInfoType).</t>

              <t>&lt;KeyContainerFormat&gt;: The key container format type to
              be used by the DSKPP server. The default setting relies on the
              KeyContainerType element defined in
              "urn:ietf:params:xml:schema:keyprov:container" <xref
              target="PSKC"></xref>.</t>

              <t>&lt;Payload&gt;: The actual payload. For this version of the
              protocol, only one payload is defined: the pseudorandom string
              R_S.</t>

              <t>&lt;Extensions&gt;: A list of server extensions. Two
              extensions are defined for this message in this version of
              DSKPP: the ClientInfoType and the ServerInfoType (see <xref
              target="Section-ProtocolExts"></xref>).</t>

              <t>&lt;Mac&gt;: The MAC MUST be present if the DSKPP run will
              result in the replacement of an existing symmetric key with a
              new one (i.e., if the &lt;KeyID&gt; element was present in the
              &lt;ClientHello message). In this case, the DSKPP server MUST
              prove to the cryptographic module that it is authorized to
              replace it.</t>
            </list><list>
              <t>The DSKPP client MUST verify the MAC if the successful
              execution of the protocol will result in the replacement of an
              existing symmetric key with a newly generated one. The DSKPP
              client MUST terminate the DSKPP session if the MAC does not
              verify, and MUST delete any nonces, keys, and/or secrets
              associated with the failed run of the DSKPP protocol.</t>

              <t>The MacType's MacAlgorithm attribute MUST, when present,
              identify the negotiated MAC algorithm.</t>
            </list></t>
        </section>
      </section>

      <section title="Round-Trip #2: &lt;KeyProvClientNonce&gt; and &lt;KeyProvServerFinished&gt;">
        <t></t>

        <section title="Examples">
          <t></t>

          <section title="Example Using Default Encryption">
            <t>This message contains the nonce chosen by the cryptographic
            module, R_C, encrypted by the specified encryption key and
            encryption algorithm.</t>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientNonce Version="1.0" SessionID="4114"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
    keyprov-dskpp-1.0.xsd">
  <EncryptedNonce>VXENc+Um/9/NvmYKiHDLaErK0gk=</EncryptedNonce>
  <AuthenticationData>
    <ClientID>31300257</ClientID>
    <AuthenticationCodeMac>
      <IterationCount>512</IterationCount>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>	
</dskpp:KeyProvClientNonce>]]></artwork>

              <postamble></postamble>
            </figure>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
    keyprov-dskpp-1.0.xsd">  
  <KeyContainer>
    <KeyContainer Version="1.0">
      <pskc:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <pskc:Device>
        <pskc:Key 
          KeyAlgorithm=
          "http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES" 
          KeyId="XL0000000001234">
          <pskc:Issuer>CredentialIssuer</pskc:Issuer>
          <pskc:Usage otp="true">
            <pskc:ResponseFormat format="DECIMAL" length="6"/>
          </pskc:Usage>
          <pskc:FriendlyName>MyFirstToken</pskc:FriendlyName>
          <pskc:Data Name="TIME">
            <pskc:Value>AAAAADuaygA=</pskc:Value>
          </pskc:Data>
          <pskc:Expiry>10/30/2012</pskc:Expiry>
        </pskc:Key>
      </pskc:Device>     
    </KeyContainer>        
  </KeyContainer>
  <Mac 
    MacAlgorithm="urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    miidfasde312asder394jw==
  </Mac>
</dskpp:KeyProvServerFinished>]]></artwork>

              <postamble></postamble>
            </figure>
          </section>
        </section>

        <section title="Components of a &lt;KeyProvClientNonce&gt; Request">
          <t>The components of this message have the following meaning:</t>

          <t><list style="symbols">
              <t>Version: (inherited from the AbstractRequestType type) MUST
              be the same version as in the &lt;KeyProvServerHello&gt;
              message.</t>

              <t>&lt;SessionID&gt;: MUST have the same value as the SessionID
              attribute in the received &lt;KeyProvServerHello&gt;
              message.</t>

              <t>&lt;EncryptedNonce&gt;: The nonce generated and encrypted by
              the cryptographic module. The encryption MUST be made using the
              selected encryption algorithm and identified key, and as
              specified in <xref target="DSKPP-PRF"></xref>.</t>

              <t>&lt;AuthenticationData&gt;: The authentication data value
              MUST be set as specified in <xref
              target="Section-ClientAuthN"></xref> and <xref
              target="Section-AuthNData"></xref>.</t>

              <t>&lt;Extensions&gt;: A list of extensions. Two extensions are
              defined for this message in this version of DSKPP: the
              ClientInfoType and the ServerInfoType (see <xref
              target="Section-ProtocolExts"></xref>)</t>
            </list></t>
        </section>

        <section title="Components of a &lt;KeyProvServerFinished&gt; Response">
          <t>This message is the last message of the DSKPP protocol run. In a
          4-pass exchange, the DSKPP server sends this message in response to
          a &lt;KeyProvClientNonce&gt; message, whereas in a 2-pass exchange,
          the DSKPP server sends this message in response to a
          &lt;KeyProvClientHello&gt; message. In a 1-pass exchange, the DSKPP
          server sends only this message to the client. The components of this
          message have the following meaning:</t>

          <t><list style="symbols">
              <t>Version: (inherited from the AbstractResponseType type) The
              DSKPP version used in this session.</t>

              <t>SessionID: (inherited from the AbstractResponseType type) The
              previously established identifier for this session.</t>

              <t>Status: (inherited from the AbstractResponseType type) Return
              code for the &lt;KeyProvServerFinished&gt; message. If Status is
              not "Success", only the Status, SessionID, and Version
              attributes will be present (the presence of the SessionID
              attribute is dependent on the type of reported error);
              otherwise, all the other elements MUST be present as well. In
              this latter case, the &lt;KeyProvServerFinished&gt; message can
              be seen as a "Commit" message, instructing the cryptographic
              module to store the generated key and associate the given key
              identifier with this key.</t>

              <t>&lt;KeyContainer&gt;: The key container containing symmetric
              key values (in the case of a 2- or 1-pass exchange) and
              configuration data. The default container format is based on the
              KeyContainerType type from PSKC, as defined in <xref
              target="PSKC"></xref>.</t>

              <t>&lt;Extensions&gt;: A list of extensions chosen by the DSKPP
              server. For this message, this version of DSKPP defines one
              extension, the ClientInfoType (see <xref
              target="Section-ProtocolExts"></xref>).</t>

              <t>&lt;Mac&gt;: To avoid a false "Commit" message causing the
              cryptographic module to end up in an initialized state for which
              the server does not know the stored key,
              &lt;KeyProvServerFinished&gt; messages MUST always be
              authenticated with a MAC. The MAC MUST be made using the already
              established MAC algorithm.</t>
            </list><list style="empty">
              <t>When receiving a &lt;KeyProvServerFinished&gt; message with
              Status="Success" for which the MAC verifies, the DSKPP client
              MUST associate the generated key K_TOKEN with the provided key
              identifier and store this data permanently. After this
              operation, it MUST NOT be possible to overwrite the key unless
              knowledge of an authorizing key is proven through a MAC on a
              later &lt;KeyProvServerHello&gt; (and
              &lt;KeyProvServerFinished&gt;) message.</t>

              <t>The DSKPP client MUST verify the MAC. The DSKPP client MUST
              terminate the DSKPP session if the MAC does not verify, and
              MUST, in this case, also delete any nonces, keys, and/or secrets
              associated with the failed run of the DSKPP protocol.</t>

              <t>The MacType's MacAlgorithm attribute MUST, when present,
              identify the negotiated MAC algorithm.</t>
            </list></t>
        </section>
      </section>

      <section title="DSKPP Server Results:  The StatusCode Type">
        <t>The StatusCode type enumerates all possible return codes. Upon
        transmission or receipt of a message for which the Status attribute's
        value is not "Success" or "Continue", the default behavior, unless
        explicitly stated otherwise below, is that both the DSKPP server and
        the DSKPP client MUST immediately terminate the DSKPP session. DSKPP
        servers and DSKPP clients MUST delete any secret values generated as a
        result of failed runs of the DSKPP protocol. Session identifiers MAY
        be retained from successful or failed protocol runs for replay
        detection purposes, but such retained identifiers MUST NOT be reused
        for subsequent runs of the protocol.</t>

        <t>When possible, the DSKPP client SHOULD present an appropriate error
        message to the user.</t>

        <t>These status codes are valid in all 4-Pass DSKPP Response messages
        unless explicitly stated otherwise:<list style="symbols">
            <t>"Continue" indicates that the DSKPP server is ready for a
            subsequent request from the DSKPP client. It cannot be sent in the
            server's final message.</t>

            <t>"Success" indicates successful completion of the DSKPP session.
            It can only be sent in the server's final message.</t>

            <t>"Abort" indicates that the DSKPP server rejected the DSKPP
            client's request for unspecified reasons.</t>

            <t>"AccessDenied" indicates that the DSKPP client is not
            authorized to contact this DSKPP server.</t>

            <t>"MalformedRequest" indicates that the DSKPP server failed to
            parse the DSKPP client's request.</t>

            <t>"UnknownRequest" indicates that the DSKPP client made a request
            that is unknown to the DSKPP server.</t>

            <t>"UnknownCriticalExtension" indicates that a critical DSKPP
            extension (see below) used by the DSKPP client was not supported
            or recognized by the DSKPP server.</t>

            <t>"UnsupportedVersion" indicates that the DSKPP client used a
            DSKPP protocol version not supported by the DSKPP server. This
            error is only valid in the DSKPP server's first response
            message.</t>

            <t>"NoSupportedKeyTypes" indicates that the DSKPP client only
            suggested key types that are not supported by the DSKPP server.
            This error is only valid in the DSKPP server's first response
            message.</t>

            <t>"NoSupportedEncryptionAlgorithms" indicates that the DSKPP
            client only suggested encryption algorithms that are not supported
            by the DSKPP server. This error is only valid in the DSKPP
            server's first response message.</t>

            <t>"NoSupportedMacAlgorithms" indicates that the DSKPP client only
            suggested MAC algorithms that are not supported by the DSKPP
            server. This error is only valid in the DSKPP server's first
            response message.</t>

            <t>"NoProtocolVariants" indicates that the DSKPP client only
            suggested a protocol variant (either 2-pass or 4-pass) that is not
            supported by the DSKPP server. This error is only valid in the
            DSKPP server's first response messagei</t>

            <t>"NoSupportedKeyContainers" indicates that the DSKPP client only
            suggested key container formats that are not supported by the
            DSKPP server. This error is only valid in the DSKPP server's first
            response message.</t>

            <t>"AuthenticationDataMissing" indicates that the DSKPP client
            didn't provide authentication data that the DSKPP server
            required.</t>

            <t>"AuthenticationDataInvalid" indicates that the DSKPP client
            supplied user or device authentication data that the DSKPP server
            failed to validate.</t>

            <t>"InitializationFailed" indicates that the DSKPP server could
            not generate a valid key given the provided data. When this status
            code is received, the DSKPP client SHOULD try to restart DSKPP, as
            it is possible that a new run will succeed.</t>

            <t>"ProvisioningPeriodExpired" indicates that the provisioning
            period set by the DSKPP server has expired. When the status code
            is received, the DSKPP client SHOULD report the key initialization
            failure reason to the user and the user MUST register with the
            DSKPP server to initialize a new key.</t>
          </list></t>
      </section>
    </section>

    <section title="Two-Pass Protocol">
      <t>In this section, example messages are used to describe parameters,
      encoding and semantics in a 2-pass DSKPP exchanges. The examples are
      written using XML. While they are syntactically correct, MAC and cipher
      values are fictitious.</t>

      <section title="XML Basics">
        <t>The DSKPP XML schema can be found in <xref
        target="Section-Schema"></xref>. Some DSKPP elements rely on the
        parties being able to compare received values with stored values.
        Unless otherwise noted, all elements in this document that have the
        XML Schema "xs:string" type, or a type derived from it, MUST be
        compared using an exact binary comparison. In particular, DSKPP
        implementations MUST NOT depend on case-insensitive string
        comparisons, normalization or trimming of white space, or conversion
        of locale-specific formats such as numbers.</t>

        <t>Implementations that compare values that are represented using
        different character encodings MUST use a comparison method that
        returns the same result as converting both values to the Unicode
        character encoding, Normalization Form C <xref
        target="UNICODE"></xref>, and then performing an exact binary
        comparison.</t>

        <t>No collation or sorting order for attributes or element values is
        defined. Therefore, DSKPP implementations MUST NOT depend on specific
        sorting orders for values.</t>
      </section>

      <section title="Round-Trip #1:  &lt;KeyProvClientHello&gt; and &lt;KeyProvServerFinished&gt;">
        <t></t>

        <section title="Examples">
          <t></t>

          <section anchor="Example-TwoPass-1"
                   title="Example Using the Key Transport Profile">
            <t>The client indicates support all the Key Transport, Key Wrap,
            and Passphrase-Based Key Wrap profiles (see <xref
            target="Section-Profiles"></xref>):</t>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
  keyprov-dskpp-1.0.xsd">
  <DeviceIdentifierData>
    <DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </DeviceId>
  </DeviceIdentifierData>
  <ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</ClientNonce>
  <SupportedKeyTypes>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:otpalg#HOTP</Algorithm>
    <Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </Algorithm>    
  </SupportedKeyTypes>  
  <SupportedEncryptionAlgorithms>
    <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
    <Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128</Algorithm>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes</Algorithm>
  </SupportedEncryptionAlgorithms>
  <SupportedMacAlgorithms>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes</Algorithm>
  </SupportedMacAlgorithms>  
  <SupportedProtocolVariants>
    <TwoPass>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#wrap
      </SupportedKeyInitializationMethod>
      <Payload xsi:type="ds:KeyInfoType">
        <ds:KeyName>Key_001</ds:KeyName>
      </Payload>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#transport
      </SupportedKeyInitializationMethod>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap
      </SupportedKeyInitializationMethod>
      <Payload xsi:type="ds:KeyInfoType">
        <ds:X509Data>
          <ds:X509Certificate>miib</ds:X509Certificate>
        </ds:X509Data>
      </Payload>
    </TwoPass>
  </SupportedProtocolVariants>
  <SupportedKeyContainers>
    <KeyContainerFormat>
      urn:ietf:params:xml:schema:keyprov:container#KeyContainer
    </KeyContainerFormat>
  </SupportedKeyContainers>
  <AuthenticationData>
    <DigitalSignature>
      <ds:SignedInfo>
        <ds:CanonicalizationMethod 
          Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" />
        <ds:SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/> 
        <ds:Reference URI="#Nonce">
          <ds:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
          <ds:DigestValue></ds:DigestValue>
        </ds:Reference>
      </ds:SignedInfo>
      <ds:SignatureValue></ds:SignatureValue>
      <ds:KeyInfo>
        <ds:X509Data>
          <ds:X509Certificate>miib</ds:X509Certificate>
        </ds:X509Data>
      </ds:KeyInfo>
      <ds:Object Id="Nonce">xwQzwEl0CjPAiQeDxwRJdQ==</ds:Object>
    </DigitalSignature>
  </AuthenticationData>
</dskpp:KeyProvClientHello>]]></artwork>

              <postamble></postamble>
            </figure>

            <t>In this example, the server responds to the previous request
            using the key transport profile.</t>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
    keyprov-dskpp-1.0.xsd">
  <KeyContainer>
    <KeyContainer Version="1.0">
      <pskc:EncryptionMethod 
        Algorithm="http://www.w3.org/2001/05/xmlenc#rsa_1_5">
        <pskc:KeyInfo>
          <ds:X509Data>
            <ds:X509Certificate>miib</ds:X509Certificate>
          </ds:X509Data>
        </pskc:KeyInfo>
      </pskc:EncryptionMethod>
      <pskc:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <Device xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
        <Key KeyAlgorithm="urn:ietf:params:xml:schema:keyprov:otpalg#HOTP" 
          KeyId="SDU312345678">
          <Issuer>CredentialIssuer</Issuer>
          <Usage otp="true">
            <ResponseFormat format="DECIMAL" length="6"/>
          </Usage>
          <FriendlyName>MyFirstToken</FriendlyName>
          <Data Name="SECRET">
            <Value>
              7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
            </Value>
            <ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </ValueDigest>
          </Data>
          <Data Name="COUNTER">
            <Value>AAAAAAAAAAA=</Value>
          </Data>
          <Expiry>10/30/2012</Expiry>
        </Key>
      </Device>
    </KeyContainer>
  </KeyContainer>
  <Mac 
    MacAlgorithm="urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    miidfasde312asder394jw==
  </Mac>
  <AuthenticationData>
    <AuthenticationCodeMac>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>  
</dskpp:KeyProvServerFinished>]]></artwork>

              <postamble></postamble>
            </figure>
          </section>

          <section title="Example Using the Key Wrap Profile">
            <t>The client sends a request that specifies a shared key to
            protect the K_TOKEN, and the server responds using the Key Wrap
            Profile. Authentication data in this example is basing on an
            authentication code rather than a device certificate.</t>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:pkcs-5="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
  keyprov-dskpp-1.0.xsd">
  <DeviceIdentifierData>
    <DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </DeviceId>
  </DeviceIdentifierData>
  <ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</ClientNonce>
  <SupportedKeyTypes>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:otpalg#HOTP</Algorithm>
    <Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </Algorithm>    
  </SupportedKeyTypes>  
  <SupportedEncryptionAlgorithms>
    <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
    <Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128</Algorithm>
    <Algorithm>
      http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2
    </Algorithm>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedEncryptionAlgorithms>
  <SupportedMacAlgorithms>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedMacAlgorithms>  
  <SupportedProtocolVariants>
    <TwoPass>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#wrap
      </SupportedKeyInitializationMethod>
      <Payload xsi:type="ds:KeyInfoType">
        <ds:KeyName>Key_001</ds:KeyName>
      </Payload>
    </TwoPass>
  </SupportedProtocolVariants>
  <SupportedKeyContainers>
    <KeyContainerFormat>
      urn:ietf:params:xml:schema:keyprov:container#KeyContainer
    </KeyContainerFormat>
  </SupportedKeyContainers>
  <AuthenticationData>
    <ClientID>31300257</ClientID>
    <AuthenticationCodeMac>
      <IterationCount>512</IterationCount>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>	
</dskpp:KeyProvClientHello>]]></artwork>

              <postamble></postamble>
            </figure>

            <t>In this example, the server responds to the previous request
            using the key wrap profile.</t>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
  keyprov-dskpp-1.0.xsd">
  <KeyContainer>
    <ServerID>https://www.somedskppservice.com/</ServerID>
    <KeyContainer Version="1.0">
      <EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#kw-aes128" 
        xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
        <KeyInfo>
           <ds:KeyName>Key-001</ds:KeyName>
         </KeyInfo>
      </EncryptionMethod>
      <pskc:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <Device xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
        <Key KeyAlgorithm="urn:ietf:params:xml:schema:keyprov:otpalg#HOTP" 
          KeyId="SDU312345678">
          <Issuer>CredentialIssuer</Issuer>
          <Usage otp="true">
            <ResponseFormat format="DECIMAL" length="6"/>
          </Usage>
          <FriendlyName>MyFirstToken</FriendlyName>
          <Data Name="SECRET">
            <Value>
              JSPUyp3azOkqJENSsh6b2hdXz1WBYypzJxEr+ikQAa22M6V/BgZhRg==
            </Value>
            <ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </ValueDigest>
          </Data>
          <Data Name="COUNTER">
            <Value>AAAAAAAAAAA=</Value>
          </Data>
          <Expiry>10/30/2012</Expiry>
        </Key>
      </Device>
    </KeyContainer>
  </KeyContainer>
  <Mac MacAlgorithm="urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    miidfasde312asder394jw==
  </Mac>
  <AuthenticationData>
    <AuthenticationCodeMac>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>	    
</dskpp:KeyProvServerFinished>]]></artwork>

              <postamble></postamble>
            </figure>
          </section>

          <section title="Example Using the Passphrase-Based Key Wrap Profile">
            <t>The client sends a request similar to that in <xref
            target="Example-TwoPass-1"></xref> with authentication data basing
            on an authentication code, and the server responds using the
            Passphrase-Based Key Wrap Profile. The authentication data is set
            in clear text when it is sent over a secure transport channel such
            as TLS.</t>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:pkcs-5="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
  keyprov-dskpp-1.0.xsd">
  <DeviceIdentifierData>
    <DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </DeviceId>
  </DeviceIdentifierData>
  <ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</ClientNonce>
  <SupportedKeyTypes>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:otpalg#HOTP</Algorithm>
    <Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </Algorithm>    
  </SupportedKeyTypes>  
  <SupportedEncryptionAlgorithms>
    <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
    <Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128</Algorithm>
    <Algorithm>
      http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2
    </Algorithm>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedEncryptionAlgorithms>
  <SupportedMacAlgorithms>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedMacAlgorithms>  
  <SupportedProtocolVariants>
    <TwoPass>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#wrap
      </SupportedKeyInitializationMethod>
      <Payload xsi:type="ds:KeyInfoType">
        <ds:KeyName>Key_001</ds:KeyName>
      </Payload>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap
      </SupportedKeyInitializationMethod>
    </TwoPass>
  </SupportedProtocolVariants>
  <SupportedKeyContainers>
    <KeyContainerFormat>
      urn:ietf:params:xml:schema:keyprov:container#KeyContainer
    </KeyContainerFormat>
  </SupportedKeyContainers>
  <AuthenticationData>
    <ClientID>31300257</ClientID>
    <AuthenticationCodeMac>
      <IterationCount>512</IterationCount>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>
</dskpp:KeyProvClientHello>]]></artwork>

              <postamble></postamble>
            </figure>

            <t>In this example, the server responds to the previous request
            using the Passphrase-Based Key Wrap Profile.</t>

            <figure>
              <preamble></preamble>

              <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
    keyprov-dskpp-1.0.xsd">
  <KeyContainer>
    <KeyContainer Version="1.0">
      <EncryptionMethod 
        Algorithm="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2"
        xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">         
          <PBEEncryptionParam 
             EncryptionAlgorithm="http://www.w3.org/2001/04/xmlenc#kw-aes128-cbc">
            <PBESalt>y6TzckeLRQw=</PBESalt>
            <PBEIterationCount>1024</PBEIterationCount>            
          </PBEEncryptionParam>
          <IV>c2FtcGxlaXY=</IV>
        </EncryptionMethod> 
      <pskc:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>    
      <Device xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
        <Key KeyAlgorithm="urn:ietf:params:xml:schema:keyprov:otpalg#HOTP" 
          KeyId="SDU312345678">
          <Issuer>CredentialIssuer</Issuer>
          <Usage otp="true">
            <ResponseFormat format="DECIMAL" length="6"/>
          </Usage>
          <FriendlyName>MyFirstToken</FriendlyName>
          <Data Name="SECRET">
            <Value>
              JSPUyp3azOkqJENSsh6b2hdXz1WBYypzJxEr+ikQAa22M6V/BgZhRg==
            </Value>
            <ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </ValueDigest>
          </Data>
          <Data Name="COUNTER">
            <Value>AAAAAAAAAAA=</Value>
          </Data>
          <Expiry>10/30/2012</Expiry>
        </Key>
      </Device>
    </KeyContainer>
  </KeyContainer>
  <Mac MacAlgorithm="urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    miidfasde312asder394jw==
  </Mac>
  <AuthenticationData>
    <AuthenticationCodeMac>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>	      
</dskpp:KeyProvServerFinished>]]></artwork>

              <postamble></postamble>
            </figure>
          </section>
        </section>

        <section title="Components of the &lt;KeyProvClientHello&gt; Request">
          <t>The components of this message have the following meaning:<list
              style="symbols">
              <t>Version: (attribute inherited from the AbstractRequestType
              type) The highest version of this protocol the client supports.
              Only version one ("1.0") is currently specified.</t>

              <t>&lt;DeviceIdentifierData&gt;: An identifier for the
              cryptographic module as defined in <xref
              target="Section-ClientAuthN"></xref> above. The identifier MUST
              only be present if such shared secrets exist or if the
              identifier was provided by the server in a
              &lt;KeyProvTrigger&gt; element (see <xref
              target="Section-InitDSKPP"></xref> below). In the latter case,
              it MUST have the same value as the identifier provided in that
              element.</t>

              <t>&lt;KeyID&gt;: An identifier for the key that will be
              overwritten if the protocol run is successful. The identifier
              MUST only be present if the key exists or the identifier was
              provided by the server in a &lt;KeyProvTrigger&gt; element (see
              <xref target="Section-InitDSKPP"></xref> below). In the latter
              case, it MUST have the same value as the identifier provided in
              that element.</t>

              <t>&lt;KeyProvClientNonce&gt;: This is the nonce R, which, when
              present, MUST be used by the server when calculating MAC values
              (see below). It is RECOMMENDED that clients include this element
              whenever the &lt;KeyID&gt; element is present.</t>

              <t>&lt;TriggerNonce&gt;: This OPTIONAL element MUST be present
              if and only if the DSKPP run was initialized with a
              &lt;KeyProvTrigger&gt; message (see <xref
              target="Section-InitDSKPP"></xref> below), and MUST, in that
              case, have the same value as the &lt;TriggerNonce&gt; child of
              that message. A server using nonces in this way MUST verify that
              the nonce is valid and that any device or key identifier values
              provided in the &lt;KeyProvTrigger&gt; message match the
              corresponding identifier values in the
              &lt;KeyProvClientHello&gt; message.</t>

              <t>&lt;SupportedKeyTypes&gt;: A sequence of URIs indicating the
              key types for which the cryptographic module is willing to
              generate keys through DSKPP.</t>

              <t>&lt;SupportedEncryptionAlgorithms&gt;: A sequence of URIs
              indicating the encryption algorithms supported by the
              cryptographic module for the purposes of DSKPP. The DSKPP client
              MAY indicate the same algorithm both as a supported key type and
              as an encryption algorithm.</t>

              <t>&lt;SupportedMacAlgorithms&gt;: A sequence of URIs indicating
              the MAC algorithms supported by the cryptographic module for the
              purposes of DSKPP. The DSKPP client MAY indicate the same
              algorithm both as an encryption algorithm and as a MAC algorithm
              (e.g., urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
              defined in <xref target="Section-PRFRealizations"></xref>).</t>

              <t>&lt;SupportedProtocolVariants&gt;: This OPTIONAL element is
              used by the DSKPP client to indicate support for four-pass or
              two-pass DSKPP. If two-pass support is specified, then
              &lt;KeyProvClientNonce&gt; MUST be set to nonce R in the
              &lt;KeyProvClientHello&gt; message unless &lt;TriggerNonce&gt;
              is already present.</t>

              <t>&lt;SupportedKeyContainers&gt;: This OPTIONAL element is a
              sequence of URIs indicating the key container formats supported
              by the DSKPP client. If this element is not provided, then the
              DSKPP server MUST proceed with
              "urn:ietf:params:xml:schema:keyprov:container#KeyContainer" (see
              <xref target="PSKC"></xref>.</t>

              <t>&lt;AuthenticationData&gt;: This OPTIONAL element contains
              data that the DSKPP client uses to authenticate the user or
              device to the DSKPP server. The element is set as specified in
              <xref target="Section-ClientAuthN"></xref>.</t>

              <t>&lt;Extensions&gt;: A sequence of extensions. One extension
              is defined for this message in this version of DSKPP: the
              ClientInfoType (see <xref
              target="Section-ProtocolExts"></xref>).</t>
            </list></t>
        </section>

        <section title="Components of a &lt;KeyProvServerFinished&gt; Response">
          <t>This message is the last message of the DSKPP protocol run. In a
          4-pass exchange, the DSKPP server sends this message in response to
          a &lt;KeyProvClientNonce&gt; message, whereas in a 2-pass exchange,
          the DSKPP server sends this message in response to a
          &lt;KeyProvClientHello&gt; message. In a 1-pass exchange, the DSKPP
          server sends only this message to the client. The components of this
          message have the following meaning:</t>

          <t><list style="symbols">
              <t>Version: (inherited from the AbstractResponseType type) The
              DSKPP version used in this session.</t>

              <t>SessionID: (inherited from the AbstractResponseType type) The
              previously established identifier for this session.</t>

              <t>Status: (inherited from the AbstractResponseType type) Return
              code for the &lt;KeyProvServerFinished&gt; message. If Status is
              not "Success", only the Status, SessionID, and Version
              attributes will be present (the presence of the SessionID
              attribute is dependent on the type of reported error);
              otherwise, all the other elements MUST be present as well. In
              this latter case, the &lt;KeyProvServerFinished&gt; message can
              be seen as a "Commit" message, instructing the cryptographic
              module to store the generated key and associate the given key
              identifier with this key.</t>

              <t>&lt;KeyContainer&gt;: The key container containing symmetric
              key values (in the case of a 2- or 1-pass exchange) and
              configuration data. The default container format is based on the
              KeyContainerType type from PSKC, as defined in <xref
              target="PSKC"></xref>.</t>

              <t>&lt;Extensions&gt;: A list of extensions chosen by the DSKPP
              server. For this message, this version of DSKPP defines one
              extension, the ClientInfoType (see <xref
              target="Section-ProtocolExts"></xref>).</t>

              <t>&lt;Mac&gt;: To avoid a false "Commit" message causing the
              cryptographic module to end up in an initialized state for which
              the server does not know the stored key,
              &lt;KeyProvServerFinished&gt; messages MUST always be
              authenticated with a MAC. The MAC MUST be made using the already
              established MAC algorithm.</t>

              <t>&lt;AuthenticationData&gt;: This OPTIONAL element contains
              data that allows the DSKPP client to authenticate the DSKPP
              server. The MAC value is calculated with K_MAC' as specified in
              <xref target="Subsecton-TwoPass-ServerAuth"></xref>.</t>
            </list><list style="empty">
              <t>When receiving a &lt;KeyProvServerFinished&gt; message with
              Status="Success" for which the MAC verifies, the DSKPP client
              MUST associate the generated key K_TOKEN with the provided key
              identifier and store this data permanently. After this
              operation, it MUST not be possible to overwrite the key unless
              knowledge of an authorizing key is proven through a MAC on a
              later &lt;KeyProvServerHello&gt; (and
              &lt;KeyProvServerFinished&gt;) message.</t>

              <t>The DSKPP client MUST verify the MAC. The DSKPP client MUST
              terminate the DSKPP session if the MAC does not verify, and
              MUST, in this case, also delete any nonces, keys, and/or secrets
              associated with the failed run of the DSKPP protocol.</t>

              <t>The MacType's MacAlgorithm attribute MUST, when present,
              identify the negotiated MAC algorithm.</t>
            </list></t>
        </section>
      </section>

      <section title="DSKPP Server Results:  The StatusCode Type">
        <t>The StatusCode type enumerates all possible return codes. Upon
        transmission or receipt of a message for which the Status attribute's
        value is not "Success" or "Continue", the default behavior, unless
        explicitly stated otherwise below, is that both the DSKPP server and
        the DSKPP client MUST immediately terminate the DSKPP session. DSKPP
        servers and DSKPP clients MUST delete any secret values generated as a
        result of failed runs of the DSKPP protocol. Session identifiers MAY
        be retained from successful or failed protocol runs for replay
        detection purposes, but such retained identifiers MUST not be reused
        for subsequent runs of the protocol.</t>

        <t>When possible, the DSKPP client SHOULD present an appropriate error
        message to the user.</t>

        <t>These status codes are valid in all DSKPP Response messages unless
        explicitly stated otherwise:<list style="symbols">
            <t>"Continue" indicates that the DSKPP server is ready for a
            subsequent request from the DSKPP client. It cannot be sent in the
            server's final message.</t>

            <t>"Success" indicates successful completion of the DSKPP session.
            It can only be sent in the server's final message.</t>

            <t>"Abort" indicates that the DSKPP server rejected the DSKPP
            client's request for unspecified reasons.</t>

            <t>"AccessDenied" indicates that the DSKPP client is not
            authorized to contact this DSKPP server.</t>

            <t>"MalformedRequest" indicates that the DSKPP server failed to
            parse the DSKPP client's request.</t>

            <t>"UnknownRequest" indicates that the DSKPP client made a request
            that is unknown to the DSKPP server.</t>

            <t>"UnknownCriticalExtension" indicates that a critical DSKPP
            extension (see below) used by the DSKPP client was not supported
            or recognized by the DSKPP server.</t>

            <t>"UnsupportedVersion" indicates that the DSKPP client used a
            DSKPP protocol version not supported by the DSKPP server. This
            error is only valid in the DSKPP server's first response
            message.</t>

            <t>"NoSupportedKeyTypes" indicates that the DSKPP client only
            suggested key types that are not supported by the DSKPP server.
            This error is only valid in the DSKPP server's first response
            message.</t>

            <t>"NoSupportedEncryptionAlgorithms" indicates that the DSKPP
            client only suggested encryption algorithms that are not supported
            by the DSKPP server. This error is only valid in the DSKPP
            server's first response message. Note that the error will only
            occur if the DSKPP server does not support any of the DSKPP
            client's suggested encryption algorithms.</t>

            <t>"NoSupportedMacAlgorithms" indicates that the DSKPP client only
            suggested MAC algorithms that are not supported by the DSKPP
            server. This error is only valid in the DSKPP server's first
            response message. Note that the error will only occur if the DSKPP
            server does not support any of the DSKPP client's suggested MAC
            algorithms.</t>

            <t>"NoProtocolVariants" indicates that the DSKPP client only
            suggested a protocol variant (either 2-pass or 4-pass) that is not
            supported by the DSKPP server. This error is only valid in the
            DSKPP server's first response message. Note that the error will
            only occur if the DSKPP server does not support any of the DSKPP
            client's suggested protocol variants.</t>

            <t>"NoSupportedKeyContainers" indicates that the DSKPP client only
            suggested key container formats that are not supported by the
            DSKPP server. This error is only valid in the DSKPP server's first
            response message. Note that the error will only occur if the DSKPP
            server does not support any of the DSKPP client's suggested key
            container formats.</t>

            <t>"AuthenticationDataMissing" indicates that the DSKPP client
            didn't provide authentication data that the DSKPP server
            required.</t>

            <t>"AuthenticationDataInvalid" indicates that the DSKPP client
            supplied user or device authentication data that the DSKPP server
            failed to validate.</t>

            <t>"InitializationFailed" indicates that the DSKPP server could
            not generate a valid key given the provided data. When this status
            code is received, the DSKPP client SHOULD try to restart DSKPP, as
            it is possible that a new run will succeed.</t>

            <t>"ProvisioningPeriodExpired" indicates that the provisioning
            period set by the DSKPP server has expired. When the status code
            is received, the DSKPP client SHOULD report the key initialization
            failure reason to the user and the user MUST register with the
            DSKPP server to initialize a new key.</t>
          </list></t>
      </section>
    </section>

    <section title="One-Pass Protocol">
      <t>In this section, example messages are used to describe parameters,
      encoding and semantics in a 1-pass DSKPP protocol. The examples are
      written using XML. While they are syntactically correct, MAC and cipher
      values are fictitious.</t>

      <section title="XML Basics">
        <t>The DSKPP XML schema can be found in <xref
        target="Section-Schema"></xref>. Some DSKPP elements rely on the
        parties being able to compare received values with stored values.
        Unless otherwise noted, all elements in this document that have the
        XML Schema "xs:string" type, or a type derived from it, MUST be
        compared using an exact binary comparison. In particular, DSKPP
        implementations MUST NOT depend on case-insensitive string
        comparisons, normalization or trimming of white space, or conversion
        of locale-specific formats such as numbers.</t>

        <t>Implementations that compare values that are represented using
        different character encodings MUST use a comparison method that
        returns the same result as converting both values to the Unicode
        character encoding, Normalization Form C <xref
        target="UNICODE"></xref>, and then performing an exact binary
        comparison.</t>

        <t>No collation or sorting order for attributes or element values is
        defined. Therefore, DSKPP implementations MUST NOT depend on specific
        sorting orders for values.</t>
      </section>

      <section title="Server to Client Only: &lt;KeyProvServerFinished&gt;">
        <t></t>

        <section title="Example">
          <t>The Server sends a provisioned key to a client with prior
          knowledge about the client's capabilities:</t>

          <figure>
            <preamble></preamble>

            <artwork><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
    keyprov-dskpp-1.0.xsd">
  <KeyContainer>
    <KeyContainer Version="1.0">
      <pskc:EncryptionMethod 
        Algorithm="http://www.w3.org/2001/05/xmlenc#rsa_1_5">
        <pskc:KeyInfo>
          <ds:X509Data>
            <ds:X509Certificate>miib</ds:X509Certificate>
          </ds:X509Data>
        </pskc:KeyInfo>
      </pskc:EncryptionMethod>
      <pskc:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <Device xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
        <Key KeyAlgorithm="urn:ietf:params:xml:schema:keyprov:otpalg#HOTP" 
          KeyId="SDU312345678">
          <Issuer>CredentialIssuer</Issuer>
          <Usage otp="true">
            <ResponseFormat format="DECIMAL" length="6"/>
          </Usage>
          <FriendlyName>MyFirstToken</FriendlyName>
          <Data Name="SECRET">
            <Value>
              7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
            </Value>
            <ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </ValueDigest>
          </Data>
          <Data Name="COUNTER">
            <Value>AAAAAAAAAAA=</Value>
          </Data>
          <Expiry>10/30/2009</Expiry>
        </Key>
      </Device>
    </KeyContainer>
  </KeyContainer>
  <Mac MacAlgorithm="urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    miidfasde312asder394jw==
  </Mac>
  <AuthenticationData>
    <AuthenticationCodeMac>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>	  
</dskpp:KeyProvServerFinished>]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="Components of a &lt;KeyProvServerFinished&gt; Response">
          <t>This message is the last message of the DSKPP protocol run. In a
          4-pass exchange, the DSKPP server sends this message in response to
          a &lt;KeyProvClientNonce&gt; message, whereas in a 2-pass exchange,
          the DSKPP server sends this message in response to a
          &lt;KeyProvClientHello&gt; message. In a 1-pass exchange, the DSKPP
          server sends only this message to the client. The components of this
          message have the following meaning:</t>

          <t><list style="symbols">
              <t>Version: (inherited from the AbstractResponseType type) The
              DSKPP version used in this session.</t>

              <t>SessionID: (inherited from the AbstractResponseType type) The
              previously established identifier for this session.</t>

              <t>Status: (inherited from the AbstractResponseType type) Return
              code for the &lt;KeyProvServerFinished&gt; message. If Status is
              not "Success", only the Status, SessionID, and Version
              attributes will be present (the presence of the SessionID
              attribute is dependent on the type of reported error);
              otherwise, all the other elements MUST be present as well. In
              this latter case, the &lt;KeyProvServerFinished&gt; message can
              be seen as a "Commit" message, instructing the cryptographic
              module to store the generated key and associate the given key
              identifier with this key.</t>

              <t>&lt;KeyContainer&gt;: The key container containing symmetric
              key values (in the case of a 2- or 1-pass exchange) and
              configuration data. The default container format is based on the
              KeyContainerType type from PSKC, as defined in <xref
              target="PSKC"></xref>.</t>

              <t>&lt;Extensions&gt;: A list of extensions chosen by the DSKPP
              server. For this message, this version of DSKPP defines one
              extension, the ClientInfoType (see <xref
              target="Section-ProtocolExts"></xref>).</t>

              <t>&lt;Mac&gt;: To avoid a false "Commit" message causing the
              cryptographic module to end up in an initialized state for which
              the server does not know the stored key,
              &lt;KeyProvServerFinished&gt; messages MUST always be
              authenticated with a MAC. The MAC MUST be made using the already
              established MAC algorithm.</t>

              <t>&lt;AuthenticationData&gt;: This OPTIONAL element contains
              data that allows the DSKPP client to authenticate the DSKPP
              server. The MAC value is calculated with K_MAC' as specified in
              <xref target="Subsecton-OnePass-ServerAuth"></xref>.</t>
            </list><list style="empty">
              <t>When receiving a &lt;KeyProvServerFinished&gt; message with
              Status="Success" for which the MAC verifies, the DSKPP client
              MUST associate the generated key K_TOKEN with the provided key
              identifier and store this data permanently. After this
              operation, it MUST not be possible to overwrite the key unless
              knowledge of an authorizing key is proven through a MAC on a
              later &lt;KeyProvServerHello&gt; (and
              &lt;KeyProvServerFinished&gt;) message.</t>

              <t>The DSKPP client MUST verify the MAC. The DSKPP client MUST
              terminate the DSKPP session if the MAC does not verify, and
              MUST, in this case, also delete any nonces, keys, and/or secrets
              associated with the failed run of the DSKPP protocol.</t>

              <t>The MacType's MacAlgorithm attribute MUST, when present,
              identify the negotiated MAC algorithm.</t>
            </list></t>
        </section>
      </section>
    </section>

    <section anchor="Section-Trigger" title="Trigger">
      <t>In this section, an example is used to describe parameters, encoding
      and semantics in a DSKPP Trigger message. The example is written using
      XML.</t>

      <section title="XML Basics">
        <t>The DSKPP XML schema can be found in <xref
        target="Section-Schema"></xref>. Some DSKPP elements rely on the
        parties being able to compare received values with stored values.
        Unless otherwise noted, all elements in this document that have the
        XML Schema "xs:string" type, or a type derived from it, MUST be
        compared using an exact binary comparison. In particular, DSKPP
        implementations MUST NOT depend on case-insensitive string
        comparisons, normalization or trimming of white space, or conversion
        of locale-specific formats such as numbers.</t>

        <t>Implementations that compare values that are represented using
        different character encodings MUST use a comparison method that
        returns the same result as converting both values to the Unicode
        character encoding, Normalization Form C <xref
        target="UNICODE"></xref>, and then performing an exact binary
        comparison.</t>

        <t>No collation or sorting order for attributes or element values is
        defined. Therefore, DSKPP implementations MUST NOT depend on specific
        sorting orders for values.</t>
      </section>

      <section title="Example">
        <t></t>

        <figure>
          <preamble></preamble>

          <artwork><![CDATA[
<dskpp:KeyProvTrigger Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol" 
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol 
    keyprov-dskpp-1.0.xsd">
  <InitializationTrigger>
    <DeviceIdentifierData>
      <DeviceId>
        <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
        <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
        <pskc:Model>U2</pskc:Model>
      </DeviceId>
    </DeviceIdentifierData>
    <KeyID>SE9UUDAwMDAwMDAx</KeyID>
    <TokenPlatformInfo KeyLocation="Hardware" AlgorithmLocation="Software"/>
    <TriggerNonce>112dsdfwf312asder394jw==</TriggerNonce>       
    <DSKPPServerUrl>https://www.somekeyprovservice.com/</DSKPPServerUrl>       
  </InitializationTrigger>
</dskpp:KeyProvTrigger>]]></artwork>

          <postamble></postamble>
        </figure>
      </section>

      <section title="Components of the &lt;KeyProvTrigger&gt; Message">
        <t>The DSKPP server MAY initialize the DSKPP protocol by sending a
        &lt;KeyProvTrigger&gt; message. This message MAY, e.g., be sent in
        response to a user requesting key initialization in a browsing
        session.</t>

        <t>The &lt;KeyProvTrigger&gt; element is intended for the DSKPP client
        and MAY inform the DSKPP client about the identifier for the device
        that houses the cryptographic module to be initialized, and optionally
        of the identifier for the key on that module. The latter would apply
        to key renewal. The trigger always contains a nonce to allow the DSKPP
        server to couple the trigger with a later DSKPP
        &lt;KeyProvClientHello&gt; request. Finally, the trigger MAY contain a
        URL to use when contacting the DSKPP server. The &lt;xs:any&gt;
        elements are for future extensibility. Any provided
        &lt;DeviceIdentifierData&gt; or &lt;KeyID&gt; values MUST be used by
        the DSKPP client in the subsequent &lt;KeyProvClientHello&gt; request.
        The OPTIONAL &lt;TokenPlatformInfo&gt; element informs the DSKPP
        client about the characteristics of the intended cryptographic module
        platform, and applies in the public-key variant of DSKPP in situations
        when the client potentially needs to decide which one of several
        modules to initialize.</t>
      </section>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-ProtocolExts" title="Extensibility">
      <section title="The ClientInfoType Type">
        <t>present in a &lt;KeyProvClientHello&gt; or a
        &lt;KeyProvClientNonce&gt; message, the OPTIONAL ClientInfoType
        extension contains DSKPP client-specific information. DSKPP servers
        MUST support this extension. DSKPP servers MUST NOT attempt to
        interpret the data it carries and, if received, MUST include it
        unmodified in the current protocol run's next server response. Servers
        need not retain the ClientInfoType's data after that response has been
        generated.</t>
      </section>

      <section title="The ServerInfoType Type">
        <t>When present, the OPTIONAL ServerInfoType extension contains DSKPP
        server-specific information. This extension is only valid in
        &lt;KeyProvServerHello&gt; messages for which Status = "Continue".
        DSKPP clients MUST support this extension. DSKPP clients MUST NOT
        attempt to interpret the data it carries and, if received, MUST
        include it unmodified in the current protocol run's next client
        request (i.e., the &lt;KeyProvClientNonce&gt; message). DSKPP clients
        need not retain the ServerInfoType's data after that request has been
        generated. This extension MAY be used, e.g., for state management in
        the DSKPP server.</t>
      </section>

      <section title="The KeyInitializationDataType Type">
        <t>This extension is used for 2- and 1-pass DSKPP exchange; it carries
        an identifier for the selected key initialization method as well as
        key initialization method-dependent payload data.</t>

        <t>Servers MAY include this extension in a
        &lt;KeyProvServerFinished&gt; message that is being sent in response
        to a received &lt;KeyProvClientHello&gt; message if and only if that
        &lt;KeyProvClientHello&gt; message selected TwoPassSupport as the
        ProtocolVariantType and the client indicated support for the selected
        key initialization method. Servers MUST include this extension in a
        &lt;KeyProvServerFinished&gt; message that is sent as part of a 1-pass
        DSKPP.</t>

        <t>The elements of this type have the following meaning:</t>

        <t><list style="symbols">
            <t>&lt;KeyInitializationMethod&gt;: A two-pass key initialization
            method supported by the DSKPP client.</t>

            <t>&lt;Payload&gt;: A payload associated with the key
            initialization method. Since the syntax is a shorthand for
            &lt;xs:element name="Payload" type="xs:anyType"/&gt;, any
            well-formed payloads can be carried in this element.</t>
          </list></t>
      </section>
    </section>

    <section anchor="Section-Profiles"
             title="Key Initialization Profiles of Two- and One-Pass DSKPP">
      <section title="Introduction">
        <t>This appendix introduces three profiles of DSKPP for key
        initialization. They MAY all be used for two- as well as one-pass
        initialization of cryptographic modules. Further profiles MAY be
        defined by external entities or through the IETF process.</t>
      </section>

      <section title="Key Transport Profile">
        <section title="Introduction">
          <t>This profile initializes the cryptographic module with a
          symmetric key, K_TOKEN, through key transport and key derivation.
          The key transport is carried out using a public key, K_CLIENT, whose
          private key part resides in the cryptographic module as the
          transport key. A key K from which two keys, K_TOKEN and K_MAC are
          derived MUST be transported.</t>
        </section>

        <section title="Identification">
          <t>This profile MUST be identified with the following URN:</t>

          <t>urn:ietf:params:xml:schema:keyprov:protocol#transport</t>
        </section>

        <section title="Payloads">
          <t>In the two-pass version of DSKPP, the client MUST send a payload
          associated with this key initialization method. The payload MUST be
          of type ds:KeyInfoType (<xref target="XMLDSIG"></xref>), and only
          those choices of the ds:KeyInfoType that identify a public key are
          allowed. The ds:X509Certificate option of the ds:X509Data
          alternative is RECOMMENDED when the public key corresponding to the
          private key on the cryptographic module has been certified.</t>

          <t>The server payload associated with this key initialization method
          MUST be of type xenc:EncryptedKeyType (<xref
          target="XMLENC"></xref>), and only those encryption methods
          utilizing a public key that are supported by the DSKPP client (as
          indicated in the &lt;SupportedEncryptionAlgorithms&gt; element of
          the &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP,
          or as otherwise known in the case of 1-pass DSKPP) are allowed as
          values for the &lt;xenc:EncryptionMethod&gt; element. Further, in
          the case of 2-pass DSKPP, the &lt;ds:KeyInfo&gt; element MUST
          contain the same value (i.e. identify the same public key) as the
          &lt;Payload&gt; of the corresponding supported key initialization
          method in the &lt;KeyProvClientHello&gt; message that triggered the
          response. The &lt;CarriedKeyName&gt; element MAY be present, but
          MUST, when present, contain the same value as the &lt;KeyID&gt;
          element of the &lt;KeyProvServerFinished&gt; message. The Type
          attribute of the xenc:EncryptedKeyType MUST be present and MUST
          identify the type of the wrapped key. The type MUST be one of the
          types supported by the DSKPP client (as reported in the
          &lt;SupportedKeyTypes&gt; of the preceding
          &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP, or
          as otherwise known in the case of 1-pass DSKPP). The transported key
          MUST consist of two parts of equal length. The first half
          constitutes K_MAC and the second half constitutes K_TOKEN. The
          length of K_TOKEN (and hence also the length of K_MAC) is determined
          by the type of K_TOKEN.</t>

          <t>DSKPP servers and cryptographic modules supporting this profile
          MUST support the http://www.w3.org/2001/04/xmlenc#rsa-1_5
          key-wrapping mechanism defined in <xref target="XMLENC"></xref>.</t>

          <t>When this profile is used, the MacAlgorithm attribute of the
          &lt;Mac&gt; element of the &lt;KeyProvServerFinished&gt; message
          MUST be present and MUST identify the selected MAC algorithm. The
          selected MAC algorithm MUST be one of the MAC algorithms supported
          by the DSKPP client (as indicated in the
          &lt;SupportedMacAlgorithms&gt; element of the
          &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP, or
          as otherwise known in the case of 1-pass DSKPP). The MAC MUST be
          calculated as described in <xref target="Subsecton-TwoPass"></xref>
          for Two-Pass DSKPP and <xref target="Subsection-OnePass"></xref> for
          One-Pass DSKPP.</t>

          <t>In addition, DSKPP servers MUST include the
          AuthenticationDataType element in their
          &lt;KeyProvServerFinished&gt; messages whenever a successful
          protocol run will result in an existing K_TOKEN being replaced.</t>
        </section>
      </section>

      <section title="Key Wrap Profile">
        <section title="Introduction">
          <t>This profile initializes the cryptographic module with a
          symmetric key, K_TOKEN, through key wrap and key derivation. The key
          wrap MUST be carried out using a (symmetric) key-wrapping key,
          K_SHARED, known in advance by both the cryptographic module and the
          DSKPP server. A key K from which two keys, K_TOKEN and K_MAC are
          derived MUST be wrapped.</t>
        </section>

        <section title="Identification">
          <t>This profile MUST be identified with the following URI:</t>

          <t>urn:ietf:params:xml:schema:keyprov:protocol#wrap</t>
        </section>

        <section title="Payloads">
          <t>In the 2-pass version of DSKPP, the client MUST send a payload
          associated with this key initialization method. The payload MUST be
          of type ds:KeyInfoType (<xref target="XMLDSIG"></xref>), and only
          those choices of the ds:KeyInfoType that identify a symmetric key
          are allowed. The ds:KeyName alternative is RECOMMENDED.</t>

          <t>The server payload associated with this key initialization method
          MUST be of type xenc:EncryptedKeyType (<xref
          target="XMLENC"></xref>), and only those encryption methods
          utilizing a symmetric key that are supported by the DSKPP client (as
          indicated in the &lt;SupportedEncryptionAlgorithms&gt; element of
          the &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP,
          or as otherwise known in the case of 1-pass DSKPP) are allowed as
          values for the &lt;xenc:EncryptionMethod&gt; element. Further, in
          the case of 2-pass DSKPP, the &lt;ds:KeyInfo&gt; element MUST
          contain the same value (i.e. identify the same symmetric key) as the
          &lt;Payload&gt; of the corresponding supported key initialization
          method in the &lt;KeyProvClientHello&gt; message that triggered the
          response. The &lt;CarriedKeyName&gt; element MAY be present, and
          MUST, when present, contain the same value as the &lt;KeyID&gt;
          element of the &lt;KeyProvServerFinished&gt; message. The Type
          attribute of the xenc:EncryptedKeyType MUST be present and MUST
          identify the type of the wrapped key. The type MUST be one of the
          types supported by the DSKPP client (as reported in the
          &lt;SupportedKeyTypes&gt; of the preceding
          &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP, or
          as otherwise known in the case of 1-pass DSKPP). The wrapped key
          MUST consist of two parts of equal length. The first half
          constitutes K_MAC and the second half constitutes K_TOKEN. The
          length of K_TOKEN (and hence also the length of K_MAC) is determined
          by the type of K_TOKEN.</t>

          <t>DSKPP servers and cryptographic modules supporting this profile
          MUST support the http://www.w3.org/2001/04/xmlenc#kw-aes128
          key-wrapping mechanism defined in <xref target="XMLENC"></xref>.</t>

          <t>When this profile is used, the MacAlgorithm attribute of the
          &lt;Mac&gt; element of the &lt;KeyProvServerFinished&gt; message
          MUST be present and MUST identify the selected MAC algorithm. The
          selected MAC algorithm MUST be one of the MAC algorithms supported
          by the DSKPP client (as indicated in the
          &lt;SupportedMacAlgorithms&gt; element of the
          &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP, or
          as otherwise known in the case of 1-pass DSKPP). The MAC MUST be
          calculated as described in <xref
          target="Subsecton-TwoPass"></xref>.</t>

          <t>In addition, DSKPP servers MUST include the
          AuthenticationDataType element in their
          &lt;KeyProvServerFinished&gt; messages whenever a successful
          protocol run will result in an existing K_TOKEN being replaced.</t>
        </section>
      </section>

      <section title="Passphrase-Based Key Wrap Profile">
        <section title="Introduction">
          <t>This profile is a variation of the key wrap profile. It
          initializes the cryptographic module with a symmetric key, K_TOKEN,
          through key wrap and key derivation, using a passphrase-derived
          key-wrapping key, K_DERIVED. The passphrase is known in advance by
          both the device user and the DSKPP server. To preserve the property
          of not exposing K_TOKEN to any other entity than the DSKPP server
          and the cryptographic module itself, the method SHOULD be employed
          only when the device contains facilities (e.g. a keypad) for direct
          entry of the passphrase. A key K from which two keys, K_TOKEN and
          K_MAC are derived MUST be wrapped.</t>
        </section>

        <section title="Identification">
          <t>This profile MUST be identified with the following URI:</t>

          <t>urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap</t>
        </section>

        <section title="Payloads">
          <t>In the 2-pass version of DSKPP, the client MUST send a payload
          associated with this key initialization method. The payload MUST be
          of type ds:KeyInfoType (<xref target="XMLDSIG"></xref>). The
          ds:KeyName option MUST be used and the key name MUST identify the
          passphrase that will be used by the server to generate the
          key-wrapping key. As an example, the identifier could be a user
          identifier or a registration identifier issued by the server to the
          user during a session preceding the DSKPP protocol run.</t>

          <t>The server payload associated with this key initialization method
          MUST be of type xenc:EncryptedKeyType (<xref
          target="XMLENC"></xref>), and only those encryption methods
          utilizing a passphrase to derive the key-wrapping key that are
          supported by the DSKPP client (as indicated in the
          &lt;SupportedEncryptionAlgorithms&gt; element of the
          &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP, or
          as otherwise known in the case of 1-pass DSKPP) are allowed as
          values for the &lt;xenc:EncryptionMethod&gt; element. Further, in
          the case of 2-pass DSKPP, the &lt;ds:KeyInfo&gt; element MUST
          contain the same value (i.e. identify the same passphrase) as the
          &lt;Payload&gt; of the corresponding supported key initialization
          method in the &lt;KeyProvClientHello&gt; message that triggered the
          response. The &lt;CarriedKeyName&gt; element MAY be present, and
          MUST, when present, contain the same value as the &lt;KeyID&gt;
          element of the &lt;KeyProvServerFinished&gt; message. The Type
          attribute of the xenc:EncryptedKeyType MUST be present and MUST
          identify the type of the wrapped key. The type MUST be one of the
          types supported by the DSKPP client (as reported in the
          &lt;SupportedKeyTypes&gt; of the preceding
          &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP, or
          as otherwise known in the case of 1-pass DSKPP). The wrapped key
          MUST consist of two parts of equal length. The first half
          constitutes K_MAC and the second half constitutes K_TOKEN. The
          length of K_TOKEN (and hence also the length of K_MAC) is determined
          by the type of K_TOKEN.</t>

          <t>DSKPP servers and cryptographic modules supporting this profile
          MUST support the PBES2 password based encryption scheme defined in
          <xref target="PKCS-5"></xref> (and identified as
          http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2 in
          <xref target="PKCS-5-XML"></xref>), the PBKDF2 passphrase-based key
          derivation function also defined in <xref target="PKCS-5"></xref>
          (and identified as
          http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2 in
          <xref target="PKCS-5-XML"></xref>), and the
          http://www.w3.org/2001/04/xmlenc#kw-aes128 key-wrapping mechanism
          defined in <xref target="XMLENC"></xref>.</t>

          <t>When this profile is used, the MacAlgorithm attribute of the
          &lt;Mac&gt; element of the &lt;KeyProvServerFinished&gt; message
          MUST be present and MUST identify the selected MAC algorithm. The
          selected MAC algorithm MUST be one of the MAC algorithms supported
          by the DSKPP client (as indicated in the
          &lt;SupportedMacAlgorithms&gt; element of the
          &lt;KeyProvClientHello&gt; message in the case of 2-pass DSKPP, or
          as otherwise known in the case of 1-pass DSKPP). The MAC MUST be
          calculated as described in <xref
          target="Subsecton-TwoPass"></xref>.</t>

          <t>In addition, DSKPP servers MUST include the
          AuthenticationDataType element in their
          &lt;KeyProvServerFinished&gt; messages whenever a successful
          protocol run will result in an existing K_TOKEN being replaced.</t>
        </section>
      </section>
    </section>

    <section anchor="Section-Bindings" title="Protocol Bindings">
      <section title="General Requirements">
        <t>DSKPP assumes a reliable transport.</t>
      </section>

      <section title="HTTP/1.1 Binding for DSKPP">
        <section title="Introduction">
          <t>This section presents a binding of the previous messages to
          HTTP/1.1 <xref target="RFC2616"></xref>. Note that the HTTP client
          normally will be different from the DSKPP client, i.e., the HTTP
          client will only exist to "proxy" DSKPP messages from the DSKPP
          client to the DSKPP server. Likewise, on the HTTP server side, the
          DSKPP server MAY receive DSKPP PDUs from a "front-end" HTTP
          server.</t>
        </section>

        <section anchor="Subsection-ContentType"
                 title="Identification of DSKPP Messages">
          <t>The MIME-type for all DSKPP messages MUST be</t>

          <t>application/vnd.ietf.keyprov.dskpp+xml</t>
        </section>

        <section title="HTTP Headers">
          <t>HTTP proxies MUST NOT cache responses carrying DSKPP messages.
          For this reason, the following holds:<list style="symbols">
              <t>When using HTTP/1.1, requesters SHOULD:<list>
                  <t>Include a Cache-Control header field set to "no-cache,
                  no-store".</t>

                  <t>Include a Pragma header field set to "no-cache".</t>
                </list></t>

              <t>When using HTTP/1.1, responders SHOULD:<list>
                  <t>Include a Cache-Control header field set to "no-cache,
                  no-must-revalidate, private".</t>

                  <t>Include a Pragma header field set to "no-cache".</t>

                  <t>NOT include a Validator, such as a Last-Modified or ETag
                  header.</t>
                </list></t>
            </list>There are no other restrictions on HTTP headers, besides
          the requirement to set the Content-Type header value according to
          <xref target="Subsection-ContentType"></xref>.</t>
        </section>

        <section title="HTTP Operations">
          <t>Persistent connections as defined in HTTP/1.1 are assumed but not
          required. DSKPP requests are mapped to HTTP POST operations. DSKPP
          responses are mapped to HTTP responses.</t>
        </section>

        <section title="HTTP Status Codes">
          <t>A DSKPP HTTP responder that refuses to perform a message exchange
          with a DSKPP HTTP requester SHOULD return a 403 (Forbidden)
          response. In this case, the content of the HTTP body is not
          significant. In the case of an HTTP error while processing a DSKPP
          request, the HTTP server MUST return a 500 (Internal Server Error)
          response. This type of error SHOULD be returned for HTTP-related
          errors detected before control is passed to the DSKPP processor, or
          when the DSKPP processor reports an internal error (for example, the
          DSKPP XML namespace is incorrect, or the DSKPP schema cannot be
          located). If the type of a DSKPP request cannot be determined, the
          DSKPP responder MUST return a 400 (Bad request) response.</t>

          <t>In these cases (i.e., when the HTTP response code is 4xx or 5xx),
          the content of the HTTP body is not significant.</t>

          <t>Redirection status codes (3xx) apply as usual.</t>

          <t>Whenever the HTTP POST is successfully invoked, the DSKPP HTTP
          responder MUST use the 200 status code and provide a suitable DSKPP
          message (possibly with DSKPP error information included) in the HTTP
          body.</t>
        </section>

        <section title="HTTP Authentication">
          <t>No support for HTTP/1.1 authentication is assumed.</t>
        </section>

        <section anchor="Section-InitDSKPP" title="Initialization of DSKPP">
          <t>The DSKPP server MAY initialize the DSKPP protocol by sending an
          HTTP response with Content-Type set according to <xref
          target="Subsection-ContentType"></xref> and response code set to 200
          (OK). This message MAY, e.g., be sent in response to a user
          requesting key initialization in a browsing session. The
          initialization message MAY carry data in its body. If this is the
          case, the data MUST be a valid instance of a &lt;KeyProvTrigger&gt;
          element.</t>
        </section>

        <section title="Example Messages">
          <t hangText=""><list counter="Examples" hangIndent="0"
              style="format %c.">
              <t>Initialization from DSKPP server:</t>
            </list><list hangIndent="4" style="empty">
              <t hangText="">HTTP/1.1 200 OK<vspace
              blankLines="1" />Cache-Control: no-store<vspace
              blankLines="0" />Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<vspace
              blankLines="0" />Content-Length: &lt;some value&gt;<vspace
              blankLines="1" />DSKPP initialization data in XML form...</t>
            </list></t>

          <t><list counter="Examples" hangIndent="0" style="format %c.">
              <t>Initial request from DSKPP client:</t>
            </list><list hangIndent="4" style="empty">
              <t>POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1<vspace
              blankLines="0" />Cache-Control: no-store<vspace
              blankLines="0" />Pragma: no-cache<vspace blankLines="0" />Host:
              example.com<vspace blankLines="0" />Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<vspace
              blankLines="0" />Content-Length: &lt;some value&gt;<vspace
              blankLines="1" />DSKPP data in XML form (supported version,
              supported algorithms...)</t>
            </list></t>

          <t hangText=""><list counter="Examples" hangIndent="0"
              style="format %c.">
              <t>Initial response from DSKPP server:</t>
            </list><list hangIndent="4" style="empty">
              <t hangText="">HTTP/1.1 200 OK<vspace
              blankLines="1" />Cache-Control: no-store<vspace
              blankLines="0" />Content-Type:
              application/vnd.ietf.keyprov.dskpp+xml<vspace
              blankLines="0" />Content-Length: &lt;some value&gt;<vspace
              blankLines="1" />DSKPP data in XML form (server random nonce,
              server public key, ...)</t>
            </list></t>
        </section>
      </section>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-Schema" title="DSKPP Schema">
      <figure>
        <preamble></preamble>

        <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>

 <xs:schema
   xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
   xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
   targetNamespace="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
   elementFormDefault="unqualified" attributeFormDefault="unqualified" 
   version="1.0">

   <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
     schemaLocation="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/xmldsig-core-schema.xsd"/>

   <xs:import namespace="urn:ietf:params:xml:ns:keyprov:1.0:container"
     schemaLocation="keyprov-pskc-1.0.xsd"/>
         
   <!-- Basic types -->
   <xs:complexType name="AbstractRequestType" abstract="true">
     <xs:attribute name="Version" type="dskpp:VersionType" use="required"/>
   </xs:complexType>

   <xs:complexType name="AbstractResponseType" abstract="true">
     <xs:attribute name="Version" type="dskpp:VersionType" use="required"/>
     <xs:attribute name="SessionID" type="dskpp:IdentifierType"/>
     <xs:attribute name="Status" type="dskpp:StatusCode" use="required"/>
   </xs:complexType>

   <xs:simpleType name="VersionType">
     <xs:restriction base="xs:string">
       <xs:pattern value="\d{1,2}\.\d{1,3}"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:simpleType name="IdentifierType">
     <xs:restriction base="xs:string">
       <xs:maxLength value="128"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:simpleType name="StatusCode">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Continue"/>
       <xs:enumeration value="Success"/>
       <xs:enumeration value="Abort"/>
       <xs:enumeration value="AccessDenied"/>
       <xs:enumeration value="MalformedRequest"/>
       <xs:enumeration value="UnknownRequest"/>
       <xs:enumeration value="UnknownCriticalExtension"/>
       <xs:enumeration value="UnsupportedVersion"/>
       <xs:enumeration value="NoSupportedKeyTypes"/>
       <xs:enumeration value="NoSupportedEncryptionAlgorithms"/>
       <xs:enumeration value="NoSupportedMacAlgorithms"/>
       <xs:enumeration value="NoProtocolVariants"/>
       <xs:enumeration value="NoSupportedKeyContainers"/>
       <xs:enumeration value="AuthenticationDataMissing"/>
       <xs:enumeration value="AuthenticationDataInvalid"/>
       <xs:enumeration value="InitializationFailed"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="DeviceIdentifierDataType">
     <xs:choice>
       <xs:element name="DeviceId" type="pskc:DeviceIdType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

   <xs:simpleType name="PlatformType">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Hardware"/>
       <xs:enumeration value="Software"/>
       <xs:enumeration value="Unspecified"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="TokenPlatformInfoType">
     <xs:attribute name="KeyLocation" type="dskpp:PlatformType"/>
     <xs:attribute name="AlgorithmLocation" type="dskpp:PlatformType"/>
   </xs:complexType>

   <xs:simpleType name="NonceType">
     <xs:restriction base="xs:base64Binary">
       <xs:minLength value="16"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="AlgorithmsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Algorithm" type="dskpp:AlgorithmType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="AlgorithmType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

   <xs:complexType name="ProtocolVariantsType">
     <xs:sequence>
       <xs:element name="FourPass" minOccurs="0"/>
       <xs:element name="TwoPass" type="dskpp:TwoPassSupportType"
         minOccurs="0"/>
       <xs:element name="OnePass" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="TwoPassSupportType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="SupportedKeyInitializationMethod"
         type="xs:anyURI"/>
       <xs:element name="Payload" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="KeyContainersFormatType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="KeyContainerFormat"
         type="dskpp:KeyContainerFormatType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="KeyContainerFormatType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

   <xs:complexType name="AuthenticationDataType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Authentication data can consist of either authentication code 
         for authenticating a user of the protocol, or an X.509 Certificate for 
         authenticating a device. When a device certificate is used over a
         transport layer that is not secure, the Signature is calculated over 
         a nonce value specified in ds:Signature/Object. When used in 
         conjunction with the KeyProvServerFinished PDU, it contains a MAC 
         authenticating the DSKPP server to the client.
       </xs:documentation>
     </xs:annotation>       
     <xs:sequence>
       <xs:element name="ClientID" type="dskpp:IdentifierType"
                   minOccurs="0"/>
       <xs:choice minOccurs="0">
           <xs:element name="AuthenticationCodeMac"
                       type="dskpp:AuthenticationCodeMacType"/>
           <xs:element name="DigitalSignature"
                       type="ds:SignatureType"/>
       </xs:choice>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="AuthenticationCodeMacType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         An authentication MAC calculated from an authentication code and
         optionally server information as well as nonce value if they are
         available.
       </xs:documentation>
     </xs:annotation>       
     <xs:sequence>
       <xs:element name="Nonce" type="dskpp:NonceType" minOccurs="0"/>
       <xs:element name="IterationCount" type="xs:int" minOccurs="0"/>
       <xs:element name="Mac" type="dskpp:MacType"/>       
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="MacType">
     <xs:simpleContent>
       <xs:extension base="xs:base64Binary">
         <xs:attribute name="MacAlgorithm" type="xs:anyURI"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>

   <xs:complexType name="KeyContainerType">
     <xs:sequence>
       <xs:element name="ServerID" type="xs:anyURI" minOccurs="0"/>
       <xs:choice>
         <xs:element name="KeyContainer" type="pskc:KeyContainerType"/>
         <xs:any namespace="##other" processContents="strict"/>
       </xs:choice>
     </xs:sequence>
   </xs:complexType>
   
   <xs:complexType name="InitializationTriggerType">
     <xs:sequence>
       <xs:element name="DeviceIdentifierData"
         type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
       <xs:element name="KeyID" type="xs:base64Binary" minOccurs="0"/>
       <xs:element name="TokenPlatformInfo"
         type="dskpp:TokenPlatformInfoType" minOccurs="0"/>
       <xs:element name="TriggerNonce" type="dskpp:NonceType"/>
       <xs:element name="DSKPPServerUrl" type="xs:anyURI" minOccurs="0"/>
       <xs:any namespace="##other" processContents="strict"
         minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <!-- Extension types -->
   <xs:complexType name="ExtensionsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Extension" type="dskpp:AbstractExtensionType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="AbstractExtensionType" abstract="true">
     <xs:attribute name="Critical" type="xs:boolean"/>
   </xs:complexType>

   <xs:complexType name="ClientInfoType">
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="ServerInfoType">
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="PayloadType">
     <xs:choice>
       <xs:element name="Nonce" type="dskpp:NonceType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>
   
   <xs:complexType name="KeyInitializationDataType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         This extension is only valid in KeyProvServerFinished PDUs. It
         contains key initialization data and its presence results in a
         two-pass (or one-pass, if no KeyProvClientHello was sent) DSKPP
         exchange.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractExtensionType">
         <xs:sequence>
           <xs:element name="KeyInitializationMethod" type="xs:anyURI"/>
           <xs:element name="Payload" type="dskpp:PayloadType"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- DSKPP PDUs -->

   <xs:element name="KeyProvTrigger" type="dskpp:KeyProvTriggerType"/>

   <xs:complexType name="KeyProvTriggerType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message used to trigger the device to initiate a
         DSKPP protocol run.
       </xs:documentation>
     </xs:annotation>
     <xs:sequence>
       <xs:choice>
         <xs:element name="InitializationTrigger"
           type="dskpp:InitializationTriggerType"/>
         <xs:any namespace="##other" processContents="strict"/>
       </xs:choice>
     </xs:sequence>
     <xs:attribute name="Version" type="dskpp:VersionType"/>
   </xs:complexType>

   <!-- KeyProvClientHello PDU -->
   <xs:element name="KeyProvClientHello" type="dskpp:KeyProvClientHelloPDU"/>

   <xs:complexType name="KeyProvClientHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP client to DSKPP server to initiate a
         DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractRequestType">
         <xs:sequence>
           <xs:element name="DeviceIdentifierData"
             type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
           <xs:element name="KeyID" type="xs:base64Binary"
             minOccurs="0"/>
           <xs:element name="ClientNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="TriggerNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="SupportedKeyTypes"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedEncryptionAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedMacAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedProtocolVariants"
             type="dskpp:ProtocolVariantsType" minOccurs="0"/>
           <xs:element name="SupportedKeyContainers"
             type="dskpp:KeyContainersFormatType" minOccurs="0"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions" type="dskpp:ExtensionsType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- KeyProvServerHello PDU -->
   <xs:element name="KeyProvServerHello" type="dskpp:KeyProvServerHelloPDU"/>

   <xs:complexType name="KeyProvServerHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP server to DSKPP client
         in response to a received KeyProvClientHello PDU.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyType"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="MacAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionKey"
             type="ds:KeyInfoType"/>
           <xs:element name="KeyContainerFormat"
             type="dskpp:KeyContainerFormatType"/>
           <xs:element name="Payload"
             type="dskpp:PayloadType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac" type="dskpp:MacType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- KeyProvClientNonce PDU -->
   <xs:element name="KeyProvClientNonce" type="dskpp:KeyProvClientNoncePDU"/>

   <xs:complexType name="KeyProvClientNoncePDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Second message sent from DSKPP client to
         DSKPP server in a DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractRequestType">
         <xs:sequence>
           <xs:element name="EncryptedNonce"
             type="xs:base64Binary"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="SessionID" type="dskpp:IdentifierType"
           use="required"/>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- KeyProvServerFinished PDU -->
   <xs:element name="KeyProvServerFinished" type="dskpp:KeyProvServerFinishedPDU"/>

   <xs:complexType name="KeyProvServerFinishedPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Final message sent from DSKPP server to DSKPP client in a DSKPP 
         session. A MAC value serves for key confirmation, and optional
         AuthenticationData servers for server authentication.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyContainer"
             type="dskpp:KeyContainerType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac"
             type="dskpp:MacType"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>             
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

 </xs:schema>
]]></artwork>

        <postamble></postamble>
      </figure>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-Security" title="Security Considerations">
      <section title="General">
        <t>DSKPP is designed to protect generated key material from exposure.
        No other entities than the DSKPP server and the cryptographic module
        will have access to a generated K_TOKEN if the cryptographic
        algorithms used are of sufficient strength and, on the DSKPP client
        side, generation and encryption of R_C and generation of K_TOKEN take
        place as specified in the cryptographic module. This applies even if
        malicious software is present in the DSKPP client. However, as
        discussed in the following, DSKPP does not protect against certain
        other threats resulting from man-in-the-middle attacks and other forms
        of attacks. DSKPP SHOULD, therefore, be run over a transport providing
        privacy and integrity, such as HTTP over Transport Layer Security
        (TLS) with a suitable ciphersuite, when such threats are a concern.
        Note that TLS ciphersuites with anonymous key exchanges are not
        suitable in those situations.</t>
      </section>

      <section title="Active Attacks">
        <section title="Introduction">
          <t>An active attacker MAY attempt to modify, delete, insert, replay,
          or reorder messages for a variety of purposes including service
          denial and compromise of generated key material. <xref
          target="Subsection-Messages"></xref> through <xref
          target="Subsection-MITM"></xref>.</t>
        </section>

        <section anchor="Subsection-Messages" title="Message Modifications">
          <t>Modifications to a &lt;DSKPPTrigger&gt; message will either cause
          denial-of-service (modifications of any of the identifiers or the
          nonce) or will cause the DSKPP client to contact the wrong DSKPP
          server. The latter is in effect a man-in-the-middle attack and is
          discussed further in <xref target="Subsection-MITM"></xref>.</t>

          <t>An attacker may modify a &lt;KeyProvClientHello&gt; message. This
          means that the attacker could indicate a different key or device
          than the one intended by the DSKPP client, and could also suggest
          other cryptographic algorithms than the ones preferred by the DSKPP
          client, e.g., cryptographically weaker ones. The attacker could also
          suggest earlier versions of the DSKPP protocol, in case these
          versions have been shown to have vulnerabilities. These
          modifications could lead to an attacker succeeding in initializing
          or modifying another cryptographic module than the one intended
          (i.e., the server assigning the generated key to the wrong module),
          or gaining access to a generated key through the use of weak
          cryptographic algorithms or protocol versions. DSKPP implementations
          MAY protect against the latter by having strict policies about what
          versions and algorithms they support and accept. The former threat
          (assignment of a generated key to the wrong module) is not possible
          when the shared-key variant of DSKPP is employed (assuming existing
          shared keys are unique per cryptographic module), but is possible in
          the public-key variant. Therefore, DSKPP servers MUST NOT accept
          unilaterally provided device identifiers in the public-key variant.
          This is also indicated in the protocol description. In the
          shared-key variant, however, an attacker may be able to provide the
          wrong identifier (possibly also leading to the incorrect user being
          associated with the generated key) if the attacker has real-time
          access to the cryptographic module with the identified key. In other
          words, the generated key is associated with the correct
          cryptographic module but the module is associated with the incorrect
          user. See further <xref target="Subsection-Interactions"></xref> for
          a discussion of this threat and possible countermeasures.</t>

          <t>An attacker may also modify a &lt;KeyProvServerHello&gt; message.
          This means that the attacker could indicate different key types,
          algorithms, or protocol versions than the legitimate server would,
          e.g., cryptographically weaker ones. The attacker may also provide a
          different nonce than the one sent by the legitimate server. Clients
          MAY protect against the former through strict adherence to policies
          regarding permissible algorithms and protocol versions. The latter
          (wrong nonce) will not constitute a security problem, as a generated
          key will not match the key generated on the legitimate server. Also,
          whenever the DSKPP run would result in the replacement of an
          existing key, the &lt;Mac&gt; element protects against modifications
          of R_S.</t>

          <t>Modifications of &lt;KeyProvClientNonce&gt; messages are also
          possible. If an attacker modifies the SessionID attribute, then, in
          effect, a switch to another session will occur at the server,
          assuming the new SessionID is valid at that time on the server. It
          still will not allow the attacker to learn a generated K_TOKEN since
          R_C has been wrapped for the legitimate server. Modifications of the
          &lt;EncryptedNonce&gt; element, e.g., replacing it with a value for
          which the attacker knows an underlying R'C, will not result in the
          client changing its pre-DSKPP state, since the server will be unable
          to provide a valid MAC in its final message to the client. The
          server MAY, however, end up storing K'TOKEN rather than K_TOKEN. If
          the cryptographic module has been associated with a particular user,
          then this could constitute a security problem. For a further
          discussion about this threat, and a possible countermeasure, see
          <xref target="Subsection-Interactions"></xref> below. Note that use
          of Secure Socket Layer (SSL) or TLS does not protect against this
          attack if the attacker has access to the DSKPP client (e.g., through
          malicious software, "trojans").</t>

          <t>Finally, attackers may also modify the
          &lt;KeyProvServerFinished&gt; message. Replacing the &lt;Mac&gt;
          element will only result in denial-of-service. Replacement of any
          other element may cause the DSKPP client to associate, e.g., the
          wrong service with the generated key. DSKPP SHOULD be run over a
          transport providing privacy and integrity when this is a
          concern.</t>
        </section>

        <section title="Message Deletion">
          <t>Message deletion will not cause any other harm than
          denial-of-service, since a cryptographic module MUST NOT change its
          state (i.e., "commit" to a generated key) until it receives the
          final message from the DSKPP server and successfully has processed
          that message, including validation of its MAC. A deleted
          &lt;KeyProvServerFinished&gt; message will not cause the server to
          end up in an inconsistent state vis-a-vis the cryptographic module
          if the server implements the suggestions in <xref
          target="Subsection-Interactions"></xref>.</t>
        </section>

        <section title="Message Insertion">
          <t>An active attacker may initiate a DSKPP run at any time, and
          suggest any device identifier. DSKPP server implementations MAY
          receive some protection against inadvertently initializing a key or
          inadvertently replacing an existing key or assigning a key to a
          cryptographic module by initializing the DSKPP run by use of the
          &lt;KeyProvTrigger&gt;. The &lt;TriggerNonce&gt; element allows the
          server to associate a DSKPP protocol run with, e.g., an earlier
          user-authenticated session. The security of this method, therefore,
          depends on the ability to protect the &lt;TriggerNonce&gt; element
          in the DSKPP initialization message. If an eavesdropper is able to
          capture this message, he may race the legitimate user for a key
          initialization. DSKPP over a transport providing privacy and
          integrity, coupled with the recommendations in <xref
          target="Subsection-Interactions"></xref>, is RECOMMENDED when this
          is a concern.</t>

          <t>Insertion of other messages into an existing protocol run is seen
          as equivalent to modification of legitimately sent messages.</t>
        </section>

        <section title="Message Replay">
          <t>During 4-pass DSKPP, attempts to replay a previously recorded
          DSKPP message will be detected, as the use of nonces ensures that
          both parties are live. For example, a DSKPP client knows that a
          server it is communicating with is "live" since the server MUST
          create a MAC on information sent by the client.</t>

          <t>The same is true for 2-pass DSKPP thanks to the requirement that
          the client sends R in the &lt;KeyProvClientHello&gt; message and
          that the server includes R in the MAC computation.</t>

          <t>In 1-pass DSKPP clients that record the latest I used by a
          particular server (as identified by ID_S) will be able to detect
          replays.</t>
        </section>

        <section title="Message Reordering">
          <t>An attacker may attempt to re-order 4-pass DSKPP messages but
          this will be detected, as each message is of a unique type. Note:
          Message re-ordering attacks cannot occur in 2- and 1-pass DSKPP
          since each party sends at most one message each.</t>
        </section>

        <section anchor="Subsection-MITM" title="Man-in-the-Middle">
          <t>In addition to other active attacks, an attacker posing as a man
          in the middle may be able to provide his own public key to the DSKPP
          client. This threat and countermeasures to it are discussed in <xref
          target="Subsection-FourPassUsage"></xref>. An attacker posing as a
          man-in-the-middle may also be acting as a proxy and, hence, may not
          interfere with DSKPP runs but still learn valuable information; see
          <xref target="Subsection-Passive"></xref>.</t>
        </section>
      </section>

      <section anchor="Subsection-Passive" title="Passive Attacks">
        <t>Passive attackers may eavesdrop on DSKPP runs to learn information
        that later on may be used to impersonate users, mount active attacks,
        etc.</t>

        <t>If DSKPP is not run over a transport providing privacy, a passive
        attacker may learn:<list hangIndent="0" style="symbols">
            <t>What cryptographic modules a particular user is in possession
            of;</t>

            <t>The identifiers of keys on those cryptographic modules and
            other attributes pertaining to those keys, e.g., the lifetime of
            the keys; and</t>

            <t>DSKPP versions and cryptographic algorithms supported by a
            particular DSKPP client or server.</t>
          </list>Whenever the above is a concern, DSKPP SHOULD be run over a
        transport providing privacy. If man-in-the-middle attacks for the
        purposes described above are a concern, the transport SHOULD also
        offer server-side authentication.</t>
      </section>

      <section title="Cryptographic Attacks">
        <t>An attacker with unlimited access to an initialized cryptographic
        module may use the module as an "oracle" to pre-compute values that
        later on may be used to impersonate the DSKPP server. <xref
        target="Subsection-Enc"></xref> and <xref
        target="Section-Protocol"></xref> contain discussions of this threat
        and steps RECOMMENDED to protect against it.</t>
      </section>

      <section anchor="Subsection-Interactions"
               title="Attacks on the Interaction between DSKPP and User Authentication">
        <t>If keys generated in DSKPP will be associated with a particular
        user at the DSKPP server (or a server trusted by, and communicating
        with the DSKPP server), then in order to protect against threats where
        an attacker replaces a client-provided encrypted R_C with his own R'C
        (regardless of whether the public-key variant or the shared-secret
        variant of DSKPP is employed to encrypt the client nonce), the server
        SHOULD not commit to associate a generated K_TOKEN with the given
        cryptographic module until the user simultaneously has proven both
        possession of the device that hosts the cryptographic module
        containing K_TOKEN and some out-of-band provided authenticating
        information (e.g., a temporary password). For example, if the
        cryptographic module is a one-time password token, the user could be
        required to authenticate with both a one-time password generated by
        the cryptographic module and an out-of-band provided temporary PIN in
        order to have the server "commit" to the generated OTP value for the
        given user. Preferably, the user SHOULD perform this operation from
        another host than the one used to initialize keys on the cryptographic
        module, in order to minimize the risk of malicious software on the
        client interfering with the process.</t>

        <t>Note: This scenario, wherein the attacker replaces a
        client-provided R_C with his own R'C, does not apply to 2- and 1-pass
        DSKPP as the client does not provide any entropy to K_TOKEN. The
        attack as such (and its countermeasures) still applies to 2- and
        1-pass DSKPP, however, as it essentially is a man-in-the-middle
        attack.</t>

        <t>Another threat arises when an attacker is able to trick a user to
        authenticate to the attacker rather than to the legitimate service
        before the DSKPP protocol run. If successful, the attacker will then
        be able to impersonate the user towards the legitimate service, and
        subsequently receive a valid DSKPP trigger. If the public-key variant
        of DSKPP is used, this may result in the attacker being able to (after
        a successful DSKPP protocol run) impersonate the user. Ordinary
        precautions MUST, therefore, be in place to ensure that users
        authenticate only to legitimate services.</t>
      </section>

      <section title="Additional Considerations Specific to 2- and 1-pass DSKPP">
        <section title="Client Contributions to K_TOKEN Entropy">
          <t>In 4-pass DSKPP, both the client and the server provide
          randomizing material to K_TOKEN , in a manner that allows both
          parties to verify that they did contribute to the resulting key. In
          the 1- and 2-pass DSKPP versions defined herein, only the server
          contributes to the entropy of K_TOKEN. This means that a broken or
          compromised (pseudo-)random number generator in the server may cause
          more damage than it would in the 4-pass variant. Server
          implementations SHOULD therefore take extreme care to ensure that
          this situation does not occur.</t>
        </section>

        <section title="Key Confirmation">
          <t>4-pass DSKPP servers provide key confirmation through the MAC on
          R_C in the &lt;KeyProvServerFinished&gt; message. In the 1- and
          2-pass DSKPP variants described herein, key confirmation is provided
          by the MAC including I (in the 1-pass case) or R (2-pass case),
          using K_MAC.</t>
        </section>

        <section anchor="Subsection-ServerAuth" title="Server Authentication">
          <t>DSKPP servers MUST authenticate themselves whenever a successful
          DSKPP 1- or 2-pass protocol run would result in an existing K_TOKEN
          being replaced by a K_TOKEN', or else a denial-of-service attack
          where an unauthorized DSKPP server replaces a K_TOKEN with another
          key would be possible. In 1- and 2-pass DSKPP, servers authenticate
          by including the AuthenticationDataType extension containing a MAC
          as described in <xref target="Subsecton-TwoPass"></xref> for
          Two-Pass DSKPP and <xref target="Subsection-OnePass"></xref> for
          One-Pass DSKPP.</t>
        </section>

        <section title="Client Authentication">
          <t>A DSKPP server MUST authenticate a client to ensure that K_TOKEN
          is delivered to the intended device. The following measures SHOULD
          be considered:<list style="symbols">
              <t>When a device certificate is used for client authentication,
              the DSKPP server SHOULD follow standard certificate verification
              processes to ensure that it is a trusted device.</t>

              <t>When an Authentication Code is used for client
              authentication, a password dictionary attack on the
              authentication data is possible.</t>

              <t>The length of the Authentication Code when used over a
              non-secure channel SHOULD be longer than what is used over a
              secure channel. When a device, e.g., some mobile phones with
              small screens, cannot handle a long Authentication Code in a
              user-friendly manner, DSKPP SHOULD rely on a secure channel for
              communication.</t>

              <t>In the case that a non-secure channel has to be used, the
              Authentication Code SHOULD be sent to the server MAC's as
              specified in <xref target="Section-ClientAuthN"></xref>. The
              Authentication Code and nonce value MUST be strong enough to
              prevent offline brute-force recovery of the Authentication Code
              from the HMAC data. Given that the nonce value is sent in
              plaintext format over a non-secure transport, the cryptographic
              strength of the AuthenticationData depends more on the quality
              of the AuthenticationCode.</t>

              <t>When the AuthenticationCode is sent from the DSKPP server to
              the device in a DSKPP initialization trigger message, an
              eavesdropper may be able to capture this message and race the
              legitimate user for a key initialization. To prevent this, the
              transport layer used to send the DSKPP trigger MUST provide
              privacy and integrity e.g. secure browser session.</t>
            </list></t>
        </section>

        <section title="Key Protection in the Passphrase Profile">
          <t>The passphrase-based key wrap profile uses the PBKDF2 function
          from <xref target="PKCS-5"></xref> to generate an encryption key
          from a passphrase and salt string. The derived key, K_DERIVED is
          used by the server to encrypt K_TOKEN and by the cryptographic
          module to decrypt the newly delivered K_TOKEN. It is important to
          note that passphrase-based encryption is generally limited in the
          security that it provides despite the use of salt and iteration
          count in PBKDF2 to increase the complexity of attack.
          Implementations SHOULD therefore take additional measures to
          strengthen the security of the passphrase-based key wrap profile.
          The following measures SHOULD be considered where applicable:</t>

          <t><list style="symbols">
              <t>The passphrase SHOULD be selected well, and usage guidelines
              such as the ones in <xref target="NIST-PWD"></xref> SHOULD be
              taken into account.</t>

              <t>A different passphrase SHOULD be used for every key
              initialization wherever possible (the use of a global passphrase
              for a batch of cryptographic modules SHOULD be avoided, for
              example). One way to achieve this is to use randomly-generated
              passphrases.</t>

              <t>The passphrase SHOULD be protected well if stored on the
              server and/or on the cryptographic module and SHOULD be
              delivered to the device's user using secure methods.</t>

              <t>User pre-authentication SHOULD be implemented to ensure that
              K_TOKEN is not delivered to a rogue recipient.</t>

              <t>The iteration count in PBKDF2 SHOULD be high to impose more
              work for an attacker using brute-force methods (see <xref
              target="PKCS-5"></xref> for recommendations). However, it MUST
              be noted that the higher the count, the more work is required on
              the legitimate cryptographic module to decrypt the newly
              delivered K_TOKEN. Servers MAY use relatively low iteration
              counts to accommodate devices with limited processing power such
              as some PDA and cell phones when other security measures are
              implemented and the security of the passphrase-based key wrap
              method is not weakened.</t>

              <t>Transport level security (e.g. TLS) SHOULD be used where
              possible to protect a 2-pass or 1-pass protocol run. Transport
              level security provides a second layer of protection for the
              newly generated K_TOKEN.</t>
            </list></t>
        </section>
      </section>
    </section>

    <section title="Internationalization Considerations">
      <t>The DSKPP protocol is mostly meant for machine-to-machine
      communications; as such, most of its elements are tokens not meant for
      direct human consumption. If these tokens are presented to the end user,
      some localization may need to occur. DSKPP exchanges information using
      XML. All XML processors are required to understand UTF-8 and UTF-16
      encoding, and therefore all DSKPP clients and servers MUST understand
      UTF-8 and UTF-16 encoded XML. Additionally, DSKPP servers and clients
      MUST NOT encode XML with encodings other than UTF-8 or UTF-16.</t>
    </section>

    <section title="IANA Considerations">
      <t>This document calls for registration of new URNs within the IETF
      sub-namespace per RFC3553 <xref target="RFC3553"></xref>. The following
      URNs are RECOMMENDED:<list style="symbols">
          <t>DSKPP XML schema:
          "urn:ietf:params:xml:schema:keyprov:protocol"</t>

          <t>DSKPP XML namespace:
          "urn:ietf:params:xml:ns:keyprov:protocol"</t>
        </list></t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="Section-IPR" title="Intellectual Property Considerations">
      <t>RSA and RSA Security are registered trademarks or trademarks of RSA
      Security Inc. in the United States and/or other countries. The names of
      other products and services mentioned may be the trademarks of their
      respective owners.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Contributors">
      <t>This work is based on information contained in <xref
      target="RFC4758"></xref>, authored by Magnus Nystrom, with enhancements
      (esp. Client Authentication, and support for multiple key container
      formats) from an individual Internet-Draft co-authored by Mingliang Pei
      and Salah Machani.</t>

      <t>We would like to thank Shuh Chang for contributing the DSKPP object
      model, and Philip Hoyer for his work in aligning DSKPP and PSKC
      schemas.</t>

      <t>We would also like to thank Hannes Tschofenig for his draft reviews,
      feedback, and text contributions.</t>
    </section>

    <section anchor="Section-Acknowledgements" title="Acknowledgements">
      <t>We would like to thank the following for detailed review of previous
      DSKPP document versions:<vspace blankLines="1" /><list style="symbols">
          <t>Dr. Ulrike Meyer (Review June 2007)<vspace blankLines="1" /></t>

          <t>Niklas Neumann (Review June 2007)<vspace blankLines="1" /></t>

          <t>Shuh Chang (Review June 2007)<vspace blankLines="1" /></t>

          <t>Hannes Tschofenig (Review June 2007 and again in August
          2007)<vspace blankLines="1" /></t>

          <t>Sean Turner (Review August 2007)<vspace blankLines="1" /></t>

          <t>John Linn (Review August 2007)<vspace blankLines="1" /></t>

          <t>Philip Hoyer (Review September 2007)</t>
        </list></t>

      <t>We would also like to thank the following for their input to selected
      design aspects of the DSKPP protocol:<vspace blankLines="1" /><list
          style="symbols">
          <t>Anders Rundgren (Key Container Format and Client Authentication
          Data)<vspace blankLines="1" /></t>

          <t>Hannes Tschofenig (HTTP Binding)<vspace blankLines="1" /></t>

          <t>Phillip Hallam-Baker (Registry for Algorithms)</t>
        </list></t>

      <t>Finally, we would like to thank Robert Griffin for opening
      communication channels for us with the IEEE P1619.3 Key Management
      Group, and facilitating our groups in staying informed of potential
      areas (esp. key provisioning and global key identifiers of
      collaboration) of collaboration.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->
  </middle>

  <back>
    <references title="Normative references">
      <reference anchor="UNICODE"
                 target="http://www.unicode.org/unicode/reports/tr15/tr15-21.html">
        <front>
          <title>Unicode Normalization Forms</title>

          <author initials="M." surname="Davis">
            <organization>UNICODE Consortium</organization>
          </author>

          <author initials="M." surname="Duerst">
            <organization>UNICODE Consortium</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="March" year="2001" />
        </front>
      </reference>

      <reference anchor="XMLENC"
                 target="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">
        <front>
          <title>XML Encryption Syntax and Processing</title>

          <author>
            <organization>W3C</organization>
          </author>

          <date month="December" year="2002" />
        </front>

        <seriesInfo name="W3C" value="Recommendation" />
      </reference>

      <reference anchor="XMLDSIG"
                 target="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/">
        <front>
          <title>XML Signature Syntax and Processing</title>

          <author>
            <organization>W3C</organization>
          </author>

          <date month="February" year="2002" />
        </front>

        <seriesInfo name="W3C" value="Recommendation" />
      </reference>
    </references>

    <references title="Informative references">
      <reference anchor="CT-KIP-P11"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>PKCS #11 Mechanisms for the Cryptographic Token Key
          Initialization Protocol</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="December" year="2005" />
        </front>

        <seriesInfo name="PKCS" value="#11 Version 2.20 Amd.2" />
      </reference>

      <reference anchor="FAQ">
        <front>
          <title>Frequently Asked Questions About Today's Cryptography</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="" year="2000" />
        </front>

        <seriesInfo name="" value="Version 4.1" />
      </reference>

      <reference anchor="FIPS180-SHA"
                 target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf">
        <front>
          <title>Secure Hash Standard</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="February" year="2004" />
        </front>

        <seriesInfo name="FIPS" value="180-2" />
      </reference>

      <reference anchor="FIPS197-AES"
                 target="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">
        <front>
          <title>Specification for the Advanced Encryption Standard
          (AES)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="November" year="2001" />
        </front>

        <seriesInfo name="FIPS" value="197" />
      </reference>

      <reference anchor="FSE2003"
                 target="http://crypt.cis.ibaraki.ac.jp/omac/docs/omac.pdf">
        <front>
          <title>OMAC: One-Key CBC MAC. In Fast Software Encryption</title>

          <author initials="T." surname="Iwata">
            <organization></organization>
          </author>

          <author initials="K." surname="Kurosawa">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date year="2003" />
        </front>

        <seriesInfo name="FSE" value="2003" />

        <seriesInfo name="Springer-Verlag" value="" />
      </reference>

      <reference anchor="NIST-PWD"
                 target="http://www.itl.nist.gov/fipspubs/fip112.htm">
        <front>
          <title>Password Usage</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="May" year="1985" />
        </front>

        <seriesInfo name="FIPS" value="112" />
      </reference>

      <reference anchor="OATH" target="http://www.openauthentication.org">
        <front>
          <title>Initiative for Open AuTHentication</title>

          <author>
            <organization></organization>
          </author>

          <date year="2005" />
        </front>
      </reference>

      <reference anchor="PSKC"
                 target="http://www.ietf.org/internet-drafts/draft-hoyer-keyprov-portable-symmetric-key-container-00.txt">
        <front>
          <title>Portable Symmetric Key Container</title>

          <author fullname="">
            <organization></organization>
          </author>

          <date year="2005" />
        </front>
      </reference>

      <reference anchor="PKCS-1"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>RSA Cryptography Standard</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="June" year="2002" />
        </front>

        <seriesInfo name="PKCS" value="#1 Version 2.1" />
      </reference>

      <reference anchor="PKCS-5"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>Password-Based Cryptography Standard</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="March" year="1999" />
        </front>

        <seriesInfo name="PKCS" value="#5 Version 2.0" />
      </reference>

      <reference anchor="PKCS-5-XML"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>XML Schema for PKCS #5 Version 2.0</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="October" year="2006" />
        </front>

        <seriesInfo name="PKCS" value="#5 Version 2.0 Amd.1 (FINAL DRAFT)" />
      </reference>

      <reference anchor="PKCS-11"
                 target="http://www.rsasecurity.com/rsalabs/pkcs/">
        <front>
          <title>Cryptographic Token Interface Standard</title>

          <author>
            <organization>RSA Laboratories</organization>
          </author>

          <date month="June" year="2004" />
        </front>

        <seriesInfo name="PKCS" value="#11 Version 2.20" />
      </reference>

      <reference anchor="PKCS-12"
                 target="ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12v1.pdf">
        <front>
          <title>Personal Information Exchange Syntax Standard</title>

          <author fullname="">
            <organization></organization>
          </author>

          <date year="2005" />
        </front>

        <seriesInfo name="PKCS" value="#12 Version 1.0" />
      </reference>

      <reference anchor="RFC2104">
        <front>
          <title>HMAC: Keyed-Hashing for Message Authentication</title>

          <author initials="H." surname="Krawzcyk">
            <organization></organization>
          </author>

          <author initials="M." surname="Bellare">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="R." surname="Canetti">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="February" year="1997" />
        </front>

        <seriesInfo name="RFC" value="2104" />
      </reference>

      <reference anchor="RFC2119" target="http://www.ietf.org/rfc/rfc2119.txt">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement
          Levels</title>

          <author fullname="">
            <organization></organization>
          </author>

          <date month="March" year="1997" />
        </front>

        <seriesInfo name="BCP" value="14" />

        <seriesInfo name="RFC" value="2119" />
      </reference>

      <reference anchor="RFC2616" target="http://www.ietf.org/rfc/rfc2616.txt">
        <front>
          <title>Hypertext Transfer Protocol -- HTTP/1.1</title>

          <author initials="R." surname="Fielding">
            <organization></organization>
          </author>

          <author initials="J." surname="Gettys">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="J." surname="Mogul">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="H." surname="Frystyk">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="L." surname="Masinter">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="P." surname="Leach">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="T." surname="Berners-Lee">
            <organization></organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="June" year="1999" />
        </front>

        <seriesInfo name="RFC" value="2616" />
      </reference>

      <reference anchor="RFC3280">
        <front>
          <title>Internet X.509 Public Key Infrastructure Certificate and
          Certificate Revocation List (CRL) Profile</title>

          <author initials="R." surname="Housley">
            <organization>VeriSign</organization>
          </author>

          <author initials="W." surname="Polk">
            <organization>Adobe Systems</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="W." surname="Ford">
            <organization>Qualcomm</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="D." surname="Solo">
            <organization>Nine by Nine</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="April" year="2002" />
        </front>

        <seriesInfo name="RFC" value="3280" />
      </reference>

      <reference anchor="RFC3553">
        <front>
          <title>An IETF URN Sub-namespace for Registered Protocol
          Parameters</title>

          <author initials="M." surname="Mealling">
            <organization>VeriSign</organization>
          </author>

          <author initials="L." surname="Masinter">
            <organization>Adobe Systems</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="T." surname="Hardie">
            <organization>Qualcomm</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <author initials="G." surname="Klyne">
            <organization>Nine by Nine</organization>

            <address>
              <postal>
                <street></street>

                <city></city>

                <region></region>

                <code></code>

                <country></country>
              </postal>

              <phone></phone>

              <facsimile></facsimile>

              <email></email>

              <uri></uri>
            </address>
          </author>

          <date month="June" year="2003" />
        </front>

        <seriesInfo name="RFC" value="3553" />

        <seriesInfo name="BCP" value="73" />
      </reference>

      <reference anchor="RFC4758" target="http://www.ietf.org/rfc/rfc4758.txt">
        <front>
          <title>Cryptographic Token Key Initialization Protocol
          (CT-KIP)</title>

          <author fullname="Magnus Nystrom">
            <organization>RSA, The Security Division of EMC</organization>
          </author>

          <date month="November" year="2006" />
        </front>
      </reference>
    </references>

    <section anchor="Section-Integration" title="Integration with PKCS #11">
      <t>A DSKPP client that needs to communicate with a connected
      cryptographic module to perform a DSKPP exchange MAY use PKCS #11 <xref
      target="PKCS-11"></xref>as a programming interface.</t>

      <section title="The 4-pass Variant">
        <t>When performing 4-pass DSKPP with a cryptographic module using the
        PKCS #11 programming interface, the procedure described in <xref
        target="CT-KIP-P11"></xref>, Appendix B, is RECOMMENDED.</t>
      </section>

      <section title="The 2-pass Variant">
        <t>A suggested procedure to perform 2-pass DSKPP with a cryptographic
        module through the PKCS #11 interface using the mechanisms defined in
        <xref target="CT-KIP-P11"></xref> is as follows:</t>

        <t><list counter="2-pass" style="format %c.">
            <t>On the client side, <list counter="1st" style="format %d.">
                <t>The client selects a suitable slot and token (e.g. through
                use of the &lt;DeviceIdentifier&gt; or the
                &lt;PlatformInfo&gt; element of the DSKPP trigger
                message).</t>

                <t>A nonce R is generated, e.g. by calling C_SeedRandom and
                C_GenerateRandom.</t>

                <t>The client sends its first message to the server, including
                the nonce R.</t>
              </list></t>

            <t>On the server side, <list counter="2nd" style="format %d.">
                <t>A generic key K = K_TOKEN | K _MAC (where '|' denotes
                concatenation) is generated, e.g. by calling C_GenerateKey
                (using key type CKK_GENERIC_SECRET). The template for K MUST
                allow it to be exported (but only in wrapped form, i.e.
                CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
                also be set to CK_TRUE), and also to be used for further key
                derivation. From K, a token key K_TOKEN of suitable type is
                derived by calling C_DeriveKey using the PKCS #11 mechanism
                CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
                the first bit of the generic secret key (i.e. set to 0).
                Likewise, a MAC key K_MAC is derived from K by calling
                C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism, this
                time setting CK_EXTRACT_PARAMS to the length of K (in bits)
                divided by two.</t>

                <t>The server wraps K with either the token's public key
                K_CLIENT, the shared secret key K_SHARED, or the derived
                shared secret key K_DERIVED by using C_WrapKey. If use of the
                DSKPP key wrap algorithm has been negotiated then the
                CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
                C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure MUST
                be set to NULL_PTR. The pSeed parameter in the CK_KIP_PARAMS
                structure MUST point to the nonce R provided by the DSKPP
                client, and the ulSeedLen parameter MUST indicate the length
                of R. The hWrappingKey parameter in the call to C_WrapKey MUST
                be set to refer to the wrapping key.</t>

                <t>Next, the server needs to calculate a MAC using K_MAC. If
                use of the DSKPP MAC algorithm has been negotiated, then the
                MAC is calculated by calling C_SignInit with the CKM_KIP_MAC
                mechanism followed by a call to C_Sign. In the call to
                C_SignInit, K_MAC MUST be the signature key, the hKey
                parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure
                MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be
                set to zero. In the call to C_Sign, the pData parameter MUST
                be set to the concatenation of the string ID_S and the nonce
                R, and the ulDataLen parameter MUST be set to the length of
                the concatenated string. The desired length of the MAC MUST be
                specified through the pulSignatureLen parameter and MUST be
                set to the length of R.</t>

                <t>If the server also needs to authenticate its message (due
                to an existing K_TOKEN being replaced), the server MUST
                calculate a second MAC. Again, if use of the DSKPP MAC
                algorithm has been negotiated, then the MAC is calculated by
                calling C_SignInit with the CKM_KIP_MAC mechanism followed by
                a call to C_Sign. In this call to C_SignInit, the K_MAC
                existing before this DSKPP protocol run MUST be the signature
                key, the hKey parameter in the CK_KIP_PARAMS structure MUST be
                set to NULL, the pSeed parameter of the CT_KIP_PARAMS
                structure MUST be set to NULL_PTR, and the ulSeeidLen
                parameter MUST be set to zero. In the call to C_Sign, the
                pData parameter MUST be set to the concatenation of the string
                ID_S and the nonce R, and the ulDataLen parameter MUST be set
                to the length of concatenated string. The desired length of
                the MAC MUST be specified through the pulSignatureLen
                parameter and MUST be set to the length of R.</t>

                <t>The server sends its message to the client, including the
                wrapped key K, the MAC and possibly also the authenticating
                MAC.</t>
              </list></t>

            <t>On the client side, <list counter="3rd" style="format %d.">
                <t>The client calls C_UnwrapKey to receive a handle to K.
                After this, the client calls C_DeriveKey twice: Once to derive
                K_TOKEN and once to derive K_MAC. The client MUST use the same
                mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same mechanism
                parameters as used by the server above. When calling
                C_UnwrapKey and C_DeriveKey, the pTemplate parameter MUST be
                used to set additional key attributes in accordance with local
                policy and as negotiated and expressed in the protocol. In
                particular, the value of the &lt;KeyID&gt; element in the
                server's response message MAY be used as CKA_ID for K_TOKEN.
                The key K MUST be destroyed after deriving K_TOKEN and
                K_MAC.</t>

                <t>The MAC is verified in a reciprocal fashion as it was
                generated by the server. If use of the CKM_KIP_MAC mechanism
                has been negotiated, then in the call to C_VerifyInit, the
                hKey parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
                ulSeedLen MUST be set to 0. The hKey parameter of C_VerifyInit
                MUST refer to K_MAC. In the call to C_Verify, pData MUST be
                set to the concatenation of the string ID_S and the nonce R,
                and the ulDataLen parameter MUST be set to the length of the
                concatenated string, pSignature to the MAC value received from
                the server, and ulSignatureLen to the length of the MAC. If
                the MAC does not verify the protocol session ends with a
                failure. The token MUST be constructed to not "commit" to the
                new K_TOKEN or the new K_MAC unless the MAC verifies.</t>

                <t>If an authenticating MAC was received (REQUIRED if the new
                K_TOKEN will replace an existing key on the token), then it is
                verified in a similar vein but using the K_MAC associated with
                this server and existing before the protocol run. Again, if
                the MAC does not verify the protocol session ends with a
                failure, and the token MUST be constructed no to "commit" to
                the new K_TOKEN or the new K_MAC unless the MAC verifies.</t>
              </list></t>
          </list></t>
      </section>

      <section title="The 1-pass Variant">
        <t>A suggested procedure to perform 1-pass DSKPP with a cryptographic
        module through the PKCS #11 interface using the mechanisms defined in
        <xref target="CT-KIP-P11"></xref> is as follows:</t>

        <t><list counter="1-pass" style="format %c.">
            <t>On the server side, <list counter="1-1" style="format %d.">
                <t>A generic key K = K_TOKEN | K _MAC (where '|' denotes
                concatenation) is generated, e.g. by calling C_GenerateKey
                (using key type CKK_GENERIC_SECRET). The template for K MUST
                allow it to be exported (but only in wrapped form, i.e.
                CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
                also be set to CK_TRUE), and also to be used for further key
                derivation. From K, a token key K_TOKEN of suitable type is
                derived by calling C_DeriveKey using the PKCS #11 mechanism
                CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
                the first bit of the generic secret key (i.e. set to 0).
                Likewise, a MAC key K_MAC is derived from K by calling
                C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism, this
                time setting CK_EXTRACT_PARAMS to the length of K (in bits)
                divided by two.</t>

                <t>The server wraps K with either the token's public key,
                K_CLIENT, the shared secret key, K_SHARED, or the derived
                shared secret key, K_DERIVED by using C_WrapKey. If use of the
                DSKPP key wrap algorithm has been negotiated, then the
                CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
                C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure MUST
                be set to NULL_PTR. The pSeed parameter in the CK_KIP_PARAMS
                structure MUST point to the octet-string representation of an
                integer I whose value MUST be incremented before each protocol
                run, and the ulSeedLen parameter MUST indicate the length of
                the octet-string representation of I. The hWrappingKey
                parameter in the call to C_WrapKey MUST be set to refer to the
                wrapping key.<vspace blankLines="1" /> Note: The
                integer-to-octet string conversion MUST be made using the
                I2OSP primitive from <xref target="PKCS-1"></xref>. There MUST
                be no leading zeros.</t>

                <t>For the server's message to the client, if use of the DSKPP
                MAC algorithm has been negotiated, then the MAC is calculated
                by calling C_SignInit with the CKM_KIP_MAC mechanism followed
                by a call to C_Sign. In the call to C_SignInit, K_MAC MUST be
                the signature key, the hKey parameter in the CK_KIP_PARAMS
                structure MUST be set to NULL_PTR, the pSeed parameter of the
                CT_KIP_PARAMS structure MUST be set to NULL_PTR, and the
                ulSeedLen parameter MUST be set to zero. In the call to
                C_Sign, the pData parameter MUST be set to the concatenation
                of the string ID_S and the octet-string representation of the
                integer I, and the ulDataLen parameter MUST be set to the
                length of concatenated string. The desired length of the MAC
                MUST be specified through the pulSignatureLen parameter as
                usual, and MUST be equal to, or greater than, sixteen
                (16).</t>

                <t>If the server also needs to authenticate its message (due
                to an existing K_TOKEN being replaced), the server calculates
                a second MAC. If the DSKPP MAC mechanism is used, the server
                does this by calling C_SignInit with the CKM_KIP_MAC mechanism
                followed by a call to C_Sign. In the call to C_SignInit, the
                K_MAC existing on the token before this protocol run MUST be
                the signature key, the hKey parameter in the CK_KIP_PARAMS
                structure MUST be set to NULL_PTR, the pSeed parameter of the
                CT_KIP_PARAMS structure MUST be set to NULL_PTR, and the
                ulSeedLen parameter MUST be set to zero. In the call to
                C_Sign, the pData parameter MUST be set to the concatenation
                of the string ID_S and the octet-string representation of the
                integer I+1 (i.e. I MUST be incremented before each use), and
                the ulDataLen parameter MUST be set to the length of the
                concatenated string. The desired length of the MAC MUST be
                specified through the pulSignatureLen parameter as usual, and
                MUST be equal to, or greater than, sixteen (16).</t>

                <t>The server sends its message to the client, including the
                MAC and possibly also the authenticating MAC.</t>
              </list></t>

            <t>On the client side, <list counter="1-2" style="format %d.">
                <t>The client calls C_UnwrapKey to receive a handle to K.
                After this, the client calls C_DeriveKey twice: Once to derive
                K_TOKEN and once to derive K_MAC. The client MUST use the same
                mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same mechanism
                parameters as used by the server above. When calling
                C_UnwrapKey and C_DeriveKey, the pTemplate parameter MUST be
                used to set additional key attributes in accordance with local
                policy and as negotiated and expressed in the protocol. In
                particular, the value of the &lt;KeyID&gt; element in the
                server's response message MAY be used as CKA_ID for K_TOKEN.
                The key K MUST be destroyed after deriving K_TOKEN and
                K_MAC.</t>

                <t>The MAC is verified in a reciprocal fashion as it was
                generated by the server. If use of the CKM_KIP_MAC mechanism
                has been negotiated, then in the call to C_VerifyInit, the
                hKey parameter in the CK_KIP_PARAMS structure MUST be set to
                NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
                ulSeedLen MUST be set to 0. The hKey parameter of C_VerifyInit
                MUST refer to K_MAC. In the call to C_Verify, pData MUST be
                set to the concatenation of the string ID_S and the
                octet-string representation of the provided value for I, and
                the ulDataLen parameter MUST be set to the length of the
                concatenated string, pSignature to the MAC value received from
                the server, and ulSignatureLen to the length of the MAC. If
                the MAC does not verify or if the provided value of I is not
                larger than any stored value I' for the identified server ID_S
                the protocol session ends with a failure. The token MUST be
                constructed to not "commit" to the new K_TOKEN or the new
                K_MAC unless the MAC verifies. If the verification succeeds,
                the token MUST store the provided value of I as a new I' for
                ID_S.</t>

                <t>If an authenticating MAC was received (REQUIRED if K_TOKEN
                will replace an existing key on the token), it is verified in
                a similar vein but using the K_MAC existing before the
                protocol run. Again, if the MAC does not verify the protocol
                session ends with a failure, and the token MUST be constructed
                no to "commit" to the new K_TOKEN or the new K_MAC unless the
                MAC verifies.</t>
              </list></t>
          </list></t>
      </section>
    </section>

    <section anchor="Section-PRFRealizations"
             title="Example of DSKPP-PRF Realizations">
      <section title="Introduction">
        <t>This example appendix defines DSKPP-PRF in terms of AES <xref
        target="FIPS197-AES"></xref> and HMAC <xref
        target="RFC2104"></xref>.</t>
      </section>

      <section title="DSKPP-PRF-AES">
        <section title="Identification">
          <t>For cryptographic modules supporting this realization of
          DSKPP-PRF, the following URI MAY be used to identify this algorithm
          in DSKPP:</t>

          <t>urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes</t>

          <t>When this URI is used to identify the encryption algorithm to
          use, the method for encryption of R_C values described in <xref
          target="Subsection-Enc"></xref> MUST be used.</t>
        </section>

        <section title="Definition">
          <t>DSKPP-PRF-AES (k, s, dsLen)</t>

          <t>Input:<list hangIndent="10" style="hanging">
              <t hangText="k">Encryption key to use</t>

              <t hangText="s">Octet string consisting of randomizing material.
              The length of the string s is sLen.</t>

              <t hangText="dsLen">Desired length of the output</t>
            </list></t>

          <t>Output:</t>

          <t><list hangIndent="10" style="hanging">
              <t hangText="DS">A pseudorandom string, dsLen-octets long</t>
            </list></t>

          <t>Steps:</t>

          <t><list hangIndent="0" style="format %d.">
              <t>Let bLen be the output block size of AES in octets:<vspace
              blankLines="1" />bLen = (AES output block length in
              octets)<vspace blankLines="0" />(normally, bLen = 16)</t>

              <t>If dsLen &gt; (2**32 - 1) * bLen, output "derived data too
              long" and stop</t>

              <t>Let n be the number of bLen-octet blocks in the output data,
              rounding up, and let j be the number of octets in the last
              block:<vspace blankLines="1" />n = ROUND( dsLen / bLen)<vspace
              blankLines="0" />j = dsLen - (n - 1) * bLen</t>

              <t>For each block of the pseudorandom string DS, apply the
              function F defined below to the key k, the string s and the
              block index to compute the block:<vspace blankLines="1" />B1 = F
              (k, s, 1) ,<vspace blankLines="0" />B2 = F (k, s, 2) ,<vspace
              blankLines="0" />...<vspace blankLines="0" />Bn = F (k, s,
              n)</t>
            </list>The function F is defined in terms of the OMAC1
          construction from <xref target="FSE2003"></xref>, using AES as the
          block cipher:<vspace blankLines="1" />F (k, s, i) = OMAC1-AES (k,
          INT (i) || s)<vspace blankLines="1" />where INT (i) is a four-octet
          encoding of the integer i, most significant octet first, and the
          output length of OMAC1 is set to bLen.<vspace
          blankLines="1" />Concatenate the blocks and extract the first dsLen
          octets to product the desired data string DS:<vspace
          blankLines="1" />DS = B1 || B2 || ... || Bn&lt;0..j-1&gt;<vspace
          blankLines="1" />Output the derived data DS.</t>
        </section>

        <section title="Example">
          <t>If we assume that dsLen = 16, then:</t>

          <t>n = 16 / 16 = 1</t>

          <t>j = 16 - (1 - 1) * 16 = 16</t>

          <t>DS = B1 = F (k, s, 1) = OMAC1-AES (k, INT (1) || s)</t>
        </section>
      </section>

      <section title="DSKPP-PRF-SHA256">
        <section title="Identification">
          <t>For cryptographic modules supporting this realization of
          DSKPP-PRF, the following URI MAY be used to identify this algorithm
          in DSKPP:</t>

          <t>urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-sha256</t>

          <t>When this URI is used to identify the encryption algorithm to
          use, the method for encryption of R_C values described in <xref
          target="Subsection-Enc"></xref> MUST be used.</t>
        </section>

        <section title="Definition">
          <t>DSKPP-PRF-SHA256 (k, s, dsLen)</t>

          <t>Input:<list hangIndent="10" style="hanging">
              <t hangText="k">Encryption key to use</t>

              <t hangText="s">Octet string consisting of randomizing material.
              The length of the string s is sLen.</t>

              <t hangText="dsLen">Desired length of the output</t>
            </list></t>

          <t>Output:</t>

          <t><list hangIndent="10" style="hanging">
              <t hangText="DS">A pseudorandom string, dsLen-octets long</t>
            </list></t>

          <t>Steps:</t>

          <t><list hangIndent="0" style="format %d.">
              <t>Let bLen be the output size of SHA-256 in octets of <xref
              target="FIPS180-SHA"></xref> (no truncation is done on the HMAC
              output):<vspace blankLines="1" />bLen = 32<vspace
              blankLines="0" />(normally, bLen = 16)</t>

              <t>If dsLen &gt; (2**32 - 1) * bLen, output "derived data too
              long" and stop</t>

              <t>Let n be the number of bLen-octet blocks in the output data,
              rounding up, and let j be the number of octets in the last
              block:<vspace blankLines="1" />n = ROUND( dsLen / bLen)<vspace
              blankLines="0" />j = dsLen - (n - 1) * bLen</t>

              <t>For each block of the pseudorandom string DS, apply the
              function F defined below to the key k, the string s and the
              block index to compute the block:<vspace blankLines="1" />B1 = F
              (k, s, 1) ,<vspace blankLines="0" />B2 = F (k, s, 2) ,<vspace
              blankLines="0" />...<vspace blankLines="0" />Bn = F (k, s,
              n)</t>
            </list>The function F is defined in terms of the HMAC construction
          from <xref target="RFC2104"></xref>, using SHA-256 as the digest
          algorithm:<vspace blankLines="1" />F (k, s, i) = HMAC-SHA256 (k, INT
          (i) || s)<vspace blankLines="1" />where INT (i) is a four-octet
          encoding of the integer i, most significant octet first, and the
          output length of HMAC is set to bLen.<vspace
          blankLines="1" />Concatenate the blocks and extract the first dsLen
          octets to product the desired data string DS:<vspace
          blankLines="1" />DS = B1 || B2 || ... || Bn&lt;0..j-1&gt;<vspace
          blankLines="1" />Output the derived data DS.</t>
        </section>

        <section title="Example">
          <t>If we assume that sLen = 256 (two 128-octet long values) and
          dsLen = 16, then:</t>

          <t>n = ROUND ( 16 / 32 ) = 1</t>

          <t>j = 16 - (1 - 1) * 32 = 16</t>

          <t>B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)</t>

          <t>DS = B1&lt;0 ... 15&gt;</t>

          <t>That is, the result will be the first 16 octets of the HMAC
          output.</t>
        </section>
      </section>
    </section>
  </back>
</rfc>