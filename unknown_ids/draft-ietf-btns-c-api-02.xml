<?xml version="1.0" encoding="UTF-8"?>
<!-- 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' -->

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' [
    <!ENTITY RFC2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY RFC2396 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2396.xml'>
    <!ENTITY RFC2246 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2246.xml'>
    <!ENTITY RFC2367 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2367.xml'>
    <!ENTITY RFC2407 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2407.xml'>
    <!ENTITY RFC2408 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2408.xml'>
    <!ENTITY RFC2409 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2409.xml'>
    <!ENTITY RFC2692 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2692.xml'>
    <!ENTITY RFC4251 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4251.xml'>
    <!ENTITY RFC3552 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml'>
    <!ENTITY RFC3723 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3723.xml'>
    <!ENTITY RFC4301 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml'>
    <!ENTITY RFC4306 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4306.xml'>
    <!ENTITY RFC4307 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4307.xml'>
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc tocindent="no" ?>
<?rfc autobreaks="no" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

<rfc ipr="full3978" docName="draft-ietf-btns-c-api-02.txt">

<front>
  <title abbrev="ipsp-c-api">
     An interface between applications and keying systems
  </title>
  <author initials="M." surname="Richardson" fullname="Michael C. Richardson">
    <organization abbrev="SSW">Sandelman Software Works</organization>
    <address>
      <postal>   
        <street>470 Dawson Avenue</street>
        <city>Ottawa</city>
        <region>ON</region>
        <code>K1Z 5V7</code>
        <country>CA</country>
      </postal>
      <email>mcr@sandelman.ottawa.on.ca</email>
      <uri>http://www.sandelman.ottawa.on.ca/</uri>
    </address>

  </author>

<!--
  <author initials="W." surname="Sommerfeld" fullname="Bill Sommerfeld">
    <organization abbrev="Sun">Sun Microsystems</organization>
    <address>
      <postal>   
        <street>1 Network Drive</street>
        <city>Burlington</city>
        <region>MA</region>
        <code>xxxxx</code>
        <country>USA</country>
      </postal>
      <email>sommerfeld@east.sun.com</email>
      <uri>http://www.orchard.arlington.ma.us/</uri>
    </address>
  </author>
-->

  <date year="2008" />

<abstract>
  <t>
  Abstract
</t>
</abstract>

</front>

<middle>

<section title="Overview">
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC2119 <xref target="RFC2119" />.
</t>

</section>
<section title="Introduction">
<t>
Purpose of this API.
</t>
</section>

<section title="Objects involved">
<t>
There are two major kinds of objects that are defined by this document.
These are the Protection Token (pToken) and the Identity Token (iToken).
Both objects are abstracted into unique opaque tokens which may be manipulated
only indirectly by applications.
</t>
<t>
Each object has a series of attributes associated with it. The API provides 
a mechanism to query the value of attributes of the token. The attributes
are where all of the content of the objects are.
</t>

<t>
Each token has a scope - the place and time in which it can be considered
valid. There are many conflicting qualities that one would wish for the
token, and the result is a different compromise among these qualities for each token type. The tokens should be:
<list>
<t>small</t>
<t>easy to allocate and deallocate</t>
<t>automatically cleaned up when an application terminates (both properly and inproperly)</t>
<t>easily compared</t>
<t>easily passed back in a recvmsg(2) call as auxiliary data (for pToken)</t>
</list>
</t>

<section title="Scope of Protection Token">
<t>
The protection token has a per-process (i.e. per-address space) scope.
The scope of the token is not related to the underlying protection
provided by IPsec. The token is a handle.
</t>
</section>

<section title="Scope of Identity Token">
<t>
The identity token has a per-system scope, although two applications running
on the same system may not be able to compare it literally.
</t>
</section>

<section title="Validity period of Protection Token">
<t>
The pToken is valid only within the scope of a single process.
The token may not be saved in any long term storage.
</t>

<t>
It is permitted for one protection token to be replaced with another
(equivalent) protection token due to a node moving, suspending and resuming,
or due to extended network outages, however the underlying identity token
would be guaranteed to be the same.   This would most likely occur with
unconnected sockets, where due to the outage/downtime, the keying system was
unable to maintain a keying channel, and had to re-create the keys from
scratch. 
</t>
</section>

<section title="Validity period of Identity Token">
<t>
The iToken may be valid across the entire system, although it may need
to be turned into an external representation.  Some forms of identity
token may be valid across systems, but in general an identity token
is only valid in reference to a local set of trust anchors.
(See <xref target="RFC2692" />).
</t>
</section>

</section>

<section title="Namespace">
<t>
All functions and macros defined by this API are prefixed with "ipsec_"
for functions and variables, and with "IPSEC_" if they are macros or
enumerated types. (cf. to appropriate POSIX section?)
</t>
<t>
Whenever sensible, the enumerated values defined in <xref target="RFC2367" /> are 
used if appropriate.
</t>
</section>

<section title="pToken discovery">
<t>
An application that receives a connection using accept(2), or with
recvmsg(2) needs to get a protection token that is associated with the
socket.  
</t>
<t>
For connected sockets (such as TCP and some SCTP modes), the
protection token should not change during the lifetime of the socket, so
a simple process is appropriate.
</t>
<t>
For unconnected sockets (such as UDP and some SCTP modes), each datagram
received may be received may arrive from a different source, and therefore may
have different protections applied. A protection token needs to be returned
with each datagram, so it must be returned as ancilliary data with recvmsg(2).
</t>
<t>
For connected sockets, the pToken will not change during the connection.
(see notes about rekeying).  A simple function is provided to return a pToken
from a file descriptor.  Many implementions are likely to implement this
using getsockopt(2), but an interface in those terms is not specified in
order to keep it somewhat abstract.
</t>
</section>

<section title="Accessor Functions">
<t>
</t>
</section>

<section title="Security Considerations">
<t>
stuff
</t>
</section>

<section title="IANA Considerations">
<t>
stuff
</t>
</section>

<section title="Acknowledgments">
<t>
stuff
</t>
</section>

</middle>

<back>
<references title="Normative references">
&RFC2119;
&RFC2367;
&RFC2692;
<!-- DNSSEC -->
</references>

<references title="Non-normative references">
&RFC4301;
</references>
</back>
</rfc>
<!--
  $Id: ietf-btns-c-api.xml,v 1.4 2007/02/16 03:24:09 mcr Exp $

  $Log: ietf-btns-c-api.xml,v $
  Revision 1.4  2007/02/16 03:24:09  mcr
    updated to make XML happy, and dates corrected

  Revision 1.3  2007/02/16 03:04:44  mcr
  C API document.

  Revision 1.2  2006/03/21 22:02:47  mcr
  added API requirements and skeleton of original API spec

  Revision 1.1  2006/03/21 21:04:43  mcr
  added documents from ipsp WG

  Revision 1.1  2003/06/03 20:45:06  mcr
    initial template


!>
