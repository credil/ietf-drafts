<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
     <!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-kolberg-sam-baseline-protocol-00"
     ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="ALM Extensions to RELOAD">Application Layer Multicast
    Extensions to RELOAD</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <author fullname="John Buford" initials="J.F." surname="Buford">
      <organization>Avaya Labs Research</organization>

      <address>
        <postal>
          <street>233 Mt. Airy Rd</street>

          <city>Basking Ridge</city>

          <region>New Jersey</region>

          <code>07920</code>

          <country>USA</country>
        </postal>

        <phone>+1 908 848 5675</phone>

        <email>buford@avaya.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Mario Kolberg" initials="M." role="editor"
            surname="Kolberg">
      <organization>University of Stirling</organization>

      <address>
        <postal>
          <street>Dept. Computing Science and Mathematics</street>

          <city>Stirling</city>

          <region></region>

          <code>FK9 4LA</code>

          <country>UK</country>
        </postal>

        <phone>+44 1786 46 7440</phone>

        <email>mkolberg@ieee.org</email>

        <uri>http://www.cs.stir.ac.uk/~mko</uri>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Thomas C. Schmidt" initials="T C." surname="Schmidt">
      <organization>HAW Hamburg</organization>

      <address>
        <postal>
          <street>Berliner Tor 7</street>

          <city>Hamburg</city>

          <region></region>

          <code>20099</code>

          <country>Germany</country>
        </postal>

        <email>schmidt@informatik.haw-hamburg.de</email>

        <uri>http://inet.cpt.haw-hamburg.de/members/schmidt</uri>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Matthias Waehlisch" initials="M." surname="Waehlisch">
      <organization>link-lab &amp; FU Berlin</organization>

      <address>
        <postal>
          <street>Hoenower Str. 35</street>

          <city>Berlin</city>

          <code>10318</code>

          <country>Germany</country>
        </postal>

        <email>mw@link-lab.net</email>
      </address>
    </author>

    <date day="01" month="March" year="2010" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>IRTF</area>

    <workgroup>SAM Research Group</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>scalable adaptive multicast</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>We describe protocol and API extensions to P2P-SIP for constructing
      SAM sessions using hybrid combinations of Application Layer Multicast,
      native multicast, and multicast tunnels. We use the AMT relay and
      gateway elements for interoperation between native regions and ALM
      regions. The baseline architecture allows different overlay algorithms
      and different ALM control algorithms to be used.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The concept of scalable adaptive multicast includes both scaling
      properties and adaptability properties. Scalability is intended to
      cover: <list style="symbols">
          <t>large group size</t>

          <t>large numbers of small groups</t>

          <t>rate of group membership change</t>

          <t>admission control for QoS</t>

          <t>use with network layer QoS mechanisms</t>

          <t>varying degrees of reliability</t>

          <t>trees connect nodes over global internet</t>
        </list> Adaptability includes <list style="symbols">
          <t>use of different control mechanisms for different multicast trees
          depending on initial application parameters or application class</t>

          <t>changing multicast tree structure depending on changes in
          application requirements, network conditions, and membership</t>

          <t>use of different control mechanisms and tree structure in
          different regions of network depending on native multicast support,
          network characteristics, and node behavior</t>
        </list> In this document we describe a protocol and API extension to
      P2P-SIP [P2P-SIP] for constructing SAM sessions using hybrid
      combinations of Application Layer Multicast, native multicast, and
      multicast tunnels.</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119">RFC 2119</xref>.</t>
      </section>

      <!--      <section title="Section authors">
       <t>
This section will be removed.
       <list style="symbols">
         <t>Intro, Definitions, Assumptions - all</t>
         <t>Hybrid ALM Tree Operatios - John</t>
         <t>Group Management API - Thomas/Matthias</t>
         <t>Protocol - Mario</t>
         <t>Examples - TBD</t>
         <t>Security Considerations - TBD</t>
       </list>
       </t>
      </section>
-->
    </section>

    <section anchor="definitions" title="Definitions">
      <section title="Overlay Network">
        <figure align="center" anchor="overlay">
          <artwork align="left"><![CDATA[
                    P    P    P   P     P
                  ..+....+....+...+.....+...
                 .                          +P
               P+                            .
                 .                          +P
                  ..+....+....+...+.....+...
                    P    P    P   P     P
            ]]></artwork>
        </figure>

        <t>Overlay network - An application layer virtual or logical network
        in which end points are addressable and that provides connectivity,
        routing, and messaging between end points. Overlay networks are
        frequently used as a substrate for deploying new network services, or
        for providing a routing topology not available from the underlying
        physical network. Many peer-to-peer systems are overlay networks that
        run on top of the Internet. In the above figure, "P" indicates overlay
        peers, and peers are connected in a logical address space. The links
        shown in the figure represent predecessor/successor links. Depending
        on the overlay routing model, additional or different links may be
        present.</t>
      </section>

      <section title="Overlay Multicast">
        <t>Overlay Multicast (OM): Hosts participating in a multicast session
        form an overlay network and utilize unicast connections among pairs of
        hosts for data dissemination. The hosts in overlay multicast
        exclusively handle group management, routing, and tree construction,
        without any support from Internet routers. This is also commonly known
        as Application Layer Multicast (ALM) or End System Multicast (ESM). We
        call systems which use proxies connected in an overlay multicast
        backbone "proxied overlay multicast" or POM.</t>
      </section>

      <section title="Peer">
        <t>Peer: an autonomous end system that is connected to the physical
        network and participates in and contributes resources to overlay
        construction, routing and maintenance. Some peers may also perform
        additional roles such as connection relays, super nodes, NAT
        traversal, and data storage.</t>
      </section>

      <section title="Multi-Destination Routing">
        <t>Multi-Destination Routing (MDR): A type of multicast routing in
        which group member's addresses are explicitly listed in each packet
        transmitted from the sender <xref target="AGU1984"></xref>. XCAST
        <xref target="RFC5058"></xref> is an experimental MDR protocol. A
        hybrid host group and MDR design is described in <xref
        target="HE2005"></xref>.</t>
      </section>
    </section>

    <section anchor="Assumptions" title="Assumptions">
      <section title="Overlay">
        <t>Peers connect in a large-scale overlay, which may be used for a
        variety of peer-to-peer applications in addition to multicast
        sessions. Peers may assume additional roles in the overlay beyond
        participation in the overlay and in multicast trees. We assume a
        single structured overlay routing algorithm is used. Any of a variety
        of multi-hop, one-hop, or variable-hop overlay algorithms could be
        used.</t>

        <t>Castro et al. <xref target="CASTRO2003"></xref>compared multi-hop
        overlays and found that tree-based construction in a single overlay
        out-performed using separate overlays for each multicast session. We
        use a single overlay rather than separate overlays per multicast
        sessions. We defer federated and hierarchical multi-overlay designs to
        later versions of this document.</t>

        <t>Peers may be distributed throughout the network, in regions where
        native multicast (NM) is available as well as regions where it is not
        available.</t>

        <t>An overlay multicast algorithm may leverage the overlay's mechanism
        for maintaining overlay state in the face of churn. For example, a
        peer may hold a number of DHT (Distributed Hash Table) entries. When
        the peer gracefully leaves the overlay, it transfers those entries to
        the nearest peer. When another peers joins which is closer to some of
        the entries than the current peer which holds those entries, than
        those entries are migrated. Overlay churn affects multicast trees as
        well; remedies include automatic migration of the tree state and
        automatic re-join operations for dislocated children nodes.</t>
      </section>

      <section title="Overlay Multicast">
        <t>The overlay supports concurrent multiple multicast trees. The limit
        on number of concurrent trees depends on peer and network resources
        and is not an intrinsic property of the overlay. Some multicast trees
        will contain peers use ALM only, i.e., the peers do not have NM
        connectivity. Some multicast trees will contain peers with a
        combination of ALM and NM. Although the overlay could be used to form
        trees of NM-only peers, if such peers are all in the same region we
        expect native mechanisms to be used for such tree construction, and if
        such peers are in different regions we expect AMT to handle most cases
        of interest.</t>

        <t>Peers are able to determine, through configuration or
        discovery:</t>

        <t><list style="symbols">
            <t>Can they connect to a NM router</t>

            <t>Is an AMT gateway accessible</t>

            <t>Can the peer support the AMT-GW functionality locally</t>

            <t>Is MDR supported in the region</t>
          </list></t>
      </section>

      <section title="P2PSIP">
        <t>We use P2PSIP <xref target="I-D.ietf-p2psip-base"></xref> as the
        distibuted hash table (DHT) for data storage and overlay by which the
        peers interconnect and route messages. P2PSIP is a generic P2P
        overlay, and application support is defined by profiles called Usages.
        In this document we present an Application Layer Multicast (ALM) Usage
        and a Hybrid ALM Usage.</t>

        <t>We also follow the P2PSIP terminology for overlay specific terms,
        such as the distinction between peer, node, and client.</t>
      </section>

      <section title="NAT">
        <t>Some nodes in the overlay may be in a private address space and
        behind firewalls. We use the P2PSIP mechanisms for NAT traversal. We
        permit clients to be leaf nodes in an ALM or HALM tree. The specific
        capabilities of clients in terms of tree creation and being parents of
        other nodes will be described in subsequent versions.</t>
      </section>

      <section title="Regions">
        <t>A region is a contiguous internetwork such that if native multicast
        is available, all routers and end systems can connect to native
        multicast groups available in that region. A region may include end
        systems.</t>
      </section>

      <section title="AMT">
        <t>We use AMT <xref target="I-D.ietf-mboned-auto-multicast"></xref> to
        connect nodes in ALM region with nodes in NM region. AMT permits AMT-R
        and AMT-GW functionality to be embedded in hosts or specially
        configured routers. We assume AMT-R and AMT-GW can be implemented in
        nodes. AMT has certain restrictions: 1) isolated sites/hosts can
        receive SSM, 2) isolated non-NAT sites/hosts can send SSM, 3) isolated
        sites/hosts can receive general multicast. AMT does not permit
        isolated sites/hosts to send general multicast.</t>
      </section>
    </section>

    <section title="Hybrid ALM Tree Operations">
      <t>Peers use the overlay to support ALM operations such as: <list
          style="symbols">
          <t>Create tree</t>

          <t>Join</t>

          <t>Leave</t>

          <t>Re-Form or optimize tree</t>
        </list> There are a variety of algorithms for peers to form multicast
      trees in the overlay. We permit multiple such algorithms to be supported
      in the overlay, since different algorithms may be more suitable for
      certain application requirements, and since we wish to support
      experimentation. Therefore, overlay messaging corresponding to the set
      of overlay multicast operations must carry algorithm identification
      information.</t>

      <t>For example, for small groups, the join point might be directly
      assigned by the rendezvous point, while for large trees the join request
      might be propagated down the tree with candidate parents forwarding
      their position directly to the new node.</t>

      <t>In addition to these overlay level tree operations, some peers may
      implement additional operations to map tree operations to native
      multicast and/or AMT <xref
      target="I-D.ietf-mboned-auto-multicast"></xref> connections</t>

      <figure align="center" anchor="hybrid-alm">
        <artwork align="left"><![CDATA[
+---------------+                            +---------------+
| AMT Site      |   P    P    P   P     P    | Native MCast  |
|     ..........+...+....+....+...+.....+....+.......        |
|     .     +---++                          ++---+  +P       |
|    P+     |AMT |                          |AMT |  .        |
|     .     |GW  |                          |RLY |  +P       |
|     .     +---++                          ++---+  .        |
+-----+---------+                            +------+--------+
      .                                             .
      .                                      +------+--------+
      .                                      |      . Native |
      .                                      |      .  MDR   |
     P+....+P                           .....+...+..+P       |
         .                              .    |   P           |        
+--------+------+                       .    +---------------+
| Native . MCast|                       .
|        .      |                       .    +---------------+
| P-AMT-R+      |                      P+    |Native Mcast   |
|        .      |                       .   ++---+           |
| P-AMT-R+      |               P-AMT-GW+===|AMT |           |  
|        ...+...+..                     .   |RLY |           |
|           P   |  .+....+........+.....+   ++---+           | 
+---------------+   P    P        P     P    +---------------+
   ]]></artwork>
      </figure>

      <t>In the above figure we show the hybrid architecture in six regions of
      the network. All peers are connected in an overlay, and the figure shows
      the predecessor/successor links between peers. The peers may have other
      connections in the overlay. <list style="symbols">
          <t>No native multicast: Peers (P) in this region connect to the
          overlay</t>

          <t>Native multicast (NM) with a local AMT gateway (AMT GW). There
          are one or more peers (P) connected to the overlay in this
          region.</t>

          <t>Native multicast with a local AMT relay (AMT RLY). There are one
          or more peers (P) connected to the overlay in this region.</t>

          <t>Native multicast with one or more peers which emulate the AMT
          relay behavior (P-AMT-R) which also connect to the overlay. There
          may be other peers (P) which also connect to the overlay.</t>

          <t>Native MDR is a native multicast region using multi-destination
          routing, in which one or more peers reside in the region.</t>

          <t>Native multicast with no peers that connect to the overlay, but
          for which there is at least one peer in the unicast-only part of the
          network which can behave as an AMT-GW (P-AMT-GW) to connect to
          multicast sources through an AMT-R for that region. It may be
          feasible to also allow non-peer hosts in such a region to
          participate as receivers of overlay multicast; for this version, we
          prefer to require all hosts to join the overlay as peers.</t>
        </list></t>

      <section title="ALM-Only Tree - Algorithm 1">
        <t>Here is a simplistic algorithm for forming a multicast tree in the
        overlay. Its main advantage is use of the overlay routing mechanism
        for routing both control and data messages. The group creator doesn't
        have to be the root of the tree or even in the tree. It doesn't
        consider per node load, admission control, or alternative paths.</t>

        <t>As stated earlier, multiple algorithms will co-exist in the
        overlay. <list style="numbers">
            <t>Peer which initiates multicast group: <vspace blankLines="1" />
            <!--NOTE: This is intended to produce unformatted text,
   is there a less involved way to do this? --> <figure align="left"
                anchor="create">
                <artwork align="left"><![CDATA[
groupID = create();  // allocate a unique groupId 
                     // the root is the nearest peer in the overlay
                     // out of band advertisement or
                     // distribution of groupID, 
                     // perhaps by publishing in DHT
]]></artwork>
              </figure></t>

            <t>Any joining peer: <vspace blankLines="1" /> <figure
                align="left" anchor="joinTree">
                <artwork align="left"><![CDATA[
// out of band discovery of groupID, perhaps by lookup in DHT
joinTree(groupID); // sends "join groupID" message
]]></artwork>
              </figure> <vspace blankLines="1" /> The overlay routes the join
            request using the overlay routing mechanism toward the peer with
            the nearest id to the groupID. This peer is the root. Peers on the
            path to the root join the tree as forwarding points.</t>

            <t>Leave Tree: <vspace blankLines="1" /> leaveTree(groupID) //
            removes this node from the tree <vspace blankLines="1" />
            Propagates a leave message to each child node and to the parent
            node. If the parent node is a forwarding node and this is its last
            child, then it propagates a leave message to its parent. A child
            node receiving a leave message from a parent sends a join message
            to the groupID.</t>

            <t>Message forwarding: <vspace blankLines="1" />
            multicastMsg(groupID, msg);</t>

            <t><list style="symbols">
                <t>SSM tree The creator of the tree is the source. It sends
                data messages to the tree root which are forwarded down the
                tree.</t>

                <t>ASM tree A node sending a data message sends the message to
                its parent and its children. Each node receiving a data
                message from one edge forwards it to remaining tree edges it
                is connected to.</t>
              </list></t>
          </list></t>
      </section>

      <section title="ALM tree with peer at AMT site (AMT-GW)">
        <t>The joining peer connects to the tree using the ALM protocol, or,
        if the tree includes a peer in an NM region, then the peer can use the
        AMT GW to connect to the NM peer through the AMT relay. The peer can
        choose the delivery path based on latency and throughput. If the peer
        is not a joining peer and is on the overlay path of a join request:
        <list style="symbols">
            <t>If its next hop is a peer in an NM region with AMT-R, then it
            can select either overlay routed multicast messages or AMT
            delivered multicast messages.</t>

            <t>If its next hop is a peer outside of an NM region, then it
            could use either ALM only or use AMT delivery as an alternate
            path</t>
          </list></t>
      </section>

      <section title="ALM tree with NM peer using AMT-R">
        <t>There are these cases: <list style="symbols">
            <t>There is no peer in the tree which has an AMT-GW. The NM peer
            uses ALM routing.</t>

            <t>There is at least one peer in the tree which can function as
            P-AMT-GW. The NM peer can join the tree using ALM routing and/or
            connecting to the P-AMT-GW.</t>

            <t>There is at least one peer in the tree which is in an AMT-GW
            region. The NM peer can join the tree using ALM routing and/or
            connecting to the AMT-GW.</t>
          </list></t>
      </section>

      <section title="ALM tree with NM peer with P-AMT-R">
        <t>Either the NM peer supports P-AMT-R or another peer in the multcast
        tree in the same region is P-AMT-R capable. The three cases above
        apply here, replacing AMT-R with P-AMT-R.</t>
      </section>

      <section title="Mixed Region Scenarios">
        <t>In version 2 of this document we elaborate on: <list
            style="symbols">
            <t>ALM tree topology vs NM topology and NM-ALM edges</t>

            <t>Single NM-ALM edge nodes vs multi NM peers from same region in
            the tree</t>

            <t>Initial tree membership is ALM vs initial tree membership is
            NM</t>
          </list> For ALM tree topology vs NM topology, all peers belong to
        the overlay, but only P-ALM peers use overlay routing for multicast
        data transmission. As a default behavior, a P-NM peer should generally
        prefer to join the tree via an AMT-GW node. But there may be special
        cases (small trees, short multicast sessions, trees where most of the
        members are known to be P-ALM) in which the peer can override this to
        specify an ALM-only join. A P-NM peer may also accept P-ALM children
        which don't use the AMT tunnel path to participate in the multicast
        tree.</t>

        <t>Consider 3 types of tree links: P-ALM to P-ALM, P-NM to P-NM and
        P-ALM to/from P-NM: <list style="symbols">
            <t>P-ALM to P-ALM This is a normal ALM tree path with management
            strictly in the overlay</t>

            <t>P-NM to P-NM If the peers are in the same region, then the data
            path use native multicast capability in that region, and control
            occurs in ALM layer for ALM tree coordination and NM layer for
            native multicast purposes. If the peers are in different NM
            regions, then, if AMT gateways are available and configured to
            support an AMT tunnel between the regions, a tunnel is created
            using the AMT protocol (or already exists for this multicast
            group). The peers connect to their respective AMT gateways using
            the AMT procedure.</t>

            <t>P-ALM to/from P-NM The connection can be either ALM or AMT
            tunnel depending on the context.</t>
          </list> We expect two new functions are needed to build hybrid
        trees: <list style="symbols">
            <t>joinViaAMTGateway(peer, AMT-GW, group_id) where 'Peer' is the
            peer requesting to join the ALM group identified by group_id, and
            AMT-GW is the ip address of the AMT gateway that the peer uses in
            its native multicast region. Request is transmitted to one or more
            parent peer candiates and/or rendezvous peers for the specified
            group id, according to the usual join protocol in this overlay. If
            the parent peer is a P-AMT-GW, then a tunnel is formed using the
            AMT protocol from the P-AMT-GW to the specified AMT-GW. If parent
            peer is a peer P-NM in native multicast region, then the tunnel is
            created between P-NM's AMT-GW and the specified AMT-GW, using the
            AMT protocol. If parent peer is a P-ALM, then the requested is
            propagated to other peers in the tree according to the join
            rules.</t>

            <t>leaveViaAMTGateway(peer, AMT-GW, group_id)where 'Peer' is the
            peer requesting to leave the ALM group identified by group_id, and
            AMT-GW is the ip address of the AMT gateway that the peer uses in
            its native multicast region. Request is transmitted the parent
            peer which is associated with the AMT-GW or provides that role. If
            the parent peer is a P-AMT-GW, then it removes the child from its
            AMT children list and may tear down the AMT tunnel P-AMT-GW to the
            specified AMT-GW if no other children are using it. If parent peer
            is a peer P-NM in native multicast region, then the tunnel is
            created between P-NM's AMT-GW and the specified AMT-GW, using the
            AMT protocol.</t>
          </list> Regarding initial tree membership being either P-NM or P-ALM
        node(s), we expect the general case should be that hybrid tree
        formation is supported transparently regardless.</t>
      </section>
    </section>

    <section title="Group Management API">
      <t>The group management API describes interfaces to register or
      deregister multicast listeners, and to send and receive multicast data.
      An important issue lies in addressing. While native multicast is bound
      to IP addresses, ALM uses arbitrary strings as multicast names, which
      will be mapped to the overlay identifier space.</t>

      <t>The aim of this API is to implement group-oriented data communication
      independent of the underlying distribution technologies. In particular,
      applications should be designed to meet efficiency requirements, but
      also to remain robust with respect to deployment. The API is located
      between applications and the group stack at the current host. We do not
      consider an interface between hosts.</t>

      <t></t>

      <section title="Data Types">
        <t><list style="hanging">
            <t hangText="Address">is any address structure suitable with
            respect to the technology available at the host. This may be an
            IPv4 or an IPv6 address, or any overlay identifier.</t>

            <t hangText="Handle">gives a reference to a specific instance of a
            communication object.</t>
          </list></t>
      </section>

      <section title="Send and Receive Calls">
        <t><list style="hanging">
            <t hangText="init(out Handle s)">This call gives a handle on a
            multicast socket, which will be used for subsequent
            communication.</t>

            <t hangText="join(in Address a, in Handle s)">This operation
            initiates a group subscription for the address a.</t>

            <t hangText="leave(in Address a, in Handle s)">This operation
            results in an unsubscription for the given address a.</t>

            <t hangText="send(in Address a, in Handle s, in Message m)">This
            call sends data m to the multicast address a.</t>

            <t hangText="receive(in Handle s, out Message m)">This call
            delivers data m to the application.</t>
          </list></t>
      </section>
    </section>

    <section title="Protocol">
      <section title="Introduction">
        <t>In this document we define messages for hybrid overlay multicast
        tree creation, using an existing proposal (RELOAD) in the P2P-SIP WG
        <xref target="I-D.ietf-p2psip-base"></xref> for a universal structured
        peer-to-peer overlay protocol. RELOAD provides the mechanism to
        support a number of overlay topologies. Hence the hybrid overlay
        multicast framework [TODO: BUF2008] (hereafter SAM framework) can be
        used with P2P-SIP, and that the SAM framework is overlay agnostic.</t>

        <t>We are not proposing that these SAM-specific messages be
        incorporated into RELOAD since constructing the SAM framework is still
        a research activity. However, we do propose that RELOAD add an
        extension mechanism.</t>

        <t>As discussed in the SAM requirements draft, there are a variety of
        ALM tree formation and tree maintenance algorithms. The intent of this
        specification is to be algorithm agnostic, similar to how RELOAD is
        overlay algorithm agnostic. We assume that all control messages are
        propagated using overlay routed messages.</t>

        <t>The message types needed for ALM behavior are divided into the
        following categories: <list style="symbols">
            <t>Tree life-cycle (create, join, leave, re-form, heartbeat)</t>

            <t>AMT gateway advertisement and discovery</t>

            <t>Peer region and multicast properties</t>
          </list></t>

        <t>For encoding we propose a single SAM message type be added to P2PP.
        Implementations of P2PP compliant with this specification MUST support
        this new message type and all subtypes defined here.</t>
      </section>

      <section title="Tree Lifecylce Messages">
        <t>Peers use the overlay to transmit ALM (application layer multicast)
        operations and hybrid ALM operations defined in this section.</t>

        <section title="Create Tree">
          <t>A new ALM tree is created in the overlay with the identity
          specified by GroupId. The usual interpretation of GroupId is that
          the peer with peer id closest to and less than the GroupId is the
          root of the tree. The tree has no children at the time it is
          created.</t>

          <t>The GroupId is generated from a well-known session key to be used
          by other Peers to address the multicast tree in the overlay. The
          generation of the GroupId from the SessionKey MUST be done using the
          overlay's id generation mechanism.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId;
        opaque SessionKey<0..2^32-1>;
        NodeID GroupId;
        Dictionary Options;
      } CreateALMTree;
]]></artwork>
          </figure>

          <t>PeerId: the overlay address of the peer that creates the
          multicast tree.</t>

          <t>SessionKey: a well-known string when hashed using the overlay's
          id generation algorithm produces the GroupId.</t>

          <t>GroupId: the overlay address of the root of the tree</t>

          <t>Options: name-value list of properties to be associated with the
          tree, such as the maximum size of the tree, restrictions on peers
          joining the tree, latency constraints, preference for distributed or
          centralized tree formation and maintenance, heartbeat interval.</t>
        </section>

        <section title="Join">
          <t>Causes the distributed algorithm for peer join of a specific ALM
          group to be invoked. If successful, the PeerId is notified of one or
          more candidate parent peers in one or more JoinAccept messages. The
          particular ALM join algorithm is not specified in this protocol.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId;
        NodeID GroupId;
        Dictionary Options;
      } Join;
]]></artwork>
          </figure>

          <t>PeerId: overlay address of joining/leaving peer</t>

          <t>GroupId: the overlay address of the root of the tree</t>

          <t>Options: name-value list of options proposed by joining peer</t>
        </section>

        <section title="Join Accept">
          <t>Tells the requesting joining peer that the indicated peer is
          available to act as its parent in the ALM tree specified by GroupId,
          with the corresponding Options specified. A peer MAY receive more
          than one JoinAccept from diffent candidate parent peers in the
          GroupId tree. The peer accepts a peer as parent using a JoinConfirm
          message. A JoinAccept which receives neither a JoinConfirm or
          JoinDecline response MUST expire.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID ParentPeerId;
        NodeID ChildPeerId;
        NodeID GroupId;
        Dictionary Options;
      } JoinAccept;
]]></artwork>
          </figure>

          <t>ParentPeerId: overlay address of a peer which accepts the joining
          peer</t>

          <t>ChildPeerId: overlay address of joining peer</t>

          <t>GroupId: the overlay address of the root of the tree</t>

          <t>Options: name-value list of options accepted by parent peer</t>
        </section>

        <section title="Join Confirm">
          <t>A peer receiving a JoinAccept message which it wishes to accept
          MUST explicitly accept it before the expiration of the JoinAccept
          using a JoinConfirm message. The joining peer MUST include only
          those options from the JoinAccept which it also accepts, completing
          the negotiation of options between the two peers.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID ChildPeerId;
        NodeID ParentPeerId;
        NodeID GroupId;
        Dictionary Options;
      } JoinConfirm;
]]></artwork>
          </figure>

          <t>ChildPeerId: overlay address of joining peer which is a child of
          the parent peer</t>

          <t>ParentPeerId: overlay address of the peer which is the parent of
          the joining peer</t>

          <t>GroupId: the overlay address of the root of the tree</t>

          <t>Options: name-value list of options accepted by both peers</t>
        </section>

        <section title="Join Decline">
          <t>A peer receiving a JoinAccept message which does not wish to
          accept it MAY explicitly decline it using a JoinDecline message.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId;
        NodeID ParentPeerId;
        NodeID GroupId;
      } JoinDecline;
]]></artwork>
          </figure>

          <t>PeerId: overlay address of joining peer which declines the
          JoinAccept</t>

          <t>ParentPeerId: overlay address of the peer which issued a
          JoinAccept to this peer</t>

          <t>GroupId: the overlay address of the root of the tree</t>
        </section>

        <section title="Join Via AMT Gateway">
          <t>A request to create a hybrid native multicast connection for the
          specified PeerId peer to join the tree identified by the GroupId.
          The request is transmitted to one or more parent peer candidates
          and/or rendezvous peers for the specified group id, according to the
          usual join protocol in this overlay.</t>

          <t>If the parent peer is a P-AMT-GW (a peer which supports the
          AMT-GW interface), then after JoinAccept and JoinConfirm steps,
          instead of an overlay parent-child link, an AMT tunnel is formed
          using the AMT protocol from the P-AMT-GW to the specified AMT-GW to
          which the Peer is associated.</t>

          <t>If parent peer is a peer P-NM in native multicast region, then
          after JoinAccept and JoinConfirm steps, the tunnel is created
          between P- NM's AMT-GW and the specified AMT-GW, using the AMT
          protocol. If parent peer is a P-ALM, then the requested is
          propagated to other peers in the tree according to the join
          processing rules.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId;
        IpAddressPort AMT-GW;
        NodeID GroupId;
        Dictionary Options;
      } JoinViaAMTGateway;
]]></artwork>
          </figure>

          <t>PeerID: the peer requesting to join the ALM group identified by
          group_id</t>

          <t>AMT-GW: ip address of the AMT gateway that the peer uses in its
          native multicast region.</t>

          <t>Options: name-value list of options proposed by joining peer</t>
        </section>

        <section title="Join Via Native Link">
          <t>This allows child to select specific parent peer, overriding
          selection based on the basic join method. Typical use is for a peer
          in NM region to join the multicast group using the local native
          multicast path for this GroupId. Joining peer determines:</t>

          <t><list style="symbols">
              <t>It is in an NM region, determined for example using MRD
              (Multicast Router Discovery) <xref target="RFC4286"></xref> or
              configuration</t>

              <t>It knows the native multicast address (NMA) in its region, if
              it exists, which corresponds to the GroupId</t>

              <t>It can connect to the NMA using IGMP</t>

              <t>Either 1) there is at least one peer that is in the same NM
              region that is already part of the GroupId, or 2) the region has
              an AMT- GW which can connect to some P-AMT-GW or P-NM in another
              NM region which is part of the GroupId. It uses a separate
              discovery step such as LookupPeerNMInfo described later.</t>

              <t>If there is no such peer in the GroupId, then this joining
              peer is the first peer to be added which is in an NM region. It
              CANNOT join using this message type.</t>
            </list></t>

          <t>ParentPeer and ChildPeer are either in same NM region or in two
          different NM regions with capability for AMT. Since media is passed
          via NM path, the parent-child relationship established by this join
          is for control and membership management</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID ChildPeerId;
        NodeID ParentPeerId;
        NodeID GroupId;
        Dictionary Options;
      } JoinWithNativeLink;
]]></artwork>
          </figure>

          <t>ChildPeerId: overlay address of joining peer which is a child of
          the parent peer</t>

          <t>ParentPeerId: overlay address of the peer which is the parent of
          the joining peer</t>

          <t>GroupId: the overlay address of the root of the tree</t>

          <t>Options: name-value list of options accepted by both peers</t>
        </section>

        <section title="Leave">
          <t>A peer which is part of an ALM tree idenfied by GroupId which
          intends to detach from either a child or parent peer SHOULD send a
          Leave message to the peer it wishes to detach from. A peer receiving
          a Leave message from a peer which is neither in its parent or child
          lists SHOULD ignore the message.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId;
        NodeID GroupId;
        Dictionary Options;
      } Leave;
]]></artwork>
          </figure>

          <t>PeerId: overlay address of leaving peer</t>

          <t>GroupId: the overlay address of the root of the tree</t>

          <t>Options: name-value list of options</t>
        </section>

        <section title="Leave via AMT Gateway">
          <t>A peer which is part of an ALM tree identified by GroupId which
          intends to detach from either a child or parent peer and which uses
          an AMT tunnel to connect to the peer SHOULD send a
          LeaveViaAMTGateway message to the peer it wishes to detach from. A
          peer receiving a LeaveViaAMTGateway message from a peer which is
          neither in its parent or child lists SHOULD ignore the message.</t>

          <t>The request is transmitted the AdjacentPeerId. AdjacentPeerId
          MUST remove the specified PeerId from its children or parent lists
          if present.</t>

          <t>If AdjacentPeerId is a P-AMT-GW, then it MAY tear down the AMT
          tunnel from P-AMT-GW to the specified AMT-GW if no other children
          are using it. If AdjacentPeerId is a peer P-NM (peer in a native
          multicast region), then the tunnel between P-NM's AMT-GW and the
          specified AMT- GW MAY be removed according to the policy and
          configuration of the AMT-GW.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId;
        NodeID AdjacentPeerId;
        IpAddressPort AMT-GW;
        NodeID GroupId;
        Dictionary Options;
      } LeaveViaAMTGateway;
]]></artwork>
          </figure>

          <t>PeerId: overlay address of leaving peer</t>

          <t>AdjacentPeerId: overlay address of an adjacent (parent or child)
          peer</t>

          <t>AMT-GW: ip address of the AMT gateway that the peer uses in its
          native multicast region.</t>

          <t>GroupId: the overlay address of the root of the tree</t>

          <t>Options: name-value list of options</t>
        </section>

        <section title="Re-Form or Optimize Tree">
          <t>This triggers a reorganization of either the entire tree or only
          a sub-tree. It MAY include hints to specific peers of recommended
          parent or child peers to reconnect to. A peer receiving this message
          MAY ignore it, MAY propagate it to other peers in its subtree, and
          MAY invoke local algorithms for selecting preferred parent and/or
          child peers.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID GroupId;
        NodeID PeerId;
        Dictionary Options;
      } Reform;
]]></artwork>
          </figure>

          <t>GroupId: the overlay address of the root of the tree</t>

          <t>PeerId: if omitted, then the tree is reorganized starting from
          the root, otherwise it is reorganized only at the sub-tree
          identified by PeerId.</t>

          <t>Options: name-value list of options</t>
        </section>

        <section title="Heartbeat">
          <t>A node signals to its adjacent nodes in the tree that it is
          alive. If a peer does not receive a Heartbeat message within N
          heartbeat time intervals, it MUST treat this as an explicit Leave
          message from the unresponsive peer. N is configurable.</t>

          <figure>
            <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId1;
        NodeID PeerId2;
        NodeID GroupId;
      } Heartbeat;
]]></artwork>
          </figure>

          <t>PeerId1: source of heartbeat</t>

          <t>PeerId2: destination of heartbeat</t>

          <t>GroupId: overlay address of the root of the tree</t>
        </section>
      </section>

      <section title="AMT Gateway Advertisement and Discovery">
        <t>Allows peer to disclose to other peers in the overlay their ability
        to act as a native-multicast gateway (as in AMT) for peers in a given
        region. We expect to use the P2P Publish and Lookup messages for this
        purpose. But to avoid collision with the semantics of those
        operations, we temporarily define shadow versions within the SAM
        extension. Publish stores an advertisement object for a peer with is
        an AMT gateway in the DHT for the overlay, under a given key.</t>

        <figure>
          <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId;
        ResourceID Key;
        opaque Region<0..2^32-1>;
        Dictionary Options;
      } PublishAMTGateway;
]]></artwork>
        </figure>

        <figure>
          <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId;
        ResourceID Key;
      } LookupAMTGateway;
]]></artwork>
        </figure>

        <t>PeerId: the peer which is the AMT gateway</t>

        <t>Key: the key by which other peers lookup the advertisement, details
        TBD. There can be more than one key.</t>

        <t>Region: an id for a region, using some region identification scheme
        TBD. For example, the Autonomous System Number (ASN) could be used.
        <xref target="RFC1930"></xref></t>

        <t>Options: Name-value list of options</t>
      </section>

      <section title="Peer Region and Multicast Properties Messages">
        <t>Peers can advertise the network region that they belong to and its
        native multicast properties if any. Similar to AMT Gateway
        advertisement and discovery, uses the DHT for lookup and publish.</t>

        <figure>
          <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId;
        ResourceID Key;
        opaque Region<0..2^32-1>;
        Dictionary Options;
      } PublishPeerNMInfo;
]]></artwork>
        </figure>

        <figure>
          <artwork align="left"><![CDATA[
      struct {  
        NodeID PeerId;
        ResourceID Key;
      } LookupPeerNMInfo;
]]></artwork>
        </figure>

        <t>PeerId: the peer which is the AMT gateway</t>

        <t>Key: the key by which other peers lookup the advertisement, details
        TBD. There can be more than one key.</t>

        <t>Options: Name-value list of options.</t>
      </section>
    </section>

    <section title="RELOAD Usages">
      <t>Applications of RELOAD are restricted in the data types that be can
      stored in the DHT. The profile of accepted data types for an application
      is referred to as a Usage. RELOAD is designed so that new applications
      can easily define new Usages. New RELOAD Usages are needed for hybrid
      multicast applications since the data types in base RELOAD and existing
      usages are not sufficient.</t>

      <t>We define an ALM Usage and a Hybrid ALM Usage in RELOAD. The ALM
      Usage is sufficient for applications which only require ALM
      functionality in the overlay. The Hybrid ALM (HALM) Usage extends the
      ALM Usage so that hybrid native multicast and ALM trees can be used by
      applications.</t>

      <t>The ALM Uaage involves the functions: <list style="symbols">
          <t>ALM applications use the RELOAD data storage functionality to
          store a groupID when a new ALM tree is created in the overlay, and
          to retrieve groupIDs for existing ALM trees.</t>

          <t>ALM applications use the RELOAD data storage functionality to
          store a set of attributes for an ALM tree, such as owner, tree size,
          tree height, tree formation algorithm, and join criteria.</t>

          <t>ALM applications and management tools use the RELOAD data storage
          functionality to store diagnostic information about the operation of
          tree, including average number of tree, delay from source to leaf
          nodes, bandwidth use, lost packet rate. In addition, diagnostic
          information may include statistics specific to the tree root, or to
          any node in the tree.</t>
        </list> The Hybrid ALM Usage involves the following additional
      functions: <list style="symbols">
          <t>HALM applications use the RELOAD data storage functionality to
          store a set of attributes for a AMT Gateway that can connect to at
          least one node in the overlay.</t>

          <t>HALM applications use the RELOAD data storage functionality to
          store a set of attributes about a native multicast region associated
          with an AMT Gateway.</t>

          <t>HALM applications and management tools use the RELOAD data
          storage functionality to store diagnostic information about the
          operation of AMT and ALM interconnections.</t>
        </list> A RELOAD Usage is required <xref
      target="I-D.ietf-p2psip-base"></xref> to define the following: <list
          style="symbols">
          <t>Register Kind-Id points</t>

          <t>Define data structures for each kind</t>

          <t>Defines access control rules for each kind</t>

          <t>Defines the Resource Name used to hash to the Resource ID where
          the kind is stored</t>

          <t>Addresses restoration of values after recovery from a network
          partition</t>

          <t>Defines the types of connections that can be initiated using
          AppConnect</t>
        </list> The following sections are preliminary steps towards
      formalizing the for ALM and HALM Uages.</t>

      <section title="ALM Usage for RELOAD">
        <t>A ALM GroupID is a RELOAD Node-ID. The owner of a ALM group creates
        a RELOAD Node-ID as specified in <xref
        target="I-D.ietf-p2psip-base"></xref>. This means that a GroupID is
        used as a RELOAD Destination for overlay routing purposes.</t>
      </section>

      <section title="Hybrid ALM Usage for RELOAD">
        <t></t>
      </section>
    </section>

    <section title="Examples">
      <t>TBD.</t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Overlays are vulnerable to DOS and collusion attacks. We are not
      solving overlay security issues. We assume the centralized node
      authentication model as defined in <xref
      target="I-D.ietf-p2psip-base"></xref>.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->

      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.0792"?>
      <?rfc include="reference.RFC.3376"?>
      <?rfc include="reference.RFC.3810"?>
      <?rfc include="reference.RFC.4605"?>
      <?rfc include="reference.RFC.4607"?>
      <?rfc include="reference.RFC.5058"?>

    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

      <?rfc include="reference.RFC.1930"?>
      <?rfc include="reference.RFC.3552"?>
      <?rfc include="reference.RFC.4286"?>

      <?rfc include="reference.I-D.ietf-mboned-auto-multicast"?>
      <?rfc include="reference.I-D.ietf-p2psip-base"?>
      <?rfc include="reference.I-D.ietf-p2psip-sip"?>
      <?rfc include="reference.I-D.matuszewski-p2psip-security-overview"?>
      <?rfc include="reference.I-D.irtf-p2prg-rtc-security"?>
      <?rfc include="reference.I-D.waehlisch-sam-common-api"?>

      <reference anchor="AGU1984" target="">
        <front>
          <title>Datagram Routing for Internet Multicasting</title>

          <author initials="L." surname="Aguilar"></author>

          <date month="March" year="1984" />
        </front>

        <seriesInfo name="ACM Sigcomm 84" value="1984" />
      </reference>

      <reference anchor="CASTRO2002"
                 target="http://research.microsoft.com/en-us/um/people/antr/past/jsac.pdf">
        <front>
          <title>Scribe: A large-scale and decentralized application-level
          multicast infrastructure</title>

          <author initials="M." surname="Castro"></author>

          <author initials="P." surname="Druschel"></author>

          <author initials="A.-M." surname="Kermarrec"></author>

          <author initials="A." surname="Rowstron"></author>

          <date month="October" year="2002" />
        </front>

        <seriesInfo name="IEEE Journal on Selected Areas in Communications"
                    value="vol.20, No.8" />
      </reference>

      <reference anchor="CASTRO2003"
                 target="http://research.microsoft.com/en-us/um/people/mcastro/publications/infocom-compare.pdf">
        <front>
          <title>An Evaluation of Scalable Application-level Multicast Built
          Using Peer-to-peer overlays</title>

          <author initials="M." surname="Castro"></author>

          <author initials="M." surname="Jones"></author>

          <author initials="A.-M." surname="Kermarrec"></author>

          <author initials="A." surname="Rowstron"></author>

          <author initials="M." surname="Theimer"></author>

          <author initials="H." surname="Wang"></author>

          <author initials="A." surname="Wolman"></author>

          <date month="April" year="2003" />
        </front>

        <seriesInfo name="Proceedings of IEEE INFOCOM" value="2003" />
      </reference>

      <reference anchor="HE2005" target="">
        <front>
          <title>Dynamic Host-Group/Multi-Destination Routing for Multicast
          Sessions</title>

          <author initials="Q." surname="He" />

          <author initials="M." surname="Ammar" />
        </front>

        <seriesInfo name="J. Telecommunication Systems"
                    value="vol. 28, pp. 409-433" />
      </reference>
    </references>

    <section anchor="app-additional" title="Additional Stuff">
      <t>This becomes an Appendix.</t>
    </section>
  </back>
</rfc>
