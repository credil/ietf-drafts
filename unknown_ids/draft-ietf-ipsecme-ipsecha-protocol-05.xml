<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type='text/xsl' href='./rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc symrefs="no"?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc strict="yes" ?>
<?rfc linkmailto="yes" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" >

<rfc ipr="trust200902" docName="draft-ietf-ipsecme-ipsecha-protocol-05" category="std">
  <front>
    <title abbrev="High Availability in IKEv2/IPsec">Protocol Support for High Availability of IKEv2/IPsec</title>
    <author initials="R." surname="Singh, Ed." fullname="Raj Singh (Editor)">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>Divyashree Chambers, B Wing, O'Shaugnessy Road</street>
          <city>Bangalore</city>
          <region>Karnataka</region>
          <code>560025</code>
          <country>India</country>
        </postal>
        <phone>+91 80 4301 3320</phone>
        
        <email>rsj@cisco.com</email>
      </address>
    </author>
    <author initials="G." surname="Kalyani" fullname="Kalyani Garigipati">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>Divyashree Chambers, B Wing, O'Shaugnessy Road</street>
          <city>Bangalore</city>
          <region>Karnataka</region>
          <code>560025</code>
          <country>India</country>
        </postal>
        <phone>+91 80 4426 4831</phone>
        <email>kagarigi@cisco.com</email>
      </address>
    </author>
    <author initials="Y." surname="Nir" fullname="Yoav Nir">
      <organization abbrev="Check Point">Check Point Software Technologies Ltd.</organization>
      <address>
        <postal>
          <street>5 Hasolelim St.</street>
          <city>Tel Aviv</city>
          <code>67897</code>
          <country>Israel</country>
        </postal>
        <email>ynir@checkpoint.com</email>
      </address>
    </author>
    <author initials="Y." surname="Sheffer" fullname="Yaron Sheffer">
      <organization abbrev="Independent">Independent</organization>
      <address>
        <email>yaronf.ietf@gmail.com</email>
      </address>
    </author>
    <author initials="D." surname="Zhang" fullname="Dacheng Zhang">
      <organization abbrev="Huawei"> Huawei Technologies Ltd.</organization>
      <address>
        <email>zhangdacheng@huawei.com</email>
      </address>
    </author>
    <date year="2011"/>
    <abstract>
      <t> The IPsec protocol suite is widely used for business-critical network traffic. 
        In order to make IPsec deployments highly available, more scalable and failure-resistant, 
        they are often implemented as IPsec High Availability (HA) clusters.
        However there are many issues in IPsec HA clustering, and in particular in IKEv2 clustering. An earlier
        document, "IPsec Cluster Problem Statement", enumerates the issues encountered in
        the IKEv2/IPsec HA cluster environment. This document resolves these issues with
        the least possible change to the protocol.
      </t>
      
      <t> This document defines an extension to the IKEv2 protocol to solve the main issues of
        "IPsec Cluster Problem Statement" in the commonly deployed hot-standby cluster, 
        and provides implementation advice for other issues.
	The main issues solved are the synchronization of IKEv2
        Message ID counters, and of IPsec Replay Counters.
      </t>
    </abstract>
  </front>
  <middle>
    <!-- ====================================================================== -->
    <section title="Introduction" toc="default">
      <t> The IPsec protocol suite, including IKEv2, is a major building block of virtual private networks (VPNs).
	In order to make such VPNs highly available, more scalable and failure-resistant,
	these VPNs are implemented as 
        IKEv2/IPsec Highly Available (HA) clusters. However there are many issues with the IKEv2/IPsec HA cluster.
	<xref target="sync_problem"/> below
        enumerates the issues around the IKEv2/IPsec HA cluster solution. 
      </t>
      
      <t> In the case of a hot-standby cluster implementation of IKEv2/IPsec based VPNs,
	the IKEv2/IPsec session is first established between the peer and the 
        active member of the cluster. Later, the active member continuously syncs/updates the IKE/IPsec SA state
	to the standby member of the cluster. This 
        primary SA state sync-up takes place upon each SA bring-up and/or rekey.
	Performing the SA state synchronization/update 
        for every single IKE and IPsec message is very costly, so normally it is done periodically.
	As a result, when the failover event happens,
	this is first detected by the standby member and, possibly after a considerable amount of time,
	it becomes the active member.
	During this failover process the peer is unaware of the failover event, and keeps sending IKE requests
	and IPsec packets 
        to the cluster, as in fact it is allowed to do because of the IKEv2 windowing feature.
	After the newly-active member starts, it detects the mismatch in IKE Message 
	ID values and IPsec replay counters and needs to resolve this situation.
	Please see <xref target="sync_problem"/> for more details of the problem. 
      </t>
      
      <t> This document proposes an extension to the IKEv2 protocol to solve the main issues of IKE Message ID
	synchronization and IPsec SA replay counter synchronization and gives 
        implementation advice for others. Following is a summary of the solutions provided in this document:  
      </t>
      
      <t>
      <list style="symbols">
      <t> IKEv2 Message ID synchronization: this is done by syncing up the expected send and receive 
	Message ID values with the peer, and updating the 
	values at the newly active cluster member. 
      </t>
      
      <t> IPsec Replay Counter synchronization: this is done by incrementing the cluster's outgoing
	SA replay counter values by a "large" number; in addition, the newly-active member requests
	the peer to increment the replay counter values it is using for the peer's outgoing traffic.
      </t>
      </list>
      </t>
      
      <t> Although this document describes the IKEv2 Message ID and IPsec replay counter synchronization
	in the context of an IPsec HA cluster, 
	the solution provided is generic and can be used in other scenarios where IKEv2 Message ID or
	IPsec SA replay counter synchronization may be required.
      </t>
      
      <t> Implementations differ on the need to synchronize the IKEv2 Message ID and/or IPsec replay counters.
	Both of these problems are handled separately, using a separate notification for
        each capability. This provides the flexibility of implementing either or both of these solutions.
      </t>
      
    </section>
    
    <!-- ====================================================================== -->

    <section toc= "default" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
        "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in
        <xref target="RFC2119" />.
      </t>
      
      <t> "SA Counter Synchronization Request/Response" are the request viz. response of the informational exchange 
	defined in this document to synchronize the 
	IKEv2/IPsec SA counter information between one member of the cluster and the peer. 
      </t>
      
      <t>
        Some of the terms listed below are reused from  <xref target="RFC6027"/> with further clarification 
        in the context of the current document. 
      </t>
      
      <t>
      <list style="symbols">
      <t> "Hot Standby Cluster", or "HS Cluster" is a cluster where only one of the members is active at any one time. 
        This member is also referred to as the "active" member, whereas the other(s) are referred to as "standby" members.  
        VRRP <xref target="RFC5798"/> is one method of building such a cluster. The goal of the Hot Standby Cluster is to
        create the illusion of a single virtual gateway to the peer(s). 
      </t>
      
      <t> "Active Member" is the primary member in the Hot-Standby cluster. It is responsible for forwarding packets
        on behalf of the virtual gateway.
      </t>
      
      <t> "Standby Member" is the primary backup member. This member takes control, i.e. becomes the active member, after
        the failover event. 
      </t>
      
      <t> "Peer" is an IKEv2/IPsec endpoint that maintains an IPsec connection with the Hot-Standby cluster. The Peer 
        identifies the cluster by the cluster's (single) IP address. If a failover event occurs, the standby member of the
        cluster becomes active, and the peer normally doesn't notice that failover has taken place.
	Although we treat the peer as a single entity, it may also be a cluster.
      </t>
      
      <t> "Multiple failover" is the situation where, in a cluster with three or more members,
        multiple failover events happen in rapid succession, e.g. from M1 to M2, and then to M3.
        It is our goal that the implementation should be able to handle this situation, i.e. 
	to handle the new failover event even if it is still processing the old failover. 
      </t>
      
      <t> "Simultaneous failover" is the situation where two clusters have an IPsec connection between them,
      and failover happens at both ends at the same time. 
      It is our goal that implementations should be able to handle simultaneous failover. 
      </t>
      </list>
      </t>
      
      <t> The generic term "IKEv2/IPsec SA Counters" is used throughout this document.
      This term refers to both IKEv2 Message ID counters and IPsec replay counters.
      According to the IPsec standards, the IKEv2 Message ID counter is mandatory, and used to ensure reliable delivery
      as well as to protect against message replay in IKEv2; the IPsec SA replay counters are optional,
      and are used to provide the IPsec anti-replay feature. 
      </t>
    </section>
    
    <!-- ====================================================================== -->
    
    <section title="Issues Resolved from IPsec Cluster Problem Statement" toc="default">        
      <t>  The IPsec Cluster Problem Statement <xref target="RFC6027"/>
	enumerates the problems raised by IPsec clusters.
        The following table lists the problem statement's sections that are resolved by this document.
        <list style="symbols">  
          <t>  3.2.  Lots of Long Lived State </t>
          <t>  3.3.  IKE Counters</t>
          <t>  3.4.  Outbound SA Counters</t>
          <t>  3.5.  Inbound SA Counters</t>
          <t>  3.6.  Missing Synchronization Messages</t>
          <t>  3.7.  Simultaneous use of IKE and IPsec SAs by Different Members
	    <list style="symbols">  
		<t>   3.7.1.  Outbound SAs using counter modes</t>
	    </list>
          </t>
          <t>   3.8.  Different IP addresses for IKE and IPsec</t>
          <t>  3.9.  Allocation of SPIs</t>
        </list>
      </t>
      

      <t> The main problem areas are solved using the protocol extension defined below, starting with <xref target="sync_solution"/>;
        additionally, this section provides implementation advice for other issues in the following
        subsections.</t>
      <section anchor="lotsofstate" title="Large Amount of State">
        <t> Section 3.2 of the Problem Statement mentions that a lot of state needs to be 
          synchronized for a cluster to be transparent. The actual volume of that data is very much
          implementation-dependent, and even for the same implementation, the amounts of data may
          vary wildly. An IPsec gateway used for inter-domain VPN with a dozen other gateways, and
          having SAs that are rekeyed every 8 hours, will need a lot less synchronization traffic 
          than a similar gateway used for remote access, and supporting 10,000 clients. This is 
          because counter synchronization is proportional to the number of SAs and requires little 
          data, and the setting up of an SA requires a lot of data. Additionally, remote access IKE 
          and IPsec SA setup tend to happen at a particular time of day, so the example gateway with 
          the 10,000 clients may see 30-50 IKE SA setups per second at 9:00 AM. This would require
          very heavy synchronization traffic over that short period of time.</t>
        <t> If a large volume of traffic is necessary, it may be advisable to use a dedicated
          high-speed network interface for synch traffic. When packet loss can be made extremely low,
          it may be advisable to use a stateless transport such as UDP, to minimize network 
          overhead.</t>
        <t> If these methods are insufficient, it may be prudent that for some SAs the entire 
          state is not synchronized. Instead, only an indication of the SA's existence is
          synchronized. This, in combination with a sticky solution (as described in section 3.7
          of the problem statement) ensures that the traffic from a particular peer does not
          reach a different member before an actual failover happens. When that happens, the method
          described in <xref target="I-D.ietf-ipsecme-failure-detection"/> can be used to 
          quickly force the peer to set up a new SA.</t>
      </section>
      <section anchor="needmultiple" title="Multiple Members Using the Same SA">
        <t> In a load-sharing cluster of the "duplicate" variety (see section 3.7 of the problem
          statement) multiple members may need to send traffic with the same selectors. To actually
          use the same SA the cluster would have to synchronize the Replay Counter after every packet,
          and that would impose unreasonable requirements on the synch connection.</t>
        <t> A far better solution would be to not synchronize the outbound SA, and create multiple
          outbound SAs, one for each member. The problem with this option is that the peer might view 
          these multiple parallel SAs as redundant, and tear down all but one of them.</t>
        <t> Section 2.8 of <xref target="RFC5996"/> specifically allows multiple parallel SAs, but 
          the reason given for this is to have multiple SAs with different QoS attributes. So while 
          this is not a new requirement of IKEv2 implementations, we re-iterate here that IPsec 
          peers MUST accept the long-term existence of multiple parallel SAs, even when QoS 
          mechanisms are not in use.</t>
      </section>
      <section anchor="collisions" title="Avoiding Collisions in SPI Number Allocation">
        <t> Section 3.9 of the problem statement describes the problem of two cluster members 
          allocating the same SPI number for two different SAs. This would violate section 
          4.4.2.1 of <xref target="RFC4301"/>. There are several schemes to allow implementations
          to avoid such collisions, such as partitioning the SPI space, a request-response over
          the synch channel, and locking mechanisms. We believe that these are sufficiently robust
          and available so that we don't need to make an exception to RFC 4301, and we can leave 
          this problem for the implementations to solve. Cluster members MUST NOT generate multiple
          inbound SAs with the same SPI.</t>
      </section>
      <section anchor="countermodes" title="Interaction with Counter Modes">
            <t> For SAs involving counter mode ciphers such as CTR <xref target="RFC3686"/> or 
              GCM <xref target="RFC4106"/> there is yet another complication. The initial vector 
              for such modes MUST NOT be repeated, and senders use methods such as counters or 
              LFSRs to ensure this property. For an SA shared between multiple active members (load sharing cases),
	      implementations MUST ensure that no initial vector is ever repeated. Similar concerns apply to an SA failing over from one
	      member to another. See <xref target="RFC6054"/> for a discussion of this 
              problem in another context.</t>
            <t> Just as in the SPI collision problem, there are ways to avoid a collision of initial vectors, and this
              is left up to implementations. In the context of load sharing, parallel SAs are a simple solution to this problem as well.</t>
      </section>
    </section>
     
    <!-- ====================================================================== -->
    
    <section anchor = "sync_problem" title="The IKEv2/IPsec SA Counter Synchronization Problem" toc="default">
      <t> The IKEv2 protocol <xref target="RFC5996"/> states that "An IKE endpoint MUST NOT exceed 
      the peer's stated window size for
        transmitted IKE requests".
      </t>
      
      <t>All IKEv2 messages are required to follow a request-response paradigm. 
        The initiator of an IKEv2 request MUST retransmit the request, until it has received a response from the peer.
        IKEv2 introduces a windowing mechanism that allows multiple requests to be outstanding at a given point of time,
	but mandates
        that the sender's window should not move until the oldest message it has sent is acknowledged.
        Loss of even a single message leads to repeated retransmissions followed by an IKEv2 SA teardown 
	if the retransmissions remain unacknowledged.
      </t>
      
      <t>An IPsec Hot Standby Cluster is required to ensure that in the case of failover, 
	the standby member becomes active immediately.
        The standby member is expected to have the exact value of the Message ID counter as the active member had
	before failover.
        Even assuming the best effort to update the Message ID values from active to standby member, 
	the values at the standby 
        member can still be stale due to the following reasons:
        
        <list style="symbols">         
          
          <t> The standby member is unaware of the last message that was received and acknowledged by the 
            previously active member, as the failover event could have happened before the standby member could be updated.
          </t>
          
          <t> The standby member does not have information about on-going unacknowledged requests sent by
	    the previously active member.
            As a result after the failover event, the newly active member cannot retransmit those requests.
          </t>
        </list>
      </t>
      
      <t> When a standby member takes over as the active member, it can only initialize the Message ID
        values from the previously updated values.
        This would make it reject requests from the peer when these values are stale.
        Conversely, the standby member may end up reusing a stale Message ID value which would cause
	the peer to drop the request.
        Eventually there is a high probability of the IKEv2 and corresponding IPsec SAs getting torn down 
	simply because of a 
        transitory Message ID mismatch and retransmission of requests, negating the benefits of
	the high availability cluster despite the periodic update between the cluster members.
      </t>
      
      
      <t>A similar issue is also observed with IPsec anti-replay counters if anti-replay protection is enabled,
        which is commonly the case. Regardless of how well the ESP and AH SA counters are synchronized from the 
        active to the standby member, there is a chance that the standby member would end up with stale counter values.
	The standby member would then use those stale counter values when sending IPsec packets.
        The peer would reject/drop such packets since when the anti-replay protection feature is enabled,
	duplicate use of counters is not allowed. Note that IPsec allows the sender to skip 
        some counter values and continue sending with higher counter values.
      </t>
      
      <t>We conclude that a mechanism is required to ensure that the standby member has correct Message ID
        and IPsec counter values when it becomes active, 
        so that sessions are not torn down as a result of mismatched counters.
      </t>
      
    </section>
    
    <!-- ====================================================================== -->

    <section title="SA Counter Synchronization Solution" anchor="sync_solution" toc="include">
      
      <t>This document proposes two separate approaches to resolving the issues of mismatched IKE Message ID values and
      IPsec counter values.</t>
      <t>
      <list style="symbols">
      <t>In the case of IKE Message ID values, the newly active cluster member and the peer
      negotiate a pair of new values so that future IKE messages
      will not be dropped.</t>
      <t>For IPsec counter values, the newly-active member and the peer both increment their respective counter values,
      "skipping forward" by a large number, to ensure that no IPsec counters are ever reused.</t>
      </list>
      </t>
      <t>Although conceptually separate, the two synchronization processes would typically take place
      simultaneously.</t>
      
      <t> First, the peer and the active member of the cluster negotiate their ability to
      support IKEv2 Message ID synchronization and/or IPsec Replay Counter synchronization. This is done by
      exchanging one or both of the IKEV2_MESSAGE_ID_SYNC_SUPPORTED and IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED
      notifications during the IKE_AUTH exchange. When negotiating these capabilities, the responder MUST NOT assert
      support of a capability unless such support was asserted by the initiator. Only a capability whose support
      was asserted by both parties can be used during the lifetime of the SA.</t>
      <t>
	This per-IKE SA information is
	shared with the other cluster members.
      </t>
      
      <figure align="left" >
        <artwork align="left" xml:space="preserve"> 
<![CDATA[          
Peer                                                  Active Member
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
HDR, SK {IDi, [CERT], [CERTREQ], [IDr], AUTH, 
     [N(IKEV2_MESSAGE_ID_SYNC_SUPPORTED),]
     [N(IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED),]
     SAi2, TSi, TSr} ---------->

<-------- HDR, SK {IDr, [CERT+], [CERTREQ+], AUTH, 
               [N(IKEV2_MESSAGE_ID_SYNC_SUPPORTED),]
               [N(IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED),] SAr2, TSi, TSr} 
      
]]>          
        </artwork>
         
      </figure>
      
      <t> After a failover event, the standby member MAY use
	the IKE Message ID and/or IPsec Replay Counter synchronization capability when it becomes
	the active member, and provided support for the capabilities used has been negotiated.
	Following that, the peer MUST respond to any synchronization message it receives from
	the newly-active cluster member, subject to the rules noted below.
      </t>
      
      <t>  After the failover event, when the standby member becomes active, it has to synchronize its SA counters
      with the peer. There are now three possible cases:</t>
      <t>
      <list style="numbers">
      <t>The cluster member wishes to only perform IKE Message ID value synchronization. In this case
      it initiates an Informational exchange, with Message ID zero and the sole notification IKEV2_MESSAGE_ID_SYNC.</t>
      <t>If the newly-active member wishes to perform only IPsec replay counter synchronization, it generates
      a regular IKEv2 Informational exchange using the current Message ID values,
      and containing the IPSEC_REPLAY_COUNTER_SYNC
      notification.</t>
      <t>If synchronization of both counters is needed, the cluster member generates a zero-Message ID message
      as in case #1, and includes both notifications in this message.</t>
      </list>
      </t>

	<t>This figure contains the IKE message exchange used for SA counter synchronization. The following
	subsections describe the details of the sender and receiver processing of each message.</t>
      <figure align="left" >
        <artwork align="left" xml:space="preserve"> 
<![CDATA[          
Standby [Newly Active] Member                            Peer
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
HDR, SK {N(IKEV2_MESSAGE_ID_SYNC),
     [N(IPSEC_REPLAY_COUNTER_SYNC)]} -------->
                                
             <--------- HDR, SK {N(IKEV2_MESSAGE_ID_SYNC)}
]]>          
        </artwork>
      </figure>
      
<t>Alternatively, if only IPsec Replay Counter synchronization is desired, a normal Informational exchange
is used, where the Message ID is non-zero:</t>
      
      <figure align="left" >
        <artwork align="left" xml:space="preserve"> 
<![CDATA[          
Standby [Newly Active] Member                            Peer
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
HDR, SK{N(IPSEC_REPLAY_COUNTER_SYNC)} -------->
                                
             <--------- HDR
]]>          
        </artwork>
      </figure>

      <section title="Processing Rules for IKE Message ID Synchronization">
	<t>The newly-active member sends a request containing two counter value, one for the member (itself) and
	another for the peer, as well as a random nonce. We denote the values M1 and P1.
	The peer responds with a message containing two counter
	values, M2 and P2. The goal of the rules below is to prevent an attacker from replaying
	a synchronization message, thereby invalidating IKE messages that are currently in process.</t>
	<t>
	<list style="symbols">
	<t>M1 is the next sender's Message ID to be used by the member. M1 MUST be chosen so that it is larger than
	any value known to have been used. It is RECOMMENDED to increment the known value at least by the
	size of the IKE sender window.</t>
	<t>P1 SHOULD be 1 more than the last Message ID value received from the peer, but may be any higher value.</t>
	<t>The member SHOULD communicate the sent values to the other cluster members, so that if a second
	failover event takes place, the synchronization message is not replayed. Such a replay would result in the eventual
	deletion of the IKE SA (see below).</t>
	<t>The peer MUST reject any received synchronization message if M1 is lower than or equal to the highest
	value it has seen from the cluster. This includes any previous received synchronization messages.</t>
	<t>M2 MUST be at least the higher of the received M1, and one more than the highest sender value received
	from the cluster. This includes any previous received synchronization messages.</t>
	<t>P2 MUST be the higher of the received P1 value, and one more than the highest sender value used by the
	peer.</t>
	<t>The request contains a Nonce field. This field MUST be returned in the response, unchanged.
	A response MUST be silently dropped if the received Nonce does not match the one that was sent.</t>
	<t>Both the request and the response MUST NOT contain any additional payloads, other than an optional
	IPSEC_REPLAY_COUNTER_SYNC notification in the request.</t>
	<t>The request and the response MUST both be sent with a Message ID value of zero.</t>
	</list>
	</t>
	</section>

	<section title="Processing Rules for IPsec Replay Counter Synchronization">
      <t>Upon failover, the newly-active member MUST increment its own Replay Counter
      (the counter used for outgoing traffic),
      so as to prevent the case of its traffic being dropped by the peer as replay. We note that
      IPsec allows the replay counter to skip forward by any amount. The estimate is based on the
      outgoing IPsec bandwidth and the frequency of synchronization between cluster members.
      In those implementations where it is difficult to estimate this value,
      the counter can be incremented by a very large number, e.g. 2**30.
      In the latter case, a rekey SHOULD follow shortly afterwards, to ensure that the counter never wraps around.</t>
      <t>Next, the cluster member estimates the number of incoming messages it might have missed,
      using similar logic. The member sends out a IPSEC_REPLAY_COUNTER_SYNC notification, either
      stand-alone or together with a IKEV2_MESSAGE_ID_SYNC notification.</t>
      <t>If the IPSEC_REPLAY_COUNTER_SYNC is included in the same message as IKEV2_MESSAGE_ID_SYNC, the peer MUST
      process the Message ID notification first (which might cause the entire message to be dropped as a replay).
      Then, it MUST increment the replay counters for all Child SAs associated with the current IKE SA
      by the amount requested by the cluster member.</t>
      </section>
      
    </section>
    
    <section anchor="sync_payload" title="IKEv2/IPsec Synchronization Notification Payloads" toc="default">
      
      <t>This section lists the new notification payload types defined by this extension.</t>
      
      <section   toc="include" title="The IKEV2_MESSAGE_ID_SYNC_SUPPORTED Notification">   
        
        <t>This notification payload is included in the IKE_AUTH request/response to indicate 
          support of the IKEv2 Message ID synchronization mechanism described in this document. 
        </t>
        
        <figure>
           <artwork> <![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Payload  |C|  RESERVED   |         Payload Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]> </artwork> 
        </figure>
        
        <t> The 'Next Payload', 'Payload Length', 'Protocol ID', 'SPI Size', and 'Notify Message Type'
          fields are the same as described in Section 3 of <xref target="RFC5996"/>.
          The 'SPI Size' field MUST be set to 0 to indicate that the SPI is not present in this message.
          The 'Protocol ID' MUST be set to 0, since the notification is not specific to a particular security association. 
          
          The 'Payload Length' field is set to the length in octets of the entire payload, including 
          the generic payload header.  The 'Notify Message Type' field is set to indicate 
          IKEV2_MESSAGE_ID_SYNC_SUPPORTED, value TBD by IANA. There is no data associated with this notification.
        </t>
        
      </section>
      
      <section   toc="include" title="The IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED Notification">   
        
        <t>This notification payload is included in the IKE_AUTH request/response to indicate 
          support for the IPsec SA Replay Counter synchronization mechanism described in this document. 
        </t>
        <figure>
           <artwork> <![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Payload  |C|  RESERVED   |         Payload Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 ]]> </artwork> 
        </figure>
        
        <t> The 'Next Payload', 'Payload Length', 'Protocol ID', 'SPI Size', and 'Notify Message Type'
          fields are the same as described in Section 3 of <xref target="RFC5996"/>
          .
          The 'SPI Size' field MUST be set to 0 to indicate that the SPI is not present in this message.  
          The 'Protocol ID' MUST be set to 0, since the notification is not specific to a particular security association. 
          
          The 'Payload Length' field is set to the length in octets of the entire payload, including 
          the generic payload header.  The 'Notify Message Type' field is set to indicate 
          IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED, value TBD by IANA. There is no data associated with this notification. 
        </t>
        
      </section>
      
      <section   toc="include" title="The IKEV2_MESSAGE_ID_SYNC Notification">   
        <t> This notification payload type (value TBD by IANA) is defined to synchronize
	  the IKEv2 Message ID values between
          the newly-active (formerly standby) cluster member and the peer. 
        </t>
        
        
        <figure>
           <artwork> <![CDATA[

                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Payload  |C|  RESERVED   |         Payload Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Nonce Data                                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             EXPECTED_SEND_REQ_MESSAGE_ID                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             EXPECTED_RECV_REQ_MESSAGE_ID                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 

 ]]> </artwork> 
        </figure>
        <t>
           It contains the following data.<list style ="symbols" > 
            
            <t>  Nonce Data (4 octets): the random nonce data. The data should be identical in the
	    synchronization request and response.
            </t>
            <t> EXPECTED_SEND_REQ_MESSAGE_ID (4 octets): 
              this field is used by the sender of this notification payload to indicate the Message ID it will
	      use in the next request that it will send to the other protocol peer. 
            </t>
            
            <t> EXPECTED_RECV_REQ_MESSAGE_ID (4 octets): this field is used by the sender of this notification payload
              to indicate the Message ID it is expecting in the next request to be received from the other protocol peer.
            </t>
          </list>
           
        </t>
        
      </section>
      
      <section toc="include" title="The IPSEC_REPLAY_COUNTER_SYNC Notification">   
        <t> This notification payload type (value TBD by IANA) is defined to synchronize
	  the IPsec SA Replay Counters between the newly-active (formerly standby) cluster member and the peer.
	  Since there may be numerous IPsec SAs established under a single IKE SA, we do not directly synchronize
	  the value of each one. Instead, a delta value is sent and all Replay Counters for Child SAs
	  of this IKE SA are incremented by the same value. Note that this solution requires that all these
	  Child SAs either use or do not use Extended Sequence Numbers <xref target="RFC4301"/>.
	  This notification is only sent by the cluster.
        </t>
        <figure>
           <artwork> <![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Next Payload  |C|  RESERVED   |         Payload Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
|                 Incoming IPsec SA delta value                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
 ]]> </artwork> 
        </figure>
        
        <t>
           The notification payload contains the following data.

	  <list style ="symbols" > 
            
            <t> Incoming IPsec SA delta value (4 or 8 octets): The sender requests that the peer
	      should increment all the Child SA
	      Replay Counters for the sender's incoming (the peer's outgoing) traffic by this value.
              The size of this field depends on the ESN bit associated with the Child SAs:
	      if the ESN bit is 1, the field's size is 8 octets,
	      otherwise it is 4 octets. We note that this constrains the Child SAs of each IKE SA to either all have
	      the ESN bit on or off.
            </t>
          </list>
        </t>
      </section>
    </section>
    
  <!-- ====================================================================== -->
    
    <section title="Implementation Details" toc="include">
      
      <t> This protocol does not change any of the existing IKEv2 rules regarding Message ID values.</t>
      
      <t>
            The standby member can initiate the synchronization of IKEv2 Message ID's under different circumstances.
	<list style="symbols"> 
          
          <t>  When it receives a problematic IKEv2/IPsec packet, i.e. a packet outside its expected receive window.</t>
          <t> When it has to send the first IKEv2/IPsec packet after a failover event.</t>
          <t>  When it has just received control from the active member and wishes to update the values proactively,
            so that it need not start this exchange later, when sending or receiving the request.
          </t>
        </list>
      </t>
      
      <t>
            The standby member can initiate the synchronization of IPsec SA Replay Counters:
	<list style="symbols"> 
          
          <t>  If there has been traffic using the IPsec SA in the recent past and the standby member
	    suspects that its Replay Counter may be stale.</t>
        </list>
      </t>
      
      <t> Since there can be a large number of sessions at the standby member, and sending synchronization 
	exchanges for all of them may result in overload, the standby member can choose to initiate
	the exchange in a "lazy" fashion: only when it has to
        send or receive the request. In general, the standby member is free to initiate this exchange at its discretion.
      </t>
      
    </section>
<!--==========================================-->
<section title="IKE SA and IPsec SA Message Sequencing">
<t>The straightforward definitions of message sequence numbers, retransmissions and replay protection in IPsec and IKEv2
are strained by the failover scenarios described in this document. This section describes some policy choices
that need to be made by implementations in this setting.</t>
<section title="Handling of Pending IKE Messages">
<t>After sending its "receive" counter, the cluster member MUST reject any incoming IKE messages that
are outside its declared window. A similar rule applies to the peer. Local policies vary, and strict implementations
will reject any incoming IKE message arriving before Message ID synchronization is complete.</t>
</section>
<section title="Handling of Pending IPsec Messages">
<t>For IPsec, there is often a trade-off between security and reliability of the protected protocols.
Here again there is some leeway for local policy. Some
implementations might accept incoming traffic that is outside the replay window for some time after the failover
event. Strict implementations will only accept traffic that's inside the "safe" window.</t>
</section>
<section title="IKE SA Inconsistencies">
<t>IKEv2 is normally a reliable protocol. As long as an IKE SA is valid, both peers share a single, consistent
view of the IKE SA and all associated Child SAs. Failover situations as described in this document may involve
forced deletion of IKE messages, resulting in inconsistencies,
such as Child SAs that exist on only one of the peers. Such SAs would cause an INVALID_SPI to be returned
when used by that peer.</t>
<t>The Working Group discussed at some point a proposed set of rules for dealing with such situations. However
we believe that these situations should be rare in practice; as a result the "default" behavior of tearing
down the entire IKE SA is to be preferred over the complexity of dealing with a multitude of edge cases.
</t>
</section>
</section>
    
<!--==========================================-->
    <section title = "Step by Step Details" toc="default">
      <t>
        This section goes through the sequence of steps of a typical failover event,
	looking at a case where the IKEv2 Message ID 
	values are synchronized.
        
        <list style="symbols">    
          
          <t> The active cluster member and the peer device establish the session.
	  They both announce the capability to synchronize counter information 
            by sending the IKEV2_MESSAGE_ID_SYNC_SUPPORTED notification in the IKE_AUTH Exchange.
          </t>
          
          <t> Some time later, the active member dies, and a standby member takes over.
            The standby member sends its own idea of the IKE Message IDs (both incoming and outgoing)
	    to the peer in an Informational
	    message exchange with Message ID zero. 
          </t>
          
          <t> The peer first authenticates the message. 
	    The peer compares the received values with the values available locally and picks the higher value.
	    It then updates its Message IDs with the higher values and also propose the same values in its response.
          </t>
          
          <t>The peer should not wait for any pending responses while responding with the new Message ID values.
            For example, if the window size is 5 and the peer's window is 3-7, and if the peer has sent
	    requests 3, 4, 5, 6, 7 and received responses only for 4, 5, 6, 7 but not for 3, 
	    then it should include the value 8 in its EXPECTED_SEND_REQ_MESSAGE_ID payload
	    and should not wait for a response to message 3 anymore.
          </t>
          
          <t>  Similarly, the peer should also not wait for pending (incoming) requests.
	    For example if the window size is 5 and 
            the peer's window is 3-7  and if the peer has received requests 4, 5, 6, 7 but not 3,
	    then it should send the value 8 in the 
            EXPECTED_RECV_REQ_MESSAGE_ID payload, and should not expect to receive message 3 anymore.
          </t>
          
        </list>
      </t>
    </section>
    
  <!-- ====================================================================== -->

    <section title="Interaction with other drafts" toc="default">
      <t>
        The usage scenario of the IKEv2/IPsec SA counter synchronization proposal is that an 
	IKEv2 SA has been established between 
        the active member of a hot-standby cluster and a peer, then a failover event occurred with the standby member 
        becoming active. The proposal further assumes that the IKEv2 SA state was continuously synchronized between 
	the active and standby members of the 
        cluster before the failover event.
        
        <list style="symbols">    
          <t>  
            Session resumption <xref target="RFC5723"/> assumes that a peer (client or initiator) 
	    detects the need to re-establish the session. In 
            IKEv2/IPsec SA counter synchronization, it is the newly-active member (a gateway or responder)
            that detects the need to synchronize the SA counter after the failover event. 
            Also in a hot-standby cluster, the peer establishes the IKEv2/IPsec session with a single IP address
	    that represents the whole cluster, so the peer normally does
            not detect the event of failover in the cluster unless the standby member takes too 
	    long to become active and the IKEv2 SA times out by use of the IKEv2
            liveness check mechanism. To conclude, session resumption and SA counter synchronization 
	    after failover are mutually exclusive.
          </t>
          <t> 
            The IKEv2 Redirect mechanism for load-balancing <xref target="RFC5685"/> can be used 
	    either during the initial stages of SA setup (the IKE_SA_INIT and IKE_AUTH exchanges) or after session 
            establishment. SA counter synchronization is only useful after the IKE SA has been established 
	    and a failover event has occurred.
            So, unlike Redirect, it is irrelevant during the first two exchanges. 
	    Redirect after the session has been established is mostly useful for timed
            or planned shutdown/maintenance. A real failover event cannot be detected by the active member 
	    ahead of time, and so using 
            Redirect after session establishment is not possible in the case of failover. 
	    So, Redirect and SA counter synchronization after failover are mutually exclusive.
          </t>
          
          <t> IKEv2 Failure Detection <xref target="I-D.ietf-ipsecme-failure-detection"/>
            solves a similar problem where the peer can rapidly detect that a cluster member has 
	    crashed based on a token. It is unrelated to the current scenario because the goal in
	    failover is for the peer not to notice that a failure has occurred.
          </t>
          
        </list>
      </t>
       
    </section>

  <!-- ====================================================================== -->

    <section anchor="Security" title="Security Considerations" toc="default">
      
      <t>
        Since Message ID synchronization messages need to be sent with Message ID zero, they are potentially
	vulnerable to replay attacks. Because of the semantics of this protocol, 
	these can only be denial-of-service (DoS) attacks, and we are aware of two variants.
        
        <list style="symbols">    
          <t>  Replay of Message ID synchronization request:
            
            This is countered by the requirement that the Send counter sent by the cluster member should
	    always be monotonically increasing, a rule that the peer enforces by silently dropping messages
	    that contradict it. 
          </t>
          <t> Replay of the Message ID synchronization response:
            This is countered by sending the nonce data along with the synchronization payload.
	    The same nonce
            data has to be returned in the response.  Thus the standby member will accept a reply only for the current request.
            After it receives a valid response, it MUST NOT process the same response again and MUST discard 
	    any additional responses.
          </t>
        </list>
      </t>
       
    </section>

    <section title="IANA Considerations" toc="default">
      <t>
        This document introduces four new IKEv2 Notification Message types as
        described in Section 6. The new Notify Message Types must be assigned values between 16396 and 40959.</t>
	<texttable>
	<ttcol>Name</ttcol>
	<ttcol>Value</ttcol>
	<c>IKEV2_MESSAGE_ID_SYNC_SUPPORTED</c>
	<c>TBD by IANA</c>
	<c>IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED</c>
	<c>TBD by IANA</c>
	<c>IKEV2_MESSAGE_ID_SYNC</c>
	<c>TBD by IANA</c>
	<c>IPSEC_REPLAY_COUNTER_SYNC</c>
	<c>TBD by IANA</c>
	</texttable>
    </section>

  <!-- ====================================================================== -->

    <section   toc="default" title="Acknowledgements">
      <t>  We would like to thank Pratima Sethi and Frederic Detienne for their review comments and valuable suggestions
        for the initial version of the document.  
      </t>
      <t>  We would also like to thank the following people (in alphabetical order) for their review comments and valuable 
        suggestions:  Dan Harkins, Paul Hoffman, Steve Kent, Tero Kivinen, David McGrew, and Pekka Riikonen. 
      </t>
      
    </section>
         
  <!-- ====================================================================== -->
  
    <section anchor="history" title="Change Log">
      <t> This section lists all the changes in this document. </t>
      <t> NOTE TO RFC EDITOR: Please remove this section before publication.</t>
      
      <section   toc="include" title="Draft -04"> 
	<t>Extended Sec. 3 for better coverage of other IPsec cluster-related issues, and how they
	are resolved within the existing standards.</t>
      </section>

      <section   toc="include" title="Draft -03"> 
	<t>Clarified the rules for Message ID sync, so that replay attacks can be avoided without a
	failover counter.</t>
	<t>Added wording regarding inconsistent IKE state (basically choosing to ignore the problem) and
	further rules dealing with pending traffic.</t>
	<t>The IPsec replay counter delta value now refers to incoming traffic. The associated
	notification is only sent from the cluster to the peer, and not back.</t>
      </section>

      <section   toc="include" title="Draft -02"> 
        <t> Addressed comments by Yaron Sheffer posted on the WG mailing list. </t>
        
        <t> Numerous editorial changes. </t>
      </section>
      
    <section   toc="include" title="Draft -01"> 
        <t> Added "Multiple and Simultaneous failover' scenarios as pointed out by Pekka Riikonen.</t>
        <t> Now document provides a mechanism to sync either IKEv2 message or IPsec replay counter or both to cater different types of implementations. </t>
        <t> HA cluster's "failover count' is used to encounter replay of sync requests by attacker. </t>
        
        <t> The sync of IPsec SA replay counter optimized to to have just one global bumped-up outgoing IPsec SA counter of ALL Child SAs under an IKEv2 SA. </t>
        
        <t> The examples added for IKEv2 Message ID sync to provide more clarity. </t>
        
        <t> Some edits as per comments on mailing list to enhance clarity. </t>
      </section>
      <section   toc="include" title="Draft  -00"> 
        <t> Version 00 is identical to draft-kagarigi-ipsecme-ikev2-windowsync-04, started as WG 
          document.
        </t>
        <t> Added IPSECME WG HA design team members as authors. </t>
        <t> Added comment in Introduction to discuss the window sync process on WG mailing list to solve some concerns. </t>
      </section>
    </section>
    
    
  </middle>
   
  
  <!-- ====================================================================== -->
  
  <back>    
    <references title="Normative References"> 
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.4301"?>
      <?rfc include="reference.RFC.5996"?>
      
    </references>
    
    <references title="Informative References">
      <?rfc include="reference.RFC.3686"?>
      <?rfc include="reference.RFC.4106"?>
      <?rfc include="reference.RFC.5685"?>
      <?rfc include="reference.RFC.5723"?>
      <?rfc include="reference.RFC.5798"?>
      <?rfc include="reference.RFC.6027"?>
      <?rfc include="reference.RFC.6054"?>
      <?rfc include="reference.I-D.ietf-ipsecme-failure-detection"?>
    </references>
    <!-- ====================================================================== -->
    
    <section anchor="Examples" title="IKEv2 Message ID Sync Examples" toc="default">
      
      <t>
        This (non-normative) section presents some examples that illustrate how the IKEv2 Message ID values 
	are synchronized.
        We use a tuple notation, denoting the two counters EXPECTED_SEND_REQ_MESSAGE_ID and EXPECTED_RECV_REQ_MESSAGE_ID
        on a member as (EXPECTED_SEND_REQ_MESSAGE_ID, EXPECTED_RECV_REQ_MESSAGE_ID). 
      </t>
      <section title="Normal Failover - Example 1">
      
      <figure align="left" >
        <artwork align="left" xml:space="preserve"> 
<![CDATA[
Standby (Newly Active) Member                            Peer
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Sync Request (2, 3) -------->
                    
                          Peer has the values (4, 5) so it sends             
             <------------- (4, 5) as the Sync Response
]]>
        </artwork>
         
      </figure>
      </section>
      <section title="Normal Failover - Example 2">
      <figure align="left" >
        <artwork align="left" xml:space="preserve"> 
<![CDATA[
Standby (Newly Active) Member                            Peer
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Sync Request (2, 5) -------->
                    
                          Peer has the values (2, 4) so it sends   
             <-------------(5, 4) as the Sync Response
]]>
        </artwork>
         
      </figure>
      </section>
      <section title="Simultaneous Failover">
      
      
      <!-- YS: Do we have convergence in the case of simultaneous failover? -->
      <t>In the case of simultaneous failover, both sides send the synchronization request,
      but whichever side has the higher value will be eventually synchronized.
      </t>
      <figure align="left" >
        <artwork align="left" xml:space="preserve"> 
<![CDATA[
Standby (Newly Active) Member                            Peer
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Sync Request (4,4)     ----->

                 <-------------- Sync Request (5,5)

Sync Response (5,5)    ---->

                     <--------  Sync Response (5,5)
]]>
        </artwork>
         
      </figure>
      </section>
    </section>
  </back>
</rfc>
