<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<!-- This is built from a template for a generic Internet Draft. Suggestions for
     improvement welcome - write to Brian Carpenter, brian.e.carpenter @ gmail.com -->

<!-- This can be converted using the Web service at http://xml.resource.org/experimental.html
     (which supports the latest, sometimes undocumented and under-tested, features.) -->

<?rfc toc="yes"?>            <!-- You want a table of contents -->
<?rfc symrefs="yes"?>        <!-- Use symbolic labels for references -->
<?rfc sortrefs="yes"?>       <!-- This sorts the references -->
<?rfc iprnotified="no" ?>    <!-- Change to "yes" if someone has disclosed IPR for the draft -->
<?rfc compact="yes"?>

<!-- You need one entry like the following for each RFC referenced -->


<!ENTITY RFC2119 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119'>
<!ENTITY RFC2101 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2101'>
<!ENTITY RFC0959 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.0959'>
<!ENTITY RFC3484 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3484'>
<!ENTITY RFC4903 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4903'>
<!ENTITY RFC4091 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4091'>
<!ENTITY RFC4092 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4092'>
<!ENTITY RFC4007 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4007'>
<!ENTITY RFC4193 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4193'>
<!ENTITY RFC2775 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2775'>
<!ENTITY RFC1918 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1918'>
<!ENTITY RFC4861 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4861'>
<!ENTITY RFC4291 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4291'>
<!ENTITY RFC1958 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1958'>
<!ENTITY RFC1035 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035'>
<!ENTITY RFC5201 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5201'>
<!ENTITY RFC5226 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226'>
<!ENTITY RFC3234 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3234'>
<!ENTITY RFC3323 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3323'>


<!ENTITY RFC2629 PUBLIC ''
  'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629'>



<!-- You need one entry like the following for each I-D referenced -->

<!ENTITY DRAFT-ice SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-mmusic-ice.xml">
<!ENTITY DRAFT-turn SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-behave-turn.xml">
<!ENTITY DRAFT-atypes SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.boucadair-sipping-ipv6-atypes.xml">
<!ENTITY DRAFT-sipriv SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-sip-ua-privacy.xml">


<!-- This defines the specific filename and version number of your draft (and inserts the appropriate IETF boilerplate -->
<rfc ipr="trust200902" docName="draft-carpenter-behave-referral-object-00" category="std">  


<front>
<title abbrev="Generic Referral Object">A Generic Referral Object for Internet Entities</title>


<author initials="B. E." surname="Carpenter" fullname="Brian Carpenter" role="editor">
    <organization abbrev="Univ. of Auckland"></organization>
    <address>
      <postal>
        <street>Department of Computer Science</street>
        <street>University of Auckland</street>
        <street>PB 92019</street>
        <city>Auckland</city>
        <region></region>
        <code>1142</code>
        <country>New Zealand</country>
      </postal>
      
      <email>brian.e.carpenter@gmail.com</email>
    </address>
</author>

<author fullname="Mohamed Boucadair" initials="M."  surname="Boucadair">
      <organization>France Telecom</organization>
      <address>
        <postal>
          <street>3, Avenue François Châteaux</street>
                   <city> Rennes</city>
         <code>35000</code>
         <country>France</country>
        </postal>
        <email>mohamed.boucadair@orange-ftgroup.com</email>
      </address>
</author>

<author initials="S." surname="Brim" fullname="Scott Brim">
    <organization abbrev="Cisco">Cisco</organization>
    <address>
      <postal>
        <street>146 Honness Lane</street>
        <city>Ithaca</city>
        <region>NY</region>
        <code>14850</code>
        <country>US</country>
      </postal>
      <email>swb@employees.org</email>
    </address>
</author>    

    <author fullname="Joel M. Halpern" initials="J.M.H." 
            surname="Halpern">
      <organization abbrev="Ericsson">Ericsson</organization>
      <address>
        <postal>
          <street>P. O. Box 6049</street>
          <city>Leesburg</city>
          <region>VA</region>
          <code>20178</code>
          <country>US</country>
        </postal>
        <email>jhalpern@redback.com</email>
      </address>
    </author> 

   <author fullname="Sheng Jiang" initials="S.J." surname="Jiang">
      <organization>Huawei Technologies Co., Ltd</organization>
      <address>
        <postal>
          <street>KuiKe Building, No.9 Xinxi Rd.,</street>
          <city>Shang-Di Information Industry Base, Hai-Dian District, Beijing</city>
          <country>P.R. China</country>
        </postal>
        <email>shengjiang@huawei.com</email>
      </address>
    </author>


<author initials="K." surname="Moore" fullname="Keith Moore">
<organization abbrev="Network Heretics">Network Heretics</organization>
    <address>
      <email>moore@network-heretics.com</email>
    </address>
</author>   

 
<date day="11" month="May" year="2009" />

<area>Transport</area>
<workgroup>BEHAVE</workgroup>

 


<abstract>

<t>The purpose of a referral is to enable a given entity in a multiparty application to pass information to another party. This memo specifies a Generic Referral Object (GRO) to be used in the context of referrals. The proposed object is compact and is application-independent. Both IPv4 and IPv6 schemes are supported, as well as upper layer identifiers. Additional information to characterise an enclosed reference is also described. To allow proper interpretation of referrals,
a new notion of scope identifiers is introduced.
</t>
    
</abstract>
</front>

<middle>
<section anchor="intro" title="Introduction and Motivation">


<t>A frequently occurring situation is that one entity A connected to the Internet (or to some private network
using the Internet protocol suite) needs to inform another entity B how to reach either A itself or some third-party entity C. This is known as a referral.</t>

<t>In the original design of the Internet, IP addresses were global, unique, and quasi-permanent.
Also any differentiation beyond that provided by an IP address was done by protocol and port numbers. Referrals
were therefore performed simply by passing an IP address and possibly protocol and port numbers. 
In fact simple referrals (the first case above,
sometimes called first-party referrals) were never
needed since B could simply use A's address. Third-party referrals were trivial: A would tell B about C's address.
Thus, it became common practice to pass raw addresses between entities. A classical example is the FTP
PORT command <xref target="RFC0959"/>.</t>

<t>Unfortunately, this simple approach to referrals often fails in today's Internet. As has been
known for some time <xref target="RFC2101"/>, addresses no longer all have global scope, and
may have limited lifetime. Both addresses and port numbers may be different on either side of a
NAT or some other middlebox <xref target="RFC3234"/>, and firewalls may block them. 
Also, the Internet now has two coexisting address formats for IPv4
and IPv6. Sending an out-of-scope or expired address, or one of the wrong format, as a referral
will fail.</t>

<t>In some cases, this problem may be readily solved by passing a Fully Qualified Domain Name (FQDN)
instead of an address. Indeed, that is an architecturally preferred solution <xref target="RFC1958"/>.
However, it is not sufficient in many cases of dynamic referrals. 
Experience shows that an application cannot use a
domain name in order to reliably find the address(es) of an arbitrary
peer.  Domain names work fairly well to find the addresses of servers,
as in web servers or SMTP servers, because operators of public servers
take pains to make sure that their domain names work.  But DNS records
are not as reliably maintained for arbitrary hosts such as might need to
be contacted in peer-to-peer applications.   Many small networks do not even
maintain DNS entries for their hosts, and for some networks that do list
local hosts in DNS, the listings may well be unusable from a remote
location (say because of two-faced DNS, or because the A record contains
a private address). Furthermore, an FQDN may not be sufficient to establish successful communications involving heterogeneous peers (i.e. IPv4 and IPv6) since A and AAAA records may not be correctly provisioned.  
</t>

<t>Another problem is that an application does not have a reliable way of
knowing its own domain name - or to be more precise, a way of knowing a
domain name that will allow the application to be reached from another
environment.</t>

<t>For these reasons, the problem of address referrals cannot be solved just
by recommending the use of FQDNs instead.</t>

<t>The first motivation for this draft is the observation that unless the
parties involved have reached an understanding about the scope,
lifetime, and format of the elements in a referral through some other
means, that information must be passed with the referral.  This is
required so that the receiving entity can determine whether or not the
referral is useful.</t>

<t>When a referral fails, good design suggests that the receiving entity should attempt
to correct the situation. For example, if communication fails to be established using an 
IP address, it would often be appropriate to attempt a DNS lookup. 
The second motivation for this draft is that it may be helpful to the
entity receiving a referral to also receive information about the source of the referral,
such as an FQDN, if that is known to the sender of the referral.  
The receiving entity can then attempt to recover a valid address (and possibly port number) 
for the referred entity.
</t>

<t>It should be noted that partial or application-specific solutions to this problem
abound. A non-normative Appendix gives examples, in the form of use cases. 
The objective of this specification is to define a generic and extensible
solution, to allow more robust application design. It is an open question whether
existing applications will benefit from retro-fitting GROs, or whether they will
mainly be of use for new applications.</t>

 <section title="Terminology">
 <t>This document makes use of the following terms:</t>
 <list style="symbols">
  <t>"Generic Referral Object (GRO)": the data object defined by this specification.</t>
  <t>"Entity": we use this rather than "application" to describe any software component embedded in
  a host, not just a specific application, that sends, receives or makes use of GROs. Also,
  in case of dynamic load sharing or failover, an entity might even migrate between hosts. </t>
  <t>"Referral": the act of one entity informing another entity how to contact a specific entity.</t>
  <t>"Reference": the actual data (name, address, identitifier, locator, pointer, etc.) that is
     the basis of a referral. </t>
  <t>"Scope Identifier (ScopeID): an identifier for the scope of validity of a reference. </t>
  <t>"Qualifier": a data item that gives additional information about a Reference. </t>
  <t>"Referring entity": the entity that sends a referral.</t>
  <t>"Receiving entity": the entity that receives a referral.</t>
  <t>"Referenced entity": the entity described in a GRO.</t>
 </list>
 </section>

 <section title="Normative Notation">
 <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.</t>
 </section>
</section> <!-- intro -->

<section anchor="reqts" title="Summary of Requirements">

<t>A GRO should be self-describing; that is to say, even if it is forwarded several
times across the network, the ultimate receiving entity should be able to extract
and interpret all the information inserted by the original referring entity.</t>

<t>A GRO should be compact (i.e., binary encoded) and designed for efficient processing.</t>

<t>The GRO format must not be specific to a given IP version and
must not be application-specific. </t>


<t>A GRO should contain information that the
referring entity can provide about the scope, lifetime, format
and source of the referral, encoded in a universal format. </t>

<t>The GRO format should be extensible with well-defined backwards compatibility. </t>

<t>A damaged GRO would be useless.  However, 
to maintain efficiency, intrinsic error detection or correction for GROs should not be mandatory.
Therefore, GROs SHOULD be sent over a channel supporting error detection or correction.</t>

<t>A forged GRO would be at least as dangerous as a forged IP address. However, 
to maintain efficiency, intrinsic cryptographic authentication of GROs should not be mandatory. 
The use of an authenticated channel to transmit GROs is RECOMMENDED.</t>

<t>An intercepted GRO would be at least as revelatory as an intercepted IP address.
However, to maintain efficiency, intrinsic encryption of GROs should not be mandatory.
The use of an encrypted channel to transmit GROs is RECOMMENDED.</t>

</section> <!-- reqts -->

<section anchor="semantics" title="Referral Semantics and Scope Identifiers">

<t>The principal purpose of a referral is to enable one entity in a multi-party
application to pass information to another party involved in the same application.
This specification makes no assumptions about whether the entities are acting
as clients, servers, peers, super-nodes, relays, proxies, etc., as far as the 
application is concerned. Neither
does it take a position as to how the various entities become aware of the need to
send a referral; this depends entirely on the structure of the application. </t>

<t>It is the
responsibility of the referring entity to construct a GRO on the basis of information
in its possession.
It is the responsibility of the receiving entity to interpret
and check this information. Due to the fluidity of connectivity in today's Internet,
the referring entity cannot guarantee that the referenced entity can be reached. This
can only be checked by the receiving entity. In the event of a reachability problem,
information in the GRO may assist the receiving entity to find an alternative path. </t>

<t> Since the most fundamental quantity likely to be conveyed in a GRO is an IP address,
(and possibly a port number) its scope is a key question. 
Address scope is not a simple concept, as shown by the discussion in <xref target="RFC4007"/>
and the practical difficulties caused by <xref target="RFC3484"/>. Even the concept of link-local
scope is complicated by the existence of multi-link subnets <xref target="RFC4903"/>. For the purpose
of referrals, it seems that previous formalisations of the concept of scope
are inadequate. Assuming that a GRO is trustworthy, one question that a receiving entity 
must answer is: can the address in this GRO be reached from here? That question is not answered by knowing only
the scope (in the sense of RFC4007) as defined at the location of the referring entity. 
For that reason, scope is represented in a new way in GROs. Firstly, the scope is qualified
(to the best of the referring entity's knowledge) as follows:</t>
<list style="symbols">
    <t>Null. The address is known not to be applicable outside the referring host (e.g., a loopback
        address). This option is provided mainly for completeness. There is no value in such a GRO,
        and for privacy reasons it should not be communicated anyway.</t>
    <t>Link. Apart
       from the standard Ethernet-like view of link locality, this scope would also apply
       to point-to-point links and to fragments of a multi-link subnet. Although on-link referrals
       should be trivial, this case is included to allow for uniform design of applications
       utilising GROs, so that link-local does not become a special case. </t>
    <t>Limited. The address has applicability beyond the link, but it is known not to have global
        applicability. Examples include IPv4 private addresses <xref target="RFC1918"/> and
        IPv6 Unique Local Addresses <xref target="RFC4193"/>. Other cases include addresses on subnets
        which the referring entity knows to be obstructed by firewalls, network address translators,
        or other barriers to transparency <xref target="RFC2775"/>.</t>
    <t>Global. The address has applicability beyond the link, and is believed to have global
        applicability within its address family.</t>
</list>
<t>However, particularly in the case of limited scope, this is insufficient for the receiving entity
to decide whether the address is applicable in the receiving entity's context. The scopes above
are described as if they were a set of concentric circles, but reality is more complex, and limited
scopes might overlap each other in an arbitrary way, for example when multiple VPNs are formed.
Indeed, a referring entity may or may not be aware that the receiving entity and the referenced entity
are within a link scope or limited scope that does not contain the referring entity. Therefore, a GRO may
also include a scope identifier (ScopeID), which is an arbitrary label for a region of the network within
which certain link or limited scope addresses are applicable.</t>

<t>There needs to be a high level of assurance that ScopeIDs are unique, or at least
that a GRO will never be forwarded outside a region in which ScopeIDs are unique. 
Also, all referring and receiving entities need to be aware of the ScopeID(s)
that apply to them. However, it is clearly undesirable to create a new global registration 
scheme for ScopeIDs.
</t>
<t>The delimiter of a limited scope will in many cases be the device
(firewall or NAT) that obstructs transparency. A tempting solution would be to use
some unique identifier of that device as the unique ScopeID. Unfortunately, this
cannot be an IP address of the device, since in the case of nested NATs, all its addresses
may be ambiguous. Neither can we rely on such a device having its own FQDN, or on that
FQDN being known to all entities within the scope concerned. Finally, some limited scopes
may not be hidden behind a single such device; for example, a limited scope might
consist of a company's network and selected VPN connections to subsets of several business
partners' networks. Alternatively, multiple limited scopes might be hidden behind the
same device. Device addresses are therefore not suitable as ScopeIDs.
</t>
<t>Therefore, a limited scope can best be defined as whatever set of referring and receiving
entities have been configured (statically or dynamically) to accept a given ScopeID
in some unambiguous namespace (see <xref target="scopid"/>).</t>

<t>Methods for configuring, advertising and discovering ScopeIDs are not defined in this document.
However, in their absence, it is extremely hard for receiving entities to interpret
and use information about limited scopes.
To the extent possible, all entities involved in referrals should
determine what scope is shared between the referred entity and the
receiving entity, by any means. Those means are not covered in this
document, but may include use of external services, agreement on scope
identifiers, or direct negotiation. </t>
  <list style="symbols">
  <t>If shared scope (or set of scopes) is determined, a referral should ideally only include
     information useful in that scope or set of scopes. </t>

  <t>If shared scope is uncertain, a referral should include all
     information that might be useful, taking privacy considerations into
     account. </t>
  </list>

<t>In general, the referring entity cannot know the scope in which
the GRO will be interpreted. For example, the initial receiving entity may itself be
behind a NAT, unknown to the referring entity, or the receiving entity
may send the GRO onwards to another host in yet another scope. In practice,
we have to leave the receiver to decide whether certain information is useful
or not. In the case of a ScopeID in particular, the referring entity
is not required to know which ScopeIDs apply to the receiving entity. </t>

<t>Discovery or negotiation of ScopeIDs between referring, referenced and
receiving entities is certainly a possibility, but may be expensive, and is
not assumed by this specification. </t>

<t>A referring entity may obtain the address and port number for the referenced entity
in various ways, and knowledge about this may help the receiving 
entity when combined with scope information. For example,
if the receiving entity is aware that the address has been translated, and that it has global
scope, it may choose to use it without further checks. If it is not marked as translated,
and has limited scope, the receiving entity may then verify whether it has a suitable ScopeID. </t>

<t>To enable such logic, a GRO may describe the source of an address or port number. How knowledge
of this source is obtained is outside the scope of the present specification, but ICE
<xref target="I-D.ietf-mmusic-ice"/> is an example method. It is also out of scope here
to describe exactly how the receiving entity uses the information; for example GRO semantics do
not include or imply preferences or priorities when multiple addresses are provided. 
The receiving entity may choose to use a predefined policy, apply general logic as sketched in the
previous paragraph, or follow application-specific logic, all based on the data provided
in a GRO. </t>

<t>Obviously, a GRO is no use unless it contains at least one item that can be used to
find a path to the referred entry. One option would be to make the presence of at least one IP address
mandatory. However, there are alternatives, the most obvious one being an FQDN. Any form of identifier-locator
separation, with HIP <xref target="RFC5201"/> as an example, may also offer an alternative. Therefore, we
do not require a GRO to include an IP address, even though its inclusion is a very likely case. </t>

</section> <!-- semantics -->

<section anchor="grof" title="Generic Referral Object Format">

<t>A GRO is composed of a sequence of binary-encoded type-length-value fields (TLVs) 
transmitted in network byte order. The TLV format is as follows:</t>

<artwork>

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+..
|   GRType    |Q|   GRLength    |          GRValue               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+..

</artwork>

<t>A GRO MUST include at least one reference that allows a receiving entity to attempt to
establish a path to the referred entity. A typical case is an IPv4_address or IPv6_address TLV. Multiple
references may be present, and their order is not significant. </t>

<t>Apart from this, all TLVs are OPTIONAL. </t>

<t>[[ Discusssion invited: At the moment, there is no total length field or end flag for the whole GRO, assuming
that GROs will be sent in some kind of container. Opinions among the authors vary about whether
this is OK. ]]</t>

<t>GRType: Specifies the type of the current TLV. GRType is encoded in 7 bits.
The initially specified types are, in decimal: </t>
 <list>
 <t>0: EOQ.</t>
 <t>1: IPv4_address.</t>
 <t>2: IPv6_address.</t>
 <t>3: FQDN.</t>
 <t>4: HIT. </t>
 <t>5: HI. </t>
 <t>65: IPv4_mask.</t>
 <t>66: IPv6_mask.</t>
 <t>67: Ref_lifetime.</t>
 <t>68: Ref_source.</t>
 <t>69: Ref_scope.</t>
 <t>70: ScopeID.</t>
 <t>71: Port_number. </t>
 <t>72: Transport_protocol. </t>
 <t>73: Port_source. </t>
 <t>127: reserved.</t>
 </list>
<t>A receiving entity MUST silently ignore any TLV with an unknown or reserved GRType.</t>
<t>Each TLV is classified semantically as a reference or as a qualifier. A qualifier
provides extra information about a reference or another qualifier.. </t>

<t>[[ Discusssion invited: Do we need a syntactic method of distinguishing references
from qualifiers? Since unknown TLVs are always discarded, why would that be needed? ]]</t>

<t>Q bit: If this bit is set to 1, the current TLV is followed by one or more TLVs
that qualify it.</t>

<t>GRLength: The length in bytes of the GRValue field. Thus, the total length of the
TLV is GRLength+2 bytes.</t>

<t>GRValue: The content and encoding depend on GRType. Any padding required to fill
an integral number of bytes MUST consist of a sequence of zero bits at the end of the content.</t>

<section title="End of Qualifiers (EOQ)">
<t>This TLV follows the last TLV that qualifies a TLV whose Q bit is set to 1. 
Its GRLength must be set to 0.</t>
<t> The Q bit and EOQ MAY be used recursively, so that qualifiers may themselves be qualified if that
proves to be useful. </t>
<artwork>
    Example (GT=GRType):

    GT Q|GT Q|GT Q|GT Q|GT Q|GT Q|GT  Q|GT  Q 
    A  1|xx 0|xx 0|B  1|xx 0|xx 0|EOQ 0|EOQ 0
                        &lt;-------> Qualifiers of B
         &lt;----------------------------> Qualifiers of A    
</artwork>

<t> The Q bit MUST NOT be set in an EOQ TLV. </t>
</section>

<section title="IPv4 and IPv6 Addresses (references)">
<t>IPv4 and IPv6 addresses are encoded in their normal binary form, 
with GRLength being 4 and 16 respectively. </t>

<t>When multiple addresses are provided, their order does not imply an order of preference.
The receiving entity SHOULD apply a local policy and mechanism to choose between alternative addresses,
using other information included in the GRO appropriately. 
This document does not describe such policies and mechanisms, which could be 
application specific. </t>
</section>

<section title="FQDN (reference)">
<t>The Fully Qualified Domain Name of the referenced entity in ASCII format according to <xref target="RFC1035"/>.
</t>
<t>The GRLength is variable (maximum 63).</t>

<t>[[ Discussion invited: Is there also value in a generic URI item? 
See section on Extensibility below for a related discussion point. ]]</t>
</section>

<section title="HIT (reference)">
<t>The Host Identity Tag of the referenced entity <xref target="RFC5201"/>. </t>
<t>The GRLength must be set to 16.</t>


</section>

<section title="HI (reference)">
<t>The Host Identifier of the referenced entity <xref target="RFC5201"/>. </t>
<t>The GRLength is variable.</t>

<t>[[ Discussion invited: Is this necessary in order to run the HIP base exchange? 
The HI is a large object to include in a GRO. Also, do we need a more precise
definition of what the HI is (see section 5.2.8 of RFC5201)? ]] </t>
</section>


<section title="IPv4 and IPv6 Masks (qualifiers)">
<t>IPv4 and IPv6 masks are encoded in their normal binary form, 
with GRLength being 4 and 16 respectively. </t>


</section>


<section title="Ref_lifetime (qualifier)">
<t>Remaining lifetime in seconds of the reference that it qualifies, encoded as a 32 bit binary
number in the format of an IPv6 Valid Lifetime <xref target="RFC4861"/>. 
GRLength must be set to 4.</t>
<t>
If the lifetime is absent, or if it indicates an infinite lifetime <xref target="RFC4861"/>, 
the receiving
entity MUST assign a lifetime of one day to the corresponding reference.</t>

<t>The receiving entity MUST count down a received lifetime appropriately. 
If the GRO is forwarded to an additional receiving entity, the lifetime
MUST be updated appropriately. </t>

<t>[[ Discussion invited: would it be better to specify an expiry timestamp? ]] </t>

<t>[[ Discussion invited: is the default of one day reasonable? ]] </t>
</section>

<section title="Ref_source (qualifier)">
<t>This is a single byte indicating the source of the reference that it qualifies. GRLength must be set to 1.
The following values may be used:
</t>
<list> <t>0: source was static configuration</t>
       <t>1: source was DNS lookup</t>
       <t>2: source was DHCP or DHCPv6</t>
       <t>3: source was SLAAC</t>
       <t>4: relayed address (e.g. from TURN <xref target="I-D.ietf-behave-turn"/>
             or SOCKS) </t>
       <t>5: translated address. ("server reflexive" in ICE
             <xref target="I-D.ietf-mmusic-ice"/> terminology.)</t>
</list>
<t>A receiving entity MUST silently ignore unknown values.</t>
</section>

<section title="Ref_scope (qualifier)">
<t>This is a single byte indicating the scope of the reference that it qualifies. GRLength must be set to 1.
The scopes are explained in <xref target="semantics"/>. The currently defined values are as follows:</t>
<list> <t>0: Null</t>
       <t>1: Link</t>
       <t>2: Limited</t>
       <t>7: Global. Note that some unused values precede this value, in case of future changes.</t>
</list>
<t>A receiving entity MUST silently ignore unknown values.</t>
<t>References qualified with the Null value SHOULD NOT be sent and MUST be silently 
ignored by a receiving entity.</t>
<t>When a receiving entity receives a reference qualified with a Link or Limited Ref_scope,
and without a ScopeID, it should take locally defined steps to check whether the reference is in fact
within a reachable scope. </t>
</section>

<section anchor="scopid" title="ScopeID (qualifier)">

<t>A ScopeID, if present, is a label for the scope of the reference that it qualifies.</t>

<t>When a receiving entity receives a reference qualified with a Ref_scope
and a ScopeID, it should verify the ScopeID against a list of ScopeIDs known to be reachable
and if not, take other locally defined steps to check whether the reference is in fact
within a reachable scope. </t>

<t>ScopeIDs should be reasonably certain
to be unique, yet require no new system for central administration. </t>

<t>[[ Discusssion invited: It isn't clear to the authors that a single syntax for
ScopeID is sufficient. Should we allow for subtypes, so that (e.g.) ULA format
and FQDN format would both be possible? The following proposal is tentative. ]]</t>

<t>The proposed method is that 
each organisation that needs to define a ScopeID will first generate a ULA prefix
as defined in <xref target="RFC4193"/>, and then form a specific IPv6 address using
that ULA prefix. It is RECOMMENDED to form an address using a valid universal
EUI-64 interface identifier according to <xref target="RFC4291"/>, and this EUI-64
identifier MAY be the same one as used in the RFC4193 procedure.</t>

<t>The GRLength must be set to 16. The GRValue is the ScopeID in the format of an
IPv6 address, although it will be treated entirely as an opaque binary value in
the GRO referring and receiving entities. </t>
</section>


<section title="Port_number (qualifier)">
<t>The inbound TCP/UDP/SCTP/DCCP port number associated with the reference that it qualifies. 
The port number may be bound to a specific transport protocol (see next item).</t>
<t>The GRLength must be set to 2.</t> 
<t>This TLV MAY be qualified by Transport_protocol or Port_source TLVs. 

An IP address may be qualified by zero, one or several Port_number TLVs.</t>

</section>

<section title="Transport_protocol (qualifier)">
<t>This is a single byte indicating the IPv4  protocol number or IPv6 Next Header value used with the reference or Port_number that it qualifies. GRLength must be set to 1. </t>

<t>A receiving entity MUST silently ignore unknown values.</t>
</section>


<section title="Port_source (qualifier)">
<t>This is a single byte indicating the source of the Port_number that it qualifies. GRLength must be set to 1.
Accepted values are:</t>
<list> <t>0: direct (i.e. known to be the original port number used by the referenced entity)</t>
       <t>4: relayed port (e.g. from TURN <xref target="I-D.ietf-behave-turn"/>
             or SOCKS) </t>
       <t>5: translated port. ("server reflexive" in ICE
             <xref target="I-D.ietf-mmusic-ice"/> terminology.)</t>     
</list>
<t>[[ Discussion invited: Is this distinction usfeul? ]]</t>
<t>The assigned values were chosen to align with those for Ref_source. 
A receiving entity MUST silently ignore unknown values.</t>
</section>



<section anchor="extens" title="Extensibility">
<t>Additional GRTypes may be assigned in the range up to 126 by IANA action as defined in 
<xref target="iana"/>. The documentation of a new GRType must specify its name, define its
GRLength, and describe the contents and meaning of its GRValue, including whether it is
a reference or a qualifier. </t>

<t>This extensibility is not intended to allow a GRO to grow enough to
contain every possible kind of application-layer identifier
that could ever be used in a referral, because then it would be too hard
to write a generic "please connect me to the peer at this GRO" function. Thus, additional
GRTypes SHOULD NOT be assigned except for generic purposes that will apply to multiple
applications. Similarly, additional sub-types for Address_source, Address_scope,
Transport_protocol, and Port_source SHOULD NOT be assigned except for generic purposes. </t>

<t>[[ Discussion invited: Sheng Jiang suggested that there should be a generic 'Application-specific
ID' GRType, for example in URI format. A problem with this is that it might end up
as a catch-all like a DNS TXT record, and threaten interoperability as a result. ]] </t>

<t>The reserved GRType value 127 is intended to be used to define an extended 
range of GRTypes in the highly unlikely event that this becomes necessary. </t>

</section>
</section> <!-- grof -->


<section anchor="security" title="Security Considerations">

<t>Forged or intercepted GROs would enable a wide variety of attacks. 
Although not fundamentally different from attacks based on forged or observed IP addresses or FQDNs, no doubt 
GROs would allow such attacks to be more ingenious, simply because they provide more information than 
an address or FQDN alone. As noted in <xref target="reqts"/>, GROs SHOULD be transmitted through authenticated and encrypted channels. Since this is a requirement of the channel and not of the GRO, and the channel used
depends on a specific use case, it is not further elaborated here. </t>

<t>GROs are variable length objects with no defined maximum length. It is possible that a malicious GRO
could be constructed, with harmful code masquerading as legitimate or unknown GRType items.
All implementations of receiving entities MUST guard against buffer overflows, as well as obeying
the rules about ignoring unknown values in <xref target="grof"/>. </t>

<t>Unknown TLVs in GROs are to be ignored by the receiving entity. However, GROs may be forwarded
to additional receiving entities, in which case the unknown TLVs will be forwarded too. A
receiving entity MAY remove unknown TLVs before forwarding a GRO, as a precaution
against malicious use. </t>

<t>GROs raise potential privacy issues, which are not explored in this document. For example,
in the SIP context, mechanisms such as <xref target="RFC3323"/> and <xref target="I-D.ietf-sip-ua-privacy"/>
are available to hide information that might identify end-points. Usage scenarios for GROs MUST ensure
that they do not unintentionally defeat privacy solutions. </t>
   
</section> <!-- security -->


<section anchor="iana" title="IANA Considerations">
   <t>IANA is requested to established a Generic Referral Object (GRO) registry, containing sub-registries
for GRType, Ref_source, Ref_scope, and Port_source. The range and initial assignments
are defined in <xref target="grof"/>. </t>
   <t>New values in this registry are to be assigned according to the Specification Required policy
defined in <xref target="RFC5226"/>, which implies review by a Designated Expert according
to <xref target="extens"/>. </t>

<t>[[ Discussion invited: It has been suggested to define a (small) registry for Global ScopeIDs,
instead of assuming that "global" for IPv4 and IPv6 is unambiguous. ]] </t>
</section> <!-- iana -->


<section anchor="ack" title="Acknowledgements">

<t>This document originated from a Thai Lunch BOF (a variant of a Bar BOF) at IETF74.
Valuable comments and contributions were made by Dan Wing, ...</t>

<t>This document was produced using the xml2rfc tool
<xref target="RFC2629"/>.</t>

</section> <!-- ack -->


<section anchor ="changes" title="Change log">

<t>draft-carpenter-referral-object-00: original version, 2009-05-11</t>

</section> <!-- changes -->

</middle>

<back>

<references title="Normative References">

&RFC2119;
&RFC4861;
&RFC4193;
&RFC4291;
&RFC1035;
&RFC5226;


</references>

<references title="Informative References">

&RFC2629;
&RFC2101;
&RFC0959;
&RFC3484;
&RFC4903;
&RFC4007;
&RFC2775;
&RFC1918;
&RFC1958;
&RFC5201;
&RFC3234;
&RFC4091;
&RFC4092;
&RFC3323;
&DRAFT-sipriv;
&DRAFT-ice;
&DRAFT-turn;
&DRAFT-atypes;
    
</references>

<section anchor="Appendix1" title="Example Use Cases">

<t>[[ This appendix is incomplete and preliminary. ]]</t>

<t> Referrals may be used to add an entity to a multi-party conversation, or they may be used
(in applications such as telephony) as the first step of transferring one end of
a conversation from the referring entity to the receiving entity. [[ Say more? ]] </t>

<t>TBD: FTP/PORT,  HTTP referrals... text needed</t> 

<t>BitTorrent is a distributed file sharing infrastructure. It is based on P2P techniques for exchanging files between connected users. Three parties are involved in a BitTorrent architecture: (1) The server into which, has been uploaded the torrent file. (2) The Tracker which maintains a list of clients which have the file or some portions of that file. (3) Entities which are downloading and/or uploading portions of the file. In order to download a given file, a BitTorrent client needs to obtain the corresponding torrent file (i.e. a file which includes the meta-data information of the file to be shared: the file name, its length, a hash and the URL of the tracker.). Then, it connects to the tracker to retrieve a list of lechers (clients which are currently downloading the file but do not yet detain all the portions of the file) and seeders (clients which detain all the portions of the file and are uploading them to other requesting clients). The client connects to those machines and downloads the available portions of the requested file. </t>

<t> In a GRO for Skype purposes, if the address fails, you'd have to fall back to the Skype ID
instead of an FQDN. This is a case where allowing an application-specific ID might be valuable. 
Another case would be Lotus Domino databases - if both IP address and FQDN fail to find the relevant server,
the server name and the database name could be used as fallback identifiers. </t>


<t>In SIP environments, a SIP Proxy Server intervenes in the placement of SIP sessions between two UAs. Particularly, the SDP part of relayed SIP messages includes required information for establishment of RTP sessions (particularly IP address and port number). A media description may be unidirectional or symmetric. ICE and ANAT allow listing several network types and addresses in the same SDP offer.</t>



<t>ANAT: ANAT <xref target="RFC4091"/>,<xref target="RFC4092"/> is a procedure used by Dual Stack UAs to provide both IPv4 and IPv6 addresses in the context of a single logical media stream. This helps interworking as, whatever the distant UA version is (IPv4/IPv6-only or Dual-Stack) provided that this latter is able to understand at least one of the offers. ANAT semantic does not allow to characterize the IP address(es) it carries. For instance, no indication if the UA is behind a translator or not is supported by ANAT (or even ICE). ICE deprecates ANAT attribute. </t>

<t>Atypes <xref target="I-D.boucadair-sipping-ipv6-atypes"/>: atypes is a SIP media feature tag which indicates the IP address type capabilities of the UA (User Agent) and can aid the routing process and ease the invocation of required functions (e.g. SIP-ALG, NAT64, NAT46) when heterogeneous (i.e. IPv4 and IPv6) parties are involved in a given SIP session. Atypes can be used jointly with GRO (also with ICE and ANAT) to optimise the media path as experienced between involved parties (especially when Dual-stacks UAs are involved). </t>



</section>


</back>
</rfc>

