<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<rfc category="info" ipr="full3978" docName="draft-smarr-vcarddav-portable-contacts-00" ipr="full3978">

  <?rfc strict="yes" ?>
  <?rfc toc="yes"?>
  <?rfc tocdepth="3"?>
  <?rfc symrefs="yes"?>
  <?rfc sortrefs="yes" ?>
  <?rfc compact="yes" ?>
  <?rfc subcompact="no" ?>

  <front>
    <title abbrev="Portable Contacts 1.0">Portable Contacts: A Common Format and Protocol for Accessing Contacts</title>

    <author initials="J" surname="Smarr" fullname="Joseph Smarr">
      <organization>Plaxo</organization>
      <address>
        <email>joseph@plaxo.com</email>
        <uri>http://josephsmarr.com/</uri>
      </address>
    </author>

    <date year="2008"/>

    <abstract>
      <t>
        This document specifies Portable Contacts, XML and JSON address book document formats
        and an interface for accessing address book and friends-list information over HTTP.
      </t>
    </abstract>

  </front>
  <middle>

    <section title="Introduction">
      <t>
        The Portable Contacts specification is designed to make it easier for developers to give their users
        a secure way to access the address books and friends lists they have built up all over the web.
        Specifically, it seeks to create a common access pattern and contact schema that any site can provide,
        well-specified authentication and access rules, standard libraries that can work with any site, and
        absolutely minimal complexity, with the lightest possible toolchain requirements for developers.
      </t>
      <t>
        By far the easiest way to start understanding this spec is to jump to the example in the Appendix.
        The format and meaning of the response should be readily apparent, and the majority of this document
        is merely an attempt to formalize the details of what should be relatively clear from this example.
      </t>
      <t>
        This API defines a language- and platform- neutral protocol for Consumers to request address book,
        profile, and friends-list information from Service Providers. As a protocol, it is intended to be easy
        to understand and implement, either as a Service Provider or Consumer, using any language or platform
        of choice. It is also intended to be implemented by both individuals and small services as well as large
        providers, in any case where a service contains data about who a user knows and wishes to make that
        information portable, under the user's control.
      </t>
      <t>
        While there are currently standards for describing contact info (such as vCard), these standards do not
        specify how to discover, access, and manipulate this information, and they do not capture the full range
        of information typically found in modern address book and social networking applications. Several large
        companies have also released their own non-standard APIs for accessing and interacting with contact
        information, increasing the burden on developers and Consumers who wish to support most or all Service
        Providers. Nor do these APIs inform other providers as to how they should construct similar APIs. Thus
        Portable Contacts is an attempt to specify a complete, modern, and straight-forward recipe for Service
        Providers and Consumers of all sizes to make available and consume contact data in a standardized way.
      </t>
      
      <section title="Goals">
        <t>
          The goal of Portable Contacts is to make it easier for developers to give their users a secure way to
          access the address books and friends lists they have built up all over the web. Specifically, we seek
          to create:
          
          <list style="symbols">
            <t>
              A common access pattern and contact schema that any Service Provider can implement
            </t>
            <t>
              Well-specified authorization and access rules
            </t>
            <t>
              Free and open source libraries in many languages for most popular platforms
            </t>
            <t>
              Community-sourced support, documentation, and collaborative tools
            </t>
            <t>
              and absolutely minimal complexity, with the lightest possible toolchain requirements for developers.
            </t>
          </list>
        </t>
        <t>
          A measure of our success will be the elimination of the "password anti-pattern," by making it far easier to
          implement Portable Contacts than to engage in scraping, as well as a dramatic increase in the number of sites
          that both provide and consume who-you-know data.
        </t>
      </section>
      
      <section title="Approach">
        <t>
          Our design is focused around ease of adoption, which means a few things:
          
          <list style="numbers">
            <t>
              First, our emphasis is on simplicity of design and targeted use cases, keeping our scope intentionally narrow
              at the outset. For example, version 1 is simply about access, and defers for now on the more complex issues
              around update and sync.
            </t>
            <t>
              Second, we're taking a modern approach to who-you-know data by unifying traditional contact information and
              social network data, in order to properly represent the current diversity of the social web ecosystem.
            </t>
            <t>
              Third, we're reusing existing standards wherever possible, including vCard, OpenSocial, XRDS-Simple, OAuth, etc.
            </t>
            <t>
              And lastly, we're designing something that should be easy for current service providers to adopt. We started
              with a review of all the major existing contacts APIs and targeted common capabilities that they all share
              and provide. We believe this pragmatic balance is the best and quickest way to achieve our intended goal of
              widespread adoption.
            </t>
          </list>
        </t>
      </section>

      <section title="Feedback">
        <t>
          The Portable Contact specification is currently being developed on the http://groups.google.com/group/portablecontacts
          mailing list, with additional feedback coming from the OpenSocial community. Feedback can be posted to the Portable Contacts
          list or directly to the author. If you encounter any problems with joining the list, please contact the author.
        </t>
      </section>
      
    </section>

    <section title="Notational Conventions">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119" />.
      </t>
    </section>

    <section title="Definitions">
      <t>
        <list style="hanging">
          <t hangText="Contact:">
            A record describing information about a particular person or entity, consisting of contact information (e.g. name, e-mail addresses, phone numbers) and other descriptive information, as is typically found in address book and social networking applications.
          </t>
          <t hangText="Service Provider:">
            A web application that provides Contact information via the Portable Contacts protocol.
          </t>
          <t hangText="Consumer:">
            A website or application that uses the Portable Contacts protocol to request contacts managed by the Service Provider.
          </t>
          <t hangText="Base URL:">
            The root endpoint URL specified by the Service Provider during Discovery and used to make requests. Consumers MAY append additional path information and query string parameters to this URL as part of the request.
          </t>
          <t hangText="Singular Field:">
            A contact field that can appear at most once per contact, e.g. <spanx style="verb">displayName</spanx> or <spanx style="verb">gender</spanx>.
          </t>
          <t hangText="Plural Field:">
            A contact field that can appear multiple times per contact, e.g. <spanx style="verb">emails</spanx> or <spanx style="verb">tags</spanx>.
          </t>
          <t hangText="Simple Field">
            A Singular Field or Plural Field whose value is a single string attribute (see <xref target="structure" />).
          </t>
          <t hangText="Complex Field">
            A Singular Field or Plural Field whose value is an object containing multiple sub-field attributes (see <xref target="structure" />).
          </t>          
          <t hangText="Canonical Value:">
            Specified string values for string-valued contact fields that represent common values in a canonical form, e.g. "male" and "female" for <spanx style="verb">gender</spanx>. Service Providers SHOULD conform to Canonical Values if appropriate, but MAY deviate if they need to represent additional values.
          </t>
          <t hangText="Primary Sub-Value:">
            The sub-field in a Complex Field that should be used when sorting or filtering by that field. Unless otherwise specified, the <spanx style="verb">value</spanx> sub-field is always the Primary Sub-Field.
          </t>
        </list>
      </t>
    </section>

    <section title="Workflow Overview">
      <t>
        A Consumer wishing to access a user's data via Portable Contacts must start with an Initial Identifier for the Service Provider containing the user's data, usually provided by the user. In many cases, this may be the domain name of the Service Provider's web site, such as sample.site.org, but may be a more specific URL, such as the OpenID identifier of the user, if available. Consumers then perform Discovery on the Initial Identifier to determine where the Portable Contacts endpoint for this Service Provider resides. If successful, the Consumer may then attempt to request information from that endpoint. If the endpoint contains private data, the Service Provider will return an authorization challenge, and the Consumer must then guide the user through an appropriate authorization flow to obtain the credentials necessary to access this private data. Upon successful authorization, the Consumer may request data from the Portable Contacts endpoint using these authorization credentials. Whether accessing public or private data, Consumers may request a specific subset of the user's data using standard Query Parameters. Upon a successful request, the data is returned in the response, and the Consumer may then parse the response data and use it as desired. The following sections detail each of these steps.
      </t>
    </section>

    <section title="Discovery" anchor="discovery">
      <t>
        Portable Contacts API endpoint is discoverable from the domain root using <xref target="XRDS-Simple" /> (previously known as YADIS). The API is identified by the Service Type http://portablecontacts.net/spec/1.0 and the corresponding URI is the Base URL for the API. The Base URL MUST NOT contain any query string, as additional path information and query string variables MAY be appended by Consumers as part of forming the request (as described in detail below).
      </t>
      <t>
        An example XRDS-Simple document describing the availability and location of a Portable Contacts endpoint might look like this:
        <figure>
          <artwork><![CDATA[
<XRDS xmlns="xri://$xrds">
  <XRD xmlns:simple="http://xrds-simple.net/core/1.0"
      xmlns="xri://$XRD*($v*2.0)" version="2.0">
    <Type>xri://$xrds*simple</Type>
    <Service>
      <Type>http://portablecontacts.net/spec/1.0</Type>
      <URI>http://sample.site.org/path/to/api/</URI>
    </Service>
  </XRD>
</XRDS>
          ]]></artwork>
        </figure>
      </t>
      <t>
        In addition to discovering the endpoint itself, Service Providers using OAuth to protect responses MUST also support OAuth Discovery, as described in <xref target="auth" />.
      </t>
    </section>

    <section title="Invocation">
      <t>
        All requests to the Service Provider are made as HTTP GET operations on a URL deriving from the Base URL specified in <xref target="discovery" />. Consumers MAY append additional path information and/or query string parameters to the Base URL as part of the request, as specified in <xref target="query-params" />. Additionally, authentication information MAY be sent via POST data or additional HTTP headers in the request, as specified in <xref target="auth" />. Responses are returned in the body of the HTTP response, formatted as JSON or XML, depending on what is requested. Response and error codes SHOULD be transmitted via the HTTP status code of the response (if possible), and SHOULD also be specified in the body of the response, as described in <xref target="response-format" /> and <xref target="error-codes" />. Since the API endpoint is dynamic (and not serving static content), Consumers MUST NOT interpret any cache headers in the response as having meaning concerning when the same URL request might return a different response upon subsequent invocation.
      </t>

      <section title="Authentication and Authorization" anchor="auth">
        <t>
          The data returned by a Portable Contacts endpoint MAY contain public data, or it MAY contain private data. If the data returned is public, no authentication or authorization is required. In most cases however, the data returned is not public, and Service Providers SHOULD ensure that the user has given prior consent, either explicitly or implicitly, for their information to be released by this API. Typically this is done by Consumers obtaining either Direct Authorization (with raw credentials, for example the user's username and password) or Delegated Authorization (with an access token obtained out-of-band by the user, and given to the Consumer to present as part of the request). Portable Contacts specifies standard mechanisms for both types of authorization, so that Consumers may be able to obtain private data on a user's behalf from Service Providers in an automated and consistent fashion. Regardless of the Authorization method used, the context of the request (i.e. the user for whom data is being requested) MUST be inferred by Service Providers from the Base URL and the authorization credentials provided. If public data is being accessed (and no authorization is provided), the Base URL MUST contain enough information for Service Providers to know which data to return, but if private data is being accessed (and authorization is provided), the same Base URL MAY return information for different users depending on the authorization credentials provided.
        </t>
        <section title="Delegated Authorization">
          <t>
            Service Providers wishing to provide Delegated Authorization MUST support <xref target="OAuth Core 1.0" /> as an OAuth Service Provider, and MAY also support additional Delegated Authorization mechanisms, if they choose. Service Providers supporting OAuth MUST also support <xref target="OAuth Discovery" /> to facilitate automatic discovery of authorization endpoints for Consumers. Service Providers SHOULD provide a mechanism for Consumers to automatically obtain a Consumer Key and Consumer Secret, but MAY require this to be done out-of-band.
          </t>
        </section>
        <section title="Direct Authorization">
          <t>
            Service Providers wishing to provide Direct Authorization MUST support HTTP Basic Access Authentication <xref target="RFC2617" />, and MAY also support additional Direct Authorization mechanisms, if they choose. In addition to being a well-established mechanism for Direct Authorization, HTTP Basic has the added benefit of being understood by most Web Browsers, and can prompt users to enter their credentials as part of accessing a resource protected in this manner. There are also convenient ways of providing and parsing HTTP Basic credentials in popular tools and libraries like curl and PHP.
          </t>
        </section>
          <section title="Available Authorization Methods">
          <t>
            Service Providers that provide access to private data MAY choose not to support either Direct Authorization or Delegated Authorization, depending on their security requirements, but they MUST support either OAuth or HTTP Basic auth if they require any Authorization. When accessing a Portable Contacts endpoint, if sufficient authorization credentials are not provided, the Service Provider SHOULD return a 401 Unauthorized response, and SHOULD provide the available Authorization mechanisms available by including WWW-Authenticate headers in the response for each type of Authorization method supported (as defined in <xref target="RFC2616" />, section 14.47. Consumers will then be able to recognize that the API is a protected resource and initiate the proper Authorization process needed to obtain the appropriate credentials. An example set of WWW-Authenticate headers returned by a Service Provider that supports both OAuth and HTTP Basic might look like this. Note that the realm value is intended to be an opaque string that merely defines a shared label for resources that share the same authorization requirements.
            <figure>
              <artwork>
WWW-Authenticate: OAuth realm="sample.site.org"
WWW-Authenticate: Basic realm="sample.site.org"
              </artwork>
            </figure>
          </t>
          <t>
            If Service Providers wish to make some response data publicly available and also provide additional info given the proper authorization credentials, they SHOULD provide a 200 OK response to requests without authorization with a WWW-Authenticate header in the response indicating that additional info is available via the specified authorization mechanisms.
          </t>
        </section>
      </section>

      <section title="Additional Path Information">
        <t>
          A request using the Base URL alone MUST yield a result, assuming that adequate authorization credentials are provided. In addition, Consumers MAY append additional path information to the Base URL to request more specific information. Service Providers MUST recognize the following additional path information when appended to the Base URL, and MUST return the corresponding data:
          <list style="symbols">
            <t>
              <spanx style="verb">/@me/@all</spanx> -- Return all contact info (equivalent to providing no additional path info)
            </t>
            <t>
              <spanx style="verb">/@me/@all/{id}</spanx> -- Only return contact info for the contact whose <spanx style="verb">id</spanx> value is equal to the provided <spanx style="verb">{id}</spanx>, if such a contact exists. In this case, the response format is the same as when requesting all contacts, but any contacts not matching the requested ID MUST be filtered out of the result list by the Service Provider
            </t>
            <t>
              <spanx style="verb">/@me/@self</spanx> -- Return contact info for the owner of this information, i.e. the user on whose behalf this request is being made. In this case, the response format is the same as when requesting all contacts, but any contacts not matching the requested ID MUST be filtered out of the result list by the Service Provider.
            </t>
          </list>
        </t>
      </section>

      <section title="Query Parameters" anchor="query-params">
        <t>
          Portable Contacts defines a standard set of operations that can be used to filter, sort, and paginate response results. The operations are specified by adding query parameter to the Base URL, either in the query string or as HTTP POST data. Providers MAY support additional query parameters not specified here, and Providers SHOULD ignore any query parameters they don't recognize.
        </t>

        <section title="Filtering">
          <t>
            Filtering is used to limit the request results to Contacts that match given criteria. Content filtering is accomplished by combining three request parameters:

            <list style="hanging">
              <t hangText="filterBy:">
                Specifies the field name to filter by. If the specified field is a Plural Field, the Contact SHALL match if any of the instances of the given field match the specified criterion (e.g. if a contact has multiple <spanx style="verb">emails</spanx> values, only one has to match for the entire Contact to match). If a Simple Field is specified, its value must match the specified <spanx style="verb">filterValue</spanx> according to the specified <spanx style="verb">filterOp</spanx>. If a Complex Field is specified, its Primary Sub-Field must match. If the specified field is not a direct child of the <spanx style="verb">entry</spanx> element, the full path MUST be specified using the '.' character as separator. For example, to filter by gender the parameter value is <spanx style="verb">gender</spanx> and to filter by first name, the parameter value is <spanx style="verb">name.givenName</spanx>. 
              </t>
              <t hangText="filterOp:">
                Specifies the comparison method used to evaluate the field value with the value of the filter criterion. Providers SHOULD support the following values:
                <list style="symbols">
                  <t>
                    <spanx style="verb">equals</spanx>: the two values must be identical strings.
                  </t>
                  <t>
                    <spanx style="verb">contains</spanx>: the entire <spanx style="verb">filterValue</spanx>
                    must be a substring of the Contact field value.
                  </t>
                  <t>
                    <spanx style="verb">startswith</spanx>: the entire <spanx style="verb">filterValue</spanx>
                    must be a substring of the Contact field value, starting at the beginning of the field value. This criterion is satisfied if the two strings are equal.
                  </t>
                  <t>
                    <spanx style="verb">present</spanx>: a Contact matches the criterion if the field specified by
                    <spanx style="verb">filterBy</spanx> has a non-empty value, or if it contains a non-empty node for complex fields.
                  </t>
                </list>
                Providers MAY support additional filter operations if they choose. Providers MUST decline to filter results if the specified filter operation is not recognized (as per <xref target="declining" />).
              </t>
              <t hangText="filterValue:">
                Specifies the value to filter by, using the comparison method defined by <spanx style="verb">filterOp</spanx>.
              </t>
            </list>
          </t>
          <t>
            In addition, requests can filter content based on their <spanx style="verb">update</spanx> timestamp:

            <list style="hanging">
              <t hangText="updatedSince:">
                Returns only contacts that have been modified on or after the given time, specified as an xs:dateTime. The filter is based on the value of the <spanx style="verb">updated</spanx> field, and can be used independently of other filters or combined. It enables a basic syndication pattern when accessing the same data over time. The first API call returns all data, which can be stored locally. Subsequent API calls can specify <spanx style="verb">updatedSince</spanx> with the time of the last API call, so that only contacts that have been added or modified since the last API call will be returned.
              </t>
            </list>
          </t>
          <t>
            Here are a few illustrative examples of filtering matches with <spanx style="verb">filterBy</spanx>,
            <spanx style="verb">filterOp</spanx>, and <spanx style="verb">filterValue</spanx>. In each case, assume the following two contacts would be returned if no filtering parameters were provided:

          <figure>
            <artwork>
{
  "id": "1",
  "displayName": "Chris Messina",
  "urls": [
    { "value": "http://factoryjoe.com/blog", "type": "blog" }
  ]
},
{
  "id": "2",
  "displayName": "Joseph Smarr",
  "emails": [
    { "value": "joseph@plaxo.com", "type": "work", "primary": "true" },
    { "value": "jsmarr@gmail.com", "type": "home" }
  ],
}
            </artwork>
          </figure>

            Given the parameters <spanx style="verb">filterBy=displayName&amp;filterOp=startswith&amp;filterValue=Chr</spanx>, only the first contact (with id=1) would match and be returned. However, with parameters <spanx style="verb">filterBy=displayName&amp;filterOp=present</spanx>, both contacts would be returned. Given the parameters <spanx style="verb">filterBy=email&amp;filterOp=contains&amp;filterValue=plaxo.com</spanx>, only the second contact (with id=2) would match, as would it be the only contact to match given the parameters <spanx style="verb">filterBy=email&amp;filterOp=present</spanx>.
          </t>
          
          <t>
            If a request specifies a <spanx style="verb">filterValue</spanx> but no <spanx style="verb">filterBy</spanx> or <spanx style="verb">filterOp</spanx>, it is up to the Provider how to interpret this filter request. Providers MAY choose to default to filtering by a given field (e.g. <spanx style="verb">displayName</spanx>); they MAY choose to implement a custom, Provider-specific query syntax for <spanx style="verb">filterValue</spanx> in this case; or they MAY choose to reject requests of this type. In general, if Consumers want to request specific behavior from Providers, they should do so by being explicit in their use of query parameters.
          </t>

        </section>

        <section title="Sorting">
          <t>
            Sorting allows requests to specify the order in which contacts are returned.

            <list style="hanging">
              <t hangText="sortBy">
                Specifies the field name whose value SHALL be used to order the returned Contacts. The sort order is determine by the <spanx style="verb">sortOrder</spanx> parameter. If <spanx style="verb">sortBy</spanx> is a Singular Field, contacts are sorted according to that field's value; if it's a Plural Field, contacts are sorted by the Value (or Major Value, if it's a Complex Field, see <xref target="schema" />) of the field marked with "primary": "true", if any, or else the first value in the list, if any, or else they are sorted last if the given contact has no data for the given field.
              </t>
              <t hangText="sortOrder">
                The order in which the <spanx style="verb">sortBy</spanx> parameter is applied. Allowed values are <spanx style="verb">ascending</spanx> and <spanx style="verb">descending</spanx>. If a value for <spanx style="verb">sortBy</spanx> is provided and no <spanx style="verb">sortOrder</spanx> is specifies, the <spanx style="verb">sortOrder</spanx> SHALL default to <spanx style="verb">ascending</spanx>. Sort order is expected to be case-insensitive Unicode alphabetic sort order, with no specific locale implied.
              </t>
            </list>
          </t>
        </section>

        <section title="Pagination">
          <t>
            The pagination parameters can be used together to "page through" a large number of results in manageable chunks:

            <list style="hanging">
              <t hangText="startIndex:">
                Specifies the offset of the first result to be returned with respect to the list of contacts that would be returned if no <spanx style="verb">startIndex</spanx> were provided. For instance, if in a given request 10 contacts would normally be provided, if <spanx style="verb">startIndex</spanx>
                is 7 and no <spanx style="verb">count</spanx> is specified, then only the last 3 contacts in that list would be returned (contacts are zero-indexed). If <spanx style="verb">startIndex</spanx> is greater than or equal to the total number of results that would be returned, no contacts are returned. Value MUST be a non-negative integer and defaults to 0 if no value is specified.
              </t>
              <t hangText="count:">
                If non-zero, specifies the maximum number of contacts the Consumer would like the Provider to return at a time. Value MUST be a non-negative integer and defaults to 0 if no value is specified. A <spanx style="verb">count</spanx> of 0 means that is up to the Provider to determine how many contacts to return by default (some Providers may return all contacts by default; others may return a fixed default number like 10). Providers SHOULD honor a very large <spanx style="verb">count</spanx> value, and SHOULD support returning all contacts at once when presented with a <spanx style="verb">count</spanx> request that is larger than the number of contacts the user has, but Providers MAY choose to never return more than a Provider-determined maximum number of contacts per request, if returning all contacts is too burdensome. In all cases, at most <spanx style="verb">count</spanx>
                contacts SHALL be returned, starting at <spanx style="verb">startIndex</spanx> and counting up from there. In each of these cases, Providers MUST indicate the total number of contacts they chose to return in the response using the <spanx style="verb">itemsPerPage</spanx> response element (see <xref target="response-format" />).
              </t>
            </list>

            For instance, on an initial query, specifying <spanx style="verb">startIndex=0&amp;count=10</spanx>
            will return only the first 10 results. The total number of possible results is indicated by the <spanx style="verb">totalResults</spanx> field of results, so the client knows how many "pages" of results exist. A subsequent query of <spanx style="verb">startIndex=10&amp;count=10</spanx> will return the next 10 results, and so on.
          </t>
        </section>

        <section title="Presentation">
          <t>
            Presentation controls the format, makeup, and delivery mechanism for returning the requested result set:

            <list style="hanging">
              <t hangText="fields:">
                If non-empty, each contact returned SHALL contain only the fields explicitly requested. Service Provider MAY return a subset of the requested fields if they are not supported. This field is used for efficiency when the client only wishes to access a subset of the fields normally returned in results. Value is a comma separated list of top level field names (e.g. <spanx style="verb">id,name,emails,photos</spanx>) and defaults to an empty list which means it's up to the Provider which fields to return. Consumers may request all available fields to be returned by using the special value <spanx style="verb">@all</spanx>.
              </t>
              <t hangText="format:">
                Specifies the format in which the response data is returned. Service Providers MUST support the values <spanx style="verb">json</spanx> for JSON (http://json.org) and <spanx style="verb">xml</spanx> for XML (http://www.w3.org/XML/) and MAY support additional formats if desired. The format defaults to <spanx style="verb">json</spanx> if no format is specified. The data structure returned is equivalent in both formats; the only difference is in the encoding of the data. Singular Fields are encoded as string key/value pairs in JSON and tags with text content in XML, e.g. <spanx style="verb">"field": "value"</spanx> and <spanx style="verb">&lt;field&gt;value&lt;/field&gt;</spanx> respectively. Plural Fields and Plural Bundles are encoded as arrays in JSON and repeated tags in XML, e.g. <spanx style="verb">"fields": [ "value1", "value2" ]</spanx> and <spanx style="verb">&lt;fields&gt;value1&lt;/fields&gt;&lt;fields&gt;value2&lt;/fields&gt;</spanx> respectively. Nodes with multiple sub-nodes are represented as objects in JSON and tags with sub-tags in XML, e.g. <spanx style="verb">"field": { "subfield1": "value1", "subfield2": "value2" }</spanx> and <spanx style="verb">&lt;field&gt;&lt;subfield1&gt;value1&lt;/subfield1&gt;&lt;subfield2&gt;value2&lt;/subfield2&gt;&lt;/field&gt;</spanx> respectively.
              </t>
            </list>
          </t>
        </section>
        
        <section title="Declining to honor query parameters" anchor="declining">
          <t>
            Providers SHOULD honor all filtering, sorting, and pagination requests specified via Query Parameters. However, in some instances it may be too burdensome to comply with a particular request, e.g. because the Provider does not have an efficient database index set up for a given field that is requested for filtering or sorting, and is unable to efficiently fetch all data and post-process the results to honor the request before returning the response. In such cases, Providers MAY decline to honor the request (or specific pieces of the request). If any part of the request is declined, Providers MUST specify which part(s) of the request were declined in the response, using <spanx style="verb">"sorted": false</spanx>, <spanx style="verb">"filtered": false</spanx>, and/or <spanx style="verb">"updatedSince": false</spanx> as appropriate. For efficiency, Providers SHOULD omit these response fields if that part of the request was successfully performed, or if no such Query Parameter was specified in the request. 
          </t>
          <t>
            Note that since all of the filtering, sorting, and pagination operations are designed to reduce the amount of data returned, it is possible for Consumers to emulate these operations client-side when a Provider declines to perform them server-side. For instance, filtering can be accomplished by iterating through each entry returned and deleting those that do not match the filtering criteria. Thus Consumers can request these operations to be performed server-side, and Providers will honor them if possible, and otherwise indicate to Consumers that they need to be performed client-side, effectively "splitting the workload" while maintaining consistent semantics.
          </t>
        </section>

      </section>

      <section title="Response Format" anchor="response-format">
        <t>
          The structure of the response object returned from a successful request is as follows. The root element is <spanx style="verb">response</spanx>, which is shown explicitly as the root element in XML format, and is the anonymous root object returned when the format is JSON (i.e. in JSON, the response returned is the object value of the <spanx style="verb">response</spanx> node). The <spanx style="verb">response</spanx> node MUST contain the following child nodes, and MAY contain additional nodes that the Service Provider wishes to add to expose additional data. Note that <spanx style="verb">startIndex</spanx>, <spanx style="verb">itemsPerPage</spanx>, and <spanx style="verb">totalResults</spanx> are based on <xref target="OpenSearch" />. See the Appendix for a full example.
          <list style="symbols">
            <t>
              <spanx style="verb">startIndex</spanx>: the index of the first result returned in this response, relative to the starting index of all results that would be returned if no <spanx style="verb">startIndex</spanx> had been requested. In general, this will be equal to the value requested by the <spanx style="verb">startIndex</spanx>, or 0 if no specific <spanx style="verb">startIndex</spanx> was requested.
            </t>
            <t>
              <spanx style="verb">itemsPerPage</spanx>: the number of results returned per page in this response. In general, this will be equal to the <spanx style="verb">count</spanx> Query Parameter, but MAY be less if the Service Provider is unwilling to return as many results per page as requested, or if there are less than the requested number of results left to return when starting at the current <spanx style="verb">startIndex</spanx>. This field MUST be present if and only if a value for <spanx style="verb">count</spanx> is specified in the request.
            </t>
            <t>
              <spanx style="verb">totalResults</spanx>: the total number of contacts that would be returned if there were no <spanx style="verb">startIndex</spanx> or <spanx style="verb">count</spanx> specified. This value tells the Consumer how many total results to expect, regardless of the current pagination being used, but taking into account the current filtering options in the request.
            </t>
            <t>
              <spanx style="verb">entry</spanx>: an array of Contact objects, one for each contact matching the request, as defined in <xref target="entry-schema" />. For consistency of parsing, if the request could possibly return multiple contacts (as is normally the case), this value MUST always be an array of results, even if there happens to be 0 or 1 matching results. If the request is specifically for a single contact (e.g. because the request contains Additional Path Information like <spanx style="verb">/@me/@all/{id}</spanx> or <spanx style="verb">/@me/@self</spanx>), then <spanx style="verb">entry</spanx> MUST be an object containing the single contact returned (i.e. <spanx style="verb">"entry": [ { /* first contact */ } ]</spanx> and <spanx style="verb">"entry": { /* only contact */ }</spanx> respectively).
            </t>
          </list>
        </t>
      </section>

      <section title="Error Codes" anchor="error-codes">
        <t>
          The Service Provider MUST return a response code with every response. Response codes are numeric and conform to existing HTTP response codes where possible, as defined below. In addition to the response code, Service Providers SHOULD also provide a human-readable reason that explains the reason for the response code. This message SHOULD be intelligible to developers, but MAY be unsuitable for display to end-users. Clients SHOULD provide their own appropriate error message to users when encountering an error response.
        </t>
        <t>
          Service Providers SHOULD conform to the following response codes to indicate the following situations. Service Providers MAY return additional codes to indicate additional information, but are discouraged from doing so and should instead augment the reason text with existing codes, if possible.
        </t>
        <t>
          <list style="hanging">
            <t hangText="200:">
              OK (response returned successfully)
            </t>
            <t hangText="400:">
              Bad Request (request was malformed or illegal and cannot be completed)
            </t>
            <t hangText="401:">
              Unauthorized (authentication headers / parameters were invalid or missing)
            </t>
            <t hangText="404:">
              Not Found (the request points to an object that does not exist, e.g. to an unknown contact id; note that Service Providers MUST return a 200 with an empty array of contacts if the request has filtering parameters that are valid but have no matches)
            </t>
            <t hangText="500:">
              Internal Server Error (un unexpected error occurred during processing)
            </t>
            <t hangText="503:">
              Service Unavailable (service is temporarily unavailable; this may be because the Consumer has exceeded their rate-limit of requests)
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title="Contact Schema" anchor="schema">
      <t>
        The Contact schema defines the containers and attributes used to deliver an individual Contact or a list of Contacts as requested by the Consumer. The traditional contact info fields were taken directly from the vCard spec where possible <xref target="RFC2425" />, though instances of vCard's archaic spellings were modernized (e.g. <spanx style="verb">addresses</spanx> instead of <spanx style="verb">adr</spanx>). Even with the spelling updates, the field mappings remain equivalent, which means it should be easy to convert Portable Contacts data to and from vCard. By convention, Singular Fields have singular spelling (e.g. <spanx style="verb">displayName</spanx>) and plural fields have plural spelling (e.g. <spanx style="verb">phoneNumbers</spanx>) to make it easy to distinguish them.
      </t>
      <t>
        Each contact returned MUST include the <spanx style="verb">id</spanx> and <spanx style="verb">displayName</spanx> fields with non-empty values, but all other fields are optional, and it is recognized that not all Service Providers will be able to provide data for all the supported fields. The field list below is broad so that, for Service Providers that do support any of these fields, there is a standard field name available.
      </t>

      <section title="Structure" anchor="structure">
        <t>
          Each field is defined as either a Singular Field, in which case there MUST NOT be more than one instance of that field per contact, or as a Plural Field, in which case any number of instances of that field MAY be present per contact.
        </t>
        <t>
          Contact information is formatted using labeled attributes with either structured or unstructured string data. Each attribute value consists of one of the following types:

          <list style="hanging">
            <t hangText="Simple:">
              A single string attribute which MAY specify a REQUIRED data format or allow any string. A simple field MAY contain Canonical Values specified, in which case Service Providers SHOULD try to conform to those values if appropriate, but MAY provide alternate string values to represent additional values.
            </t>
            <t hangText="Boolean:">
              A special case of a Simple Field with two legal values: <spanx style="verb">true</spanx> and
              <spanx style="verb">false</spanx>. Values are case-sensitive.
            </t>
            <t hangText="Complex:">
              A multi-value attribute containing any combination of other attributes. Complex attributes are defined by listing the child attributes and their types. For most Complex Fields, the <spanx style="verb">value</spanx> sub-field contains the Major Value of that field (i.e. the primary piece of contact information described by that field), and the other fields provide additional meta-data.
            </t>
          </list>
        </t>
      </section>

      <section title="entry Element" anchor="entry-schema">
        <t>
          Unless otherwise specified, all fields are optional and of type xs:string. Also, unless specified, all field values MUST NOT contain any newline characters (\r or \n).
        </t>
        <section title="Singular Fields">
          <t>
            <list style="hanging">
              <t hangText="id:">
                Unique identifier for the Contact. Each Contact returned MUST include a non-empty <spanx style="verb">id</spanx> value. This identifier MUST be unique across this user's entire set of Contacts, but MAY not be unique across multiple users' data. It MUST be a stable ID that does not change when the same contact is returned in subsequent requests. For instance, an e-mail address is not a good id, because the same person may use a different e-mail address in the future. Usually, in internal database ID will be the right choice here, e.g. <spanx style="verb">"12345"</spanx>.
              </t>
              <t hangText="displayName:">
                The name of this Contact, suitable for display to end-users. Each Contact returned MUST include a non-empty <spanx style="verb">displayName</spanx> value. The name SHOULD be the full name of the Contact being described if known (e.g. <spanx style="verb">Joseph Smarr</spanx> or <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>), but MAY be a username or handle, if that is all that is available (e.g. <spanx style="verb">jsmarr</spanx>). The value provided SHOULD be the primary textual label by which this Contact is normally displayed by the Service Provider when presenting it to end-users.
              </t>
              <t hangText="name:">
                The broken-out components and fully formatted version of the contact's real name, as described in <xref target="name_element" />.
              </t>
              <t hangText="nickname:">
                The casual way to address this Contact in real life, e.g. "Bob" or "Bobby" instead of "Robert". This field SHOULD NOT be used to represent a user's username (e.g. <spanx style="verb">jsmarr</spanx> or <spanx style="verb">daveman692</spanx>); the latter should be represented by the <spanx style="verb">preferredUsername</spanx> field.
              </t>
              <t hangText="published:">
                The date this Contact was first added to the user's address book or friends list (i.e. the creation date of this entry). The value MUST be a valid xs:dateTime (e.g. <spanx style="verb">2008-01-23T04:56:22Z</spanx>).
              </t>
              <t hangText="updated:">
                The most recent date the details of this Contact were updated (i.e. the modified date of this entry). The value MUST be a valid xd:dateTime (e.g. <spanx style="verb">2008-01-23T04:56:22Z</spanx>). If this Contact has never been modified since its initial creation, the value MUST be the same as the value of <spanx style="verb">published</spanx>. Note the <spanx style="verb">updatedSince</spanx> Query Parameter described in <xref target="query-params" /> can be used to select only contacts whose <spanx style="verb">updated</spanx> value is equal to or more recent than a given xs:dateTime. This enables Consumers to repeatedly access a user's data and only request newly added or updated contacts since the last access time.
              </t>
              <t hangText="birthday:">
                The birthday of this contact. The value MUST be a valid xs:date (e.g. <spanx style="verb">1975-02-14</spanx>. The year value MAY be set to <spanx style="verb">0000</spanx> when the age of the Contact is private or the year is not available.
              </t>
              <t hangText="anniversary:">
                The wedding anniversary of this contact. The value MUST be a valid xs:date (e.g. <spanx style="verb">1975-02-14</spanx>. The year value MAY be set to <spanx style="verb">0000</spanx> when the year is not available.
              </t>
              <t hangText="gender:">
                The gender of this contact. Service Providers SHOULD return one of the following Canonical Values, if appropriate: <spanx style="verb">male</spanx>, <spanx style="verb">female</spanx>, or <spanx style="verb">undisclosed</spanx>, and MAY return a different value if it is not covered by one of these Canonical Values.
              </t>
              <t hangText="note:">
                Notes about this contact, with an unspecified meaning or usage (normally contact notes by the user about this contact). This field MAY contain newlines.
              </t>
              <t hangText="preferredUsername:">
                The preferred username of this contact on sites that ask for a username (e.g. <spanx style="verb">jsmarr</spanx> or <spanx style="verb">daveman692</spanx>). This field may be more useful for describing the owner (i.e. the value when /@me/@self is requested) than the user's contacts, e.g. Consumers MAY wish to use this value to pre-populate a username for this user when signing up for a new service.
              </t>
              <t hangText="utcOffset:">
                The offset from UTC of this Contact's current time zone, as of the time this response was returned. The value MUST conform to the offset portion of xs:dateTime, e.g. <spanx style="verb">-08:00</spanx>. Note that this value MAY change over time due to daylight saving time, and is thus meant to signify only the current value of the user's timezone offset.
              </t>
              <t hangText="connected:">
                Boolean value indicating whether the user and this Contact have established a bi-directionally asserted connection of some kind on the Service Provider's service. The value MUST be either <spanx style="verb">true</spanx> or <spanx style="verb">false</spanx>. The value MUST be true if and only if there is at least one value for the <spanx style="verb">relationship</spanx> field, described below, and is thus intended as a summary value indicating that some type of bi-directional relationship exists, for Consumers that aren't interested in the specific nature of that relationship. For traditional address books, in which a user stores information about other contacts without their explicit acknowledgment, or for services in which users choose to "follow" other users without requiring mutual consent, this value will always be false.
              </t>
            </list>
            The following additional Singular Fields are defined, based on their specification in OpenSocial <xref target="OpenSocial" />:
            <spanx style="verb">aboutMe</spanx>,
            <spanx style="verb">bodyType</spanx>,
            <spanx style="verb">currentLocation</spanx>,
            <spanx style="verb">drinker</spanx>,
            <spanx style="verb">ethnicity</spanx>,
            <spanx style="verb">fashion</spanx>,
            <spanx style="verb">happiestWhen</spanx>,
            <spanx style="verb">humor</spanx>,
            <spanx style="verb">livingArrangement</spanx>,
            <spanx style="verb">lookingFor</spanx>,
            <spanx style="verb">profileSong</spanx>,
            <spanx style="verb">profileVideo</spanx>,
            <spanx style="verb">relationshipStatus</spanx>,
            <spanx style="verb">religion</spanx>,
            <spanx style="verb">romance</spanx>,
            <spanx style="verb">scaredOf</spanx>,
            <spanx style="verb">sexualOrientation</spanx>,
            <spanx style="verb">smoker</spanx>, and
            <spanx style="verb">status</spanx>.
          </t>
        </section>
        <section title="Plural Fields">
          <t>
            Unless specified otherwise, all Plural Fields have the same three standard sub-fields:
            <list style="hanging">
              <t hangText="value:">
                The primary value of this field, e.g. the actual e-mail address, phone number, or URL. When specifying a <spanx style="verb">sortBy</spanx> field in the Query Parameters for a Plural Field, the default meaning is to sort based on this <spanx style="verb">value</spanx> sub-field. Each non-empty Plural Field value MUST contain at least the value sub-field, but all other sub-fields are optional.
              </t>
              <t hangText="type:">
                The type of field for this instance, usually used to label the preferred function of the given contact information. Unless otherwise specified, this string value specifies Canonical Values of <spanx style="verb">work</spanx>, <spanx style="verb">home</spanx>, and <spanx style="verb">other</spanx>.
              </t>
              <t hangText="primary:">
                A Boolean value indicating whether this instance of the Plural Field is the primary or preferred value of for this field, e.g. the preferred mailing address or primary e-mail address. Service Providers MUST NOT mark more than one instance of the same Plural Field as primary="true", and MAY choose not to mark any fields as primary, if this information is not available. For efficiency, Service Providers SHOULD NOT mark all non-primary fields with primary="false", but should instead omit this sub-field for all non-primary instances.
              </t>
            </list>
            When returning Plural Fields, Service Providers SHOULD canonicalize the value returned, if appropriate (e.g. for e-mail addresses and URLs). Providers MAY return the same value more than once with different types (e.g. the same e-mail address may used for work and home), but SHOULD NOT return the same (type, value) combination more than once per Plural Field, as this complicates processing by the Consumer.

            <list style="hanging">
              <t hangText="emails:">
                E-mail address for this Contact. The value SHOULD be canonicalized by the Service Provider, e.g. <spanx style="verb">joseph@plaxo.com</spanx> instead of <spanx style="verb">joseph@PLAXO.COM</spanx>.
              </t>
              <t hangText="urls:">
                URL of a web page relating to this Contact. The value SHOULD be canonicalized by the Service Provider, e.g. <spanx style="verb">http://josephsmarr.com/about/</spanx> instead of <spanx style="verb">JOSEPHSMARR.COM/about/</spanx>. In addition to the standard Canonical Values for <spanx style="verb">type</spanx>, this field also defines the additional Canonical Values <spanx style="verb">blog</spanx> and <spanx style="verb">profile</spanx>.
              </t>
              <t hangText="phoneNumbers:">
                Phone number for this Contact. No canonical value is assumed here. In addition to the standard Canonical Values for <spanx style="verb">type</spanx>, this field also defines the additional Canonical Values <spanx style="verb">mobile</spanx>, <spanx style="verb">fax</spanx>, and <spanx style="verb">pager</spanx>.
              </t>
              <t hangText="ims:">
                Instant messaging address for this Contact. No official canonicalization rules exist for all instant messaging addresses, but Service Providers SHOULD remove all whitespace and convert the address to lowercase, if this is appropriate for the service this IM address is used for. Instead of the standard Canonical Values for <spanx style="verb">type</spanx>, this field defines the following Canonical Values to represent currently popular IM services: <spanx style="verb">aim</spanx>, <spanx style="verb">gtalk</spanx>, <spanx style="verb">icq</spanx>, <spanx style="verb">xmpp</spanx>, <spanx style="verb">msn</spanx>, <spanx style="verb">skype</spanx>, <spanx style="verb">qq</spanx>, and <spanx style="verb">yahoo</spanx>.
              </t>

              <t hangText="photos:">
                URL of a photo of this contact. The value SHOULD be a canonicalized URL, and MUST point to an actual image file (e.g. a GIF, JPEG, or PNG image file) rather than to a web page containing an image. Service Providers MAY return the same image at different sizes, though it is recognized that no standard for describing images of various sizes currently exists. Note that this field SHOULD NOT be used to send down arbitrary photos taken by this user, but specifically profile photos of the contact suitable for display when describing the contact.
              </t>
              <t hangText="tags:">
                A user-defined category or label for this contact, e.g. "favorite" or "web20". These values SHOULD be case-insensitive, and there SHOULD NOT be multiple tags provided for a given contact that differ only in case. Note that this field is a Simple Field, meaning each instance consists only of a string value.
              </t>
              <t hangText="relationships:">
                A bi-directionally asserted relationship type that was established between the user and this contact by the Service Provider. The value SHOULD conform to one of the XFN relationship values (e.g. kin, friend, contact, etc.) if appropriate, but MAY be an alternative value if needed. Note this field is a parallel set of category labels to the <spanx style="verb">tags</spanx> field, but relationships MUST have been bi-directionally confirmed, whereas tags are asserted by the user without acknowledgment by this Contact. Note that this field is a Simple Field, meaning each instance consists only of a string value.
              </t>
              <t hangText="addresses:">
                A physical mailing address for this Contact, as described in <xref target="address_element" />.
              </t>
              <t hangText="organizations:">
                A current or past organizational affiliation of this Contact, as described in <xref target="organization_element" />.
              </t>
              <t hangText="accounts:">
                An online account held by this Contact, as described in <xref target="account_element" />.
              </t>
            </list>
            The following additional Plural Fields are defined, based on their specification in OpenSocial:
            <spanx style="verb">activities</spanx>,
            <spanx style="verb">books</spanx>,
            <spanx style="verb">cars</spanx>,
            <spanx style="verb">children</spanx>,
            <spanx style="verb">food</spanx>,
            <spanx style="verb">heroes</spanx>,
            <spanx style="verb">interests</spanx>,
            <spanx style="verb">jobInterests</spanx>,
            <spanx style="verb">languages</spanx>,
            <spanx style="verb">languagesSpoken</spanx>,
            <spanx style="verb">movies</spanx>,
            <spanx style="verb">music</spanx>,
            <spanx style="verb">pets</spanx>,
            <spanx style="verb">politicalViews</spanx>,
            <spanx style="verb">quotes</spanx>,
            <spanx style="verb">sports</spanx>,
            <spanx style="verb">turnOffs</spanx>,
            <spanx style="verb">turnOns</spanx>, and
            <spanx style="verb">tvShows</spanx>.
          </t>
        </section>
      </section>

      <section title="name Element" anchor="name_element">
        <t>
          The components of the contact's real name. Providers MAY return just the full name as a single string in the <spanx style="verb">formatted</spanx> sub-field, or they MAY return just the individual component fields using the other sub-fields, or they MAY return both. If both variants are returned, they SHOULD be describing the same name, with the formatted name indicating how the component fields should be combined. 
          <list style="hanging">
            <t hangText="formatted:">
              The full name, including all middle names, titles, and suffixes as appropriate, formatted for display (e.g. <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>). This is the Primary Sub-Field for this field, for the purposes of sorting and filtering.
            </t>
            <t hangText="familyName:">
              The family name of this Contact, or "Last Name" in most Western languages (e.g. <spanx style="verb">Smarr</spanx> given the full name <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>).
            </t>
            <t hangText="givenName:">
              The given name of this Contact, or "First Name" in most Western languages (e.g. <spanx style="verb">Joseph</spanx> given the full name <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>).
            </t>
            <t hangText="middleName:">
              The middle name(s) of this Contact (e.g. <spanx style="verb">Robert</spanx> given the full name <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>).
            </t>
            <t hangText="honorificPrefix:">
              The honorific prefix(es) of this Contact, or "Title" in most Western languages (e.g. <spanx style="verb">Mr.</spanx> given the full name <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>).
            </t>
            <t hangText="honorificSuffix:">
              The honorifix suffix(es) of this Contact, or "Suffix" in most Western languages (e.g. <spanx style="verb">Esq.</spanx> given the full name <spanx style="verb">Mr. Joseph Robert Smarr, Esq.</spanx>).
            </t>
          </list>
        </t>
      </section>
      
      <section title="address Element" anchor="address_element">
        <t>
          The components of a physical mailing address. Service Providers MAY return just the full address as a single string in the <spanx style="verb">formatted</spanx> sub-field, or they MAY return just the individual component fields using the other sub-fields, or they MAY return both. If both variants are returned, they SHOULD be describing the same address, with the formatted address indicating how the component fields should be combined.
          <list style="hanging">
            <t hangText="formatted:">
              The full mailing address, formatted for display or use with a mailing label. This field MAY contain newlines. This is the Primary Sub-Field for this field, for the purposes of sorting and filtering.
            </t>
            <t hangText="streetAddress:">
              The full street address component, which may include house number, street name, PO BOX, and multi-line extended street address information. This field MAY contain newlines.
            </t>
            <t hangText="locality:">
              The city or locality component.
            </t>
            <t hangText="region:">
              The state or region component.
            </t>
            <t hangText="postalCode:">
              The zipcode or postal code component.
            </t>
            <t hangText="country:">
              The country name component.
            </t>
          </list>
        </t>
      </section>

      <section title="organization Element" anchor="organization_element">
        <t>
          Describes a current or past organizational affiliation of this contact. Service Providers that support only a single Company Name and Job Title field should represent them with a single <spanx style="verb">organization</spanx> element with <spanx style="verb">name</spanx> and <spanx style="verb">title</spanx> properties, respectively.
          <list style="hanging">
            <t hangText="name:">
              The name of the organization (e.g. company, school, or other organization). This field MUST have a non-empty value for each organization returned. This is the Primary Sub-Field for this field, for the purposes of sorting and filtering.
            </t>
            <t hangText="department:">
              The department within this organization.
            </t>
            <t hangText="title:">
              The job title or role within this organization.
            </t>
            <t hangText="type:">
              The type of organization, with Canonical Values <spanx style="verb">job</spanx> and <spanx style="verb">school</spanx>.
            </t>
            <t hangText="startDate:">
              The date this Contact joined this organization. This value SHOULD be a valid xs:date if possible, but MAY be an unformatted string, since it is recognized that this field is often presented as free-text.
            </t>
            <t hangText="endDate:">
              The date this Contact left this organization or the role specified by title within this organization. This value SHOULD be a valid xs:date if possible, but MAY be an unformatted string, since it is recognized that this field is often presented as free-text.
            </t>
            <t hangText="location:">
              The physical location of this organization. This may be a complete address, or an abbreviated location like "San Francisco".
            </t>
            <t hangText="description:">
              A textual description of the role this Contact played in this organization. This field MAY contain newlines.
            </t>
          </list>
        </t>
      </section>

      <section title="account Element" anchor="account_element">
        <t>
          Describes an account held by this Contact, which MAY be on the Service Provider's service, or MAY be on a different service. Consumers SHOULD NOT assume that this account has been verified by the Service Provider to actually belong to this Contact. For each account, the <spanx style="verb">domain</spanx> is the top-most authoritative domain for this account, e.g. <spanx style="verb">yahoo.com</spanx> or <spanx style="verb">reader.google.com</spanx>, and MUST be non-empty. Each account must also contain a non-empty value for either <spanx style="verb">username</spanx> or <spanx style="verb">userid</spanx>, and MAY contain both, in which case the two values MUST be for the same account. These accounts can be used to determine if a user on one service is also known to be the same person on a different service, to facilitate connecting to people the user already knows on different services. If Consumers want to turn these accounts into profile URLs, they can use an open-source library like <xref target="google-sgnodemapper" />.
          <list style="hanging">
            <t hangText="domain:">
              The top-most authoritative domain for this account, e.g. "twitter.com". This is the Primary Sub-Field for this field, for the purposes of sorting and filtering.
            </t>
            <t hangText="username:">
              An alphanumeric user name, usually chosen by the user, e.g. "jsmarr".
            </t>
            <t hangText="userid:">
              A user ID number, usually chosen automatically, and usually numeric but sometimes alphanumeric, e.g. "12345" or "1Z425A".
            </t>
          </list>
        </t>
      </section>

    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>
        This memo includes no request to IANA at this time. [[Future drafts are likely to request registration for the XML and JSON content types.]]
      </t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
        This memo abides by the security considerations of HTTP Basic Auth <xref target="RFC2617" /> and the OAuth protocol <xref target="OAuth Core 1.0" />.
      </t>
    </section>
    
    <appendix title="Example">
      <t>
        Here is a sample request and response that illustrates much of Portable Contacts. For simplicity, authorization information is not shown in the request.
      </t>
      <t>Sample request (via HTTP GET):</t>
      <t>
        <figure>
          <artwork>
http://sample.site.org/path/to/api/@me/@all?startIndex=10
    &count=10&sortBy=displayName
          </artwork>
        </figure>
      </t>
      <t>Sample response (JSON):</t>
      <t>
        <figure>
          <artwork>
{
  "startIndex": 10,
  "itemsPerPage": 10,
  "totalResults": 12,
  "entry": [
    {
      "id": "123",
      "displayName": "Minimal Contact"
    },
    {
      "id": "703887",
      "displayName": "Mork Hashimoto",
      "name": {
        "familyName": "Hashimoto",
        "givenName": "Mork"
      },
      "birthday": "0000-01-16",
      "gender": "male",
      "drinker": "heavily",
      "tags": [
        "plaxo guy"
      ],
      "emails": [
        {
          "value": "mhashimoto-04@plaxo.com",
          "type": "work",
          "primary": "true"
        },
        {
          "value": "mhashimoto-04@plaxo.com",
          "type": "home"
        },
        {
          "value": "mhashimoto@plaxo.com",
          "type": "home"
        }
      ],
      "urls": [
        {
          "value": "http://www.seeyellow.com",
          "type": "work"
        },
        {
          "value": "http://www.angryalien.com",
          "type": "home"
        }
      ],
      "phoneNumbers": [
        {
          "value": "KLONDIKE5",
          "type": "work"
        },
        {
          "value": "650-123-4567",
          "type": "mobile"
        }
      ],
      "photos": [
        {
          "value": "http://sample.site.org/photos/12345.jpg",
          "type": "thumbnail"
        }
      ],
      "ims": [
        {
          "value": "plaxodev8",
          "type": "aim"
        }
      ],
      "addresses": [
        {
          "type": "home",
          "streetAddress": "742 Evergreen Terrace\nSuite 123",
          "locality": "Springfield",
          "region": "VT",
          "postalCode": "12345",
          "country": "USA",
          "formatted":
          "742 Evergreen Terrace\nSuite 123\nSpringfield, VT 12345 USA"
        }
      ],
      "organizations": [
        {
          "name": "Burns Worldwide",
          "title": "Head Bee Guy"
        }
      ],
      "accounts": [
        {
          "domain": "plaxo.com",
          "userid": "2706"
        }
      ]
    }
  ]
}
          </artwork>
        </figure>
      </t>
      <t>Sample response (XML):</t>
      <t>
        <figure>
          <artwork>
&lt;response>
 &lt;startIndex>10&lt;/startIndex>
 &lt;itemsPerPage>10&lt;/itemsPerPage>
 &lt;totalResults>12&lt;/totalResults>
 &lt;entry>
  &lt;id>123&lt;/id>
  &lt;displayName>Minimal Contact&lt;/displayName>
 &lt;/entry>
 &lt;entry>
  &lt;id>703887&lt;/id>
  &lt;displayName>Mork Hashimoto&lt;/displayName>
  &lt;name>
   &lt;familyName>Hashimoto&lt;/familyName>
   &lt;givenName>Mork&lt;/givenName>
  &lt;/name>
  &lt;birthday>0000-01-16&lt;/birthday>
  &lt;gender>male&lt;/gender>
  &lt;drinker>heavily&lt;/drinker>
  &lt;tags>plaxo guy&lt;/tags>
  &lt;emails>
   &lt;value>mhashimoto-04@plaxo.com&lt;/value>
   &lt;type>work&lt;/type>
   &lt;primary>true&lt;/primary>
  &lt;/emails>
  &lt;emails>
   &lt;value>mhashimoto-04@plaxo.com&lt;/value>
   &lt;type>home&lt;/type>
  &lt;/emails>
  &lt;emails>
   &lt;value>mhashimoto@plaxo.com&lt;/value>
   &lt;type>home&lt;/type>
  &lt;/emails>
  &lt;urls>
   &lt;value>http://www.seeyellow.com&lt;/value>
   &lt;type>work&lt;/type>
  &lt;/urls>
  &lt;urls>
   &lt;value>http://www.angryalien.com&lt;/value>
   &lt;type>home&lt;/type>
  &lt;/urls>
  &lt;phoneNumbers>
   &lt;value>KLONDIKE5&lt;/value>
   &lt;type>work&lt;/type>
  &lt;/phoneNumbers>
  &lt;phoneNumbers>
   &lt;value>650-123-4567&lt;/value>
   &lt;type>mobile&lt;/type>
  &lt;/phoneNumbers>
  &lt;photos>
   &lt;value>http://sample.site.org/photos/12345.jpg&lt;/value>
   &lt;type>thumbnail&lt;/type>
  &lt;/photos>
  &lt;ims>
   &lt;value>plaxodev8&lt;/value>
   &lt;type>aim&lt;/type>
  &lt;/ims>
  &lt;addresses>
   &lt;type>home&lt;/type>
   &lt;streetAddress>&lt;![CDATA[742 Evergreen Terrace
Suite 123]]&gt;&lt;/streetAddress>
   &lt;locality>Springfield&lt;/locality>
   &lt;region>VT&lt;/region>
   &lt;postalCode>12345&lt;/postalCode>
   &lt;country>USA&lt;/country>
   &lt;formatted>&lt;![CDATA[742 Evergreen Terrace
Suite 123
Springfield, VT 12345 USA]]&gt;&lt;/formatted>
  &lt;/addresses>
  &lt;organizations>
   &lt;name>Burns Worldwide&lt;/name>
   &lt;title>Head Bee Guy&lt;/title>
  &lt;/organizations>
  &lt;accounts>
   &lt;domain>plaxo.com&lt;/domain>
   &lt;userid>2706&lt;/userid>
  &lt;/accounts>
 &lt;/entry>
&lt;/response>
          </artwork>
        </figure>
      </t>
    </appendix>
    <appendix title="Compatibility with OpenSocial">
      <t>
        This version of the Portable Contacts specification is currently wire-compatible with the overlapping portion of the OpenSocial RESTful Protocol version 0.8.1 <xref target="OpenSocial" />. Specifically, <spanx style="emph">any compliant OpenSocial RESTful Protocol 0.8.1 Provider is also a compliant Portable Contacts Provider</spanx>, because they are specified to use the same Authorization methods (OAuth), Additional Path Information, Query Parameters, and Contact Schema. The OpenSocial and Portable Contacts communities chose to wire-align our respective specs in order to maximize widespread adoption of a single API for accessing people data.
      </t>
      <t>
        It is our intention to maintain this compatibility going forward, so long as it is feasible, and so long as the changes required are compatible with the Goals and Approach of this spec. Although Portable Contacts is an independent spec, with a more limited scope than OpenSocial, any proposed changes to either this Portable Contacts spec or the OpenSocial RESTful Protocol should be considered in the context of both communities, and we should strive not to break compatibility unless it is truly necessary, e.g. if the goals of the two communities diverge significantly in the future.
      </t>
    </appendix>

  </middle>

  <back>
    <references title="Normative References">

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2425.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml"?>

    </references>

    <references title="Informative References">

      <reference anchor="OAuth Core 1.0">
        <front>
          <title>OAuth Core 1.0</title>
          <author initials="OCW" surname="OAuth" fullname="OAuth Core Workgroup">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://oauth.net/core/1.0" />
      </reference>

      <reference anchor="OAuth Discovery">
        <front>
          <title>OAuth Discovery 1.0</title>
          <author initials="E.H.-L." surname="Eran Hammer-Lahav" fullname="Eran Hammer-Lahav">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://oauth.net/discovery/ " />
      </reference>

      <reference anchor="XRDS-Simple">
        <front>
          <title>XRDS-Simple 1.0</title>
          <author initials="E.H.-L." surname="Hammer-Lahav" fullname="Eran Hammer-Lahav">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://xrds-simple.net/core/1.0/" />
      </reference>

      <reference anchor="OpenSearch">
        <front>
          <title>OpenSearch 1.1</title>
          <author initials="D.C." surname="Clinton" fullname="DeWitt Clinton">
            <organization>A9</organization>
          </author>
        </front>
        <format type="HTML" target="http://www.opensearch.org/Specifications/OpenSearch/1.1/Draft_3" />
      </reference>

      <reference anchor="google-sgnodemapper">
        <front>
          <title>Social Graph Node Mapper</title>
          <author initials="B.F." surname="Fitzpatrick" fullname="Brad Fitzpatrick">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://code.google.com/p/google-sgnodemapper/" />
      </reference>

      <reference anchor="OpenSocial">
        <front>
          <title>OpenSocial 0.8.1 RESTful Protocol Specification</title>
          <author initials="J.P." surname="Panzer" fullname="John Panzer">
            <organization />
          </author>
        </front>
        <format type="HTML" target="http://www.opensocial.org/Technical-Resources/opensocial-spec-v081/restful-protocol" />
      </reference>

    </references>
  </back>

</rfc>
