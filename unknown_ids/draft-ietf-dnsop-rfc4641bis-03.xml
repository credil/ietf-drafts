<?xml version="1.0" encoding="UTF-8"?><?rfc linefile="1:draft-ietf-dnsop-rfc4641bis.xml"?>
<!-- automatically generated by xml2rfc v1.35pre1 on 2010-07-12T19:32:33Z -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc rfcedstyle="yes"?>
<?rfc subcompact="no"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="no" ?>
<?rfc sortrefs="no" ?>

<!-- rfc number="4641" category="info" obsoletes="2541" -->

<rfc ipr="pre5378Trust200902"
     obsoletes="2541"
     category="info"
     docName="draft-ietf-dnsop-rfc4641bis-03"
     >
  
  
  
  <front>
    <title>DNSSEC Operational Practices, Version 2</title>
    
    <author initials="O." surname="Kolkman" fullname="Olaf M. Kolkman">
      <organization>NLnet Labs</organization>
      <address>
	<postal>
	  <street>Kruislaan 419</street>
	  <city>Amsterdam</city>
	  <code>1098 VA</code>
	  <country>The Netherlands</country>
	</postal>
	<email>olaf@nlnetlabs.nl</email>
	<uri>http://www.nlnetlabs.nl</uri>
      </address>
    </author>
<!--
 -   <author initials="R." surname="Gieben" fullname="Miek Gieben">
 -     <organization>&#160;</organization>
 -     <address>
 -	<email>miek@miek.nl</email>
 -     </address>
 -   </author>
-->
    <date month="July" day="12" year="2010" />
    <area>Operations and Management</area>
    <workgroup>DNSOP</workgroup>
    <keyword>DNSSEC</keyword>
    <keyword>operational</keyword>
    <abstract>
      <t>
	This document describes a set of practices for operating the
	DNS with security extensions (DNSSEC).  The target audience is
	zone administrators deploying DNSSEC.
      </t>
      <t>
	The document discusses operational aspects of using keys and
	signatures in the DNS. It discusses issues of key generation,
	key storage, signature generation, key rollover, and related
	policies.
      </t>
      <t>
        [When apporoved] This document obsoletes RFC 4641 as it covers more
        operational ground and gives more up-to-date requirements with
        respect to key sizes and the DNSSEC operations.
      </t>
    </abstract>
  </front>
  
  <!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  -->
  <middle>
    
    
    <?rfc?><?rfc linefile="1:Introduction.xml"?>



<section title="Introduction">
  <t>
    This document describes how to run a DNS Security (DNSSEC)-enabled
    environment. It is intended for operators who have knowledge of
    the DNS (see <xref target="RFC1034">RFC 1034</xref> and <xref
    target="RFC1035">RFC 1035</xref>) and want to deploy DNSSEC. The
    focus of the document is on serving authoritative DNS information
    and concerns zone owners, name server operators, registry,
    registrar and registrants whereby it is assumed that there is no
    direct relation between those entities and the operators of
    validating recursive name servers (validators). See <xref
    target="RFC4033">RFC 4033</xref> for an introduction to DNSSEC,
    <xref target="RFC4034">RFC 4034</xref> for the newly introduced
    Resource Records (RRs), and <xref target="RFC4035">RFC 4035</xref>
    for the protocol changes.
  </t>
  
  <t>
    During workshops and early operational deployment, operators and
    system administrators have gained experience about operating the
    DNS with security extensions (DNSSEC).  This document translates
    these experiences into a set of practices for zone
    administrators. At the time of writing -the root is being signed
    and the first secure delegations are provisioned- there exists
    relatively little experience with DNSSEC in production
    environments; this document should therefore explicitly not be
    seen as representing 'Best Current Practices'. The document
    therefore targets to provide a number of choices with the
    considerations that motivate a particular choice. It then gives
    the operational guidelines that relate to a choice. The document
    does not give strong recommendations, that may be subject for a
    future version of this document. [OK: This is really a straw-man
    and causes a difference in tone that I believe was the instruction
    of the WG during the IETF 77 meeting. The document could be made
    much shorter when particular recommendations are made? Is there a
    general consensus that we should currently not make particular
    recommendations?]
  </t>
  
  <t>
    The procedures herein are focused on the maintenance of signed
    zones (i.e., signing and publishing zones on authoritative
    servers). It is intended that maintenance of zones such as
    re-signing or key rollovers be transparent to any verifying
    clients on the Internet.
  </t>
  
  
  <t>
    The structure of this document is as follows. In <xref
    target="trustchain"/>, we discuss the importance of keeping the
    "chain of trust" intact.  Aspects of key generation and storage of
    private keys are discussed in <xref target="keys"/>; the focus in
    this section is mainly on the private part of the key(s).  <xref
    target="sigs_keyrolls_policies"/> describes considerations
    concerning the public part of the keys. Since these public keys
    appear in the DNS one has to take into account all kinds of timing
    issues, which are discussed in <xref target="time"/>. <xref
    target="keyroll"/> and <xref target="emergency"/> deal with the
    rollover, or supercession, of keys. Finally, <xref
    target="parents"/> discusses considerations on how parents deal
    with their children's public keys in order to maintain chains of
    trust.
  </t>
  <t>
    The typographic conventions used in this document are explained in
    <xref target="typography" />.
  </t>
  
  <t>
    Since this is a document with operational suggestions and there
    are no protocol specifications, the <xref target="RFC2119">RFC
    2119</xref> language does not apply.
  </t>
  
  <t>
    This document [OK: when approved] obsoletes <xref
    target="RFC4641">RFC 4641</xref>.
  </t>
  <t>
    [OK: Editorial comments and questions are indicated by square
    brackets and editor innitials]
  </t>
  
  <section title="The Use of the Term 'key'">
    
    <t>
      It is assumed that the reader is familiar with the concept of
      asymmetric keys on which DNSSEC is based (public key
      cryptography <xref target="RFC4949">RFC4949</xref>). Therefore,
      this document will use the term 'key' rather loosely. Where it
      is written that 'a key is used to sign data' it is assumed that
      the reader understands that it is the private part of the key
      pair that is used for signing. It is also assumed that the
      reader understands that the public part of the key pair is
      published in the DNSKEY Resource Record and that it is the
      public part that is used in key exchanges.
    </t>
    
    
  </section> <!-- The usage of the term key -->
  
  
  <section title="Time Definitions">
    
    <t>
      In this document, we will be using a number of time-related
      terms. The following definitions apply:
    </t>
    <t>
      <list style="symbols">
	<t>
	  "Signature validity period" The period that a signature is
	  valid.  It starts at the time specified in the signature
	  inception field of the RRSIG RR and ends at the time
	  specified in the expiration field of the RRSIG RR.
	</t>
		
	<t>
	  "Signature publication period" Time after which a signature
	  (made with a specific key) is replaced with a new signature
	  (made with the same key). This replacement takes place by
	  publishing the relevant RRSIG in the master zone file.
	  After one stops publishing an RRSIG in a zone, it may take a
	  while before the RRSIG has expired from caches and has
	  actually been removed from the DNS.
	</t>
	
	<t>
	  "Key effectivity period" The period during which a key pair
	  is expected to be effective. This period is defined as the
	  time between the first inception time stamp and the last
	  expiration date of any signature made with this key,
	  regardless of any discontinuity in the use of the key.  The
	  key effectivity period can span multiple signature validity
	  periods.
	</t>
	
	<t>
	  "Maximum/Minimum Zone Time to Live (TTL)" The maximum or
	  minimum value of the TTLs from the complete set of RRs in a
	  zone. Note that the minimum TTL is not the same as the
	  MINIMUM field in the SOA RR. See <xref target="RFC2308">RFC2308</xref>
	  for more information.
	</t>
	
	
      </list>
    </t>
  </section> <!--Time definitions -->
  
  
</section> <!-- Introduction -->
<?rfc linefile="74:draft-ietf-dnsop-rfc4641bis.xml"?>

    
    <?rfc?><?rfc linefile="1:trustchain.xml"?>

    <section anchor="trustchain" title="Keeping the Chain of Trust Intact">


      <t>
	Maintaining a valid chain of trust is important because
	broken chains of trust will result in data being marked as
	  Bogus (as defined in <xref
	  target="RFC4033">RFC4033</xref> Section 5), which
	  may cause entire (sub)domains to become invisible to
	  verifying clients. The administrators of secured zones have
	  to realize that their zone is, to verifying clients, part of a
	  chain of trust.
	</t>
	<t>
	  As mentioned in the introduction, the procedures herein are
	  intended to ensure that maintenance of zones, such as re-signing or
	  key rollovers, will be transparent to the verifying clients on the
	  Internet.
	</t>
	<t>
	Administrators of secured zones will have to keep in mind that data
	published on an authoritative primary server will not be
	immediately seen by verifying clients; it may take some time for
	the data to be transferred to other secondary authoritative
	nameservers and clients may be fetching data from caching
	non-authoritative servers. In this light, note that
	the time for a zone transfer from master to slave is negligible when
        using NOTIFY <xref target="RFC1996"/> and incremental transfer
        (IXFR) <xref target="RFC1995"/>.  It increases when full zone
        transfers (AXFR) are used in combination
        with NOTIFY.  It increases even more if you rely on full zone
        transfers based on only the SOA timing parameters for refresh.
	</t>
	<t>
	  For the verifying clients, it is important that data from
	  secured zones can be used to build chains of trust
	  regardless of whether the data came directly from an
	  authoritative server, a caching nameserver, or some middle
	  box. Only by carefully using the available timing parameters
	  can a zone administrator ensure that the data necessary for
	  verification can be obtained.
	</t>

	<t>
	  The responsibility for maintaining the chain of trust is
	  shared by administrators of secured zones in the chain of
	  trust.  This is most obvious in the case of a 'key
	  compromise' when a trade-off between maintaining a valid
	  chain of trust and replacing the compromised keys as soon as
	  possible must be made.  Then zone administrators will have
	  to make a trade-off, between keeping the chain of trust
	  intact -- thereby allowing for attacks with the compromised
	  key -- or deliberately breaking the chain of trust and making
	  secured subdomains invisible to security-aware
	  resolvers. Also see <xref target="emergency"/>.

	</t>


      </section><!-- Keeping the chain of trust intact -->




<?rfc linefile="77:draft-ietf-dnsop-rfc4641bis.xml"?>
    
    <?rfc?><?rfc linefile="1:Keys.xml"?>
<section anchor="keys" title="Keys Generation and Storage"> <!-- Keys -->
  
  <t>
    This section describes a number of considerations with respect to
    the use of keys. For the desgin of a operational procedure for key
    generation and storage the following decisions need to be taken in
    order:
    <list style='symbols'>
      <t>
	Does one differentiate between Zone Signing and Key Signing
	Keys or is the use of one type of key sufficient;
      </t>
      <t>
	Are Key Signing Keys (likely to be) in use as Trust Anchors;
      </t>
      <t>
	What are the timing parameters that are allowed by the
	operational requirements; and finally
      </t>
      <t>
	What are the cryptographic parameters that fit the operational
	need?
      </t>
    </list>
    Below are the considerations that need to be taken into account
    when making decisions.
  </t>
  
  
  <section title="Operational motivation for ZSKs and KSKs">
    <t>
      The DNSSEC validation protocol does not distinguish between
      different types of DNSKEYs. All DNSKEYs can be used during the
      validation. The motivations to differentiate between keys are
      purely operational.
    </t>
    <t>
      For operational reasons, motivated below, it is possible to
      designate one or more keys as Key Signing Keys (KSKs). These
      keys will only sign the apex DNSKEY RRSet in a zone. Other keys
      can be used to sign all the RRSets in a zone and are referred to
      as Zone Signing Keys (ZSKs). In case the differentiation between
      KSK and ZSK is not made we talk about a Single Type signing
      scheme
    </t>
    <section anchor="zsk-ksk-motivation" title="Motivations for the KSK and ZSK Separation">
      
      <t>
	Differentiating between the KSK and ZSK is mostly done for
	operational purposes whereby 
      </t> 
      <t>
	If the two functions are separated then, for almost any method
	of key management and zone signing, the KSK is used less
	frequently then the ZSK. Once a key set is signed with the
	KSK, all the keys in the key set can be used as ZSKs.  If
	there has been an event that increases the risk that a ZSK is
	compromised it can be simply dropped from the key set. The new
	key set is then re-signed with the KSK.
      </t>
      <t>
	Changing a key with secure entry point (SEP) functionality can
	be relatively expensive as it involves interaction with 3rd
	parties: When a key is only pointed to by the parental DS one
	needs to complete the interaction with the parental registry
	and wait for the transaction to appear in the DNS.  In the
	case that a SEP key that is in use as a trust-anchor one has
	to wait until one has sufficient confidence that all trust
	anchors have been replaced. In fact, it may be that one is not
	able to reach the complete user-base with information about
	the key rollover.
      </t>
      <t>
	There is also a risk that keys are compromised through theft
	or loss. For keys that are needed to sign dynamically updated
	records and are therefore installed on file-systems of
	nameservers that are connected to the network that risk is
	relatively high. For keys that are stored on Hardware Signing
	Modules such risk is relatively low. By separating the KSK and
	ZSK functionality these risks can be managed while making the
	tradeoff against the costs involved. For example, a KSK can be
	stored off-line or with more limitation on access control than
	ZSKs which need to be readily available for operational
	purposes such as the addition or deletion of zone data. More
	concretely a KSK stored on a smartcard, that is kept in a
	safe, combinded with a ZSK stored on a filesystem accessible
	by operators for daily routine may provide more operational
	flexibility and higher computational performance than a single
	key (with combined KSK and ZSK functionality) stored on an
	HSM.
      </t>
     
      <t>
	[OK: The following paragraph is new in version 3 of the draft,
	does it need to be more detailed e.g. by referring to RFC
	3766? Also the argument is made on
	http://www.educatedguesswork.org/2009/10/on_the_security_of_zsk_rollove.html,
	not sure about how about providing a stable reference to
	that. Should we add an informative reference here? ]
      </t>
      <t>
	Finally there is a risk of cryptanalysis of the key material.
	The costs of such analysis are correlated to the length of the
	key. However, cryptanalysis arguments provide no strong
	motivation for a KSK/ZSK split. Suppose one differentiates
	between a KSK and a ZSK whereby the KSK effectivity period is
	X times the ZSK effectivity period. Then, in order for the
	resistance to cryptanalysis to be the same for the KSK and the
	ZSK, the KSK needs to be X times stronger than the ZSK. Since
	for all practical purposes X will somewhere of the order of 10
	to 100 the associated key sizes will vary only about a byte in
	size for symmetric keys. Which, translated to asymmetric keys,
	is still an insignificant enough size difference to warrant a
	key-split; not for packet size or signing speed arguments.
      </t>
	  
     <t>
	The arguments for differentiation between the ZSK and KSK are
	weakest when:
	<list type="symbols">
	  <t>
	    the exposure to risk is low (e.g. when keys are stored on
	    HSMs);
	  </t>
	  <t>
	    if one can be certain that a key is not used as a
	    trust-anchor; 
	  </t>
	  <t>
	    maintenance of the various keys cannot be performed
	    through tools (is prone to human error); and
	  </t>  
	  <t> 
	    the interaction through the registrar-registry
	    provisioning chain -- in particular the timely appearance
	    of a new DS record in the parent zone in emergency
	    situations -- is predictable.
	  </t>
	</list>
	If the above holds then the costs of the operational
	complexity of a KSK-ZSK split may outweigh the costs of
	operational flexibility and choosing for a single type signing
	scheme is then a reasonable option. In other cases we advise
	that the separation between KSKs and ZSKs is made and that the
	SEP flag is exclusively set on KSKs.
      </t>
    </section>
    <section anchor="zsk-ksk-practicalites" title="Practical
						   concequences of KSK and ZSK Separation">
      
      <t>
	Given the assumption that for KSKs the SEP flag is set, the
	KSK can be distinguished from a ZSK by examining the flag
	field in the DNSKEY RR: If the flag field is an odd number it
	is a KSK. If it is an even number it is a ZSK.
      </t>
      
      <t>
	The Zone Signing Key can be used to sign all the data in
	a zone on a regular basis. When a Zone Signing Key is to be
	rolled, no interaction with the parent is needed.  This
	allows for signature validity periods on the order
	of days.
      </t>
      
      <t>
	The Key Signing Key is only to be used to sign the DNSKEY RRs
	in a zone. If a Key Signing Key is to be rolled over, there
	will be interactions with parties other than the zone
	administrator.  If there is a parent zone, these can include
	the registry of the parent zone or administrators of verifying
	resolvers that have the particular key configured as secure
	entry points. If this is a trust anchor, everyone relying on
	the trust anchor needs to roll over to the new key. The latter
	may be subject to stability costs if automated trust-anchor
	rollover mechanisms (such as e.g. <xref
	target="RFC5011">RFC5011</xref>) are not in place.  Hence, the
	key effectivity period of these keys can and should be made
	much longer.
      </t>
      


      <section title="Rolling a KSK that is not a trust-anchor">
      <t>
	There are 3 schools of thought on rolling a KSK that is not a
	trust anchor:
	<list style="symbols">
	  <t> 
	    It should be done frequently and regularly (possibly every
	    few months) so that a key rollover remains an operational
	    routine.
	  </t>
	  <t> 
	    It should be done frequently but irregularly. Frequently
	    meaning every few monthts, again based on the argument
	    that a rollover is a practiced and common operational
	    routine, but irregular, i.e. with a large jitter, so that
	    3rd parties do not start to rely on the key and will not
	    be tempted to configure those as a trust-anchor.
	  </t>
	  <t>
	    It should only be done when it is known or strongly
	    suspected that the key can be or has been compromised.
	    <!-- I do not understand this sentence : in order to
	         reduce the stability issues on systems where the
	         rollover does not happen cleanly.
	    -->
	  </t>
	</list>
	There is no widespread agreement on which of these three schools of
	thought is better for different deployments of DNSSEC.  There is a
	stability cost every time a non-anchor KSK is rolled over, but it
	is possibly low if the communication between the child and the
	parent is good.  On the other hand, the only completely effective
	way to tell if the communication is good is to test it
	periodically.  Thus, rolling a KSK with a parent is only done for
	two reasons: to test and verify the rolling system to prepare for
	an emergency, and in the case of (preventing) an actual emergency.
      </t>
      <t>      
	Finally, a zone ower can, in most cases, not be fully certain
	that the zone's KSK is not in use as a trust-anchor and while
	the configuration of trust-anchors is not the responsibility
	of the zone owner there may be stabilty costs for the
	validator administrator that (wrongfully) configured the
	trust-anchor when the zone owner roles a KSK.
      </t>
      </section>
      <section anchor="rolling-ksk-ta" title="Rolling a KSK that is a trust-anchor">
      <t>
	The same operational concerns apply to the rollover of KSKs
	that are used as trust-anchors. But remember: if a trust
	anchor replacement is done incorrectly, the entire zone that
	the trust anchor covers will become bogus until the trust
	anchor is corrected.
      </t>

      <t>
	In a large number of cases it will be safe to work from the
	assumption that ones keys are not in use as trust-anchors. If
	a zone owner publishes a "DNSSEC Signing Policy and Practice
	Statement" <xref target="I-D.ietf-dnsop-dnssec-dps-framework"
	/> that should be explicit about the fact whether the
	existence of trust anchors will be taken into account in any
	way or not. There may be cases where local policies enforce
	the configuration of trust-anchors on zones which are mission
	critical (e.g. in enterprises where the trust-anchor for the
	enterprise domain is configured in the enterprise's validator)
	It is expected that the zone owners are aware of such
	circumstances.
      </t>

      <t>
	One can argue that because of the difficulty of getting all
	users of a trust anchor to replace an old trust anchor with a
	new one, a KSK that is a trust anchor should never be rolled
	unless it is known or strongly suspected that the key has been
	compromised.  In other words the costs of a KSK rollover are
	prohibitively high because some users cannot be reached.
      </t>
   
      <t>
	However, the "operational habit" argument also applies to
	trust anchor reconfiguration at the clients validator. If a
	short key effectivity period is used and the trust anchor
	configuration has to be revisited on a regular basis, the odds
	that the configuration tends to be forgotten is smaller. In
	fact, the costs for those users can be minimized by automating
	the rollover <xref target="RFC5011">RFC5011</xref> and by
	rolling the key regularly, and advertising such, so that the
	operators of recursive nameservers will put the appropriate
	mechanism in place to deal with these stability costs, or, in
	other words, budget for these costs instead of incuring them
	unexpectedly.
      </t>
      <t>
	It is therefore recommended to roll KSKs (that are likely to
	be used as trust-anchors) if and only if those rollovers can
	be tracked using standardized (e.g. RFC5011) mechanisms.
      </t>

      </section>

      <section anchor="SEP-practicalites" title="The use of the SEP flag">	
	<t>
	  The so-called Secure Entry Point (SEP) <xref target="RFC4035" />
	  flag can be used to distinguish between keys that are intended
	  to be used as the secure entry point into the zone when building
	  chains of trust, e.g they are (to be) pointed to by parental DS
	  RRs or configured as a trust-anchor.
	</t>
	<t>
	  While the SEP flag does not play any role in the validation
	  failure it is used in parctice for operational purposes such
	  as for the rollover mechanism discribed in <xref
	  target="RFC5011">RFC5011</xref>. The comon convention is to
	  set the SEP flag on any key that is used for key exchanges
	  with the parent and potentially for configuration as trust
	  anchors. Therefore it is recomended that the SEP flag is set
	  on KSKs and not on ZSKs while in those cases that a
	  distinction between KSK and ZSK is not made (i.e. for a
	  Single Type signing scheme) the SEP flag is recommended be
	  set on all keys.
	</t>
	<t>
	  Note that signing tools may assume a KSK/ZSK split and use
	  the (non) presence of the SEP flag to determine which key is
	  to be used for signing zone data, these tools may get
	  confused when a single type signing scheme is used.

	</t>
      </section>

 
    </section> <!-- Motivations for the function -->
    
    
 
  <section anchor="key_lifetime" title="Key Effectivity Period">
    <t> 
      In general the available key lenght sets an upper limit on the
      Key Effectivity Period. For all practical purposes it is
      sufficient to define the Key Effectivity Period based on purely
      operational requirements and match the keylength to that value;
      Ignoring the operational perspective, a reasonable effectivity
      period for KSKs that have a parent zone is of the order of 2
      decades or longer.  That is, if one does not plan to test the
      rollover procedure, the key should be effective essentially
      forever, and then only rolled over in case of emergency.
    </t>
    <t>
      When one chooses for a regular key-rollover, a reasonable key
      effectivity period for KSKs that have a parent zone is 13
      months, with the intent to replace them after 12 months. As
      argued above, this annual rollover gives operational practice to
      rollovers for both the zone as the validator
      administrators. Besided, in most environments a year is a
      timespan that is easily planned and communicated.
    </t>
    <t>
      In case keys are stored on on-line systems and the exposure to
      various threats of compromise is fairly high an intended key
      effectivity period of a month is reasonable for Zone Signing
      Keys.
    </t>

    <t>
      Key effectivity periods can be made very short, as in a few
      minutes. But when replacing keys one has to take the
      considerations from <xref target="time"/> and <xref
      target="keyroll"/> into account.
    </t>
    
    <t>
      The motivation for having the ZSK's effectivity period shorter
      than the KSK's effectivity period is rooted in the operational
      consideration that it is more likely that operators have more
      frequent read access to the ZSK than to the KSK. If ZSK's are
      maintained on cryptographic Hardware Security Modules (HSM) than
      the motivation to have different key effectivity periods is
      weakend.
    </t>
    <t>
      However, if the risk of loss, theft or other compromise is the
      same for a zone and key signing key there are little arguments
      to choose different effectivity periods for ZSKs and KSKs. And
      in fact, when the split between ZSKs and KSKs is not made than
      all considerations above apply.
    </t>
    <t>
      There are certainly cases (e.g. where the the costs and risk of
      compromise, and the costs and risks involved with having to
      perform an emergency roll are also low) that the use of a single
      type signing scheme with a long key effectivity period is a good
      choice.
    </t>


  </section> <!-- key effectivity period -->
  
  <section title="Cryptographic Considerations">
    <section anchor="key algorithm" title="Key Algorithm">
      <t>
	There are currently two types of signature algorithms that can
	be used in DNSSEC: RSA and DSA. Both are fully specified in many
	freely-available documents, and both are widely considered to be
	patent-free. The creation of signatures wiht RSA and DSA takes
	roughly the same time, but DSA is about ten times slower for
	signature verification.
      </t>

      <t>
	We suggest the use of RSA/SHA-256 as the preferred signature
	algorithms and RSA/SHA-1 as an alternative.  Both have
	advantages and disadvantages.  RSA/SHA-1 has been deployed for
	many years, while RSA/SHA-256 has only begun to be deployed.
	On the other hand, it is expected that if effective attacks on
	either algorithm appeark, they will appear for RSA/SHA-1
	first.  RSA/MD5 should not be considered for use because
	RSA/MD5 will very likely be the first common-use signature
	algorithm to have an effective attack.
      </t>
      <t>
	At the time of publication, it is known that the SHA-1 hash has
	cryptanalysis issues. There is work in progress on addressing
	these issues. We recommend the use of public key algorithms
	based on hashes stronger than SHA-1 (e.g., SHA-256), as soon as
	these algorithms are available in protocol specifications (see
	<xref target="RFC5702">RFC5702</xref> and <xref
	target="RFC4509">RFC4509</xref>) and implementations.
      </t>
    </section> <!-- Key algorithm -->
    
    <section anchor="key sizes" title="Key Sizes">
      <t>
	DNSSEC signing keys should be large enough to avoid all know
	cryptographic attacks during the lifetime of the key.  To date,
	despite huge efforts, no one has broken a regular 1024-bit key;
	in fact, the best completed attack is estimated to be the
	equivalent of a 700-bit key.  An attacker breaking a 1024-bit
	signing key would need expend phenominal amounts of networked
	computing power in a way that would not be detected in order to
	break a single key.  Because of this, it is estimated that most
	zones can safely use 1024-bit keys for at least the next ten
	years.  A 1024-bit asymmetric key has an approximate equivalent
	strength of a symmetric 80-bit key.
      </t>
      <t>
	Keys that are used as extremely high value trust anchors, or
	non-anchor keys that may be difficult to roll over, may want to
	use lengths longer than 1024 bits.  Typically, the next larger
	key size used is 2048 bits, which have the approximate
	equivalent strength of a symmetric 112-bit key. In a standard
	CPU, it takes about four times as long to sign or verify with a
	2048-bit key as it does with a 1024-bit key.
      </t>
      <t>
	Another way to decide on the size of key to use is to remember
	that the phenominal effort it takes for an attacker to break a
	1024-bit key is the same regardless of how the key is used.  If
	an attacker has the capability of breaking a 1024-bit DNSSEC
	key, he also has the capability of breaking one of the many
	1024-bit TLS trust anchor keys that are installed with web
	browsers.  If the value of a DNSSEC key is lower to the attacker
	than the value of a TLS trust anchor, the attacker will use the
	resources to attack the TLS trust anchor.
      </t>
      <t>
	It is possible that there is a unexpected improvement in the
	ability for attackers to beak keys, and that such an attack
	would make it feasible to break 1024-bit keys but not 2048-bit
	keys.  If such an improvement happens, it is likely that there
	will be a huge amount of publicity, particularly because of the
	large number of 1024-bit TLS trust anchors build into popular
	web browsers. At that time, all 1024-bit keys (both ones with
	parent zones and ones that are trust anchors) can be rolled over
	and replaced with larger keys.
      </t>
      
      <t>
	Earlier documents (including the previous version of this
	document) urged the use of longer keys in situations where a
	particular key was "heavily used".  That advice may have been
	true 15 years ago, but it is not true today when using RSA or
	DSA algorithms and keys of 1024 bits or higher.
      </t>
      
    </section> <!-- Key sizes -->
    
    <section title="Private Key Storage">
      <t>
	It is recommended that, where possible, zone private keys and
	the zone file master copy that is to be signed be kept and used
	in off-line, non-network-connected, physically secure machines
	only.  Periodically, an application can be run to add
	authentication to a zone by adding RRSIG and NSEC RRs.  Then the
	augmented file can be transferred.
      </t>
      
      <t>
	When relying on dynamic update <xref target="RFC3007"/> to
	manage a signed zone, be aware that at least one private key
	of the zone will have to reside on the master server.  This
	key is only as secure as the amount of exposure the server
	receives to unknown clients and the security of the host.
	Although not mandatory, one could administer the DNS in the
	following way. The master that processes the dynamic updates
	is unavailable from generic hosts on the Internet, it is not
	listed in the NS RRSet, although its name appears in the SOA
	RRs MNAME field.  The nameservers in the NS RRSet are able to
	receive zone updates through NOTIFY, IXFR, AXFR, or an
	out-of-band distribution mechanism. This approach is known as
	the "hidden master" setup.
      </t>
      
      <t>
	The ideal situation is to have a one-way information flow to
	the network to avoid the possibility of tampering from the
	network.  Keeping the zone master file on-line on the network
	and simply cycling it through an off-line signer does not do
	this.  The on-line version could still be tampered with if the
	host it resides on is compromised.  For maximum security, the
	master copy of the zone file should be off-net and should not
	be updated based on an unsecured network mediated
	communication.
      </t>
      <t>
	The ideal situation may not be achievable because of economic
	tradeoffs between risks and costs.  For instance, keeping a
	zone file off-line is not practical and will increase the
	costs of operating a DNS zone. So in practice the machines on
	which zone files are maintained will be connected to a
	network. Operators are advised to take security measures to
	shield unauthorized access to the master copy in order to
	prevent modification of DNS data before its signed.
      </t>
      
      <t>
	Similarly the choice for storing a private key in a HSM will
	be influenced by a tradeoff between various concerns:
      
	<list style="symbols">
	  <t> 
	    The risks that an unauthorized person has unnoticed
	    read-access to the private key
	  </t>
	  <t>
	    The remaining window of opportunity for the attacker.
	  </t>
	  <t>
	    The economic impact of the possible attacks (for a TLD
	    that impact will in most cases be higher than for an
	    individual users).
	  </t>
	  <t>
	    The costs of rolling the (compromised) keys: whereby the
	    costs of roling a ZSK is lowest and the costs of rolling a
	    KSK that is in wide use as a trust anchor is highest
	  </t>
	  <t>
	    The costs of buying and maintaining an HSM.
	  </t>
	</list>
	
	
      </t>
      <t>
	For dynamically updated secured zones <xref
	target="RFC3007"/>, both the master copy and the private key
	that is used to update signatures on updated RRs will need to
	be on-line.
      </t>
      
    </section>
    
    
    
    <section title="Key Generation">
      <t>
	Careful generation of all keys is a sometimes overlooked but
	absolutely essential element in any cryptographically secure
	system.  The strongest algorithms used with the longest keys
	are still of no use if an adversary can guess enough to lower
	the size of the likely key space so that it can be
	exhaustively searched.  Technical suggestions for the
	generation of random keys will be found in <xref
	target="RFC4086">RFC 4086</xref> and <xref
	target="NIST-SP-800-90">NIST SP 800-900</xref>. One should
	carefully assess if the random number generator used during
	key generation adheres to these suggestions.
      </t>
      <t>
	Keys with a long effectivity period are particularly sensitive
	as they will represent a more valuable target and be subject
	to attack for a longer time than short-period keys.  It is
	strongly recommended that long-term key generation occur
	off-line in a manner isolated from the network via an air gap
	or, at a minimum, high-level secure hardware.
      </t>
      
    </section> <!-- Key Generation -->


    <section title="Differentiation for 'High-Level' Zones?"/>
    
    <t>
      In an earlier version of this document (<xref
      target="RFC4641">RFC4641</xref>) we made a differentiation
      between KSKs used for zones that are high in the DNS hierarchy
      versus KSKs used for zones low in that hierarchy.
    </t>
    <t>
      Longer keys are not useful because the crypto guidance is that
      everyone should use keys that no one can break. Also, it is
      impossible to judge which zones are more or less valuable to an
      attacker. An attack can only be used if the compromise is
      unnoticed and the attacker can act as an man-in-the-middle
      attack (MITM) in an unnoticed way. If example.  is compromised
      and the attacker forges answers for somebank.example. and sends
      them out as an MITM, when the attack is discovered it will be
      simple to prove that example. has been compromised and the KSK
      will be rolled.  Defining a long-term successful attack is
      difficult for keys at any level.
    </t>
    
  </section> <!-- High level -->
  
  
  </section>    <!-- cryptographic considerations --> 
  

</section> <!-- Key sec considerations -->


  <?rfc linefile="79:draft-ietf-dnsop-rfc4641bis.xml"?>
    
    
    
    <?rfc?><?rfc linefile="1:Rollover.xml"?>
<!-- Included from Rollover.xml -->
<!-- $Id -->


<section anchor="sigs_keyrolls_policies" title="Signature Generation, Key Rollover, and Related Policies">

    <section anchor="keyroll" title="Key Rollovers">

      <t>
	Regardless of whether a zone uses periodic key rollovers in
	order to practice for emergencies, or only rolls over keys in
	an emergency, key rollovers are a fact of life when using
	DNSSEC.  Zone administrators who are in the process of rolling
	their keys have to take into account that data published in
	previous versions of their zone still lives in caches. When
	deploying DNSSEC, this becomes an important consideration;
	ignoring data that may be in caches may lead to loss of
	service for clients.
      </t>
      <t>
	The most pressing example of this occurs when zone material
	signed with an old key is being validated by a resolver that
	does not have the old zone key cached. If the old key is no
	longer present in the current zone, this validation fails,
	marking the data "Bogus".  Alternatively, an attempt could be
	made to validate data that is signed with a new key against an
	old key that lives in a local cache, also resulting in data
	being marked "Bogus".
      </t>

      <section title="Zone Signing Key Rollovers">
	<t>
	  If the choice for splitting zone and key signing keys has
	  been made than those two types of keys can be rolled
	  seperatly and zone signing keys can be rolled without taking
	  into acount DS records from the parent or the configuration
	  of such a key as trust-anchor.
	</t>

	<t> 
	  For "Zone Signing Key rollovers", there are two ways to make
	  sure that during the rollover data still cached can be
	  verified with the new key sets or newly generated signatures
	  can be verified with the keys still in caches. One schema,
	  described in <xref target="dub-sig-zsk"/>, uses double
	  signatures; the other uses key pre-publication (<xref
	  target="pre-pub-zsk" />). The pros, cons, and
	  recommendations are described in <xref target="zsk-pro-con"
	  />.
	</t>
	
	<section anchor="pre-pub-zsk" title="Pre-Publish Key Rollover">
	  <t>
	    This section shows how to perform a ZSK rollover without
	    the need to sign all the data in a zone twice -- the
	    "pre-publish key rollover". This method has advantages in
	    the case of a key compromise. If the old key is
	    compromised, the new key has already been distributed in
	    the DNS. The zone administrator is then able to quickly
	    switch to the new key and remove the compromised key from
	    the zone.  Another major advantage is that the zone size
	    does not double, as is the case with the double signature
	    ZSK rollover.  A small "how-to" for this kind of rollover
	    can be found in <xref target="zskhowto" />.
	  </t>
	  <t>
	    <figure>
	      <preamble>
		Pre-publish key rollover involves four stages as follows:
	      </preamble>
	    <artwork>
----------------------------------------------------------------
 initial         new DNSKEY       new RRSIGs      DNSKEY removal
----------------------------------------------------------------
 SOA0            SOA1             SOA2            SOA3
 RRSIG10(SOA0)   RRSIG10(SOA1)    RRSIG11(SOA2)   RRSIG11(SOA3)

 DNSKEY1         DNSKEY1          DNSKEY1         DNSKEY1
 DNSKEY10        DNSKEY10         DNSKEY10        DNSKEY11
                 DNSKEY11         DNSKEY11
 RRSIG1 (DNSKEY) RRSIG1 (DNSKEY)  RRSIG1(DNSKEY)  RRSIG1 (DNSKEY)
 RRSIG10(DNSKEY) RRSIG10(DNSKEY)  RRSIG11(DNSKEY) RRSIG11(DNSKEY)
----------------------------------------------------------------
	    </artwork>
            <postamble>
	      Pre-Publish Key Rollover
            </postamble>
	  </figure>
	  </t>
	  <t>
	    <list style="hanging">
	      <t hangText="initial:"> Initial version of the zone: DNSKEY 1
	      is the Key Signing Key. DNSKEY 10 is used to sign all
	      the data of the zone, the Zone Signing Key.
	      </t>
	      <t hangText="new DNSKEY:"> DNSKEY 11 is introduced into
	      the key set. Note that no signatures are generated with
	      this key yet, but this does not secure against brute
	      force attacks on the public key.  The minimum duration
	      of this pre-roll phase is the time it takes for the
	      data to propagate to the authoritative servers plus
	      TTL value of the key set.
	      <!--This equates to two times the Maximum Zone TTL. -->
	      </t>

	      <t hangText="new RRSIGs:"> At the "new RRSIGs" stage (SOA serial
	      2), DNSKEY 11 is used to sign the data in the zone
	      exclusively  (i.e., all the signatures from DNSKEY 10 are
	      removed from the zone). DNSKEY 10 remains published in
	      the key set. This way data that was loaded into caches
	      from version 1 of the zone can still be verified with
	      key sets fetched from version 2 of the zone.
	      The minimum time that the key set including DNSKEY 10
	      is to be published is the time that it takes for
	      zone data from the previous version of the zone to
	      expire from old caches, i.e., the time it takes for
	      this zone to propagate to all authoritative servers
	      plus the Maximum Zone TTL value of any of the data
	      in the previous version of the zone.
	      </t>

	      <t hangText="DNSKEY removal:"> DNSKEY 10 is removed from the
	      zone. The key set, now only containing DNSKEY 1 and
	      DNSKEY 11, is re-signed with the DNSKEY 1.

	      </t>
	    </list>
	  </t>
	  <t> The above scheme can be simplified by always
	  publishing the "future" key immediately after the rollover.
	  The scheme would look as follows (we show two rollovers); the
	  future key is introduced in "new DNSKEY" as DNSKEY 12 and again
	  a newer one, numbered 13, in "new DNSKEY (II)":

	  </t>
	  <t>

	    <figure>
            <preamble>
            </preamble>
	      <artwork>
    initial             new RRSIGs          new DNSKEY
   -----------------------------------------------------------------
    SOA0                SOA1                SOA2
    RRSIG10(SOA0)       RRSIG11(SOA1)       RRSIG11(SOA2)

    DNSKEY1             DNSKEY1             DNSKEY1
    DNSKEY10            DNSKEY10            DNSKEY11
    DNSKEY11            DNSKEY11            DNSKEY12
    RRSIG1(DNSKEY)      RRSIG1 (DNSKEY)     RRSIG1(DNSKEY)
    RRSIG10(DNSKEY)     RRSIG11(DNSKEY)     RRSIG11(DNSKEY)
    ----------------------------------------------------------------

    ----------------------------------------------------------------
    new RRSIGs (II)     new DNSKEY (II)
    ----------------------------------------------------------------
    SOA3                SOA4
    RRSIG12(SOA3)       RRSIG12(SOA4)

    DNSKEY1             DNSKEY1
    DNSKEY11            DNSKEY12
    DNSKEY12            DNSKEY13
    RRSIG1(DNSKEY)      RRSIG1(DNSKEY)
    RRSIG12(DNSKEY)     RRSIG12(DNSKEY)
    ----------------------------------------------------------------
	      </artwork>
              <postamble>

              Pre-Publish Key Rollover, Showing Two Rollovers

              </postamble>
</figure>
</t>
	    <t> Note that the key introduced in the "new DNSKEY" phase is not
	    used for production yet; the private key can thus be
	    stored in a physically secure manner and does not need to
	    be 'fetched' every time a zone needs to be signed.

</t>

	  </section>

	  <section anchor="dub-sig-zsk" title="Double Signature Zone Signing Key Rollover">

	    <t>This section shows how to perform a ZSK key rollover
	    using the double zone data signature scheme, aptly named
	    "double signature rollover".
	    </t>
	    <t>During the "new DNSKEY" stage the new version of the zone
	    file will need to propagate to all authoritative servers
	    and the data that exists in (distant) caches will need to
	    expire, requiring at least the Maximum Zone TTL.

	    </t>
	    <figure>
            <preamble>

        Double signature ZSK rollover involves three stages
        as follows:

            </preamble>
	      <artwork>
   ----------------------------------------------------------------
   initial             new DNSKEY         DNSKEY removal
   ----------------------------------------------------------------
   SOA0                SOA1               SOA2
   RRSIG10(SOA0)       RRSIG10(SOA1)      RRSIG11(SOA2)
                       RRSIG11(SOA1)
   DNSKEY1             DNSKEY1            DNSKEY1
   DNSKEY10            DNSKEY10           DNSKEY11
                       DNSKEY11
   RRSIG1(DNSKEY)      RRSIG1(DNSKEY)     RRSIG1(DNSKEY)
   RRSIG10(DNSKEY)     RRSIG10(DNSKEY)    RRSIG11(DNSKEY)
                       RRSIG11(DNSKEY)
   ----------------------------------------------------------------
	      </artwork>
              <postamble>

		  Double Signature Zone Signing Key Rollover
                <!--
                Stages of Deployment for Double Signature Zone Signing
                Key Rollover.
		-->
              </postamble>
	    </figure>


	    <t><list style="hanging">
            <t hangText="initial:"> Initial Version
	    of the zone: DNSKEY 1 is the Key Signing Key. DNSKEY 10 is used
	    to sign all the data of the zone, the
	    Zone Signing Key.
	    </t>
	    <t hangText="new DNSKEY:"> At the "New DNSKEY" stage (SOA serial
	    1) DNSKEY 11 is introduced into the key set and all the
	    data in the zone is signed with DNSKEY 10 and DNSKEY
	    11. The rollover period will need to continue until all
	    data from version 0 of the zone has expired from
	    remote caches. This will take at least the Maximum
	    Zone TTL of version 0 of the zone.

	    </t>
	    <t hangText="DNSKEY removal:"> DNSKEY 10 is removed from the
	    zone. All the signatures from DNSKEY 10 are removed from
	    the zone. The key set, now only containing DNSKEY 11, is
	    re-signed with DNSKEY 1.  </t>
	    </list>

	    </t>

	    <t> At every instance, RRSIGs from the previous version of
	    the zone can be verified with the DNSKEY RRSet from the
	    current version and the other way around. The data from
	    the current version can be verified with the data from the
	    previous version of the zone. The duration of the "new DNSKEY"
	    phase and the period between rollovers should be at least
	    the Maximum Zone TTL.

	    </t>
	    <t>Making sure that the "new DNSKEY" phase lasts until the
	    signature expiration time of the data in the initial version  of the
	    zone is recommended. This way all caches are cleared of the old
	    signatures.  However, this duration could be
	    considerably longer than the Maximum Zone TTL, making the
	    rollover a lengthy procedure.
	    </t>
	    <t>Note that in this example we assumed that the zone was
	    not modified during the rollover. New data can be
	    introduced in the zone as long as it is signed with both
	    keys.
	    </t>


	  </section> <!--double sig rollover-->


	  <section anchor="zsk-pro-con" title="Pros and Cons of the Schemes">

	    <t>
	      <list style="hanging">
		<t hangText="Pre-publish key rollover:">
		  This rollover does not involve signing the zone data
		  twice. Instead, before the actual rollover, the
		  new key is published in the key set and thus is
		  available for cryptanalysis attacks. A small
		  disadvantage is that this process requires four
		  steps. Also the pre-publish scheme involves more
		  parental work when used for KSK rollovers as
		  explained in <xref target="diff_zsk_ksk"/>.
		</t>


		<t hangText="Double signature ZSK rollover:">
		  The drawback of this signing scheme is that during the
		  rollover the number of signatures in your zone doubles;
		  this may be prohibitive if you have very big zones. An
		  advantage is that it only requires three steps.

		</t>

	      </list>
	    </t>

	  </section> <!-- Pros and cons of the schemes -->



	</section><!--Zone Signing key rollovers-->

	<section  anchor="ksk-rollover" title="Key Signing Key Rollovers">

	  <t> 
	    For the rollover of a Key Signing Key, the same
	    considerations as for the rollover of a Zone Signing Key
	    apply. However, we can use a double signature scheme to
	    guarantee that old data (only the apex key set) in caches
	    can be verified with a new key set and vice versa.  Since
	    only the key set is signed with a KSK, zone size
	    considerations do not apply.
	  </t>
	  <t>
	    <figure>
	      <artwork>
--------------------------------------------------------------------
    initial        new DNSKEY        DS change       DNSKEY removal
--------------------------------------------------------------------
  Parent:
    SOA0           -------->         SOA1            -------->
    RRSIGpar(SOA0) -------->         RRSIGpar(SOA1)  -------->
    DS1            -------->         DS2             -------->
    RRSIGpar(DS)   -------->         RRSIGpar(DS)    -------->


  Child:
    SOA0            SOA1             -------->       SOA2
    RRSIG10(SOA0)   RRSIG10(SOA1)    -------->       RRSIG10(SOA2)
                                     -------->
    DNSKEY1         DNSKEY1          -------->       DNSKEY2
                    DNSKEY2          -------->
    DNSKEY10        DNSKEY10         -------->       DNSKEY10
    RRSIG1 (DNSKEY) RRSIG1 (DNSKEY)  -------->       RRSIG2 (DNSKEY)
                    RRSIG2 (DNSKEY)  -------->
    RRSIG10(DNSKEY) RRSIG10(DNSKEY)  -------->       RRSIG10(DNSKEY)
--------------------------------------------------------------------
	      </artwork>
              <postamble>
            Stages of Deployment for a Double Signature Key Signing
Key Rollover

              </postamble>
	    </figure>
	  </t>

	  <t>
	    <list style="hanging"> 
	      <t hangText="initial:">
		Initial version of the zone.  The parental DS points
		to DNSKEY1. Before the rollover starts, the child will
		have to verify what the TTL is of the DS RR that
		points to DNSKEY1 -- it is needed during the rollover
		and we refer to the value as TTL_DS.
	      </t>

	      <t hangText="new DNSKEY:">
		During the "new DNSKEY" phase, the zone administrator
		generates a second KSK, DNSKEY2. The key is provided
		to the parent, and the child will have to wait until a
		new DS RR has been generated that points to
		DNSKEY2. After that DS RR has been published on all
		servers authoritative for the parent's zone, the zone
		administrator has to wait at least TTL_DS to make sure
		that the old DS RR has expired from caches.
	  </t>

          <t hangText="DS change:"> 
	    The parent replaces DS1 with DS2.
          </t>

	  <t hangText="DNSKEY removal:"> 
	    DNSKEY1 has been removed.
	  </t>
	  </list>
	  </t>
	  <t>The scenario above puts the responsibility for
	  maintaining a valid chain of trust with the child. It also
	  is based on the premise that the parent only has one DS RR
	  (per algorithm) per zone.  An alternative mechanism has been
	  considered.  Using an established trust relation, the
	  interaction can be performed in-band, and the removal of
	  the keys by the child can possibly be signaled by the parent. In
	  this mechanism, there are periods where there are two DS RRs
	  at the parent. Since at the moment of writing the protocol
	  for this interaction has not been developed, further discussion
	  is out of scope for this document.
	  </t>

	  <t>
	    The scenario scetched above assumes that the KSK is not in
	    use as a trust-anchor too. If that is the case then
	    special care need to be taken. For instance, when RFC5011
	    type rollover is in use then the DNSKEY1 removal phase
	    above is the moment that the revoke flag is set on DNSKEY1
	    while it is still published, at least as long as the
	    RFC5011 holdback timer proscribes. Only after that timer
	    expired DNSKEY1 can be removed.
	  </t>


	</section><!--Key signing key rollovers-->


      <section anchor="diff_zsk_ksk" title="Difference Between ZSK and KSK Rollovers">

	<t> Note that KSK rollovers and ZSK rollovers are different in the
	sense that a KSK rollover requires interaction with the parent (and
	possibly replacing of trust anchors) and the ensuing delay while waiting
	for it.
	</t>

	<t>
	  A zone key
	  rollover can be handled in two different ways: pre-publish (<xref
	  target="pre-pub-zsk"/>) and double signature (<xref
	  target="dub-sig-zsk"/>).
	</t>
	<t>
	  As the KSK is used to validate the key set and because the
	  KSK is not changed during a ZSK rollover, a cache is able to
	  validate the new key set of the zone.  The pre-publish
	  method would also work for a KSK rollover. The records that are to
	  be pre-published are the parental DS RRs.
	The pre-publish method has some drawbacks for KSKs. We first describe the
	rollover scheme and then indicate these drawbacks.
        </t>
	  <figure>
          <preamble>
        <!-- nothing -->

          </preamble>
	    <artwork>
--------------------------------------------------------------------
  initial         new DS           new DNSKEY      DS/DNSKEY removal
--------------------------------------------------------------------
Parent:
  SOA0            SOA1             -------->       SOA2
  RRSIGpar(SOA0)  RRSIGpar(SOA1)   -------->       RRSIGpar(SOA2)
  DS1             DS1              -------->       DS2
                  DS2              -------->
  RRSIGpar(DS)    RRSIGpar(DS)     -------->       RRSIGpar(DS)

Child:
  SOA0            -------->        SOA1            SOA1
  RRSIG10(SOA0)   -------->        RRSIG10(SOA1)   RRSIG10(SOA1)
                  -------->
  DNSKEY1         -------->        DNSKEY2         DNSKEY2
                  -------->
  DNSKEY10        -------->        DNSKEY10        DNSKEY10
  RRSIG1 (DNSKEY) -------->        RRSIG2(DNSKEY)  RRSIG2 (DNSKEY)
  RRSIG10(DNSKEY) -------->        RRSIG10(DNSKEY) RRSIG10(DNSKEY)
--------------------------------------------------------------------
	    </artwork>
            <postamble>
            Stages of Deployment for a Pre-Publish Key Signing Key
            Rollover
            </postamble>
	  </figure>

          <t>
	  When the child zone wants to roll, it notifies the
	  parent during the "new DS" phase and submits the new key (or
	  the corresponding DS) to the parent.
	  The parent publishes DS1 and DS2, pointing to
	  DNSKEY1 and DNSKEY2, respectively. During the rollover ("new DNSKEY"
          phase), which
	  can take place as soon as the new DS set propagated through
	  the DNS, the child replaces DNSKEY1 with
   	  DNSKEY2. Immediately after that ("DS/DNSKEY removal" phase),
          it can notify the parent that the old DS record can be deleted.
	</t>

        <t> The drawbacks of this scheme are that during the
	"new DS" phase the parent cannot verify the match between the
	DS2 RR and DNSKEY2 using the DNS -- as DNSKEY2 is not
        yet published. Besides, we introduce a
	"security lame" key (see <xref target="lame"/>). Finally, the
	child-parent interaction consists of two steps. The "double
	signature" method only needs one interaction.

</t>



      </section> <!-- Difference Between ZSK and KSK Rollovers -->


      <section title="Rollover for a Single Type Signing Key rollover" anchor="STSrollover">
	
	<t>
	  The rollover of a DNSKEY when a Single Type Signing scheme
	  is used is subject to the same requirement as the rollover
	  of a KSK or ZSK: During any stage of the rollover the chain
	  of trust needs to continue to validate for any combination
	  of data in the zone as well as data that may still live in
	  distant caches.
	</t>
	<t>
	  There are two variants for this rollover. Since the choice
	  for a Single Type Signing scheme is motivated by operational
	  simplicity we first describe the most straightforward
	  rollover scheme first.
	</t>

	  <figure>
	    <artwork>
   -----------------------------------------------------------------
   initial           new DNSKEY       DS change      DNSKEY removal
   -----------------------------------------------------------------
 Parent:
   SOA0             -------->        SOA1            -------->
   RRSIGpar(SOA0)   -------->        RRSIGpar(SOA1)  -------->
   DS1              -------->        DS2             -------->
   RRSIGpar(DS)     -------->        RRSIGpar(DS)    -------->


 Child:
   SOA0             SOA1             ------------>    SOA2
   RRSIG1(SOA0)     RRSIG1(SOA1)     ------------>    RRSIG2(SOA2)
                    RRSIG2(SOA1)     ------------>
   DNSKEY1          DNSKEY1          ------------>    DNSKEY2
                    DNSKEY2          ------------>
   RRSIG1(DNSKEY)   RRSIG1(DNSKEY)   ------------>    RRSIG2(DNSKEY)
                    RRSIG2(DNSKEY)   ------------>
   -----------------------------------------------------------------
	    </artwork>
            <postamble>
	      Stages of the Straightforward rollover in a Single Type Signing scheme.
            </postamble>
	  </figure>	
	  <t>
	    <list style="hanging"> 
	      <t hangText="initial:">
		Parental DS points to DNSKEY1. All RR sets in the zone are signed with DNSKEY1.
	      </t>
	      <t hangText="new DNSKEY:">
		A new key (DNSKEY2) is introduced and all the RR sets are signed with both DNSKEY1 and DNSKEY2.
	      </t>
	      <t hangText="DS change:">
		After the DNSKEY RRset with the two keys had time to
		propagate into distant caches (that is the key set
		exclusively containing DNSKEY1 has been expired) the
		parental DS record can be changed.
	      </t>
	      <t hangText="DNSKEY removal:">
		After the DS RRset containing DS1 has expired from
		distant caches DNSKEY1 can be removed from the DNSKEY
		RRset .
	      </t>
	    </list>
	  </t>
	  <t>
	    There is a second variety of this rollover during which
	    one introduces a new DNSKEY into the key set and signs the
	    keyset with both keys while signing the zone data with
	    only the original DNSKEY1. One replaces the DNSKEY1
	    signatures with signatures made with DNSKEY2 at the moment
	    of DNSKEY1 removal.
	  </t>
	  <t>
	    The second variety of this rollover can be considered when
	    zone size considerations prevent the introduction of
	    double signatures over all of the zone data although in
	    that case choosing for a KSK/ZSK split may be a better
	    option.
	  </t>
	  <t>
	    A double DS rollover scheme is compatible with a rollover
	    using a Single Type signing scheme although in order to
	    maintain a valid chain of trust the zone data would need
	    to be published with a double signatures or a double key
	    key set would need to be published. Since this leads to
	    increase in zone and packet size at both child and parent
	    there are little benefits to a double DS rollover with a
	    Single Type signing scheme.
	  </t>


      </section>


      <section title="Key algorithm rollover" anchor="KAR">
      <t>
	A special class of keyrollover is the rollover of key
	algorithms (either adding a new algorithm, removing an old
	algorithm, or both), additional steps are needed to retain
	integrity during the rollover.
      </t>
      <t>
	Because of the algorithm downgrade protection in RFC4035
	section 2.2, you may not have a key of an algorithm for which
	you do not have signatures.
      </t>
      <t>
	When adding a new algorithm, the signatures should be added
	first. After the TTL has expired, and caches have dropped the
	old data covered by those signatures, the DNSKEY with the new
	algorithm can be added. When removing an old algorithm, the
	DNSKEY should be removed first.
      </t>
      <t>
	The following figure describes the steps. Whereby the trailing
	underscored number indicates the algorithm and ZSK and KSK
	indicate the obvious difference in key use. For example
	DNSKEY_KSK_1 is a the DNSKEY RR representing the public part
	of a key signing key of algorithm type 1 while
	RRSIG_ZSK_2(SOA3) is the RRSIG RR made with the private part
	of a zone signing key of algorithm type 2 over a SOA RR (that
	has serialnumber 3).
      </t>
      <figure>
	<preamble>
	  <!-- nothing -->
	</preamble>
	<?rfc?><?rfc linefile="1:Algorithm-rollover-figure.xml"?><artwork>
----------------------------------------------------------------
1 Initial            2 New RRSIGS         3 New DNSKEY
----------------------------------------------------------------
SOA0                 SOA1                 SOA2
RRSIG_ZSK_1(SOA0)    RRSIG_ZSK_1(SOA1)    RRSIG_ZSK_1(SOA2)
                     RRSIG_ZSK_2(SOA1)    RRSIG_ZSK_2(SOA2)
  
DNSKEY_KSK_1         DNSKEY_KSK_1         DNSKEY_KSK_1
DNSKEY_ZSK_1         DNSKEY_ZSK_1         DNSKEY_ZSK_1
RRSIG_KSK_1(DNSKEY)  RRSIG_KSK_1(DNSKEY)  DNSKEY_KSK_2
                     RRSIG_KSK_2(DNSKEY)  DNSKEY_ZKS_2
                                          RRSIG_KSK_1(DNSKEY)
                                          RRSIG_KSK_2(DNSKEY)
----------------------------------------------------------------
4 Remove DNSKEY      5 Remove RRSIGS
----------------------------------------------------------------
SOA3                 SOA4
RRSIG_ZSK_1(SOA3)    RRSIG_ZSK_2(SOA4)
RRSIG_ZSK_2(SOA3) 

DNSKEY_KSK_2         DNSKEY_KSK_2
DNSKEY_ZSK_2         DNSKEY_ZSK_2
RRSIG_KSK_1(DNSKEY)  RRSIG_KSK_2(DNSKEY)
RRSIG_KSK_2(DNSKEY)
----------------------------------------------------------------

</artwork>
<?rfc linefile="624:Rollover.xml"?>
	<postamble>
	  Stages of Deployment during an Algorithm Rollover.
	</postamble>
      </figure>
      <t>
	In step 2, the signatures for the new key are added, but the
	key itself is not. While in theory, the signatures of the
	keyset should always be synchronized with the keyset itself,
	it can be possible that RRSIGS are requested separately, so it
	might be prudent to also sign the DNSKEY set with the new
	signature.
      </t>
      <t>
      After the cache data has expired, the new key can be added to the zone,
      as done in step 3.
      </t>
      <t>
	The next step is to remove the old algorithm. This time the key needs
	to be removed first, before removing the signatures. The key is removed
	in step 4, and after the cache data has expired, the signatures can be
	removed in step 5.
      </t>
      <t>
	If a parent needs to roll a DS record that step can be done
	during stage 3. First one has to wait until caches are
	populated with the content of the DNSKEY RRset that was
	created at the beginning of stage 3, then the parent can swap
	the DS from pointing to DNSKEY_KSK_1 to DNSKEY_KSK_2, and then
	one has to wait for the old DS to expire from distant caches
	before taking step 4.
      </t>
      <t>
	[OK:The following paragrapgh is provisional and needs careful review.] 
      </t>
      <t>
	A special case is the rollover from an NSEC signed zone to an
	NSEC3 signed zone. In this case algortihm numbers are used to
	signal support for NSEC3 but they do not mandate the use of
	NSEC3. Therefore NSEC records should remain to be served
	untill the rollover to a new algorithm has completed and the
	new DNSKEY RR set has populated distant caches(at least one
	TTL into stage 4, or at any time during stage 5). At that
	stage the validators that have not implemented NSEC3 will
	treat the zone as unsecured as soon as they follow the chain
	of trust to DS that points to a DNSKEY of the new algorithm
	while validators that support NSEC3 will happily validate
	using NSEC. Turning on NSEC3 can then be done when moving from
	one serial to another, realizing that that involves a
	resigning of the zone and the introduction of the NSECPARAM
	record in order to signal authoritative servers to start
	serving NSEC3 authenticated denial of existence.
	
      </t>


      </section><!-- key algorithm rollover-->


	<!-- Adopted from gilles - ambivalent on whether this is
	     useful -->
	<section anchor="autokeyroll" title="Automated Key Rollovers">
	  <t>
	    As keys must be renewed periodically, there is some
	    motivation to automate the rollover process. Consider the
	    following:
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		ZSK rollovers are easy to automate as only the child
		zone is involved.
	      </t>

	      <t>
		A KSK rollover needs interaction between parent and
		child.  Data exchange is needed to provide the new
		keys to the parent; consequently, this data must be
		authenticated and integrity must be guaranteed in
		order to avoid attacks on the rollover.
	      </t>

	    </list>
	  </t>

	</section> <!-- Automated Key Rollovers -->

      </section><!--Key rollover-->


      <section anchor="emergency" title="Planning for Emergency Key Rollover">

	<t>
	  This section deals with preparation for a possible key
	  compromise. Our advice is to have a documented procedure
	  ready for when a key compromise is suspected or confirmed.
	</t>
	
	<t> 
	  When the private material of one of your keys is compromised
	  it can be used for as long as a valid trust chain exists.  A
	  trust chain remains intact for
	  <list style="symbols">
	    <t> 
	      as long as a signature over the compromised key in the
	      trust chain is valid,
	    </t>
	    <t> 
	      as long as a parental DS RR (and signature) points to
	      the compromised key,
	    </t>
	    <t> 
	      as long as the key is anchored in a resolver and is used
	      as a starting point for validation (this is generally
	      the hardest to update).
	  </t>
	</list>
	
	
	</t>
	<t>
	  While a trust chain to your compromised key exists, your
	  namespace is vulnerable to abuse by anyone who has obtained
	  illegitimate possession of the key. Zone operators have to
	  make a trade-off if the abuse of the compromised key is
	  worse than having data in caches that cannot be
	  validated. If the zone operator chooses to break the trust
	  chain to the compromised key, data in caches signed with
	  this key cannot be validated. However, if the zone
	  administrator chooses to take the path of a regular
	  rollover, the malicious key holder can spoof data so that it
	  appears to be valid.
	</t>

	<section title="KSK Compromise">

          <t> 
	    A zone containing a DNSKEY RRSet with a compromised KSK is
	    vulnerable as long as the compromised KSK is configured as
	    trust anchor or a parental DS points to it.
	  </t>
	  
	  <t> 
	    A compromised KSK can be used to sign the key set of an
	    attacker's zone. That zone could be used to poison the
	    DNS.
	   </t>

	   <t>
	     Therefore, when the KSK has been compromised, the trust
	     anchor or the parental DS should be replaced as soon as
	     possible. It is local policy whether to break the trust
	     chain during the emergency rollover. The trust chain
	     would be broken when the compromised KSK is removed from
	     the child's zone while the parent still has a DS pointing
	     to the compromised KSK (the assumption is that there is
	     only one DS at the parent. If there are multiple DSes
	     this does not apply -- however the chain of trust of this
	     particular key is broken).  
	   </t>
	   
	   <t> 
	     Note that an attacker's zone still uses the compromised
	     KSK and the presence of a parental DS would cause the
	     data in this zone to appear as valid. Removing the
	     compromised key would cause the attacker's zone to appear
	     as valid and the child's zone as Bogus. Therefore, we
	     advise not to remove the KSK before the parent has a DS
	     to a new KSK in place. 
	   </t>

	   <section title="Keeping the Chain of Trust Intact">
	     
	     <t>
	       If we follow this advice, the timing of the replacement
	       of the KSK is somewhat critical. The goal is to remove
	       the compromised KSK as soon as the new DS RR is
	       available at the parent. And also make sure that the
	       signature made with a new KSK over the key set with the
	       compromised KSK in it expires just after the new DS
	       appears at the parent, thus removing the old cruft in
	       one swoop.
	     </t>
	     
	     <t>
	       The procedure is as follows:
	       <list style="numbers">


          <t>Introduce a new KSK into the key set, keep the
          compromised KSK in the key set.</t>

         <t>Sign the key set, with a short validity period.  The
	  validity period should expire shortly after the DS is
	  expected to appear in the parent and the old DSes have
	  expired from caches.</t>

	  <t>Upload the DS for this new key to the parent.</t>

          <t>Follow the procedure of the regular KSK rollover: Wait
          for the DS to appear in the authoritative servers and then
          wait as long as the TTL of the old DS RRs. If necessary
          re-sign the DNSKEY RRSet and modify/extend the expiration time.</t>

         <t> Remove the compromised
             DNSKEY RR from the zone and re-sign the key set using your
             "normal" validity interval.
	     </t>

        </list>
	
     </t>

           <t>
          An additional danger of a key compromise is that the
          compromised key could be used to facilitate a legitimate
          DNSKEY/DS rollover and/or nameserver changes at the parent. When
          that happens, the domain may be in dispute. An
          authenticated out-of-band and secure notify mechanism to
          contact a parent is needed in this case.
                  </t>
                  <!-- This is only when as DNSSEC keys are used to
                  validate the rollover -->
                  <t>
                  Note that this is only a problem when the DNSKEY and or
                  DS records are used for authentication at the parent.
                  </t>

	</section> <!-- Keeping the Chain of Trust Intact -->

	<section title="Breaking the Chain of Trust">
        <t> 
	  There are two methods to break the chain of trust. The first
	  method causes the child zone to appear 'Bogus' to validating
	  resolvers. The other causes the child zone to appear
	  'insecure'. These are described below.
	</t>
	
	<t>
	  In the method that causes the child zone to appear 'Bogus'
	  to validating resolvers, the child zone replaces the current
	  KSK with a new one and re-signs the key set.  Next it sends
	  the DS of the new key to the parent. Only after the parent
	  has placed the new DS in the zone is the child's chain of
	  trust repaired.
	</t>
        <t>
	  An alternative method of breaking the chain of trust is by
	  removing the DS RRs from the parent zone altogether. As a
	  result, the child zone would become insecure.
	</t>
      </section> <!-- Breaking the Chain of Trust -->
      
      
    </section><!--KSK compromise-->
    
    <section title="ZSK Compromise">
      
      <t>
	Primarily because there is no parental interaction required
	when a ZSK is compromised, the situation is less severe than
	with a KSK compromise. The zone must still be re-signed with a
	new ZSK as soon as possible. As this is a local operation and
	requires no communication between the parent and child, this
	can be achieved fairly quickly. However, one has to take into
	account that just as with a normal rollover the immediate
	disappearance of the old compromised key may lead to
	verification problems.  Also note that as long as the RRSIG
	over the compromised ZSK is not expired the zone may be still
	at risk.
      </t>
    </section><!--ZSK compromise-->
    
    <section title="Compromises of Keys Anchored in Resolvers">
      
      
      <t>
	A key can also be pre-configured in resolvers. For instance,
	if DNSSEC is successfully deployed the root key may be
	pre-configured in most security aware resolvers.
      </t>
      
      <t>
	If trust-anchor keys are compromised, the resolvers using
	these keys should be notified of this fact. Zone
	administrators may consider setting up a mailing list to
	communicate the fact that a SEP key is about to be rolled
	over. This communication will of course need to be
	authenticated, e.g., by using digital signatures.
      </t>
      <t>
	End-users faced with the task of updating an anchored key
	should always validate the new key. New keys should be
	authenticated out-of-band, for example, through the use of an
	announcement website that is secured using secure sockets
	(TLS) <xref target="RFC5246"/>.
	  </t>
	</section><!--Pre-configured key compromise-->


      </section> <!--Planning for key compromise -->

      <!--  -->

      <section anchor="parents" title="Parental Policies">


	<section title="Initial Key Exchanges and Parental Policies Considerations">

	  <t> The initial key exchange is always subject to the
	  policies set by the parent. The initial key exchange is
	  always subject to the policies set by the parent. This is
	  specifically important in a registry-registrar model where
	  the key material is to be passed from the DNS operator, via
	  a registrar to the (parent) registry, where both DNS
	  operator and registrar is selected by the registrant and
	  they might be different organisations. When designing a key
	  exchange policy one should take into account that the
	  authentication and authorization mechanisms used during a
	  key exchange should be as strong as the authentication and
	  authorization mechanisms used for the exchange of delegation
	  information between parent and child. That is, there is no
	  implicit need in DNSSEC to make the authentication process
	  stronger than it was in DNS.</t>


	  <t> Using the DNS itself as the source for the actual DNSKEY
	  material, with an out-of-band check on the validity of the
	  DNSKEY, has the benefit that it reduces the chances of user
	  error. A DNSKEY query tool can make use of the
	  SEP bit <xref target="RFC4035"/> to select the proper
	  key from a DNSSEC key set, thereby reducing the chance that
	  the wrong DNSKEY is sent. It can validate the self-signature
	  over a key; thereby verifying the ownership of the private
	  key material. Fetching the DNSKEY from the DNS ensures that
	  the chain of trust remains intact once the parent publishes
	  the DS RR indicating the child is secure.  </t>

	  <t> Note: the out-of-band verification is still needed when the
	  key material is fetched via the DNS. The parent can never be
	  sure whether or not the DNSKEY RRs have been spoofed.
	  </t>

	</section>

	<section title="Storing Keys or Hashes?">

	  <t>When designing a registry system one should consider
	  which of the DNSKEYs and/or the corresponding DSes to store.
	  Since a child zone might wish to have a DS published using a
	  message digest algorithm not yet understood by the registry,
	  the registry can't count on being able to generate the DS
	  record from a raw DNSKEY.  Thus, we recommend that registry
	  systems at least support storing DS records.
	  </t>

	  <t> It may also be useful to store DNSKEYs, since having
	  them may help during troubleshooting and, as long as the
	  child's chosen message digest is supported, the overhead of
	  generating DS records from them is minimal.  Having an
	  out-of-band mechanism, such as a registry directory (e.g., Whois),
	  to find out which keys are used to generate DS Resource Records for
	  specific owners and/or zones may also help with
	  troubleshooting.
	  </t>

	  <t>
	    The storage considerations also relate to the design of
	    the customer interface and the method by which data is
	    transferred between registrant and registry; Will the
	    child zone administrator be able to upload DS RRs with
	    unknown hash algorithms or does the interface only allow
	    DNSKEYs?  When Registries support the Extensible
	    Provisioning Protocol (EPP) <xref target="RFC4310"/> then
	    that can be used for registrar-registry interactions since
	    that protocol allows the transfer of DS and optionally
	    DNSKEY RRs. For moving data between DNS operator and
	    registrar there is no standardized way for moving the
	    data.  Different registrars have different mechanisms,
	    ranging from simple web interfaces to various APIs. In
	    some cases the use of the DNSSEC extentions to EPP may be
	    aplicable to.
	  </t>

	</section>

	<section title="Security Lameness" anchor="lame">

	  <t> Security lameness is defined as what happens when a
	  parent has a DS RR pointing to a non-existing
	  DNSKEY RR.  When this happens, the child's zone may be marked
	  "Bogus" by verifying DNS clients.
	  </t>

	 <t> As part of a comprehensive delegation check, the parent could,
	 at key exchange time, verify that the child's key is actually
	 configured in the DNS.
	  However, if a parent does not understand the hashing algorithm used
	  by child, the parental checks are limited to only comparing the key
	  id.
	  </t>

	  <t>
	    Child zones should be very careful in removing DNSKEY material,
	    specifically SEP keys, for which a DS RR exists.
	  </t>

	  <t> Once a zone is "security lame", a fix (e.g., removing a
	  DS RR) will take time to propagate through the DNS.

	  </t>
	</section>

	<section anchor="DSvalidity" title="DS Signature Validity Period">

	  <t>
	    Since the DS can be replayed as long as it has a valid
	    signature, a short signature validity period over the DS
	    minimizes the time a child is vulnerable in the case of a
	    compromise of the child's KSK(s).  A signature validity
	    period that is too short introduces the possibility that a
	    zone is marked "Bogus" in case of a configuration error in
	    the signer. There may not be enough time to fix the
	    problems before signatures expire.  Something as mundane
	    as operator unavailability during weekends shows the need
	    for DS signature validity periods longer than 2 days. We
	    recommend an absolute minimum for a DS signature validity
	    period of a few days.
	  </t>

	  <t>
	    The maximum signature validity period of the DS record
	    depends on how long child zones are willing to be
	    vulnerable after a key compromise. On the other hand,
	    shortening the DS signature validity interval increases
	    the operational risk for the parent. Therefore, the parent
	    may have policy to use a signature validity interval that
	    is considerably longer than the child would hope for.
	  </t>

	  <t> 
	    A compromise between the operational constraints of the
	    parent and minimizing damage for the child may result in a
	    DS signature validity period somewhere between a week and
	    months.
	  </t>
	  
	  <t>
	    In addition to the signature validity period, which sets a
	    lower bound on the number of times the zone owner will
	    need to sign the zone data and which sets an upper bound
	    to the time a child is vulnerable after key compromise,
	    there is the TTL value on the DS RRs.  Shortening the TTL
	    means that the authoritative servers will see more
	    queries.  But on the other hand, a short TTL lowers the
	    persistence of DS RRSets in caches thereby increasing the
	    speed with which updated DS RRSets propagate through the
	    DNS.
	  </t>
	</section>
	<section title="Changing DNS Operators" anchor="changing-operators">
	  <t>
	    [OK: No feedback received between version 2 and 3. This is likely to 
	    remain]
	  </t>
	  <section title="Cooperationg DNS operators" anchor="non_cooperating_registrars">
	    <t>
	      The parent-child relation is often described in terms of
	      a (thin) registry model. Where a registry maintains the
	      parent zone, and the registrant (the user of the
	      child-domain name), deals with the registry through an
	      intermediary called a registrar. (See <xref
	      target="RFC3375"/> for a comprehensive
	      definition). Registrants may out-source the maintenance
	      of their DNS system, including the maintenance of DNSSEC
	      key material, to the registrar or to another third
	      party, which we will call the DNS operator. The DNS
	      operator that has control over the DNS zone and its keys
	      may prevent the registrant to make a timely move to a
	      different DNS operator.
	    </t>
	    <t>
	      Suppose that the registrant wants to move from a losing
	      DNS operator (loosing operator for short) to a gaining
	      DNS operator (gaining operator).  Let us first look what
	      would happen in a cooperative environment. The
	      assumption is that the loosing operator will not hand
	      off any private key material to the gaining operator,
	      that would constitute a trivial case.
	    </t>
	    
	    <t>
	      In a cooperating environment one could proceed with a
	      pre-publish ZSK rollover whereby the loosing operator
	      pre-publishes the ZSK of the gaining operator, combined
	      with a double signature KSK rollover where the two
	      registrars exchange public KSKs and independently
	      generate a signature over those keysets that they
	      combine and both publish in their copy of the zone. Once
	      that is done they can use their own private keys to sign
	      any of their zone content during the transfer.
	    </t>

 	    <figure>
 	      <artwork>
 		
 ............................................................
 intitial          |        pre-publish             |
 ............................................................
 Parent:
  NSA                            NSA          
  DSA                            DSA          
 
 ............................................................
Child at A:             Child at A:    Child at B:
  ZSKA                   ZSKA            ZSKA            
  KSKA                   ZSKB            ZSKB            
  RRSIGZA(DNSKEY)        KSKA            KSKA            
  RRSIGKA(DNSKEY)        KSKB            KSKB
                         RRSIGZB         RRSIGZB         
                         RRSIGKB         RRSIGKB
                         RRSIGZA         RRSIGZA
                         RRSIGKA         RRSIGKA

 
  SOAA                   SOAA             SOAB
  RRSIGZA(SOA)           RRSIGZA(SOA)     RRSIGZB(SOA)
                         
  NSA                    NSA              NSB
  RRSIGZA(NS)            NSB              RRSIGZB(NS)
                         RRSIGZA(NS)
 ............................................................

 ............................................................
       Redelegation          |        post migration        |
 ............................................................

           NSB                             NSB
           DSB                             DSB
 
 ............................................................
 Child at A:    Child at B:             Child at B:
  ZSKA            ZSKA                   ZSKB
  ZSKB            ZSKB                   KSKB
  KSKA            KSKA                   RRSIGZB(DNSKEY)
  KSKB            KSKB                   RRSIGKB(DNSKEY)
  RRSIGZB         RRSIGZB         
  RRSIGKB         RRSIGKB
  RRSIGZA         RRSIGZA
  RRSIGKA         RRSIGKA


  SOAA             SOAB                  SOAB
  RRSIGZA(SOA)     RRSIGZB(SOA)          RRSIGZB(SOA)

  NSA              NSB                   NSB
  NSB              RRSIGZB(NS)           RRSIGZB(NS)
  RRSIGZA(NS)
 ............................................................

	      </artwork>
	      <t>
		In this figure A denotes the loosing DNS operator and
		B the gaining DNS operator. RRSIGZ is the RRSIG
		produced by a ZSK, RRSIGK is produced with a KSK, the
		appendend A or B indicate the producers of the key
		pair. Child at A is how the zone content is represented
 		by the loosing DNS operator and Child at B is how the
 		zone content is represented by the gaining DNS
		operator.
	      </t>
 	    </figure>



	  </section>
	  <section title="Non Cooperationg DNS Operators">

	    <t>
	      In the non-cooperative case matters are more
	      complicated. The loosing operator may not cooperate and
	      leave the data in the DNS as is.  In the extreme case
	      the loosing operator may become obstructive and publish
	      a DNSKEY RR with a high TTL and corresponding signature
	      validity so that registrar A's DNSKEY, would end up in
	      caches for, in theory, tens of years.
	    </t>
	    
	    <t>
	      The problem arises when a validator tries to validate
	      with the loosing operator's key and there is no
	      signature material produced with the loosing operator
	      available in the delegation path after redelegation from
	      the loosing operator to the gaiing operator has taken
	      place.  One could imagine a rollover scenario where the
	      gaining operator pulls all RRSIGs created by the loosing
	      operator and publishes those in conjunction with its own
	      signatures, but that would not allow any changes in the
	      zone content. Since a redelegation took place the NS
	      RRset has -- per definition-- changed so such rollover
	      scenario will not work. Besides if zone transfers are
	      not allowed by the loosing operator and NSEC3 is
	      deployed in the loosing operator's zone then the
	      gainging operator's zone will not have certainty that
	      all of A's RRSIGs are transfered.
	    </t>
	    <t>
	      The only viable option for the registrant is to publish
	      its zone unsigned and ask the registry to remove the DS
	      pointing to the loosing operator's DNSKEY for as long as
	      the DNSKEY of the loosing operator, or any of the
	      signatures produced by it are likely to disappear in
	      caches, which as mentioned above could in theory be for
	      tens of years.
	    </t>
	    <t>
	      Note that some [OK: most/all ?] implementations limit
	      the time DNSKEYs that seem to be unable to validate
	      signatures are cached and/or will try to recover from
	      cases where DNSKEYs do not seem to be able to validate
	      data. Although that is not a protocol requirement it
	      seems that that practice may limit the impact of this
	      problem the problem of non-cooperating registrars.
	    </t>
	    <t>
	      However, there is no operational methodology to work
	      around this business issue, and proper contractual
	      relationships between all involved parties seems to be
	      the only solution to cope with these problems. It should
	      be noted that in many cases, the problem with temporary
	      broken delegations already exists when a zone changes
	      from one DNS operator to another. Besides, it is often
	      the case that when the DNS moves from one operator to
	      another the services that that zone references also
	      change operator, possibly involving some downtime.
	    </t>
	    <t>
	      In any case. To minimise such problems, the classic
	      recommendation is to have relative short TTL on all
	      involved resource records. That will solve many of the
	      problems regarding changes to a zone regardless of
	      whether DNSSEC is used.

	    </t>
	    
	    
	</section><!--noncooperative registrars-->
      </section>
    </section><!-- Parental policies -->



    <section anchor="time" title="Time in DNSSEC">
      <t>
	Without DNSSEC, all times in the DNS are relative. The SOA
	fields REFRESH, RETRY, and EXPIRATION are timers used to
	determine the time elapsed after a slave server synchronized
	with a master server. The Time to Live (TTL) value and the SOA
	RR minimum TTL parameter <xref target="RFC2308" /> are used to
	determine how long a forwarder should cache data after it has
	been fetched from an authoritative server. By using a
	signature validity period, DNSSEC introduces the notion of an
	absolute time in the DNS. Signatures in DNSSEC have an
	expiration date after which the signature is marked as invalid
	and the signed data is to be considered Bogus.
      </t>
      <t>
	The considerations in this section are all qualitative and
	focused on the operational and managerial issues. A more
	thourhough quantitative analysis of rollover timing parameters
	can be found in <xref
	target="I-D.ietf-dnsop-dnssec-key-timing">draft-ietf-dnsop-dnssec-key-timing</xref>
      </t>

      <section anchor="time_considerations" title="Time Considerations">

	<t>
	  Because of the expiration of signatures, one should consider the
	  following:
	</t>
	<t>
	  <list style="symbols">

	    <t>
	      We suggest the Maximum Zone TTL of your zone data to be a
	      fraction of your signature validity period.
	    </t>


	      <list style="hanging">

		<t>
		  If the TTL would be of similar order as the
		  signature validity period, then all RRSets fetched
		  during the validity period would be cached until the
		  signature expiration time.  <xref
		  target="RFC4033">Section 7.1 of RFC4033</xref>
		  suggests that "the resolver may use the time
		  remaining before expiration of the signature
		  validity period of a signed RRSet as an upper bound
		  for the TTL". As a result, query load on
		  authoritative servers would peak at signature
		  expiration time, as this is also the time at which
		  records simultaneously expire from caches.
		</t>
		<t>
		  To avoid query load peaks, we suggest the TTL on all
		  the RRs in your zone to be at least a few times
		  smaller than your signature validity period.
		</t>
	      </list>

	    <t>
	      We suggest the signature publication period to end at
	      least one Maximum Zone TTL duration before the end of
	      the signature validity period.
	    </t>

	      <list style="hanging">

		<t>
		  Re-signing a zone shortly before the end of the
		  signature validity period may cause simultaneous
		  expiration of data from caches. This in turn may
		  lead to peaks in the load on authoritative
		  servers. To avoid this schemes are deployed whereby
		  the zone is periodically visited for a resigning
		  operation and those signatures that are within a so
		  called refresh intervall from signature expiration
		  are recreated. Also see <xref target="sigval"/>
		  below.
		</t>

	      </list>

	    <t>
	      We suggest the Minimum Zone TTL to be long enough to
	      both fetch and verify all the RRs in the trust chain. In
	      workshop environments, it has been demonstrated <xref
	      target="NIST-workshop" /> that a low TTL (under 5 to 10
	      minutes) caused disruptions because of the following two
	      problems:
	    </t>
	      <list style="hanging">

		<t>
		  1. During validation, some data may expire before
		  the validation is complete. The validator should be
		  able to keep all data until it is completed. This
		  applies to all RRs needed to complete the chain of
		  trust: DSes, DNSKEYs, RRSIGs, and the final answers,
		  i.e., the RRSet that is returned for the initial
		  query.
		</t>
		<t>
		  2. Frequent verification causes load on recursive
		  nameservers. Data at delegation points, DSes, DNSKEYs, and
		  RRSIGs benefit from caching. The TTL on those should be
		  relatively long.

		</t>
	      </list>
	    <t>
	      Slave servers will need to be able to fetch newly signed
	      zones well before the RRSIGs in the zone served by the
	      slave server pass their signature expiration time.

	    </t>

	      <list style="hanging">


		<t>
		  When a slave server is out of sync with its master
		  and data in a zone is signed by expired signatures,
		  it may be better for the slave server not to give
		  out any answer.
		</t>

		<t>
		  Normally, a slave server that is not able to contact
		  a master server for an extended period will expire a
		  zone. When that happens, the server will respond
		  differently to queries for that zone. Some servers
		  issue SERVFAIL, whereas others turn off the 'AA' bit
		  in the answers.

		  The time of expiration is set in the SOA
		  record and is relative to the last successful refresh
		  between the master and the slave servers. There exists no
		  coupling between the signature expiration of RRSIGs in
		  the zone and the expire parameter in the SOA.
		</t>

		<t>
		  If the server serves a DNSSEC zone, then it may well
		  happen that the signatures expire well before the SOA
		  expiration timer counts down to zero. It is not possible
		  to completely prevent this from happening by tweaking
		  the SOA parameters.
		</t>
		<t>
		  However, the effects can be minimized where the SOA
		  expiration time is equal to or shorter than the
		  signature validity period.
		</t>



		<t>
		  The consequence of an authoritative server not being
		  able to update a zone, whilst that zone includes expired
		  signatures, is that non-secure resolvers will continue to
		  be able to resolve data served by the particular slave
		  servers while security-aware resolvers will experience
		  problems because of answers being marked as Bogus.
		</t>


		<t>
		  We suggest the SOA expiration timer being approximately
		  one third or one fourth of the signature validity period.
		  It will allow problems with transfers from the master server
		  to be noticed before the actual signature times out.
		</t>


		<t>
		  We also suggest that operators of nameservers that
		  supply secondary services develop 'watch dogs' to spot
		  upcoming signature expirations in zones they slave, and
		  take appropriate action.
		</t>

		<t>
		  When determining the value for the expiration parameter
		  one has to take the following into account: What are the
		  chances that all my secondaries expire the zone? How quickly
		  can I reach an administrator of secondary servers to
		  load a valid zone? These questions are not DNSSEC
		  specific but may influence the choice of your signature
		  validity intervals.
		</t>
	      </list>

	  </list>
	</t>
      </section> <!-- time considerations -->


    <section title="Signature Validation Periods" anchor="sigval">
      <t>
      [OK: This section is newly introduced and needs a check on
      consistency with the rest of the document]
      </t>
      <section title="Maximum Value">
      <t>
	The first consideration for choosing a maximum signature
	validity period is the risk of a replay attack. For low-value,
	long-term stable resources the risks may be minimal and the
	signature validity period may be multiple months. Although
	signature validity periods of many years are allowed the same
	operational habit arguments as in <xref
	target="rolling-ksk-ta"/> play a role: when a zone is resigned
	with some regularity then operators remain conscious about the
	operational necessity of resigning.
      </t>
      </section>
      <section title="Minimum Value">
	<t> 
	  The minimum value of the signature validity period is set by
	  the time by which one would like to survive operational
	  failure in provisioning: what is the time that a failure
	  will be noticed, what is the time that action is expected to
	  be taken? By answering these questions availability of
	  operators during (long) weekends or access to backup media
	  needs to be taken into account which could easily suggest a
	  minimum Signature Validity period of a few days.
	</t>
	<t>
	  Note however, the argument above is assuming that zone data
	  has just been signed and published when the problem
	  occurred. In practice it may be that a zone is signed
	  according to a frequency set by the Resign Period whereby
	  the signer visits the zone content and only refreshes
	  signatures that are close to expiring: the signer will only
	  refresh signatures if they are within the Refresh Period
	  from the signature expiration time.  The Resign Period must
	  be smaller than the Refresh Period in order for zone data to
	  be signed timely.
	</t>
	<t>
	  If an operational problem occurs during resigning then the
	  signatures in the zone wich will expire first are the ones
	  that have been generated longest ago. And in the worst case
	  these signatures are the Refresh Period minus the Resign
	  Period away from signature validation.
	</t>
	<t>
	  In other words, the minimum Signature Validity intervall is
	  set by first choosing the Refresh Period (usually a few
	  days), then defining the Resign period in such a way that 
	  the Refresh Period minus the Resign period sets the time in
	  which operational havoc can be resolved.
	</t>
	<t>
	  To make matters slightly mor complicated. Some signers apply
	  some jitter to the signature expiry time so that not all
	  signatures expire at the same time.  The jitter should not
	  influence your calculation as long as it is smaller than the
	  refresh period and the resign period is at least half the
	  refresh period [OK: The above needs careful review]
	</t>


	<figure>
	<?rfc?><?rfc linefile="1:SignatureFigure.xml"?><artwork>

 Inception      Signing                                 Expiration
 time             time                                     time
 |                  |                              |       |       |
 |------------------|------------------------------|.......|.......|
 |                  |                              |       |       |
                                                       +/- jitter

 | Inception offset |         Validity Period              |
 | &lt;---------------&gt;|&lt;------------------------------------&gt;|



                          
 Inception      Signing  reuse  reuse  reuse    new      Expiration
 time             time                          signature     time
 |                  |      |      |      |      |             |         
 |------------------|-----------------------------------------|         
 |                  |      |      |      |      |             |         
                     &lt;----&gt; &lt;----&gt; &lt;----&gt; &lt;----&gt;                    
                 Resign Period
                     
                                             |                  |
                                             |&lt;-Refresh Period-&gt;|
                                             |                  |
</artwork>
<?rfc linefile="1540:Rollover.xml"?>
	  <postamble>
	  </postamble>
	</figure>	
	

      </section>
      <section title="differentiation between RR sets">
	<t>
	  It is possible to vary signature validity periods between
	  signatures over different RR sets in the zone. In practice
	  this could be done when zones contain highly volatile data
	  (which may be the case in dynamic update environments). Note
	  however that the risk of replay (e.g. by stale secondary
	  servers) is what should be leading in determining the
	  signature validity period since the TTL on the data itself
	  still are the primary parameter for cache expiry.  [OK: are
	  there strong arguments besides replay risks for varying
	  signature validity]
	</t>
	<t>
	  In some cases the risk of replaying existing data might be
	  different from the risk of replaying the denial of data. In
	  those cases the signature validity period on NSEC or NSEC3
	  records may be tweaked accordingly.
	</t>
	<t>
	  When a zone contains secure delegations then a relatively
	  short signature validity interval protects the child agains
	  replay attacks, in the case the child's key is compromised
	  (see <xref target="DSvalidity"/>). Since there is a higher
	  operational risk for the parent registry when choosing a
	  short validity intervall and a higher operational risk for
	  the child when choosing a long validity period some (price)
	  differentiation may occur for validity periods between
	  individual DS RRs in a single zone.
	</t>
	<t>
	  There seem to be no other arguments for differentiation in
	  validity periods.
	</t>
      </section>
      
      <section title="Other timing parameters in a zone">
	<t>
	  [OK: Isn't the following not to vague? Is it sufficient?]
	</t>
	<t>
	  The arguments for tuning minimum signature validity period
	  are remarkably similar to the arguments used to set the
	  SOA expiration timer. It is advised to set the expiration
	  time longer than the signature validity period.
	</t>

      </section>
      
    </section>
    
    
    </section> <!-- time in DNS -->


      
      
    </section><!-- Signature generation key rollover and related policies -->
<?rfc linefile="83:draft-ietf-dnsop-rfc4641bis.xml"?>
    
    <?rfc?><?rfc linefile="1:NSEC_NSEC3.xml"?>
<!-- Included from NSEC_NSEC3.xml -->
<!-- $Id -->

<section anchor="nsec_nsec3" title="Next Record type">
  <t>
    One of the design tradeofs made during the development of DNSSEC
    has been to seperate the signing and serving operations instead of
    performing cryptographic operations on the fly. It is therefore
    necessry to create records that cover the very large number of
    non-existent names that lie between the names that do exist.
  </t>
  <t>
    There are two mechanisms to provide authenticated proof of
    non-existence of domain names in DNSSEC: clear text one and an obfuscated-data
    one.  Each mechanism
    <list style="symbols">
      <t>
	includes a list of all the RRTYPEs present which can be used
	to prove the non-existence of RRTYPEs at a certain name;
      </t>
      <t>
	stores only the name for which the zone is authoritative (that
	is, glue in the zone is omitted); and
      </t>
      <t>
	uses a specific RRTYPE to store information about the RRTYPEs
	present at the name: the clear-text mechanism uses NSEC, and
	the obfuscated-data mechanism uses NSEC3.
      </t>
    </list>
  </t>
  
  <section title="Differences between  NSEC and NSEC3">
    <t>
      The clear text mechanism (NSEC) is implemented using a sorted
      linked list of names in the zone.  The obfuscated-data mechanism
      (NSEC3) first hashes the names using a one-way hash function,
      and then sorts the resulting (hashed) strings.
    </t>
 
    <t>
      The NSEC record requires no cryptographic operations aside from
      validating its associated signature record. It is human readable
      and can be used in manual queries to determine correct
      operation.  The disadvantage is that it allows for "zone
      walking", where one can request all the entries of a zone by
      following the next RRlabel pointed to in each subsequent NSEC
      record.
    </t>
    <t>
      Though all agree DNS data is accessible through query
      mechanisms, a side effect of NSEC is that it allows the contents
      of a zone file to be enumerated in full by sequential
      queries. Whilst for some operators this behaviour is acceptable
      or even desirable, for others it is undesirable for policy,
      regulatory or other reasons.  This is the first difference
      between NSEC and NSEC3.
    </t>
    <t>
      The second difference between NSEC and NSEC3 is that NSEC
      requires a signature over every RR in the zonefile, thereby
      ensuring that any denial of existence is cryptographically
      signed. However, in a large zonefile containing many delegations
      very few of which are to signed zones, this may produce
      unacceptable additional overhead especially where insecure
      delegations are subject to frequent update (a typical example
      might be a TLD operator with few registrants using secure
      delegations). NSEC3 allows intervals between two such
      delegations to "Opt-out" in which case they may contain one more
      more insecure delegations, thus reducing the size and
      cryptographic complexity of the zone at the expense of the
      ability to cryptographically deny the existence of names in a
      specific span.
    </t>
    <t>
      The NSEC3 record uses a hashing method of the requested RRlabel.
      To increase the workload required to guess entries in the zone,
      the number of hashing iteration's can be specified in the NSEC3
      record. Additionally, a salt can be specified that also modifies
      the hashes. Note that NSEC3 does not give full protection
      against information leakage from the zone.
    </t>
  </section>
  <section title="NSEC or NSEC3">

    <t> 
      The first motivation to deploy NSEC3, prevention of zone
      enumeration, only makes sense when zone content is not highly
      structured or trivially guessable. Highly structured zones such
      as the in-addr.arpa, ip6.arpa and e164.arpa can be trivially
      enumerated using ordinary DNS properties while for small zones
      that only contain contain records in the APEX and a few common
      RRlabels such as "www" or "mail" guessing zone content and
      proving completeness is also trivial when using NSEC3.
    </t>
    <t>
      In those cases the use of NSEC is recommended to ease the work
      required by signers and validating resolvers.
    </t>
    <t>
      
      For large zones where there is an implication of "not readily
      available" RRlabels, such as those where one has to sign an NDA
      before obtaining it, NSEC3 is recommended.
    </t>
    <t>The considerations for the second reason to deploy NSEC3 are
    discussed below (<xref target="opt-out"/>).</t>
    
  </section>
  
  <section title="NSEC3 parameters">
    <t>
      The NSEC3 hashing algorithm is performed on the Fully Qualified
      Domain Name (FQDN) in its uncompressed form. This ensures brute
      force work done by an attacker for one (FQDN) RRlabel cannot be
      re-used for another (FQDN) RRlabel attack, as these entries are
      per definition unique.
    </t>
    <section title="NSEC3 Algorithm">
      <t>
	At the moment of writing there is only one NSEC3 Hashing
	algorithm defined. <xref target="RFC5155"/> specifically calls
	out that when a new hash algorithm for use with NSEC3 is
	specified, a transition mechanism MUST also be
	defined. Therefore this document does not considder NSEC3 hash
	algorithm transition.

      </t>
    </section>
    <section title="NSEC3 Iterations">
      <t>
	One of the concerns with NSEC3 is that bad actors could
	perform a pre-calculated dictionary attack in order to assess
	if certain domain names exist within the zones or not. Two
	mechanisms are introduced in the NSEC3 specification to
	increase the costs of such dictionary attacks: Iterations and
	Salt.
      </t>
      
      <t>
	<xref target="RFC5155">RFC5155</xref> considers the trade-offs
	between incuring cost during the signing process, imposing
	costs to the validating nameserver, while still providing a
	reasonable barrier against dictionary attacks. It provides
	useful limits of iterations compared to RSA key size. These
	are 150 iterations for 1024 bit keys, 500 iterations for 2048
	bit keys and 2,500 iterations for 4096 bit keys. Choosing
	2/3rd of the maximum is deemed to be a sufficiently costly yet
	not excessive value.
      </t>
    </section>
    <section title="NSEC3 Salt">
      <t>
	While the NSEC3 iterations parameter increases the cost of
	hashing a dictionary word, the NSEC3 salt reduces the lifetime
	for which that calculated hash can be used. A change of the
	salt value by the zone owner would cause an attacker to lose
	all precalculated work for that zone.
      </t>
      <t>
	The FQDN RRlabel, which is part of the value that is hashed,
	already ensures that brute force work for one RRlabel can not
	be re-used to attack other RRlabel (e.g. in other domains) due
	to their uniqueness.
      </t>

      <t>
	The salt of all NSEC3 records in a zone needs to be the same.
	Since changing the salt requires all the NSEC3 records to be
	regenerated, and thus requires generating new RRSIG's over
	these NSEC3 records, it is recommended to align the change of
	the salt with a change of the Zone Signing Key, as that
	process in itself already requires all RRSIG's to be
	regenerated. If there is no critical dependency on incremental
	signing and the whole zone can be signed with little effort
	there is no need for such alignment. However, unlike Zone
	Signing Key changes, NSEC3 salt changes do not need special
	rollover procedures.  It is possible to change the salt each
	time the zone is updated.
      </t>
    </section>
    <section anchor="opt-out" title="Opt-out">
      <t>
	The Opt-Out mechanism was introduced to allow for a gradual
	introduction of signed records in zones that contain mostly
	delegation records. The use of the OPT-OUT flag changes the
	meaning of the NSEC3 span from authoritative denial of the
	existence of names within the span to a proof that DNSSEC is
	not available for the delegations within the span. [Editors
	Note: One could make this construct more correct by talking
	about the hashed names and the hashed span, but I believe that
	is overkill]. This allows for the addition or removal of the
	delegations covered by the span without recalculating or re-
	signing RRs in the NSEC3 RR chain.
      </t>
      <t>
	Opt-Out is specified to be used only over delegation points
	and will therefore only bring relieve in zones with a large
	number of zones and where the number of secure delegations is
	small. This consideration typically holds for large
	top-level-domains and similar zones, in most other
	circumstances Opt-Out should not be deployed. Further
	considerations can be found in <xref target="RFC5155">RFC5155
	section 12.2</xref>.
	
      </t>
    </section>
  </section>
</section><?rfc linefile="85:draft-ietf-dnsop-rfc4641bis.xml"?>
    
    
    
    
    
    <section title="Security Considerations">
      
      <t> 
	DNSSEC adds data integrity to the DNS. This document tries to
	assess the operational considerations to maintain a stable and
	secure DNSSEC service. Not taking into account the 'data
	propagation' properties in the DNS will cause validation
	failures and may make secured zones unavailable to
	security-aware resolvers.  
      </t>
      
      
    </section><!--Security considerations-->
    
    
    <section title="IANA considerations">
      <t>
	There are no IANA considerations with respect to this document
      </t>
    </section>
    
    <section title="Acknowledgments">
      <t>
	Most of the text of this document is copied from <xref
	target="RFC4641">RFC4641</xref>. That document was edited by
	Olaf Kolkman and Miek Gieben. Other people that contributed or
	where otherwise involved in that work were in random order:
	Rip Loomis, Olafur Gudmundsson, Wesley Griffin, Michael
	Richardson, Scott Rose, Rick van Rein, Tim McGinnis, Gilles
	Guette Olivier Courtay, Sam Weiler, Jelte Jansen, Niall
	O'Reilly, Holger Zuleger, Ed Lewis, Hilarie Orman, Marcos
	Sanz, Peter Koch, Mike StJohns, Emma Bretherick, Adrian
	Bedford, and Lindy Foster, G. Guette, and O. Courtay.
	</t>
	<t>
	  For this version of the document we would like to acknowldge a few 
	  people for significant contributions:

	  <list style="symbols">
	    <t> 
	      Paul Hoffman for his contribution on the choice of
	      cryptographic paramenters and addressing some of the
	      trust anchor issues.
	    </t>
	    <t> 
	      Jelte Jansen who provided the text in <xref
	      target="KAR"/>
	    </t>
	    <t> 
	      Paul Wouters who provided the initial text for <xref
	      target="nsec_nsec3"/> and Alex Bligh who improved it.
	    </t>
	    <t>
	      Erik Rescorla's blogpost on "the Security of ZSK
	      rollovers" inspired text in <xref
	      target="zsk-ksk-motivation"/>.
	    </t>
	    <t>
	      The figure in <xref target="sigval"/> was adapted from
	      the OpenDNSSEC user documentation.
	    </t>
	  </list>

	  In addition valuable contributions in the form of text,
	  comments, or review where provided by Mark Andrews, Patrik Faltstrom, Tony
	  Finch, Olafur Gudmundsson,  Alfred Hines, Bill Manning, Scott Rose.
	  </t>
	  <t>
	    [EDITOR NOTE: please let me know if there is an oversight here]
	  </t>
	  
	  
	</section><!-- Acknowledgments -->
	
	
	
  </middle>
  
  
  <back>
    
    
    <references title='Normative References'>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.1034.xml"?>

<reference anchor='RFC1034'>

<front>
<title abbrev='Domain Concepts and Facilities'>Domain names - concepts and facilities</title>
<author initials='P.' surname='Mockapetris' fullname='P. Mockapetris'>
<organization>Information Sciences Institute (ISI)</organization></author>
<date year='1987' day='1' month='November' /></front>

<seriesInfo name='STD' value='13' />
<seriesInfo name='RFC' value='1034' />
<format type='TXT' octets='129180' target='ftp://ftp.isi.edu/in-notes/rfc1034.txt' />
</reference>
<?rfc linefile="174:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.1035.xml"?>

<reference anchor='RFC1035'>

<front>
<title abbrev='Domain Implementation and Specification'>Domain names - implementation and specification</title>
<author initials='P.' surname='Mockapetris' fullname='P. Mockapetris'>
<organization>USC/ISI</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90291</code>
<country>US</country></postal>
<phone>+1 213 822 1511</phone></address></author>
<date year='1987' day='1' month='November' /></front>

<seriesInfo name='STD' value='13' />
<seriesInfo name='RFC' value='1035' />
<format type='TXT' octets='125626' target='ftp://ftp.isi.edu/in-notes/rfc1035.txt' />
</reference>
<?rfc linefile="175:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4033.xml"?>

<reference anchor='RFC4033'>

<front>
<title>DNS Security Introduction and Requirements</title>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'>
<organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'>
<organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'>
<organization /></author>
<date year='2005' month='March' />
<abstract>
<t>The Domain Name System Security Extensions (DNSSEC) add data origin authentication and data integrity to the Domain Name System.  This document introduces these extensions and describes their capabilities and limitations.  This document also discusses the services that the DNS security extensions do and do not provide.  Last, this document describes the interrelationships between the documents that collectively describe DNSSEC. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4033' />
<format type='TXT' octets='52445' target='ftp://ftp.isi.edu/in-notes/rfc4033.txt' />
</reference>
<?rfc linefile="176:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4034.xml"?>

<reference anchor='RFC4034'>

<front>
<title>Resource Records for the DNS Security Extensions</title>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'>
<organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'>
<organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'>
<organization /></author>
<date year='2005' month='March' />
<abstract>
<t>This document is part of a family of documents that describe the DNS Security Extensions (DNSSEC). The DNS Security Extensions are a collection of resource records and protocol modifications that provide source authentication for the DNS. This document defines the public key (DNSKEY), delegation signer (DS), resource record digital signature (RRSIG), and authenticated denial of existence (NSEC) resource records. The purpose and format of each resource record is described in detail, and an example of each resource record is given.&lt;/t>&lt;t> This document obsoletes RFC 2535 and incorporates changes from all updates to RFC 2535. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4034' />
<format type='TXT' octets='63879' target='ftp://ftp.isi.edu/in-notes/rfc4034.txt' />
</reference>
<?rfc linefile="177:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4035.xml"?>

<reference anchor='RFC4035'>

<front>
<title>Protocol Modifications for the DNS Security Extensions</title>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='R.' surname='Austein' fullname='R. Austein'>
<organization /></author>
<author initials='M.' surname='Larson' fullname='M. Larson'>
<organization /></author>
<author initials='D.' surname='Massey' fullname='D. Massey'>
<organization /></author>
<author initials='S.' surname='Rose' fullname='S. Rose'>
<organization /></author>
<date year='2005' month='March' />
<abstract>
<t>This document is part of a family of documents that describe the DNS Security Extensions (DNSSEC). The DNS Security Extensions are a collection of new resource records and protocol modifications that add data origin authentication and data integrity to the DNS. This document describes the DNSSEC protocol modifications. This document defines the concept of a signed zone, along with the requirements for serving and resolving by using DNSSEC. These techniques allow a security-aware resolver to authenticate both DNS resource records and authoritative DNS error indications.&lt;/t>&lt;t> This document obsoletes RFC 2535 and incorporates changes from all updates to RFC 2535. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4035' />
<format type='TXT' octets='130589' target='ftp://ftp.isi.edu/in-notes/rfc4035.txt' />
</reference>
<?rfc linefile="178:draft-ietf-dnsop-rfc4641bis.xml"?>
    </references>
    
    
    
    
    <references title='Informative References'>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.2119.xml"?>

<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
<format type='HTML' octets='17491' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>
<?rfc linefile="185:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.1995.xml"?>

<reference anchor='RFC1995'>

<front>
<title>Incremental Zone Transfer in DNS</title>
<author initials='M.' surname='Ohta' fullname='Masataka Ohta'>
<organization>Computer Center Tokyo Institute of Technology</organization>
<address>
<postal>
<street>2-12-1, O-okayama</street>
<street>Meguro-ku</street>
<city>Tokyo</city>
<code>152</code>
<country>JP</country></postal>
<phone>+81 3 57343299</phone>
<facsimile>+81 3 57343415</facsimile>
<email>mohta@necom830.hpcl.titech.ac.jp</email></address></author>
<date year='1996' month='August' />
<abstract>
<t>This document proposes extensions to the DNS protocols to provide an incremental zone transfer (IXFR) mechanism.</t></abstract></front>

<seriesInfo name='RFC' value='1995' />
<format type='TXT' octets='16810' target='ftp://ftp.isi.edu/in-notes/rfc1995.txt' />
</reference>
<?rfc linefile="186:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.1996.xml"?>

<reference anchor='RFC1996'>

<front>
<title>A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY)</title>
<author initials='P.' surname='Vixie' fullname='Paul Vixie'>
<organization>Internet Software Consortium</organization>
<address>
<postal>
<street>Star Route Box 159A</street>
<city>Woodside</city>
<region>CA</region>
<code>94062</code>
<country>US</country></postal>
<phone>+1 415 747 0204</phone>
<email>paul@vix.com</email></address></author>
<date year='1996' month='August' />
<abstract>
<t>This memo describes the NOTIFY opcode for DNS, by which a master server advises a set of slave servers that the master's data has been changed and that a query should be initiated to discover the new data.</t></abstract></front>

<seriesInfo name='RFC' value='1996' />
<format type='TXT' octets='15247' target='ftp://ftp.isi.edu/in-notes/rfc1996.txt' />
</reference>
<?rfc linefile="187:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.2308.xml"?>

<reference anchor='RFC2308'>

<front>
<title abbrev='DNS NCACHE'>Negative Caching of DNS Queries (DNS NCACHE)</title>
<author initials='M.' surname='Andrews' fullname='Mark Andrews'>
<organization>CSIRO - Mathematical and Information Sciences</organization>
<address>
<postal>
<street>Locked Bag 17</street>
<street>North Ryde NSW 2113</street>
<country>AUSTRALIA</country></postal>
<phone>+61 2 9325 3148</phone>
<email>Mark.Andrews@cmis.csiro.au</email></address></author>
<date year='1998' month='March' />
<area>Applications</area>
<keyword>domain name system</keyword>
<keyword>DNS</keyword>
<abstract>
<t>

   [RFC1034] provided a description of how to cache negative responses.

   It however had a fundamental flaw in that it did not allow a name

   server to hand out those cached responses to other resolvers, thereby

   greatly reducing the effect of the caching.  This document addresses

   issues raise in the light of experience and replaces [RFC1034 Section

   4.3.4].
</t>
<t>



   Negative caching was an optional part of the DNS specification and

   deals with the caching of the non-existence of an RRset [RFC2181] or

   domain name.

</t>
<t>


   Negative caching is useful as it reduces the response time for

   negative answers.  It also reduces the number of messages that have

   to be sent between resolvers and name servers hence overall network

   traffic.  A large proportion of DNS traffic on the Internet could be

   eliminated if all resolvers implemented negative caching.  With this

   in mind negative caching should no longer be seen as an optional part

   of a DNS resolver.
</t></abstract></front>

<seriesInfo name='RFC' value='2308' />
<format type='TXT' octets='41428' target='ftp://ftp.isi.edu/in-notes/rfc2308.txt' />
<format type='XML' octets='41491' target='http://xml.resource.org/public/rfc/xml/rfc2308.xml' />
</reference>
<?rfc linefile="188:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.3007.xml"?>

<reference anchor='RFC3007'>

<front>
<title>Secure Domain Name System (DNS) Dynamic Update</title>
<author initials='B.' surname='Wellington' fullname='B. Wellington'>
<organization /></author>
<date year='2000' month='November' />
<abstract>
<t>This document proposes a method for performing secure Domain Name System (DNS) dynamic updates. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3007' />
<format type='TXT' octets='18056' target='ftp://ftp.isi.edu/in-notes/rfc3007.txt' />
</reference>
<?rfc linefile="189:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.3375.xml"?>

<reference anchor='RFC3375'>

<front>
<title>Generic Registry-Registrar Protocol Requirements</title>
<author initials='S.' surname='Hollenbeck' fullname='S. Hollenbeck'>
<organization /></author>
<date year='2002' month='September' /></front>

<seriesInfo name='RFC' value='3375' />
<format type='TXT' octets='46022' target='ftp://ftp.isi.edu/in-notes/rfc3375.txt' />
</reference>
<?rfc linefile="190:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.3766.xml"?>

<reference anchor='RFC3766'>

<front>
<title>Determining Strengths For Public Keys Used For Exchanging Symmetric Keys</title>
<author initials='H.' surname='Orman' fullname='H. Orman'>
<organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<date year='2004' month='April' />
<abstract>
<t>Implementors of systems that use public key cryptography to exchange symmetric keys need to make the public keys resistant to some predetermined level of attack.  That level of attack resistance is the strength of the system, and the symmetric keys that are exchanged must be at least as strong as the system strength requirements.  The three quantities, system strength, symmetric key strength, and public key strength, must be consistently matched for any network protocol usage.  While it is fairly easy to express the system strength requirements in terms of a symmetric key length and to choose a cipher that has a key length equal to or exceeding that requirement, it is harder to choose a public key that has a cryptographic strength meeting a symmetric key strength requirement.  This document explains how to determine the length of an asymmetric key as a function of a symmetric key strength requirement.  Some rules of thumb for estimating equivalent resistance to large-scale attacks on various algorithms are given.  The document also addresses how changing the sizes of the underlying large integers (moduli, group sizes, exponents, and so on) changes the time to use the algorithms for key exchange.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='86' />
<seriesInfo name='RFC' value='3766' />
<format type='TXT' octets='55939' target='ftp://ftp.isi.edu/in-notes/rfc3766.txt' />
</reference>
<?rfc linefile="191:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4086.xml"?>

<reference anchor='RFC4086'>

<front>
<title>Randomness Requirements for Security</title>
<author initials='D.' surname='Eastlake' fullname='D. Eastlake'>
<organization /></author>
<author initials='J.' surname='Schiller' fullname='J. Schiller'>
<organization /></author>
<author initials='S.' surname='Crocker' fullname='S. Crocker'>
<organization /></author>
<date year='2005' month='June' />
<abstract>
<t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts. However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities. The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.&lt;/t>&lt;t> Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult. This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities. It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='106' />
<seriesInfo name='RFC' value='4086' />
<format type='TXT' octets='114321' target='ftp://ftp.isi.edu/in-notes/rfc4086.txt' />
</reference>
<?rfc linefile="192:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4310.xml"?>

<reference anchor='RFC4310'>

<front>
<title>Domain Name System (DNS) Security Extensions Mapping for the Extensible Provisioning Protocol (EPP)</title>
<author initials='S.' surname='Hollenbeck' fullname='S. Hollenbeck'>
<organization /></author>
<date year='2005' month='December' />
<abstract>
<t>This document describes an Extensible Provisioning Protocol (EPP) extension mapping for the provisioning and management of Domain Name System security extensions (DNSSEC) for domain names stored in a shared central repository.  Specified in XML, this mapping extends the EPP domain name mapping to provide additional features required for the provisioning of DNS security extensions. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4310' />
<format type='TXT' octets='46326' target='ftp://ftp.isi.edu/in-notes/rfc4310.txt' />
</reference>
<?rfc linefile="193:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4641.xml"?>

<reference anchor='RFC4641'>

<front>
<title>DNSSEC Operational Practices</title>
<author initials='O.' surname='Kolkman' fullname='O. Kolkman'>
<organization /></author>
<author initials='R.' surname='Gieben' fullname='R. Gieben'>
<organization /></author>
<date year='2006' month='September' />
<abstract>
<t>This document describes a set of practices for operating the DNS with security extensions (DNSSEC). The target audience is zone administrators deploying DNSSEC.&lt;/t>&lt;t> The document discusses operational aspects of using keys and signatures in the DNS. It discusses issues of key generation, key storage, signature generation, key rollover, and related policies.&lt;/t>&lt;t> This document obsoletes RFC 2541, as it covers more operational ground and gives more up-to-date requirements with respect to key sizes and the new DNSSEC specification. This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4641' />
<format type='TXT' octets='79894' target='ftp://ftp.isi.edu/in-notes/rfc4641.txt' />
</reference>
<?rfc linefile="194:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4949.xml"?>

<reference anchor='RFC4949'>

<front>
<title>Internet Security Glossary, Version 2</title>
<author initials='R.' surname='Shirey' fullname='R. Shirey'>
<organization /></author>
<date year='2007' month='August' />
<abstract>
<t>This Glossary provides definitions, abbreviations, and explanations of terminology for information system security.  The 334 pages of entries offer recommendations to improve the comprehensibility of written material that is generated in the Internet Standards Process (RFC 2026).  The recommendations follow the principles that such writing should (a) use the same term or definition whenever the same concept is mentioned; (b) use terms in their plainest, dictionary sense; (c) use terms that are already well-established in open publications; and (d) avoid terms that either favor a particular vendor or favor a particular technology or mechanism over other, competing techniques that already exist or could be developed.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4949' />
<format type='TXT' octets='867626' target='ftp://ftp.isi.edu/in-notes/rfc4949.txt' />
</reference>
<?rfc linefile="195:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.5011.xml"?>

<reference anchor='RFC5011'>

<front>
<title>Automated Updates of DNS Security (DNSSEC) Trust Anchors</title>
<author initials='M.' surname='StJohns' fullname='M. StJohns'>
<organization /></author>
<date year='2007' month='September' />
<abstract>
<t>This document describes a means for automated, authenticated, and authorized updating of DNSSEC "trust anchors". The method provides protection against N-1 key compromises of N keys in the trust point key set. Based on the trust established by the presence of a current anchor, other anchors may be added at the same place in the hierarchy, and, ultimately, supplant the existing anchor(s).&lt;/t>&lt;t> This mechanism will require changes to resolver management behavior (but not resolver resolution behavior), and the addition of a single flag bit to the DNSKEY record. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5011' />
<format type='TXT' octets='30138' target='ftp://ftp.isi.edu/in-notes/rfc5011.txt' />
</reference>
<?rfc linefile="196:draft-ietf-dnsop-rfc4641bis.xml"?>
      
      
      <!--   <reference anchor="selecting-crypto-key-sizes">
	   <front>
	   <title>Selecting Cryptographic Key
	   Sizes</title>
	   
	   <author initials="A." surname="Lenstra" fullname="A. Lenstra">
	   <organization></organization>
	   </author>
	   <author initials="E." surname="Verheul" fullname="E. Verheul">
	   <organization></organization>
	   </author>
	   
	   
	   <date year="2001" />
	   </front>
	   <seriesInfo name="The Journal of Cryptology 14" value="(255-293)" />
	   </reference>
	   
      -->
      
      <!-- <reference anchor="applied-crypto">
	   <front>
	   <title>Applied Cryptography: Protocols, Algorithms, and
	   Source Code in C</title>
	   
	   <author initials="B." surname="Schneier" fullname="B. Schneier">
	   <organization></organization>
	   </author>
	   
	   <date year="1996" />
	   </front>
	   <seriesInfo name="ISBN (hardcover) 0-471-12845-7, ISBN
	   (paperback) 0-471-59756-2" value="Published by John Wiley &amp;
	   Sons Inc." />
	   </reference>-->
      <reference anchor="NIST-workshop">
	<front>
	  <title>NIST DNSSEC workshop notes</title>
	  
	  <author initials="S." surname="Rose" fullname="S. Rose">
	    <organization></organization>
	  </author>
	  
	  <date month ="June" year="2001" />
	</front>
	<seriesInfo name="" value="" />
      </reference>
      
      
      <reference anchor="NIST-SP-800-90">
	<front>
	  <title>
	    Recommendation for Random Number Generation Using
	    Deterministic Random Bit Generators (Revised)
	  </title>
	  
	  <author initials="E." surname="Barker" fullname="Elaine Barker">
	    <organization>Computer Security Division, Information Technology Laboratory
	    
	    </organization>
	  </author>
	  <author initials="J." surname="Kelsey" fullname="John Kelsey">
	    <organization>Computer Security Division, Information Technology Laboratory
	    
	    </organization>
	  </author>
	  
	  
	  <date year="2007" month="March"/>
	</front>
	<seriesInfo name="Nist Special Publication" value="800-90" />
      </reference>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.4509.xml"?>

<reference anchor='RFC4509'>

<front>
<title>Use of SHA-256 in DNSSEC Delegation Signer (DS) Resource Records (RRs)</title>
<author initials='W.' surname='Hardaker' fullname='W. Hardaker'>
<organization /></author>
<date year='2006' month='May' />
<abstract>
<t>This document specifies how to use the SHA-256 digest type in DNS Delegation Signer (DS) Resource Records (RRs).  DS records, when stored in a parent zone, point to DNSKEYs in a child zone. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4509' />
<format type='TXT' octets='14155' target='ftp://ftp.isi.edu/in-notes/rfc4509.txt' />
</reference>
<?rfc linefile="271:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.5155.xml"?>

<reference anchor='RFC5155'>

<front>
<title>DNS Security (DNSSEC) Hashed Authenticated Denial of Existence</title>
<author initials='B.' surname='Laurie' fullname='B. Laurie'>
<organization /></author>
<author initials='G.' surname='Sisson' fullname='G. Sisson'>
<organization /></author>
<author initials='R.' surname='Arends' fullname='R. Arends'>
<organization /></author>
<author initials='D.' surname='Blacka' fullname='D. Blacka'>
<organization /></author>
<date year='2008' month='March' />
<abstract>
<t>The Domain Name System Security (DNSSEC) Extensions introduced the NSEC resource record (RR) for authenticated denial of existence.  This document introduces an alternative resource record, NSEC3, which similarly provides authenticated denial of existence.  However, it also provides measures against zone enumeration and permits gradual expansion of delegation-centric zones. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5155' />
<format type='TXT' octets='112338' target='ftp://ftp.isi.edu/in-notes/rfc5155.txt' />
</reference>
<?rfc linefile="272:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.5246.xml"?>

<reference anchor='RFC5246'>

<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='ftp://ftp.rfc-editor.org/in-notes/rfc5246.txt' />
</reference>
<?rfc linefile="273:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.RFC.5702.xml"?>

<reference anchor='RFC5702'>

<front>
<title>Use of SHA-2 Algorithms with RSA in DNSKEY and RRSIG Resource Records for DNSSEC</title>
<author initials='J.' surname='Jansen' fullname='J. Jansen'>
<organization /></author>
<date year='2009' month='October' />
<abstract>
<t>This document describes how to produce RSA/SHA-256 and RSA/SHA-512 DNSKEY and RRSIG resource records for use in the Domain Name System Security Extensions (RFC 4033, RFC 4034, and RFC 4035). [STANDARDS TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5702' />
<format type='TXT' octets='19425' target='ftp://ftp.isi.edu/in-notes/rfc5702.txt' />
</reference>
<?rfc linefile="274:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.I-D.draft-ietf-dnsop-dnssec-key-timing-00.xml"?>

<reference anchor='I-D.ietf-dnsop-dnssec-key-timing'>
<front>
<title>DNSSEC Key Timing Considerations</title>

<author initials='S' surname='Morris' fullname='Stephen Morris'>
    <organization />
</author>

<author initials='J' surname='Ihren' fullname='Johan Ihren'>
    <organization />
</author>

<author initials='J' surname='Dickinson' fullname='John Dickinson'>
    <organization />
</author>

<date month='July' day='1' year='2010' />

<abstract><t>This document describes the issues surrounding the timing of events in the rolling of a key in a DNSSEC-secured zone.  It presents timelines for the key rollover and explicitly identifies the relationships between the various parameters affecting the process.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-dnsop-dnssec-key-timing-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-key-timing-00.txt' />
</reference>
<?rfc linefile="275:draft-ietf-dnsop-rfc4641bis.xml"?>
      <?rfc?><?rfc linefile="1:bibxml/reference.I-D.draft-ietf-dnsop-dnssec-dps-framework-01.xml"?>

<reference anchor='I-D.ietf-dnsop-dnssec-dps-framework'>
<front>
<title>DNSSEC Signing Policy &amp; Practice Statement Framework</title>

<author initials='F' surname='Ljunggren' fullname='Fredrik Ljunggren'>
    <organization />
</author>

<author initials='A' surname='Eklund-Lowinder' fullname='Anne-Marie Eklund-Lowinder'>
    <organization />
</author>

<author initials='T' surname='Okubo' fullname='Tomofumi Okubo'>
    <organization />
</author>

<date month='March' day='23' year='2010' />

<abstract><t>This document presents a framework to assist writers of DNSSEC Signing Policy and Practice Statements such as Regulatory Authorities and Registry Managers on both the TLD and secondary level, who is operating a DNS zone with Security Extensions (DNSSEC) implemented.  In particular, the framework provides a comprehensive list of topics that potentially (at the writer's discretion) needs to be covered in a DNSSEC Signing Policy definition and Practice Statement.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-dnsop-dnssec-dps-framework-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-dnsop-dnssec-dps-framework-01.txt' />
</reference>
<?rfc linefile="276:draft-ietf-dnsop-rfc4641bis.xml"?>      
      
    </references>
    
    <section title="Terminology" anchor="terminology">
      
      <t> 
	In this document, there is some jargon used that is defined in
	other documents. In most cases, we have not copied the text
	from the documents defining the terms but have given a more
	elaborate explanation of the meaning. Note that these
	explanations should not be seen as authoritative.
      </t>
      
      <t>
	<list style="hanging">
	  
	  <t hangText="Anchored key:">
	    A DNSKEY configured in resolvers around the globe. This key
	    is hard to update, hence the term anchored.
	  </t>
	  
	  
	  <t hangText="Bogus:">
	    Also see <xref target="RFC4033">Section
	    5 of RFC4033</xref>.  An RRSet in DNSSEC is marked "Bogus" when a
	    signature of an RRSet does not validate against a DNSKEY.
	  </t>
	  
	 	  
	  <t hangText="Key Signing Key or KSK:">
	    A Key Signing Key (KSK) is a key that is used exclusively for
	    signing the apex key set.  The fact that a key is a KSK is
	    only relevant to the signing tool.
	  </t>
	  
	  <t hangText="Key size:">
	    The term 'key size' can be substituted by 'modulus size'
	    throughout the document. It is mathematically more correct to
	    use modulus size, but as this is a document directed at
	    operators we feel more at ease with the term key size.
	  </t>
	  
	  <t hangText="Private and public keys:">
	    DNSSEC secures the DNS through the use of public key
	    cryptography. Public key cryptography is based on the
	    existence of two (mathematically related) keys, a public
	    key and a private key. The public keys are published in
	    the DNS by use of the DNSKEY Resource Record (DNSKEY
	    RR). Private keys should remain private.
	  </t>
	  
	  <t hangText="Key rollover:">
	    A key rollover (also called key supercession in some
	    environments) is the act of replacing one key pair with
	    another at the end of a key effectivity period.
	  </t>
	  <!--
	      <t hangText="Key Suppercession"> The term used when
	      rolling over a key while enjoying a meal.  </t>
	  -->
	  <t hangText="Refresh Period:">
	    The time at the end of the Signature Validity
	    Period during which signatures are refreshed.
	  </t>
	  
	  
	  <t hangText="Resinging frequency:"> 
	    Frequency with wich a signing pass on the zone is
	    performed. Alternatively expressed as "Resigning
	    Period". It defines when the zone is exposed to the
	    signer. During a signing pass not all signatures in the
	    zone may be refreshed, that depend refresh
	    frequency/intervall.
	  </t>
	  
	  <t hangText="Secure Entry Point (SEP) key:">
	    A KSK that has a parental DS record pointing to it or is
	    configured as a trust anchor. Although not required by the
	    protocol, we recommend that the SEP flag <xref
	    target="RFC4035"/> is set on these keys.
	  </t>
	  <t hangText="Self-signature:">
            This only applies to signatures over DNSKEYs; a signature
            made with DNSKEY x, over DNSKEY x is called a
            self-signature.  Note: without further information,
            self-signatures convey no trust. They are useful to check
            the authenticity of the DNSKEY, i.e., they can be used as
            a hash.
	  </t>
	  <t hangText="Signing Jitter:">
	    Jitter applied to the signature validty intervall.
	  </t>	  

	  <t hangText="Signer:">
	    The system that has access to the private key material and
	    signs the Resource Record sets in a zone. A signer may be
	    configured to sign only parts of the zone, e.g., only
	    those RRSets for which existing signatures are about to
	    expire.
	  </t>


	  <t hangText="Single Type Signing Scheme:">
	    A signing scheme whereby the distinction between Zone Signing Keys
	    and Key Singing Keys is not made.
	  </t>
	  


	  <t hangText="Zone Signing Key (ZSK):">
	    A key that is used for signing all data in a zone
	    (except, perhaps, the DNSKEY RRSet).  The fact that a
	    key is a ZSK is only relevant to the signing tool.
	  </t>

	  <t hangText="Singing the zone file:">
	    The term used for the event where an administrator joyfully
	    signs its zone file while producing melodic sound patterns.
	  </t>


	  <t hangText="Zone administrator:">
	    The 'role' that is responsible for signing a zone and
	    publishing it on the primary authoritative server.
	  </t>
	</list>
	
      </t>
    </section>
    
    
    
    
    <section anchor="zskhowto" title="Zone Signing Key Rollover How-To">
      
      <t> 
	Using the pre-published signature scheme and the most
	conservative method to assure oneself that data does not live
	in caches, here follows the "how-to".
      </t>
      <list style="hanging">
	
	<t hangText="Step 0:">
	  The preparation: Create two keys and publish both in your
	  key set.  Mark one of the keys "active" and the other
	  "published". Use the "active" key for signing your zone
	  data. Store the private part of the "published" key,
	  preferably off-line.  The protocol does not provide for
	  attributes to mark a key as active or published. This is
	  something you have to do on your own, through the use of a
	  notebook or key management tool.
	</t>
	<t hangText="Step 1:">
	  Determine expiration: At the beginning of the rollover make
	  a note of the highest expiration time of signatures in your
	  zone file created with the current key marked as active.
	  Wait until the expiration time marked in Step 1 has passed.
	</t>
	<t hangText="Step 2:">
	  Then start using the key that was marked "published" to sign
	  your data (i.e., mark it "active"). Stop using the key that
	  was marked "active"; mark it "rolled".
	</t>
	<t hangText="Step 3:">
	  It is safe to engage in a new rollover (Step 1) after at
	  least one signature validity period.
	</t>
      </list>
    </section><!--"Zone Signing key operational checklist-->
    <section anchor="typography" title="Typographic Conventions">
      <t>
	The following typographic conventions are used in this document:
	
	<list style="hanging">
	  <t hangText="Key notation:">
	    A key is denoted by DNSKEYx, where x is a number or an
	    identifier, x could be thought of as the key id.
	  </t>
	  <t hangText="RRSet notations:">
	    RRs are only denoted by the type. All other information
	    -- owner, class, rdata, and TTL -- is left out. Thus:
	    "example.com 3600 IN A 192.0.2.1" is reduced to
	    "A". RRSets are a list of RRs. A example of this would
	    be "A1, A2", specifying the RRSet containing two "A"
	    records. This could again be abbreviated to just "A".
	  </t>
	  <t hangText="Signature notation:">
	    Signatures are denoted as RRSIGx(RRSet), which means
	    that RRSet is signed with DNSKEYx.
	  </t>
	  
	  <t hangText="Zone representation:">
	    Using the above notation we have simplified the
	    representation of a signed zone by leaving out all
	    unnecessary details such as the names and by
	    representing all data by "SOAx"
	  </t>
	  
	  <t hangText="SOA representation:">
	    SOAs are represented as SOAx, where x is the serial
	    number.
	  </t>
	</list>
	
	Using this notation the following signed zone:
	
	<figure>
	  <artwork>
example.net.      86400  IN SOA  ns.example.net. bert.example.net. (
                         2006022100   ; serial
                         86400        ; refresh (  24 hours)
                         7200         ; retry   (   2 hours)
                         3600000      ; expire  (1000 hours)
                         28800 )      ; minimum (   8 hours)
                  86400  RRSIG   SOA 5 2 86400 20130522213204 (
                               20130422213204 14 example.net.
                               cmL62SI6iAX46xGNQAdQ... )
                  86400  NS      a.example.net.
                  86400  NS      b.example.net.
                  86400  RRSIG   NS 5 2 86400 20130507213204 (
                               20130407213204 14 example.net.
                               SO5epiJei19AjXoUpFnQ ... )
                  86400  DNSKEY  256 3 5 (
                               EtRB9MP5/AvOuVO0I8XDxy0... ) ; id = 14
                  86400  DNSKEY  257 3 5 (
                               gsPW/Yy19GzYIY+Gnr8HABU... ) ; id = 15
                  86400  RRSIG   DNSKEY 5 2 86400 20130522213204 (
                               20130422213204 14 example.net.
                               J4zCe8QX4tXVGjV4e1r9... )
                  86400  RRSIG   DNSKEY 5 2 86400 20130522213204 (
                               20130422213204 15 example.net.
                               keVDCOpsSeDReyV6O... )
                  86400  RRSIG   NSEC 5 2 86400 20130507213204 (
                               20130407213204 14 example.net.
                               obj3HEp1GjnmhRjX... )
a.example.net.    86400  IN TXT  "A label"
                  86400  RRSIG   TXT 5 3 86400 20130507213204 (
                               20130407213204 14 example.net.
                               IkDMlRdYLmXH7QJnuF3v... )
                  86400  NSEC    b.example.com. TXT RRSIG NSEC
                  86400  RRSIG   NSEC 5 3 86400 20130507213204 (
                               20130407213204 14 example.net.
                               bZMjoZ3bHjnEz0nIsPMM... )
                  ...
	  </artwork>
	</figure>
	
	is reduced to the following representation:

	<figure>
	  <artwork>
    SOA2006022100
    RRSIG14(SOA2006022100)
    DNSKEY14
    DNSKEY15

    RRSIG14(KEY)
    RRSIG15(KEY)
	  </artwork>
	</figure>
	
	The rest of the zone data has the same signature as the SOA
	record, i.e., an RRSIG created with DNSKEY 14.
	
      </t>
      
    </section>
    
    <section anchor="DED" title="Document Editing History">
      <t>
      [To be removed prior to publication as an RFC]
      </t>
      <section title="draft-ietf-dnsop-rfc4641-00">
	<t>
	  Version 0 was differs from RFC4641 in the following ways.
	  <list style="symbols">
	    <t>
	      Status of this memo appropriate for I-D
	    </t>
	    <t>
	      TOC formatting differs.
	    </t>
	    <t>
	      Whitespaces, linebreaks, and pagebreaks may be slightly different
	      because of xml2rfc generation.
	    </t>
	    <t>
	      References slightly reordered.
	    </t>
	    <t>
	      Applied the errata from
	      http://www.rfc-editor.org/errata_search.php?rfc=4641
	    </t>
	    <t>
	      Inserted trivial "IANA considertations" section.
	    </t>
	  </list>

	  In other words it should not contain substantive changes in
	  content as intended by the workinggroup for the original RFC4641.
	  </t>
	</section>
	<section title="version 0->1">
	  <t>Cryptography details rewritten.
	  (See http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/cryptography_flawed)
	  </t>
	  <t>
	    <list style="symbols">
	      <t>Reference to NIST 800-90 added</t>
	      <t>RSA/SHA256 is being recommended in addition to RSA/SHA1.</t>
	      <t> Complete rewrite of <xref target="key sizes"/>
	      removing the table and suggesting a keysize of 1024 for
	      keys in use for less than 8 years, issued up to at least
	      2015.  </t>
	      <t>Replaced the reference to Schneiers' applied cryptograpy with a reference to RFC4949.
	      </t>
	      <t> Removed the KSK for high level zones consideration</t>
	    </list>
	  </t>
	  <t>
	    Applied some differentiation with respect of the use of a
	    KSK for parent or trust-anchor relation
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/differentiation_trustanchor_parent
	  </t>
	  <t>
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/rollover_assumptions
	  </t>
	  <t>
	    Added <xref target="KAR"/> as suggested by Jelte Jansen
	    in
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/Key_algorithm_roll
	  </t> 
	  
	  <t>
	    Added <xref target="non_cooperating_registrars"/> Issue
	    identified by Antoin Verschuur
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/non-cooperative-registrars
	  </t>
	  <t>
	  In <xref target="terminology"/>: ZSK does not nescessarily sign the DNSKEY RRset.
	  </t>
	</section>
	
	<section title="version 1->2">
	  <list style="symbols">
	    <t>
	      Significant rewrite of <xref target="keys"/> whereby the
	      argument is made that the timescakes for rollovers are
	      made purely on operational arguments hopefully resolving
	      http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/discussion_of_timescales
	    </t>
	    <t>
	      Added <xref target="nsec_nsec3"/> based on
	    http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/NSEC-NSEC3
	    </t>
	    <t>
	      Added a reference to <xref
	      target="I-D.ietf-dnsop-dnssec-key-timing">draft-morris-dnsop-dnssec-key-timing</xref>
	      for the quantitative analysis on keyrolls 
	    </t>
	    <t> 
	      Updated <xref target="changing-operators"/> to reflect
	      that the problem occurs when changing DNS operators, and
	      not DNS registrars, also added the table indicating the
	      redelegation procedure. Added text about the fact that
	      implementations will dismiss keys that fail to validate
	      at some point.
	    </t>
	    <t> 
	      Updated a number of references.
	    </t>
	    
	  </list>
	</section>
	<section title="version 2->3">
	  <list style="symbols">
	    
	    <t>
	      Added bulleted list to serve as an introduction on the
	      decision tree in <xref target="keys"/>.
	    </t>
	   
	    <t>
	      In section <xref target="zsk-ksk-motivation"/>:
	    <list style="symbols">
	      <t>
		tried to motivate that keylength is not a strong
		motivation for KSK ZSK split (based on
		http://www.educatedguesswork.org/2009/10/on_the_security_of_zsk_rollove.html)
	      </t>
	      <t>
		Introduced Common Signing Key terminology and made the
		arguments for the choice of a Common Signing Key more
		explicit.
	      </t>
	      <t>
		Moved the SEP flag considerations to its own paragraph
	      </t>
	    </list>
	    </t>
	    
	    <t>
	      In a few places in the document, but section <xref
	      target="sigs_keyrolls_policies"/> in particular the
	      comments from Patrik Faltstrom (On Mar 24, 2010) on the
	      clarity on the roles of the registrant, dns operator,
	      registrar and registry was addressed.
	    </t>
	    <t>
	      Added some terms based on
	      http://www.nlnetlabs.nl/svn/rfc4641bis/trunk/open-issues/timing_terminology
	    </t>
	    <t>
	      Added paragrap 2 and clarified the second but last
	      paragraph of <xref target="rolling-ksk-ta"/>.
	    </t>
	    <t>
	      Clarified the table and some text in <xref
	      target="KAR"/>. Also added some text on what happens
	      when the algorithm rollover also involves a roll from
	      NSEC to NSEC3.
	    </t>
	    <t>
	      Added a paragraph about rolling KSKs that are also
	      configured as trust-anchors in <xref target="ksk-rollover"/>
	    </t>
	    <t>
	      Added <xref target="STSrollover"/>.
	    </t>

	    <t>
	      Added <xref target="sigval"/> to address issue "Signature_validity"
	    </t>

	  </list>
	</section>
	
	<t>$Id: draft-ietf-dnsop-rfc4641bis-03.xml 60 2010-07-12 19:33:51Z olaf $</t>
      </section>
      
    </back>
    
  </rfc>
  