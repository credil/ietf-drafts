


Internet Engineering Task Force                                  A. Ford
Internet-Draft                                       Roke Manor Research
Intended status: Experimental                                  C. Raiciu
Expires: January 11, 2010                                     M. Handley
                                               University College London
                                                                S. Barre
                                                Universite catholique de
                                                                 Louvain
                                                           July 10, 2009


     TCP Extensions for Multipath Operation with Multiple Addresses
                   draft-ford-mptcp-multiaddressed-01

Status of this Memo

   This Internet-Draft is submitted to IETF in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on January 11, 2010.

Copyright Notice

   Copyright (c) 2009 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents in effect on the date of
   publication of this document (http://trustee.ietf.org/license-info).
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.




Ford, et al.            Expires January 11, 2010                [Page 1]

Internet-Draft                Multipath TCP                    July 2009


Abstract

   Often endpoints are connected by multiple paths, but the nature of
   TCP/IP restricts communications to a single path per socket.
   Resource usage within the network would be more efficient were these
   multiple paths able to be used concurrently.  This should enhance
   user experience through higher throughput and improved resilience to
   network failure.  This document presents extensions to TCP in order
   to transparently provide this multi-path functionality at the
   transport layer, if at least one endpoint is multi-addressed.









































Ford, et al.            Expires January 11, 2010                [Page 2]

Internet-Draft                Multipath TCP                    July 2009


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  Motivation . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.2.  Design Assumptions . . . . . . . . . . . . . . . . . . . .  4
     1.3.  Layered Representation . . . . . . . . . . . . . . . . . .  5
     1.4.  Operation Summary  . . . . . . . . . . . . . . . . . . . .  6
     1.5.  Open Issues  . . . . . . . . . . . . . . . . . . . . . . .  7
     1.6.  Requirements Language  . . . . . . . . . . . . . . . . . .  8
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  8
   3.  Semantic Issues  . . . . . . . . . . . . . . . . . . . . . . .  8
   4.  MPTCP Protocol . . . . . . . . . . . . . . . . . . . . . . . .  9
     4.1.  Session Initiation . . . . . . . . . . . . . . . . . . . .  9
     4.2.  Starting a New Subflow . . . . . . . . . . . . . . . . . . 11
     4.3.  Address Knowledge Exchange (Path Management) . . . . . . . 12
       4.3.1.  Adding Addresses . . . . . . . . . . . . . . . . . . . 13
       4.3.2.  Remove Address . . . . . . . . . . . . . . . . . . . . 14
     4.4.  General MPTCP Operation  . . . . . . . . . . . . . . . . . 15
       4.4.1.  Receive Window Considerations  . . . . . . . . . . . . 16
       4.4.2.  Congestion Control Considerations  . . . . . . . . . . 17
       4.4.3.  Subflow Policy . . . . . . . . . . . . . . . . . . . . 17
       4.4.4.  Retransmissions  . . . . . . . . . . . . . . . . . . . 18
     4.5.  Closing a Connection . . . . . . . . . . . . . . . . . . . 19
     4.6.  Error Handling . . . . . . . . . . . . . . . . . . . . . . 20
   5.  Congestion Control Coupling for MPTCP  . . . . . . . . . . . . 20
   6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 21
   7.  Interactions with Middleboxes  . . . . . . . . . . . . . . . . 22
   8.  Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . 22
   9.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 23
   10. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 23
   11. References . . . . . . . . . . . . . . . . . . . . . . . . . . 23
     11.1. Normative References . . . . . . . . . . . . . . . . . . . 23
     11.2. Informative References . . . . . . . . . . . . . . . . . . 24
   Appendix A.  Functional Separation . . . . . . . . . . . . . . . . 24
     A.1.  Motivations  . . . . . . . . . . . . . . . . . . . . . . . 24
     A.2.  TCP Performance  . . . . . . . . . . . . . . . . . . . . . 25
     A.3.  Architecture overview  . . . . . . . . . . . . . . . . . . 25
     A.4.  PM/MPS interface . . . . . . . . . . . . . . . . . . . . . 27
   Appendix B.  Notes on use of TCP Options . . . . . . . . . . . . . 28
   Appendix C.  Resync Packet . . . . . . . . . . . . . . . . . . . . 28
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 30










Ford, et al.            Expires January 11, 2010                [Page 3]

Internet-Draft                Multipath TCP                    July 2009


1.  Introduction

   Multipath TCP is set of extensions for regular TCP [RFC0793] to allow
   one TCP connection to be spread across multiple paths.  This section
   describes the motivation behind the design of Multipath TCP
   (henceforth referred to as MPTCP), and gives a summary of its
   operation.  The following sections describe in greater detail the
   proposed extensions and the operation of the resulting protocol.

1.1.  Motivation

   As the Internet evolves, demands on Internet resources are ever-
   increasing, but often these resources (in particular, bandwidth)
   cannot be fully utilised due to protocol constrains on both the end-
   systems and within the network.  By the application of resource
   pooling [WISCHIK], these resources can be 'pooled' such that they
   appear as a single logical resource to the user.  Multipath TCP
   achieves resource pooling by combining multiple TCP sessions running
   over multiple paths, and presenting them as a single TCP connection
   to the application.

   This form of resource pooling bring two key benefits:

   o  To increase the resilience of the connectivity by providing
      multiple paths, protecting end hosts from the failure of one.

   o  To increase the efficiency of the resource usage, and thus
      increase the network capacity available to end hosts.

   The protocol presented in this document follows the same service
   model as TCP [RFC0793]: byte oriented, in order reliable delivery.
   To have a deployable protocol, we impose the following "do no harm"
   philosophy: multipath TCP should behave no worse (throughput wise)
   than running a single TCP connection over any of its paths, and using
   multiple paths should not harm users using single path TCP at shared
   bottlenecks.

1.2.  Design Assumptions

   In order to limit the potentially huge design space, the authors
   imposed two key constraints on the multipath TCP design presented in
   this document:

   o  It must be backwards-compatible with current, regular TCP, to
      increase its chances of deployment

   o  It can be assumed that one or both endpoints are multihomed and
      multiaddressed



Ford, et al.            Expires January 11, 2010                [Page 4]

Internet-Draft                Multipath TCP                    July 2009


   To simplify the design we assume that the presence of multiple
   addresses at an endpoint is sufficient to indicate the existence of
   multiple paths.  These paths need not be entirely disjoint: they may
   share one or many routers between them.  Even in such a situation
   making use of multiple paths is beneficial, improving resource
   utilisation and resilience to a subset of node failures.

   There are three aspects to the backwards-compatibility listed above:

   External Constraints:  The protocol must function through the vast
      majority of existing middleboxes such as NATs, firewalls and
      proxies, and as such must resemble existing TCP as far as possible
      on the wire.  Furthermore, the protocol must not assume the
      segments it sends on the wire arrive unmodified at the
      destination: they may be split or coalesced; options may be
      removed or duplicated.

   Application Constraints:  The protocol must be usable with no change
      to existing applications that use the standard TCP API (although
      it is reasonable that not all features would be available to such
      legacy applications).

   Fall-back:  The protocol should be able to fall back to standard TCP
      with no interference from the user, to be able to communicate with
      legacy hosts.

   Areas for further study:

   o  In theory, since this is purely a TCP extension, it should be
      possible to use MPTCP with both IPv4 and IPv6 on dual-stack hosts,
      thus having the additional possible benefit of aiding transition.

   o  Some features of the design presented here could be extended to
      work with non-multi-addressed hosts by using packet marking or
      partial multipath.

   o  Some features of the design presented here could be combined with
      mechanisms such as shim6 [I-D.ietf-shim6-proto].

   This draft also suggests a safe way to couple congestion controllers
   in a way that achieves the "do no harm philosophy".  This is for
   completeness or our arguments: we expect this description to evolve
   into a companion new internet draft.

1.3.  Layered Representation

   MPTCP operates at the transport layer, and its existence aims to be
   transparent to both higher and lower layers.  It is a set of



Ford, et al.            Expires January 11, 2010                [Page 5]

Internet-Draft                Multipath TCP                    July 2009


   additional features on top of standard TCP, and as such MPTCP is
   designed to be usable by legacy applications with no changes.  A
   possible implementation would be for such a feature to be a system-
   wide setting: "Use multipath TCP by default?  Y/N".  Multipath-aware
   applications would be able to use an extended sockets API to have
   further influence on the behaviour of MPTCP.  Figure 1 illustrates
   this architecture.

                                      +-------------------------------+
                                      |           Application         |
      +---------------+               +-------------------------------+
      |  Application  |               |             MPTCP             |
      +---------------+               + - - - - - - - + - - - - - - - +
      |      TCP      |               | Subflow (TCP) | Subflow (TCP) |
      +---------------+               +-------------------------------+
      |      IP       |               |       IP      |      IP       |
      +---------------+               +-------------------------------+

      Figure 1: Comparison of Standard TCP and MPTCP Protocol Stacks

   Detailed discussion of an architecture for developing a multipath TCP
   implementation, especially regarding the functional separation by
   which different components should be developed, is given in
   Appendix A.

1.4.  Operation Summary

   This section provides a high-level summary of normal operation in
   MPTCP, and is illustrated by the scenario shown in Figure 2.  A
   detailed description of operation is given in Section 4.

   o  To a non-MPTCP-aware application, MPTCP will be indistinguishable
      from normal TCP.  All MPTCP operation is handled by the MPTCP
      implementation, although extended APIs could provide additional
      control.  An application begins by opening a TCP socket in the
      normal way.

   o  An MPTCP connection begins as a single TCP session.  This is
      illustrated in Figure 2 as being between Addresses A1 and B1 on
      Hosts A and B respectively.

   o  If extra paths are available, additional TCP sessions are created
      on these paths, and are combined with the existing session, which
      continues to appear as a single connection to the applications at
      both ends.  The creation of the additional TCP session is
      illustrated between Address A2 on Host A and Address B1 on Host B.





Ford, et al.            Expires January 11, 2010                [Page 6]

Internet-Draft                Multipath TCP                    July 2009


   o  MPTCP identifies multiple paths by the presence of multiple
      addresses at endpoints.  Combinations of these multiple addresses
      equate to the additional paths.  In the example, other potential
      paths that could be set up are A1<->B2 and A2<->B2.  Although this
      additional session is shown as being initiated from A2, it could
      equally have been initiated from B1.

   o  The discovery and setup of additional TCP sessions (termed
      'subflows') will be achieved through a path management method.
      This document describes a mechanism by which an endpoint can
      initiate new subflows by using its additional addresses, or by
      signalling to the other endpoint its available addresses.

   o  The exact properties of these TCP sessions that are logically
      bonded are dependent upon the congestion and flow control
      characteristics of the endpoints' MPTCP implementation.

   o  MPTCP adds connection-level sequence numbers in order to
      reassemble the data stream in-order from multiple subflows.
      Connections are terminated by connection-level FIN packets as well
      as those relating to the individual subflows.


               Host A                               Host B
      ------------------------             ------------------------
      Address A1    Address A2             Address B1    Address B2
      ----------    ----------             ----------    ----------
          |             |                      |             |
          |     (initial connection setup)     |             |
          |----------------------------------->|             |
          |<-----------------------------------|             |
          |             |                      |             |
          |            (additional subflow setup)            |
          |             |--------------------->|             |
          |             |<---------------------|             |
          |             |                      |             |
          |             |                      |             |

                  Figure 2: Example MPTCP Usage Scenario

1.5.  Open Issues

   This specification is a work-in-progress, and as such there are many
   issues that are still to be resolved.  This section lists many of the
   key open issues within this specification; these are discussed in
   more detail in the appropriate sections throughout this document.





Ford, et al.            Expires January 11, 2010                [Page 7]

Internet-Draft                Multipath TCP                    July 2009


   o  Best handshake mechanisms.  This document contains a proposed
      scheme by which connections and subflows can be set up.  It is
      felt that, although this is "no worse than regular TCP", there
      could be opportunities for significant improvements in security
      that could be included (potentially optionally) within this
      protocol.

   o  Issues around simulataneous opens, where both ends attempt to
      create a new subflow simultaneously, need to be investigated and
      behaviour specified.

   o  Appropriate mechanisms for controlling policy of subflow usage.
      The ECN signal is currently proposed but other alternatives,
      including path property options, could be employed instead.

1.6.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].


2.  Terminology

   Path:  A sequence of links between a sender and a receiver, defined
      in this context by a source and destination address pair.

   Subflow:  A stream of TCP packets sent over a path.  A subflow is a
      component part of a connection between two endpoints.

   Connection:  A collection of one or more subflows, over which an
      application can communicate between two endpoints.  There is a
      one-to-one mapping between a connection and a socket.

   Token:  A unique identifier given to a multipath connection by an
      endpoint.  May also be referred to as a "Connection ID".

   Endpoint:  A host operating an MPTCP implementation, and either
      initiating or terminating a MPTCP connection.


3.  Semantic Issues

   In order to support multipath operation, the semantics of some TCP
   components have changed.  To aid clarity, this section collects these
   semantic changes as a reference.





Ford, et al.            Expires January 11, 2010                [Page 8]

Internet-Draft                Multipath TCP                    July 2009


   Sequence Number:  The TCP sequence number is subflow-specific, with a
      data sequence number used for reassembly at connection-level.

   FIN:  The FIN only applies to a subflow, not to a connection.  For a
      connection-level FIN, use the DATA FIN option.

   ACK:  The ACK acknowledges the subflow sequence number only, and the
      mapping to the data sequence number is handled out-of-band.

   RST:  The RST only applies to a subflow.  There is no connection-
      level RST, since it would be impossible to distinguish the two, as
      the link between a subflow and a connection is established at the
      SYN handshake.  A connection is considered reset if every subflow
      sends a RST in response.

   Length:  There is additionally an explicit length for each MPTCP
      segment in order to separate potential TCP/IP-layer segmentation
      from the MPTCP data flow.

   Address List:  The address management is handled per-connection to
      permit the application of per-connection local policy.

   5-tuple:  The 5-tuple (protocol,local IP, local port, remote IP,
      remote port) presented to the application layer in a non-
      multipath-aware application is that of the first subflow, even if
      the subflow has since been closed and removed from the connection.


4.  MPTCP Protocol

   This section describes the operation of the MPTCP protocol, and is
   subdivided into sections for each key part of the protocol operation.

   All MPTCP operations are signalled using optional TCP header fields.
   These TCP Options will have option numbers allocated by IANA, as
   discussed in Section 10, and are defined throughout the following
   subsections.

4.1.  Session Initiation

   Session Initiation begins with a SYN, SYN/ACK exchange on a single
   path.  Each of these packets will additionally feature the Multipath
   Capable TCP option (Figure 3, which declares the sender's locally
   unique 32-bit token for this connection, and a version field.

   The "Multipath Capable" option declares an endpoint to be capable of
   operating Multipath TCP (or rather, more accurately, a desire to
   operate Multipath TCP on this particular connection).  As well as



Ford, et al.            Expires January 11, 2010                [Page 9]

Internet-Draft                Multipath TCP                    July 2009


   this declaration, this field presents a token, which is used when
   adding additional subflows to this connection.

   This token is generated by the sender and has local meaning only, but
   therefore it MUST be unique for the sender.  The token MUST be
   difficult for an attacker to guess, and thus it is recommended it
   SHOULD be generated randomly.  (However, see further discussions
   about security in Section 6, including the possibility of a 64-bit
   token and an initial data sequence number.)

   This option is only present in packets with the SYN flag set.  It is
   only used in the first TCP session of a connection, in order to
   identify the connection; all following connections will use path
   management techniques to join the existing connection.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+-------------------------------+
      | Kind=OPT_MPC  |  Length = 7   |(resvd)|Version|  Sender Token :
      +---------------+---------------+-------------------------------+
      : Sender Token (continued - 4 octets total)     |
      +-----------------------------------------------+

                    Figure 3: Multipath Capable option

   The version field represents the version of MPTCP in use.  The
   version provided in this specification is 0.  The reserved bits may
   be used for connection-specific flags in later versions.

   If a SYN contains a "multipath capable" option but the SYN/ACK does
   not, it is assumed that the recipient is not multipath capable and
   thus the MPTCP session will operate as regular, single-path TCP.  If
   a SYN does not contain a "multipath capable" option, the SYN/ACK MUST
   NOT contain one in response.

   If these packets are unacknowledged, it is up to local policy to
   decide how to respond.  It is expected that a sender will eventually
   fall back to single-path TCP (i.e. without the Multipath Capable
   Option), in order to work around middleboxes that may drop packets
   with unknown options, however the number of multipath-capable
   attempts that are made first will be up to local policy.  In the case
   of out-of-order packets, i.e. if a multipath-capable SYN/ACK is
   received in response to a multipath-capable SYN, after a standard SYN
   has been sent, then once again it is up to the sender to choose how
   to behave.  For example, the sender could respond to new connections
   using the previously declared token, or it could simply drop any new
   multipath options within the flow.




Ford, et al.            Expires January 11, 2010               [Page 10]

Internet-Draft                Multipath TCP                    July 2009


   If an endpoint is known to be multiaddressed (e.g. through multiple
   addresses returned in a DNS lookup), alternative destination
   addresses should be tried first, before falling back to regular TCP.

   In addition to this option, a Data Sequence Number option (discussed
   in Section 4.4) is included to provide an initial data-level sequence
   number (and this initial SYN counts as one octet in this space, as
   for a regular SYN in single-path TCP).

4.2.  Starting a New Subflow

   Endpoints have knowledge of their own address(es), and can become
   aware of the other endpoint's addresses through a path management
   technique as described in Section 4.3.  Using this knowledge, an
   endpoint will initiate a new subflow over a currently unused pair of
   addresses.

   A new subflow is started as a normal TCP SYN/ACK exchange.  The
   following TCP option is used to identify which connection the new
   subflow should become a part.  The token used is the locally unique
   token of the destination for the subflow, as defined by the Multipath
   Capable option received in the first SYN/ACK exchange.

   It should be noted that, in theory, additional subflows can exist
   between any pair of ports, and as such it is this token that is used
   for demuxing at the receiver.  A receiver must store some mapping
   state, of (source_addr, dest_addr, source_port, dest_port) to its
   token, using information from the initial SYN exchange, in order to
   enable this.  In practice, however, it is envisaged that most new
   subflows will connect to a port that is already in use as the source
   or destination port of an existing subflow, in order to have a
   greater chance of getting through firewalls and other middleboxes,
   and to support traffic engineering of the flows.

   This option includes an "Address ID".  This is an identifier, locally
   unique to the sender of this option, that identifies the source
   address of this packet.  This serves two purposes.  Firstly, if an
   address becomes unexpectedly unavailable on the sender, it can signal
   this to the receiver via a remove address option (Section 4.3.2)
   without needing to know what the source address actually is (thus
   allowing the use of NATs).  Secondly, it allows correlation between
   new connection attempts and address signalling (Section 4.3.1), to
   prevent duplicate subflow initiation.

   This option can only be present when the SYN flag is set.






Ford, et al.            Expires January 11, 2010               [Page 11]

Internet-Draft                Multipath TCP                    July 2009


                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+-------------------------------+
      | Kind=OPT_JOIN |  Length = 6   |Receiver Token (4 octets total):
      +---------------+---------------+----------------+--------------+
      :  Receiver Token (continued)   |   Address ID   |
      +-------------------------------+----------------+

                     Figure 4: Join Connection option

4.3.  Address Knowledge Exchange (Path Management)

   We use the term "path management" to refer to the exchange of
   information about additional paths between endpoints, which in this
   design is managed by multiple addresses at endpoints.  For more
   detail of the architectrual thinking behind this design, see the
   discussion of functional separation in Appendix A.

   This design makes use of two methods of sharing such information,
   used simultaneously.  The first is the direct setup of new subflows,
   already described in Section 4.2.  The second is described in the
   following subsections, whereby addresses are signalled explicitly to
   the endpoint to allow it to initiate new connections.  This approach
   has been chosen so as to allow addresses to change in flight, and
   thus the use of NATs, whilst also allowing the signalling of
   previously unknown addresses, such as those belonging to other
   address families.

   In more detail, an example of the typical operation is as follows,
   where an existing address is used at one endpoint:

   o  An endpoint that is multihomed starts an additional TCP session to
      an address/port pair that is already in use on the other endpoint,
      using a token to identify the flow (Section 4.2).  (A multihomed
      destination may open a new subflow from its new address to the
      source address and port, or a multihomed source may open a new
      subflow from its new address another connection to the existing
      destination and port).

   o  To expand upon this, say a connection is intiated from host "A" on
      (address, port) combination A1 to desintation (address, port) B1
      on host "B".  If host A is multihomed, it starts an additional
      connection from new (address, port) A2 to B1, using B's previously
      declared token.  Alternatively, if B is multhomed, it will try to
      set up a new TCP connection from B2 to A1, using A's previously
      declared token.





Ford, et al.            Expires January 11, 2010               [Page 12]

Internet-Draft                Multipath TCP                    July 2009


   o  Simultaneously (or near-simultaneously), an "Add Address" option
      (Section 4.3.1) is sent on an existing subflow, informing the 
      receiver of the sender's alternative address(es).  The recipient 
      can use this information to open a new subflow to the sender's 
      additional address.  Using the previous notation, this would be a
      Add Address packet sent from A1 to B1, informing B of address A2.

   o  If host B successfully receives the first SYN, starting a new
      subflow, it can use the Address ID to correlate this with the Add
      Address option that will also arrive on an existing subflow, and
      it will respond to the SYN with a SYN/ACK.  Otherwise, if it does
      not receive such a SYN, it tries to initiate a new subflow from
      one or more of its addresses to address A2.  This is intended to
      permit new sessions to be opened if one endpoint is behind a NAT.

   Other scenarios are valid, however, such as those where entirely new
   addresses are signalled, e.g. to allow an IPv6 and an IPv4 path to be
   used simultaneously.

4.3.1.  Adding Addresses

   Announcing additional addresses that an endpoint can be reached on
   will be undertaken by the Add Address TCP Option (Figure 5), where an
   (ID, address) pair can be announced to the other endpoint.  Several
   addresses can be added if there is sufficient TCP option space,
   otherwise multiple TCP messages containing this option must be sent.
   This option can be used at any time during a connection.

   The Add Address option announces a list of alternative IP addresses,
   beyond the current one in use, that the sender can be contacted on.
   This option can be used multiple times until all available addresses
   have been announced, in order to get around TCP option space limits.
   It should be noted that every address has an ID which can be used for
   address removal, and therefore endpoints must cache the mapping
   between ID and address.  This is also used to identify Join
   Connection options (Section 4.2) relating to the same address, even
   when address translators are in use.  The ID must be unique to the
   sender, and although it may be a sequential counter, this is not
   mandated.

   This option is shown for IPv4.  For IPv6, the IPVer field will read
   6, and the length of the address will be 16 octets not 4, and thus
   the length of the option will be 2 + (18 * number_of_entries).
   Multiple addresses can be included, with an ID following on
   immediately from the previous address, and their existance can be
   inferred through the option length and version fields.

   NB: by having a IPVer field, we get four free reserved bits.  These



Ford, et al.            Expires January 11, 2010               [Page 13]

Internet-Draft                Multipath TCP                    July 2009


   could be used in later versions of this protocol, e.g. one bit for
   "use now" or similar, to differentiate between subflows for backup
   purposes and those for throughput.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+---------------+-------+-------+
      | Kind=OPT_ADDR |     Length    |  Address ID   | IPVer |(resvd)|
      +---------------+---------------+---------------+-------+-------+
      |                   Address (IPv4 - 4 octets)                   |
      +---------------------------------------------------------------+
          ( ... further ID/Version/Address fields as required ... )

                  Figure 5: Add Address option (for IPv4)

4.3.2.  Remove Address

   If, during the lifetime of a MPTCP connection, a previously-announced
   address becomes invalid (e.g. if the interface disappears), the
   affected endpoint should announce this so that the other endpoint can
   remove subflows related to this address.

   This is achieved through the Remove Address option (Figure 6), which
   will remove a previously-added address (or list of addresses) from a
   connection and terminate any subflows currently using that address.

   The sending and receipt of this message should trigger the sending of
   FINs by both endpoints on the affected subflow(s) (if possible), as a
   courtesy to cleaning up middlebox state, but endpoints may clean up
   their internal state without a long timeout.

   If there is no address at the requested ID, the receiver will
   silently ignore the request.

   Address removal is undertaken by ID, so as to permit the use of NATs
   and other middleboxes, in the cases where new connections have been
   initiated but now want to be removed.

   The closure of a single subflow, rather than all using a particular
   address, is undertaken as normal with a FIN exchange on the subflow -
   for more information, see Section 4.5.










Ford, et al.            Expires January 11, 2010               [Page 14]

Internet-Draft                Multipath TCP                    July 2009


                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+---------------+
      |Kind=OPT_REMADR|  Length = 2+n |  Address ID   | ...
      +---------------+---------------+---------------+

                      Figure 6: Remove Address option

4.4.  General MPTCP Operation

   This section discusses operation of MPTCP for data transfer,
   independent of the path management mechanism used.

   At a high level, the an MPTCP implementation will take one input data
   stream from an application, and split it into one or more subflows.
   The data stream as a whole can be reassembled through the use of the
   Data Sequence Number (Figure 7) option, which defines the sequence in
   the data stream of the first octet of the packet's payload, and this
   is used by the receiver to ensure in-order delivery to th application
   layers.  Meanwhile, the subflow-level sequence numbers (i.e. the
   regular sequence numbers in the TCP header) have subflow-only
   relevance.

   The only acknowledgements are those at the subflow-level, so the
   sender must be able to map these acknowledgements to the data
   sequence numbers that were contained in the relevant packets.  The
   sender thus knows, if subflow data goes unackowledged, which part of
   the original data stream this equates to, and thus what data must be
   retransmitted.  It is expected (but not mandated) that SACK [RFC2018]
   is used as an efficiency at the subflow level.  Each subflow will
   maintain its own congestion widow.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+------------------------------+
      | Kind=OPT_DSN  |    Length     |      Data Sequence Number... :
      +---------------+---------------+------------------------------+
      : ... ( (length-4) octets )     | Data-level Length (2 octets) |
      +-------------------------------+------------------------------+

                   Figure 7: Data Sequence Number option

   In addition to the Data Sequence Number, this option also includes a
   Data-level Length field.  The purpose of this field is to assist with
   compatibility with situations where TCP/IP segmentation is undertaken
   separately from the stack that is generating the data flow (e.g.
   through the use of TCP segementation offloading on network interface
   cards, or by middleboxes).  This field declares what length of data



Ford, et al.            Expires January 11, 2010               [Page 15]

Internet-Draft                Multipath TCP                    July 2009


   this data sequence number is valid for, allowing a receiver to infer
   when it has received sufficient segments.  The primary motivation for
   this behaviour is the understanding that devices involved in re-
   segmentation typically repeat additional TCP options into every re-
   segmented packet.  The use of this length field will make it clear
   when all relevant segments have been received.  (It is FFS whether
   this is the optimal solution to this issue.)

   As a TCP option contains a length field, the length of the Data
   Sequence Number can be declared implicitly.  Although it is expected
   that initial implementations will use 32-bit sequence numbers (i.e. 4
   octets, so a length field of 8), setting the length field to 12 and
   including a 64-bit sequence number (of four octets) MUST be
   considered valid and processed appropriately.  This may have also
   have useful security implications, discussed in Section 6.

   As wth the standard TCP sequence number, the data sequence number
   should not start at zero, but at a random value to make session
   hijacking harder.  This is done by including a Data Sequence Number
   option along with the Multipath Capable option in the initial SYN
   (which occupies one octet of data sequence space; see Section 4.1).

   The Data Sequence Number is included in every MPTCP packet that
   contains data (or a DATA FIN, see Section 4.5), even if only one path
   is in use, so long as the MPTCP handshake has been completed and the
   endpoints have therefore agreed to use MPTCP.

   The MPTCP data and subflow level sequence numbering could be seen to
   be analogous to that used in SACK, however there are subtle
   differences.  The key similarity is that it is possible to have
   temporary "holes" in the received data sequence space - later data
   may have arrived earlier (most likely on a different subflow), but
   does not need to be retransmitted.  The "holes" are later filled in.
   The key difference, however, is that while SACK can rely on the
   regular TCP cumulative acknowledgements to indicate how much data has
   been successfully received (with no holes), there is no similar
   method in MPTCP.  Instead, the sender must keep track of the
   acknowledgements to derive what data has been successfully received.
   This leads to some oddities especially with session termination (see
   Section 4.5).

4.4.1.  Receive Window Considerations

   Normal TCP advertises a receive window in each packet, telling the
   sender how much data the receiver is willing to accept past the
   cumulative ack.  The receive window is used to implement flow
   control, throttling down fast senders when receivers cannot keep up.




Ford, et al.            Expires January 11, 2010               [Page 16]

Internet-Draft                Multipath TCP                    July 2009


   MPTCP also uses a unique receive window, shared between the subflows.
   The idea is to allow any subflow to send data as long as the receiver
   is willing to accept it; the alternative, maintaining per subflow
   receive windows, could end-up stalling some subflows while others
   would not use up their window.

4.4.2.  Congestion Control Considerations

   Different subflows in an MPTCP connection have different congestion
   windows.  To achieve resource pooling [WISCHIK], it is necessary to
   couple the congestion windows in use on each subflow, in order to
   push most traffic to uncongested links.  One algorithm for achieving
   this is presented in Section 5; the algorithm does not achieve
   perfect resource pooling but is "safe" in that it is readily
   deployable in the current Internet.

   It is foreseeable that different congestion controllers will be
   implemented for MPTCP, each aiming to achieve different properties in
   the resource pooling/fairness/stability design space.  Much research
   is expected in this area in the near future.

   Regardless of the algorithm used, the design of the MPTCP protocol
   aims to provide the congestion control implementations sufficient
   information to take the right decisions; this information includes,
   for each subflow, which packets where lost and when.

4.4.3.  Subflow Policy

   Within a local MPTCP implementation, a host may use any local policy
   it wishes to decide how to share the traffic to be sent over the
   available paths.

   In the typical use case, where the goal is to maximise throughput,
   all available paths will be used simultaneously for data transfer.
   It is expected, however, that other use cases will appear.

   For instance, a possibility is an 'all-or-nothing' approach, i.e.
   have a second path ready for use in the event of failure of the first
   path, but alternatives could include entirely saturating one path
   before using an additional path (the 'overflow' case).  Such choices
   would be most likely based on the monetary cost of links, but may
   also be based on properties such as delay or bandwidth, in cases
   where the additional paths are significantly worse and not worth
   including in the base operation.  Other metrics such as this could be
   wrapped into an overall "cost" metric for a link.

   The ability to make effective choices at the sender requires full
   knowledge of the path cost, which is unlikely to be the case.  There



Ford, et al.            Expires January 11, 2010               [Page 17]

Internet-Draft                Multipath TCP                    July 2009


   is no mechanism in MPTCP for a receiver to signal their own
   particular preferences for paths, but this is a necessary feature
   since receivers will often be the multihomed party, such as in the
   case of laptop computers with wired and wireless connectivity.
   Instead of incorporating complex signalling, it is proposed to use
   existing TCP features to signal priority implicitly.  If a receiver
   wishes to keep a path active as a backup but wishes to prevent data
   being sent on that path, this could be achieved by the receiver not
   sending ACKs for any data it receives on that path.  The sender would
   interpret this as severe congestion or a broken path and stop using
   it.  We do not advocate this method, however, since this is brutal,
   naive, and will result in unnecessary retransmissions.

   Therefore, it is proposed to use ECN [RFC3168] to to provide fake
   congestion signals on paths that a receiver wishes to stop being used
   for data.  This has the benefit of causing the sender to back off
   without the need to retransmit data unnecessarily, as in the case of
   a lost ACK.  This should be sufficient to allow a receiver to express
   their policy, although does not permit a rapid increase in throughput
   when switching to such a path.

4.4.4.  Retransmissions

   This protocol specification does not mandate any mechanisms for
   handling retransmissions in the event of path failures, and much will
   be dependent upon local policy (as discussed in Section 4.4.3).  The
   data sequence number, as given in a TCP option, is used to reassemble
   the incoming streams before presentation to the application layers,
   so a sender is free to re-send data with the same data sequence
   number on a different subflow.  When doing this, an endpoint must
   still retransmit the original data on the original subflow, in order
   to preserve the subflow integrity (middleboxes could replay old data,
   and/or could reject holes in subflows), and a receiver will ignore
   these retransmissions.  While this is clearly suboptimal, for
   compatibility reasons we feel this is the best behaviour.
   Optimisations could be negotiated in future versions of this
   protocol.

   Of course, retransmissions on alternative subflows will only occur if
   this is what local policy suggests.  Indeed, it may be equally valid
   to retransmit on the same subflow if alternative paths have
   considerably worse quality of service, or are only kept for backup
   purposes.  Additionally, it may be possible for some implementations
   to signal from lower layers if there are problems with the paths, and
   so more appropriate responses could occur.






Ford, et al.            Expires January 11, 2010               [Page 18]

Internet-Draft                Multipath TCP                    July 2009


4.5.  Closing a Connection

   Under single path TCP, a FIN signifies that the sender has no more
   data to send.  In order to allow subflows to operate independently,
   however, and with as little change from regular TCP as possible, a
   FIN in MPTCP will only affect the subflow on which it is sent.  This
   allows nodes to exercise considerable freedom over which paths are in
   use at any one time.  The semantics of a FIN remain as for regular
   TCP, i.e. it is not until both sides have ACKed each other's FINs
   that the subflow is fully closed.

   When an application calls close() on a socket, this indicates that it
   has no more data to send, and for regular TCP this would result in a
   FIN on the connection.  For MPTCP, an equivalent mechanism is needed,
   and this is the DATA FIN.  This option, shown in Figure 8, is
   attached to a regular FIN option on a subflow.

   A DATA FIN is an indication that the sender has no more data to send,
   and as such can be used as a rapid indication of the end of data from
   a sender.  Therefore, it is an optimisation to clean up state
   associated with a MPTCP connection, especially when some subflows may
   have failed.  Specifically, when a DATA FIN has been received, IF all
   data has been successfully received, timeouts on all subflows MAY be
   reduced.  Similarly, when sending a DATA FIN, once all data
   (including the DATA FIN has been acknowledged, FINs must be sent on
   every subflow.  This applies to both endpoints, and is required in
   order to clean up state in middleboxes.

   There are complex interactions, however, between a DATA FIN and
   subflow properties:

   o  A DATA FIN can only be sent on a packet which also has the FIN
      flag set.

   o  A DATA FIN occupies one octet (the final octet) of Data Sequence
      Number space.  Therefore, even if there is no user data, a Data
      Sequence Number option must be added to a packet containing the
      DATA FIN option.  This allows the receiver to easily determine the
      last data sequence number that should have been received.

   o  There is a one-to-one mapping between the DATA FIN and the
      subflow's FIN flag (and its associated sequence space and thus its
      acknowlegement).  In other words, when a subflow's FIN flag has
      been acknowledged, the associated DATA FIN is also acknowledged.

   o  As such, the acknowledgement of a FIN and DATA FIN DOES NOT
      indicate that all data has been successfully received.  Because
      the data level ack is inferred from subflow acks, the endpoint can



Ford, et al.            Expires January 11, 2010               [Page 19]

Internet-Draft                Multipath TCP                    July 2009


      tell when all data before the DATA FIN has been received.

   It should be noted that an endpoint may also send a FIN on an
   individual subflow to shut it down, but this impact is limited to the
   subflow in question.  If all subflows have been closed with a FIN,
   that is equivalent to having closed the connection with a DATA FIN.

                           1
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
      +---------------+---------------+
      | Kind=OPT_DFIN |   Length = 2  |
      +---------------+---------------+

                         Figure 8: DATA FIN option

4.6.  Error Handling

   TBD

   Unknown token in MPTCP SYN should equate to an unknown port, e.g. a
   TCP reset?  We should make this as silent and tolerant as possible.
   Where possible, we should keep this close to the semantics of TCP.
   The amount of error handling required may also have an impact on the
   choice of path management schemes.  Issues may include odd cases
   where a data sequence number is missing from a subflow.  Will
   definitely need errors in those cases.


5.  Congestion Control Coupling for MPTCP

   Coupling congestion windows can achieve resource pooling, by pushing
   traffic to underutilized areas of the network.  Another effect of
   coupling is fairness at bottleneck: when two MPTCP flows share a
   common bottleneck, their combined throughput should not be more than
   that of a single TCP flow.

   To achieve perfect resource pooling, one must couple both increase
   and decrease of congestion windows across subflows.  Yet this tends
   to exhibit flappyness: when the two paths have similar levels of
   congestion, the controller will tend to allocate all the window to
   one or the other subflows, and perform random flips between the two
   equilibrium points.  This seems not desirable in general, and is
   particularly bad when the achieved rates depend on the RTT (as in the
   current Internet).

   By only coupling increases we remove flappyness but also reduce the
   extent of resource pooling the protocol achieves.  We now succintly
   describe our protocol, assuming there are only two subflows (the



Ford, et al.            Expires January 11, 2010               [Page 20]

Internet-Draft                Multipath TCP                    July 2009


   general case is easy to derive, but is more difficult to understand).

   Let v_1 and v_2 be the congestion windows on the two subflows, and
   assume there is always data to send.  Let w = v_1 + v_2.  Let p_i,
   rtt_i be the drop probability and round trip time on path i.

   Our proposed algorithm is as follows:

   o  Increase v_i by a/w for each ack received on subflow i.

   o  Decrease v_i by v_i/2 for each drop on subflow i.

   "a" is a parameter of the algorithm, and we'll describe next how to
   pick proper values for it.

   This algorithm will allocate window to the two subflows such that p1
   * v1 = p2 * v2.  Thus, when the drop probabilities are equals, each
   subflow gets an equal window; when they are different, more and more
   window will be allocated to the flow with the lower drop probability.

   The total throughput of the algorithm depends on the drop
   probabilities and rtts of the two paths.  We require that the total
   throughput is no worse than the throughput a single TCP would get on
   the fastest path.  If we kept a constant regardless of path
   properties, this requirement would be violated.  However, if we
   increase a according to the difference in drop probabilities and
   rtts, it is always possible to match the throughput of the best path.

   The second requirement is that none of the subflows should be, on
   their own, more aggressive than a single TCP on the same path.
   Increasing "a" indefinitely as required above, may create fairness
   issues in some scenarios.  In such cases, the "a" parameter is capped
   on the paths where the increase is too aggressive, and some traffic
   is pushed on the other paths.

   It is possible to achieve all this behavior (adjusting and capping a)
   by only using estimates of the rtts and the current windows for the
   two subflows; explicit estimates of the drop probabilities are not
   needed.

   A full description of the congestion control algorithm is beyond the
   scope of this document.  The algorithm will be thoroughly described
   in a companion document, soon to be released.


6.  Security Considerations

   TBD



Ford, et al.            Expires January 11, 2010               [Page 21]

Internet-Draft                Multipath TCP                    July 2009


   (Token generation, handshake mechanisms, new subflow authentication,
   etc...)

   The development of a TCP extension such as this will bring with it
   many additional security concerns.  We have set out here to produce a
   solution that is "no worse" than current TCP, with the possibility
   that more secure extensions could be proposed later.

   The primary area of concern will be around the handshake to start new
   subflows which join existing connections.  The proposal set out in
   Section 4.1 and Section 4.2 is for the initiator of the new subflow
   to include the token of the other endpoint in the handshake.  The
   purpose of this is to indicate that the sender of this token was the
   same entity that received this token at the initial handshake.

   One area of concern is that the token could be simply brute-forced.
   The token must behard to guess, and as such could be randomly
   generated.  This may still not be strong enough, however, and so the
   use of 64 bits for the token would alleviate this somewhat.

   Use of these tokens only provide an indication that the token is the
   same as at the initial handshake, and does not say anything about the
   current sender of the token.  Therefore, another approach would be to
   bring a new measure of freshness in to the handshake, so instead of
   using the initial token a sender could request a new token from the
   receiver to use in the next handshake.

   Yet another alternative would be for all SYN packets to include a
   data sequence number.  This could either be used as a passive
   identifier to indicate an awareness of the current data sequence
   number (although a reasonable window would have to be allowed for
   delays).  Or, the SYN could form part of the data sequence space -
   but this would cause issues in the event of lost SYNs (if a new
   subflow is never established), thus causing unnecessary delays for
   retransmissions.


7.  Interactions with Middleboxes

   TBD

   How we get around NATs, firewalls.  Problems with TCP proxies.  How
   to make an MPTCP-aware middlebox, ...


8.  Interfaces

   TBD



Ford, et al.            Expires January 11, 2010               [Page 22]

Internet-Draft                Multipath TCP                    July 2009


   Interface with applications, interface with TCP, interface with lower
   layers...


9.  Acknowledgements

   The authors are supported by Trilogy
   (http://www.trilogy-project.org), a research project (ICT-216372)
   partially funded by the European Community under its Seventh
   Framework Program.  The views expressed here are those of the
   author(s) only.  The European Commission is not liable for any use
   that may be made of the information in this document.

   The authors gratefully acknowledge significant input into this
   document from many members of the Trilogy project, notably Iljitsch
   van Beijnum, Lars Eggert, Marcelo Bagnulo Braun, Robert Hancock, Pasi
   Sarolahti, Olivier Bonaventure, Toby Moncaster, Philip Eardley and
   Andrew McDonald.


10.  IANA Considerations

   This document will make a request to IANA to allocate new values for
   TCP Option identifiers, as follows:

       +------------+----------------------+---------------+-------+
       |   Symbol   |         Name         |      Ref      | Value |
       +------------+----------------------+---------------+-------+
       |   OPT_MPC  |   Multipath Capable  |  Section 4.1  | (tbc) |
       |  OPT_ADDR  |      Add Address     | Section 4.3.1 | (tbc) |
       | OPT_REMADR |    Remove Address    | Section 4.3.2 | (tbc) |
       |  OPT_JOIN  |    Join Connection   |  Section 4.2  | (tbc) |
       |   OPT_DSN  | Data Sequence Number |  Section 4.4  | (tbc) |
       |  OPT_DFIN  |       DATA FIN       |  Section 4.5  | (tbc) |
       +------------+----------------------+---------------+-------+

                      Table 1: TCP Options for MPTCP


11.  References

11.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.






Ford, et al.            Expires January 11, 2010               [Page 23]

Internet-Draft                Multipath TCP                    July 2009


11.2.  Informative References

   [I-D.eddy-tcp-loo]
              Eddy, W. and A. Langley, "Extending the Space Available
              for TCP Options", draft-eddy-tcp-loo-04 (work in
              progress), July 2008.

   [I-D.ietf-shim6-proto]
              Nordmark, E. and M. Bagnulo, "Shim6: Level 3 Multihoming
              Shim Protocol for IPv6", draft-ietf-shim6-proto-12 (work
              in progress), February 2009.

   [I-D.van-beijnum-1e-mp-tcp-00]
              van Beijnum, I., "One-ended Multipath TCP",
              draft-van-beijnum-1e-mp-tcp-00 (work in progress),
              May 2009.

   [RFC0793]  Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, September 1981.

   [RFC2018]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
              Selective Acknowledgment Options", RFC 2018, October 1996.

   [RFC3168]  Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              RFC 3168, September 2001.

   [WISCHIK]  Wischik, D., Handley, M., and M. Bagnulo Braun, "The
              Resource Pooling Principle", ACM SIGCOMM CCR vol. 38 num.
              5, pp. 47-52, October 2008,
              <http://ccr.sigcomm.org/online/files/p47-handleyA4.pdf>.


Appendix A.  Functional Separation

   [Potential to move to separate architectural document]

   This section describes the functional separation that drives the
   design of the MPTCP protocol.  Its main goal is to separate MPTCP in
   two parts that communicate through a well defined interface.  We
   first provide the motivations for this functional separation, then we
   describe in more details the two main components of the MPTCP
   architecture.

A.1.  Motivations

   The major goal behind MPTCP is to send data over different paths in
   the same time.  This assumes that an MPTCP implementation must be



Ford, et al.            Expires January 11, 2010               [Page 24]

Internet-Draft                Multipath TCP                    July 2009


   able to discover and use the multiple paths that connect two given
   hosts, when they exist.  However, different mechanisms can be
   envisioned for multipath discovery and use.  Examples are as follows:

   Use multiple addresses:  This is the method currently proposed in
      this document - if hosts are multi-addressed, different address
      pairs may take different routes.

   Use a path selector value:  An end-host might be able to tag packets
      with a path selector value, or "colour".  If some network nodes
      are able to read the colour and use it as a path selector, the
      host can influence the outgoing path of the packet.

   Next-hop selection:  In a network configuration where multiple next-
      hops can offer to forward packets, a host may decide to send some
      of its packets through one next-hop, and some through another.

   The above list is not exhaustive, and could grow as new network
   technologies are deployed.

A.2.  TCP Performance

   In addition to purely sending data over multiple paths, MTCP must do
   it in a way that will not affect TCP performance.  This raises the
   need for an efficient multipath congestion control algorithm.  While
   this specification does not mandate the use of any particular
   algorithm for congestion control, it ensures that the protocol is
   designed in such a way that any CC algorithm can be designed,
   independently of the particular path management mechanism available
   to the host.  Consequently our architecture for MTCP decouples the
   policy from the mechanism.  The policy is the decision of what path
   to use for each packet to send.  It is mainly driven by the
   implementation-dependent congestion control algorithm.  The mechanism
   is the technology used to ensure that a packet will be sent on the
   desired path.  This separation is intended to be relatively future-
   proof by allowing these components to evolve at different speeds.

A.3.  Architecture overview













Ford, et al.            Expires January 11, 2010               [Page 25]

Internet-Draft                Multipath TCP                    July 2009


            Control plane    <--     |     -->    Data plane
   +---------------------------------------------------------------+
   |                     Multipath Scheduler (MPS)                 |
   +---------------------------------------------------------------+
                ^                    |          |
                |                    |          |
                |Announcing new      |   +-------------+
                |paths. (referred    |   | Data packet |<--Path idx:3
                |to as path indices) |   +-------------+   attached
                |                    |          |          by MPS
                |                    |          V
   +--------------------------------------------\------------------+
   |                         Path Manager (PM)   \__________zzzzz  |
   +--------------------------------------------------------\------+
      /                   \          |                       \
     /---------------------\         |   /"\       /"\       /"\
     | Path key    Action  |         |   | |       | |       | |
     |     1        xxxxx  |         |   | |       | |       | |
     |     2        yyyyy  |         |   \./       \./       \./
     |     3        zzzzz  |         |  path1     path2     path3
     +---------------------+

                  Figure 9: Overview of MTCP architecture

   A general overview of the architecture is provided in Figure 9.  The
   Multipath Scheduler (MPS) learns about the number of available paths
   through notifications received from the Path Manager (PM).  From the
   point of view of the Multipath Scheduler, a path is just a number,
   called a Path Index.  Notifications from the PM to the MPS MAY
   contain supporting information about the paths, if relevant, so that
   the MPS can make more intelligent decisions about where to route
   traffic.  When the Multipath Scheduler initiates a communication to a
   new host, it can only send the packets to the default path.  But
   since the Path manager is layered below the MPS, it can detect that a
   new communication is happening, and tell the MPS about the other
   paths it knows about.

   From then on, it is possible for the MPS to attach a Path Index to
   the control structure of its packets (internal to the MTCP
   implementation), so that the Path Manager can map this Path Index to
   the corresponding action. (see table in the lower left part of
   Figure 9).  The particular action depends on the network mechanism
   used to select a path.  Examples are address rewriting, tunnelling or
   setting a path selector valude inside the packet.

   The applicability of the architecture is not limited to the MTCP
   protocol.  While we define in this document an MTCP MPS (MTCP
   Multipath Scheduler), other Multipath Schedulers can be defined.  For



Ford, et al.            Expires January 11, 2010               [Page 26]

Internet-Draft                Multipath TCP                    July 2009


   example, if an appropriate socket interface is designed, applications
   could behave as a Multipath Scheduler and decide where to send any
   particular data.  In this document we concentrate on the MTCP case,
   however.

   In this specification, we define the core protocol for Multipath TCP.
   The core protocol is not dependent on the Path Management technique
   that is chosen, and MUST be implemented in any MTCP MPS.  We also
   provide a default Path Manager that is based on declaring IP
   addresses, and carries control information in TCP options.  An
   implementation of Multipath TCP can use any Path Manager, but it MUST
   be able to fallback to the default PM in case the other end does not
   support the custom PM.  Alternative Path Managers may be specified in
   separate documents in the future.

A.4.  PM/MPS interface

   The minimal set of requirement for a Path Manager is as follows:

   o  Outgoing untagged packets: Any outgoing packet flowing through the
      Path Manager is either tagged or untagged (by the MPS) with a path
      index.  If it is untagged, the packet is sent normally to the
      Internet, as if no multi-path support were present.  Untagged
      packets can be used to trigger a path discovery procedure, that
      is, a Path Manager can listen to untagged packets and decide at
      some time to find if any other path than the default one is
      useable for the corresponding host pair.  Note that any other
      criteria could be used to decide when to start discovering
      available paths.  Note also that MPS scheduling will not be
      possible until the Path Manager has notified the available paths.
      The PM is thus the first entity coming into action.

   o  Outgoing tagged packets: The Path Manager maintains a table
      mapping path indices to actions.  The action is the operation that
      allows using a particular path.  Examples of possible actions are
      route selection, interface selection or packet transformation.
      When the PM sees a packet tagged with a path index, it looks up
      its table to find the appropriate action for that packet.  The tag
      is purely local.  It is removed before the packet is transmitted.

   o  Incoming packets: A Path Manager MUST ensure that incoming path is
      mapped unambiguously to exactly one outgoing path.  Note that this
      requirement implies that the same number of incoming/outgoing
      paths must be established.  Moreover, a PM MUST tag any incoming
      path with the same Path Index as the one used for the
      corresponding outgoing path.  This is necessary for MTCP to know
      what outgoing path in acknowledged by an incoming packet.




Ford, et al.            Expires January 11, 2010               [Page 27]

Internet-Draft                Multipath TCP                    July 2009


   o  Module interface: A PM MUST be able to notify the MPS about the
      number of available paths.  Such notifications MUST contain the
      path indices that are legal for use by the MPS.  In case the PM
      decides to stop providing service for one path, it MUST notify the
      MPS about path deletion.  Additionnaly, a PM MAY provide
      complementary path information when available, such as link
      quality or preference level.


Appendix B.  Notes on use of TCP Options

   The TCP option space is limited due to the length of the Data Offset
   field in the TCP header (4 bits), which defines the TCP header length
   in 32-bit words.  With the standard TCP header being 20 bytes, this
   leaves a maximum of 40 bytes for options, and many of these may
   already be used by options such as timestamp and SACK.

   As such, when doing address list manipulation, not all data may fit.
   This can be mitigated in one of two ways:

   o  Using an option to extend the option space, such as that proposed
      in [I-D.eddy-tcp-loo], which proposes an option providing a 16-bit
      header length field.  Such an option could only be used between
      nodes that support it, however, and so long options could not be
      used until a handshake is complete.

   o  Alternatively, since at least one IP address option field should
      be able to fit per packet, address list manipulation can be
      undertaken with one address per packet.  One method could be to
      wait for data to send, and then append one new address per packet.
      This would seem reasonable if the TCP session begins rapidly, but
      if it is required that the multipath session is ready before the
      first data is to be sent, address list manipulation would be
      required on empty data (signalling only) packets.  Issues may
      arise regarding acknowledged delivery of signalling versus data -
      this is discussed in Section 3 below.


Appendix C.  Resync Packet

   In earlier versions of this draft, we proposed the use of a "re-sync"
   option that would be used in certain circumstances when a sender
   needs to instruct the receiver to skip over certain subflow sequence
   numbers (i.e. to treat the specified sequence space as having been
   received and acknowledged).

   The typical use of this option will be when packets are retransmitted
   on different subflows, after failing to be acknowledged on the



Ford, et al.            Expires January 11, 2010               [Page 28]

Internet-Draft                Multipath TCP                    July 2009


   original subflow.  In such a case, it becomes necessary to move
   forward the original subflow's sequence numbering so as not to later
   transmit different data with a previously used sequence number (i.e.
   when more data comes to be transmitted on the original subflow, it
   would be different data, and so must not be sent with previously-used
   (but unacknowledged) sequence numbering).

   The rationale for needing to do this is two-fold: firstly, when ACKs
   are received they are for the subflow only, and the sender infers
   from this the data that was sent - if the same sequence space could
   be occupied by different data, the sender won't know whether the
   intended data was received.  Secondly, certain classes of middleboxes
   may cache data and not send the new data on a previously-seen
   sequence number.

   This option was dropped, however, since some middleboxes may get
   confused when they meet a hole in the sequence space, and do not
   understand the resync option.  It is therefore felt that the same
   data must continue to be retransmitted on a subflow even if it is
   already received after being retransmitted on another.  There should
   not be a significant performance hit from this since the amount of
   data involved and needing to be retransmitted multiple times will be
   relatively small.

   Therefore, it is necessary to 're-sync' the expected sequence
   numbering at the receiving end of a subflow, using the following TCP
   option.  This packet declares a sequence number space (inclusive)
   which the receiving node should skip over, i.e. if the receiver's
   next expected sequence number was previously within the range
   start_seq_num to end_seq_num, move it forward to end_seq_num + 1.

   This option will be used on the first new packet on the subflow that
   needs its sequence numbering re-synchronised.  It will be continue to
   be included on every packet sent on this subflow until a packet
   containing this option has been acknowledged (i.e. if subflow
   acknowledgements exist for packets beyond the end sequence number).
   If the end sequence number is earlier than the current expected
   sequence number (i.e. if a resync packet has already been received),
   this option should be ignored.












Ford, et al.            Expires January 11, 2010               [Page 29]

Internet-Draft                Multipath TCP                    July 2009


                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+------------------------------+
      |Kind=OPT_RESYNC|  Length = 10  |     Start Sequence Number    :
      +---------------+---------------+------------------------------+
      :          (4 octets)           |      End Sequence Number     :
      +---------------+---------------+------------------------------+
      :          (4 octets)           |
      +-------------------------------+

                         Figure 10: Resync option


Authors' Addresses

   Alan Ford
   Roke Manor Research
   Old Salisbury Lane
   Romsey, Hampshire  SO51 0ZN
   UK

   Phone: +44 1794 833 465
   Email: alan.ford@roke.co.uk


   Costin Raiciu
   University College London
   Gower Street
   London  WC1E 6BT
   UK

   Email: c.raiciu@cs.ucl.ac.uk


   Mark Handley
   University College London
   Gower Street
   London  WC1E 6BT
   UK

   Email: m.handley@cs.ucl.ac.uk










Ford, et al.            Expires January 11, 2010               [Page 30]

Internet-Draft                Multipath TCP                    July 2009


   Sebastien Barre
   Universite catholique de Louvain
   Pl. Ste Barbe, 2
   Louvain-la-Neuve  1348
   Belgium

   Phone: +32 10 47 91 03
   Email: sebastien.barre@uclouvain.be











































Ford, et al.            Expires January 11, 2010               [Page 31]

