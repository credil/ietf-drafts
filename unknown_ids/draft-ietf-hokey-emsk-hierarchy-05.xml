<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc2434 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2434.xml">
<!ENTITY rfc3748 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3748.xml">
<!ENTITY rfc4306 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4306.xml">
<!ENTITY rfc4346 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4346.xml">
<!ENTITY rfc1034 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml">
<!ENTITY rfc0822 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0822.xml">
<!ENTITY rfc4282 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4282.xml">
<!ENTITY ietf-eap-keying SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-eap-keying.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<rfc category="std" docName="draft-ietf-hokey-emsk-hierarchy-05.txt" ipr="full3978">
  <front>
    <title abbrev="EMSK Root Key Derivation">Specification for the Derivation of Root Keys from an
      Extended Master Session Key (EMSK)</title>

    <author fullname="Joseph Salowey" initials="J." surname="Salowey">
      <organization>Cisco Systems</organization>

      <address>
        <email>jsalowey@cisco.com</email>
      </address>
    </author>

    <author fullname="Lakshminath Dondeti" initials="L." surname="Dondeti">
      <organization>Qualcomm, Inc</organization>

      <address>
        <email>ldondeti@qualcomm.com</email>
      </address>
    </author>

    <author fullname="Vidya Narayanan" initials="V." surname="Narayanan">
      <organization>Qualcomm, Inc</organization>

      <address>
        <email>vidyan@qualcomm.com</email>
      </address>
    </author>

    <author fullname="Madjid Nakhjiri" initials="M." surname="Nakhjiri">
      <organization>Motorola</organization>

      <address>
        <email>madjid.nakhjiri@motorola.com</email>
      </address>
    </author>

    <date month="April" year="2008"/>

    <area>Security Area</area>

    <workgroup>Network Working Group</workgroup>

    <abstract>
      <t>The Extensible Authentication Protocol (EAP) defined the Extended Master Session Key (EMSK) generation, but reserved it for unspecified future uses. This memo reserves the EMSK for the sole purpose of deriving root keys. Root keys are are master keys that can be used for multiple purposes, identified by usage definitions.  This document also specifies a mechanism for avoiding conflicts between root keys by deriving them in a manner that guarantee cryptographic separation. Finally, this document also defines one such root key usage: domain specific root keys are root keys made available to and used within specific key management domains.</t>  

      <t/>

      <t/>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t>This document deals with keys generated by authenticated key exchange mechanisms defined
        within the EAP framework <xref target="RFC3748"/>. EAP defines two types of keying material;
        a Master Session Key (MSK) and an Extended Master Session Key (EMSK). The EAP specification
        implicitly assumes that the MSK produced by EAP will be used for a single purpose at a
        single device, however it does reserve the EMSK for future use. This document defines the
        EMSK to be used solely for deriving root keys using the key derivation specified. The root
        keys are meant for specific purposes called usages; a special usage class is the domain specific root keys made
        available to and used within specific key management domains. This document also provides 
        guidelines for creating usage definitions for the various uses of EAP key material and for
        the management of the root keys. In this document, the terms application and usage (or
        "usage definition") refer to a specific use case of the EAP keying material.</t>


      <t>Different uses for keys derived from the EMSK have been proposed. Some examples include
        hand off across access points in various mobile technologies, mobile IP authentication and
        higher layer application authentication. In order for a particular usage of EAP key material
        to make use of this specification it must specify a so-called usage definition. This document does not define how the derived Usage Specific Root Keys (USRK) are used, see the following section for discussion of applicable usages. It does define a framework for the derivation of USRKs for
        different purposes such that different usages can be developed independently from one
        another. The goal is to have security properties of one usage have minimal or no effect on
        the security properties of other usages.  </t>

      <t>This document does define a special class of USRK, called a Domain Specific Root Key (DSRK)
         for use in deriving keys specific to a key management domain.  Each DSRK is a root key 
         used to derive Domain Specific Usage Specific Root Keys (DSUSRK).  
         The DSUSRKs are USRKs specific to a particular key management domain. </t>

      <t>In order to keep root keys for specific purposes separate from one another, two requirements
        are defined in the following sections. One is coordinated key derivation and another is
        cryptographic separation.</t>
      <section title="Applicable usages of keys derived from the EMSK">
	<t>The EMSK is established as part of network access authentication and authorization.  The derived keys need to be distributed to the involved parties along with context necessary to use them.  The security of the system relies upon trust relationships between the parties involved in this process.  These trust relationships are the basis for applying protection during key transport and ensuring proper key usage. Hence, deriving USRKs or DSUSRKs for purposes where placing trust in the entities involved in establishing network access is inappropriate or not possible is NOT RECOMMENDED. </t>

<t>It is also only feasible to make use of EMSK usages when network access occurs over an EAP-capable interface.  If it is possible for an entity to access these services though an interface that does not involve EAP authentication and authorization with the appropriate entities then alternate means of authentication and key establishment for these services needs to be provided.</t>
      </section>
      <section title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119"/></t>

        <t>The following terms are taken from <xref target="RFC3748"/>: EAP Server, peer,
          authenticator, Master Session Key (MSK), Extended Master Session Key (EMSK), Cryptographic
          Separation.</t>

        <t>Usage Definition<list>
            <t>An application of cryptographic key material to provide one or more security
              functions such as authentication, authorization, encryption or integrity protection
              for related applications or services. This document provides guidelines and
              recommendations for what should be included in usage definitions. This document does
              not place any constraints on the types of use cases or services that create usage
              definitions.</t>
          </list></t>

        <t>Usage Specific Root Key (USRK)<list>
            <t>Keying material derived from the EMSK for a particular usage definition. 
               It is used to derive child keys in a way defined by its usage definition.</t>
          </list></t>
	  <t>Key Management Domain<list>
	  <t>A key management domain is specified by the scope of a given root key.
The scope is the collection of systems authorized to access key material derived from that key. Systems within a key
	    management domain may be authorized to (1) derive key materials, (2) use key materials, or (3) distribute key
	    materials to other systems in the same domain.  A derived key's scope is constrained to a subset of the scope of
	    the key it is derived from. In this document the term domain refers to a key management domain unless otherwise
	    qualified.      
</t></list></t>
 
        <t>Domain Specific Root Key (DSRK)<list>
            <t>Keying material derived from the EMSK that is restricted to use in a specific
              key management domain. It is used to derive
              child keys for a particular usage definition. The child keys derived from a DSRK are
              referred to as domain specific usage specific root keys (DSUSRK). DSUSRKs are similar
              to the USRK, except in the fact that their scope is restricted to the same domain as
              the parent DSRK from which it is derived. </t>
          </list>

	</t>


      </section>

      <t/>
    </section>

    <section title="Cryptographic Separation and Coordinated Key Derivation">
      <t>The EMSK is used to derive keys for multiple use cases, and thus it is required that the
        derived keys are cryptographically separate. Cryptographic separation means that when
        multiple keys are derived from an EMSK, given any derived key it is computationally
        infeasible to derive any of the other derived keys. Note that deriving the EMSK from any
        combinations of the derived keys must also be computationally infeasible. In practice this
        means that derivation of an EMSK from a derived key or derivation of one child key from
        another must require an amount of computation equivalent to that required to, say, reversing
        a cryptographic hash function.</t>

      <t>Cryptographic separation of keys derived from the same key can be achieved in many ways.
        Two obvious methods are as follows: it is plausible to use the IKEv2 PRF <xref
          target="RFC4306"/> on the EMSK and generate a key stream. Keys of various lengths may be
        provided as required from the key stream for various uses. The other option is to derive
        keys from EMSK by providing different inputs to the PRF. However, it is desirable that
        derivation of one child key from the EMSK is independent of derivation of another child key.
        This allows child keys to be derived in any order, independent of other keys. Thus it is
        desirable to use the second option from above. That implies the additional input to the PRF
        must be different for each child key derivation. This additional input to the PRF must be
        coordinated properly to meet the requirement of cryptographic separation and to prevent
        reuse of key material between usages.</t>

      <t>If cryptographic separation is not maintained then the security of one usage depends upon
        the security of all other usages that use key derived from the EMSK. If a system does not
        have this property then a usage's security depends upon all other usages deriving keys from
        the same EMSK, which is undesirable. In order to prevent security problems in one usage from
        interfering with another usage, the following cryptographic separation is required:</t>

      <t>
        <list style="symbols">
          <t>It MUST be computationally infeasible to compute the EMSK from any root key derived
            from it.</t>

          <t>Any root key MUST be cryptographically separate from any other root key derived from
            the same EMSK or DSRK</t>

          <t>Derivation of USRKs MUST be coordinated so that two separate cryptographic usages do
            not derive the same key.</t>

          <t>Derivation of DSRKs MUST be coordinated so that two separate key management domains do
            not derive the same key.</t>
          
          <t>Derivation of DSRKs and USRKs MUST be specified such that no domain can obtain a USRK by providing a
            domain name identical to a Usage Key Label.</t>
        </list>
      </t>

      <t>This document provides guidelines for a key derivation mechanism, which can be used with existing and new
        EAP methods to provide cryptographic separation between usages of EMSK. This allows for the
        development of new usages without cumbersome coordination between different usage
        definitions.</t>
    </section>

    <section anchor="keyframe" title="EMSK Key Root Derivation Framework ">
      <t>The EMSK key derivation framework provides a coordinated means for generating multiple root
        keys from an EMSK. Further keys may then be derived from the root key for various purposes,
        including encryption, integrity protection, entity authentication by way of proof of
        possession, and subsequent key derivation. A root key is derived from the EMSK for specific
        set of uses set forth in a usage definition described in <xref target="usage"/>.</t>

      <t>The basic EMSK root key hierarchy looks as follows:</t>
      <t>
        <figure>
          <preamble/>

          <artwork><![CDATA[                   EMSK
                  /    \     
                USRK1  USRK2
]]></artwork>
        </figure>
      </t>
      <t>This document defines how to derive usage specific root keys (USRK) from the EMSK and also defines a specific
        USRK called  a domain specific root key (DSRK). DSRK are root keys 
        restricted to use in a particular key management domain. From the DSRK, usage specific root
        keys for a particular application may be derived (DSUSRK). The DSUSRKs are equivalent to
        USRKs that are restricted to use in a particular domain. The details of lower levels of key
        hierarchy are outside scope of this document. The key hierarchy looks as follows:</t>
      <t>
        <figure>
          <preamble/>

          <artwork><![CDATA[
                   EMSK
                  /    \     
               USRK   DSRK
                     /    \
                DSUSRK1 DSUSRK2
]]></artwork>
        </figure>
      </t>
      <section title="USRK Derivation" anchor="KDF">
        <t>The EMSK Root Key derivation function (KDF) derives a USRK from the EMSK, a key
          label, optional data, and output length. The KDF is expected to give the same output for
          the same input. The basic key derivation function is given below.</t>

        <t>
          <figure>
            <preamble/>

            <artwork><![CDATA[
     USRK = KDF(EMSK, key label | "\0" | optional data | length)
        
   Where: 

     | denotes concatenation
     "\0" is a NULL octet (0x00 in hex)
     length is a 2 octet unsigned integer in network byte order
              ]]></artwork>
            <postamble/>
          </figure>
        </t>

        <t>The key labels are printable ASCII strings unique for each usage definition and are a
          maximum of 255 octets. In general they are of the form label-string@specorg where specorg
          is the organization that controls the specification of the usage definition of the Root
          Key. The key label is intended to provide global uniqueness. Rules for the allocation of
          these labels are given in <xref target="IANA"/>.
          </t>
          
        <t>The NULL octet after the key label is used to avoid collisions if one key label is a
          prefix of another label (e.g. "foobar" and "foobarExtendedV2"). This is considered a
          simpler solution than requiring a key label assignment policy that prevents prefixes from
          occurring.</t>
        
        <t>
          For the optional data the KDF MUST be capable of processing at least 2048 opaque octets. The optional data
          must be constant during the execution of the KDF.    Usage definitions MAY use the EAP session-ID <xref
            target="I-D.ietf-eap-keying"/>  in the specification of the optional data parameter that go into the KDF
          function. This provides the advantage of providing data into the key derivation that is unique to the session
          that generated the keys.  
        </t>
        <t>The KDF must be able to process input keys of up to 256 bytes. It may do this by providing a mechanism for "hashing" long keys down to a suitable size that can be consumed by the underlying derivation algorithm. </t>
        <t>
          The length is a 2-octet unsigned integer in network byte order of the output key length in octets. An
          implementation of the KDF MUST be capable of producing at least 2048 octets of output, however it is
          RECOMMENDED that Root Keys be at least 64 octets long.</t>
    
        <t>A usage definition requiring derivation of a Root Key must specify all the inputs (other
          than EMSK) to the key derivation function.</t>
        
        <t>USRKs MUST be at least 64 octets in length.</t>
        
        <section title="On the KDFs">
 
        <t>This specification allows for the use of different KDFs. However, in order to have a
          coordinated key derivation function the same KDF function MUST be used for all key
          derivations for a given EMSK. If no KDF is specified, then the default KDF specified in
            <xref target="defprf"/> MUST be used. A system may provide the capability to negotiate
          additional KDFs. KDFs are assigned numbers through IANA following the policy set in
          section <xref target="IANA"/>. The rules for negotiating a KDF are as follows:</t>

        <t>
          <list style="symbols">
            <t>If no other KDF is specified the KDF specified in this document MUST be used. This is
              the "default" KDF.</t>

            <t>The initial authenticated key exchange MAY specify a favored KDF. For example an EAP
              method may define a preferred KDF to use in its specification. If the initial
              authenticated key exchange specifies a KDF then this MUST override the default KDF.</t>

            <t>A system MAY specify a separate default KDF if all participants within the system
              have the knowledge of which KDF to use. If specified this MUST take precedence over
              key exchange defined KDF.</t>
          </list>
        </t>

        <t>Note that usage definitions MUST NOT concern themselves with the details of the KDF
          construction or the KDF selection, they only need to worry about the inputs specified in
            <xref target="keyframe"/>.</t>
      </section>

      <section anchor="defprf" title="Default KDF">
        <t>The default KDF for deriving root keys from an EMSK is taken from the PRF+ key expansion
          specified in <xref target="RFC4306"/> based on HMAC-SHA-256 <xref target="SHA256"/>. The PRF+
          construction was chosen because of its simplicity and efficiency over other mechanisms such as
          those used in <xref target="RFC4346"/>. The motivation for the design of PRF+ is
          described in <xref target="SIGMA"/>. The definition of PRF+ from <xref target="RFC4306"
          />is given below:</t>

        <figure>
          <preamble/>

          <artwork><![CDATA[
     PRF+ (K,S) = T1 | T2 | T3 | T4 | ...
            ]]></artwork>
        </figure>

        <t>Where:</t>

        <figure>
          <artwork><![CDATA[
     T1 = PRF (K, S | 0x01)
     T2 = PRF (K, T1 | S | 0x02)
     T3 = PRF (K, T2 | S | 0x03)
     T4 = PRF (K, T3 | S | 0x04)]]></artwork>
        </figure>

        <t>continuing as needed to compute the required length of key material. The key, K, is the
          EMSK and S is the concatenation of key label, the NULL octet, optional data  and length defined in <xref
            target="KDF"/>. For this specification the PRF is 
          taken as HMAC-SHA-256 <xref target="SHA256"/>. Since PRF+ is only defined for 255
          iterations it may produce up to 8160 octets of key material.</t>
      </section>
      </section>

      <section anchor="keyname" title="EMSK and USRK Name Derivation">
        <t>The EAP keying framework <xref target="I-D.ietf-eap-keying"/> specifies that the EMSK MUST be named using the
          EAP Session-Id and a binary or textual indication.  Following that requirement, the EMSK name SHALL be derived
          as follows:</t> 
        <t>
          <figure>
            <preamble/>
            
            <artwork><![CDATA[
     EMSKname = KDF ( EAP Session-ID, "EMSK" | "\0" | length )]]>
         
Where:  

     | denotes concatenation
     "EMSK" consists of the 4 ASCII values for the letters
     "\0" = is a NULL octet (0x00 in hex)
     length is the 2 octet unsigned integer 8 in network byte order   
           </artwork> <postamble/>
          </figure>
        </t>
        <t> </t>
        
        <t>It is RECOMMENDED that all keys derived from the EMSK are referred to by the EMSKname and the context of the
          descendant key usage.  This is the default behavior.  Any exceptions SHALL be signaled by individual usages.</t>
        
        <t>USRKs MAY be named explicitly with a name derivation specified as follows:</t>

        <t>
          <figure>
            <preamble/>

            <artwork><![CDATA[
      USRKName = 
           KDF(EAP Session-ID, key label|"\0"|optional data|length)
         
 Where:
  
      key label and optional data MUST be the same as those used 
        in the corresponding USRK derivation 
      length is the 2 octet unsigned integer 8 in network byte order
              ]]></artwork>

            <postamble/>
          </figure>
        </t>

        <t>USRKName derivation and usage is applicable when there is ambiguity in the referencing the keys using the
          EMSKname and the associated context of the USRK usage.  The usage SHALL signal
          such an exception in key naming, so both parties know the key name used. </t>
        
        
      </section>
    </section>
    <section title="Domain Specific Root Key Derivation">
      <t>A specific USRK called a Domain Specific Root Key (DSRK) is derived from the
        EMSK for a specific set of usages in a particular key management domain. Usages derive
        specific keys for specific services from this DSRK. The DSRK may be
        distributed to a key management domain for a specific set of usages so keys can be derived
        within the key management domain for those usages.  DSRK based usages will follow a key
        hierarchy similar to the following:</t>


      <t>
        <figure>
          <preamble/>

          <artwork><![CDATA[
                                EMSK
                               /    \
                              /      \
                             /        \
                            /          \
                       DSRK1            DSRK2
                      /  \                /  \
                     /    \              /    \
               DSUSRK11  DSUSRK12  DSUSRK21  DSUSRK22
]]></artwork>

          <postamble/>
        </figure>
      </t>


      <t> The DSRK is a USRK with a key label of "dsrk@ietf.org" and the optional data containing a domain label.
        The optional data MUST contain an ASCII string representing the key management domain that the root key is being
        derived for. The DSRK MUST be at least 64 octets long. </t>

      <t>Domain Specific Usage Specific Root Keys (DSUSRK) are derived from the DSRK. The KDF is expected to
        give the same output for the same input. The basic key derivation function is given below.</t>

      <t>
        <figure>
          <preamble/>

          <artwork><![CDATA[
     DSUSRK = KDF(DSRK, key label | "\0" | optional data | length)]]></artwork>

          <postamble/>
        </figure>
      </t>

      <t>The key labels are printable ASCII strings unique for each usage definition within a DSRK
        usage and are a maximum of 255 octets. In general they are of the form label-string@specorg
        where specorg is the organization that controls the specification of the usage definition of
        the DSRK. The key label is intended to provide global uniqueness. Rules for the allocation
        of these labels are given in <xref target="IANA"/>. For the optional data the KDF MUST be
        capable of processing at least 2048 opaque octets. The optional data must be constant during
        the execution of the KDF. The length is a 2-octet unsigned integer in network byte order of
        the output key length in octets. An implementation of the KDF MUST be capable of producing
        at least 2048 octets of output, however it is RECOMMENDED that DSUSRKs be at least 64 octets long.</t>

      <t>Usages that make use of the DSRK must define how the peer learns the domain label to use in a
        particular derivation. A multi-domain usage must define how both DSRKs and specific DSUSRKs
        are transported to different key management domains.  Note that usages may define alternate 
        ways to constrain specific keys to particular key management domains.</t>
      
      <t>
        To facilitate the use of EMSKname to refer to keys derived from DSRKs, EMSKname SHOULD
        be sent along with the DSRK.  The exception is when a DSRKname is expected to be used.  The usage SHALL signal
        such an exception in key naming, so both parties know the key name used.
      </t>
      
        <t>DSUSRKs MAY be named explicitly with a name derivation specified as follows:</t>
        
        <t>
          <figure>
            <preamble/>

            <artwork><![CDATA[
     DSUSRKName = 
          KDF(EMSKName,key label | "\0" | optional data | length)]]></artwork>

            <postamble/>
          </figure>
        </t>

        <t>where length is the 2 octet unsigned integer 8 in network byte order.</t>
     
      <section title="Applicability of Multi-Domain usages">
<t>When a DSRK is distributed to a domain the domain can generate any DSUSRKs it wishes.  This keys can be used to authorize entities in a domain to perform specific functions.  In cases where it is appropriate for only a specific domain to be authorized to perform a function the usage SHOULD NOT be defined as multi-domain.</t>

<t>In some cases only certain domains are authorized for a particular Multi-Domain usage.  In this case domains that do not have full authorization should not receive the DSRK and should only receive DSUSRKs for the usages which they are authorized.  If it is possible for a peer to know which domains are authorized for a particular usage without relying on restricting access to the DSRK to specific domains then this recommendation may be relaxed.</t>
      </section>
      </section>

    <section anchor="usage" title="Requirements for Usage Definitions">
      <t>In order for a usage definition to meet the guidelines for USRK usage it must meet the
        following recommendations:</t>

      <t>
        <list style="symbols">
          <t>The usage must define if it is a domain enabled usage. </t>

          <t>The usage definition MUST NOT use the EMSK in any other way except to derive Root Keys
            using the key derivation specified in <xref target="keyframe"/> of this document. They
            MUST NOT use the EMSK directly.</t>

          <t>The usage definition SHOULD NOT require caching of the EMSK. It is RECOMMENDED that the
            Root Key derived specifically for the usage definition rather than the EMSK should be
            used to derive child keys for specific cryptographic operations.</t>

          <t>Usage definition MUST define distinct key labels and optional data used in the key
            derivation described in <xref target="keyframe"/>. Usage definitions are encouraged to
            use the key name described in <xref target="keyname"/> and include
            additional data in the optional data to provide additional entropy. </t>

          <t>Usage definitions MUST define the length of their Root Keys. It is RECOMMENDED that the
            Root Keys be at least as long as the EMSK (at least 64 octets).</t>

          <t>Usage definitions MUST define how they use their Root Keys. This includes aspects of
            key management covered in the next section on Root Key Management guidelines.</t>

          <t/>
        </list>
      </t>

      <section title="Root Key Management Guidelines">
        <t>This section makes recommendations for various aspects of key management of the Root Key
          including lifetime, child key derivation, caching and transport.</t>

        <t>It is RECOMMENDED that the Root Key is only used for deriving child keys. A usage definition
          must specify how and when the derivation of child keys should be done. It is RECOMMENDED
          that usages following similar considerations for key derivation are as outlined in this
          document for the Root Key derivation with respect to cryptographic separation and key
          reuse. In addition, usages should take into consideration the number of keys that will be
          derived from the Root Key and ensure that enough entropy is introduced in the derivation
          to support this usage. It is desirable that the entropy is provided by the two parties
          that derive the child key.</t>

        <t>Root Keys' lifetimes should not be more than that of the EMSK. Thus, when the EMSK expires, the Root Keys
          derived from it should be removed from use. If a new EMSK is derived from a subsequent EAP
          transaction then a usage implementation should begin to use the new Root Keys derived from
          the new EMSK as soon as possible. Whether or not child keys associated with a Root Key are
          replaced depends on the requirements of the usage definition. It is conceivable that some
          usage definition forces the child key to be replaced and others allow child keys to be
          used based on the policy of the entities that use the child key.</t>

        <t>Recall that the EMSK never leaves the EAP peer and server. That also holds true for some
          Root Keys; however, some Root Keys may be provided to other entities for child key
          derivation and delivery. Each usage definition specification will specify delivery caching
          and/or delivery procedures. Note that the purpose of the key derivation in <xref
            target="keyframe"/> is to ensure that Root Keys are cryptographically separate from each
          other and the EMSK. In other words, given a Root Key, it is computationally infeasible to
          derive the EMSK, any other Root Keys, or child keys associated with other Root Keys. In
          addition to the Root Key, several other parameters may need to be sent.</t>
        <t>
        Root Key names may be derived using the EAP Session ID, and thus the key name may need to be sent along
          with the key. When Root Keys are delivered to another entity, the EMSKname and the lifetime associated with
          the specific root keys MUST also be transported to that entity. Recommendations for
          transporting keys are discussed in <xref target="seckeydist">the security considerations
          </xref>.</t>

        <t>Usage definition may also define how keys are bound to particular entities. This
          can be done through the inclusion of usage parameters and identities in the child key
          derivation. Some of this data is described as "channel bindings" in <xref target="RFC3748"
          />.</t>
      </section>

      <t/>
    </section>

    <section anchor="reqeap" title="Requirements for EAP System">
      <t>The system that wishes to make use of EAP root keys derived from the EMSK must take certain
        things into consideration. The following is a list of these considerations:</t>

      <t>
        <list style="symbols">
          <t>The EMSK MUST NOT be used for any other purpose than the key derivation described in
            this document.</t>

          <t>The EMSK MUST be secret and not known to someone observing the authentication mechanism
            protocol exchange.</t>

          <t>The EMSK MUST be maintained within a protected location inside the entity where it is
            generated. Only root keys derived according to this specification may be exported from
            this boundary.</t>

          <t>The EMSK MUST be unique for each EAP session</t>

          <t>The EAP method MUST provide an identifier for the EAP transaction that generated the
            key</t>

          <t>The system MUST define which usage definitions are used and how they are invoked.</t>

          <t>The system may define ways to select an alternate PRF for key derivation as defined in
              <xref target="KDF"/>.</t>
        </list>
      </t>

      <t>The system MAY use the MSK transmitted to the NAS in any way it chooses. This is required
        for backward compatibility. New usage definitions following this specification MUST NOT use
        the MSK. If more than one usage uses the MSK, then the cryptographic separation is not
        achieved. Implementations MUST prevent such combinations.</t>
    </section>

    <section title="Security Considerations">
      <section title="Key strength">
        <t>The effective key strength of the derived keys will never be greater than the strength of
          the EMSK (or a master key internal to an EAP mechanism).</t>
      </section>

      <section title="Cryptographic separation of keys">
        <t>The intent of the KDF is to derive keys that are cryptographically separate: the
          compromise of one of the usage specific root keys (USRKs) should not compromise the
          security of other USRKs or the EMSK. It is believed that the KDF chosen provides the
          desired separation.</t>
      </section>

      <section title="Implementation">
        <t>An implementation of an EAP framework should keep the EMSK internally as close to where
          it is derived as possible and only provide an interface for obtaining Root Keys. It may
          also choose to restrict which callers have access to which keys. A usage definition MUST
          NOT assume that any entity outside the EAP server or EAP peer EAP framework has access to
          the EMSK. In particular it MUST NOT assume that a lower layer has access to the EMSK.</t>
      </section>

      <section anchor="seckeydist" title="Key Distribution">
        <t>In some cases it will be necessary or convenient to distribute USRKs from where they are
          generated. Since these are secret keys they MUST be transported with their integrity and
          confidentiality maintained. They MUST be transmitted between authenticated and authorized
          parties. It is also important that the context of the key usage be transmitted along with
          the key. This includes information to identify the key and constraints on its usage such
          as lifetime.</t>

        <t>This document does not define a mechanism for key transport. It is up to usage
          definitions and the systems that use them to define how keys are distributed. Usage
          definition designers may enforce constraints on key usage by various parties by deriving a
          key hierarchy and by providing entities only with the keys in the hierarchy that they
          need.</t>
      </section>

      <section title="Key Lifetime">
        <t>The key lifetime is dependent upon how the key is generated and how the key is used.
          Since the Root Key is the responsibility of the usage definition it must determine how
          long the key is valid for. If key lifetime or key strength information is available from
          the authenticated key exchange then this information SHOULD be used in determining the
          lifetime of the key. If possible it is recommended that key lifetimes be coordinated
          throughout the system. Setting a key lifetime shorter that a system lifetime may result is
          keys becoming invalid with no convenient way to refresh them. Setting a key lifetime to
          longer may result in decreased security since the key may be used beyond its recommended
          lifetime.</t>
      </section>

      <section title="Entropy consideration">
        <t>The number of root keys derived from the EMSK is expected to be low. Note that there is
          no randomness required to be introduced into the EMSK to root key derivation beyond the
          root key labels. Thus, if many keys are going to be derived from an Root Key it is
          important that Root Key to child key derivation introduce fresh random numbers in deriving
          each key.</t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>The keywords "PRIVATE USE", "SPECIFICATION REQUIRED" and "IETF CONSENSUS" that appear in
        this document when used to describe namespace allocation are to be interpreted as described
        in <xref target="RFC2434"/>.</t>

      <section title="Key Labels">
        <t>This specification introduces a new name space for "USRK key labels". Key labels are of
          one of two formats: "label-string" or "label-string@specorg" (without the double quotes).</t>

        <t>Labels of the form "label-string" registered by the IANA MUST be printable US-ASCII
          strings, and MUST NOT contain the characters at-sign ("@"), comma (","), whitespace,
          control characters (ASCII codes 32 or less), or the ASCII code 127 (DEL). Labels are
          case-sensitive, and MUST NOT be longer than 64 characters. Labels of this form are
          assigned based on the IETF CONSENSUS policy.</t>

        <t>Labels with the at-sign in them of the form "label-string@specorg" where the part
          preceding the at-sign is the label. The format of the part preceding the at-sign is not
          specified; however, these labels MUST be printable US-ASCII strings, and MUST NOT contain
          the comma character (","), whitespace, control characters (ASCII codes 32 or less), or the
          ASCII code 127 (DEL). They MUST have only a single at-sign in them. The part following the
          at-sign MUST be a valid, fully qualified Internet domain name <xref target="RFC1034"/>
          controlled by the person or organization defining the label. Labels are case-sensitive,
          and MUST NOT be longer than 64 characters. It is up to each organization how it manages its
          local namespace. Note that the total number of octets in a label is limited to 255. It has
          been noted that these labels resemble STD 11 <xref target="RFC0822"/> addresses and
          network access identifiers (NAI) defined in <xref target="RFC4282"/>. This is purely
          coincidental and has nothing to do with STD 11 <xref target="RFC0822"/> or <xref
            target="RFC4282"/>. An example of a key label is "service@example.com"
          (without the double quotes).</t>

        <t>Labels within the "ietf.org" organization are assigned based on the IETF CONSENSUS policy with
          specification recommended. Labels from other organizations may be registered with IANA by the
          person or organization controlling the domain with an assignment policy of SPECIFICATION
          REQUIRED. It is RECOMMENDED that the specification contain the following information:</t>
        
        <t>The following labels are reserved by this document: "EMSK", "dsrk@ietf.org".</t>

        <t>
          <list style="symbols">
            <t>A description of the usage</t>

            <t>The key label to be used</t>

            <t>Length of the Root Key</t>

            <t>If optional data is used, what it is and how it is maintained</t>

            <t>How child keys will be derived from the Root Key and how they will be used</t>

            <t>How lifetime of the Root Key and its child keys will be managed</t>

            <t>Where the Root Keys or child keys will be used and how they are communicated if
              necessary</t>
          </list>
        </t>
      </section>

      <section title="PRF numbers">
        <t>This specification introduces a new number space for "EMSK PRF numbers". The numbers are
          int he range 0 to 255 Numbers from 0 to 220 are assigned through the policy IETF CONSENSUS
          and numbers in the range 221 to 255 are left for PRIVATE USE. The initial registry should
          contain the following values:</t>

        <t>
          <list>
            <t>0 RESERVED</t>

            <t>1 HMAC-SHA-256 PRF+ (Default)</t>
          </list>
        </t>
      </section>

      <t/>
    </section>

    <section title="Acknowledgements">
      <t>This document expands upon previous collaboration with Pasi Eronen. This document reflects
        conversations with Bernard Aboba, Jari Arkko, Avi Lior, David McGrew, Henry Haverinen, Hao
        Zhou, Russ Housley, Glen Zorn, Charles Clancy, Dan Harkins, Alan DeKok, Yoshi Ohba and members of the EAP and
        HOKEY working groups.</t>
      <t>Thanks to Dan Harkins for the idea of using a single root key name to refer to all keys.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References"> &rfc2119; &rfc2434; &rfc3748;
      &rfc4306; <reference anchor="SHA256">
        <front>
          <title>Secure Hash Standard</title>

          <author>
            <organization>National Institute of Standards and Technology</organization>
          </author>

          <date month="August" year="2002"/>
        </front>

        <seriesInfo name="FIPS" value="180-2"/>

        <annotation>With Change Notice 1 dated February 2004</annotation>
      </reference>
    </references>

    <references title="Informative References"> &rfc4346; &rfc1034; &rfc0822;
      &rfc4282; &ietf-eap-keying; <reference anchor="SIGMA">
        <front>
          <title>SIGMA: the 'SIGn-and-MAc' Approach to Authenticated Diffie-Hellman and its Use in
            the IKE Protocols</title>

          <author initials="H" surname="Krawczyk">
            <organization/>
          </author>

          <date year="2003"/>
        </front>

        <seriesInfo name="LNCS" value="2729"/>

        <seriesInfo name="" value="Springer"/>

        <format target="http://www.informatik.uni-trier.de/~ley/db/conf/crypto/crypto2003.html"
          type="HTML"/>

        <annotation>Available at
          http://www.informatik.uni-trier.de/~ley/db/conf/crypto/crypto2003.html</annotation>
      </reference>
    </references>
  </back>
</rfc>
