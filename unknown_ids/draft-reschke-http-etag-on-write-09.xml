<?xml version="1.0" encoding="UTF-8"?>
<!--
    This XML document is the output of clean-for-DTD.xslt; a tool that strips
    extensions to RFC2629(bis) from documents for processing with xml2rfc.
-->
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?><!--<!DOCTYPE rfc SYSTEM "rfc2629.dtd">-->
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc subcompact="no"?>
<!DOCTYPE rfc
  PUBLIC "" "rfc2629.dtd">
<rfc ipr="trust200902" docName="draft-reschke-http-etag-on-write-09" category="exp" updates="2616">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
	<front>
  <title abbrev="HTTP ETag Header in Write Operations">The Hypertext Transfer Protocol (HTTP)
  Entity Tag ("ETag") Response Header in Write Operations</title>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <phone>+49 251 2807760</phone>	
      <email>julian.reschke@greenbytes.de</email>	
      <uri>http://greenbytes.de/tech/webdav/</uri>	
    </address>
  </author>

  <date month="March" year="2009"/>
  
  <abstract>
    <t>
      The Hypertext Transfer Protocol (HTTP) specifies a state identifier,
      called "Entity Tag", to be returned in the "ETag" response header.  However,
      the description of this header for write operations
      such as PUT is incomplete, and has caused confusion among developers and
      protocol designers, and potentially interoperability problems.
    </t>
    <t>
      This document explains the problem in detail and suggests both a 
      clarification for a revision to the HTTP/1.1 specification (RFC2616) and a new header for use in responses,
      making HTTP entity tags more useful for user agents that want to avoid
      round-trips to the server after modifying a resource.
    </t>
  </abstract>
  
  <note title="Editorial Note (To be removed by RFC Editor before publication)">
    <t>
      Distribution of this document is unlimited. Please send comments to the 
      Hypertext Transfer Protocol (HTTP) mailing list at <eref target="mailto:ietf-http-wg@w3.org">ietf-http-wg@w3.org</eref>, which may be joined by sending a message with subject 
      "subscribe" to <eref target="mailto:ietf-http-wg-request@w3.org?subject=subscribe">ietf-http-wg-request@w3.org</eref>.
    </t>
    <t>
      Discussions of the HTTP working group are archived at
      <eref target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.               
    </t> 
    <t>
      XML versions, latest edits and the issues list for this document
      are available from <eref target="http://greenbytes.de/tech/webdav/#draft-reschke-http-etag-on-write"/>.
    </t>
  </note>
  </front>

  <middle>



<section title="Introduction" anchor="introduction">
  <t>
    The Hypertext Transfer Protocol (HTTP) specifies a state identifier,
    called "Entity Tag", to be returned in the "ETag" response header (see
    <xref target="RFC2616"/>, Section 14.19).  However,
    the description of this header for write operations
    such as PUT is incomplete, and has caused confusion among developers and
    protocol designers, and potentially interoperability problems.
  </t>
  <t>
    This document explains the problem in detail and suggests both a 
    clarification for a revision to <xref target="RFC2616"/> 
    and a new header for use in responses, making HTTP entity tags more useful for user agents that want to avoid
    round-trips to the server after modifying a resource. 
  </t>

<section title="Questions out of Scope">
  <t>
    Note that there is a related problem: modifying content-negotiated
    resources.  Here the consensus seems to be simply not to do it. Instead,
    the origin server should reveal specific URIs of content that is not
    content-negotiated in the Content-Location response header (<xref target="RFC2616"/>, Section 14.14), and user
    agents should use this more specific URI for authoring. Thus, the remainder
    of this document will focus on resources for which no content negotiation
    takes place.
  </t>
  <t>
    Another related question is the usability of the weak entity tags for
    authoring (see <xref target="RFC2616"/>, Section 13.3.3). Although
    this document focuses on the usage of strong entity tags, it is believed
    that the changes suggested in this document could be applied to weak
    entity tags as well.
  </t>
</section>

<section title="The Interoperability Problem" anchor="problem">
  <t>
    For a long time, nobody realized that there was a problem at all, or
    those who realized preferred to ignore it.     
  </t>
  <t>
    Server implementers added code that would return the new value of the
    "ETag" header in a response to a successful PUT request. After all, the client
    could be interested in it.
  </t>
  <t>
    User agent developers in turn were happy to get a new "ETag" value, saving
    a subsequent HEAD request to retrieve the new entity tag.
  </t>
  <t>
    However, at some point of time, potentially during a Web Distributed
    Authoring and Versioning (WebDAV, <xref target="RFC2518"/>, obsoleted by <xref target="RFC4918"/>) interoperability
    event, client programmers asked server programmers to always return "ETag" headers
    upon PUT, never ever to change the entity tag without "good reason", and
    - by the way - always to guarantee that the server stores the new content
    octet-by-octet. 
  </t>
  <t>
    From the perspective of client software that wants to treat an HTTP 
    server as a file system replacement, this makes a lot of sense. After all,
    when one writes to a file one usually expects the file system to
    store what was written, and not to unexpectedly change the contents.
  </t>
  <t>
    However, in general, an HTTP server is not a file system replacement. There
    may be some that have been designed that way, and some that expose some
    parts of their namespace that have this quality.
    But in general, HTTP server implementers have a lot of freedom in how 
    resources are implemented. Indeed, this flexibility is one of the reasons
    for HTTP's success, allowing it to be used for a wide range of tasks, of which
    replacing file systems is just one (and not necessarily the most
    interesting one).
  </t>
  <t>
    In particular:
    <list style="symbols">
      <t>
      A server may not store a resource as a binary object - in this case,
      the representation returned in a subsequent GET request may just
      be similar, but not identical to what was written. Good examples
      are servers that use HTTP to access XML data (<xref target="RFC4825"/>),
      Calendaring data (<xref target="RFC4791"/>) or newsfeed data
      (<xref target="RFC5023"/>).
      </t>
      <t>
      A server may change the data being written on purpose, while it is
      being written. Examples that immediately come to mind are keyword
      substitution in a source control system, or filters that remove
      potentially insecure parts out of HTML pages.
      </t>
    </list>
  </t>
  <t>
    Furthermore:
    <list style="symbols">
      <t>
      An "unrelated" method such as WebDAV's PROPPATCH (see <xref target="RFC4918"/>, Section 9.2)
      may affect the entity body and therefore the entity tag in an
      unexpected way, because the server stores some or all of the WebDAV
      properties inside the entity body (for instance, GPS information inside a
      JPG image file).
      </t>
    </list>
  </t>
  <t>
    As long as servers store the content octet-by-octet, and return exactly
    what the client wrote, there is no problem at all.
  </t>
  <t>
    Things get more interesting when a server does change the content,
    such as in the "simple authoring" example given in <xref target="simple.authoring"/>.
    Here, the server does change the content upon writing to the resource,
    yet no harm is done, because the final state of the resource on the
    server does not depend on the client being aware of that.
  </t>
  <t>
    All of the content rewriting examples mentioned above have this quality:
    the client can safely continue to edit the entity it sent, because
    the result of the transformation done by the server will be the same
    in the end. Formally, if we call the server-side transformation "t", the
    initial content "c", and the client-side editing steps "e1" and "e2",
    then
  </t>
  <figure>
    <artwork type="text/plain"><![CDATA[
t(e2(e1(c))) = t(e2(t(e1(c))))
]]></artwork>
    <postamble>
      e.g., it is irrelevant whether the client obtained the current entity
      body before doing its second edit.
    </postamble>
  </figure>
  <t>
    <cref source="julian.reschke@greenbytes.de" anchor="example.for.non.safe.rewrite">
    Question: does anybody know a real-world example for server-side content
    rewriting where the above is not true?</cref>
  </t>
  <t>
    Problems will only occur if the client uses the entity body it sent,
    and the entity tag it obtained
    in return, in subsequent requests that only transfer part of the 
    entity body, such as GET or PUT requests using the "Range" request header
    (see <xref target="RFC2616"/>, Section 14.35).
  </t>
  <t>
    Furthermore, some clients need to expose the actual contents to the end user.
    These clients will have to ensure that they really have the current
    representation. 
  </t>
  <t>
    Entity bodies (and thus entity tags) changing due to side effects of
    seemingly unrelated requests are indeed a problem, as demonstrated in
    <xref target="setting.both.content.and.metadata"/>, and this specification
    proposes a way to resolve this in <xref target="clarifications"/>.
  </t>
  
</section>
  
<section title="Analysis of RFC2616's Definitions" anchor="rfc2616.definitions">
  <t>
    There are several places in the HTTP/1.1 specification (<xref target="RFC2616"/>) 
    mentioning the "ETag" response header. 
  </t>
  <t>
    Let us start with the header definition in Section 14.19:
  </t>
  <t><list>
    <t>
      The ETag response-header field provides the current value of the entity
      tag for the requested variant. Sections 14.24, 14.26 and 14.44
      describe the headers used with entity tags. The entity tag MAY be
      used for comparison with other entities from the same resource (see
      Section 13.3.3).
    </t>
  </list></t>
  <t>
    The meaning of a "response-header" in turn is defined in Section 6.2:
  </t>
  <t><list>
    <t>
      The response-header fields allow the server to pass additional information
      about the response which cannot be placed in the Status-Line. These header
      fields give information about the server and about further access to the
      resource identified by the Request-URI.
    </t>
  </list></t>
  <t>
    The "ETag" response header itself is mentioned mainly in the context
    of cache validation, such as in Section 13.3.2.
    What is missing is a coherent description on how the origin server can notify the
    user-agent when the entity tag changes as result of a write operation, such 
    as PUT.
  </t>
  <t>
    Indeed, the definition of the 201 Created status code mentions entity tags (Section 10.2.2):
  </t>
  <t><list>
    <t>
      A 201 response MAY contain an ETag response header field indicating the
      current value of the entity tag for the requested variant just created,
      see Section 14.19.
    </t>
  </list></t> 
  <t>
    The "ETag" response header is mentioned again in the definition of
    206 Partial Content (Section 10.2.7)
    and 304 Not Modified (Section 10.3.5),
    but notably missing are statements about other 2xx series status codes
    that can occur upon a successful PUT operation, such as 200 OK (Section 10.2.1)
    and 204 No Content (Section 10.2.5).
  </t>
  <t>
    Summarizing, the specification is a bit vague about what an ETag
    response header upon a write operation means,
    but this problem is somewhat mitigated by the precise definition
    of a response header. A proposal for enhancing <xref target="RFC2616"/>
    in this regard is made in <xref target="clarifications"/> below.
  </t>
</section>
  
<section title="Prior Work">
<t>
  While working on the revision of <xref target="RFC2518"/>, the IETF WebDAV
  working group realized that this is a generic problem that needs attention
  independently of WebDAV. An initial attempt was made with
  <xref target="draft-whitehead-http-etag"/> in February 2006, but no
  progress was made since.
</t>
<t>
  Since then, two specifications based on HTTP
  were just published by the RFC Editor, taking two opposite approaches:

  <list style="symbols">
    <t>Section 8.5 of <xref target="RFC4825"/> makes it a MUST-level
    requirement to return an entity tag upon PUT, even though the very nature of
    an XCAP server will cause it to rewrite contents (due to its XML-based
    storage).
    </t>
    <t>Section 5.3.4 of <xref target="RFC4791"/> explicitly forbids
    ("MUST NOT") returning an entity tag upon PUT if the content was rewritten.
    </t>
  </list>
</t>
<t>
  In essence, this makes it impossible to implement an HTTP resource that
  conforms to both specifications. Due to the differing use cases of XCAP and CalDAV,
  this may not be a problem in practice, but the disagreement in itself is
  scary. Publication of these specifications on the standards track will
  make it much harder for future protocols to deal with this topic in a 
  meaningful way (comments were sent during IETF Last Call for CalDAV,
  see <eref target="http://www1.ietf.org/mail-archive/web/ietf/current/msg43021.html"/>).
</t>

</section>
  
</section>

<section title="Notational Conventions" anchor="notational.conventions">
  <t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL-NOT", "SHOULD",
    "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
    interpreted as described in <xref target="RFC2119"/>. 
  </t>
  <t>
    The terminology used here follows and extends that in the HTTP specification
    <xref target="RFC2616"/>, notably the augmented Backus-Naur Form (BNF) defined
    in Section 2.1 of that document.
  </t>
</section>

<section title="Clarifications on the Behavior of the 'ETag' Response Header" anchor="clarifications">
<t>
  This section describes a minimal change to <xref target="RFC2616"/>, proposed
  in <eref target="http://lists.w3.org/Archives/Public/ietf-http-wg/2006JanMar/0003.html"/>.
</t>
<t>
  At the end of Section 10.2 of <xref target="RFC2616"/>, add:
</t>
<t><list>
<t>
  The response MAY contain an ETag response header field indicating the
  current value of the entity tag (Section 14.19) for the requested
  variant.  The value SHOULD be the same as the one returned upon a
  subsequent HEAD request addressing the same variant.
</t>
</list></t>
<t>
  In Section 10.2.1 of <xref target="RFC2616"/>, remove:
</t>
<t><list>
<t>
   A 201 response MAY contain an ETag response header field indicating
   the current value of the entity tag for the requested variant just
   created, see Section 14.19.
</t>
</list></t>
<t>
  In essence, this moves the statement about entity tags in write operations
  from the specific case of status 201 Created into the more generic
  description of the 2xx series status codes.
</t>
<t>
  
  Note that the term "requested variant" is somewhat misleading, in particular
  in the context of write operations (see 
  <eref target="http://www.tools.ietf.org/wg/httpbis/trac/ticket/69"/>
  on the RFC2616bis issues list).
  
</t>
</section>


<section title="The 'Entity-Transform' Header" anchor="header.entity-transform">
<t>
  The 'Entity-Transform' entity header provides information about whether a 
  transformation has been applied to an entity body.
</t>
<t>
  When used in an HTTP request, its meaning is undefined. In an HTTP response,
  it provides information whether the server has applied a transformation
  when the entity was stored last.
</t>
<t>
  In general, entity headers may be stored in intermediates. The main use
  of this header however applies to the HTTP PUT method, of which by default
  the results are not cacheable (see <xref target="RFC2616"/>, Section 9.6).
  In addition, the value format is defined so that a client can reliably
  detect whether the information is fresh.
</t>
<figure>
  <preamble>Format:</preamble>
<artwork type="abnf2616"><![CDATA[
Entity-Transform = "Entity-Transform" ":" entity-transform-spec
entity-transform-spec = entity-transform-keyword SP entity-tag
entity-transform-keyword = "identity" | "unspecified"| token

entity-tag = <entity-tag: defined in [RFC2616], Section 3.11>
token = <token: defined in [RFC2616], Section 2.2>
]]></artwork></figure>  
<t>
  The entity-tag specifies the entity body to which this information applies.
</t>
<t>
  An entity-transform-keyword of "identity" specifies that the origin server has stored the
  entity octet-by-octet, thus the user agent MAY use a local copy of the entity body
  with the given entity-tag for subsequent requests that rely on octet-by-octet identity (such
  as a PUT with "Range" request header).
</t>
<t>
  Both the absence of this response header and any entity-transform-keyword value other than "identity"
  specify that the origin server may have transformed the entity before
  storage, thus a subsequent retrieval will not necessarily return an exact
  copy of the submitted entity.
</t>
<t><list><t>
  Note: usage of keywords other than "identity" or "unspecified" is
  reserved for future revisisions of this specification.
</t>

<t>
  Further note that the definition of the "identity" keyword is independant
  of the type of entity-tag. Thus, when "identity" is returned with a weak
  entity-tag, the client can indeed rely on octet-by-octet identity.
</t>

</list></t>

<section title="Examples">
<figure><preamble>Content was stored octet-by-octet:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
ETag: "1"
Entity-Transform: identity "1"
]]></artwork></figure>

<figure><preamble>Content was transformed:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
ETag: "2"
Entity-Transform: unspecified "2"
]]></artwork></figure>

<figure><preamble>Response containing a stale "Entity-Transform" header:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
ETag: "3"
Entity-Transform: unspecified "2"
]]></artwork>
<postamble>Note that in this case the newly assigned entity tag and the
entity tag returned in "Entity-Transform" do not match, thus the client is
aware that the header value is stale and can't be used.</postamble>
</figure>

</section>
</section>



<section title="How This Helps">
<t>
  The clarification of <xref target="RFC2616"/> (see <xref target="clarifications"/>)
  makes it clear that user agents can use "ETag" headers obtained in write
  operations, as long as they do not require octet-by-octet identity.  In
  particular, a new entity tag can be returned for any method, such
  as a WebDAV PROPPATCH (see <xref target="RFC4918"/>, Section 9.2).
  This helps dealing with the problem described in <xref target="setting.both.content.and.metadata"/>.
  See <xref target="setting.both.content.and.metadata.new.style"/> for details.
</t>
<t>
  The addition of the "Entity-Transform" header (see <xref target="header.entity-transform"/>)
  enables origin servers to signal that they stored an exact copy of the
  content, thus allowing clients not to refetch the content. Note that by
  default (in absence of the response header), a client can not make any
  assumptions about the server's behavior in this regard.  Thus clients will
  only benefit from new servers explicitly setting the new header.
</t>
</section>

<section title="IANA Considerations">
<t>
  This document specifies the new HTTP header listed below.
</t>
<t>
<list style="hanging">
  <t hangText="Header field name:">Entity-Transform</t>
  <t hangText="Applicable protocol:">http</t>
  <t hangText="Status:">informational</t>
  <t hangText="Author/Change controller:">IETF</t>
  <t hangText="Specification document:"><xref target="header.entity-transform"/> of this specification</t>
</list></t>
</section>

<section title="Security Considerations">
<t>
  This specification introduces no new security considerations beyond those
  discussed in Section 15 of <xref target="RFC2616"/>.
</t>
</section>
<!--
<ed:replace ed:resolves="edit" datetime="2006-11-04"><ed:ins>
<section title="Acknowledgments">
<t>
  <cref>TODO.</cref>
</t>
</section>
</ed:ins></ed:replace>
-->
  </middle>

  <back>
    <references title="Normative References">
    


<reference anchor="RFC2119">
  <front>
    <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
    <organization>Harvard University</organization>
    <address>
      <email>sob@harvard.edu</email>
    </address></author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>
    
    </references>
    
<references title="Informative References">
<reference anchor="RFC2518">
  <front>
    <title>HTTP Extensions for Distributed Authoring -- WEBDAV</title>
    <author initials="Y." surname="Goland" fullname="Y. Goland">
      <organization>Microsoft Corporation</organization>
      <address><email>yarong@microsoft.com</email></address>
    </author>
    <author initials="E." surname="Whitehead" fullname="E. J. Whitehead, Jr.">
      <organization abbrev="UC Irvine">Dept. Of Information and Computer Science, University of California, Irvine</organization>
    	<address><email>ejw@ics.uci.edu</email></address>
    </author>
    <author initials="A." surname="Faizi" fullname="A. Faizi">
      <organization abbrev="Netscape">Netscape</organization>
      <address><email>asad@netscape.com</email></address>
    </author>
    <author initials="S.R." surname="Carter" fullname="S. R. Carter">
      <organization abbrev="Novell">Novell</organization>
      <address><email>srcarter@novell.com</email></address>
    </author>
    <author initials="D." surname="Jensen" fullname="D. Jensen">
      <organization abbrev="Novell">Novell</organization>
      <address><email>dcjensen@novell.com</email></address>
    </author>
    <date month="February" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2518"/>
</reference>



  <reference anchor="RFC4791">
    <front>
      <title abbrev="CalDAV">Calendaring Extensions to WebDAV (CalDAV)</title>
      <author initials="C." surname="Daboo" fullname="Cyrus Daboo">
        <organization abbrev="Apple">Apple Inc.</organization>
        <address>
          <postal>
            <street>1 Infinite Loop</street>
            <city>Cupertino</city>
            <region>CA</region>
            <code>95014</code>
            <country>USA</country>
          </postal>
          <email>cyrus@daboo.name</email>
          <uri>http://www.apple.com/</uri>
        </address>
      </author>
      <author initials="B." surname="Desruisseaux" fullname="Bernard Desruisseaux">
        <organization abbrev="Oracle">Oracle Corporation</organization>
        <address>
          <postal>
            <street>600 Blvd. de Maisonneuve West</street>
            <street>Suite 1900</street>
            <city>Montreal</city>
            <region>QC</region>
            <code>H3A 3J2</code>
            <country>CANADA</country>
          </postal>
          <email>bernard.desruisseaux@oracle.com</email>
          <uri>http://www.oracle.com/</uri>
        </address>
      </author>
      <author initials="L.M." surname="Dusseault" fullname="Lisa Dusseault">
        <organization abbrev="CommerceNet">CommerceNet</organization>
        <address>
          <postal>
            <street>169 University Ave.</street>
            <city>Palo Alto</city>
            <region>CA</region>
            <code>94301</code>
            <country>USA</country>
          </postal>
          <email>ldusseault@commerce.net</email>
          <uri>http://commerce.net/</uri>
        </address>
      </author>
      <date month="March" year="2007"/>
    </front>
    <seriesInfo name="RFC" value="4791"/>
  </reference>


<reference anchor="HTML" target="http://www.w3.org/TR/html401/">
  <front>
    <title>HTML 4.01 Specification</title>
    <author initials="D." surname="Raggett" fullname="David Raggett">
      <organization>W3C</organization>
      <address>
        <email>dsr@w3.org</email>
      </address>
    </author>
    <author initials="A." surname="Hors" fullname="Arnaud Le Hors">
      <organization>W3C</organization>
    </author>
    <author initials="I." surname="Jacobs" fullname="Ian Jacobs">
      <organization>W3C</organization>
    </author>
    <date month="December" day="24" year="1999"/>
  </front>
  <seriesInfo name="W3C" value="REC-html401-19991224"/>
</reference>

<reference anchor="draft-whitehead-http-etag"> 
<front>
  <title abbrev="State Identifiers in HTTP/WebDAV">Design Considerations for State Identifiers in HTTP and WebDAV</title>

  <author initials="J." surname="Whitehead" fullname="Jim Whitehead">
    <organization abbrev="U.C. Santa Cruz">UC Santa Cruz, Dept. of Computer Science</organization>
    <address>
      <postal>
        <street>1156 High Street</street>
        <city>Santa Cruz</city>
        <region>CA</region>
        <code>95064</code>
      </postal>
      <email>ejw@cse.ucsc.edu</email>
    </address>
  </author>

  <date month="February" year="2006"/>
</front>
  <seriesInfo name="Internet-Draft" value="draft-whitehead-http-etag-00"/>
  <annotation>
    (Not updated since.)
  </annotation>
  
</reference>


<reference anchor="RFC4825">
<front>
<title>The Extensible Markup Language (XML) Configuration Access Protocol (XCAP)</title>
<author initials="J." surname="Rosenberg" fullname="Jonathan Rosenberg">
    <organization>Cisco Systems</organization>
    <address>
      <email>jdrosen@cisco.com</email>
    </address>
</author>
<date month="May" year="2007"/>
</front>
<seriesInfo name="RFC" value="4825"/>
</reference>

<reference anchor="RFC4918">
  <front>
    <title>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</title>
    <author initials="L." surname="Dusseault" fullname="Lisa Dusseault" role="editor">
      <organization>CommerceNet</organization>
      <address>
        <postal>
          <street>2064 Edgewood Dr.</street>
          <city>Palo Alto</city> <region>CA</region> <code>94303</code>
          <country>US</country>
        </postal>
        <email>ldusseault@commerce.net</email>
      </address>
    </author>
    <date month="June" year="2007"/>
  </front>
  <seriesInfo name="RFC" value="4918"/>
</reference>


<reference anchor="RFC5023">
  <front>
    <title>The Atom Publishing Protocol</title>
    <author role="editor" fullname="Joe Gregorio" surname="Gregorio" initials="J.C.">
      <organization>Google</organization>
      <address>
        <email>joe@bitworking.org</email>
        <uri>http://bitworking.org/</uri>
      </address>
    </author>
    <author role="editor" fullname="Bill de hOra" surname="de hOra" initials="B.">
      <organization>NewBay Software</organization>
      <address>
        <email>bill@dehora.net</email>
        <uri>http://dehora.net/</uri>
      </address>
    </author>
    <date month="October" year="2007"/>
  </front>
  <seriesInfo name="RFC" value="5023"/>
</reference>


</references>

<section title="Use Cases">
  <section title="Simple Authoring" anchor="simple.authoring">
  <t>
    Let us consider a server not having the quality of preserving octet-by-octet
    identity, for instance because
    of SVN-style keyword expansion in text content (<eref target="http://svnbook.red-bean.com/en/1.2/svn-book.html#svn.advanced.props.special.keywords"/>).
  </t>
  <t>
    In this case, the client has previously retrieved the representation for
    &lt;http://example.com/test&gt;, and the server has returned the ETag "1":
  </t>
  <figure>
    <preamble>
      &gt;&gt; Request (1)
    </preamble>
    <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
GET /test HTTP/1.1
Host: example.com]]></artwork>
  </figure>
  <figure>
    <preamble>
      &gt;&gt; Response (1)
    </preamble>
    <artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
Content-Type: text/plain
ETag: "1"

# $Revision: 1 $
Sample text.]]></artwork>
     </figure>
  <t>
    The client now wants to update the resource. To avoid overwriting
    somebody else's changes, it submits the PUT request with the HTTP
    "If-Match" request header (see <xref target="RFC2616"/>, Section 14.24):
  </t>
  <figure>
    <preamble>
      &gt;&gt; Request (2)
    </preamble>
    <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
PUT /test HTTP/1.1
Host: example.com
If-Match: "1"

# $Revision: 1 $
New sample text.]]></artwork>
  </figure>
  <t>
    If the resource was modified in the meantime, the server will reject
    the request with a 412 Precondition Failed status:
  </t>
  <figure>
    <preamble>
      &gt;&gt; Response (2a)
    </preamble>
    <artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 412 Precondition Failed
Content-Type: text/plain

Precondition Failed: entity tag supplied in If-Match request header
did not match current.
]]></artwork>
  </figure>
  <t>
    In this case, the client usually has take care of merging the changes
    made locally with those made on the server ("Merge Conflict").
  </t>
  <t>
    If there was no overlapping update, the server will execute the
    request and return a new entity tag:
  </t>
  <figure>
    <preamble>
      &gt;&gt; Response (2b)
    </preamble>
    <artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
Content-Type: text/plain
ETag: "2"]]></artwork>
  </figure>
  <figure>
    <preamble>
      Note however, that at this point the client knows the new entity tag,
      but doesn not know the current representation, which will have been
      updated by the server to:
    </preamble>
    <artwork type="text/plain"><![CDATA[
# $Revision: 2 $
New sample text.]]></artwork>
  </figure>
  <t>
    What seems to be a problem at first may not be a real problem in 
    practice. Let us assume that the client continues editing the resource,
    using the entity tag obtained from the previous request, but editing
    the entity it last sent:
  </t>
  <figure>
    <preamble>
      &gt;&gt; Request (3)
    </preamble>
    <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
PUT /test HTTP/1.1
Host: example.com
If-Match: "2"

# $Revision: 1 $
A third attempt.]]></artwork>
  </figure>
  <t>
    Assuming there was no overlapping update, the PUT request will succeed:
  </t>
  <figure>
    <preamble>
      &gt;&gt; Response (3)
    </preamble>
    <artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
Content-Type: text/plain
ETag: "3"]]></artwork>
  </figure>
  <t>
    Note that the only problem here is that the client doesn't have an exact
    copy of the entity it is editing. However, from the server's point of view
    this is entirely irrelevant, because the "Revision" keyword will be
    automatically updated upon every write anyway.
  </t>
  <t>
    In any case, the final contents will be:
  </t>
  <figure>
    <artwork type="text/plain"><![CDATA[
# $Revision: 3 $
A third attempt.]]></artwork>
  </figure>
  </section>
  

<section title="Simple Authoring, with Entity-Transform header">
  <t>
    In the example above (<xref target="simple.authoring"/>, Response 2b), the server
    returns an ETag response header upon PUT, although the content actually
    was rewritten due to keyword substitution.
  </t>
  <t>
    A server implementing this specification would instead respond with:
  </t>
  <figure>
    <preamble>
      &gt;&gt; Response (2c)
    </preamble>
    <artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
Content-Type: text/plain
ETag: "2"
Entity-Transform: unspecified "2"]]></artwork>
  </figure>
  <t>
    This indicates that the content that was sent is not
    octet-by-octet identical to what a subsequent GET request would retrieve.
    It is then up to the client to decide whether it wants to re-fetch the
    content before continuing edits.
  </t>
</section>


  <section title="Setting both Content and Metadata" anchor="setting.both.content.and.metadata">
  <t>
    In this example, the server exposes data extracted from the HTML
    &lt;title&gt; element (<xref target="HTML"/>, Section 7.4.2)
    as a custom WebDAV property (<xref target="RFC4918"/>, Section 4), 
    allowing both read and write access.
  </t>
  <t>
    In the first step, the client obtains the current representation for
    &lt;http://example.com/test.html&gt;:
  </t>
  <figure>
  <preamble>
    &gt;&gt; Request (1)
  </preamble>
  <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
GET /test.html HTTP/1.1
Host: example.com]]></artwork></figure>
  <figure>
  <preamble>
    &gt;&gt; Response (1)
  </preamble>
  <artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
Content-Type: text/html
ETag: "A"

<html>
  <head>
  </head>
  <body>
  </body>
</html>]]></artwork></figure>
    <t>
    Next, it adds one paragraph to the &lt;body&gt; element, and gets back
    a new entity tag:
  </t>
  <figure>
  <preamble>
    &gt;&gt; Request (2)
  </preamble>
  <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
PUT /test.html HTTP/1.1
Host: example.com
If-Match: "A"

<html>
  <head>
  </head>
  <body>
    <p>First paragraph.</p>
  </body>
</html>]]></artwork></figure>
  <figure>
  <preamble>
    &gt;&gt; Response (2)
  </preamble>
  <artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 200 OK
ETag: "B"]]></artwork></figure>

  <t>
    Next, the client sets a custom "title" property (see <xref target="RFC4918"/>, Section 9.2):
  </t>
  <figure>
  <preamble>
    &gt;&gt; Request (3)
  </preamble>
  <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
PROPPATCH /test.html HTTP/1.1
Host: example.com
Content-Type: application/xml

<proppatch xmlns="DAV:">
  <set>
    <prop>
      <title xmlns="http://ns.example.org/"
      >A sample document</title>
    </prop>
  </set>
</proppatch>]]></artwork></figure>
  <figure>
  <preamble>
    &gt;&gt; Response (3)
  </preamble>
  <artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 207 Multi-Status
Content-Type: application/xml

<multistatus xmlns="DAV:">
  <response>
    <href>/test.html</href>
    <propstat>
      <prop>
        <title xmlns="http://ns.example.org/"/>
      </prop>
      <status>HTTP/1.1 2OO OK</status>
    </propstat>
  </response>
</multistatus>]]></artwork></figure>

  <t>
    The server knows how to propagate property changes into the HTML
    content, so it updates the entity by adding an HTML title document
    accordingly. This causes the entity tag changing to "C".
  </t>
  <figure>
    <preamble>
    The new entity body is shown below, but the client does not
    realize that it did change at all.</preamble>
    <artwork type="text/plain"><![CDATA[
<html>
  <head>
    <title>A sample document</title>
  </head>
  <body>
    <p>First paragraph.</p>
  </body>
</html>]]></artwork>
  </figure>
  <t>
    A subsequent attempt by the client to update the entity body will fail,
    unless it realizes that changing WebDAV properties may affect the
    entity as well. In this case, it would have had to get the current
    entity tag before proceeding. Of course, this introduces an additional
    round-trip, and a timing window during which overlapping updates by
    other clients would go unnoticed.
  </t>

  <t><list><t>
    Note that a client would be affected by this behaviour even in the
    presence of an exclusive WebDAV write lock (see <xref target="RFC4918"/>, Section 7).
  </t></list></t>

</section>

  <section title="Setting both Content and Metadata, new style" anchor="setting.both.content.and.metadata.new.style">
  <t>
    Below we repeat the example from above (<xref target="setting.both.content.and.metadata"/>),
    but here the origin server returns entity tags for all write operations,
    and the user agent knows how to deal with them. That is, both take
    advantage of what <xref target="RFC2616"/> already allows.
  </t>
  <figure>
  <preamble>
    &gt;&gt; Request (3)
  </preamble>
  <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
PROPPATCH /test.html HTTP/1.1
Host: example.com
Content-Type: application/xml

<proppatch xmlns="DAV:">
  <set>
    <prop>
      <title xmlns="http://ns.example.org/">
        A sample document
      </title>
    </prop>
  </set>
</proppatch>]]></artwork></figure>
  <figure>
  <preamble>
    &gt;&gt; Response (3)
  </preamble>
  <artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
HTTP/1.1 207 Multi-Status
Content-Type: application/xml
ETag: "C"

<multistatus xmlns="DAV:">
  <response>
    <href>/test.html</href>
    <propstat>
      <prop>
        <title xmlns="http://ns.example.org/"/>
      </prop>
      <status>HTTP/1.1 2OO OK</status>
    </propstat>
  </response>
</multistatus>]]></artwork></figure>
  <t>
    As before, this causes the entity to change, and a new entity tag
    to be assigned. But in this case, the origin server actually
    notifies the client of the changed state by including the 
    "ETag" response header.
  </t>
  <t>
    The client now will be aware that the requested entity change, and can
    use the new entity tag in subsequent requests (potentially after
    refreshing the local copy).
  </t>
  
  </section>
</section>
    

<section title="Change Log (to be removed by RFC Editor before publication)">
<section title="Since draft-reschke-http-etag-on-write-00">
<t>
  Add and resolves issues "entity-header" and "extensibility", by removing
  the extension hooks, and by redefining the header to it can be used as an
  Entity header.
</t>
</section>


<section title="Since draft-reschke-http-etag-on-write-01">
<t>
  Update APP and CALDAV references. Remove RFC3986 reference (not needed anymore after
  the simplication in draft 01). Fix typo in header description ("submitted entity", not
  "stored entity"). Remove comparison about how XCAP and CALDAV profile
  RFC2616: after all, both mandate a behaviour that was legal but optional before.
  Add "Updates: RFC2616".
</t>
</section>


<section title="Since draft-reschke-http-etag-on-write-02">
<t>
  In the references, note that there was no activitiy on draft-whitehead-http-etag-00
  anymore. Change intended status to "Experimental". Update APP reference.
  Update statements about current status of XCAP and CALDAV.
  Add and resolve "clarify-extension".
</t>
</section>

<section title="Since draft-reschke-http-etag-on-write-03">
<t>
  Update XCAP reference. Update header definition to use prose rules
  rather than comments. Clarify "identity" keyword when appearing with 
  a weak entity-tag. In PROPPATCH/HTML example, fix whitespace so that
  the HTML title element has exactly the same value as the one that was
  PROPPATCHed. Mention that ETags changing due to a PROPPATCH could even
  occur in presence of a WebDAV write lock. Expand keyword substitution
  example with variant where Entity-Transform is returned.
</t>
</section>

<section title="Since draft-reschke-http-etag-on-write-04">
<t>
  Update APP reference. Update CalDAV reference (published as RFC4791).
  Update "prior work" (RFC4791 being published, XCAP having been approved).
</t>
</section>

<section title="Since draft-reschke-http-etag-on-write-05">
<t>
  Update XCAP reference (published as RFC4825).
  Update "prior work" (RFC4825 being published).
</t>
</section>

<section title="Since draft-reschke-http-etag-on-write-06">
<t>
  Replace RFC2518 references with RFC4918 where appropriate.
  Update APP reference.
</t>
</section>

<section title="Since draft-reschke-http-etag-on-write-07">
<t>
  Update APP reference.
  Reference the "requested variant" issue on the RFC2616bis issues list
  (<eref target="http://www.w3.org/Protocols/HTTP/1.1/rfc2616bis/issues/#i69"/>).
</t>
</section>

<section title="Since draft-reschke-http-etag-on-write-08">
<t>
  Update pointer to RFC2616bis "requested variant" issue.
</t>
</section>

</section>
    
    
  <section title="Open issues (to be removed by RFC Editor prior to publication)"><section title="edit"><t>
      Type: edit</t><t>julian.reschke@greenbytes.de (2006-08-10): 
    Umbrella issue for editorial fixes/enhancements.
  </t></section></section></back>
  
  
</rfc>