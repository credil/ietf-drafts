<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="no" ?>
<?rfc subcompact="no" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC1964 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1964.xml">
<!ENTITY RFC2865 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2865.xml">
<!ENTITY RFC2203 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2203.xml">
<!ENTITY RFC3588 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3588.xml">
<!ENTITY RFC3588 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3588.xml">
<!ENTITY RFC2743 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2743.xml">
<!ENTITY RFC3748 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3748.xml">
<!ENTITY RFC4462 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4462.xml">
<!ENTITY RFC4422 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4422.xml">
<!ENTITY RFC4282 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4282.xml">
<!ENTITY RFC5056 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5056.xml">
<!ENTITY RFC3645 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3645.xml">
<!ENTITY RFC4072 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4072.xml">
<!ENTITY RFC5801 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5801.xml">
<!ENTITY RFC2904 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2904.xml">
<!ENTITY RFC3579 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3579.xml">
<!ENTITY RFC2138 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2138.xml">
<!ENTITY I-D.nir-tls-eap SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.nir-tls-eap.xml">
<!ENTITY I-D.ietf-abfab-gss-eap SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-abfab-gss-eap.xml">
<!ENTITY I-D.hansen-privacy-terminology SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hansen-privacy-terminology.xml">
<!ENTITY SAML20 SYSTEM "http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml">
]>
<rfc category="info" docName="draft-lear-abfab-arch-01.txt" ipr="trust200902">
  <front>
    <title abbrev="ABFAB Architecture">Application Bridging for Federated Access Beyond Web (ABFAB) Architecture</title>

    <author initials="J." surname="Howlett" fullname="Josh Howlett">
      <organization>JANET(UK)</organization>
      <address>
        <postal>
          <street> </street>
          <city> </city>
          <code> </code>
          <country> </country>
        </postal>
        <phone> </phone>
        <email>Josh.Howlett@ja.net</email>
      </address>
    </author>
    <author initials="S." surname="Hartmann" fullname="Sam Hartman">
      <organization>Painless Security</organization>
      <address>
        <postal>
          <street> </street>
          <city> </city>
          <code> </code>
          <country> </country>
        </postal>
        <phone> </phone>
        <email>hartmans-ietf@mit.edu</email>
      </address>
    </author>
    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Nokia Siemens Networks</organization>
      <address>
        <postal>
          <street>Linnoitustie 6</street>
          <city>Espoo</city>
          <code>02600</code>
          <country>Finland</country>
        </postal>
        <phone>+358 (50) 4871445</phone>
        <email>Hannes.Tschofenig@gmx.net</email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>
    <author fullname="Eliot Lear" initials="E." surname="Lear">
      <organization>Cisco Systems GmbH</organization>
      <address>
        <postal>
          <street>Richtistrasse 7</street>
          <city>Wallisellen</city>
          <code>CH-8304</code>
          <region>ZH</region>
          <country>Switzerland</country>
        </postal>
        <phone>+41 44 878 9200</phone>
        <email>lear@cisco.com</email>
      </address>
    </author>
    <date year="2010"/>
    <area>Internet</area>
    <workgroup>ABFAB</workgroup>
    <keyword>Internet-Draft</keyword>
    <keyword>Federated Authentication</keyword>
    <keyword>AAA</keyword>
    <keyword>RADIUS</keyword>
    <keyword>Diameter</keyword>
    <keyword>GSS-API</keyword>
    <keyword>EAP</keyword>
    <keyword>SASL</keyword>
    <abstract>
<t>Over the last decade a substantial amount of work has occurred in
  the space of federated authentication and authorization.  Most of
  this effort has focused on two common use cases: network and
  web-based access, with few common building blocks within the
  architecture.  This memo describes an architecture that makes use of
  extensions to the commonly used mechanisms for both federated and
  non-federated authentication and authorization, including
  Radius/Diameter, GSS/GS2, and SAML, to primarily address non-web
  based authentication, in a that will scale to large numbers of
  federations.
</t>
    </abstract>
  </front>

  <middle>
    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="introduction" title="Introduction">
<t>XXX This document is a first draft.  Comments and contributions are
  requested.
</t>
<t>The Internet makes uses of numerous authentication methods to grant
access to various resources.  These mechanisms have been generalized
and scaled over the last decade through mechanisms such as
  GS2, <xref target="OASIS.saml-core-2.0-os">Security Assertion Markup Language (SAML)</xref>,
Radius, and Diameter.  So-called "federated" access has evolved over
the last decade between web servers through such standards as SAML,
OpenID, and OAUTH, allowing entire domains of individuals to be
authorized for resources.  The key scaling points that have been
addressed are the following:
<list style="symbols">
<t>An Internet service need not copy manually authentication
  information from a domain to allow for authentication and
  authorization.
</t>
<t>Individual users are able to make use of a single credential to
  authenticate to such services.
</t>
</list>
</t>
<t>As the number of such federated services has proliferated, however,
  the role of the individual has become ambiguous in certain
  circumstances.  For example, a school might provide online access to
  grades to a parent who is also a teacher.  She must
  clearly distinguish her role upon access.  After all, she is
  probably not allowed to edit her own child's grades.
</t>
<t>Similarly, as the number of federations proliferates, it becomes
  increasingly difficult to discover which identity provider a user is
  associated with.  This is true for both the web and non-web case,
  but particularly acute for the latter ans many non-web
  authentication systems are not semantically rich enough on their own
  to allow for such ambiguities.  For instance, in the case of an
  email provider, the use of SMTP and IMAP protocols does not on its
  own provide for a way to select a federation.  However, the building
  blocks do exist to add this functionality.
</t>
<section title="Federation Description">
      <t>The typical setup for a three party protocol involves the following entities:
      </t>
      <t>
      <list style="symbols">
      <t>the End Host,</t>
      <t>the Identity Provider, and </t>
      <t>the Relying Party.</t>
      </list>
      </t>
      <t>
      These entities are illustrated graphically in <xref
        target="framework"/>.
      </t>
      <t>
        <figure title="Three Party Authentication Framework" anchor="framework">
          <artwork><![CDATA[
                       -----
                     /-     -\
                   //         \\
                   /           \
                  |             |
 ,----------\    |               |   ,---------\
 | Identity |    |               |   | Relying |
 | Provider +----+   Federation  +---+ Party   |
 `----------'    |               |   '---------'
          <      |               |        >
           \      |             |        /
            \      \           /        /
             \     \\         //       /
             \       \-     -/        /
              \        -----         /
               \                    /
                \  +------------+  /
                 \ |            | /
                  v|  End Host  |v
                   |            |
                   +------------+
                   ]]></artwork>
        </figure>
      </t>
      <t><xref
        target="framework"/> also shows the logical entity
        'Federation'.  In a federation, policy is agreed upon by some
        form of administrative management, and then instantiated through an
        operational framework that the members use, and where
        compliance is measured in some fashion.  Some deployments
        may be required to deploy message routing intermediaries, such as application layer relays or proxies, to offer the required technical functionality while in other deployments those are missing.
      </t>

      <t>Often a real world entity is associated with the end host and
        responsible for interacting with the identity provider, even if it is
        only as weak as completing a web form and confirming the verification email. The outcome of
        this initial registration step is that credentials are made available to the identity
        provider and to the end host.
        It is important to highlight that in some
        scenarios there might indeed be a human behind the device denoted as end host and in other
        cases there is no human involved in the actual protocol execution.</t>

      <t>To support the more generic deployment case, we assume that the identity provider and the relying party belong to different
        administrative domains. The nature of federation dictates that there is some form of relationship between the identity
        provider and the relying party. This is particularly important when the relying party wants
        to use information obtained from the identity provider for authorization decisions and when
        the identity provider does not want to release information to every relying party (or only
        under certain conditions). While it is possible to have a bilateral agreement between every
        identity provider and every relying party; on an Internet scale this setup requires the introduction of a
        federation concept, as the management of such pair-wise
        relationships would otherwise prove burdensome.
        While many of the non-technical aspects of such a federation, such as business practices and operational arrangements, are outside the
        scope of the IETF they still impact the architecture setup on how to ensure the dynamic establishment of trust. </t>
<t>
The steps taken generally in an ABFAB federated authentication/authorization
exchange are as follows (XXX not complete):
</t>
<t>
<list style="numbers">
<t>Principal provides NAI to Application: Somehow the client is
  configured with at least the realm portion of 
  an NAI, which represents the IdP to be discovered.
</t>
<t>
Authentication mechanism selection: this is the step necessary to
indicate that the GSS-EAP SASL/GS2 mechanism will be used for
authentication/authorization.
</t>
<t>
Client Application provides NAI to RP: At the conclusion of mechanism
selection the NAI must be provided to the RP for discovery.
</t>
<t>
Discovery of federated IdP: 
This is discussed in detail below.  Either the RP is configured with
authorized IdPs, or it makes use of a federation proxy.
</t>
<t>
Request from Relying Party to IdP: Once the RP knows who the IdP is,
 it or its agent will forward RADIUS 
 request that encapsulates a GSS/EAP access request to an IdP.  This
 may or may not contain a SAML request as a series of attributes.. At
 this stage, the RP will likely  have no idea who the principal is.
 The RP claims its identity to the  IdP in AAA attributes.
</t>
<t>
IdP informs the principal of which EAP method to use: The available
and appropriate methods are discussed below in this memo.
</t>
<t>
A bunch of EAP messages happen between the endpoints: Messages are
exchanged between the principal and the IdP until a 
result is determined.  The number and content of those messages will
depend on the EAP method.  If the IdP is unable to authenticate the
principal, the process concludes here.  As part of this process, the
principal will, under protection of EAP, assert the identity of the
RP to which it intends to authenticate.
</t>
<t>
Successful Authentication: At the very least the EAP server / IdP has
authenticated the 
principal, and the principal has authenticated the IdP.  As a result
of this step, the principal and the EAP server hold two cryptographic
keys- a Master Session Key (MSK), and an Extended MSK (EMSK).  If the
asserted identity of the RP by the principal matches the identity the
RP itself asserted, there is some confidence that the RP is now
authenticated to the IdP.
</t>
<t> 
Local IdP Policy Check: At this stage, the IdP checks local policy to
determine whether the RP 
and principal are authorized for the assertion to be made.  Additional
policy checks will likely have been made earlier just through the
process of discovery (see later discussion).
</t>
<t>
Response from the IdP to the Relying Party: Once the IdP has made a
determination of whether and how to 
authenticate or authorize the principal to the RP, it returns either a
negative answer to the RP, or it returns the identity of the principal
to the RP, as well as an optional set of attributes associated with the
principal. XXX XXX XXX this needs work!!!
</t>
<t>
Return results to principal: Once the RP has a response it must inform
the client application of 
the result.  If all has gone well, all are authenticated, and the
application proceeds with appropriate authorization levels.
</t>
</list>
</t>
<t>
An example communication flow is given below:
</t>
<t>
 <figure>
 <artwork><![CDATA[
    Relying Party    Client App       IdP

       |              (1)             | Client App gets NAI (somehow)
       |               |              |
       |<-----(2)----->|              | Mechanism Selection
       |               |              |
       |<-----(3)-----<|              | NAI transmitted to RP
       |               |              |
       |<=====(4)====================>| Discovery
       |               |              |
       |>=====(5)====================>| Access request from RP to IdP
       |               |              |
       |               |< - - (6) - -<| EAP method to Principal
       |               |              |
       |               |< - - (7) - ->| EAP Exchange to authenticate
       |               |              | Principal
       |               |              |
       |               |           (8 & 9) Local Policy Check
       |               |              |
       |<====(10)====================<| IdP Assertion to RP
       |               |              |
       |>----(11)----->|              | Results to client app.



     ----- = Between Client App and RP
     ===== = Between RP and IdP
     - - - = Between Client App and IdP

]]>

</artwork></figure>
</t>
</section>
<section title="Design Goals">
<t>Our key design goals are as follows:</t>
<t>
<list style="symbols">
<t>Each party of a transaction will be authenticated, and the
  principal will be authorized for access to a specific resource .</t>
<t>Means of authentication is decoupled so as to allow for multiple
  authentication methods.</t>
<t>Hence, the architecture requires no sharing of long term private
  keys.</t>
<t>The system will scale to large numbers of identity providers,
  relying parties, and users.</t>
<t>The system will be designed primarily for non-Web-based
  authentication.</t>
<t>The system will build upon existing standards, components, and
  operational practices.
</t>
</list>
</t>
      <t>Designing new three party authentication and authorization
        protocols is hard and frought with risk of cryptographic
        flaws. Achieving widespead deployment is even more
        difficult. A lot of attention on federated access has been devoted to the Web. This document instead
        focuses on a non-Web-based environment and focuses on those protocols where HTTP is not
        used. Despite the increased excitement for layering every protocol on top of HTTP there are
        still a number of protocols available that do not use HTTP-based transports. Many of these
        protocols are lacking a native authentication and authorization framework of the style shown in
          <xref target="framework"/>.</t>
</section>
<section title="Use of Radius">
      <t>Interestingly, for network access authentication the usage of the AAA framework with RADIUS
          <xref target="RFC2865"/> and Diameter <xref target="RFC3588"/> was quite successful from a
        deployment point of view. To map the terminology used in <xref target="framework"/> to the
        AAA framework the identity provider corresponds to the AAA server, the relying party
        corresponds to the AAA client, and the technical building blocks of a federation are AAA proxies, relays
        and redirect agents
        (particularly if they are operated by third parties, such as AAA brokers and clearing
        houses). The front-end, i.e. the end host to AAA client communication, is in case of network
        access authentication offered by link layer protocols that forward authentication protocol
        exchanges back-and-forth.  An example of a large scale
          Radius-based federation
          is <eref target="http://www.eduroam.org">EDUROAM</eref>.</t>

      <t>Is it possible to design a system that builds on top of successful protocols to offer
        non-Web-based protocols with a solid starting point for authentication and authorization in
        a distributed system? </t>
</section>
    </section>


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="terminology" title="Terminology">

      <t>This document uses identity management and privacy terminology from <xref target="I-D.hansen-privacy-terminology"/>.</t>

    </section>


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Architecture">


      <t><xref target="introduction"/> already introduced the federated access architecture, with the illustration
       of the different actors that need to interact, but it did not expand on the specifics of providing support for non-Web based applications. This section details this aspect and motivates
      design decisions. The main theme of the work described in this document is focused on re-using existing building blocks that have been deployed already and to re-arrange them in a novel way.</t>


      <t>
        Although this architecture assumes updates to both the relying party as well as to the end host for application integration, those changes
        are kept at a minimum.  A mechanism that can
        demonstrate deployment benefits (based on ease of update of existing
        software, low implementation effort, etc.)is preferred and there may be a need
        to specify multiple mechanisms to support the range of different
        deployment scenarios.
        </t>

      <t>There are a number of ways for encapsulating EAP into an application protocol. For ease of integration with a wide range of non-Web based application protocols the usage of the GSS-API was chosen. Encapsulating EAP into the GSS-API also allows EAP to be used in SASL. A description of the technical specification can be found in <xref target="I-D.ietf-abfab-gss-eap"/>. Other alternatives exist as well and may be considered later, such as "TLS using EAP Authentication" <xref target="I-D.nir-tls-eap"/>.</t>
      <t>There are several architectural layers in the system; this section discusses the individual layers.</t>
      <section title="Federation Substrate">
	<t>The federation substrate is responsible for the connunication between the relying party and the identity provider. This layer is responsible for the inter-domain communication and for the technical mechanisms necessary to establish inter-domain trust.</t>
      <t>A key design goal is the re-use of an existing infrastructure,
      we build upon the AAA framework as utilized by RADIUS
      <xref target="RFC2138"/> and Diameter
      <xref target="RFC3588"/>. Since this document does not aim to
      re-describe the AAA framework the interested reader is referred
      to <xref target="RFC2904"/>. Building on the AAA infrastructure,
      and RADIUS and Diameter as protocols, modifications to that
      infrastructure is to be avoided. Also, modifications to AAA
      servers should be kept at a minimum.</t>
<t>One demand that the AAA substrate must make of the upper
  layers is that they must properly identify the end points of the
  communication.  That is-  it must be possible for the AAA server at
  the RP to determine where to send each radius or diameter message.
  Otherwise, it is the RP's responsibility to determine the identity
  of the principal on its own, without the assistance of an IdP.  This
  architecture makes use of the Network Access Identifier (NAI), where
  the IdP is indicated in the realm component <xref target="RFC4282"
  />.  The NAI is represented and consumed by the GSS-API
  layer as GSS_C_NT_USER_NAME as specified in <xref target="RFC2743"
  />. XXX Where is EAP here?
</t>
<t>Once an IdP has been determined by the RP, it or its proxy agent
  must determine whether or not the IdP itself is authorized to make
  assertions, as it will likely not blindly accept any old provider.
  Federations serve this purpose.  This architecture provides for
  three approaches to resolve whether an IdP is authorized:
</t>
<t>
<list style="hanging">
<t hangText="Static Configuration: ">
In this case, the federation provides the RP or its proxy agent with
a static list of IdPs that it may trust.
</t>
<t hangText="Federation Dynamic Referral">
In this case, the federation provides a proxy of its own that will
in some way authorize the IdP to the RP, and visa versa, as not all
RPs may be authorized to use all IdPs for all purposes within a
federation.  N.B., because the identity of the principal is likely
unknown at this point, it will not be possible for a federation to
authorize an IdP to an RP based on the identity of the principal.
</t>
<t hangText="Federation Proxy: ">
In this case, the authentication request is forwarded to a federation
proxy, who then further forwards the request to the IdP.
</t>
</list>
</t>
<t>
In the first two cases, it is expected that RPs will be configured to consult
multiple federations, as a matter of practice.  The first successful
query is sufficient for the RP to then contact the IdP's AAA server.
</t>

<t>The astute reader will notice that RADIUS and Diameter have
  substantially similar characteristics.  Why not pick one?  A key
  difference is that today RADIUS is largely transported upon UDP, and
  its use is largely, though not exclusively, intra-domain.  Diameter
  itself was designed to scale to broader uses.  We leave as a
  deployment decision, which protocol will be appropriate.
</t>
	<t>Through the integrity protection mechanisms in the AAA framework, the relying party can establish technical trust that messages are being sent by the appropriate relying party. Any given interaction will be associated with one federation at the policy level. The legal or business relationship defines what statements the identity provider is trusted to make and how these statements are interpreted by the relying party. The AAA framework also permits the relying party or elements between the relying party and identity provider to make statements about the relying party. </t>
	<t>The AAA framework provides transport for attributes. Statements made about the subject by the identity provider, statements made about the relying party and other information is transported as attributes.</t>

      </section>
      <section title="Subject To Identity Provider">
	<t>Traditional web federation does not describe how a subject
	communicates with an identity provider. As a result, this
	communication is not standardized. There are several
	disadvantages to this approach. It is difficult to have
	subjects that are machines rather than humans that use some
	sort of programatic credential. In addition, use of browsers
	for authentication restricts the deployment of more secure
	forms of authentication beyond plaintext username and password
	known by the server. In a number of cases the authentication
	interface may be presented before the subject has adequately
	validated they are talking to the intended server. By giving
	control of the authentication interface to a potential
	attacker, then the security of the system may be reduced and
	phishing opportunities introduced.</t>
	<t>As a result, it is desirable to choose some standardized
	approach for communication between the subject's end-host and
	the identity provider. There are a number of requirements this
	approach must meet.</t>
      <t>Experience has taught us one key security and scalability requirement:
        it is important that the relying party not get in possession of the
        long-term secret of the entity being authenticated by the AAA
        server. Aside from a valuable secret being exposed, a
        synchronization problem can also often develop.
Since there is
        no single authentication mechanism that will be used everywhere there is another associated
        requirement: The authentication framework must allow for the flexible integration of
        authentication mechanisms. For instance, some identity
        providers may require hardware tokens while others may use
        passwords.  A service provider would want to support both
        sorts of federations, and others.</t>

      <t>Fortunately, these requirements can be met by utilizing standardized and successfully deployed technology, namely by the Extensible Authentication
            Protocol (EAP) framework
            <xref target="RFC3748"/>.
      <xref
          target="abfab-arch"/> illustrates the integration graphically.</t>

<t>  EAP is an end-to-end framework; it provides for two-way
            communication between a peer (i.e,service client or
            principal) through the
            authenticator (i.e., service provider) to the back-end (i.e.,
            identity provider).  Conveniently, this is precisely the
            communication path that is needed for federated identity.
        Although EAP support is already integrated in AAA systems (see
            <xref target="RFC3579"/> and <xref target="RFC4072"/>)
            several challenges remain: one is to carry EAP payloads
            from the end host to the relying party. Another is to
            verify statements the relying party has made to the
            subject, confirm these statements are consistent with
            statements made to the identity provider and confirm all
            the above are consistent with the federation and any
            federation-specific policy or configuration. Another
            challenge is choosing which identity provider to use for
            which service.</t>

      </section>
      <section title="Application to Service">
	<t>One of the remaining layers is responsible for integration
	of federated authentication into the application. There are a
	number of approaches that applications have adopted for
	security. So, there may need to be multiple strategies for
	integration of federated authentication into
	applications. However, we have started with a strategy that
	provides integration to a large number of application
	protocols.</t>
	<t>Many applications such as SSH <xref target="RFC4462"/>, NFS
	<xref target="RFC2203"/>, DNS <xref target="RFC3645"/> and
	several non-IETF applications support the Generic Security
	Services Application Programming Interface <xref
	target="RFC2743"/>. Many applications such as IMAP, SMTP, XMPP
	and LDAP support e Simple Authentication and Security Layer
	(SASL) <xref target="RFC4422"/> framework. These two
	approaches work together nicely: by creating a GSS-API
	mechanism, SASL integration is also addressed <xref
	target="RFC5801"/>. In effect, using a GSS-API mechanism with
	SASL simply requires placing some headers on the front of the
	mechanism and constraining certain GSS-API options.</t>
	<t>GSS-API is specified in terms of an abstract set of
	operations which can be mapped into a programming language to
	form an API. When people are first introduced to GSS-API, they
	focus on it as an API. However, from the prospective of
	authentication for non-web applications, GSS-API should be
	thought of as a protocol not an API. It consists of some
	abstract operations such as the initial context exchange,
	which includes two sub-operations (gss_init_sec_context and
	gss_accept_sec_context). An application defines which abstract
	operations it is going to use and where messages produced by
	these operations fit into the application architecture. A
	GSS-API mechanism will define what actual protocol messages
	result from that abstract message for a given abstract
	operation. So, since this work is focusing on a particular
	GSS-API mechanism, we generally focus on protocol elements
	rather than the API view of GSS-API.</t>
	<t>The API view has significant value. Since the abstract
	operations are well defined, the set of information that a
	mechanism gets from the application is well defined. Also, the
	set of assumptions the application is permitted to make  is
	generally well defined. As a result, an application protocol
	that supports GSS-API or SASL is very likely to be usable with
	a new approach to authentication including this one with no
	required modifications. In some cases, support for a new
	authentication mechanism has been added using plugin
	interfaces to applications without the application being
	modified at all. Even when modifications are required, they
	can often be limited to supporting a new naming and
	authorization model. For example, this work focuses on
	privacy; an application that assumes it will always obtain an
	identifier for the principal will need to be modified to
	support anonymity, unlinkability or pseudonymity.</t>
	<t>So, we use GSS-API and SASL because a number of the
	application protocols we wish to federate support these
	strategies for security integration. What does this mean from
	a protocol standpoint and how does this relate to other
	layers? This means we need to design a concrete GSS-API
	mechanism. We have chosen to use a GSS-API mechanism that
	encapsulates EAP authentication. So, GSS-API (and SASL)
	encapsulate EAP between the end-host and the service. The AAA
	framework encapsulates EAP between the relying party and the
	identity provider. The GSS-API mechanism includes rules about
	how principals and services are named as well as per-message
	security and other facilities required by the applications we
	wish to support.</t>
      </section>
      <section title="Personalization Layer">
	<t>The AAA framework provides a way to transport statements
	from the identity provider to the relying party. However, we
	also need to say more about the content of these
	statements. In simple cases, attributes particular to the AAA
	protocol can be defined. However in more complicated
	situations it is strongly desirable to re-use an existing
	protocol for asking questions and receiving information about
	subjects. SAML is used for this. </t>
	<t>SAML usage may be as simple as the identity provider
	including a SAML Response message in the AAA
	response. Alternatively the relying party may generate a SAML request.</t>
      </section>
      <section title="Tieing Layers Together">
       <t>
        <figure title="Architecture for Federated Access of non-Web based Applications" anchor="abfab-arch">
          <artwork><![CDATA[
                                 +--------------+
                                 |  AAA Server  |
                                 |  (Identity   |
                                 |  Provider)   |
                                 +-^----------^-+
                                   * EAP      | RADIUS/
                                   *          | Diameter
                                 --v----------v--
                              ///                \\\
                            //                      \\   ***
                           |        Federation        |  back-
                           |                          |  end
                            \\                      //   ***
                              \\\                ///
                                 --^----------^--
                                   * EAP      | RADIUS/
                 Application       *          | Diameter
+-------------+  Data            +-v----------v--+
|             |<---------------->|               |
| Client      |  EAP/EAP Method  | Server Side   |
| Application |<****************>| Application   |
| @ End Host  |  GSS-API         |(Relying Party)|
|             |<---------------->|               |
|             |  Application     |               |
|             |  Protocol        |               |
|             |<================>|               |
+-------------+                  +---------------+
               *** front-end ***

Legend:

 <****>: End-to-end exchange
 <---->: Hop-by-hop exchange
 <====>: Protocol through which GSS-API/GS2 exchanges are tunnelled
]]></artwork>
        </figure>
      </t>
      </section>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Application Security Services">
      <t>One of the key goals is to integrate federated authentication
      into existing application protocols and where possible, existing
      implementations of these protocols. Another goal is to perform
      this integration while meeting the best security practices of
      the technologies used to perform the integration. This section
      describes security services and properties required by the EAP
      GSS-API mechanism in order to meet these goals. This information
      could be viewed as specific to that mechanism. However, other
      future application integration strategies are very likely to
      need similar services. So, it is likely that these services will
      be expanded across application integration strategies if new
      application integration strategies are adopted.</t>
      <section title="Server (Mutual) Authentication">
	<t>GSS-API provides an optional security service called mutual
	authentication. This service means that in addition to the
	initiator providing (potentially anonymous or pseudonymous)
	identity to the acceptor, the acceptor confirms its identity
	to the initiator. Especially for the ABFAB context, this
	service is confusingly named. We still say that mutual
	authentication is provided when the identity of an acceptor is
	strongly authenticated to an anonymous initiator.</t>
	<t>RFC 2743 does not explicitly talk about what mutual
	authentication means. Within the GSS-API community successful mutual
	authentication has come to mean:<list style="symbols">
	    <t>If a target name is supplied by the initiator, then the
	initiator trusts that the supplied target name describes the
	acceptor. This implies both that appropriate cryptographic
	exchanges took place for the initiator to make such a trust
	decision, and that after evaluating the results of these
	exchanges, the initiator's policy trusts that the target name
	is accurate.</t>
	    <t>The initiator trusts that its idea of the acceptor name
	correctly names the entity it is communicating with.</t>
	    <t>Both the initiator and acceptor have the same key
	material for per-message keys and both parties have confirmed
	they actually have the key material. In EAP terms, there is a
	protected indication of success.</t>
	  </list></t>
	<t>Mutual authentication is an important defense against
	certain aspects of phishing. Intuitively, users would like to
	assume that if some party asks for their credentials as part
	of authentication, successfully gaining access to the resource
	means that they are talking to the expected party. Without
	mutual authentication, the acceptor could "grant access"
	regardless of what credentials are supplied. Mutual
	authentication better matches this user intuition.</t>
	<t>The GSS-EAP mechanism MUST implement mutual
	authentication. That is, an initiator needs to be able to
	request mutual authentication. When mutual authentication is
	requested, only EAP methods capabale of providing the
	necessary service can be used, and appropriate steps need to
	be taken to provide mutual authentication. A broader set of
	EAP methods could be supported when a particular application
	does not request mutual authentication. It is an open question
	whether the mechanism will permit this.</t>
      </section>
      <section title="GSS-API Channel Binding">
	<t><xref target="RFC5056"/> defines a concept of channel
	binding to prevent man-in-the-middle attacks. It is common to
	provide SASL and GSS-API with another layer to provide
	transport security; Transport Layer Security (TLS) is the most
	common such layer. TLS provides its own server
	authentication. However there are a variety of situations
	where this authentication is not checked for policy or
	usability reasons. Even when it is checked, if the trust
	infrastructure behind the TLS authentication is different from
	the trust infrastructure behind the GSS-API mutual
	authentication. If the endpoints of the GSS-API authentication
	are different than the endpoints of the lower layer, this is a
	strong indication of a problem such as a man-in-the-middle
	attack. Channel binding provides a facility to determine
	whether these endpoints are the same.</t>
	<t>The GSS-EAP mechanism needs to support channel
	binding. When an application provides channel binding data,
	the mechanism needs to confirm this is the same on both sides
	consistent with the GSS-API specification. XXXThere is an open
	question here as to the details; today RFC 5554 governs. We
	could use that and the current draft assumes we will. However
	in Beijing we became aware of some changes to these details
	that would make life much better for GSS authentication of
	HTTP. We should resolve this with kitten and replace this note
	with a reference to the spec we're actually following.</t>
	<t>Typically when considering channel binding, people think of
	channel binding in combination with mutual
	authentication. This is sufficiently common that without
	additional qualification channel binding should be assumed to
	imply mutual authentication. Without mutual authentication, only one party
	knows that the endpoints are correct. That's sometimes
	useful. Consider for example a user who wishes to access a
	protected resource from a shared whiteboard in a conference
	room. The whiteboard is the initiator; it does not need to
	actually authenticate that it is talking to the correct
	resource because the user will be able to recognize whether
	the displayed content is correct. If channel binding were used
	without mutual authentication, it would in effect be a request
	to only disclose the resource in the context of a particular
	channel. Such an authentication would be similar in concept to
	a holder-of-key SAML assertion. However, also note that while
	it is not happening in the protocol, mutual authentication is
	happening in the overall system: the user is able to visually
	authenticate the content. This is consistent with all uses of
	channel binding without protocol level mutual authentication
	found so far.</t>
	<t>RFC 5056 channel binding (also called GSS-API channel
	binding when GSS-API is involved) is not the same thing as EAP
	channel binding. EAP channel binding is also used in the ABFAB
	context in order to implement acceptor naming and mutual
	authentication. Details are discussed in the mechanisms
	specification <xref target="I-D.ietf-abfab-gss-eap"/>.</t>
      </section>
      <section title="Host-Based Service Names">
	<t>IETF security mechanisms typically take the name of a
	service entered by a user and make some trust decision about
	whether the remote party in an interaction is the intended
	party. GSS-API has a relatively flexible naming
	architecture. However most of the IETF applications that use
	GSS-API, including SSH, NFS, IMAP, LDAP and XMPP, have chosen
	to use host-based service names when they use GSS-API. In this
	model, the initiator names an acceptor based on a service such
	as "imap" or "host" (for login services such as SSH) and a
	host name.</t>
	<t>Using host-based service names leads to a challenging trust
	delegation problem. Who is allowed to decide whether a
	particular hostname maps to an entity. The public-key
	infrastructure (PKI) used by the web has chosen to have a
	number of trust anchors (root certificate authorities) each of
	wich can map any name to a public key. A number of GSS-API
	mechanisms suchs as Kerberos <xref target="RFC1964"/> split
	the problem into two parts. A new concept called a realm is
	introduced. Then the mechanism decides what realm is
	responsible for a given name. That realm is responsible for
	deciding if the acceptor entity is allowed to claim the
	name. ABFAB needs to adopt this approach.</t>
	<t>Host-based service names do not work ideally when different
	instances of a service are running on different ports. Also,
	these do not work ideally when SRV record or other insecure
	referrals are used.</t>
	<t>The GSS-EAP mechanism needs to support host-based service
	names in order to work with existing IETF protocols.</t>
      </section>
      <section title="Per-Message Tokens">
	<t>GSs-API provides per-message security services that can
	provide confidentiality and integrity. Some IETF protocols
	such as NFS and SSH take advantage of these services. As a
	result GSS-EAP needs to support these services. As with mutual
	authentication, per-message services will limit the set of EAP
	methods that are available. Any method that produces a Master
	Session Key (MSK) should be able to support per-message
	security services.</t>
	<t>GSS-API provides a pseudo-random function. While the
	pseudo-random function does not involve sending data over the
	wire, it provides an algorithm that both the initiator and
	acceptor can run in order to arrive at the same key
	value. This is useful for designs where a successful
	authentication is used to key some other function. This is
	similar in concept to the TLS extractor. No current IETF
	protocols require this. However GSS-EAP supports this service
	because it is valuable for the future and easy to do given
	per-message services. Non-IETF protocols are expected to take
	advantage of this in the near future.</t>
      </section>
    </section>
    <section anchor="privacy-cons" title="Privacy Considerations">
      <t>Sharing identity information may lead to privacy violations. A future verison of this document
      will provide a discussion of privacy considerations in a federated access environment.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Deployment Considerations">
      <section title="EAP Channel Binding">
	<t>Discuss the implications of needing EAP channel
	binding.</t>

      </section>
      <section title="AAA Proxy Behavior">
	<t>Discuss deployment implications of our proxy requirements.</t>
      </section>
    </section>
    <section anchor="sec-cons" title="Security Considerations">
      <t>This entire document is about security. A future version of the document will highlight some important security concepts.</t>
    </section>


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="iana" title="IANA Considerations">
      <t>This document does not require actions by IANA.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Acknowledgments">
<!--      <t>The author would like to thank Sam Hartman for a discussion about all aspects of the
        "Federated Authentication Beyond The Web" effort when he was visiting MIT in June 2010.</t>-->
      <t>We would like to thank Mayutan Arumaithurai and        Klaas Wierenga for their feedback. Additionally, we would like to
      thank Eve Maler, Nicolas Williams, Bob Morgan, Scott Cantor, Jim Fenton, and Luke Howard for their feedback on the
      federation terminology question.</t>
      <t>Furthermore, we would like to thank Klaas Wierenga for his review of the pre-00 draft version.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->
  </middle>

  <!-- ////////////////////////////////////////////////////////////////////////////////// -->

  <back>
    <references title="Normative References">
&RFC2743;
      &RFC2865; &RFC3588;
      &RFC3748;  &RFC3579; &RFC4072; &RFC4282;
      &I-D.hansen-privacy-terminology;
      &I-D.ietf-abfab-gss-eap;
    </references>

    <references title="Informative References">
      &I-D.nir-tls-eap;
&RFC1964;
&RFC2203;
&RFC3645;
      &RFC2138;
&RFC4462;
&RFC4422;
&RFC5056;
&RFC5801;
      &SAML20;
      &RFC2904;
    </references>
  </back>
</rfc>
