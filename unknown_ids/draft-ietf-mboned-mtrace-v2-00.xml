<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc ipr="full3978">
<?rfc toc='yes'?>
<front>
	<title abbrev="Mtrace2">
		Mtrace Version 2: Traceroute Facility for IP Multicast
	</title>

	<author initials="H" surname="Asaeda" fullname="Hitoshi Asaeda">
	  <organization>Keio University</organization>
	  <address>
	    <postal>
	      <street>Graduate School of Media and Governance</street>
<!--	      <street>5322 Endo</street>-->
	      <city>Fujisawa</city> <region>Kanagawa</region>
	      <code>252-8520</code>
	      <country>Japan</country>
	    </postal>
	    <email>asaeda@wide.ad.jp</email>
	  </address>
	</author>

	<author initials="T" surname="Jinmei" fullname="Tatsuya Jinmei">
	<organization>Toshiba Corporation</organization>
	  <address>
	    <postal>
	      <street>Corporate Research & Development Center</street>
<!--	      <street>1 Komukai Toshiba-cho, Saiwai-ku</street>-->
	      <city>Kawasaki</city> <region>Kanagawa</region>
	      <code>212-8582</code>
	      <country>Japan</country>
	    </postal>
	    <email>jinmei@isl.rdc.toshiba.co.jp</email>
	  </address>
	</author>

	<author initials="W" surname="Fenner" fullname="William C. Fenner">
	<organization>AT&T Research</organization>
	  <address>
	    <postal>
<!--	      <street>75 Willow Rd.</street>-->
	      <city>Menlo Park</city>
	      <region>CA</region>
	      <code>94025</code>
	      <country>US</country>
	    </postal>
	    <email>fenner@research.att.com</email>
	  </address>
	</author>

	<author initials="S" surname="Casner" fullname="Stephen L. Casner">
	<organization>Packet Design, Inc.</organization>
	  <address>
	    <postal>
<!--	      <street>3400 Hillview Avenue, Building 3</street>-->
	      <city>Palo Alto</city>
	      <region>CA</region>
	      <code>94304</code>
	      <country>US</country>
	    </postal>
	    <email>casner@packetdesign.com</email>
	  </address>
	</author>

	<date month="November" year="2007" />

	<area>Operations and Management</area>
	<workgroup>MBONED Working Group</workgroup>

	<abstract>
	  <t>This document describes the IP multicast traceroute facility. Unlike unicast traceroute, multicast traceroute requires special implementations on the part of routers. This specification describes the required functionality in multicast routers, as well as how management applications can use the new router functionality.</t>
	</abstract>
<!--	<note title="IESG Note">
	  <t>The IESG has something to say.</t>
	</note>-->
</front>

<middle>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section anchor="sec.intro" title="Introduction">

	  <t>The unicast "traceroute" program allows the tracing of a path from one machine to another. The key mechanism for unicast traceroute is the ICMP TTL exceeded message, which is specifically precluded as a response to multicast packets. On the other hand, the multicast traceroute facility allows the tracing of an IP multicast routing paths. In this document, we specify the new multicast "traceroute" facility to be implemented in multicast routers and accessed by diagnostic programs. The new multicast traceroute, mtrace version 2 or mtrace2, can provide additional information about packet rates and losses that the unicast traceroute cannot, and generally requires fewer packets to be sent.</t>

	    <figure>
	    <artwork align="center">
o.  To be able to trace the path that a packet would take from some
    source to some destination.

o.  To be able to isolate packet loss problems (e.g., congestion).

o.  To be able to isolate configuration problems (e.g., TTL
    threshold).

o.  To minimize packets sent (e.g. no flooding, no implosion).
	    </artwork>
	    </figure>

	  <t>This document supports both IPv4 and IPv6 multicast traceroute facility. The protocol design, concept, and program behavior are same between IPv4 and IPv6 mtrace2. Regarding the previous IPv4 multicast traceroute, mtrace, the query and response messages for IPv4 mtrace are implemented as <xref target="refs.IGMPv3">IGMP messages</xref>. On the other hand, mtrace2 messages are carried on UDP, whereas the packet formats of IPv4 and IPv6 mtrace2 are different (but similar) because of the different address family.</t>
	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section title="Terminology">

	  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT","SHOULD", "SHOULD NOT", "RECOMMENDED","MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="refs.KEYWORDS">RFC 2119</xref>.</t>

	  <t>Since multicast traceroutes flow in the opposite direction to the data flow, we refer to "upstream" and "downstream" with respect to data, unless explicitly specified.</t>

	  <t>Incoming interface:
	  <vspace blankLines="0" />
	  The interface on which traffic is expected from the specified source and group.</t>

	  <t>Outgoing interface:
	  <vspace blankLines="0" />
	  The interface on which traffic is forwarded from the specified source and group toward the destination. It is the interface on which the multicast traceroute Request was received.</t>

	  <t>Previous-hop router:
	  <vspace blankLines="0" />
	  The router that is on the link attached to the Incoming Interface and is responsible for forwarding traffic for the specified source and group.</t>

	  <t>Group state:
	  <vspace blankLines="0" />
	  It is the state in which a shared-tree protocol (e.g., <xref target="refs.PIMSM">PIM-SM</xref>) running on a router chooses the previous-hop router toward the core router (or RP) as its parent router. In this state, source-specific state is not available for the corresponding multicast address on the router.</t>

	  <t>Source-specific state:
	  <vspace blankLines="0" />
	  It is the state in which a routing protocol running on a router chooses the path that would be followed for a source-specific join.</t>

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section title="Overview">

	  <t>Given a multicast distribution tree, tracing from a source to a multicast destination is hard, since you don't know down which branch of the multicast tree the destination lies. This means that you have to flood the whole tree to find the path from one source to one destination. However, walking up the tree from destination to source is easy, as most existing multicast routing protocols know the previous hop for each source. Tracing from destination to source can involve only routers on the direct path.</t>

	  <t>The party requesting the traceroute (which need be neither the source nor the destination) sends a traceroute Query packet to the last-hop multicast router for the given destination. The last-hop router turns the Query into a Request packet by adding a response data block containing its interface addresses and packet statistics, and then forwards the Request packet via unicast to the router that it believes is the proper previous hop for the given source and group. Each hop adds its response data to the end of the Request packet, then unicast forwards it to the previous hop. The first hop router (the router that believes that packets from the source originate on one of its directly connected networks) changes the packet type to indicate a Response packet and sends the completed response to the response destination address. The response may be returned before reaching the first hop router if a fatal error condition such as "no route" is encountered along the path.</t>

	  <t>Multicast traceroute uses any information available to it in the router to attempt to determine a previous hop to forward the trace towards. Multicast routing protocols vary in the type and amount of state they keep; multicast traceroute endeavors to work with all of them by using whatever is available. For example, if a DVMRP router has no active state for a particular source but does have a DVMRP route, it chooses the parent of the DVMRP route as the previous hop. If a PIM-SM router is on the (*,G) tree, it chooses the parent towards the RP as the previous hop. In these cases, no source/group-specific state is available, but the path may still be traced.</t>

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section title="IPv4 Multicast Traceroute Header">

	  <figure>
	  <t>The mtrace2 message is carried as a UDP packet. The UDP source port is uniquely selected by the local host operating system. The UDP destination port is the IANA reserved mtrace2 port number (see <xref target="sec.iana" />). The UDP checksum MUST be valid in mtrace2 control messages.</t>

	  <t>The IPv4 mtrace2 includes the common packet header as follows. The header is only filled in by the originator of the traceroute Query; intermediate routers MUST NOT modify any of the fields.</t>
	  <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type     |                  Reserved                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Multicast Address                        |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                        Source Address                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Destination Address                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Response Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Resp TTL/HopLim|                  Query ID                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	  </artwork>
	  </figure>

	  <section title="Type: 8 bits">
	    <t>The UDP type field is defined to be "0x1" for traceroute queries and requests. The UDP type field is changed to "0x2" when the packet is completed and sent as a response from the first hop router to the querier. Two codes are required so that multicast routers won't attempt to process a completed response in those cases where the initial query was issued from a router or the response is sent via multicast.</t>
	  </section>

	  <section anchor="sec.hops" title="# hops: 8 bits">
	    <t>This field specifies the maximum number of hops that the requester wants to trace. If there is some error condition in the middle of the path that keeps the traceroute request from reaching the first-hop router, this field can be used to perform an expanding-ring search to trace the path to just before the problem.</t>
	  </section>

	  <section title="Checksum: 16 bits">
	    <t>The checksum is the 16-bit one's complement of the one's complement sum of the whole UDP message <xref target="refs.Cksum">(the entire IP payload)</xref>. When computing the checksum, the checksum field is set to zero. When transmitting packets, the checksum MUST be computed and inserted into this field. When receiving packets, the checksum MUST be verified before processing a packet.</t>
	  </section>

	  <section anchor="sec.multi" title="Multicast Address">
	    <t>This field specifies the multicast address to be traced, or zero if no group-specific information is desired. Note that non-group-specific traceroutes may not be possible with certain multicast routing protocols.</t>
	  </section>

	  <section title="Source Address">
	    <t>This field specifies the IP address of the multicast source for the path being traced, or 0xffffffff if no source-specific information is desired. Note that non-source-specific traceroutes may not be possible with certain multicast routing protocols.</t>
	  </section>

	  <section anchor="sec.dest" title="Destination Address">
	    <t>This field specifies the IP address of the multicast receiver for the path being traced. The trace starts at this destination and proceeds toward the traffic source.</t>
	  </section>

	  <section anchor="sec.resp" title="Response Address">
	    <t>This field specifies IP address to which the completed traceroute response packet gets sent. It can be a unicast address or a multicast address, as explained in <xref target="sec.Trace.Req" /></t>
	  </section>

	  <section title="Resp TTL: 8 bits">
	    <t>This field specifies the TTL at which to multicast the response, if the response address is a multicast address.</t>
	  </section>

	  <section anchor="sec.QID" title="Query ID: 24 bits">
	    <t>This field is used as a unique identifier for this traceroute request so that duplicate or delayed responses may be detected and to minimize collisions when a multicast response address is used.</t>
	  </section>

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section title="IPv4 Multicast Traceroute Response Data">

	  <figure>
	  <t>Each intermediate router in a trace path appends "response data" to the forwarded trace packet. The response data looks as follows.</t>
	  <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Query Arrival Time                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Incoming Interface Address                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Outgoing Interface Address                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Previous-Hop Router Address                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|           Input packet count on incoming interface            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|           Output packet count on outgoing interface           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|      Total number of packets for this source-group pair       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               |               |M| |           |               |
| Rtg Protocol  |    Fwd TTL    |B|S| Src Mask  |Forwarding Code|
|               |               |Z| |           |               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	  </artwork>
	  <postamble></postamble>
	  </figure>

	  <section anchor="sec.QAT" title="Query Arrival Time: 32 bits">
	    <t>The Query Arrival Time is a 32-bit NTP timestamp specifying the arrival time of the traceroute request packet at this router. The 32-bit form of an NTP timestamp consists of the middle 32 bits of the full 64-bit form; that is, the low 16 bits of the integer part and the high 16 bits of the fractional part.</t>

	    <t>The following formula converts from a UNIX timeval to a 32-bit NTP timestamp:</t>

	    <list style="empty">
	    <t>query_arrival_time
	    <vspace blankLines="0" />
	    = (tv.tv_sec + 32384) &lt;&lt; 16 + ((tv.tv_usec &lt;&lt; 10) / 15625)
	    </t>
	    </list>

	    <t>The constant 32384 is the number of seconds from Jan 1, 1900 to Jan 1, 1970 truncated to 16 bits.  ((tv.tv_usec &lt;&lt; 10) / 15625) is a reduction of ((tv.tv_usec / 100000000) &lt;&lt; 16).</t>
	  </section>

	  <section title="Incoming Interface Address">
	    <t>This field specifies the address of the interface on which packets from this source and group are expected to arrive, or 0 if unknown.</t>
	  </section>

	  <section title="Outgoing Interface Address">
	    <t>This field specifies the address of the interface on which packets from this source and group flow to the specified destination, or 0 if unknown.</t>
	  </section>

	  <section title="Previous-Hop Router Address">
	    <t>This field specifies the router from which this router expects packets from this source. This may be a multicast group (e.g. ALL-[protocol]-ROUTERS.MCAST.NET) if the previous hop is not known because of the workings of the multicast routing protocol. However, it should be 0 if the incoming interface address is unknown.</t>
	  </section>

	  <section title="Packet counts">
	    <t>Note that these packet counts SHOULD be as up to date as possible. If packet counts are not being maintained on the processor that handles the traceroute request in a multi-processor router architecture, the packet SHOULD be delayed while the counters are gathered from the remote processor(s). If this occurs, the Query Arrival Time should be updated to reflect the time at which the packet counts were learned.</t>
	  </section>

	  <section anchor="sec.iif" title="Input packet count on incoming interface">
	    <t>This field contains the number of multicast packets received for all groups and sources on the incoming interface, or 0xffffffffffffffff if no count can be reported. This counter should have the same value as ifInMulticastPkts from the <xref target="refs.IFMIB">IF-MIB</xref> for this interface.</t>
	  </section>

	  <section anchor="sec.oif" title="Output packet count on incoming interface">
	    <t>This field contains the number of multicast packets that have been transmitted or queued for transmission for all groups and sources on the outgoing interface, or 0xffffffffffffffff if no count can be reported. This counter should have the same value as ifOutMulticastPkts from the IF-MIB for this interface.</t>
	  </section>

	  <section title="Total number of packets for this source-group pair">
	    <t>This field counts the number of packets from the specified source forwarded by this router to the specified group, or 0xffffffffffffffff if no count can be reported. If the S bit is set, the count is for the source network, as specified by the Src Mask field. If the S bit is set and the Src Mask field is 63, indicating no source-specific state, the count is for all sources sending to this group. This counter should have the same value as ipMcastRoutePkts from the <xref target="refs.MROUTEMIB">IPMROUTE-STD-MIB</xref> for this forwarding entry.</t>
	  </section>

	  <section anchor="sec.rtproto" title="Rtg Protocol: 8 bits">
	    <t>This field describes the routing protocol in use between this router and the previous-hop router. Specified values include:</t>
	    <figure>
	    <artwork align="center">
1    DVMRP
2    MOSPF
3    PIM
4    CBT
5    PIM using special routing table
6    PIM using a static route
7    DVMRP using a static route
8    PIM using MBGP route
9    CBT using special routing table
10   CBT using a static route
11   PIM using state created by Assert processing
12   Bi-directional PIM
	    </artwork>
	    <postamble></postamble>
	    </figure>

<!--	    <t>CBT <xref target="refs.CBT" />, <xref target="refs.Embed" />,  <xref target="refs.Bidir" /></t>-->

	    <t>Note that some of the routing protocols or functions are not supported or not used in either of IPv4 multicast nor IPv6 multicast.</t>
	  </section>

	  <section title="Fwd TTL: 8 bits">
	    <t>This field contains the TTL that a packet is required to have before it will be forwarded over the outgoing interface.</t>
	  </section>

	  <section title="MBZ: 1 bit">
	    <t>Must be zeroed on transmission and ignored on reception.</t>
	  </section>

	  <section title="S: 1 bit">
	    <t>This S bit indicates that the packet count for the source-group pair is for the source network, as determined by masking the source address with the Src Mask field.</t>
	  </section>

	  <section title="Src Mask: 6 bits">
	    <t>This field contains the number of 1's in the netmask this router has for the source (i.e. a value of 24 means the netmask is 0xffffff00). If the router is forwarding solely on group state, this field is set to 63 (0x3f).</t>
	  </section>

	  <section anchor="sec.fwcode" title="Forwarding Code: 8 bits">
	    <t>This field contains a forwarding information/error code. Defined values are as follows;</t>
	    <figure>
	    <artwork align="center">
Value   Name            Description

-----  --------------  -------------------------------------------

0x00   NO_ERROR        No error

0x01   WRONG_IF        Traceroute request arrived on an interface
                       to which this router would not forward for
                       this source,group,destination.

0x02   PRUNE_SENT      This router has sent a prune upstream which
                       applies to the source and group in the
                       traceroute request.

0x03   PRUNE_RCVD      This router has stopped forwarding for this
                       source and group in response to a request
                       from the next hop router.

0x04   SCOPED          The group is subject to administrative
                       scoping at this hop.

0x05   NO_ROUTE        This router has no route for the source or
                       group and no way to determine a potential
                       route.

0x06   WRONG_LAST_HOP  This router is not the proper last-hop
                       router.

0x07   NOT_FORWARDING  This router is not forwarding this source,
                       group out the outgoing interface for an
                       unspecified reason.

0x08   REACHED_RP      Reached Rendez-vous Point or Core

0x09   RPF_IF          Traceroute request arrived on the expected
                       RPF interface for this source, group.

0x0A   NO_MULTICAST    Traceroute request arrived on an interface
                       which is not enabled for multicast.

0x0B   INFO_HIDDEN     One or more hops have been hidden from this
                       trace.

0x81   NO_SPACE        There was not enough room to insert another
                       response data block in the packet.

0x82   OLD_ROUTER      The previous-hop router does not understand
                       traceroute requests.

0x83   ADMIN_PROHIB    Traceroute is administratively prohibited.
	    </artwork>
	    <postamble></postamble>
	    </figure>
	    <t>Note that if a router discovers there is not enough room in a packet to insert its response, it puts the 0x81 error code in the previous router's Forwarding Code field, overwriting any error the previous router placed there. A multicast traceroute client, upon receiving this error, MAY restart the trace at the last hop listed in the packet.</t>
	    <t>The 0x80 bit of the Forwarding Code is used to indicate a fatal error. A fatal error is one where the router may know the previous hop but cannot forward the message to it.</t>
	  </section>

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section title="IPv6 Multicast Traceroute Header">

<!--	  <figure anchor="common_header">-->
	  <figure>
	  <t>IPv6 mtrace2 includes the common packet header as follows. Because of the specification of the IPv6 address, all IPv6 addresses used in each field consume 128 bits length.</t>
	  <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type     |    # hops     |           Checksum            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Reserved                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
*                                                               *
|                                                               |
*                      Multicast Address                        *
|                                                               |
*                                                               *
|                                                               |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                                                               |
*                                                               *
|                                                               |
*                        Source Address                         *
|                                                               |
*                                                               *
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
*                                                               *
|                                                               |
*                      Destination Address                      *
|                                                               |
*                                                               *
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
*                                                               *
|                                                               |
*                       Response Address                        *
|                                                               |
*                                                               *
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Resp Hop Limit |                  Query ID                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	  </artwork>
<!--	  <postamble></postamble>-->
	  </figure>

	  <section title="Type: 8 bits">
	    <t>The UDP type field is defined to be "0x1" for traceroute queries and requests. The UDP type field is changed to "0x2" when the packet is completed and sent as a response from the first hop router to the querier. Two codes are required so that multicast routers won't attempt to process a completed response in those cases where the initial query was issued from a router or the response is sent via multicast.</t>
	  </section>

	  <section title="# hops: 8 bits">
	    <t>Same definition described in <xref target="sec.hops" /></t>
	  </section>

	  <section title="Checksum: 16 bits">
	    <t>As defined <xref target="refs.IPv6">in</xref>, the checksum is the 16-bit one's complement of the one's complement sum of the entire UDP message, starting with the UDP message type field, and prepended with a "pseudo-header" of IPv6 header fields.</t>
	  </section>

	  <section title="Reserved: 32 bits">
	    <t>Initialized to zero by the sender; ignored by receivers.</t>
	  </section>

	  <section title="Multicast Address">
	    <t>Same definition described in <xref target="sec.multi" /></t>
	  </section>

	  <section title="Source Address">
	    <t>This field specifies the IPv6 address of the multicast source for the path being traced, or is filled with the unspecified address (::) if no source-specific information is desired. Note that non-source-specific traceroutes may not be possible with certain multicast routing protocols.</t>
	  </section>

	  <section title="Destination Address">
	    <t>Same definition described in <xref target="sec.dest" /></t>
	  </section>

	  <section title="Response Address">
	    <t>Same definition described in <xref target="sec.resp" /></t>
	  </section>

	  <section title="Resp Hop Limit: 8 bits">
	    <t>This field specifies the hop limit at which to multicast the response, if the response address is a multicast address.</t>
	  </section>

	  <section title="Query ID: 24 bits">
	    <t>Same definition described in <xref target="sec.QID" /></t>
	  </section>

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section title="IPv6 Multicast Traceroute Response Data">

	  <figure>
	  <t>Each intermediate router in a trace path appends "response data" to the forwarded trace packet. The response data looks as follows.</t>
	  <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Query Arrival Time                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Incoming Interface ID                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Outgoing Interface ID                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
*                                                               *
|                                                               |
*                         Local Address                         *
|                                                               |
*                                                               *
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
*                                                               *
|                                                               |
*                         Remote Address                        *
|                                                               |
*                                                               *
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|           Input packet count on incoming interface            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|           Output packet count on outgoing interface           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|      Total number of packets for this source-group pair       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Rtg Protocol  | Fwd Hop Limit |     MBZ     |S|Src Prefix Len |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Forwarding Code|                   Reserved                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	  </artwork>
	  <postamble></postamble>
	  </figure>

	  <section title="Query Arrival Time: 32 bits">
	    <t>Same definition described in <xref target="sec.QAT" /></t>
	  </section>

	  <section title="Incoming Interface ID: 32 bits">
	    <t>This field specifies the interface ID on which packets from this source and group are expected to arrive, or 0 if unknown. This ID should be the value taken from InterfaceIndex of the IF-MIB for this interface. This field is carried in network byte order.</t>
	  </section>

	  <section title="Outgoing Interface ID: 32 bits">
	    <t>This field specifies the interface ID on which packets from this source and group flow to the specified destination, or 0 if unknown. This ID should be the value taken from InterfaceIndex of the IF-MIB for this interface. This field is carried in network byte order.</t>
	  </section>

	  <section title="Local Address">
	    <t>This field specifies a global IPv6 address that uniquely identifies the router. A <xref target="refs.DefRtr">unique local unicast address</xref> SHOULD NOT be used unless the node is only assigned link-local and unique local addresses. [TBD: What if the node is only assigned link-local addresses? It should be very unlikely case, but is possible even for a properly working router.]</t>
	    <t>Note that since interface indices used in the Incoming and Outgoing Interface ID fields are node-local information, a global identifier is needed to specify the router.</t>
	  </section>

	  <section title="Remote Address">
	    <t>This field specifies the address of the previous-hop router, which, in most cases, is a link-local unicast address for the queried source and destination addresses.</t>
	    <t>Although a link-local address does not have enough information to identify a node, it is possible to detect the previous-hop router with the assistance of Incoming Interface ID and the current router address (i.e., Local Address).</t>
	    <t>This may be a multicast group (e.g., ALL-[protocol]-ROUTERS.MCAST.NET) if the previous hop is not known because of the workings of the multicast routing protocol. However, it should be the unspecified address (::) if the incoming interface address is unknown.</t>
	  </section>

	  <section title="Input packet count on incoming interface">
	    <t>Same definition described in <xref target="sec.iif" /></t>
	  </section>

	  <section title="Output packet count on incoming interface">
	    <t>Same definition described in <xref target="sec.oif" /></t>
	  </section>

	  <section title="Total number of packets for this source-group pair">
	    <t>This field counts the number of packets from the specified source forwarded by this router to the specified group, or 0xffffffffffffffff if no count can be reported. If the S bit is set, the count is for the source network, as specified by the Src Prefix Len field. If the S bit is set and the Src Prefix Len field is 255, indicating no source-specific state, the count is for all sources sending to this group. This counter should have the same value as ipMcastRoutePkts from the IPMROUTE-STD-MIB for this forwarding entry.</t>
	  </section>

	  <section title="Rtg Protocol: 8 bits">
	    <t>Same definition described in <xref target="sec.rtproto" /></t>

	    <t>Note that some of the routing protocols or functions are not supported or not used in IPv6 multicast.</t>
	  </section>

	  <section title="Fwd Hop Limit: 8 bits">
	    <t>This field contains the hop limit that a packet is required to have before it will be forwarded over the outgoing interface.</t>
	  </section>

	  <section title="MBZ: 7 bits">
	    <t>Must be zeroed on transmission and ignored on reception.</t>
	  </section>

	  <section title="S: 1 bit">
	    <t>This S bit indicates that the packet count for the source-group pair is for the source network, as determined by masking the source address with the Src Prefix Len field.</t>
	  </section>

	  <section title="Src Prefix Len: 8 bits">
	    <t>This field contains the decimal number of the prefix length this router has for the source. If the router is forwarding solely on group state, this field is set to 255 (0xff)</t>
	  </section>

	  <section title="Forwarding Code: 8 bits">
	    <t>Same definition described in <xref target="sec.fwcode" /></t>
	  </section>

	  <section title="Reserved: 24 bit">
	    <t>Initialized to zero by the sender; ignored by receivers.</t>
	  </section>

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section title="Router Behavior">

	  <t>All of these actions are performed in addition to (NOT instead of) forwarding the packet, if applicable. E.g. a multicast packet that has TTL or the hop limit remaining MUST be forwarded normally, as MUST a unicast packet that has TTL or the hop limit remaining and is not addressed to this router.</t>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section title="Traceroute Query">
	    <t>A traceroute Query message is a traceroute message with no response blocks filled in, and uses UDP type 0x1 for IPv4 and IPv6 mtrace2.</t>

	    <section title="Packet Verification">
	      <t>Upon receiving a traceroute Query message, a router must examine the Query to see if it is the proper last-hop router for the destination address in the packet. It is the proper last-hop router if it has a multicast-capable interface on the same subnet as the Destination Address and is the router that would forward traffic from the given source onto that subnet.</t>

	      <t>If the router determines that it is not the proper last-hop router, or it cannot make that determination, it does one of two things depending if the Query was received via multicast or unicast. If the Query was received via multicast, then it MUST be silently dropped. If it was received via unicast, a forwarding code of WRONG_LAST_HOP is noted and processing continues as in <xref target="sec.Trace.Req" /></t>

	      <t>Duplicate Query messages as identified by the tuple (IP Source, Query ID) SHOULD be ignored. This MAY be implemented using a simple 1-back cache (i.e. remembering the IP source and Query ID of the previous Query message that was processed, and ignoring future messages with the same IP Source and Query ID). Duplicate Request messages MUST NOT be ignored in this manner.</t>
	    </section>

	    <section title="Normal Processing">
	      <t>When a router receives a traceroute Query and it determines that it is the proper last-hop router, it treats it like a traceroute Request and performs the steps listed in <xref target="sec.Trace.Req" /></t>
	    </section>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section anchor="sec.Trace.Req" title="Traceroute Request">
	    <t>A traceroute Request is a traceroute message with some number of response blocks filled in, and uses UDP type 0x1 for IPv4 and IPv6 mtrace2. Routers can tell the difference between Queries and Requests by checking the length of the packet.</t>

	    <section title="Packet Verification">
	      <t>If the traceroute Request is not addressed to this router, or if the Request is addressed to a multicast group which is not a link-scoped group (i.e. 224/24 for IPv4, <xref target="refs.IPv6Addr">FFx2::/16</xref> for IPv6), it MUST be silently ignored.</t>
	    </section>

	    <section title="Normal Processing">
	      <t>When a router receives a traceroute Request, it performs the following steps. Note that it is possible to have multiple situations covered by the Forwarding Codes. The first one encountered is the one that is reported, i.e. all "note forwarding code N" should be interpreted as "if forwarding code is not already set, set forwarding code to N".</t>

	      <list style='numbers'>
		<t>If there is room in the current buffer (or the router can efficiently allocate more space to use), insert a new response block into the packet and fill in the Query Arrival Time, Outgoing Interface Address (for IPv4 mtrace2) or Outgoing Interface ID (for IPv6 mtrace2), Output Packet Count, and Fwd TTL or Fwd Hop Limit. If there was no room, fill in the response code "NO_SPACE" in the <spanx style='strong'>previous</spanx> hop's response block, and forward the packet to the requester as described in "Forwarding Traceroute Requests".</t>

		<t>Attempt to determine the forwarding information for the source and group specified, using the same mechanisms as would be used when a packet is received from the source destined for the group. State need not be instantiated, it can be "phantom" state created only for the purpose of the trace.
		<vspace blankLines='1' />
		If using a shared-tree protocol and there is no source-specific state, or if the source is specified as 0xFFFFFFFF, group state should be used. If there is no group state or the group is specified as 0, potential source state (i.e. the path that would be followed for a source-specific Join) should be used. If this router is the Core or RP and no source-specific information is available, note an error code of REACHED_RP.</t>

		<t>If no forwarding information can be determined, the router notes an error code of NO_ROUTE, sets the remaining fields that have not yet been filled in to zero, and then forwards the packet to the requester as described in "Forwarding Traceroute Requests".</t>

		<t>Fill in the Incoming Interface Address, Previous-Hop Router Address, Input Packet Count, Total Number of Packets, Routing Protocol, S, and Src Mask from the forwarding information that was determined.</t>

		<t>If traceroute is administratively prohibited or the previous hop router does not understand traceroute requests, note the appropriate forwarding code (ADMIN_PROHIB or OLD_ROUTER). If traceroute is administratively prohibited and any of the fields as filled in step 4 are considered private information, zero out the applicable fields. Then the packet is forwarded to the requester as described in "Forwarding Traceroute Requests".</t>

		<t>If the reception interface is not enabled for multicast, note forwarding code NO_MULTICAST. If the reception interface is the interface from which the router would expect data to arrive from the source, note forwarding code RPF_IF. Otherwise, if the reception interface is not one to which the router would forward data from the source to the group, a forwarding code of WRONG_IF is noted.</t>

		<t>If the group is subject to administrative scoping on either the Outgoing or Incoming interfaces, a forwarding code of SCOPED is noted.</t>

		<t>If this router is the Rendez-vous Point or Core for the group, a forwarding code of REACHED_RP is noted.</t>

		<t>If this router has sent a prune upstream which applies to the source and group in the traceroute Request, it notes forwarding code PRUNE_SENT. If the router has stopped forwarding downstream in response to a prune sent by the next hop router, it notes forwarding code PRUNE_RCVD. If the router should normally forward traffic for this source and group downstream but is not, it notes forwarding code NOT_FORWARDING.</t>

		<t>The packet is then sent on to the previous hop or the requester as described in <xref target="sec.Forward"/>.</t>
	      </list>
	    </section>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section title="Traceroute Response">
	    <t>A router must forward all traceroute response packets normally, with no special processing. If a router has initiated a traceroute with a Query or Request message, it may listen for Responses to that traceroute but MUST still forward them as well.</t>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section anchor="sec.Forward" title="Forwarding Traceroute Requests">
	    <t>If the Previous-hop router is known for this request and the number of response blocks is less than the number requested, the packet is sent to that router. If the Incoming Interface is known but the Previous-hop router is not known, the packet is sent to an appropriate multicast address on the Incoming Interface. The appropriate multicast address may depend on the routing protocol in use, MUST be a link-scoped group (i.e. 224/24 for IPv4, FF02::/16 for IPv6), MUST NOT be ALL-SYSTEMS.MCAST.NET (224.0.0.1) for IPv4 and All Nodes Address (FF02::1) for IPv6, and MAY be ALL-ROUTERS.MCAST.NET (224.0.0.2) for IPv4 or All Routers Address (FF02::2) for IPv6 if the routing protocol in use does not define a more appropriate group. Otherwise, it is sent to the Response Address in the header, as described in <xref target="sec.response" />.</t>
	    <t>Note that it is not an error for the number of response blocks to be greater than the number requested; such a packet should simply be forwarded to the requester as described in <xref target="sec.response" />.</t>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section anchor="sec.response" title="Sending Traceroute Responses">

	    <section title="Destination Address">
	      <t>A traceroute response must be sent to the Response Address in the traceroute header.</t>
	    </section>

	    <section title="TTL and Hop Limit">
	      <t>If the Response Address is unicast, the router inserts its normal unicast TTL or hop limit in the IP header, and may use any of its interface addresses as the source address. If the Response Address is multicast, the router copies the Response TTL or hop limit from the traceroute header into the IP header.</t>
	    </section>

	    <section title="Source Address">
	      <t>If the Response Address is unicast, the router may use any of its interface addresses as the source address. Since some multicast routing protocols forward based on source address, if the Response Address is multicast, the router MUST use an address that is known in the multicast routing topology if it can make that determination.</t>
	    </section>

	    <section title="Sourcing multicast responses">
	      <t>When a router sources a multicast response, the response packet MUST be sent on a single interface, then forwarded as if it were received on that interface.  It MUST NOT source the response packet individually on each interface, in order to avoid duplicate packets.</t>
	    </section>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section title="Hiding information">
	    <t>Information about a domain's topology and connectivity may be hidden from multicast traceroute requests. The exact mechanism is not specified here; however, the INFO_HIDDEN forwarding code may be used to note that, for example, the incoming interface address and packet count are for the entrance to the domain and the outgoing interface address and packet count are the exit from the domain. The source-group packet count may be from either router or not specified (0xffffffff).</t>
	  </section>

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section anchor="sec.use" title="Using multicast traceroute">

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section title="Sample client">
	    <t>This section describes the behavior of an example multicast traceroute client.</t>

	    <section title="Sending initial query">
	      <t>When the destination of the mtrace2 is the machine running the client, the mtrace2 Query packet can be sent to the ALL-ROUTERS.MCAST.NET (224.0.0.2) for IPv4 or All Routers Address (FF02::2) for IPv6. This will ensure that the packet is received by the last-hop router on the subnet. Otherwise, if the proper last-hop router is known for the mtrace2 destination, the Query could be unicasted to that router. Otherwise, the Query packet should be multicasted to the group being queried; if the destination of the mtrace2 is a member of the group, this will get the Query to the proper last-hop router. In this final case, the packet should contain the <xref target="refs.RA">Router Alert option</xref>, to make sure that routers that are not members of the multicast group notice the packet.</t>
	      <t>See also <xref target="sec.Lasthop" /> on determining the last-hop router.</t>
	    </section>

	    <section title="Determining the Path">
	      <t>The client could send a small number of initial query messages with a large "# hops" field, in order to try to trace the full path. If this attempt fails, one strategy is to perform a linear search (as the traditional unicast traceroute program does); set the "# hops" field to 1 and try to get a response, then 2, and so on. If no response is received at a certain hop, the hop count can continue past the non-responding hop, in the hopes that further hops may respond. These attempts should continue until a user-defined timeout has occurred.</t>
	      <t>See also <xref target="sec.first" /> and <xref target="sec.broken" /> on receiving the results of a trace.</t>
	    </section>

	    <section title="Collecting statistics">
	      <t>After a client has determined that it has traced the whole path or as much as it can expect to (see <xref target="sec.terminate" />), it might collect statistics by waiting a short time and performing a second trace. If the path is the same in the two traces, statistics can be displayed as described in <xref target="sec.loss" /> and <xref target="sec.util" />.</t>
	    </section>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section anchor="sec.Lasthop" title="Last hop router">
	    <t>The mtrace2 querier may not know which is the last hop router, or that router may be behind a firewall that blocks unicast packets but passes multicast packets. In these cases, the mtrace2 request should be multicasted to the group being traced (since the last hop router listens to that group). All routers except the correct last hop router should ignore any mtrace2 request received via multicast. Mtrace2 requests which are multicasted to the group being traced must include the <xref target="refs.RA">Router Alert option</xref>.</t>

	    <t>Another alternative is to unicast to the trace destination. Traceroute requests which are unicasted to the trace destination must include the Router Alert option, in order that the last-hop router is aware of the packet.</t>

	    <t>If the traceroute querier is attached to the same router as the destination of the request, the traceroute request may be multicasted to ALL-ROUTERS.MCAST.NET (224.0.0.2) for IPv4 or All Routers Address (FF02::2) for IPv6 if the last-hop router is not known.</t>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section anchor="sec.first" title="First hop router">
	    <t>The mtrace2 querier may not be unicast reachable from the first hop router. In this case, the querier should set the traceroute response address to a multicast address, and should set the response TTL (or hop limit) to a value sufficient for the response from the first hop router to reach the querier. It may be appropriate to start with a small TTL and increase in subsequent attempts until a sufficient TTL is reached, up to an appropriate maximum (such as 192).</t>
	    <t>The IANA has assigned 224.0.1.32, MTRACE.MCAST.NET as the default multicast group for IPv4 mtrace2 responses, and will assign MTRACE2_IPV6RESPADDR (TBD (see <xref target="sec.iana" />)) for IPv6 mtrace2 responses. Other groups may be used if needed, e.g. when using mtrace2 to diagnose problems with the IANA-assigned group.</t>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section anchor="sec.broken" title="Broken intermediate router">
	    <t>A broken intermediate router might simply not understand traceroute packets, and drop them. The querier would then get no response at all from its traceroute requests. It should then perform a hop-by-hop search by setting the number of responses field until it gets a response (both linear and binary search are options, but binary is likely to be slower because a failure requires waiting for a timeout).</t>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section anchor="sec.terminate" title="Mtrace2 termination">
	    <t>When performing an expanding hop-by-hop trace, it is necessary to determine when to stop expanding.</t>

	    <section title="Arriving at source">
	      <t>A trace can be determined to have arrived at the source if the Incoming Interface of the last router in the trace is non-zero, but the Previous Hop router is zero.</t>
	    </section>

	    <section title="Fatal error">
	      <t>A trace has encountered a fatal error if the last Forwarding Error in the trace has the 0x80 bit set.</t>
	    </section>

	    <section title="No previous hop">
	      <t>A trace can not continue if the last Previous Hop in the trace is set to 0.</t>
	    </section>

	    <section title="Traceroute shorter than requested">
	      <t>If the trace that is returned is shorter than requested (i.e. the number of Response blocks is smaller than the "# hops" field), the trace encountered an error and could not continue.</t>
	    </section>

	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section title="Continuing after an error">
	    <t>When the NO_SPACE error occurs, the client might try to continue the trace by starting it at the last hop in the trace. It can do this by unicasting to this router's outgoing interface address, keeping all fields the same. If this results in a single hop and a "WRONG_IF" error, the client may try setting the trace destination to the same outgoing interface address.</t>

	    <t>If a trace times out, it is likely to be because a router in the middle of the path does not support multicast traceroute. That router's address will be in the Previous Hop field of the last entry in the last reply packet received. A client may be able to determine (via mrinfo or SNMP <xref target="refs.DefRtr" /><xref target="refs.MROUTEMIB" />) a list of neighbors of the non-responding router. If desired, each of those neighbors could be probed to determine the remainder of the path. Unfortunately, this heuristic may end up with multiple paths, since there is no way of knowing what the non-responding router's algorithm for choosing a previous-hop router is. However, if all paths but one flow back towards the non-responding router, it is possible to be sure that this is the correct path.</t>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section title="Multicast Traceroute and shared tree routing protocols">
	    <t>When using shared-tree routing protocols like PIM-SM and CBT, a more advanced client may use multicast traceroute to determine paths or potential paths.</t>

	    <section title="PIM-SM">
	      <t>When a multicast traceroute reaches a PIM-SM RP and the RP does not forward the trace on, it means that the RP has not performed a source-specific join so there is no more state to trace. However, the path that traffic would use if the RP did perform a source-specific join can be traced by setting the trace destination to the RP, the trace source to the traffic source, and the trace group to 0. This trace Query may be unicasted to the RP.</t>
	    </section>

	    <section title="Bi-directional PIM">
	      <t><xref target="refs.Bidir">Bi-directional PIM</xref> is a variant of PIM-SM that builds bi-directional shared trees connecting multicast sources and receivers. Along the bi-directional shared trees, multicast data is natively forwarded from sources to the RPA (Rendezvous Point Address) and from the RPA to receivers without requiring source-specific state. In contrast to PIM-SM, RP always has the state to trace.</t>

	      <t>A Designated Forwarder (DF) for a given RPA is in charge of forwarding downstream traffic onto its link, and forwarding upstream traffic from its link towards the RPL (Rendezvous Point Link) that the RPA belongs to. Hence mtrace2 reports DF addresses or RPA along the path.</t>
	    </section>

	    <section title="CBT">
	      <t>When a multicast traceroute reaches a <xref target="refs.CBT">CBT</xref> Core, it must simply stop since CBT does not have source-specific state. However, a second trace can be performed, setting the trace destination to the traffic source, the trace group to the group being traced, and the trace source to the Core (or to 0, since CBT does not have source-specific state). This trace Query may be unicasted to the Core. There are two possibilities when combining the two traces:</t>

	      <section title="No overlap">
	        <t>If there is no overlap between the two traces, the second trace can be reversed and appended to the first trace. This composite trace shows the full path from the source to the destination.</t>
	      </section>

	      <section title="Overlapping paths">
	        <t>If there is a portion of the path that is common to the ends of the two traces, that portion is removed from both traces. Then, as in the no overlap case, the second trace is reversed and appended to the first trace, and the composite trace again contains the full path.</t>

		<t>This algorithm works whether the source has joined the CBT tree or not.</t>
	      </section>
	    </section>
	  </section>

	  <!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	  <section title="Protocol-specific considerations">
	    <section title="DVMRP">
	      <t>DVMRP's dominant router election and route exchange guarantees that DVMRP routers know whether or not they are the last-hop forwarder for the link and who the previous hop is.</t>
	    </section>

	    <section title="PIM-DM">
	      <t>Routers running PIM Dense Mode do not know the path packets would take unless traffic is flowing. Without some extra protocol mechanism, this means that in an environment with multiple possible paths with branch points on shared media, multicast traceroute can only trace existing paths, not potential paths. When there are multiple possible paths but the branch points are not on shared media, the previous hop router is known, but the last hop router may not know that it is the appropriate last hop.</t>

	      <t>When traffic is flowing, PIM Dense Mode routers know whether or not they are the last-hop forwarder for the link (because they won or lost an Assert battle) and know who the previous hop is (because it won an Assert battle). Therefore, multicast traceroute is always able to follow the proper path when traffic is flowing.</t>
	    </section>
	  </section>

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section title="Problem Diagnosis">

	  <section title="Forwarding Inconsistencies">
	    <t>The forwarding error code can tell if a group is unexpectedly pruned or administratively scoped.</t>
	  </section>

	  <section title="TTL or hop limit problems">
	    <t>By taking the maximum of (hops from source + forwarding TTL (or hop limit) threshold) over all hops, you can discover the TTL required for the source to reach the destination.</t>
	  </section>

	  <section anchor="sec.loss" title="Packet loss">
	    <t>By taking two traces, you can find packet loss information by comparing the difference in input packet counts to the difference in output packet counts at the previous hop.  On a point-to-point link, any difference in these numbers implies packet loss.  Since the packet counts may be changing as the trace query is propagating, there may be small errors (off by 1 or 2) in these statistics. However, these errors will not accumulate if multiple traces are taken to expand the measurement period.  On a shared link, the count of input packets can be larger than the number of output packets at the previous hop, due to other routers or hosts on the link injecting packets.  This appears as "negative loss" which may mask real packet loss.</t>

	    <t>In addition to the counts of input and output packets for all multicast traffic on the interfaces, the response data includes a count of the packets forwarded by a node for the specified source-group pair.  Taking the difference in this count between two traces and then comparing those differences between two hops gives a measure of packet loss just for traffic from the specified source to the specified receiver via the specified group.  This measure is not affected by shared links.</t>

	    <t>On a point-to-point link that is a multicast tunnel, packet loss is usually due to congestion in unicast routers along the path of that tunnel.  On native multicast links, loss is more likely in the output queue of one hop, perhaps due to priority dropping, or in the input queue at the next hop.  The counters in the response data do not allow these cases to be distinguished.  Differences in packet counts between the incoming and outgoing interfaces on one node cannot generally be used to measure queue overflow in the node.</t>
	  </section>

	  <section anchor="sec.util" title="Link Utilization">
	    <t>Again, with two traces, you can divide the difference in the input or output packet counts at some hop by the difference in time stamps from the same hop to obtain the packet rate over the link. If the average packet size is known, then the link utilization can also be estimated to see whether packet loss may be due to the rate limit or the physical capacity on a particular link being exceeded.</t>
	  </section>

	  <section title="Time delay">
	    <t>If the routers have synchronized clocks, it is possible to estimate propagation and queuing delay from the differences between the timestamps at successive hops.  However, this delay includes control processing overhead, so is not necessarily indicative of the delay that data traffic would experience.</t>
	  </section>

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section anchor="sec.iana" title="IANA Considerations">
	  <t>The following new assignments can only be made via a Standards Action as specified <xref target="refs.IANA">in</xref>.</t>

	  <section title="Routing protocols">
	    <t>The IANA is responsible for allocating new Routing Protocol codes. The Routing Protocol code is somewhat problematic, since in the case of protocols like CBT and PIM it must encode both a unicast routing algorithm and a multicast tree-building protocol. The space was not divided into two fields because it was already small and some combinations (e.g. DVMRP) would be wasted.</t>
	  </section>

	  <section title="Forwarding codes">
	    <t>New Forwarding codes must only be created by an RFC that modifies this document's <xref target="sec.use" />, fully describing the conditions under which the new forwarding code is used.  The IANA may act as a central repository so that there is a single place to look up forwarding codes and the document in which they are defined.</t>
	  </section>

	  <section title="UDP destination port and IPv6 address">
	    <t>The IANA should allocate UDP destination port for multicast traceroute version 2 upon publication of the first RFC. Additionally, the well-known multicast address (MTRACE2_IPV6RESPADDR) intended for default use by IPv6 multicast traceroute should be registered and defined by the first RFC published.</t>
	  </section>
	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section title="Security Considerations">

	  <section title="Topology Discovery">
	    <t>Mtrace2 can be used to discover any actively-used topology. If your network topology is a secret, mtrace2 may be restricted at the border of your domain, using the ADMIN_PROHIB forwarding code.</t>
	  </section>

	  <section title="Traffic Rates">
	    <t>Mtrace2 can be used to discover what sources are sending to what groups and at what rates. If this information is a secret, mtrace2 may be restricted at the border of your domain, using the ADMIN_PROHIB forwarding code.</t>
	  </section>

	  <section title="Unicast Replies">
	    <t>The "Response address" field may be used to send a single packet (the traceroute Reply packet) to an arbitrary unicast address. It is possible to use this facility as a packet amplifier, as a small multicast traceroute Query may turn into a large Reply packet.</t>
	  </section>

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

	<section title="Acknowledgements">
	  <t>This specification started largely as a transcription of Van Jacobson's slides from the 30th IETF, and the implementation in mrouted 3.3 by Ajit Thyagarajan. Van's original slides credit Steve Casner, Steve Deering, Dino Farinacci and Deb Agrawal. The original multicast traceroute client, mtrace (version 1), has been implemented by Ajit Thyagarajan, Steve Casner and Bill Fenner.</t>
	  <t>The idea of unicasting a multicast traceroute Query to the destination of the trace with Router Alert set is due to Tony Ballardie. The idea of the "S" bit to allow statistics for a source subnet is due to Tom Pusateri.</t>

<!--	  <t>In addition, extensive comments were received from Yiqun Cai, Liu Hui, Cao Wei.</t>-->

	</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

</middle>

<back>
	<references title="Normative References">
	  <reference anchor="refs.KEYWORDS">
	    <front>
	      <title>Key words for use in RFCs to indicate requirement levels</title>
	      <author initials="S" surname="Bradner" />
	      <date month="March" year="1997" />
	    </front>
	    <seriesInfo name="RFC" value="2119" />
	  </reference>

	  <reference anchor="refs.IPv6">
	    <front>
	      <title>Internet Protocol, Version 6 (IPv6) Specification</title>
	      <author initials="S" surname="Deering" />
	      <author initials="R" surname="Hinden" />
	      <date month="December" year="1998" />
	    </front>
	    <seriesInfo name="RFC" value="2460" />
	  </reference>

	  <reference anchor="refs.IPv6Addr">
	    <front>
	      <title>IP Version 6 Addressing Architecture</title>
	      <author initials="R" surname="Hinden" />
	      <author initials="S" surname="Deering" />
	      <date month="July" year="1998" />
	    </front>
	    <seriesInfo name="RFC" value="2373" />
	  </reference>

	  <reference anchor="refs.IGMPv3">
	    <front>
	      <title>Internet Group Management Protocol, Version 3</title>
	      <author initials="B" surname="Cain" />
	      <author initials="S" surname="Deering" />
	      <author initials="I" surname="Kouvelas" />
	      <author initials="B" surname="Fenner" />
	      <author initials="A" surname="Thyagarajan" />
	      <date month="October" year="2002" />
	    </front>
	    <seriesInfo name="RFC" value="3376" />
	  </reference>

<!--	  <reference anchor="refs.ICMPv6">
	    <front>
	      <title>Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</title>
	      <author initials="A" surname="Conta" />
	      <author initials="S" surname="Deering" />
	      <author initials="M" surname="Gupta" />
	      <date month="March" year="2006" />
	    </front>
	    <seriesInfo name="RFC" value="4443" />
	  </reference>

	  <reference anchor="refs.Mtrace">
	    <front>
	      <title>A "traceroute" facility for IP Multicast</title>
	      <author initials="W" surname="Fenner" />
	      <author initials="S" surname="Casner" />
	      <date month="December" year="2003" />
	    </front>
	    <seriesInfo name="draft-fenner-traceroute-ipm-00.txt" value="(work in progress)" />
	  </reference>-->

	  <reference anchor="refs.IANA">
	    <front>
	      <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
	      <author initials="T" surname="Narten" />
	      <author initials="H" surname="Alvestrand" />
	      <date month="October" year="1998" />
	    </front>
	    <seriesInfo name="RFC" value="2434" />
	  </reference>
	</references>

	<references title="Informative References">
	  <reference anchor="refs.DefRtr">
	    <front>
	      <title>Default Router Preferences and More-Specific Routes</title>
	      <author initials="R" surname="Draves" />
	      <author initials="D" surname="Thaler" />
	      <date month="November" year="2005" />
	    </front>
	    <seriesInfo name="RFC" value="4191" />
	  </reference>

  	  <reference anchor="refs.Cksum">
	    <front>
	      <title>Computing the Internet Checksum</title>
	      <author initials="B" surname="Braden" />
	      <author initials="D" surname="Borman" />
	      <author initials="C" surname="Partridge" />
	      <date month="September" year="1988" />
	    </front>
	    <seriesInfo name="RFC" value="1071" />
	  </reference>

  	  <reference anchor="refs.RA">
	    <front>
	      <title>IP Router Alert Option</title>
	      <author initials="D" surname="Katz" />
	      <date month="February" year="1997" />
	    </front>
	    <seriesInfo name="RFC" value="2113" />
	  </reference>

	  <reference anchor="refs.IFMIB">
	    <front>
	      <title>The Interfaces Group MIB</title>
	      <author initials="K" surname="McCloghrie" />
	      <author initials="F" surname="Kastenholz" />
	      <date month="June" year="2000" />
	    </front>
	    <seriesInfo name="RFC" value="2863" />
	  </reference>

	  <reference anchor="refs.MROUTEMIB">
	    <front>
	      <title>IP Multicast MIB</title>
	      <author initials="D" surname="McWalter" />
	      <author initials="D" surname="Thaler" />
	      <author initials="A" surname="Kessler" />
	      <date month="March" year="2007" />
	    </front>
	    <seriesInfo name="draft-ietf-mboned-ip-mcast-mib-05.txt" value="(work in progress)" />
	  </reference>


	  <reference anchor="refs.PIMSM">
	    <front>
	      <title>Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)</title>
	      <author initials="B" surname="Fenner" />
	      <author initials="M" surname="Handley" />
	      <author initials="H" surname="Holbrook" />
	      <author initials="I" surname="Kouvelas" />
	      <date month="August" year="2006" />
	    </front>
	    <seriesInfo name="RFC" value="4601" />
	  </reference>

<!--	  <reference anchor="refs.PIMDM">
	    <front>
	      <title>Protocol Independent Multicast - Dense Mode (PIM-DM): Protocol Specification (Revised)</title>
	      <author initials="A" surname="Adams" />
	      <author initials="J" surname="Nicholas" />
	      <author initials="W" surname="Siadak" />
	      <date month="January" year="2005" />
	    </front>
	    <seriesInfo name="RFC" value="3973" />
	  </reference>-->

	  <reference anchor="refs.CBT">
	    <front>
	      <title>Core Based Trees (CBT version 2) Multicast Routing -- Protocol Specification --</title>
	      <author initials="T" surname="Ballardie" />
	      <date month="September" year="1997" />
	    </front>
	    <seriesInfo name="RFC" value="2189" />
	  </reference>

<!--	  <reference anchor="refs.Embed">
	    <front>
	      <title>Embedding the Rendezvous Point (RP) Address in an IPv6 Multicast Address</title>
	      <author initials="P" surname="Savola" />
	      <author initials="B" surname="Haberman" />
	      <date month="November" year="2004" />
	    </front>
	    <seriesInfo name="RFC" value="3956" />
	  </reference>-->

	  <reference anchor="refs.Bidir">
	    <front>
	      <title>Bi-directional Protocol Independent Multicast (BIDIR-PIM)</title>
	      <author initials="M" surname="Handley" />
	      <author initials="I" surname="Kouvelas" />
	      <author initials="T" surname="Speakman" />
	      <date month="February" year="2007" />
	    </front>
	    <seriesInfo name="draft-ietf-pim-bidir-09.txt" value="(work in progress)" />
	  </reference>

<!--	  <reference anchor="refs.PIMMIB">
	    <front>
	      <title>Protocol Independent Multicast MIB</title>
	      <author initials="R" surname="Sivaramu" />
	      <author initials="J" surname="Lingard" />
	      <author initials="D" surname="McWalter" />
	      <author initials="B" surname="Joshi" />
	      <date month="December" year="2006" />
	    </front>
	    <seriesInfo name="draft-ietf-pim-mib-v2-09.txt" value="(work in progress)" />
	  </reference>-->
	</references>
</back>

</rfc>

<!--
draft-ietf-mboned-ip-mcast-mib-05.txt
ipMcastRoutePkts


o. case of packet too long: divided (fragmented) and ??
o. case that an intermediate router does not support mtrace: ADMIN_PROHIB
o. 
-->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<!--	<section title="Implementation specific caveats">
	  <t>Some routers with distributed forwarding architectures may not update the main processor's packet counts often enough for the packet counters to be meaningful on a small time scale.  This can be recognized during a periodic trace by seeing positive loss in one trace and negative loss in the next, with no (or small) net loss over a longer interval.  The suggested solution to this problem is to simply collect statistics over a longer interval.</t>

	  <t>In the multicast extensions for SunOS 4.1.x from Xerox PARC, which are the basis for many UNIX-based multicast routers, both the output packet count and the packet forwarding count for the source-group pair are incremented before priority dropping for rate limiting occurs and before the packets are put onto the interface output queue which may overflow. These drops will appear as (positive) loss on the link even though they occur within the router.</t>

	  <t>In release 3.3/3.4 of the UNIX multicast extensions, a multicast packet generated on a router will be counted as having come in an interface even though it did not. This can create the appearance of negative loss even on a point-to-point link.</t>

	  <t>In releases up through 3.5/3.6, packets were not counted as input on an interface if the reverse-path forwarding check decided that the packets should be dropped. That causes the packets to appear as lost on the link if they were output by the upstream hop. This situation can arise when two routers on the path for the group being traced are connected by a shared link, and the path for some other group does not flow between those two routers because the downstream router receives packets for the other group on another interface, but the upstream router is the elected forwarder to other routers or hosts on the shared link.</t>

	  <t>The packet counts for source/group pairs are generally kept in router forwarding caches. These cache entries may be occasionally garbage-collected on routers, so a multicast traceroute client should be prepared to see packet counts decrease.  If a long-running traceroute is keeping a "base" to compare against, it should use the post-reset trace as the new "base", as previous values returned by this hop are no longer valid. In addition, it may choose to discard the data for all other hops to cover the same amount of time for all hops.</t>

	  <t>Some routers (notably the obsolete mrouted 3.3 and 3.4) can constantly reset these packet counts. A client might want to detect routers that are constantly resetting and simply fail to collect statistics for that hop (instead of allowing it to cause all other data to be discarded).</t>

	  <t>Some routers send byte-swapped counter values. If the difference between a pair of measurements is extremely large, a traceroute client may want to see if the difference is more reasonable when byte-swapped. Note that this heuristic may start misfiring when packet rates get high, so implementations may want to only attempt this heuristic when the packet rate is much different on one router than on surrounding routers.</t>

	  <t>Some implementations (e.g. UNIX mrouted 3.8 and before) return incorrect time values; the difference between the time values for the same hop in two traces may have no relationship with the amount of time that passed between making the traces.  Implementations should check that time values look valid before using them.</t>

	</section>
-->
