


Internet Engineering Task Force                                  A. Ford
Internet-Draft                                       Roke Manor Research
Intended status: Experimental                                  C. Raiciu
Expires: January 13, 2011                                     M. Handley
                                               University College London
                                                           July 12, 2010


     TCP Extensions for Multipath Operation with Multiple Addresses
                   draft-ietf-mptcp-multiaddressed-01

Abstract

   TCP/IP communication is currently restricted to a single path per
   connection, yet multiple paths often exist between peers.  The
   simultaneous use of these multiple paths for a TCP/IP session would
   improve resource usage within the network, and thus improve user
   experience through higher throughput and improved resilience to
   network failure.

   Multipath TCP provides the ability to simultaneously use multiple
   paths between peers.  This document presents a set of extensions to
   traditional TCP to support multipath operation.  The protocol offers
   the same type of service to applications as TCP - reliable bytestream
   - and provides the components necessary to establish and use multiple
   TCP flows across potentially disjoint paths.

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on January 13, 2011.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.



Ford, et al.            Expires January 13, 2011                [Page 1]

Internet-Draft                Multipath TCP                    July 2010


   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.










































Ford, et al.            Expires January 13, 2011                [Page 2]

Internet-Draft                Multipath TCP                    July 2010


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  Design Assumptions . . . . . . . . . . . . . . . . . . . .  4
     1.2.  Multipath TCP in the Networking Stack  . . . . . . . . . .  5
     1.3.  Operation Summary  . . . . . . . . . . . . . . . . . . . .  6
     1.4.  Requirements Language  . . . . . . . . . . . . . . . . . .  7
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  7
   3.  MPTCP Protocol . . . . . . . . . . . . . . . . . . . . . . . .  8
     3.1.  Connection Initiation  . . . . . . . . . . . . . . . . . .  8
     3.2.  Starting a New Subflow . . . . . . . . . . . . . . . . . . 10
     3.3.  General MPTCP Operation  . . . . . . . . . . . . . . . . . 12
       3.3.1.  Data Sequence Numbering  . . . . . . . . . . . . . . . 12
       3.3.2.  Data Acknowledgements  . . . . . . . . . . . . . . . . 15
       3.3.3.  Receiver Considerations  . . . . . . . . . . . . . . . 16
       3.3.4.  Sender Considerations  . . . . . . . . . . . . . . . . 17
       3.3.5.  Congestion Control Considerations  . . . . . . . . . . 18
       3.3.6.  Subflow Policy . . . . . . . . . . . . . . . . . . . . 19
     3.4.  Closing a Connection . . . . . . . . . . . . . . . . . . . 20
     3.5.  Address Knowledge Exchange (Path Management) . . . . . . . 21
       3.5.1.  Address Advertisement  . . . . . . . . . . . . . . . . 22
       3.5.2.  Remove Address . . . . . . . . . . . . . . . . . . . . 25
     3.6.  Fallback . . . . . . . . . . . . . . . . . . . . . . . . . 26
     3.7.  Error Handling . . . . . . . . . . . . . . . . . . . . . . 29
     3.8.  Heuristics . . . . . . . . . . . . . . . . . . . . . . . . 29
       3.8.1.  Port Usage . . . . . . . . . . . . . . . . . . . . . . 29
   4.  Semantic Issues  . . . . . . . . . . . . . . . . . . . . . . . 30
   5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 31
   6.  Interactions with Middleboxes  . . . . . . . . . . . . . . . . 32
   7.  Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . 35
   8.  Open Issues  . . . . . . . . . . . . . . . . . . . . . . . . . 36
   9.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 37
   10. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 37
   11. References . . . . . . . . . . . . . . . . . . . . . . . . . . 37
     11.1. Normative References . . . . . . . . . . . . . . . . . . . 37
     11.2. Informative References . . . . . . . . . . . . . . . . . . 38
   Appendix A.  Notes on use of TCP Options . . . . . . . . . . . . . 39
   Appendix B.  Resync Packet . . . . . . . . . . . . . . . . . . . . 40
   Appendix C.  Changelog . . . . . . . . . . . . . . . . . . . . . . 41
     C.1.  Changes since draft-ietf-mptcp-multiaddressed-00 . . . . . 41
     C.2.  Changes since draft-ford-mptcp-multiaddressed-03 . . . . . 42
     C.3.  Changes since draft-ford-mptcp-multiaddressed-02 . . . . . 42
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 42








Ford, et al.            Expires January 13, 2011                [Page 3]

Internet-Draft                Multipath TCP                    July 2010


1.  Introduction

   Multipath TCP (henceforth referred to as MPTCP) is a set of
   extensions to regular TCP [2] to allow a transport connection to
   operate across multiple paths simultaneously.  This document presents
   the protocol changes required to add multipath capability to TCP;
   specifically, those for signalling and setting up multiple paths
   ("subflows"), managing these subflows, reassembly of data, and
   termination of sessions.  This is not the only information required
   to create a Multipath TCP implementation, however.  This document is
   complemented by several others:

   o  Architecture [3], which explains the motivations behind Multipath
      TCP, contains a discussion of high-level design decisions on which
      this design is based, and an explanation of a functional
      separation through which an extensible MPTCP implementation can be
      developed.

   o  Congestion Control [4], presenting a safe congestion control
      algorithm for coupling the behaviour of the multiple paths in
      order to "do no harm" to other network users.

   o  Application Considerations [5], discussing what impact MPTCP will
      have on applications, what applications will want to do with
      MPTCP, and as a consequence of these factors, what API extensions
      an MPTCP implementation should present.

1.1.  Design Assumptions

   In order to limit the potentially huge design space, the authors
   imposed two key constraints on the multipath TCP design presented in
   this document:

   o  It must be backwards-compatible with current, regular TCP, to
      increase its chances of deployment

   o  It can be assumed that one or both endpoints are multihomed and
      multiaddressed

   To simplify the design we assume that the presence of multiple
   addresses at an endpoint is sufficient to indicate the existence of
   multiple paths.  These paths need not be entirely disjoint: they may
   share one or many routers between them.  Even in such a situation
   making use of multiple paths is beneficial, improving resource
   utilisation and resilience to a subset of node failures.  The
   congestion control algorithms as discussed in [4] ensure this does
   not act detrimentally.




Ford, et al.            Expires January 13, 2011                [Page 4]

Internet-Draft                Multipath TCP                    July 2010


   There are three aspects to the backwards-compatibility listed above
   (discussed in more detail in [3]):

   External Constraints:  The protocol must function through the vast
      majority of existing middleboxes such as NATs, firewalls and
      proxies, and as such must resemble existing TCP as far as possible
      on the wire.  Furthermore, the protocol must not assume the
      segments it sends on the wire arrive unmodified at the
      destination: they may be split or coalesced; options may be
      removed or duplicated.

   Application Constraints:  The protocol must be usable with no change
      to existing applications that use the standard TCP API (although
      it is reasonable that not all features would be available to such
      legacy applications).  Furthermore, the protocol must provide the
      same service model as regular TCP to the application.

   Fall-back:  The protocol should be able to fall back to standard TCP
      with no interference from the user, to be able to communicate with
      legacy hosts.

   Areas for further study:

   o  In theory, since this is purely a TCP extension, it should be
      possible to use MPTCP with both IPv4 and IPv6 subflows for the
      same connection on dual-stack hosts, thus having the additional
      possible benefit of aiding transition.

   o  The design presented should work with network provided multipath,
      for instance ECMP routing; subflows could be opened with different
      source/destination ports between the same addreses to allow ECMP
      to place the subflows on different paths.

1.2.  Multipath TCP in the Networking Stack

   MPTCP operates at the transport layer and aims to be transparent to
   both higher and lower layers.  It is a set of additional features on
   top of standard TCP; Figure 1 illustrates this layering.  MPTCP is
   designed to be usable by legacy applications with no changes;
   detailed discussion of its interactions with applications is given in
   [5].










Ford, et al.            Expires January 13, 2011                [Page 5]

Internet-Draft                Multipath TCP                    July 2010


                                   +-------------------------------+
                                   |           Application         |
      +---------------+            +-------------------------------+
      |  Application  |            |             MPTCP             |
      +---------------+            + - - - - - - - + - - - - - - - +
      |      TCP      |            | Subflow (TCP) | Subflow (TCP) |
      +---------------+            +-------------------------------+
      |      IP       |            |       IP      |      IP       |
      +---------------+            +-------------------------------+

      Figure 1: Comparison of Standard TCP and MPTCP Protocol Stacks

   Detailed discussion of an architecture for developing a multipath TCP
   implementation, especially regarding the functional separation by
   which different components should be developed, is given in [3].

1.3.  Operation Summary

   This section provides a high-level summary of normal operation of
   MPTCP, and is illustrated by the scenario shown in Figure 2.  A
   detailed description of operation is given in Section 3.

   o  To a non-MPTCP-aware application, MPTCP will behave the same as
      normal TCP.  Extended APIs could provide additional control to
      MPTCP-aware applications [5].  An application begins by opening a
      TCP socket in the normal way.  MPTCP signaling and operation is
      handled by the MPTCP implementation.

   o  An MPTCP connection begins similarly to a regular TCP connection.
      This is illustrated in Figure 2 where a TCP connection is
      established between addresses A1 and B1 on Hosts A and B
      respectively.

   o  If extra paths are available, additional TCP sessions (termed
      "subflows") are created on these paths, and are combined with the
      existing session, which continues to appear as a single connection
      to the applications at both ends.  The creation of the additional
      TCP session is illustrated between Address A2 on Host A and
      Address B1 on Host B.

   o  MPTCP identifies multiple paths by the presence of multiple
      addresses at endpoints.  Combinations of these multiple addresses
      equate to the additional paths.  In the example, other potential
      paths that could be set up are A1<->B2 and A2<->B2.  Although this
      additional session is shown as being initiated from A2, it could
      equally have been initiated from B1.





Ford, et al.            Expires January 13, 2011                [Page 6]

Internet-Draft                Multipath TCP                    July 2010


   o  The discovery and setup of additional subflows will be achieved
      through a path management method.  This document describes a
      mechanism by which an endpoint can initiate new subflows by using
      its own additional addresses, or by signalling its available
      addresses to the other endpoint.

   o  MPTCP adds connection-level sequence numbers to allow the
      reassembly of the in-order data stream from multiple subflows
      which may deliver packets out-of-order due to differing network
      delays.

   o  Subflows are terminated as regular TCP connections, with a four
      way FIN handshake.  The MPTCP connection is terminated by a
      connection-level FIN packet, sent together with the FIN on the
      last subflow of the connection.


               Host A                               Host B
      ------------------------             ------------------------
      Address A1    Address A2             Address B1    Address B2
      ----------    ----------             ----------    ----------
          |             |                      |             |
          |     (initial connection setup)     |             |
          |----------------------------------->|             |
          |<-----------------------------------|             |
          |             |                      |             |
          |            (additional subflow setup)            |
          |             |--------------------->|             |
          |             |<---------------------|             |
          |             |                      |             |
          |             |                      |             |

                  Figure 2: Example MPTCP Usage Scenario

1.4.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].


2.  Terminology

   Path:  A sequence of links between a sender and a receiver, defined
      in this context by a source and destination address pair.






Ford, et al.            Expires January 13, 2011                [Page 7]

Internet-Draft                Multipath TCP                    July 2010


   Subflow:  A stream of TCP packets sent over a path, started and
      terminated similarly to a regular TCP connection.

   (MPTCP) Connection:  A collection of one or more subflows, over which
      an application can communicate between two endpoints.  There is a
      one-to-one mapping between a connection and an application socket.

   Data-level:  The payload data is nominally transfered over a
      connection, which in turn is transported over subflows.  Thus the
      term "data-level" is synonymous with "connection level", in
      contrast to "subflow-level" which refers to properties of an
      individual subflow.

   Token:  A locally unique identifier given to a multipath connection
      by an endpoint.  May also be referred to as a "Connection ID".

   Endpoint:  A host operating an MPTCP implementation, and either
      initiating or accepting an MPTCP connection.


3.  MPTCP Protocol

   This section describes the operation of the MPTCP protocol, and is
   subdivided into sections for each key part of the protocol operation.

   All MPTCP operations are signalled using optional TCP header fields.
   These TCP Options will have option numbers allocated by IANA, as
   listed in Section 10, and are defined throughout the following
   subsections.

3.1.  Connection Initiation

   Connection Initiation begins with a SYN, SYN/ACK exchange on a single
   path.  Each packet contains the Multipath Capable (MP_CAPABLE) TCP
   option (Figure 3).  This option declares its sender is capable of
   performing multipath TCP and wishes to do so on this particular
   connection.  Each host includes in the MP_CAPABLE option a locally-
   unique token that identifies this connection.  This is used when
   adding additional subflows to this connection.

   This token is generated by the sender and has local meaning only,
   hence it MUST be unique for the sender.  The token MUST be difficult
   for an attacker to guess, and thus it is recommended it SHOULD be
   generated randomly.  (However, see further discussions about security
   in Section 5, including the possibility of 64-bit tokens.)

   The MP_CAPABLE option is only present in packets with the SYN flag
   set.  It is only used in the first TCP session of a connection, in



Ford, et al.            Expires January 13, 2011                [Page 8]

Internet-Draft                Multipath TCP                    July 2010


   order to identify the connection; all following subflows will use the
   "Join" option (see Section 3.2) to join the existing connection.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+-------------------------------+
      |Kind=MP_CAPABLE|   Length=12   |       Sender Token            :
      +---------------+---------------+-------------------------------+
      : Sender Token (4 bytes total)  | Initial Data Sequence Number  :
      +-------------------------------+-------------------------------+
      :        Initial Data Sequence Number  (6 bytes total)          |
      +---------------------------------------------------------------+


    Figure 3: Multipath Capable (MP_CAPABLE) option (only valid on SYN
                                 packets)

   If a SYN contains an MP_CAPABLE option but the SYN/ACK does not, it
   is assumed that the passive opener is not multipath capable and thus
   the MPTCP session will operate as regular, single-path TCP.  If a SYN
   does not contain a MP_CAPABLE option, the SYN/ACK MUST NOT contain
   one in response.

   If the SYN packets are unacknowledged, it is up to local policy to
   decide how to respond.  It is expected that a sender will eventually
   fall back to single-path TCP (i.e. without the MP_CAPABLE Option) in
   order to work around middleboxes that may drop packets with unknown
   options; however, the number of multipath-capable attempts that are
   made first will be up to local policy.  Once the active opener has
   sent a SYN without the MP_CAPABLE option, it MUST fall back to
   regular TCP behavior, even if it subsequently receives a SYN/ACK that
   contains an MP_CAPABLE option.  This might happen if the MP_CAPABLE
   SYN and subsequent non-MP-capable SYN are reordered.  This is to
   ensure that the two endpoints end up in an interoperable state, no
   matter what order the SYNs arrive at the passive opener.  This final
   state is inferred from the presence or absence of the DATA_ACK option
   in the third packet of the TCP handshake.

   The MP_CAPABLE option includes the most significant 6 bytes of the
   8-byte initial Data Sequence Number option (discussed in
   Section 3.3).  The least significant two bytes should be treated as
   being zero.  This data sequence number maps the SYN into to the data
   sequence space (and this initial SYN occupies one octet of this
   space, as for a regular SYN in single-path TCP).  Having the SYN
   occupy sequence space means that it must be DATA_ACKed, and this
   ensures that there is two-way agreement on whether or not the
   multipath capability is enabled, even if a middlebox were to strip
   the MP_CAPABLE option from a SYN/ACK packet.



Ford, et al.            Expires January 13, 2011                [Page 9]

Internet-Draft                Multipath TCP                    July 2010


   To preserve option space, only the most significant six bytes of the
   data sequence number are sent in the SYN, as there is no significant
   security benefit from randomizing the values of the lower two bytes
   given that these fall within typical receive window sizes.

3.2.  Starting a New Subflow

   Once a MPTCP connection has begun with the MP_CAPABLE exchange,
   further subflows can be added to the connection.  Endpoints have
   knowledge of their own address(es), and can become aware of the other
   endpoint's addresses through signalling exchanges as described in
   Section 3.5.  Using this knowledge, an endpoint can initiate a new
   subflow over a currently unused pair of addresses.  The protocol
   permits either endpoint of a connection to initiate the creation of a
   new subflow (but see Section 3.8 for heuristics)

   A new subflow is started as a normal TCP SYN/ACK exchange.  The Join
   Connection (MP_JOIN)) TCP option (Figure 4) is used to identify the
   connection to be joined by the new subflow.  The receiver token sent
   MUST be the other endpoint's locally unique connection token, which
   was included in the MP_CAPABLE option during connection
   establishment.  The MP_JOIN option MUST only be present on SYN
   packets.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+-------------------------------+
      | Kind=MP_JOIN  |  Length = 7   |Receiver Token (4 octets total):
      +---------------+---------------+----------------+--------------+
      :  Receiver Token (continued)   |   Address ID   |
      +-------------------------------+----------------+

       Figure 4: Join Connection (MP_JOIN) option (only valid on SYN
                                 packets)

   TBD: A better security mechanism that just the token is required
   here, in order to prove that the sender of the SYN/MP_JOIN is the
   same sender as that who sent the original SYN/MP_CAPABLE.  Hash
   chains are considered an appropriate solution, and the mechanism will
   be described in detail in a later version of this document.

   When receiving a SYN with the MP_JOIN option that contains a valid
   token for an existing MPTCP connection, the recipient SHOULD respond
   with a SYN/ACK also containing an MP_JOIN option containing the
   initiator's token.  This behaviour is illustrated in Figure 5.






Ford, et al.            Expires January 13, 2011               [Page 10]

Internet-Draft                Multipath TCP                    July 2010


               Host A                               Host B
      ------------------------             ------------------------
      Address A1    Address A2             Address B1    Address B2
      ----------    ----------             ----------    ----------
          |             |                      |             |
          |     SYN + MP_CAPABLE(Token A)      |             |
          |----------------------------------->|             |
          |<-----------------------------------|             |
          |   SYN/ACK + MP_CAPABLE(Token B)    |             |
          |             |                      |             |
          |             |       SYN + MP_JOIN(Token B)       |
          |             |----------------------------------->|
          |             |<-----------------------------------|
          |             |     SYN/ACK + MP_JOIN(Token A)     |
          |             |                      |             |

                   Figure 5: Example use of MPTCP Tokens

   If the token received at Host B is unknown or local policy prohibits
   the acceptance of the new subflow, the recipient MUST respond with a
   TCP RST.

   If the token is accepted at Host B, but the token returned to Host A
   is not the one expected, Host A MUST close the subflow with a TCP
   RST.

   The echoing of the token serves two purposes: it ensures both
   endpoints agree on the connection being referred to (this is
   particularly relevant when both addresses being used are new to the
   connection); and it ensures there are no middleboxes on the path that
   will drop MPTCP options on the return path.

   If the SYN/ACK as received at Host A does not have an MP_JOIN option,
   Host A MUST close the subflow with a RST.

   If MP_JOIN is stripped from the SYN on the path from A to B, and Host
   B does not have a passive opener on the relevant port, it will
   respond with an RST in the normal way.  If in response to a SYN with
   an MP_JOIN option, a SYN/ACK is received without the MP_JOIN option
   (either since it was stripped on the return path, or it was stripped
   on the outgoing path but the passive opener on Host B responded as if
   it was a new regular TCP session), then the subflow is unusable and
   Host A MUST close it with a RST.

   It should be noted that additional subflows can be created between
   any pair of ports (but see Section 3.8 for heuristics); no explicit
   application-level accept calls or bind calls are required to open
   additional subflows.  To associate a new subflow with an existing



Ford, et al.            Expires January 13, 2011               [Page 11]

Internet-Draft                Multipath TCP                    July 2010


   connection, the token supplied in the subflow's SYN exchange is used
   for demultiplexing.  This then binds the 5-tuple of the TCP subflow
   to the local token of the connection.  A consequence is that it is
   possible to allow any port pairs to be used for a connection.

   Deumultiplexing subflow SYNs MUST be done using the token; this is
   unlike traditional TCP, where the destination port is used for
   demultiplexing SYN packets.  Once a subflow is setup, demultiplexing
   packets is done using the five-tuple, as in traditional TCP.  The
   five-tuples will be mapped to the local connection ID.

   The MP_JOIN option includes an "Address ID".  This is an identifier
   that is locally unique to the sender of this option.  It has only
   significance withing a single connection, where it identifies the
   source address of this packet.  The key purpose of this identifier is
   to allow address removal without needing to know what the source
   address actually is, thus allowing the use of NATs), when the subflow
   is no longer available.  The sender can signal this to the receiver
   via the REMOVE_ADDR option (Section 3.5.2).  It also allows
   correlation between new subflow setup attempts and address signalling
   (Section 3.5.1), to prevent setting up duplicate subflows on the same
   path.

   The Address IDs of the subflow used in the initial SYN exchange of
   the first subflow in the connection are implicit, and have the value
   zero.

   The Address ID must be stored by the receiver in a data structure
   that gathers all the Address ID to address mappings for a connection
   identified by a token pair.  In this way there is a stored mapping
   between Address ID, observed source address and token pair for future
   processing of control information for a connection.

3.3.  General MPTCP Operation

   This section discusses operation of MPTCP for data transfer.  At a
   high level, an MPTCP implementation will take one input data stream
   from an application, and split it into one or more subflows, with
   sufficient control information to allow it to be reassembled and
   delivered reliably and in-order to the recipient application.  The
   following subsections define this behaviour in detail.

3.3.1.  Data Sequence Numbering

   The data stream as a whole can be reassembled through the use of the
   Data Sequence Mapping (DSN_MAP, Figure 6) option, which defines the
   mapping from the data sequence number to the subflow sequence number.
   This is used by the receiver to ensure in-order delivery to the



Ford, et al.            Expires January 13, 2011               [Page 12]

Internet-Draft                Multipath TCP                    July 2010


   application layer.  Meanwhile, the subflow-level sequence numbers
   (i.e. the regular sequence numbers in the TCP header) have subflow-
   only relevance.  It is expected (but not mandated) that SACK [6] is
   used at the subflow level to improve efficiency.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+------------------------------+
      | Kind=DSN_MAP  |    Length     |     Data Sequence Number ... :
      +---------------+---------------+------------------------------+
      : ... ( (length-12) octets )    | Data-level Length (2 octets) |
      +-------------------------------+------------------------------+
      |              Subflow Sequence Number (4 octets)              |
      +--------------------------------------------------------------+
      |                      CRC-32C (4 octets)                      |
      +--------------------------------------------------------------+

             Figure 6: Data Sequence Mapping (DSN_MAP) option

   This option specifies a full mapping from data sequence number to
   subflow sequence number, informing the receiver that there is a one-
   to-one correspondence between the two sequence spaces for the
   specified length (number of bytes of data).  The purpose of the
   explicit mapping is to assist with compatibility with situations
   where TCP/IP segmentation or coalescing is undertaken separately from
   the stack that is generating the data flow (e.g. through the use of
   TCP segmentation offloading on network interface cards, or by
   middleboxes such as performance enhancing proxies).  It also allows a
   single mapping to cover many packets, which may be useful in bulk
   transfer situations.

   The data sequence number specified in this option is absolute,
   whereas the subflow sequence numbering is relative (the SYN at the
   start of the subflow has relative subflow sequence number 1).  This
   is allow middleboxes to change the Initial Sequence Number of a
   subflow, since the data stream itself will not be affected (some
   firewalls do ISN randomization).

   The final four octets of this option contain a checksum of the data
   that this mapping covers.  This is a CRC-32C checksum, the same as
   used in SCTP [7].  This is used to detect if the payload has been
   adjusted in any way by a non-MPTCP-aware middlebox.  If this checksum
   fails, it will trigger a failure of the subflow, or a fallback to
   regular TCP, as documented in Section 3.6.

   TBD: Is this the most appropriate checksum, or would the IP checksum
   algorithm be more appropriate?




Ford, et al.            Expires January 13, 2011               [Page 13]

Internet-Draft                Multipath TCP                    July 2010


   A mapping is unique, in that the subflow sequence number is bound to
   the data sequence number after the mapping has been processed.  It is
   not possible to change this mapping afterwards (although the length
   of a mapping can extend); however, the same data sequence number can
   be mapped on different subflows for retransmission purposes (see
   Section 3.3.4).

   To avoid possible deadlock scenarios, subflow-level processing should
   be undertaken separately from that at connection-level.  Therefore,
   even if a mapping does not exist from the subflow space to the data-
   level space, the data should still be ACKed at the subflow.  This
   data cannot, however, be acknowledged at the data level
   (Section 3.3.2) because its data sequence numbers are unknown.
   Implementations MAY hold onto such unmapped data for a short while in
   the expectation than a mapping will arrive shortly.  Such unmapped
   data cannot be counted as being within the receive window because
   this is relative to the data sequence numbers, so if the receiver
   runs out of memory to hold this data, it will have to be discarded.
   If a mapping for that subflow-level sequence space does not arrive
   within a receive window of data, that subflow should be treated as
   broken, closed with an RST, and an unmapped data silently discarded.

   Data sequence numbers are always 64-bit quantities, and MUST be
   maintained as such in implementations.  If a connection is
   progressing at a slow rate, so protection against wrapped sequence
   numbers is not required, and if security requirements against blind
   insertion attacks are not stringent, then it is permissible to
   include just the lower 32 bits of the sequence number in the DSN_MAP
   option as an optimization.  Implementations MUST accept this and
   implicitly promote it to a 64-bit quantity by incrementing the upper
   32 bits of sequence number each time the lower 32 bits wrap.  By
   defauly, the full 64 bit DSN_MAP should be sent.  Security
   implications are discussed in Section 5.

   As with the standard TCP sequence number, the data sequence number
   should not start at zero, but at a random value to make blind session
   hijacking harder.  This is done by including the most significant six
   octets of the initial data sequence number in the MP_CAPABLE option
   in the initial connection SYN (which itself occupies one octet of
   data sequence space; see Section 3.1).

   The DSN_MAP option does not need to be included in every MPTCP
   packet, as long as the subflow sequence space in that packet is
   covered by a mapping known at the receiver.  This can be used to
   reduce overhead in cases where the mapping is known in advance; one
   such case is when there is a single subflow between the endpoints,
   another is when segments of data are scheduled in larger than packet-
   sized chunks.  An "infinite" mapping can be used to fallback to



Ford, et al.            Expires January 13, 2011               [Page 14]

Internet-Draft                Multipath TCP                    July 2010


   regular TCP by mapping the subflow-level data to the connection-level
   data for the remainder of the connection (see Section 3.6).  This is
   achieved by setting the data-level length field to the reserved value
   of 0.

3.3.2.  Data Acknowledgements

   To provide full end-to-end resilience, MPTCP provides a connection-
   level acknowledgement, the DATA_ACK, illustrated in Figure 7, to act
   as a cumulative ACK for the connection as a whole.  This is analogous
   to the behaviour of the standard TCP cumulative ACK in TCP SACK -
   indicating how much data has been successfully received (with no
   holes).

   The rationale for the inclusion of the DATA_ACK includes the
   existence of certain middleboxes that pro-actively ACK packets, and
   thus might cause deadlock conditions if data were acked at the
   subflow level but then fails to reach the receiver.  This sort of bad
   interaction might be expecially prevalent when the receiver is
   mobile.  The DATA_ACK ensures the data has been delieverd to the
   receiver.

   An MPTCP sender MUST only free data from the send buffer when it has
   been acknowledged by both a DATA_ACK received on any subflow and at
   the subflow level by any subflows the data was sent on.  The former
   condition ensures liveness of the connection and the latter condition
   ensures liveness and self-consistence of a subflow when data needs to
   be restransmited.

   The DATA_ACK option MAY be included in all segments, analogous to a
   standard TCP ACK.  However, optimisations SHOULD be considered in
   more advanced implementations, where the DATA_ACK option is present
   in segments (data or pure ACKs) only when the DATA_ACK advances, and
   this behaviour MUST be treated as valid.  This behaviour ensures the
   sender buffer is freed, while reducing overhead when the data
   transfer is unidirectional.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+------------------------------+
      | Kind=DATA_ACK |    Length     |     Data Sequence Number ... :
      +---------------+---------------+------------------------------+
      : ... ( (length-2) octets )     |
      +-------------------------------+

           Figure 7: Connection-level Acknowledgement (DATA_ACK)





Ford, et al.            Expires January 13, 2011               [Page 15]

Internet-Draft                Multipath TCP                    July 2010


3.3.3.  Receiver Considerations

   Regular TCP advertises a receive window in each packet, telling the
   sender how much data the receiver is willing to accept past the
   cumulative ack.  The receive window is used to implement flow
   control, throttling down fast senders when receivers cannot keep up.

   MPTCP also uses a unique receive window, shared between the subflows.
   The idea is to allow any subflow to send data as long as the receiver
   is willing to accept it; the alternative, maintaining per subflow
   receive windows, could end-up stalling some subflows while others
   would not use up their window.

   The receive window is relative to the DATA_ACK.  As in TCP, a
   receiver MUST NOT shrink the right edge of the receive window (e.g.
   DATA_ACK + receive window).  The receiver will use the Data Sequence
   Number to tell if a packet should be accepted at connection level.

   When deciding to accept packets at subflow level, normal TCP uses the
   sequence number in the packet and checks it against the allowed
   receive window.  With multipath, such a check is done using only the
   connection level window.  A sanity check could be performed at
   subflow level to ensure that: SSN - SUBFLOW_ACK <= DSN - DATA_ACK.

   When should segments be processed at connection level?  An
   implementation might wait until they arrive in order at subflow
   level, and only then do connection level processing.  However, if
   many segments of data are restransmitted on more than one subflow,
   then because some data is duplicated then the sum total of
   unacknowledged data on all subflows might exceed the receive window
   that was advertised, which indicates buffering available for data
   sequence space.  This such a strategy is probably undesirable.

   An alternative implementation might process segments at the
   connection level segments that have not yet been acked at subflow
   level; the only requirement for this is to have a valid data sequence
   mapping for the segment.  This removes such duplicate data from the
   receive buffer, so avoids running out of buffer space.  Such
   implementations SHOULD keep track of which subflow sequence numbers
   have already been accepted in this way, so they can be ACKed
   appropriately when the hole in the subflow sequence space in
   subsequently filled.  An implementation that does store such metadata
   would still progress (the rules for freeing data at the sender ensure
   this), but unnecessary retransmissions will result.

   It is important for implementers to understand how large a receiver
   buffer is appropriate.  The lower bound for full network utilization
   is the maximum bandwidth-delay product of any of the paths.  However



Ford, et al.            Expires January 13, 2011               [Page 16]

Internet-Draft                Multipath TCP                    July 2010


   this might be insufficient when a packet is lost on a slower subflow
   and needs to be retransmitted (see Section 3.3.4).  A tight upper
   bound would be the maximum RTT of any path multiplied by the total
   bandwidth available across all paths.  This permits all subflows to
   continue at full speed while a packet is fast-retransmitted on the
   maximum RTT path.  Even this might be insufficient to maintain full
   performance in the event of a retransmit timeout on the maximum RTT
   path.  It is for future study to determine the relationship between
   retransmission strategies and receive buffer sizing.

3.3.4.  Sender Considerations

   The sender remembers receiver window advertisements from the
   receiver.  It should only update its local receive window values when
   the largest sequence number allowed (i.e.  DATA_ACK + receive window)
   increases.  This is important to allow using paths with different
   RTTs, and thus different feedback loops.

   Some classes of middleboxes may alter the TCP-level receive window.
   Typically these will shrink the offered window, although for short
   periods of time it may be possible for the window to be larger
   (however note that this would not continue for long periods since
   ultimately the middlebox must keep up with delivering data to the
   receiver).  Therefore, if receive window sizes differ on multiple
   subflows, when sending data MPTCP SHOULD take the largest of the most
   recent window sizes as the one to use in calculations. (this rule is
   implicit in the requirement not to move back the right edge of the
   window).

   The sender also remembers the receive windows advertised by each
   subflow.  The allowed window for subflow i is (ack_i, ack_i +
   rcv_wnd_i), where ack_i is the subflow-level cumulative ack of
   subflow i.  This ensures data will not be sent to a middlebox unless
   there is enough buffering for the data.

   Putting the two rules together, we get the following: a sender is
   allowed to send data segments with data-level sequence numbers
   between (DATA_ACK, DATA_ACK + receive_window).  Each of these
   segments will be mapped onto subflows, as long as subflow sequence
   numbers are in the the allowed windows for those subflows.  Note that
   subflow sequence numbers do not generally affect flow control if the
   same receive window is advertised across all subflows.  They will
   perform flow control for those subflows with a smaller advertised
   receive window.

   The data sequence mapping allows senders to re-send data with the
   same data sequence number on a different subflow.  When doing this,
   an endpoint must still retransmit the original data on the original



Ford, et al.            Expires January 13, 2011               [Page 17]

Internet-Draft                Multipath TCP                    July 2010


   subflow, in order to preserve the subflow integrity (middleboxes
   could replay old data, and/or could reject holes in subflows), and a
   receiver will ignore these retransmissions.  While this is clearly
   suboptimal, for compatibility reasons this is the best behaviour.
   Optimisations could be negotiated in future versions of this
   protocol.

   This protocol specification does not mandate any mechanisms for
   handling retransmissions, and much will be dependent upon local
   policy (as discussed in Section 3.3.6).  One can imagine aggressive
   connection level retransmissions policies where every packet lost at
   subflow level is retransmitted on a different subflow (hence wasting
   bandwidth but possibly reducing application-to-application delays),
   or conservative retransmission policies where connection-level
   retransmits are only used after a few subflow level retransmission
   timeouts occur.

   It is envisaged that a standard connection-level retransmission
   mechanism would be implemented around a connection-level data queue:
   all segments that haven't been DATA_ACKed are stored.  A timer (based
   on the subflow timer values) is set when the head of the connection-
   level is ACKed at subflow level but its corresponding data is not
   acked at data level.

   The sender MUST keep data in its send buffer as long as the data has
   not been acked at connection level and on all subflows it has been
   sent on.  In this way, the sender can always retransmit the data if
   needed, on the same subflow or on a different one.  A special case is
   when a subflow fails: the sender will typically resend the data on
   other working subflows, and will keep trying to retransmit the data
   on the failed subflow too.  The sender will declare the subflow
   failed after a predefined upper bound on retransmissions is reached,
   and only then delete the outstanding data segments.

   A sender will maintain connection level timers for unacknowledged
   segments.  These timers will be based on the subflow timers, and will
   guard against pro-active acking by middleboxes.

   The send buffer must be, at the minimum, as big as the receive
   buffer, to enable the sender to reach maximum throughput.

3.3.5.  Congestion Control Considerations

   Different subflows in an MPTCP connection have different congestion
   windows.  To achieve fairness at bottlenecks and resource pooling, it
   is necessary to couple the congestion windows in use on each subflow,
   in order to push most traffic to uncongested links.  One algorithm
   for achieving this is presented in [4]; the algorithm does not



Ford, et al.            Expires January 13, 2011               [Page 18]

Internet-Draft                Multipath TCP                    July 2010


   achieve perfect resource pooling but is "safe" in that it is readily
   deployable in the current Internet.

   It is foreseeable that different congestion controllers will be
   implemented for MPTCP, each aiming to achieve different properties in
   the resource pooling/fairness/stability design space.  Much research
   is expected in this area in the near future.

   Regardless of the algorithm used, the design of the MPTCP protocol
   aims to provide the congestion control implementations sufficient
   information to take the right decisions; this information includes,
   for each subflow, which packets where lost and when.

3.3.6.  Subflow Policy

   Within a local MPTCP implementation, a host may use any local policy
   it wishes to decide how to share the traffic to be sent over the
   available paths.

   In the typical use case, where the goal is to maximise throughput,
   all available paths will be used simultaneously for data transfer,
   using coupled congestion control as described in [4].  It is
   expected, however, that other use cases will appear.

   For instance, a possibility is an 'all-or-nothing' approach, i.e.
   have a second path ready for use in the event of failure of the first
   path, but alternatives could include entirely saturating one path
   before using an additional path (the 'overflow' case).  Such choices
   would be most likely based on the monetary cost of links, but may
   also be based on properties such as the delay or jitter of links,
   where stability is more important than throughput.  Application
   requirements such as these are discussed in detail in [5].

   The ability to make effective choices at the sender requires full
   knowledge of the path "cost", which is unlikely to be the case.
   There is no mechanism in MPTCP for a receiver to signal their own
   particular preferences for paths, but this is a necessary feature
   since receivers will often be the multihomed party, and may have to
   pay for metered incoming bandwidth.  Instead of incorporating complex
   signalling, it is proposed to use existing TCP features to signal
   priority implicitly.  If a receiver wishes to keep a path active as a
   backup but wishes to prevent data being sent on that path, it could
   stop sending ACKs for any data it receives on that path.  The sender
   would interpret this as severe congestion or a broken path and stop
   using it.  We do not advocate this method, however, since this will
   result in unnecessary retransmissions.

   Therefore, a proposal is to use ECN [8] to to provide fake congestion



Ford, et al.            Expires January 13, 2011               [Page 19]

Internet-Draft                Multipath TCP                    July 2010


   signals on paths that a receiver wishes to stop being used for data.
   This has the benefit of causing the sender to back off without the
   need to retransmit data unnecessarily, as in the case of a lost ACK.
   This should be sufficient to allow a receiver to express their
   policy, although does not permit a rapid increase in throughput when
   switching to such a path.

   TBD: This is clearly an overload of the ECN signal, and as such other
   solutions, such as explicitly signalling path operation preferences
   (such as in the reserved bits of certain TCP options, or through
   entirely new options) may be a preferred solution.

3.4.  Closing a Connection

   In regular TCP a FIN announces the receiver that the sender has no
   more data to send.  In order to allow subflows to operate
   independently and to keep the appearance of TCP over the wire, a FIN
   in MPTCP only affects the subflow on which it is sent.  This allows
   nodes to exercise considerable freedom over which paths are in use at
   any one time.  The semantics of a FIN remain as for regular TCP, i.e.
   it is not until both sides have ACKed each other's FINs that the
   subflow is fully closed.

   When an application calls close() on a socket, this indicates that it
   has no more data to send, and for regular TCP this would result in a
   FIN on the connection.  For MPTCP, an equivalent mechanism is needed,
   and this is the DATA_FIN.  This option, shown in Figure 8, is
   attached to a regular FIN option on a subflow.

   A DATA_FIN is an indication that the sender has no more data to send,
   and as such can be used as a rapid indication of the end of data from
   a sender.  A DATA_FIN, as with the FIN on a regular TCP connection,
   is a unidirectional signal.

   A DATA_FIN occupies one octet (the final octet) of Data Sequence
   Number space.  This number is included in the option, and will be
   ACKed at data level to ensure reliable delivery.

   The DATA_FIN is an optimisation to rapidly indicate the end of a data
   stream and clean up state associated with a MPTCP connection,
   especially when some subflows may have failed.  Specifically, when a
   DATA_FIN has been received, IF all data has been successfully
   received, timeouts on all subflows MAY be reduced.  Similarly, when
   sending a DATA_FIN, once all data (including the DATA_FIN, since it
   occupies one octet of data sequence space) has been acknowledged,
   FINs must be sent on every subflow.  This applies to both endpoints,
   and is required in order to clean up state in middleboxes.




Ford, et al.            Expires January 13, 2011               [Page 20]

Internet-Draft                Multipath TCP                    July 2010


   The interactions between a DATA_FIN and subflow properties are as
   follows:

   o  A DATA_FIN MUST only be sent on a packet which also has the FIN
      flag set.

   o  When DATA_FIN is sent, it should be sent on all active subflows.

   o  There is a one-to-one mapping between the DATA_FIN and the
      subflow's FIN flag (and its associated sequence space and thus its
      acknowlegement).

   o  The data sequence number included in the DATA_FIN is used to
      verify that all data has been successfully received.

   It should be noted that an endpoint may also send a FIN on an
   individual subflow to shut it down, but this impact is limited to the
   subflow in question.  If all subflows have been closed with a FIN,
   that is equivalent to having closed the connection with a DATA_FIN.

   The full eight-byte data sequence number is always included in a
   DATA_FIN.

                           1
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+------------------------------+
      | Kind=DATA_FIN |   Length=10   |   Data Sequence Number (8B)  :
      +---------------+---------------+------------------------------+
      :                  Data Sequence Number (contd.)               :
      +-------------------------------+------------------------------+
      :  Data Sequence Number (contd.)|
      +-------------------------------+


                         Figure 8: DATA_FIN option

3.5.  Address Knowledge Exchange (Path Management)

   We use the term "path management" to refer to the exchange of
   information about additional paths between endpoints, which in this
   design is managed by multiple addresses at endpoints.  For more
   detail of the architectural thinking behind this design, see the
   separate architecture document [3].

   This design makes use of two methods of sharing such information,
   used simultaneously.  The first is the direct setup of new subflows,
   already described in Section 3.2, where the initiator has an
   additional address.  The second method, described in the following



Ford, et al.            Expires January 13, 2011               [Page 21]

Internet-Draft                Multipath TCP                    July 2010


   subsections, signals addresses explicitly to the other endpoint to
   allow it to initiate new subflows.  The two mechanisms are
   complementary: the first is implicit and simple, while the explicit
   is more complex but is more robust.  Together, the mechanisms allow
   addresses to change in flight (and thus support operation through
   NATs, since the source address need not be known), and also allow the
   signalling of previously unknown addresses, and of addresses
   belonging to other address families (e.g.  IPv4 and IPv6).

   Here is an example of typical operation of the protocol:

   o  A1 of host A and address/port B1 of host B. If host A is
      multihomed, it can start an additional subflow from its address A2
      to B1, by sending a SYN with a Join option from A2 to B1, using
      B's previously declared token for this connection.  Alternatively,
      if B is multhomed, it can try to set up a new subflow from B2 to
      A1, using A's previously declared token.  In either case, the SYN
      will be sent to the port already in use for the original subflow
      on the receiving host.

   o  Simultaneously (or after a timeout), an ADD_ADDR option
      (Section 3.5.1) is sent on an existing subflow, informing the
      receiver of the sender's alternative address(es).  The recipient
      can use this information to open a new subflow to the sender's
      additional address.  In our example, A will send ADD_ADDR option
      informing B of address A2.  The mix of using the SYN-based option
      and the ADD_ADDR option, including timeouts, is implementation-
      specific and can be tailored to agree with local policy.

   o  If subflow A2-B1 is succesfully setup, host B1 can use the Address
      ID in the Join option to correlate this with the ADD_ADDR option
      that will also arrive on an existing subflow; now B knows not to
      open A2-B1, ignoring the ADD_ADDR.  Otherwise, if B has not
      received the A2-B1 SYN join but received the ADD_ADDR, it will try
      to initiate a new subflow from one or more of its addresses to
      address A2.  This permits new sessions to be opened if one
      endpoint is behind a NAT.  A slight security improvement can be
      gained if a host ensures there is a correlated ADD_ADDR option
      before responding to the SYN.

   Other ways of using the two signaling mechanisms are possible; for
   instance, signaling addresses in other address families can only be
   done explicitly using the Add Address option.

3.5.1.  Address Advertisement

   The Add Address (ADD_ADDR) TCP Option announces additional addresses
   on which an endpoint can be reached (Figure 9).  It can be used to



Ford, et al.            Expires January 13, 2011               [Page 22]

Internet-Draft                Multipath TCP                    July 2010


   announce several (ID, address) pairs to be announced to the other
   endpoint.  Multiple addresses can be added in a single message if
   there is sufficient TCP option space, otherwise multiple TCP messages
   containing this option will be sent.  This option can be used at any
   time during a connection, depending on when the sender wishes to
   enable multiple paths and/or when paths become available.

   Every address has an ID which can be used for address removal, and
   therefore endpoints must cache the mapping between ID and address.
   This is also used to identify Join Connection options (Section 3.2)
   relating to the same address, even when address translators are in
   use.  The ID must be unique to the sender and connection, per
   address, but its mechanism for allocating such IDs is implementation-
   specific.

   This option is shown for IPv4.  For IPv6, the IPVer field will read
   6, and the length of the address will be 16 octets (instead of 4),
   and the length of the option will be 2 + (18 * number_of_entries).
   If there is sufficient TCP option space, multiple addresses can be
   included, with an ID following on immediately from the previous
   address.  The number of addresses can be deduced from the option
   length and version fields.

   The 'P' bit is used to indicate the presence of an additional two
   octets specifying the port number to use.  Although it is expected
   that the majority of use cases will use the same port pairs as used
   for the initial subflow (e.g. port 80 remains port 80 on all
   subflows, as does the ephemeral port at the client, there may be
   cases (such as port-based load balancing) where the explicit
   specification of a different port is required.  If the P bit is not
   specified, MPTCP MUST attempt to connect to the specified address on
   same port as is already in use by the signalling subflow.

   [TBD: We could make use of an additional flag, as follows.  Exact
   behaviour to be worked out: The 'B' bit is used to indicate that this
   specified address (and port, if applicable) should be treated as a
   backup subflow to use only in the event of failure of other working
   subflows.  A receiver of this option SHOULD set up a TCP subflow to
   the specified address and port, but SHOULD NOT send data on it until
   the other paths have failed.]











Ford, et al.            Expires January 13, 2011               [Page 23]

Internet-Draft                Multipath TCP                    July 2010


                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+---------------+-------+-------+
      | Kind=ADD_ADDR |     Length    |  Address ID   | IPVer |(res)|P|
      +---------------+---------------+---------------+-------+-------+
      |          Address (IPv4 - 4 octets / IPv6 - 16 octets)         |
      +-------------------------------+-------------------------------+
      |    Port (2 octets if P=1)     | ...
      +-------------------------------+
       ( ... further ID/Version/Address/Port fields as required ... )

         Figure 9: Add Address (ADD_ADDR) option (shown for IPv4)

   Due to the proliferation of NATs, it is reasonably likely that one
   endpoint may attempt to advertise private addresses [9].  We do not
   wish to blanket prohibit this, since there may be cases where both
   endpoints have additional interfaces on the same private network.  We
   must ensure, however, that such advertisements do not cause harm.
   The standard mechanism to create a new subflow (Section 3.2) contains
   a randomly-generated 32-bit token that uniquely identifies the
   connection to the receiving endpoint .  If the token is unknown, the
   endpoint will return with a RST.  If the token is known, subflow
   setup will continue, but the sender's token will be sent back.  In
   order for a new subflow to be setup, both tokens must match what each
   endpoint expects.  This will provide sufficient protection against
   two unconnected endpoints accidentally setting up a new subflow upon
   the signal of a private address (furthermore, the mismatch in Data
   Sequence Number that would occur would provide even further
   protection).

   Ideally, we'd like to ensure the ADD_ADDR (and REMOVE_ADDR) option is
   sent reliably and in order to the other end.  This is to ensure that
   we don't close the connection when remove/add addresses are processed
   in reverse order, and to ensure that all possible paths are used.  We
   note, however, that losing reliability and ordering it will not break
   the multipath connections; they will just reduce the opportunity to
   open multipath paths and to survive different patterns of path
   failures.

   Subflow level ACKs do not cover options, so if we want explicit
   guarantees we need to build in other mechanisms.  Solutions include
   echoing the options and sending one option per RTT, or adding a
   sequence number to the option which is explicitly acked in another
   option.  However, we feel these mechanisms' added complexity is not
   worth the benefits they bring.  There are two basic failure modes for
   options: a) every new option gets stripped or b) some options get
   stripped, randomly.  The second option looks more like a middlebox
   implementation error, so we believe it is not worth optimizing for.



Ford, et al.            Expires January 13, 2011               [Page 24]

Internet-Draft                Multipath TCP                    July 2010


   In the first case, resending the option on a different subflow is the
   thing to do.  To achieve similar reliability without explicit ACKs,
   we propose sending all ADD_ADDR/REMOVE_ADDR options on all existing
   subflows.  If ordering is needed, we should only send one ADD_ADDR/
   REMOVE_ADDR option per RTT (modulo lost packets at subflow level).

   When receiving an ADD_ADDR message with an address ID already in use
   for that connection, the receiver SHOULD silently ignore the
   ADD_ADDR.

   During normal MPTCP operation, it is unlikely that there will be
   sufficient TCP option space for ADD_ADDR to be included along with
   those for data sequence numbering (Section 3.3.1).  Therefore, it is
   expected that an MPTCP implementation will send the ADD_ADDR option
   on separate (either duplicate, or normal but lacking any payload)
   ACKs.

   As with all TCP Options, the ADD_ADDR option does not have reliable
   delivery.  Therefore, a sender should send a duplicate ACK with this
   option on all available subflows.

3.5.2.  Remove Address

   If, during the lifetime of a MPTCP connection, a previously-announced
   address becomes invalid (e.g. if the interface disappears), the
   affected endpoint should announce this so that the other endpoint can
   remove subflows related to this address.

   This is achieved through the Remove Address (REMOVE_ADDR) option
   (Figure 10), which will remove a previously-added address (or list of
   addresses) from a connection and terminate any subflows currently
   using that address.

   For security purposes, if a host receives a REMOVE_ADDR option, it
   must ensure the affected path(s) are no longer in use before it
   instigates closure.  The receipt of REMOVE_ADDR should first trigger
   the sending of a TCP Keepalive [10] on the path, and if a response is
   received the path is not removed.  Typical TCP validity tests on the
   subflow (e.g. ensuring sequence and ack numbers are correct) MUST
   also be undertaken.

   The sending and receipt (if no keepalive response was received) of
   this message SHOULD trigger the sending of RSTs by both endpoints on
   the affected subflow(s) (if possible), as a courtesy to cleaning up
   middlebox state, but endpoints may clean up their internal state
   without a long timeout.

   Address removal is undertaken by ID, so as to permit the use of NATs



Ford, et al.            Expires January 13, 2011               [Page 25]

Internet-Draft                Multipath TCP                    July 2010


   and other middleboxes.  If there is no address at the requested ID,
   the receiver will silently ignore the request.

   The standard way to close a subflow (so long as it is still
   functioning) is to use a FIN exchange as in regular TCP - for more
   information, see Section 3.4.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+---------------+
      |Kind=REMOVEADDR|  Length = 2+n |  Address ID   | ...
      +---------------+---------------+---------------+

              Figure 10: Remove Address (REMOVE_ADDR) option

3.6.  Fallback

   At the start of a MPTCP connection (i.e. the first subflow), it is
   important to ensure that the path is fully MPTCP-capable and the
   necessary TCP options can reach each endpoint.  The handshake as
   described in Section 3.1 will fall back to regular TCP if either of
   the SYN messages do not have the MPTCP options: this is the same, and
   desired, behaviour in the case where an endpoint is not MPTCP
   capable, or the path does not support he MPTCP options.  When
   attempting to join an existing MPTCP connection (Section 3.2), if a
   path is not MPTCP capable, the TCP options will not get through on
   the SYNs and the subflow will be closed.

   There is, however, another corner case which should be addressed.
   That is one of MPTCP options getting through on the SYN, but not on
   regular packets.  This can be resolved if the subflow is the first
   subflow, and thus all data in flight is contiguous.  This resolution
   mechanism is as follows:

   o  The first window's worth of data MUST be DATA_ACKed on every
      packet

   o  If the first data packet does not have a Data Sequence Mapping
      option, drop out of MPTCP mode back to regular TCP (and thus send
      a regular, subflow-level ACK, without a DATA_ACK)

   o  If an ACK is received without a DATA_ACK within the first window,
      drop out of MPTCP mode back to regular TCP (and thus stop sending
      data with a Data Sequence Mapping)

   These rules should cover all cases where such a failure could happen:
   whether it's on the forward or reverse path, and whether the server
   or the client first sends data.  If lost options on data packets



Ford, et al.            Expires January 13, 2011               [Page 26]

Internet-Draft                Multipath TCP                    July 2010


   occur on any other subflow apart from the start of the initial
   subflow, it should be treated as a standard path failure.  The data
   would not be DATA_ACKed (since there is no mapping for the data), and
   the subflow can be closed with an RST.

   The case described above is a specialised case of fallback.  More
   generally, fallback to regular TCP can become necessary at any point
   during a connection if a non-MPTCP-aware middlebox changes the data
   stream.

   As described in Section 3.3, each portion of data for which there is
   a mapping is protected by a CRC-32 checksum.  This mechanism is used
   to detect if middleboxes have made any adjustments to the payload
   (added, removed, or changed data).  A checksum will fail if the data
   has been changed in any way.  This will also detect if the length of
   data on the subflow is increased or decreased, and this means the
   Data Sequence Mapping is no longer valid.  The sender no longer knows
   what subflow-level sequence number the receiver is genuinely
   operating at (the middlebox will be faking ACKs in return), and
   cannot signal any further mappings.  Furthermore, in addition to the
   possibility of payload modifications that are valid at the
   application layer, there is the possibility that false-positives
   could be hit across segment boundaries, corrupting the data.
   Therefore, all data from the segment that failed the checksum onwards
   is not trustworthy.

   When multiple subflows are in use, the data in-flight on a subflow
   will likely involve data that is not contiguously part of the
   connection-level stream, since segments will be spread across the
   multiple subflows.  Due to the problems identified above, it is not
   possible to determine what the adjustment has done to the data
   (notably, any changes to the subflow sequence numbering).  Therefore,
   it is not possible to recover the subflow, and the affected subflow
   must be immediately closed with an RST, featuring a "checksum failed"
   option, which defines the Data Sequence Number at the start of the
   segment (defined by the Data Sequence Mapping) which had the checksum
   failure (see Figure 11).

                           1
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+---------------+--------------+
      | Kind=MP_FAIL  |   Length=10   |   Data Sequence Number (8B)  :
      +---------------+---------------+------------------------------+
      :                  Data Sequence Number (contd.)               :
      +-------------------------------+------------------------------+
      :  Data Sequence Number (contd.)|
      +-------------------------------+




Ford, et al.            Expires January 13, 2011               [Page 27]

Internet-Draft                Multipath TCP                    July 2010


                   Figure 11: Fallback (MP_FAIL) option

   TBD: In this case, is there any point in signalling Checksum Failed,
   or could we just RST the subflow?  The signal would allow the sender
   to know there is something wrong with the path and not try to re-
   establish the subflow (if that was otherwise the policy).

   Failed data will not be DATA_ACKed and so will be re-transmitted on
   other subflows (Section 3.3.4).

   A special case is when there is a single subflow and it fails with a
   checksum error.  Here, MPTCP should be able to recover and continue
   sending data.  There are two possible mechanisms to support this.
   The first and simplest is to nevertheless close the subflow with a
   RST, and immediately establish a new one as part of the same MPTCP
   connection.  Since it is known that the path may be compromised, it
   is not desirable to use MPTCP's segmentation on this path any longer.
   The new subflow will begin and will signal an infinite mapping
   (indicated by length=0 in the Data Sequence Mapping option,
   Section 3.3) from the data sequence number of the segment that failed
   the checksum.  This connection will then continue to appear as a
   regular TCP session, and a middlebox may change the payload without
   causing unintentional harm.

   An optimisation is possible, however.  If it is known that all
   unacknowledged data in flight is contiguous, an infinite mapping
   could be applied to the subflow without the need to close it first,
   and essentially turn off all further MPTCP signalling.  In this case,
   if a receiver identifies a checksum failure when there is only one
   path, it will send back an OPT_FAIL on the subflow-level ACK.  The
   sender will receive this, and if all unacknowledged data in flight is
   contiguous, will signal an infinite mapping (if the data is not
   contiguous, the sender MUST send an RST).  This infinite mapping will
   be a Data Sequence Mapping option on the first new packet, but it
   acts retroactively, referring to the start of the subflow sequence
   number of the last segment that was known to be delivered intact.
   From that point onwards data can be altered by a middlebox without
   affecting MPTCP, as the data stream is equivalent to a regular,
   legacy TCP session.

   After a sender signals an infinite mapping it MUST only use subflow
   ACKs to clear its send buffer.  This is because data ACKs may become
   misaligned with the subflow ACKs when middleboxes insert or delete
   data.  The receive SHOULD stop generating Data ACKs after it receives
   an infinite mapping.

   When a connection is in fallback mode, only one subflow can send data
   at a time.  Otherwise, the receiver would not know how to reorder the



Ford, et al.            Expires January 13, 2011               [Page 28]

Internet-Draft                Multipath TCP                    July 2010


   data.  However, subflows can be opened and close as necessary, as
   long as a single one is active at any point.

   It should be emphasised that we are not attempting to prevent the use
   of middleboxes that want to adjust the payload.  An MPTCP-aware
   middlebox to provide such functionality could be designed that would
   re-write checksums if needed, and additionally would be able to parse
   the data sequence mappings, and thus not hit false positives though
   not knowing where data boundaries lie.

3.7.  Error Handling

   In addition to the fallback mechanism as described above, the
   standard classes of TCP errors may need to be handled in an MPTCP-
   specific way.  Note that changing semantics - such as the relevance
   of an RST - has already been covered in Section 4.  Where possible,
   we do not want to deviate from regular TCP behaviour.

   The following list covers possible errors and the appropriate MPTCP
   behaviour:

   o  Unknown token in MP_JOIN (or token mismatch in MP_JOIN ACK, or
      missing MP_JOIN in SYN/ACK response): send RST (analogous to TCP's
      behaviour on an unknown port)

   o  (TBD: If we include DSN in MP_JOIN, and the DSN is out of the
      window but the token is valid, do we still send an RST?)

   o  DSN out of Window (during normal operation): just ignore, however
      if at the beginning of a new subflow we might want to RST it as a
      security mechanism

   o  Remove request for unknown address ID: silently ignore

3.8.  Heuristics

   There are a number of heuristics that are needed for performance or
   deployment but which are not required for protocol correctness.  In
   this section we detail such heuristics

3.8.1.  Port Usage

   Under typical operation an MPTCP implementation SHOULD use the same
   ports as already in use.  In other words, the destination port of a
   SYN containing a MP_JOIN option SHOULD be the same as the remote port
   of the first subflow in the connection.  The local port for such SYNs
   SHOULD also be the same as for the first subflow (and as such, an
   implementation SHOULD reserve ephemeral ports across all local IP



Ford, et al.            Expires January 13, 2011               [Page 29]

Internet-Draft                Multipath TCP                    July 2010


   addresses), although there may be cases where this is infeasible.
   This strategy is intended to maximize the probability of the SYN
   being permitted by a firewall or NAT at the recipient and to avoid
   confusing any network monitoring software.

   There may also be cases, however, where the passive opener wishes to
   signal to the other endpoint that a specific port should be used, and
   this facility is provided in the Add Address option as documented in
   Section 3.5.1.  It is therefore feasible to allow multiple subflows
   between the same two addresses but using different port pairs, and
   such a facility could be such a facility could be used to allow load
   balancing within the network based on 5-tuples (e.g.  ECMP).


4.  Semantic Issues

   In order to support multipath operation, the semantics of some TCP
   components have changed.  To aid clarity, this section collects these
   semantic changes as a reference.

   Sequence Number:  The (in-header) TCP sequence number is specific to
      the subflow.  To allow the receiver to reorder application data,
      an additional data-level sequence space is used.  In this data-
      level sequence space, the initial SYN and the final DATA_FIN
      occupy one octet of sequence space.  There is an explicit mapping
      of data sequence space to subflow sequence space, which is
      signalled through TCP options in data packets.

   ACK:  The ACK field in the TCP header acknowledges only the subflow
      sequence number, not the data-level sequence space.
      Implementations SHOULD NOT attempt to infer a data-level
      acknowledgement from the subflow ACKs.  Instead an explicit data-
      level DATA_ACK is used.  This avoids possible deadlock scenarios
      when a non-TCP-aware middlebox pro-actively ACKs at the subflow
      level.

   Receive Window:  The receive window in the TCP header indicates the
      amount of free buffer space for the whole data-level connection
      (as opposed to for this subflow) that is available at the
      receiver.  This is the same semantics as regular TCP, but to
      maintain these semantics the receive window must be interpreted at
      the sender as relative to the sequence number given in the
      DATA_ACK rather than the subflow ACK in the TCP header.  In this
      way the original flow control role is preserved.







Ford, et al.            Expires January 13, 2011               [Page 30]

Internet-Draft                Multipath TCP                    July 2010


   FIN:  The FIN flag in the TCP header applies only to the subflow it
      is sent on, not to the whole connection.  For connection-level FIN
      semantics, the DATA_FIN option is used.

   RST:  The RST flag in the TCP header applies only to the subflow it
      is sent on, not to the whole connection.  A connection is
      considered reset if a RST is received on every subflow.

   Address List:  Address list management (i.e. knowledge of the local
      and remote hosts' lists of available IP addresses) is handled on a
      per-connection basis (as opposed to per-subflow, per host, or per
      pair of communicating hosts).  This permits the application of
      per-connection local policy.  Adding an address to one connection
      (either explicitly through an Add Address message, or implicitly
      through a Join) has no implication for other connections between
      the same pair of hosts.

   5-tuple:  The 5-tuple (protocol, local address, local port, remote
      address, remote port) presented by kernel APIs to the application
      layer in a non-multipath-aware application is that of the first
      subflow, even if the subflow has since been closed and removed
      from the connection.  This decision, and other related API issues,
      are discussed in more detail in [5].


5.  Security Considerations

   TBD

   (Token generation, handshake mechanisms, new subflow authentication,
   etc...)

   A generic threat analysis for the addition of multipath capabilities
   to TCP is presented in [11].  The protocol presented here has been
   designed to minimise or eliminate these identified threats.  (A
   future version of this document will explicitly address the presented
   threats).

   The development of a TCP extension such as this will bring with it
   many additional security concerns.  We have set out here to produce a
   solution that is "no worse" than current TCP, with the possibility
   that more secure extensions could be proposed later.

   The primary area of concern will be around the handshake to start new
   subflows which join existing connections.  The proposal set out in
   Section 3.1 and Section 3.2 is for the initiator of the new subflow
   to include the token of the other endpoint in the handshake.  The
   purpose of this is to indicate that the sender of this token was the



Ford, et al.            Expires January 13, 2011               [Page 31]

Internet-Draft                Multipath TCP                    July 2010


   same entity that received this token at the initial handshake.

   One area of concern is that the token could be simply brute-forced.
   The token must be hard to guess, and as such could be randomly
   generated.  This may still not be strong enough, however, and so the
   use of 64 bits for the token would alleviate this somewhat.

   The two tokens don't need to be the same length.  Token B could be 64
   bits and token A 32 bits.  If MP_JOIN always contains Token B, this
   would provide adequate security while saving scarce space in the
   initial SYN, where it is most at a premium.

   Use of these tokens only provide an indication that the token is the
   same as at the initial handshake, and does not say anything about the
   current sender of the token.  Therefore, another approach would be to
   bring a new measure of freshness in to the handshake, so instead of
   using the initial token a sender could request a new token from the
   receiver to use in the next handshake.  Hash chains could also be
   used for this purpose.

   Yet another alternative would be for all SYN packets to include a
   data sequence number.  This could either be used as a passive
   identifier to indicate an awareness of the current data sequence
   number (although a reasonable window would have to be allowed for
   delays).  Or, the SYN could form part of the data sequence space -
   but this would cause issues in the event of lost SYNs (if a new
   subflow is never established), thus causing unnecessary delays for
   retransmissions.


6.  Interactions with Middleboxes

   Multipath TCP was designed to be deployable in the present world.
   Its design takes into account "reasonable" existing middlebox
   behaviour.  In this section we outline a few representative
   middlebox-related failure scenarios and show how multipath TCP
   handles them.  Next, we list the design decisions multipath has made
   to accomodate the different middleboxes.

   A primary concern is our use of new TCP options.  Most middleboxes
   should just forward packets with new options unchanged, yet there are
   some that don't.  These we expect will either strip options and pass
   the data, drop packets with new options, copy the same option into
   multiple segments (e.g. when doing segmentation) or drop options
   during segment coalescing.

   MPTCP SYN packets contain the MP_CAPABLE option to indicate the use
   of MPTCP.  When the middlebox drops the packet containing the



Ford, et al.            Expires January 13, 2011               [Page 32]

Internet-Draft                Multipath TCP                    July 2010


   MP_CAPABLE option either on the outgoing or the return path, the
   connection will fail.  Host A SHOULD fall back to TCP in such cases
   (studies suggest that few middleboxes drop packets with unknown
   options).  The same applies for subflow setup.

   The second case is when the middleboxes strip options.  Let's first
   discuss behaviour for initial connection SYNs (see Figure 12).  If
   the option is stripped from the packet on the outgoing path, the
   connection falls back to regular TCP.  If the option is stripped on
   the return path, host B will wait for a DATA_ACK of its connection
   SYN, retransmitting the SYN/ACK until it declares the connection
   failed.  Host A thinks it is talking to a regular host, and may send
   data segments, but these will not be acked by host B as they do not
   have the proper mapping.  Hence the connection fails.  Host A SHOULD
   fall back to regular TCP after the connection times out.

   Subflow SYNs contain the MP_JOIN option.  If this option is stripped
   on the outgoing path the SYN will appear to be a regular SYN to host
   B. Depending on whether there is a listening socket on the target
   port, host B will reply either with SYN/ACK or RST (subflow
   connection fails).  When host A receives the SYN/ACK it sends a RST
   because the SYN/ACK does not contain the MP_JOIN option and its
   token.  Either way, the connection fails.

        Host A                             Host B
         |              Middlebox M            |
         |                   |                 |
         |  SYN(MP_CAPABLE)  |        SYN      |
         |-------------------|---------------->|
         |                SYN/ACK              |
         |<------------------------------------|
     a) MP_CAPABLE option stripped on outgoing path

       Host A                               Host B
         |            SYN(MP_CAPABLE)          |
         |------------------------------------>|
         |             Middlebox M             |
         |                 |                   |
         |    SYN/ACK      |SYN/ACK(MP_CAPABLE)|
         |<----------------|-------------------|
     b) MP_CAPABLE option stripped on return path

   Figure 12: Connection Setup with Middleboxes that Strip Options from
                                  Packets

   We now examine data flow with MPTCP, assuming the flow is correctly
   setup which implies the options in the SYN packets were allowed
   through by the relevant middleboxes.  If options are allowed through



Ford, et al.            Expires January 13, 2011               [Page 33]

Internet-Draft                Multipath TCP                    July 2010


   and there is no resegmentation or coalescing to TCP segments,
   multipath TCP flows can proceed without problems.

   The case when options get stripped on data packets has been discussed
   in the Fallback section.  We can further analyze what happens when a
   fraction of options is stripped.  The multipath subflow should
   survive losing a fraction of DATA_ACKs and data sequence mappings,
   but performance will degrade as the fraction of stripped options
   increases.  We do not expect such cases to appear in practice,
   though: most middleboxes will either strip all options or let them
   all through.

   We end this section with a list of middlebox classes, their behaviour
   and the elements in the MPTCP design that allow operation through
   such middleboxes.  Issues surrounding dropping packets with options
   or stripping options were discussed above, and are not included here:

   o  NAT [12]: changes the source address and port of packets.  This
      means that a host will not know its public-facing address for
      signalling in MPTCP.  Therefore, MPTCP permits implicit address
      addition via the MP_JOIN option, and has heuristics to ensure that
      connection attempts to private addresses [9] do not cause
      problems.  Address removal is undertaken by an ID number to allow
      no knowledge of the source address.

   o  Performance Enhancing Proxies (PEPs) [13]: might pro-actively ACK
      data to increase performance.  Problems will occur if a PEP ACKs
      data and then fails before sending it on to the receiver, of it
      the receiver is mobile and moves away before proactively ACKed
      data is forwarded on.  If subflow ACKs were used to control send
      buffering, the data could be lost and never be retransmitted, thus
      causing the subflow to permanently stall.  MPTCP therefore uses
      the DATA_ACK to make progress when one of its subflows fails in
      this way.  This is why MPTCP does not use subflow ACKs to infer
      connection level ACKs.

   o  Traffic Normalizers [14]: do not allow holes in sequence numbers,
      cache packets and retransmit the same data.  MPTCP looks like
      standard TCP on the wire, and will not retransmit different data
      on the same subflow sequence number.

   o  TCP Options: may be removed, or packets with unknown options
      dropped, by many classes of middleboxes.  It is intended that the
      initial SYN exchange, with a TCP Option, will be sufficient to
      identify the path capabilities.  If such a packet does not get
      through, MPTCP will end up falling back to regular TCP.





Ford, et al.            Expires January 13, 2011               [Page 34]

Internet-Draft                Multipath TCP                    July 2010


   o  Segmentation/Coalescing (e.g. tcp segmentation offloading, etc):
      might copy options between packets and might strip some options.
      MPTCP's data sequence mapping includes the subflow sequence number
      instead of using the sequence number in the segment.  In this way,
      the mapping is independent of the packets that carry it.

   o  Firewalls [15]: might perform sequence number randomization on TCP
      connections.  MPTCP uses relative sequence numbers in data
      sequence mapping to cope with this.  Like NATs, firewalls will not
      permit many incoming connections, so MPTCP supports address
      signalling (ADD_ADDR) so that a multihomed endpoint can invite its
      peer behind the firewall/NAT to connect out to its additional
      interface.

   o  Intrusion Detection Systems: look out for traffic patterns and
      content that could threaten a network.  Multipath will mean that
      such data is potentially spread, so it is more difficult for an
      IDS to analyse the whole traffic, and potentially increasint the
      risk of false positives.  However, for an MPTCP-aware IDS,
      connection IDs can be easily read by such systems to correlate
      multiple subflows and re-assemble for analysis.

   o  Application level NATs: may alter the payload within a subflow.
      Multipath TCP will detect these using the checksum and close the
      affected subflow(s), if there are other subflows that can be used.
      If all subflows are affected multipath will fallback to TCP,
      allowing middleboxes to change the payload.

   o  Middleboxes that alter the receive window: MPTCP will use the
      maximum window at data-level, but will also obey subflow specific
      windows.


7.  Interfaces

   TBD

   Interface with applications, interface with TCP, interface with lower
   layers...

   Discussion of interaction with applications (both in terms of how
   MPTCP will affect an application's assumptions of the transport
   layer, and what API extensions an application may wish to use with
   MPTCP) are discussed in [5].







Ford, et al.            Expires January 13, 2011               [Page 35]

Internet-Draft                Multipath TCP                    July 2010


8.  Open Issues

   This specification is a work-in-progress, and as such there are many
   issues that are still to be resolved.  This section lists many of the
   key open issues within this specification; these are discussed in
   more detail in the appropriate sections throughout this document.

   o  Best handshake mechanisms (Section 3.1).  This document contains a
      proposed scheme by which connections and subflows can be set up.
      It is felt that, although this is "no worse than regular TCP",
      there could be opportunities for significant improvements in
      security that could be included (potentially optionally) within
      this protocol.

   o  Issues around simultaneous opens, where both ends attempt to
      create a new subflow simultaneously, need to be investigated and
      behaviour specified.

   o  Appropriate mechanisms for controlling policy/priority of subflow
      usage (specifically regarding controlling incoming traffic,
      Section 3.3.6).  The ECN signal is currently proposed but other
      alternatives, including per subflow receive windows or options
      indicating path properties, could be employed instead.

   o  How much control do we want over subflows from other subflows
      (e.g. closing when interface has failed)?  Do we want to
      differentiate between subflows and addresses (Section 3.2)?

   o  Do we want a connection identifier in every packet?  E.g. would it
      make the implementation of an IDS easier?

   o  Should we do signaling in the TCP payload, rather than options as
      proposed in this draft?  We discuss this alternative in the
      appendix.

   o  Should we explicitly support SYN cookies?  With the current
      design, MPTCP would be downgraded to basic TCP if SYN cookies were
      used.  Is it worth designing the protocol to allow stateless
      server handshake?

   o  Instead of an Address ID in MP_JOIN, are there any cases where a
      Subflow ID (i.e. unique to the subflow) would be useful instead?
      For example, two addresses which become NATted to the same
      address?







Ford, et al.            Expires January 13, 2011               [Page 36]

Internet-Draft                Multipath TCP                    July 2010


9.  Acknowledgements

   The authors are supported by Trilogy
   (http://www.trilogy-project.org), a research project (ICT-216372)
   partially funded by the European Community under its Seventh
   Framework Program.  The views expressed here are those of the
   author(s) only.  The European Commission is not liable for any use
   that may be made of the information in this document.

   The authors gratefully acknowledge significant input into this
   document from many members of the Trilogy project, notably Iljitsch
   van Beijnum, Lars Eggert, Marcelo Bagnulo Braun, Robert Hancock, Pasi
   Sarolahti, Olivier Bonaventure, Toby Moncaster, Philip Eardley,
   Andrew McDonald and Sergio Lembo.


10.  IANA Considerations

   This document will make a request to IANA to allocate new values for
   TCP Option identifiers, as follows:

   +-------------+-----------------------------+---------------+-------+
   |    Symbol   |             Name            |      Ref      | Value |
   +-------------+-----------------------------+---------------+-------+
   |  MP_CAPABLE |      Multipath Capable      |  Section 3.1  | (tbc) |
   |   MP_JOIN   |       Join Connection       |  Section 3.2  | (tbc) |
   |   ADD_ADDR  |         Add Address         | Section 3.5.1 | (tbc) |
   | REMOVE_ADDR |        Remove Address       | Section 3.5.2 | (tbc) |
   |   DSN_MAP   |     Data Sequence Number    |  Section 3.3  | (tbc) |
   |             |           Mapping           |               |       |
   |   DATA_ACK  |  Data-level Acknowledgment  |  Section 3.3  | (tbc) |
   |   DATA_FIN  |        Data-level FIN       |  Section 3.4  | (tbc) |
   |   MP_FAIL   |           Fallback          |  Section 3.6  | (tbc) |
   +-------------+-----------------------------+---------------+-------+

                      Table 1: TCP Options for MPTCP


11.  References

11.1.  Normative References

   [1]   Bradner, S., "Key words for use in RFCs to Indicate Requirement
         Levels", BCP 14, RFC 2119, March 1997.







Ford, et al.            Expires January 13, 2011               [Page 37]

Internet-Draft                Multipath TCP                    July 2010


11.2.  Informative References

   [2]   Postel, J., "Transmission Control Protocol", STD 7, RFC 793,
         September 1981.

   [3]   Ford, A., Raiciu, C., Barre, S., and J. Iyengar, "Architectural
         Guidelines for Multipath TCP Development",
         draft-ietf-mptcp-architecture-01 (work in progress), June 2010.

   [4]   Raiciu, C., Handley, M., and D. Wischik, "Coupled Multipath-
         Aware Congestion Control", draft-raiciu-mptcp-congestion-01
         (work in progress), March 2010.

   [5]   Scharf, M. and A. Ford, "MPTCP Application Interface
         Considerations", draft-scharf-mptcp-api-01 (work in progress),
         March 2010.

   [6]   Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
         Selective Acknowledgment Options", RFC 2018, October 1996.

   [7]   Stewart, R., "Stream Control Transmission Protocol", RFC 4960,
         September 2007.

   [8]   Ramakrishnan, K., Floyd, S., and D. Black, "The Addition of
         Explicit Congestion Notification (ECN) to IP", RFC 3168,
         September 2001.

   [9]   Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E.
         Lear, "Address Allocation for Private Internets", BCP 5,
         RFC 1918, February 1996.

   [10]  Braden, R., "Requirements for Internet Hosts - Communication
         Layers", STD 3, RFC 1122, October 1989.

   [11]  Bagnulo, M., "Threat Analysis for Multi-addressed/Multi-path
         TCP", draft-ietf-mptcp-threat-02 (work in progress),
         March 2010.

   [12]  Srisuresh, P. and K. Egevang, "Traditional IP Network Address
         Translator (Traditional NAT)", RFC 3022, January 2001.

   [13]  Border, J., Kojo, M., Griner, J., Montenegro, G., and Z.
         Shelby, "Performance Enhancing Proxies Intended to Mitigate
         Link-Related Degradations", RFC 3135, June 2001.

   [14]  Handley, M., Paxson, V., and C. Kreibich, "Network Intrusion
         Detection: Evasion, Traffic Normalization, and End-to-End
         Protocol Semantics", Usenix Security 2001, 2001, <http://



Ford, et al.            Expires January 13, 2011               [Page 38]

Internet-Draft                Multipath TCP                    July 2010


         www.usenix.org/events/sec01/full_papers/handley/handley.pdf>.

   [15]  Freed, N., "Behavior of and Requirements for Internet
         Firewalls", RFC 2979, October 2000.


Appendix A.  Notes on use of TCP Options

   The TCP option space is limited due to the length of the Data Offset
   field in the TCP header (4 bits), which defines the TCP header length
   in 32-bit words.  With the standard TCP header being 20 bytes, this
   leaves a maximum of 40 bytes for options, and many of these may
   already be used by options such as timestamp and SACK.

   We have performed a brief study on the commonly used TCP options in
   both SYN, data packets and pure ACK packets, and found that there is
   enough room to fit all the options we propose using in this draft.

   SYN packets typically include MSS (4 bytes), window scale (3 bytes),
   SACK permitted (2 bytes) and timestamp (10 bytes) options.  Together
   these sum to 19 bytes.  Some operating systems appear to pad each
   option up to a word boundary, thus using 24 bytes (a brief survey
   suggests Windows XP and Mac OS X do this, whereas Linux does not).
   Optimistically, therefore, we have 21 bytes spare, or 16 if it has to
   be word-aligned.  In either case, however, the Multipath Capable (12
   bytes) and Join (7 bytes) options will fit in this remaining space.

   TCP data packets typically carry timestamp options in every packet,
   taking 10 bytes (or 12 with padding).  That leaves 30 bytes (or 28,
   if word-aligned), which are enough to encode the data sequence
   mapping (16 or 20 bytes, depending on the length of the sequence
   number in use) and the DATA_ACK if the flow is bidirectional (6 or 10
   bytes).  Such options will just fit in the available option space,
   although 8 byte data-level sequence numbers in both will only fit if
   word-alignment is not required.  If this proves to be a problem, it
   is not necessary to include the Data Sequence Mapping and DATA_ACK in
   each packet, and in many cases it may be possible to alternate their
   presence (so long as the mapping covers the data being sent in the
   following packet).  Other options include: wrapping the DATA_ACK into
   the Data Sequence Mapping option; alternating between 4 and 8 byte
   sequence numbers in each option; and sending the DATA_ACK on a
   duplicate subflow-level ACK.

   Pure ACKs in TCP typically contain only timestamps (10B).  Here,
   multipath TCP typically needs to encode the DATA_ACK (max 10B).
   Occasionally ACKs will contain SACK information.  Depending on the
   number of lost packets, SACK may utilize the entire option space.  If
   a DATA_ACK had to be included, then it is probably necessary to



Ford, et al.            Expires January 13, 2011               [Page 39]

Internet-Draft                Multipath TCP                    July 2010


   reduce the number of SACK blocks by one to accomodate the DATA_ACK.
   However, the presence of the DATA_ACK is unlikely to be necessary in
   a case where SACK is in use, however, since until at least some of
   the SACK blocks have been retransmitted, the cumulative data-level
   ACK will not be moving forward (or if it does, due to retransmissions
   on antoher path, then that path can also be used to transmit the new
   DATA_ACK).

   The ADD_ADDR option can be between 8 and 22 bytes, depending on
   whether IPv4 or IPv6 is used, and whether the Port number is present
   or not.  It is unlikely that such signalling would fit in a data
   packet (although if there is space, it is fine to include it).  It is
   recommended to use duplicate ACKs with no other payload or options in
   order to transmit these rare signals.

   Finally, there are issues with options reliability.  As options can
   also be sent on pure ACKs, these are not reliably sent.  This is not
   an issue for DATA_ACK due to their cumulative nature, but may be an
   issue for ADD_ADDR/REMOVE_ADDR options.  Here we favour redundant
   transmissions at the sender (whether on multiple paths, or on the
   same path on a number of ACKs).  The cases where options are stripped
   by middleboxes are discussed in Section 6.


Appendix B.  Resync Packet

   In earlier versions of this draft, we proposed the use of a "re-sync"
   option that would be used in certain circumstances when a sender
   needs to instruct the receiver to skip over certain subflow sequence
   numbers (i.e. to treat the specified sequence space as having been
   received and acknowledged).

   The typical use of this option will be when packets are retransmitted
   on different subflows, after failing to be acknowledged on the
   original subflow.  In such a case, it becomes necessary to move
   forward the original subflow's sequence numbering so as not to later
   transmit different data with a previously used sequence number (i.e.
   when more data comes to be transmitted on the original subflow, it
   would be different data, and so must not be sent with previously-used
   (but unacknowledged) sequence numbering).

   The rationale for needing to do this is two-fold: firstly, when ACKs
   are received they are for the subflow only, and the sender infers
   from this the data that was sent - if the same sequence space could
   be occupied by different data, the sender won't know whether the
   intended data was received.  Secondly, certain classes of middleboxes
   may cache data and not send the new data on a previously-seen
   sequence number.



Ford, et al.            Expires January 13, 2011               [Page 40]

Internet-Draft                Multipath TCP                    July 2010


   This option was dropped, however, since some middleboxes may get
   confused when they meet a hole in the sequence space, and do not
   understand the resync option.  It is therefore felt that the same
   data must continue to be retransmitted on a subflow even if it is
   already received after being retransmitted on another.  There should
   not be a significant performance hit from this since the amount of
   data involved and needing to be retransmitted multiple times will be
   relatively small.

   Therefore, it is necessary to 're-sync' the expected sequence
   numbering at the receiving end of a subflow, using the following TCP
   option.  This packet declares a sequence number space (inclusive)
   which the receiving node should skip over, i.e. if the receiver's
   next expected sequence number was previously within the range
   start_seq_num to end_seq_num, move it forward to end_seq_num + 1.

   This option will be used on the first new packet on the subflow that
   needs its sequence numbering re-synchronised.  It will be continue to
   be included on every packet sent on this subflow until a packet
   containing this option has been acknowledged (i.e. if subflow
   acknowledgements exist for packets beyond the end sequence number).
   If the end sequence number is earlier than the current expected
   sequence number (i.e. if a resync packet has already been received),
   this option should be ignored.

                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+------------------------------+
      |Kind=MP_RESYNC|  Length = 10  |     Start Sequence Number    :
      +---------------+---------------+------------------------------+
      :          (4 octets)           |      End Sequence Number     :
      +---------------+---------------+------------------------------+
      :          (4 octets)           |
      +-------------------------------+

                         Figure 13: Resync option


Appendix C.  Changelog

   This section maintains logs of significant changes made to this
   document between versions.

C.1.  Changes since draft-ietf-mptcp-multiaddressed-00

   o  Various clarifications and minor re-structuring in response to
      comments.




Ford, et al.            Expires January 13, 2011               [Page 41]

Internet-Draft                Multipath TCP                    July 2010


C.2.  Changes since draft-ford-mptcp-multiaddressed-03

   o  Clarified handshake mechanism, especially with regard to error
      cases (Section 3.2).

   o  Added optional port to ADD_ADDR and clarified situation with
      private addresses (Section 3.5.1).

   o  Added path liveness check to REMOVE_ADDR (Section 3.5.2).

   o  Added chunk checksumming to DSN_MAP (Section 3.3.1) to detect
      payload-altering middleboxes, and defined fallback mechanism
      (Section 3.6).

   o  Major clarifications to receive window discussion (Section 3.3.4).

   o  Various textual clarifications, especially in examples.

C.3.  Changes since draft-ford-mptcp-multiaddressed-02

   o  Remove Version and Address ID in MP_CAPABLE in Section 3.1, and
      make ISN be 6 bytes.

   o  Data sequence numbers are now always 8 bytes.  But in some cases
      where it is unambiguous it is permissible to only send the lower 4
      bytes if space is at a premium.

   o  Clarified behaviour of MP_JOIN in Section 3.2.

   o  Added DATA_ACK to Section 3.3.

   o  Clarified fallback to non-multipath once a non-MP-capable SYN is
      sent.


Authors' Addresses

   Alan Ford
   Roke Manor Research
   Old Salisbury Lane
   Romsey, Hampshire  SO51 0ZN
   UK

   Phone: +44 1794 833 465
   Email: alan.ford@roke.co.uk






Ford, et al.            Expires January 13, 2011               [Page 42]

Internet-Draft                Multipath TCP                    July 2010


   Costin Raiciu
   University College London
   Gower Street
   London  WC1E 6BT
   UK

   Email: c.raiciu@cs.ucl.ac.uk


   Mark Handley
   University College London
   Gower Street
   London  WC1E 6BT
   UK

   Email: m.handley@cs.ucl.ac.uk



































Ford, et al.            Expires January 13, 2011               [Page 43]

