<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<!--<rfc category="std" ipr="full3978" docName="draft-roca-fecframe-rs-00.txt">-->
<!-- <rfc category="std" ipr="trust200811" docName="draft-roca-fecframe-rs-00a.txt">-->
<rfc category="exp" ipr="pre5378Trust200902">

<?xml-stylesheet type='text/xsl'
                 href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<!--<?rfc symrefs="no" ?>-->
<?rfc symrefs="yes" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>


	<front>
		<title abbrev='Reed-Solomon FEC Schemes'>
			Reed-Solomon Forward Error Correction (FEC) Schemes for FECFRAME
		</title>

		<author initials='V' surname="Roca" fullname='Vincent Roca'>
			<organization>INRIA</organization>
			<address>
				<postal>
					<street>655, av. de l'Europe</street>
					<street>Inovallee; Montbonnot</street>
					<city>ST ISMIER cedex</city>
					<code>38334</code>
					<country>France</country>
				</postal>
				<email>vincent.roca@inria.fr</email>
				<uri>http://planete.inrialpes.fr/people/roca/</uri>
			</address>
		</author>
		<author initials='M' surname="Cunche" fullname='Mathieu Cunche'>
			<organization>INRIA</organization>
			<address>
				<postal>
					<street>655, av. de l'Europe</street>
					<street>Inovallee; Montbonnot</street>
					<city>ST ISMIER cedex</city>
					<code>38334</code>
					<country>France</country>
				</postal>
				<email>mathieu.cunche@inria.fr</email>
				<uri>http://planete.inrialpes.fr/people/cunche/</uri>
			</address>
		</author>
		<author initials="J" surname="Lacan" fullname="Jerome Lacan">
			<organization>ISAE/LAAS-CNRS</organization>
			<address>
				<postal>
					<street>1, place Emile Blouin</street>
					<city>Toulouse</city>
					<code>31056</code>
					<country>France</country>
				</postal>
				<email>jerome.lacan@isae.fr</email>
				<uri>http://dmi.ensica.fr/auteur.php3?id_auteur=5</uri>
				
			</address>
		</author>
		<author initials="A" surname="Bouabdallah" fullname="Amine Bouabdallah">
			<organization>ISAE/LAAS-CNRS</organization>
			<address>
				<postal>
					<street>1, place Emile Blouin</street>
					<city>Toulouse</city>
					<code>31056</code>
					<country>France</country>
				</postal>
				<email>Amine.Bouabdallah@isae.fr</email>
				<uri>http://dmi.ensica.fr/</uri>
				
			</address>
		</author>
	<author initials="K" surname="Matsuzono" fullname="Kazuhisa Matsuzono">
	  <organization>Keio University</organization>
	  <address>
	    <postal>
	      <street>Graduate School of Media and Governance</street>
	      <street>5322 Endo</street>
	      <city>Fujisawa</city> <region>Kanagawa</region>
	      <code>252-8520</code>
	      <country>Japan</country>
	    </postal>
	    <email>kazuhisa@sfc.wide.ad.jp</email>
	  </address>
	</author>

		<date day="8" month="March" year="2010"/>
		<area>Transport</area>
		<workgroup>FecFrame</workgroup>
		<keyword>I-D</keyword>
		<keyword>Internet-Draft</keyword>
		<keyword>Forward Error Correction</keyword>
		<keyword>Reed-Solomon</keyword>

		<abstract>
<t>
This document describes two fully-specified FEC schemes for Reed-Solomon codes
that can be used to protect media streams along the lines defined by the FECFRAME framework.
Reed-Solomon codes belong to the class of Maximum Distance Separable (MDS) codes which
means they offer optimal protection against packet erasures.
They are also systematic codes, which means that the source symbols are part of the encoding
symbols.
The price to pay is a limit on the maximum source block size, on the maximum number of encoding
symbols, and a computational complexity higher than that of sparse parity check based FEC codes.
However, this complexity remains compatible with software codecs.
<!-- Finally, the FEC schemes described here are compatible with the software codec from Luigi Rizzo.-->
</t>

<t>
The first scheme is for Reed-Solomon codes over GF(2^^m), with m in {2..16}, a simple FEC encoding and
arbitrary packet flows.
The second scheme is similar to the first scheme, with the exception that it is for a single sequenced
flow.
</t>
		</abstract>
	</front>

	<middle>

		<section anchor="Introduction" title="Introduction">
		<!-- =========================================== -->

<t>The use of Forward Error Correction (FEC) codes is a classic solution to improve the reliability
of unicast, multicast and broadcast Content Delivery Protocols (CDP) and applications <xref target="RFC3453"/>.
The <xref target="FECFRAME-FRAMEWORK"/> document describes a generic framework to use FEC schemes
with media delivery applications, and for instance with real-time streaming media applications based
on the RTP real-time protocol.
Similarly the <xref target="RFC5052"/> document describes a generic framework to use FEC schemes
with with objects (e.g., files) delivery applications based on the ALC  <xref target="RMT-PI-ALC"/>
and NORM <xref target="RFC5740"/> reliable multicast transport protocols.
</t>

<t>More specifically, the <xref target="RFC5053"/> and <xref target="RFC5170"/> FEC schemes introduce
erasure codes based on sparse parity check matrices for object delivery protocols like ALC and NORM.
These codes are efficient in terms of processing but not optimal in terms of erasure recovery
capabilities when dealing with "small" objects.
</t>

<t>The Reed-Solomon FEC codes described in this document belong to the class of Maximum Distance
Separable (MDS) codes that are optimal in terms of erasure recovery capability.
It means that a receiver can recover the k source symbols from any set of exactly k encoding symbols.
These codes are also systematic codes, which means that the k source symbols are part of the encoding
symbols.
However they are limited in terms of maximum source block size and number of encoding symbols.
Since the real-time constraints of media delivery applications usually limit the maximum
source block size, this is not considered to be a major issue in the context of the FEC Framework
for many (but not necessarily all) use-cases.
Additionally, if the encoding/decoding complexity is higher with Reed-Solomon codes than it is with
<xref target="RFC5053"/> or <xref target="RFC5170"/> codes, it remains reasonable for most use-cases,
even in case of a software codec.</t>

<t>Many applications dealing with reliable content transmission or content storage already rely on
packet-based Reed-Solomon erasure recovery codes.
In particular, many of them use the Reed-Solomon codec of Luigi Rizzo  <xref target="RS-codec"/>
<xref target="Rizzo97"/>.
The goal of the present document is to specify Reed-Solomon schemes that are compatible with this codec.
</t>

<t>
More specifically, the <xref target="RFC5510"/> document introduced such Reed-Solomon codes and
several associated FEC schemes that are compatible with the <xref target="RFC5052"/> framework.
The present document inherits from <xref target="RFC5510"/> the specification of the core Reed-Solomon codes
based on Vandermonde matrices, and specifies FEC schemes that are compatible with the
FECFRAME framework <xref target="FECFRAME-FRAMEWORK"/>.
Therefore this document specifies only the information specific to the FECFRAME context and
refers to <xref target="RFC5510"/> for the core specifications of the codes.
</t>

<t>To that purpose, the present document introduces:
<list style="symbols">
	<t> the Fully-Specified FEC Scheme with FEC Encoding ID XXX
	that specifies the use of Reed-Solomon codes over GF(2^^m), with m in {2..16},
	with a simple FEC encoding for arbitrary packet flows;</t>
<!--
	<t> the Fully-Specified FEC Scheme with FEC Encoding ID XXX
	that specifies the use of Reed-Solomon codes over GF(2^^8), 
	with an interleaved FEC encoding for arbitrary packet flows;</t>
-->
	<t> the Fully-Specified FEC Scheme with FEC Encoding ID XXX
	is similar to Scheme XXX except that it is for a single sequenced flow;</t>
<!--
	<t> the Fully-Specified FEC Scheme with FEC Encoding ID XXX
	is similar to Scheme XXX except that it is for a single sequenced flow;</t>
-->
</list>
</t>

<t>
With the simple FEC encoding, a set of Application Data Units (or ADUs) coming from one
or several media delivery applications (e.g., a set of RTP packets), are grouped in a ADU block
and FEC encoded as a whole.
With Reed-Solomon codes over GF(2^^8), there is a strict limit over the number
ADUs that can be protected together, since the number of encoded symbols, n, must
be inferior or equal to 255.
</t>

<!--
<t>
With the interleaved encoding we relax this constraint, and protecting a single set
of ADUs, considered as a whole since they constitute a single ADU block, can require
several independent FEC encodings.
Here a dedicated interleaving solution is used to assign the various source 
symbols to the various source blocks in an optimal way, so as to guaranty the
highest possible erasure recovery capabilities.
</t>
-->
		</section>


		<section anchor="Terminology" title="Terminology">
		<!-- =========================================== -->

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>
		</section>


		<section anchor="DefinitionsNotationsandAbbreviations" title="Definitions Notations and Abbreviations">
		<!-- =========================================== -->


			<section anchor="Definitions" title="Definitions">
			<!-- =========================================== -->

<t>This document uses the following terms and definitions.
Some of them are FEC scheme specific and are in line with <xref target="RFC5052"/>:
<list style="hanging">
<t hangText="Source symbol:">	unit of data used during the encoding process.</t>

<t hangText="Encoding symbol:">	unit of data generated by the encoding process.
				With systematic codes, source symbols are part
				of the encoding symbols.</t>

<t hangText="Repair symbol:">	encoding symbol that is not a source symbol.</t>

<t hangText="Code rate:">	the k/n ratio, i.e., the ratio between the number
				of source symbols and the number of encoding symbols.
				By definition, the code rate is such that: 0 &lt; code rate &le; 1.
				A code rate close to 1 indicates that a small number of repair
				symbols have been produced during the encoding process.</t>

<t hangText="Systematic code:">	FEC code in which the source symbols are part
				of the encoding symbols. The Reed-Solomon codes
				introduced in this document are systematic.</t>

<t hangText="Source block:">	a block of k source symbols that are considered
				together for the encoding.</t>

<t hangText="Packet Erasure Channel:"> 
				a communication path where packets are either
				dropped (e.g., by a congested router, or because the
				number of transmission errors exceeds the correction
				capabilities of the physical layer codes) or
				received. When a packet is received, it is assumed
				that this packet is not corrupted.</t>
</list>
</t>

<t>
Some of them are FECFRAME framework specific and are in line with
<xref target="FECFRAME-FRAMEWORK"/>:
<list style="hanging">
<t hangText="Application Data Unit (ADU):">
				a unit of data coming from (sender) or given to (receiver)
				the media delivery application.
				Depending on the use-case, an ADU can use an RTP encapsulation.</t>

<t hangText="(Source) ADU Flow:">
				a flow of ADUs from a media delivery application
				and to which FEC protection is applied.
				Depending on the use-case, several ADU flows can be protected
				together by the FECFRAME framework.</t>

<t hangText="ADU Block:">	a set of ADUs that are considered together by the FECFRAME
				instance for the purpose of the FEC scheme. 
				Along with the F[], L[], and Pad[] fields, they form the set
				of source symbols over which FEC encoding will be performed.
				</t>

<t hangText="ADU Information (ADUI):">
				a unit of data constituted by the ADU and the associated
				Flow ID, Length and Padding fields
				(<xref target="CommonProc_src_block_creation_global_encoding"/>).
<!--
				and <xref target="CommonProc_src_block_creation_general_case_encoding"/>).
-->
				This is the unit of data that is used to define source symbols.</t>

<t hangText="FEC Framework Configuration Information:">
				the FEC scheme specific information that enables the synchronization
				of the FECFRAME sender and receiver instances.</t>

<t hangText="FEC Source Packet:">
				a data packet submitted to (sender) or received from
				(receiver) the transport protocol.
				It contains an ADU along with its optional Explicit Source
				FEC Payload ID.</t>

<t hangText="FEC Repair Packet:">
				a repair packet submitted to (sender) or received from
				(receiver) the transport protocol.
				It contains a repair symbol along with its Explicit Repair
				FEC Payload ID.</t>
</list>
</t>


<t>
The above terminology is illustrated in <xref target="fig_terminology"/>
(sender point of view):
</t>

<figure anchor="fig_terminology" title="Terminology used in this document (sender).">
  <artwork>
+----------------------+
|     Application      |
+----------------------+
           |
 ADU flow  | (1) Application Data Unit (ADU)
           v
+----------------------+                           +----------------+
|    FEC Framework     |                           |                |
|                      |------------------------- >|  FEC Scheme    |
|(2) Construct an ADU  | (4) Source Symbols for    |                |
|    block             |     this Source Block     |(5) Perform FEC |
|(3) Construct ADU Info|                           |    Encoding    |
|(7) Construct FEC Src |< -------------------------|                |
|    Packets and FEC   |(6) Ex src FEC Payload Ids,|                |
|    Repair Packets    |    Repair FEC Payload Ids,|                |
+----------------------+    Repair Symbols         +----------------+
    |             |
    |(8) FEC Src  |(8') FEC Repair
    |    packets  |     packets
    v             v
+----------------------+
|   Transport Layer    |
|    (e.g., UDP )      |
+----------------------+
  </artwork>
</figure>

			</section>


			<section anchor="Notations" title="Notations">
			<!-- =========================================== -->

<t>This document uses the following notations:
Some of them are FEC scheme specific:
<list style="hanging" hangIndent="7">
<t hangText="k">	denotes the number of source symbols in a source block.</t>
<t hangText="max_k">	denotes the maximum number of source symbols for any source block.</t>
<t hangText="n_r">	denotes the number of repair symbols generated for a source block.</t>
<t hangText="n">	denotes the number of encoding symbols generated for a source block.
			Therefore: n = k + n_r.</t>
<!--
<t>max_n	denotes the maximum number of encoding symbols generated for any
		source block.</t>
-->
<t hangText="E">	denotes the encoding symbol length in bytes.</t>
<t hangText="S">	denotes the encoding symbol length in units of m-bit elements.
			When m = 8, then S and E are equal.</t>
<t hangText="GF(q)">	denotes a finite field (also known as Galois Field) with q elements.
			We assume that q = 2^^m in this document.</t>
<t hangText="m">	defines the length of the elements in the finite field, in bits.
			In this document, m belongs to {2..16}.</t>
<t hangText="q">	defines the number of elements in the finite field.
			We have: q = 2^^m in this specification.</t>
<t hangText="CR">	denotes the "code rate", i.e., the k/n ratio.</t>
<t hangText="a^^b">	denotes a raised to the power b.</t>
</list>
</t>

<t>
Some of them are FECFRAME framework specific:
<list style="hanging" hangIndent="7">
<t hangText="B">	denotes the number of ADUs per ADU block.</t>
<t hangText="max_B">	denotes the maximum number of ADUs for any ADU block.</t>
<t hangText="NumSPA">	(Symbols Per ADU) denotes the size of an ADUI in units of encoding symbols
			This size is constant for a given ADU block but may vary for different ADU blocks.
			We have: 1 &le; NumSPA &le; 16.</t>
<t hangText="tot_k">	denotes the total number of source symbols in an ADU block, tot_k = B * NumSPA.</t>
<!--
<t hangText="NumSB">	denotes the number of source blocks for an ADU block.</t>
-->
</list>
</t>
			</section>

			<section anchor="Abbreviations" title="Abbreviations">
			<!-- =========================================== -->

<t>This document uses the following abbreviations:
<list style="hanging" hangIndent="7">
<t hangText="ADU">	stands for Application Data Unit.</t>
<t hangText="ESI">	stands for Encoding Symbol ID.</t>
<t hangText="FEC">	stands for Forward Error Correction code.</t>
<t hangText="FFCI">	stands for FEC Framework Configuration Information.</t>
<t hangText="RS">	stands for Reed-Solomon.</t>
<t hangText="MDS">	stands for Maximum Distance Separable code.</t>
</list>
</t>
			</section>
		</section>


<!-- =========================================================================================== -->


<section anchor="CommonProcedures" title="Common Procedures Related to the ADU Block and
Source Block Creation">
<!-- ================ -->
<t>
This section introduces the procedures that are used during the ADU block and the related
source block(s) creation, for the various FEC schemes considered.
</t>

	<section anchor="CommonProc_problem" title="Problem Statement">
	<!-- ==================================== -->
<t>
Several aspects must be considered, that impact the source block creation:
<list style="symbols">
<t> the distribution of ADU sizes for the ADU flow(s) protected by the FECFRAME instance;</t>
<t> the maximum source block size (k parameter) and number of encoding symbols
	(n parameter), that are constrained by the finite field size (m parameter);</t>
<t> the potential real-time constraints, that impact the maximum ADU block size,
	since the larger the block size, the larger the decoding delay;</t>
</list>
We now detail each of these aspects.
</t>

<t>
In its most general form the FECFRAME framework and the RS FEC schemes
are meant to protect a set of independent flows.
Since the flows have no relationship to one another, the ADU size of each
flow will potentially vary significantly.
Even in the special case of a single flow, the ADU sizes may largely
vary (e.g., the various frames of a "Group of Pictures (GOP) of an H.264 flow can have
different sizes).
This diversity must be addressed by the source block creation procedure since
the RS FEC scheme requires a constant encoding symbol size (E parameter).
</t>

<t>
The finite field size parameter, m, defines the number of non zero elements in
this field which is equal to: q - 1 = 2^^m - 1.
This q - 1 value is also the theoretical maximum number of encoding symbols that can
be produced for a source block.
For instance, when m = 8 (default) there is a maximum of 2^^8 - 1 = 255 encoding symbols.
So: k &lt; n &le; 255.
Given the target FEC code rate (e.g., provided by the end-user or upper application when
starting the FECFRAME framework, and taking into account the (known or estimated) packet
loss rate), the sender calculates:
      <list style="empty">
	<t>max_k = floor((2^^m - 1) * CR)</t>
      </list>
This max_k value leaves enough room for the sender to produce the
desired number of repair symbols.
</t>

<t>
The source ADU flows usually have real-time constraints. 
It means that the maximum number of ADUs of an ADU block must not exceed a certain
threshold since it directly impacts the decoding delay.
It is the role of the developer, who knows the flow real-time features, to define an
appropriate upper bound to the ADU block size, max_B.
</t>

<!--
<t>
Another aspect is the appropriate way of performing FEC encoding over
the ADU block.
Depending of the actual situation, two strategies are considered in this document:
<list style="symbols">
	<t>There can be situations where a sender needs to protect a "small" number of ADUs.
	In that case the number of source symbols does not exceed the max_k value.
	For this kind of situation, all the ADUs and their associated flow ID, length, and padding
	fields, are virtually split into source symbols and a simple FEC encoding is performed.
	</t>
	<t>There can be situations where a sender needs to protect a "large" number of ADUs.
	In that case the number of symbols can easily exceed the max_k value.
	For this kind of situation, the present document introduces an interleaved encoding
	scheme, which potentially several source blocks over which an independent FEC encoding
	is performed.
	</t>
</list>
These two encoding strategies are introduced in the following sections.
</t>
-->

	</section>


	<section anchor="CommonProc_src_block_creation_global_encoding"
		title="Source Block Creation">
	<!-- ==================================== -->

<t>
The ADU block is always encoded as a single source block.
There are a total of B &le; max_B ADUs in this ADU block.
For the ADU i, with 0 &le; i &le; B-1, 3 bytes are prepended
(<xref target="fig_src_block_creation_global_enc"/>):
<list style="symbols">
	<t>The first byte, FID[i] (Flow ID), contains the integer identifier
		associated to the source ADU flow to which this ADU
		belongs to.
		It is assumed that a single byte is sufficient, or said
		differently, that no more than 256 flows will be protected by
		a single instance of the FECFRAME framework.
	</t>
	<t>The following two bytes, L[i] (Length), contain the length of this
		ADU, in network byte order (i.e., big endian).
		This length is for the ADU itself and does not include the 
		FID[i], L[i], or Pad[i] fields.
	</t>
</list>
</t>

<t>
Let us now assume that the largest ADU of this source block, with the prepended
3 bytes, must be segmented into NumSPA source symbols, each of size E.
By construction, we must have: 1 &le; NumSPA &le; 16.
Since E is fixed for the whole duration of the FECFRAME session, this also means
that the maximum ADUI size is 16 * E bytes.
</t>

<t>
Then zero padding is added to ADU i (if needed) in field Pad[i], for alignment purposes
up to a size of exactly NumSPA * E bytes.
The data unit resulting from the ADU and the F[], L[] and Pad[] fields, is called
ADU Information (or ADUI).
Because of padding, each ADUI contributes to exactly NumSPA source symbols to the source
block. 
However some of the NumSPA source symbols may be totally filled with zero bytes.
As a special case, the encoding symbol size (E) can be chosen to be equal to the
largest ADUI, in which case NumSPA = 1.
</t>
<t>
Thanks to the padding, a source symbol never straddles several ADUIs.
As a direct consequence, a source symbol will never straddle several FEC source packets
that are the payloads transmitted (and possibly erased) over the physical network.
</t>

<figure anchor="fig_src_block_creation_global_enc" title="Source block creation with the
simple encoding scheme, for code rate 1/2 (equal number of source and repair symbols,
7 in this example).">
  <artwork>
  Enc Symbol Len (E)    Enc Symbol Len (E)    Enc Symbol Len (E)
< ------------------ >< ------------------ >< ------------------ >
+----+----+-----------------------+------------------------------+
|F[0]|L[0]|          R[0]         |            Pad[1]            |
+----+----+----------+------------+------------------------------+
|F[1]|L[1]|   R[1]   |                         Pad[2]            |
+----+----+----------+--------------------------------------+----+
|F[2]|L[2]|                      R[2]                       |P[2]|
+----+----+----------+--------------------------------------+----+
|F[3]|L[3]| R[3] |                             Pad[3]            |
+----+----+------+-----------------------------------------------+
\_______________________________  _______________________________/
                                \/
                       simple FEC encoding

+--------------------+
|      Repair 7      |
+--------------------+
.                    .
.                    .
+--------------------+
|      Repair 13     |
+--------------------+
  </artwork>
</figure>

<t>
Note that neither the initial 3 bytes nor the optional padding
are sent over the network.
However, they are considered during FEC encoding.
It means that a receiver who lost a certain FEC source packet (e.g., the
UDP datagram containing this FEC source packet) will be able to recover the ADUI
if FEC decoding succeeds.
Thanks to the initial 3 bytes, this receiver will get rid of the padding (if any)
and identify the corresponding ADU flow.
</t>
	</section>


<!--
	<section anchor="CommonProc_src_block_creation_general_case_encoding"
		title="Source Block Creation with the Interleaved FEC Encoding Strategy">
-->
	<!-- ==================================== -->

<!--
<t>
With the interleaved encoding scheme, the ADU block is too large in terms of number
of source symbols to be encoded in a single source block (i.e., it exceeds the max_k
value, <xref target="CommonProc_problem"/>).
Therefore, the ADU block is split into several source blocks.
Each source block leads to a different FEC encoding and the appropriate number of repair
symbols are generated each time, as specified by the target code rate.
In this section we define an interleaving approach to distribute the source symbols of
the various ADUIs to source blocks in order to guaranty the best possible erasure protection.
</t>

<t>
Note that this solution is preferable to the alternative approach consisting in
considering smaller ADU blocks, from an erasure recovery capability point of view.
Note also that the simple encoding scheme
(<xref target="CommonProc_src_block_creation_global_encoding"/>) can be
regarded as a special case, when there is a single source block and when m = 8.
</t>

<t>
The creation of an ADUI follows the same approach as in
<xref target="CommonProc_src_block_creation_global_encoding"/>:
for the ADU i, with 0 &le; i &le; B-1, 3 bytes are prepended
for the F[i] and L[i] fields and an optional zero padding appended
so that each ADUI contribute to the same number, NumSPA, of source symbols.
The ADU block is naturally identified by the SBN of its first source block.
</t>

<t>
Let us detail the problem of the source symbol to source block assignement approach.
Let:
<list style="hanging" hangIndent="7">
<t hangText="tot_k">	the total number of source symbols in this ADU block.
			In other words, tot_k is equal to B * NumSPA.</t>
<t hangText="NumSB">	the number of source blocks for this ADU block.
			NumSB = ceil(tot_k / max_k).</t>
</list>
We assume that tot_k &ge; max_k (the particular case where it is equal
corresponds to <xref target="CommonProc_src_block_creation_global_encoding"/>).
The key idea is that maximum erasure recovery capabilities requires that the
source symbols for a certain ADUI be spread over the largest possible
number of source blocks.
If a single FEC source packet is lost, each source block associated to the
corresponding ADUI should experience a number of source symbol erasures that
at most equals ceil(NumSPA / NumSB). 
These erasures can often be recovered during FEC decoding since the ceil(NumSPA / NumSB)
value is usually small.
</t>

<t>
This requirement leads to the following interleaving algorithm, that specifies
how source symbols of a given ADU block are assigned to the various source blocks:
</t>
<figure anchor="fig_interleaving_algo_at_a_sender" title="Source symbols to Source blocks interleaving algorithm.">
  <artwork>
src_symbols_to_src_blocks_assignment_at_a_sender ()
{
    NumSB = ceil(tot_k / max_k);  /* number of source blocks */
    int SB_idx = 0;               /* index of current source block */
    for (int i = 0; i < B; i++) {        /* for all the ADUIs */
        for (int j = 0; j < NumSPA; j++) { /* for all symbols of ADUI*/
            add ADUI[i].src_symbol[j]  to src_block[SB_idx];
            SB_idx = (SB_idx + 1) % NumSB;
        }
    }
}
  </artwork>
</figure>

<t>
Let us consider an example (<xref target="fig_src_block_creation_general_case_encoding"/>).
The ADU block consists of five ADUs (B = 5), whose size (in unit of symbols)
is respectively 1, 1, 2, 2, and 3 symbols.
Therefore tot_k = 9 source symbols.
If max_k = 3 symbols, then NumSB = ceil(9/3) = 3 source blocks.
The above algorithm leads to the creation of the following source blocks:
SB0 = {0.0; 2.1; 4.0},
SB1 = {1.0; 3.0; 4.1}, and
SB2 = {2.0; 3.1; 4.2}.
If the FEC source packet corresponding to ADUI 4 is lost during transmission,
then it leads to a single source symbol erasure in each of the three source blocks,
which will easily be recovered during FEC decoding.
</t>
<figure anchor="fig_src_block_creation_general_case_encoding" title="Source block creation with the
interleaved encoding scheme example (the ADUIs are assumed to be already split in symbols and the F[], L[] and Pad[] fields are not represented).">
  <artwork>
        +----------+
ADUI 0: | symb 0.0 |
        +----------+

        +----------+
ADUI 1: | symb 1.0 |
        +----------+

        +----------+----------+
ADUI 2: | symb 2.0 | symb 2.1 |
        +----------+----------+

        +----------+----------+
ADUI 3: | symb 3.0 | symb 3.1 |
        +----------+----------+

        +----------+----------+----------+
ADUI 4: | symb 4.0 | symb 4.1 | symb 4.2 |
        +----------+----------+----------+
  </artwork>
</figure>

<t>
Here also, neither the initial 3 bytes nor the optional padding
are sent over the network.
However, they are considered during FEC encoding.
It means that a receiver who lost a certain FEC source packet (e.g., the
UDP datagram containing this FEC source packet) will be able to recover the ADUI
if FEC decoding succeeds.
Thanks to the initial 3 bytes, this receiver will get rid of the padding (if any)
and identify the corresponding ADU flow.
</t>

	</section>
-->

</section>


<!-- =========================================================================================== -->


<section anchor="RSover2mArbitraryGE" title="Reed-Solomon FEC Encoding Scheme over GF(2^^m) for Arbitrary ADU Flows">
<!-- ==================================== -->

<t>
This Fully-Specified FEC Scheme specifies the use of Reed-Solomon codes over GF(2^^m),
with m in {2..16}, with a simple FEC encoding for arbitrary packet flows.
</t>

	<section anchor="RSover2mArbitraryGE_formatsAndCodes" title="Formats and Codes">
	<!-- ==================================== -->

		<section title="FEC Framework Configuration Information">
		<!-- ================ -->
<t>
The FEC Framework Configuration Information (or FFCI) includes information
that MUST be communicated between the sender and receiver(s).
More specifically, it enables the synchronization of the FECFRAME sender
and receiver instances.
It includes both mandatory elements and scheme-specific elements,
as detailed below.
</t>
			<section title="Mandatory Information">
			<!-- ================ -->
<t>
<list style="symbols">
    <t> FEC Encoding ID: the value assigned to this fully-specified FEC scheme MUST be XXX,
	as assigned by IANA (<xref target="iana-cons"/>).</t>
</list>
When SDP is used to communicate the FFCI, this FEC Encoding ID is carried in
the 'encoding-id' parameter.
</t>
			</section>

			<section title="FEC Scheme-Specific Information"
				 anchor="RSover2mArbitraryGE_fssi">
			<!-- ================ -->
<t>
The FEC Scheme Specific Information (FSSI) includes elements that are specific
to the present FEC scheme. More precisely:
<list style="symbols">
    <t> Encoding symbol length (E) (16 bit field): a non-negative integer that indicates
	the length of each encoding symbol in bytes.</t>
    <t> m parameter (8 bit field): an integer that defines the length of the elements
	in the finite field, in bits.
	In this scheme, m belongs to {2..16}.</t>
</list>
The encoding format consists of the following 3 octet field:
</t>

<figure anchor="fig_RSover2mArbitraryGE_fssi" title="FSSI encoding format."> 
  <artwork>
 0                   1                   2       
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  |       m       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
These elements are required both by the sender (RS encoder) and the receiver(s) (RS decoder).
When SDP is used to communicate the FFCI, this FEC scheme-specific information is carried in
the 'fssi' parameter as an opaque octet string, using a Base64 encoding, as specified in
<xref target="SDP_ELEMENTS"/>.
</t>
			</section>

		</section>


		<section title="Explicit Source FEC Payload ID"
			 anchor="RSover2mArbitraryGE_src_fpi">
		<!-- ================ -->

<t>
A FEC source packet MUST contain an Explicit Source FEC Payload ID that is appended to the
end of the packet as illustrated in <xref target="fig_src_pkt_format"/>.
</t>

<figure anchor="fig_src_pkt_format" title="Structure of a FEC source packet with the
Explicit Source FEC Payload ID."> 
  <artwork>
+--------------------------------+
|           IP Header            |
+--------------------------------+
|        Transport Header        |
+--------------------------------+
|              ADU               |
+--------------------------------+
| Explicit Source FEC Payload ID |
+--------------------------------+
  </artwork>
</figure>

<t>
More precisely, the Explicit Source FEC Payload ID is composed of the NumSPA,
the Source Block Number and the Encoding Symbol ID.
The length of these two fields depends on the m parameter (transmitted
separately in the FFCI, <xref target="RSover2mArbitraryGE_fssi"/>):
<list style="hanging">
<t hangText="Number of Source Symbols per ADU (NumSPA) (4 bit field):">
   this field provides the number of source symbols per ADU for this source block,
   i.e., the NumSPA parameter.
   Though this field might be recovered upon receiving the first FEC repair packet
   for this block, i.e., just on time before doing FEC decoding, it is transmitted
   in the Explicit Source FEC Payload ID too in order to simplify source block preparation
   at the receiver while receiving FEC source packets.
   </t>
<t hangText="Source Block Number (SBN) (32-m bit field):">
   this field identifies the source block to which this FEC source packet belongs.</t>
<t hangText="Encoding Symbol ID (ESI) (m bit field):">
   this field identifies the first source symbol associated to this FEC source packet
   in the source block (remember there can be several source symbols per ADUI,
   <xref target="CommonProc_src_block_creation_global_encoding"/>).
   This value belongs to interval {0..k - 1} inclusive for source symbols.</t>
</list>
</t>

<figure anchor="fig_src_fpi_for_8" title="Source FEC Payload ID encoding format for m = 8 (default)."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| NumSPA|   Source Block Number (28-8=20 bits)  | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<figure anchor="fig_src_fpi_for_16" title="Source FEC Payload ID encoding format for m = 16."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| NumSPA|Source Block Nb (12 b.)|   Enc. Symbol ID (16 bits)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
The format of the Source FEC Payload ID for m = 8 and m = 16 are illustrated in 
<xref target="fig_src_fpi_for_8"/> and <xref target="fig_src_fpi_for_16"/>
respectively.</t>

		</section>

		<section title="Repair FEC Payload ID" anchor="RSover2mArbitraryGE_repair_fpi">
		<!-- ================ -->
<t>
A FEC repair packet MUST contain a Repair FEC Payload ID that is prepended to the
repair symbol(s) as illustrated in <xref target="fig_repair_pkt_format"/>.
There can be several repair symbols per repair packet.
</t>

<figure anchor="fig_repair_pkt_format" title="Structure of a repair packet with the
Repair FEC Payload ID."> 
  <artwork>
+--------------------------------+
|           IP Header            |
+--------------------------------+
|        Transport Header        |
+--------------------------------+
|      Repair FEC Payload ID     |
+--------------------------------+
|        Repair Symbol(s)        |
+--------------------------------+
  </artwork>
</figure>

<t>
More precisely, the Repair FEC Payload ID is composed of the NumSPA, 
the Source Block Number, the Encoding Symbol ID, and the Source Block Length.
The length of some of these fields depends on the m parameter (transmitted
separately in the FFCI, <xref target="RSover2mArbitraryGE_fssi"/>):
<list style="hanging">
<t hangText="Number of Source Symbols per ADU (NumSPA) (4 bit field):">
   this field provides the number of source symbols per ADU for this source block,
   i.e., the NumSPA parameter.</t>
<t hangText="Source Block Number (SBN) (28-m bit field):">
   this field identifies the source block to which the FEC repair packet belongs.</t>
<t hangText="Encoding Symbol ID (ESI) (m bit field)">
   this field identifies the first repair symbol contained in this FEC repair packet
   (remember there can be several repair symbols per FEC repair packet).
   This value belongs to interval {k..n - k - 1} inclusive for repair symbols.</t>
<t hangText="Source Block Length (k) (16 bit field):">
   this field provides the number of source symbols for this source block, i.e., the k parameter.
   If 16 bits are too much when m &le; 8, it is needed when 8 &lt; m &le; 16.</t>
</list>
</t>

<figure anchor="fig_repair_fpi_for_8" title="Repair FEC Payload ID encoding format for m = 8 (default)."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| NumSPA|   Source Block Number (28-8=20 bits)  | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Source Block Length (k)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


  </artwork>
</figure>

<figure anchor="fig_repair_fpi_for_16" title="Repair FEC Payload ID encoding format for m = 16."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| NumSPA|Source Block Nb (12 b.)|   Enc. Symbol ID (16 bits)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Source Block Length (k)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
The format of the Repair FEC Payload ID for m = 8 and m = 16 are illustrated in 
<xref target="fig_repair_fpi_for_8"/> and <xref target="fig_repair_fpi_for_16"/>
respectively.
</t>

<t>
The actual number of repair symbols contained in a FEC repair packet can
be determined by the receiver by comparing the FEC repair packet length, PL,
and the encoding symbol length, E, (transmitted in the FFCI).
More precisely, this number is given by SN = PL / E.
When multiple repair symbols are sent in the same FEC repair packet,
the FEC Payload ID refers to the first repair symbol.
The other repair symbols can be deduced from the ESI of the first repair
symbol by incrementing sequentially this ESI.
</t>

		</section>


	</section> <!-- RSover2mArbitraryGE_formatsAndCodes -->


	<section anchor="RSover2mArbitraryGE_Procedures" title="Procedures">
	<!-- ================ -->
<t>
The following procedures apply:
<list style="symbols">
	<t>
	The source block creation procedures are specified in
	<xref target="CommonProc_src_block_creation_global_encoding"/>.
	</t>
	<t>
	The SBN value is incremented for each new source block, starting at
	0 for the first block of the ADU flow. 
	Wrapping to zero will happen for long sessions, after value 2^^(32-m) - 1.
	</t>
	<t>
	The ESI of source symbols is managed sequentially, starting at
	0 for the first symbol.
	There are a maximum of 2^^m encoding symbols per block.
	The first k values (from 0 to k - 1 inclusive) identify source symbols, whereas
	the last n-k values (from k to n - k - 1 inclusive) identify repair symbols.
	</t>
	<t>
	The FEC repair packet creation procedures are specified in
	<xref target="RSover2mArbitraryGE_repair_fpi"/>.
	</t>
</list>
</t>

	</section>


	<section anchor="RSover2mArbitraryGE_FECCodeSpecification" title="FEC Code Specification">
	<!-- ================ -->
<t>
The present document inherits from <xref target="RFC5510"/> the specification of the
core Reed-Solomon codes based on Vandermonde matrices for a packet transmission channel.
</t>
	</section>

</section> <!-- RSover2mArbitraryGE -->


<!-- =========================================================================================== -->


<!--
<section anchor="RSover28ArbitraryIE" title="Reed-Solomon Interleaved FEC Encoding Scheme over GF(2^^8) for Arbitrary ADU Flows">
==================================== 

<t>
This Fully-Specified FEC Scheme specifies the use of Reed-Solomon codes over GF(2^^8) 
(the restriction to m = 8 is due to practical reasons), with an interleaved FEC encoding
for arbitrary packet flows.
</t>

	<section anchor="RSover28ArbitraryIE_formatsAndCodes" title="Formats and Codes">
	====================================

		<section title="FEC Framework Configuration Information">
		================
<t>
The FEC Framework Configuration Information (or FFCI) includes information
that MUST be communicated between the sender and receiver(s).
More specifically, it enables the synchronization of the FECFRAME sender
and receiver instances.
It includes both mandatory elements and scheme-specific elements,
as detailed below.
</t>

			<section title="Mandatory Information">
			================
<t>
<list style="symbols">
	<t> FEC Encoding ID: the value assigned to this fully-specified FEC scheme MUST be XXX,
	as assigned by IANA (<xref target="iana-cons"/>).</t>
</list>
When SDP is used to communicate the FFCI, this FEC Encoding ID is carried in
the 'encoding-id' parameter.
</t>
			</section>

			<section title="FEC Scheme-Specific Information"
				 anchor="RSover28ArbitraryIE_fssi">
			================
<t>
The FEC Scheme Specific Information (FSSI) includes elements that are specific
to the present FEC scheme. More precisely:
<list style="symbols">
    <t> Encoding symbol length (E) (16 bit field): a non-negative integer that indicates
	the length of each encoding symbol in bytes.</t>
</list>
The encoding format consists of the following 2 octet field:
</t>

<figure anchor="fig_RSover2mArbitraryIE_fssi" title="FSSI encoding format."> 
  <artwork>
 0                   1          
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
These elements are required both by the sender (RS encoder) and the receiver(s) (RS decoder).
When SDP is used to communicate the FFCI, this FEC scheme-specific information is carried in
the 'fssi' parameter as an opaque octet string, using a Base64 encoding, as specified in
<xref target="SDP_ELEMENTS"/>.
</t>
			</section>

		</section>

		<section title="Explicit Source FEC Payload ID" anchor="RSover28ArbitraryIE_src_fpi">
		================

<t>
A FEC source packet MUST contain an Explicit Source FEC Payload ID that is appended to the
end of the packet as illustrated in <xref target="fig_src_pkt_format"/>.
</t>

<t>
More precisely, the Explicit Source FEC Payload ID is composed of:
<list style="hanging">
<t hangText="First Source Block Number (1st_SBN) (16 bit field):">
   this field contains the SBN of the first source block of the ADU block. 
   It is meant to identify the ADU block itself.
   Note that this is not necessarily the SBN of the first symbol of the FEC Source Packet.
   The first block of a session MUST be assigned value 0. Then there are a maximum of 2^^16
   blocks before a wrapping to 0 of this field occurs.
   </t>
<t hangText="Source Block Number Offset (SBN_offset) (8 bit field):">
   this field contains the offset that needs to be added to 1st_SBN to
   obtain the SBN to which the first source symbol of this FEC Source Packet belongs 
   to (remember there can be several source blocks per ADUI).
   There are a maximum number of 256 source blocks per ADU block.
   </t>
<t hangText="Encoding Symbol ID (ESI) (8 bit field):">
   this field identifies the first source symbol associated to this FEC Source Packet
   in the source block (remember there can be several source symbols per ADUI,
   <xref target="CommonProc_src_block_creation_global_encoding"/>).
   This value belongs to interval {0 .. k - 1} inclusive for source symbols.
   </t>
</list>
The format of the FEC Payload ID is illustrated in <xref target="fig_src_fpi_for_ie"/>.
</t>

<figure anchor="fig_src_fpi_for_ie" title="Source FEC Payload ID encoding format."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  1st Src Blk Number (16 bits) |  SBN_offset   | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>


		</section>

		<section title="Repair FEC Payload ID" anchor="RSover28ArbitraryIE_repair_fpi">
		================
<t>
A FEC repair packet MUST contain a Repair FEC Payload ID that is prepended to the
repair symbol(s) as illustrated in <xref target="fig_repair_pkt_format"/>.
</t>

<t>
More precisely, the Explicit Source FEC Payload ID is composed of:
<list style="hanging">
<t hangText="First Source Block Number (1st_SBN) (16 bit field):">
   this field contains the SBN of the first source block of the ADU block. 
   It is meant to identify the ADU block itself.
   Note that this is not necessarily the SBN of the first symbol of the FEC Repair Packet.
   </t>
<t hangText="Source Block Number Offset (SBN_offset) (8 bit field):">
   this field contains the offset that needs to be added to 1st_SBN to
   obtain the SBN to which the first repair symbol of this FEC Repair Packet belongs 
   to (remember there can be several source blocks per ADUI).
   There are a maximum number of 256 source blocks per ADU block.
   </t>
<t hangText="Encoding Symbol ID (ESI) (8 bit field):">
   this field identifies the first repair symbol associated to this FEC Repair Packet
   in the source block (remember there can be several source symbols per ADUI,
   <xref target="CommonProc_src_block_creation_global_encoding"/>).
   This value belongs to interval {k .. n - k - 1} inclusive) for repair symbols.
   </t>
<t hangText="Total number of source symbols (tot_k) (16 bit field):">
   this field indicates the total number of source symbols in this ADU block.
   </t>
<t hangText="Reserved (8 bit field):">
   this field is reserved for future use and MUST be set to 0 in the current specification.
   </t>
<t hangText="Number of Source Blocks (NumSB) (8 bit field):">
   this field indicates the number of source blocks for this ADU block.
   </t>
</list>
The format of the FEC Payload ID is illustrated in <xref target="fig_repair_fpi_for_ie"/>.
</t>

<figure anchor="fig_repair_fpi_for_ie" title="Repair FEC Payload ID encoding format."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  1st Src Blk Number (16 bits) |  SBN_offset   | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              tot_k            |    reserved   | Num Src Blocks|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
Thanks to the tot_k and NumSB information, the receiver is capable of
defining the length of each source block of this ADU block, an information
needed by the Reed-Solomon codec (<xref target="RSover28ArbitraryIE_Procedures"/>).
</t>

		</section>

	</section> RSover28ArbitraryIE_formatsAndCodes

	<section anchor="RSover28ArbitraryIE_Procedures" title="Procedures">
	================
<t>
The source block creation procedures are specified in
<xref target="CommonProc_src_block_creation_general_case_encoding"/>.
More precisely:
<list style="symbols">
	<t>the length indication for the ADU i,
	used to compute the L[i] field, is the actual length of the
	ADU i.
	It MUST NOT include FID[i], L[i], Pad[i], nor the Explicit Source
	FEC Payload ID.
	</t>
	<t>
	The SBN value is incremented for each new source block, starting at
	0 for the first Source BLock of the session. 
	Wrapping to zero will happen for long sessions, after value 2^^(16) - 1.
	</t>
	<t>
	The ESI of source symbols of a given source block are managed sequentially, starting at
	0 for the first symbol.
	</t>
</list>
</t>


<t>
At a receiver, the NumSB source blocks must be correctly reconstructed from the
received FEC Source and Repair Packets, even in presence of erasures.
It requires in particular that the source symbols associated to the ADUI of a received
FEC source packet be correctly assigned to the various source blocks.
Thanks to the Explicit Source FEC Payload ID, this latter fully identifies the source block
and position within this source block for the first source symbol.
Concerning the remaining source symbols of this ADUI, the following algorithm is used:
</t>

<t>
We assume that at least one FEC Repair Packet for this ADU block has been received (otherwise
FEC decoding is anyway impossible).
Then let:
<list style="hanging" hangIndent="7">
<t hangText="ADUI.s">	be the size of the ADUI corresponding to the received FEC Source Packet,
			in units of symbols.</t>
<t hangText="NumSB">	be the number of source blocks for this ADU block.
			This information is contained in the Repair FEC payload ID.</t>
</list>
</t>

<figure anchor="fig_interleaving_algo_at_a_receiver"
 title="Source symbols to source block interleaving algorithm for a received ADUI.">
  <artwork>
src_symbols_to_src_blocks_assignment_at_a_receiver
                (ADUI,  /* ADUI associated to recv'd FEC Src Pkt */
                 FPI)   /* packet's Source FEC Payload ID */
{
    int SB_idx;         /* index of current source block */
    SB_idx = FPI.SBN;   /* start with the 1st source symbol */
    for (j = 0; j < ADUI.s; j++) { /* for all symbols of this ADUI */
        add ADUI.src_symbol[j]  to src_block[SB_idx];
        SB_idx = (SB_idx + 1) % NumSB;
    }
}
  </artwork>
</figure>

<t>
The second constraint is that a receiver be able to define the length of each
source block of this ADU block.
To that purpose, after receiving the first FEC Repair Packet for this ADU block,
the following algorithm is used:
</t>

<figure anchor="fig_block_structure_algo_at_a_receiver"
 title="ADU Block structure algorithm at a receiver.">
  <artwork>
adu_block_structure_definition_at_a_receiver
                 (FPI)   /* packet's Repair FEC Payload ID */
{
    int SB_idx;          /* index of current source block */
    int k1;              /* all src blocks are at least that long */
    int rem;             /* and the first rem have 1 extra symbol */
    k1 = floor(FPI.tot_k / FPI.NumSB); /* the integral part... */
    rem = FPI.tot_k % FPI.NumSB;       /* ...and the modulo */
    for (SB_idx = 0; SB_idx < FPI.NumSB; SB_idx++) {
        if (SB_idx < rem) {
            src_block[SB_idx].k = k1 + 1;
        } else {
            src_block[SB_idx].k = k1;
        }
    }
}
  </artwork>
</figure>


	</section>

	<section anchor="RSover28ArbitraryIE_FECCodeSpecification" title="FEC Code Specification">
	================ 
<t>
The present document inherits from <xref target="RFC5510"/> the specification of the
core Reed-Solomon codes based on Vandermonde matrices.
</t>
	</section>

</section>
-->
	<!-- RSover28ArbitraryIE -->


<section anchor="RSover2mSSFlowGE" title="Reed-Solomon FEC Encoding Scheme over GF(2^^m) for a Single Sequenced ADU Flow">
<!-- ==================================== -->

<t>
TBD
</t>

</section> <!-- RSover2mSSFlowGE -->


<!--
<section anchor="RSover2mSSFlowGCE" title="Reed-Solomon Interleaved FEC Encoding Scheme over GF(2^^8) for a Single Sequenced ADU Flow">
==================================== 


<t>
TBD
</t>

</section> RSover2mSSFlowGCE 
-->


<section anchor="SecurityConsiderations" title="Security Considerations">
<!-- ==================================== -->


  <section title="Problem Statement">
  <!-- ================ -->

<t>
A content delivery system is potentially subject to many attacks.
Some of them target the network (e.g., to compromise the routing infrastructure,
by compromising the congestion control component), others target
the Content Delivery Protocol (CDP) (e.g., to compromise its normal behavior),
and finally some attacks target the content itself.
Since this document focuses on various FEC schemes, this
section only discusses the additional threats that their use within the
FECFRAME framework can create to an arbitrary CDP.
</t>

<t>
More specifically, these attacks may have several goals:
<list style="symbols">
	<t> those that are meant to give access to a confidential content (e.g., in
	  case of a non-free content),</t>
	<t> those that try to corrupt the ADU Flows being transmitted (e.g., to
	  prevent a receiver from using it),</t>
	<t> and those that try to compromise the receiver's behavior (e.g., by
	  making the decoding of an object computationally expensive).</t>
</list>
These attacks can be launched either against the data flow itself (e.g.,
by sending forged FEC Source/Repair Packets) or against the FEC parameters that are
sent either in-band (e.g., in the Repair FEC Payload ID) or out-of-band (e.g., in
a session description).
</t>

  </section>

  <section title="Attacks Against the Data Flow">
  <!-- ================ -->

<t>
First of all, let us consider the attacks against the data flow.
</t>


	<section title="Access to Confidential Contents">
	<!-- ================ -->

<t>
Access control to the ADU Flow being transmitted is typically provided by means
of encryption.
This encryption can be done within the content provider itself, by the
application (for instance by using the Secure Real-time Transport Protocol (SRTP)
<xref target="RFC3711"/>), or at the Network Layer, on a packet per packet basis
when IPSec/ESP is used <xref target="RFC4303"/>.
If confidentiality is a concern, it is RECOMMENDED that one of these solutions be used.
Even if we mention these attacks here, they are not related nor facilitated by
the use of FEC.
</t>

	</section>

	<section title="Content Corruption" anchor="sec_content_corruption">
	<!-- ================ -->

<t>
Protection against corruptions (e.g., after sending forged FEC Source/Repair Packets)
is achieved by means of a content integrity verification/sender authentication scheme.
This service is usually provided at the packet level. In this case, after 
removing all forged packets, the ADU Flow may be sometimes recovered.
Several techniques can provide this source authentication/content integrity
service:
<list style="symbols">
<!--
<t> at the packet level, each packet can be digitally signed. A major limitation is
  the high computational and transmission overheads that this solution requires (unless
  perhaps if Elliptic Curve Cryptography (ECC) is used).
  To avoid this problem, the signature may span a set of symbols (instead of a
  single one) in order to amortize the signature calculation.
  But if a single symbol is missing, the integrity of the whole set cannot be checked;</t>

<t> at the packet level, a Group Message Authentication Code (MAC) <xref target="RFC2104"/>
  scheme can be used, for instance by using HMAC-SHA-1 with a secret key shared by all
  the group members, senders and receivers.
  This technique creates a cryptographically secured (thanks to the secret key)
  digest of a packet that is sent along with the packet.
  The Group MAC scheme  does not create prohibitive processing load nor transmission
  overhead, but it has a major limitation: it only provides a group authentication/integrity
  service since all group members share the same secret group key, which means that each
  member can send a forged packet. It is therefore restricted to situations where
  group members are fully trusted (or in association with another technique as a
  pre-check);</t>

<t> at the packet level, Timed Efficient Stream Loss-Tolerant Authentication (TESLA)
  <xref target="RFC4082"/> is an attractive solution that is robust to losses, provides
  a true authentication/integrity service, and does not create any prohibitive processing
  load or transmission overhead.
  Yet, checking a packet requires a small delay (a second or more) after its reception.
  For instance, <xref target="RFC4383"/> details the use of TESLA within SRTP.XXXXXXXX</t>

-->
<t>	at the application level, the Secure Real-time Transport Protocol (SRTP)
	<xref target="RFC3711"/> provides several solutions to authenticate the source and
	check the integrity of RTP and RTCP messages, among other services.
	For instance, associated to the Timed Efficient Stream Loss-Tolerant Authentication (TESLA)
	<xref target="RFC4383"/>, SRTP is an attractive solution that is robust to losses, provides
	a true authentication/integrity service, and does not create any prohibitive processing
	load or transmission overhead.
	Yet, checking a packet requires a small delay (a second or more) after its reception with
	TESLA.
	Other building blocks can be used within SRTP to provide authentication/content
	integrity services.
</t>
<t>	at the Network Layer, IPSec/ESP offers (among other services) an integrity verification
	mechanism that can be used to provide authentication/content integrity services.
</t>
</list>
</t>

<!--
<t>
Techniques relying on public key cryptography (digital signatures and TESLA during
the bootstrap process, when used) require that public keys be securely associated
to the entities. This can be achieved by a Public Key Infrastructure (PKI), or by a
PGP Web of Trust, or by pre-distributing the public keys of each group member.
</t>

<t>
Techniques relying on symmetric key cryptography (group MAC) require that a
secret key be shared by all group members. This can be achieved by means of a
group key management protocol, or simply by pre-distributing the secret key
(but this manual solution has many limitations).
</t>
-->

<t>
It is up to the developer and deployer, who know the security requirements and
features of the target application area, to define which solution is the most appropriate.
Nonetheless it is RECOMMENDED that at least one of these techniques be used.
</t>
	</section>

  </section>

  <section title="Attacks Against the FEC Parameters">
  <!-- ================ -->

<t>
Let us now consider attacks against the FEC parameters included in the FFCI that
are usually sent out-of-band (e.g., in a session description).
Attacks on these FEC parameters can prevent the decoding of the associated object.
For instance modifying the m field (when applicable) will lead a receiver to consider
a different code.
Modifying the E parameter will lead a receiver to consider bad Repair Symbols for
a received FEC Repair Packet.
</t>

<t>
It is therefore RECOMMENDED that security measures be taken to guarantee the
FFCI integrity.
When the FFCI is sent out-of-band in a session description,
this latter SHOULD be protected, for instance by digitally signing it.
</t>

<t>
Attacks are also possible against some FEC parameters included in the
Explicit Source FEC Payload ID and Repair FEC Payload ID.
For instance modifying the Source Block Number of a FEC Source of Repair Packet will
lead a receiver to assign this packet to a wrong block.
</t>

<t>
It is therefore RECOMMENDED that security measures be taken to guarantee the
Explicit Source FEC Payload ID and Repair FEC Payload ID integrity.
To that purpose, one of the packet-level source authentication/content integrity
techniques of <xref target="sec_content_corruption"/> can be used.
</t>

  </section>

</section>


			<section anchor="iana-cons" title="IANA Considerations">
			<!-- =============================================== -->
<t>
Values of FEC Encoding IDs are subject to IANA registration.
</t>
<t>
TBD
</t>
			</section>

			<section anchor="Acknowledgments" title="Acknowledgments">
			<!-- =============================================== -->
				<t>
The authors want to thank Hitoshi Asaeda for his valuable comments.
            </t>
			</section>
	</middle>
	<back>

		<references title="Normative References">
		<!-- ==================================== -->
			<reference anchor="RFC2119">
				<front>
					<title>Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials="S." surname="Bradner" fullname="Scott Bradner">
						<organization/>
					</author>
					<date year=""/>
				</front>
				<seriesInfo name="RFC" value="2119"/>
			</reference>

			<reference anchor="RFC5052">
				<front>
					<title>Forward Error Correction (FEC) Building Block</title>
					<author initials="M." surname="Watson"> <organization/> </author>
					<author initials='M.' surname='Luby'> <organization /> </author>
					<author initials='L.' surname='Vicisano'> <organization /> </author>
					<date month="August" year="2007"/>
				</front>
				<seriesInfo name="RFC" value="5052"/>
			</reference>

			<reference anchor="RFC5510">
				<front>
				<title>Reed-Solomon Forward Error Correction (FEC) Schemes</title>
					<author initials="J." surname="Lacan" fullname="Jerome Lacan">
						<organization></organization> </author>
					<author initials="V." surname="Roca" fullname="Vincent Roca">
						<organization></organization> </author>
					<author initials="J." surname="Peltotalo" fullname="Jani Peltotalo">
						<organization></organization> </author>
					<author initials="S." surname="Peltotalo" fullname="Sami Peltotalo">
						<organization></organization> </author>
					<date month="April" year="2009" />
				</front>
				<seriesInfo name="RFC" value="5510" />
			</reference>

			<reference anchor="FECFRAME-FRAMEWORK">
				<front>
				<title>Forward Error Correction (FEC) Framework</title>
					<author initials="M." surname="Watson" fullname="Mark Watson"> <organization/> </author>
					<date month="March" year="2010" />
				</front>
				<seriesInfo name="draft-ietf-fecframe-framework-07" value="(Work in Progress)" />
			</reference>

			<reference anchor="SDP_ELEMENTS">
				<front>
				<title>SDP Elements for FEC Framework</title>
					<author initials="A." surname="Begen" fullname="Ali Begen"> <organization/> </author>
					<date month="August" year="2009" />
				</front>
				<seriesInfo name="draft-ietf-fecframe-sdp-elements-04" value="(Work in Progress)" />
			</reference>

		</references>

		<references title="Informative References">
		<!-- ==================================== -->

			<reference anchor="RFC3453">
				<front>
					<title>The Use of Forward Error Correction (FEC) in Reliable Multicast</title>
					<author initials="M." surname="Luby" fullname="M. Luby"> <organization/> </author>
					<author initials="L." surname="Vicisano" fullname="L. Vicisano"> <organization/> </author>
						<author initials="J." surname="Gemmell" fullname="J. Gemmell"> <organization/> </author>
						<author initials="L." surname="Rizzo" fullname="L. Rizzo"> <organization/> </author>
						<author initials="M." surname="Handley" fullname="M. Handley"> <organization/> </author>
						<author initials="J." surname="Crowcroft" fullname="J. Crowcroft"> <organization/> </author>
					<date month="December" year="2002"/>
				</front>
				<seriesInfo name="RFC" value="3453"/>
			</reference>

			<reference anchor="RS-codec">
				<front>
					<title>Reed-Solomon FEC codec (revised version of July 2nd, 1998), available at
http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz and mirrored at http://planete-bcast.inrialpes.fr/</title>
					<author initials="L." surname="Rizzo" fullname="Luigi Rizzo">
						<organization/>
					</author>
					<date month="July" year="1998"/>
				</front>
			</reference>

			<reference anchor="Rizzo97">
				<front>
					<title>Effective Erasure Codes for Reliable Computer Communication Protocols</title>
					<author initials="L." surname="Rizzo" fullname="Luigi Rizzo">
						<organization/>
					</author>
					<date month="April" year="1997" />
				</front>
				<seriesInfo name="ACM SIGCOMM Computer Communication Review" value="Vol.27, No.2, pp.24-36" />
			</reference>

			<reference anchor="RFC5170">
				<front>
					<title>Low Density Parity Check (LDPC) Forward Error Correction</title>
					<author initials="V." surname="Roca"> <organization/> </author>
					<author initials="C." surname="Neumann"> <organization /> </author>
					<author initials="D." surname="Furodet"> <organization /> </author>
					<date month="June" year="2008"/>
				</front>
				<seriesInfo name="RFC" value="5170"/>
			</reference>

			<reference anchor="RFC5053">
				<front>
					<title>Raptor Forward Error Correction Scheme</title>
					<author initials="M." surname="Luby" fullname="M. Luby"> <organization/> </author>
					<author initials="A" surname="Shokrollahi" fullname="A. Shokrollahi"> <organization/> </author>
					<author initials="M" surname="Watson" fullname="M.  Watson"> <organization/> </author>
					<author initials="T" surname="Stockhammer" fullname="T. Stockhammer"> <organization/> </author>
					<date month="June" year="2007"/>
				</front>
				<seriesInfo name="RFC" value="5053"/>
			</reference>

			<reference anchor="RMT-PI-ALC">
				<front>
					<title>Asynchronous Layered Coding (ALC) Protocol Instantiation</title>
					<author initials="M." surname="Luby"> <organization></organization> </author>
					<author initials="M." surname="Watson"> <organization></organization> </author>
					<author initials="L." surname="Vicisano"> <organization></organization> </author>
					<date month="November" year="2009" />
				</front>
				<seriesInfo name="draft-ietf-rmt-pi-alc-revised-10" value="(work in progress)" />
			</reference>

			<reference anchor="RFC5740">
				<front>
					<title>Negative-acknowledgment (NACK)-Oriented Reliable Multicast
					(NORM) Protocol</title>
					<author initials="B." surname="Adamson"> <organization></organization> </author>
					<author initials="C." surname="Bormann"> <organization></organization> </author>
					<author initials="M." surname="Handley"> <organization></organization> </author>
					<author initials="J." surname="Macker"> <organization></organization> </author>
					<date month="November" year="2009" />
				</front>
				<seriesInfo name="RFC" value="5740" />
			</reference>

			<!-- =================================================== -->

<!--
			<reference anchor="RFC3447">
				<front>
					<title>Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</title>
					<author initials="J." surname="Jonsson" fullname="J. Jonsson"> <organization/> </author>
					<author initials="B." surname="Kaliski" fullname="B. Kaliski"> <organization/> </author>
					<date year="2003" month="February"/>
				</front>
				<seriesInfo name="RFC" value="3447"/>
				<format type="TXT" octets="143173" target="ftp://ftp.isi.edu/in-notes/rfc3447.txt"/>
			</reference>
-->

			<reference anchor="RFC4303">
				<front>
					<title>IP Encapsulating Security Payload (ESP)</title>
					<author initials="S." surname="Kent" fullname="S. Kent"> <organization/> </author>
					<date year="2005" month="December"/>
				</front>
				<seriesInfo name="RFC" value="4303"/>
				<format type="TXT" octets="114315" target="ftp://ftp.isi.edu/in-notes/rfc4303.txt"/>
			</reference>

<!--
			<reference anchor="RFC2104">
				<front>
					<title>HMAC: Keyed-Hashing for Message Authentication</title>
					<author fullname="H. Krawczyk"> <organization/> </author>
					<author fullname="M. Bellare"> <organization/> </author>
					<author fullname="R. Canetti"> <organization/> </author>
					<date month="February" year="1997"/>
				</front>
				<seriesInfo name="RFC" value="2104"/>
			</reference>
-->

			<reference anchor='RFC3711'>
				<front>
					<title>The Secure Real-time Transport Protocol (SRTP)</title>
					<author initials='M.' surname='Baugher' fullname='M. Baugher'><organization /></author>
					<author initials='D.' surname='McGrew' fullname='D. McGrew'><organization /></author>
					<author initials='M.' surname='Naslund' fullname='M. Naslund'><organization /></author>
					<author initials='E.' surname='Carrara' fullname='E. Carrara'><organization /></author>
					<author initials='K.' surname='Norrman' fullname='K. Norrman'><organization /></author>
					<date year='2004' month='March' />
				</front>
				<seriesInfo name='RFC' value='3711' />
				<format type='TXT' octets='134270' target='ftp://ftp.isi.edu/in-notes/rfc3711.txt' />
			</reference>

<!--
			<reference anchor="RFC4082">
				<front>
					<title>Timed Efficient Stream Loss-Tolerant Authentication (TESLA):
						Multicast Source Authentication Transform Introduction</title>
					<author fullname="A. Perrig"> <organization/> </author>
					<author fullname="D. Song"> <organization/> </author>
					<author fullname="R. Canetti"> <organization/> </author>
					<author fullname="J.D. Tygar"> <organization/> </author>
					<author fullname="B. Briscoe"> <organization/> </author>
					<date month="June" year="2005"/>
				</front>
				<seriesInfo name="RFC" value="4082"/>
			</reference>
-->

			<reference anchor="RFC4383">
				<front>
					<title>
					The Use of Timed Efficient Stream Loss-Tolerant Authentication (TESLA) in the Secure Real-time Transport Protocol (SRTP)
					</title>
					<author initials="M." surname="Baugher" fullname="M. Baugher"><organization/></author>
					<author initials="E." surname="Carrara" fullname="E. Carrara"><organization/></author>
					<date year="2006" month="February"/>
				</front>
				<seriesInfo name="RFC" value="4383"/>
				<format type="TXT" octets="41766" target="ftp://ftp.isi.edu/in-notes/rfc4383.txt"/>
			</reference>

<!--
			<reference anchor="RFC3275">
				<front>
					<title>(Extensible Markup Language) XML-Signature Syntax and Processing</title>
					<author initials="D." surname="Eastlake" fullname="D. Eastlake"> <organization/>
					</author>
					<author initials="J." surname="Reagle" fullname="J. Reagle"> <organization/>
					</author>
					<author initials="D." surname="Solo" fullname="D. Solo"> <organization/>
					</author>
					<date year="2002" month="March"/>
				</front>
				<seriesInfo name="RFC" value="3275"/>
				<format type="TXT" octets="164198" target="ftp://ftp.isi.edu/in-notes/rfc3275.txt"/>
			</reference>
-->

		</references>
	</back>
</rfc>
