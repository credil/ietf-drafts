


RMT                                                              V. Roca
Internet-Draft                                                     INRIA
Intended status: Experimental                                 C. Neumann
Expires: November 8, 2007                               Thomson Research
                                                              D. Furodet
                                                      STMicroelectronics
                                                             May 7, 2007


  Low Density Parity Check (LDPC) Staircase and Triangle Forward Error
                        Correction (FEC) Schemes
                   draft-ietf-rmt-bb-fec-ldpc-06.txt

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on November 8, 2007.

Copyright Notice

   Copyright (C) The IETF Trust (2007).










Roca, et al.            Expires November 8, 2007                [Page 1]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


Abstract

   This document describes two Fully-Specified FEC Schemes, LDPC-
   Staircase and LDPC-Triangle, and their application to the reliable
   delivery of objects on packet erasure channels.  These systematic FEC
   codes belong to the well known class of ``Low Density Parity Check''
   (LDPC) codes, and are large block FEC codes in the sense of RFC3453.












































Roca, et al.            Expires November 8, 2007                [Page 2]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  Requirements notation  . . . . . . . . . . . . . . . . . . . .  5
   3.  Definitions, Notations and Abbreviations . . . . . . . . . . .  6
     3.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . . .  6
     3.2.  Notations  . . . . . . . . . . . . . . . . . . . . . . . .  6
     3.3.  Abbreviations  . . . . . . . . . . . . . . . . . . . . . .  7
   4.  Formats and Codes  . . . . . . . . . . . . . . . . . . . . . .  8
     4.1.  FEC Payload IDs  . . . . . . . . . . . . . . . . . . . . .  8
     4.2.  FEC Object Transmission Information  . . . . . . . . . . .  8
       4.2.1.  Mandatory Element  . . . . . . . . . . . . . . . . . .  8
       4.2.2.  Common Elements  . . . . . . . . . . . . . . . . . . .  8
       4.2.3.  Scheme-Specific Elements . . . . . . . . . . . . . . .  9
       4.2.4.  Encoding Format  . . . . . . . . . . . . . . . . . . .  9
   5.  Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . 12
     5.1.  General  . . . . . . . . . . . . . . . . . . . . . . . . . 12
     5.2.  Determining the Maximum Source Block Length (B)  . . . . . 13
     5.3.  Determining the Encoding Symbol Length (E) and Number
           of Encoding Symbols per Group (G)  . . . . . . . . . . . . 13
     5.4.  Determining the Number of Encoding Symbols of a Block  . . 15
     5.5.  Identifying the Symbols of an Encoding Symbol Group  . . . 16
     5.6.  Pseudo Random Number Generator . . . . . . . . . . . . . . 19
   6.  Full Specification of the LDPC-Staircase Scheme  . . . . . . . 21
     6.1.  General  . . . . . . . . . . . . . . . . . . . . . . . . . 21
     6.2.  Parity Check Matrix Creation . . . . . . . . . . . . . . . 21
     6.3.  Encoding . . . . . . . . . . . . . . . . . . . . . . . . . 22
     6.4.  Decoding . . . . . . . . . . . . . . . . . . . . . . . . . 23
   7.  Full Specification of the LDPC-Triangle Scheme . . . . . . . . 24
     7.1.  General  . . . . . . . . . . . . . . . . . . . . . . . . . 24
     7.2.  Parity Check Matrix Creation . . . . . . . . . . . . . . . 24
     7.3.  Encoding . . . . . . . . . . . . . . . . . . . . . . . . . 24
     7.4.  Decoding . . . . . . . . . . . . . . . . . . . . . . . . . 25
   8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 26
   9.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 27
   10. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 28
   11. References . . . . . . . . . . . . . . . . . . . . . . . . . . 29
     11.1. Normative References . . . . . . . . . . . . . . . . . . . 29
     11.2. Informative References . . . . . . . . . . . . . . . . . . 29
   Appendix A.  Trivial Decoding Algorithm (Informative Only) . . . . 31
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 33
   Intellectual Property and Copyright Statements . . . . . . . . . . 34









Roca, et al.            Expires November 8, 2007                [Page 3]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


1.  Introduction

   RFC 3453 [3] introduces large block FEC codes as an alternative to
   small block FEC codes like Reed-Solomon.  The main advantage of such
   large block codes is the possibility to operate efficiently on source
   blocks of size several tens of thousands (or more) source symbols.
   The present document introduces the Fully-Specified FEC Encoding ID 3
   that is intended to be used with the LDPC-Staircase FEC codes, and
   the Fully-Specified FEC Encoding ID 4 that is intended to be used
   with the LDPC-Triangle FEC codes [6][9].  Both schemes belong to the
   broad class of large block codes.

   LDPC codes rely on a dedicated matrix, called a "Parity Check
   Matrix", at the encoding and decoding ends.  The parity check matrix
   defines relationships (or constraints) between the various encoding
   symbols (i.e. source symbols and repair symbols), that are later used
   by the decoder to reconstruct the original k source symbols if some
   of them are missing.  These codes are systematic, in the sense that
   the encoding symbols include the source symbols in addition to the
   repair symbols.

   Since the encoder and decoder must operate on the same parity check
   matrix, information must be communicated between them as part of the
   FEC Object Transmission Information.

   A publicly available reference implementation of these codes is
   available and distributed under a GNU/LGPL license [8].
























Roca, et al.            Expires November 8, 2007                [Page 4]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


2.  Requirements notation

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [1].














































Roca, et al.            Expires November 8, 2007                [Page 5]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


3.  Definitions, Notations and Abbreviations

3.1.  Definitions

   This document uses the same terms and definitions as those specified
   in [2].  Additionally, it uses the following definitions:

      Encoding Symbol Group: a group of encoding symbols that are sent
      together, within the same packet, and whose relationships to the
      source object can be derived from a single Encoding Symbol ID.

      Source Packet: a data packet containing only source symbols.

      Repair Packet: a data packet containing only repair symbols.

3.2.  Notations

   This document uses the following notations:

      L denotes the object transfer length in bytes

      k denotes the source block length in symbols, i.e. the number of
      source symbols of a source block

      n denotes the encoding block length, i.e. the number of encoding
      symbols generated for a source block

      E denotes the encoding symbol length in bytes

      B denotes the maximum source block length in symbols, i.e. the
      maximum number of source symbols per source block

      N denotes the number of source blocks into which the object shall
      be partitioned

      G denotes the number of encoding symbols per group, i.e. the
      number of symbols sent in the same packet

      rate denotes the "code rate", i.e. the k/n ratio

      max_n denotes the maximum number of encoding symbols generated for
      any source block

      H denotes the parity check matrix

      srand(s) denotes the initialization function of the pseudo-random
      number generator, where s is the seed (s > 0)




Roca, et al.            Expires November 8, 2007                [Page 6]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


      rand(m) denotes a pseudo-random number generator that returns a
      new random integer in [0; m-1] each time it is called

3.3.  Abbreviations

   This document uses the following abbreviations:

      ESI: Encoding Symbol ID

      FEC OTI: FEC Object Transmission Information

      FPI: FEC Payload ID

      LDPC: Low Density Parity Check

      PRNG: Pseudo Random Number Generator



































Roca, et al.            Expires November 8, 2007                [Page 7]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


4.  Formats and Codes

4.1.  FEC Payload IDs

   The FEC Payload ID is composed of the Source Block Number and the
   Encoding Symbol ID:

      The Source Block Number (12 bit field) identifies from which
      source block of the object the encoding symbol(s) in the packet
      payload is(are) generated.  There are a maximum of 2^^12 blocks
      per object.  Source block numbering starts at 0.

      The Encoding Symbol ID (20 bit field) identifies which encoding
      symbol(s) generated from the source block is(are) carried in the
      packet payload.  There are a maximum of 2^^20 encoding symbols per
      block.  The first k values (0 to k-1) identify source symbols, the
      remaining n-k values (k to n-k-1) identify repair symbols.

   There MUST be exactly one FEC Payload ID per packet.  In case of an
   Encoding Symbol Group, when multiple encoding symbols are sent in the
   same packet, the FEC Payload ID refers to the first symbol of the
   packet.  The other symbols can be deduced from the ESI of the first
   symbol thanks to a dedicated function, as explained in Section 5.5

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Source Block Number  |      Encoding Symbol ID (20 bits)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Figure 1: FEC Payload ID encoding format for FEC Encoding ID 3 and 4

4.2.  FEC Object Transmission Information

4.2.1.  Mandatory Element

   o  FEC Encoding ID: the LDPC-Staircase and LDPC-Triangle Fully-
      Specified FEC Schemes use respectively the FEC Encoding ID 3
      (Staircase) and 4 (Triangle).

4.2.2.  Common Elements

   The following elements MUST be defined with the present FEC Scheme:

   o  Transfer-Length (L): a non-negative integer indicating the length
      of the object in bytes.  There are some restrictions on the
      maximum Transfer-Length that can be supported:




Roca, et al.            Expires November 8, 2007                [Page 8]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


         maximum transfer length = 2^^12 * B * E

      For instance, if B=2^^19 (because of a code rate of 1/2,
      Section 5.2), and if E=1024 bytes, then the maximum transfer
      length is 2^^41 bytes (or 2 TB).  The upper limit, with symbols of
      size 2^^16-1 bytes and a code rate larger or equal to 1/2, amounts
      to 2^^47 bytes (or 128 TB).

   o  Encoding-Symbol-Length (E): a non-negative integer indicating the
      length of each encoding symbol in bytes.

   o  Maximum-Source-Block-Length (B): a non-negative integer indicating
      the maximum number of source symbols in a source block.  There are
      some restrictions on the maximum B value, as explained in
      Section 5.2.

   o  Max-Number-of-Encoding-Symbols (max_n): a non-negative integer
      indicating the maximum number of encoding symbols generated for
      any source block.  There are some restrictions on the maximum
      max_n value.  In particular max_n is at most equal to 2^^20.

   Section 5 explains how to define the values of each of these
   elements.

4.2.3.  Scheme-Specific Elements

   The following elements MUST be defined with the present FEC Scheme:

   o  G: a non-negative integer indicating the number of encoding
      symbols per group (i.e. per packet).  The default value is 1,
      meaning that each packet contains exactly one symbol.  Values
      greater than 1 can also be defined, as explained in Section 5.3.

   o  PRNG seed: the seed is a 32 bit unsigned integer between 1 and
      0x7FFFFFFE (i.e. 2^^31-2) inclusive.  This value is used to
      initialize the Pseudo Random Number Generator (Section 5.6).  This
      element is optional.  Whether or not it is present in the FEC OTI
      is signaled in the associated encoding format through an
      appropriate mechanism (Section 4.2.4).  When the PRNG seed is not
      carried within the FEC OTI, it is assumed that encoder and
      decoders use another way to communicate the information, or use a
      fixed, predefined value.

4.2.4.  Encoding Format

   This section shows two possible encoding formats of the above FEC
   OTI.  The present document does not specify when or how these
   encoding formats should be used.



Roca, et al.            Expires November 8, 2007                [Page 9]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


4.2.4.1.  Using the General EXT_FTI Format

   The FEC OTI binary format is the following, when the EXT_FTI
   mechanism is used (e.g. within the ALC [13] or NORM [15] protocols).

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HET = 64    | HEL (=4 or 5) |                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
   |                      Transfer-Length (L)                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Encoding Symbol Length (E)  |       G       |   B (MSB)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        B (LSB)        |   Max Nb of Enc. Symbols  (max_n)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   .                       Optional PRNG seed                      .
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

           Figure 2: EXT_FTI Header for FEC Encoding ID 3 and 4.

   In particular:

   o  The HEL (Header Extension Length) indicates whether the optional
      PRNG seed is present (HEL=5) or not (HEL=4).

   o  The Transfer-Length (L) field size (48 bits) is larger than the
      size required to store the maximum transfer length (Section 4.2.2)
      for field alignment purposes.

   o  The Maximum-Source-Block-Length (B) field (20 bits) is split into
      two parts: the 8 most significant bits (MSB) are in the third 32-
      bit word of the EXT_FTI, and the remaining 12 least significant
      bits (LSB) are in the fourth 32-bit word.

4.2.4.2.  Using the FDT Instance (FLUTE specific)

   When it is desired that the FEC OTI be carried in the FDT Instance of
   a FLUTE session [14], the following XML attributes must be described
   for the associated object:

   o  FEC-OTI-FEC-Encoding-ID

   o  FEC-OTI-Transfer-length

   o  FEC-OTI-Encoding-Symbol-Length





Roca, et al.            Expires November 8, 2007               [Page 10]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


   o  FEC-OTI-Maximum-Source-Block-Length

   o  FEC-OTI-Max-Number-of-Encoding-Symbols

   o  FEC-OTI-Scheme-Specific-Info

   The FEC-OTI-Scheme-Specific-Info contains the string resulting from
   the Base64 encoding (in the XML Schema xs:base64Binary sense) of the
   following value:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        PRNG seed                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       G       |
   +-+-+-+-+-+-+-+-+

    Figure 3: FEC OTI Scheme Specific Information to be Included in the
                 FDT Instance for FEC Encoding ID 3 and 4.

   When no PRNG seed is to be carried in the FEC OTI, the seed field
   MUST be set to 0 (which is not a valid seed value).  Otherwise the
   seed field contains a valid value as explained in Section 4.2.3.

   After Base64 encoding, the 5 bytes of the FEC OTI Scheme Specific
   Information are transformed into a string of 8 printable characters
   (in the 64-character alphabet) and added to the FEC-OTI-Scheme-
   Specific-Info attribute.






















Roca, et al.            Expires November 8, 2007               [Page 11]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


5.  Procedures

   This section defines procedures that are common to FEC Encoding IDs 3
   and 4.

5.1.  General

   The B (maximum source block length in symbols) and E (encoding symbol
   length in bytes) parameters are first determined, as explained in the
   following sections.

   The source object is then partitioned using the block partitioning
   algorithm specified in [2].  To that purpose, the B, L (object
   transfer length in bytes), and E arguments are provided.  As a
   result, the object is partitioned into N source blocks.  These blocks
   are numbered consecutively from 0 to N-1.  The first I source blocks
   consist of A_large source symbols, the remaining N-I source blocks
   consist of A_small source symbols.  Each source symbol is E bytes in
   length, except perhaps the last symbol which may be shorter.

   For each block the actual number of encoding symbols is determined,
   as explained in the following section.

   Then, FEC encoding and decoding can be done block per block,
   independently.  To that purpose, a parity check matrix is created,
   that forms a system of linear equations between the source and repair
   symbols of a given block, where the basic operator is XOR.

   This parity check matrix is logically divided into two parts: the
   left side (from column 0 to k-1) which describes the occurrence of
   each source symbol in the equation system; and the right side (from
   column k to n-1) which describes the occurrence of each repair symbol
   in the equation system.  An entry (a "1") in the matrix at position
   (i,j) (i.e. at row i and column j) means that the symbol with ESI i
   appears in equation j of the system.  The only difference between the
   LDPC-Staircase and LDPC-Triangle schemes is the construction of the
   right sub-matrix.

   When the parity symbols have been created, the sender will transmit
   source and parity symbols.  The way this transmission occurs can
   largely impact the erasure recovery capabilities of the LDPC-* FEC.
   In particular, sending parity symbols in sequence is suboptimal.
   Instead it is usually recommended the shuffle these symbols.  The
   interested reader will find more details in [7].

   The following sections detail how the B, E, and n parameters are
   determined (respectively in Section 5.2, Section 5.3 and
   Section 5.4), how encoding symbol groups are created (Section 5.5),



Roca, et al.            Expires November 8, 2007               [Page 12]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


   and finally specify the PRNG (Section 5.6).

5.2.  Determining the Maximum Source Block Length (B)

   The B parameter (maximum source block length in symbols) depends on
   several parameters: the code rate (rate), the Encoding Symbol ID
   field length of the FEC Payload ID (20 bits), as well as possible
   internal codec limitations.

   The B parameter cannot be larger than the following values, derived
   from the FEC Payload ID limitations, for a given code rate:

      max1_B = 2^^(20 - ceil(Log2(1/rate)))

   Some common max1_B values are:

   o  rate == 1 (no repair symbol): max1_B = 2^^20 = 1,048,576

   o  1/2 <= rate < 1: max1_B = 2^^19 = 524,288 symbols

   o  1/4 <= rate < 1/2: max1_B = 2^^18 = 262,144 symbols

   o  1/8 <= rate < 1/4: max1_B = 2^^17 = 131,072 symbols

   Additionally, a codec MAY impose other limitations on the maximum
   block size.  This is the case for instance when the codec uses
   internally 16 bit unsigned integers to store the Encoding Symbol ID,
   since it does not enable to store all the possible values of a 20 bit
   field.  In that case, if for instance 1/2 <= rate < 1, then the
   maximum source block length is 2^^15.  Other limitations may also
   apply, for instance because of a limited working memory size.  This
   decision MUST be clarified at implementation time, when the target
   use case is known.  This results in a max2_B limitation.

   Then, B is given by:

      B = min(max1_B, max2_B)

   Note that this calculation is only required at the coder, since the B
   parameter is communicated to the decoder through the FEC OTI.

5.3.  Determining the Encoding Symbol Length (E) and Number of Encoding
      Symbols per Group (G)

   The E parameter usually depends on the maximum transmission unit on
   the path (PMTU) from the source to the receivers.  In order to
   minimize the protocol header overhead (e.g. the LCT/UDP/IPv4 or IPv6
   headers in case of ALC), E is chosen as large as possible.  In that



Roca, et al.            Expires November 8, 2007               [Page 13]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


   case, E is chosen so that the size of a packet composed of a single
   symbol (G=1) remains below but close to the PMTU.

   However other considerations can exist.  For instance, the E
   parameter can be made a function of the object transfer length.
   Indeed, LDPC codes are known to offer better protection for large
   blocks.  In case of small objects, it can be advantageous to reduce
   the encoding symbol length (E) in order to artificially increase the
   number of symbols, and therefore the block size.

   In order to minimize the protocol header overhead, several symbols
   can be grouped in the same Encoding Symbol Group (i.e.  G > 1).
   Depending on how many symbols are grouped (G) and on the packet loss
   rate (G symbols are lost for each packet erasure), this strategy
   might or might not be appropriate.  A balance must therefore be
   found.

   The current specification does not mandate any value for either E or
   G. The current specification only provides an example of possible
   choices for E and G. Note that this choice is done by the sender.
   Then the E and G parameters are communicated to the receivers thanks
   to the FEC OTI.

   Example:

   First define the target packet payload size, pkt_sz (at most equal to
   the PMTU minus the size of the various protocol headers).  The pkt_sz
   must be chosen in such a way that the symbol size is an integer.
   This can require that pkt_sz be a multiple of 4, 8 or 16 (see the
   table below).  Then calculate the number of packets in the object:
   nb_pkts = ceil(L / pkt_sz).  Finally, thanks to nb_pkts, use the
   following table to find a possible G value.

     +------------------------+----+-------------+-------------------+
     |    Number of packets   |  G | Symbol size |         k         |
     +------------------------+----+-------------+-------------------+
     |     4000 <= nb_pkts    |  1 |    pkt_sz   |     4000 <= k     |
     |                        |    |             |                   |
     | 1000 <= nb_pkts < 4000 |  4 |  pkt_sz / 4 | 4000 <= k < 16000 |
     |                        |    |             |                   |
     |  500 <= nb_pkts < 1000 |  8 |  pkt_sz / 8 |  4000 <= k < 8000 |
     |                        |    |             |                   |
     |   1 <= nb_pkts < 500   | 16 | pkt_sz / 16 |   16 <= k < 8000  |
     +------------------------+----+-------------+-------------------+







Roca, et al.            Expires November 8, 2007               [Page 14]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


5.4.  Determining the Number of Encoding Symbols of a Block

   The following algorithm, also called "n-algorithm", explains how to
   determine the actual number of encoding symbols for a given block.

   AT A SENDER:

   Input:

      B: Maximum source block length, for any source block.  Section 5.2
      explains how to determine its value.

      k: Current source block length.  This parameter is given by the
      source blocking algorithm.

      rate: FEC code rate.  It is provided by the user, for instance
      when starting a FLUTE sending application.  It is expressed as a
      floating point value.  The rate value must be such that the
      resulting number of encoding symbols per block is at most equal to
      2^^20 (Section 4.1).

   Output:

      max_n: Maximum number of encoding symbols generated for any source
      block

      n: Number of encoding symbols generated for this source block

   Algorithm:

      max_n = floor(B / rate);

      if (max_n > 2^^20) then return an error ("invalid code rate");

      (NB: if B has been defined as explained in Section 5.2, this error
      should never happen)

      n = floor(k * max_n / B);

   AT A RECEIVER:

   Input:

      B: Extracted from the received FEC OTI

      max_n: Extracted from the received FEC OTI





Roca, et al.            Expires November 8, 2007               [Page 15]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


      k: Given by the source blocking algorithm

   Output:

      n: Number of encoding symbols generated for this source block

   Algorithm:

      n = floor(k * max_n / B);

5.5.  Identifying the Symbols of an Encoding Symbol Group

   When multiple encoding symbols are sent in the same packet, the FEC
   Payload ID information of the packet MUST refer to the first encoding
   symbol.  It MUST then be possible to identify each symbol from this
   single FEC Payload ID.  To that purpose, the symbols of an Encoding
   Symbol Group (i.e. packet):

   o  MUST all be either source symbols, or repair symbols.  Therefore
      only source packets and repair packets are permitted, not mixed
      ones.

   o  are identified by a function, sender(resp.
      receiver)_find_ESIs_of_group(), that takes as argument:

      *  for a sender, the index of the Encoding Symbol Group (i.e.
         packet) that the application wants to create,

      *  for a receiver, the ESI information contained in the FEC
         Payload ID.

      and returns a list of G Encoding Symbol IDs.  In case of a source
      packet, the G Encoding Symbol IDs are chosen consecutively, by
      incrementing the ESI.  In case of a repair packet, the G repair
      symbols are chosen randomly, as explained below.

   o  are stored in sequence in the packet, without any padding.  In
      other words, the last byte of the i-th symbol is immediately
      followed by the first byte of (i+1)-th symbol.

   The system must first be initialized by creating a random permutation
   of the n-k indexes.  This initialization function MUST be called
   immediately after creating the parity check matrix.  More precisely,
   since the PRNG seed is not re-initialized, no call to the PRNG
   function must have happened between the time the parity check matrix
   has been initialized and the time the following initialization
   function is called.  This is true both at a sender and at a receiver.




Roca, et al.            Expires November 8, 2007               [Page 16]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


   int *txseqToID;
   int *IDtoTxseq;

   /*
    * Initialization function.
    * Warning: use only when G > 1.
    */
   void
   initialize_tables ()
   {
       int i;
       int randInd;
       int backup;

       txseqToID = malloc((n-k) * sizeof(int));
       IDtoTxseq = malloc((n-k) * sizeof(int));
       /* initialize the two tables that map ID
        * (i.e. ESI-k) to/from TxSequence. */
       for (i = 0; i < n - k; i++) {
           IDtoTxseq[i] = i;
           txseqToID[i] = i;
       }
       /* now randomize everything */
       for (i = 0; i < n - k; i++) {
           randInd = rand(n - k);
           backup  = IDtoTxseq[i];
           IDtoTxseq[i] = IDtoTxseq[randInd];
           IDtoTxseq[randInd] = backup;
           txseqToID[IDtoTxseq[i]] =  i;
           txseqToID[IDtoTxseq[randInd]] = randInd;
       }
       return;
   }

   It is then possible, at the sender, to determine the sequence of G
   Encoding Symbol IDs that will be part of the group.















Roca, et al.            Expires November 8, 2007               [Page 17]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


   /*
    * Determine the sequence of ESIs for the packet under construction
    * at a sender.
    * Warning: use only when G > 1.
    * PktIdx (IN):  index of the packet, in
    *               {0..ceil(k/G)+ceil((n-k)/G)} range
    * ESIs[] (OUT): list of ESIs for the packet
    */
   void
   sender_find_ESIs_of_group (int      PktIdx,
                              ESI_t    ESIs[])
   {
       int i;

       if (PktIdx < nbSourcePkts) {
           /* this is a source packet */
           ESIs[0] = PktIdx * G;
           for (i = 1; i < G; i++) {
                   ESIs[i] = (ESIs[0] + i) % k;
           }
       } else {
           /* this is a repair packet */
           for (i = 0; i < G; i++) {
               ESIs[i] =
                   k +
                   txseqToID[(i + (PktIdx - nbSourcePkts) * G)
                             % (n - k)];
           }
       }
       return;
   }

   Similarly, upon receiving an Encoding Symbol Group (i.e. packet), a
   receiver can determine the sequence of G Encoding Symbol IDs from the
   first ESI, esi0, that is contained in the FEC Payload ID.
















Roca, et al.            Expires November 8, 2007               [Page 18]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


   /*
    * Determine the sequence of ESIs for the packet received.
    * Warning: use only when G > 1.
    * esi0 (IN):  : ESI contained in the FEC Payload ID
    * ESIs[] (OUT): list of ESIs for the packet
    */
   void
   receiver_find_ESIs_of_group (ESI_t    esi0,
                                ESI_t    ESIs[])
   {
       int i;

       if (esi0 < k) {
           /* this is a source packet */
           ESIs[0] = esi0;
           for (i = 1; i < G; i++) {
               ESIs[i] = (esi0 + i) % k;
           }
       } else {
           /* this is a repair packet */
           for (i = 0; i < G; i++) {
               ESIs[i] =
                   k +
                   txseqToID[(i + IDtoTxseq[esi0 - k])
                             % (n - k)];
           }
       }
   }

5.6.  Pseudo Random Number Generator

   The present FEC Encoding ID relies on a pseudo-random number
   generator (PRNG) that must be fully specified, in particular in order
   to enable the receivers and the senders to build the same parity
   check matrix.  The minimal standard generator [10] is used.  It
   defines a simple multiplicative congruential algorithm: Ij+1 = A * Ij
   (modulo M), with the following choices: A = 7^^5 = 16807 and M =
   2^^31 - 1 = 2147483647.  Several implementations of this PRNG are
   known and discussed in the literature.  All of them provide the same
   sequence of pseudo random numbers.  A validation criteria of such a
   PRNG is the following: if seed = 1, then the 10,000th value returned
   MUST be equal to 1043618065.

   The following implementation uses the Park and Miller algorithm with
   the optimization suggested by D. Carta in [11].






Roca, et al.            Expires November 8, 2007               [Page 19]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


   unsigned long           seed;


   /*
    * Initialize the PRNG with a seed between
    * 1 and 0x7FFFFFFE (i.e. 2^^31-2) inclusive.
    */
   void srand (unsigned long s)
   {
           if ((s > 0) && (s < 0x7FFFFFFF))
                   seed = s;
           else
                   exit(-1);
   }

   /*
    * Returns a random integer in [0; maxv-1]
    * Derived from rand31pmc, Robin Whittle,
    * September 20th, 2005.
    * http://www.firstpr.com.au/dsp/rand31/
    *      16807           multiplier constant (7^^5)
    *      0x7FFFFFFF      modulo constant (2^^31-1)
    * The inner PRNG produces a value between 1 and
    * 0x7FFFFFFE (2^^31-2) inclusive.
    * This value is then scaled between 0 and maxv-1
    * inclusive.
    */
   unsigned long
   rand (unsigned long maxv)
   {
           unsigned long   hi, lo;

           lo = 16807 * (seed & 0xFFFF);
           hi = 16807 * (seed >> 16);  /* binary shift to right */
           lo += (hi & 0x7FFF) < < 16; /* binary shift to left */
           lo += hi >> 15;
           if (lo > 0x7FFFFFFF)
                   lo -= 0x7FFFFFFF;
           seed = (long)lo;
           /* don't use modulo, least significant bits are less random
            * than most significant bits [Numerical Recipes in C] */
           return ((unsigned long)
                   ((double)seed * (double)maxv / (double)0x7FFFFFFF));
   }







Roca, et al.            Expires November 8, 2007               [Page 20]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


6.  Full Specification of the LDPC-Staircase Scheme

6.1.  General

   The LDPC-Staircase scheme is identified by the Fully-Specified FEC
   Encoding ID 3.

   The PRNG used by the LDPC-Staircase scheme must be initialized by a
   seed.  This PRNG seed is an optional instance-specific FEC OTI
   attribute (Section 4.2.3).  When this PRNG seed is not carried within
   the FEC OTI, it is assumed that encoder and decoders either use
   another way to communicate the seed value or use a fixed, predefined
   value.

6.2.  Parity Check Matrix Creation

   The LDPC-Staircase matrix can be divided into two parts: the left
   side of the matrix defines in which equations the source symbols are
   involved; the right side of the matrix defines in which equations the
   repair symbols are involved.

   The left side is generated with the following algorithm:

      /*
       * Derived from: "Software for Low Density Parity Check Codes"
       * Version of 2001-11-18, Radford M. Neal, Univ. of Toronto.
       * Copyright (c) 1995, 1996, 2000, 2001 by Radford M. Neal
       * http://www.cs.toronto.edu/~radford/ldpc.software.html
       */
      /* initialize a list of all possible choices in order to
       * guarantee a homogeneous "1" distribution */
      for (h = 3*k-1; h >= 0; h--) {
          u[h] = h % (n-k);
      }
      /* left limit within the list of possible choices, u[] */
      t = 0;

      for (j = 0; j < k; j++) { /* for each source symbol column */
          for (h = 0; h < 3; h++) { /* add 3 "1s" */
              /* check that valid available choices remain */
              for (i = t; i < 3*k && matrix_has_entry(u[i], j); i++);

              if (i < 3*k) {
                  /* choose one index within the list of possible
                   * choices */
                  do {
                      i = t + rand(3*k-t);
                  } while (matrix_has_entry(u[i], j));



Roca, et al.            Expires November 8, 2007               [Page 21]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


                  matrix_insert_entry(u[i], j);

                  /* replace with u[t] which has never been chosen */
                  u[i] = u[t];
                  t++;
              } else {
                  /* no choice left, choose one randomly */
                  do {
                      i = rand(n-k);
                  } while (matrix_has_entry(i, j));
                  matrix_insert_entry(i, j);
              }
          }
      }

      /* Add extra bits to avoid rows with less than two "1s".
       * This is needed when the code rate is smaller than 2/5. */
      for (i = 0; i < n-k; i++) { /* for each row */
          if (degree_of_row(i) == 0) {
              j = rand(k);
              e = matrix_insert_entry(i, j);
          }
          if (degree_of_row(i) == 1) {
              do {
                  j = rand(k);
              } while (matrix_has_entry(i, j));
              matrix_insert_entry(i, j);
          }
      }

   The right side (the staircase) is generated by the following
   algorithm:

      matrix_insert_entry(0, k);    /* first row */
      for (i = 1; i < n-k; i++) {   /* for the following rows */
          matrix_insert_entry(i, k+i);   /* identity */
          matrix_insert_entry(i, k+i-1); /* staircase */
      }

   Note that just after creating this parity check matrix, when encoding
   symbol groups are used (i.e.  G > 1), the function initializing the
   two random permutation tables (Section 5.5) MUST be called.  This is
   true both at a sender and at a receiver.

6.3.  Encoding

   Thanks to the staircase matrix, repair symbol creation is
   straightforward: each repair symbol is equal to the sum of all source



Roca, et al.            Expires November 8, 2007               [Page 22]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


   symbols in the associated equation, plus the previous repair symbol
   (except for the first repair symbol).  Therefore encoding MUST follow
   the natural repair symbol order: start with the first repair symbol,
   and generate repair symbol with ESI i before symbol ESI i+1.

6.4.  Decoding

   Decoding basically consists in solving a system of n-k linear
   equations whose variables are the n source and repair symbols.  Of
   course, the final goal is to recover the value of the k source
   symbols only.

   To that purpose, many techniques are possible.  One of them is the
   following trivial algorithm [12]: given a set of linear equations, if
   one of them has only one remaining unknown variable, then the value
   of this variable is that of the constant term.  So, replace this
   variable by its value in all the remaining linear equations and
   reiterate.  The value of several variables can therefore be found
   recursively.  Applied to LDPC FEC codes working over an erasure
   channel, the parity check matrix defines a set of linear equations
   whose variables are the source symbols and repair symbols.  Receiving
   or decoding a symbol is equivalent to having the value of a variable.
   Appendix A sketches a possible implementation of this algorithm.

   A Gaussian elimination (or any optimized derivative) is another
   possible decoding technique.  Hybrid solutions that start by using
   the trivial algorithm above and finish with a Gaussian elimination
   are also possible.

   Because interoperability does not depend on the decoding algorithm
   used, the current document does not recommend any particular
   technique.  This choice is left to the codec developer.

   However choosing a decoding technique will have great practical
   impacts.  It will impact the erasure capabilities: a Gaussian
   elimination enables to solve the system with a smaller number of
   known symbols compared to the trivial technique.  It will also impact
   the CPU load: a Gaussian elimination requires more processing than
   the above trivial algorithm.  Depending on the target use case, the
   codec developer will favor one feature or the other.











Roca, et al.            Expires November 8, 2007               [Page 23]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


7.   Full Specification of the LDPC-Triangle Scheme

7.1.  General

   LDPC-Triangle is identified by the Fully-Specified FEC Encoding ID 4.

   The PRNG used by the LDPC-Triangle scheme must be initialized by a
   seed.  This PRNG seed is an optional instance-specific FEC OTI
   attribute (Section 4.2.3).  When this PRNG seed is not carried within
   the FEC OTI, it is assumed that encoder and decoders either use
   another way to communicate the seed value or use a fixed, predefined
   value.

7.2.  Parity Check Matrix Creation

   The LDPC-Triangle matrix can be divided into two parts: the left side
   of the matrix defines in which equations the source symbols are
   involved; the right side of the matrix defines in which equations the
   repair symbols are involved.

   The left side is generated with the same algorithm as that of LDPC-
   Staircase (Section 6.2).

   The right side (the triangle) is generated with the following
   algorithm:

      matrix_insert_entry(0, k);    /* first row */
      for (i = 1; i < n-k; i++) {   /* for the following rows */
          matrix_insert_entry(i, k+i);   /* identity */
          matrix_insert_entry(i, k+i-1); /* staircase */
          /* now fill the triangle */
          j = i-1;
          for (l = 0; l < j; l++) { /* limit the # of "1s" added */
              j = rand(j);
              matrix_insert_entry(i, k+j);
          }
      }

   Note that just after creating this parity check matrix, when encoding
   symbol groups are used (i.e.  G > 1), the function initializing the
   two random permutation tables (Section 5.5) MUST be called.  This is
   true both at a sender and at a receiver.

7.3.  Encoding

   Here also repair symbol creation is straightforward: each repair
   symbol is equal to the sum of all source symbols in the associated
   equation, plus the repair symbols in the triangle.  Therefore



Roca, et al.            Expires November 8, 2007               [Page 24]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


   encoding MUST follow the natural repair symbol order: start with the
   first repair symbol, and generate repair symbol with ESI i before
   symbol ESI i+1.

7.4.  Decoding

   Decoding basically consists in solving a system of n-k linear
   equations, whose variables are the n source and repair symbols.  Of
   course, the final goal is to recover the value of the k source
   symbols only.  To that purpose, many techniques are possible, as
   explained in Section 6.4.

   Because interoperability does not depend on the decoding algorithm
   used, the current document does not recommend any particular
   technique.  This choice is left to the codec implementer.




































Roca, et al.            Expires November 8, 2007               [Page 25]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


8.  Security Considerations

   Data delivery can be subject to denial-of-service attacks by
   attackers which send corrupted packets that are accepted as
   legitimate by receivers.  This is particularly a concern for
   multicast delivery because a corrupted packet may be injected into
   the session close to the root of the multicast tree, in which case
   the corrupted packet will arrive at many receivers.  This is
   particularly a concern for the FEC building block because the use of
   even one corrupted packet containing encoding data may result in the
   decoding of an object that is completely corrupted and unusable.  It
   is thus RECOMMENDED that source authentication and integrity checking
   are applied to decoded objects before delivering objects to an
   application.  For example, a SHA-1 hash [4] of an object may be
   appended before transmission, and the SHA-1 hash is computed and
   checked after the object is decoded but before it is delivered to an
   application.  Source authentication SHOULD be provided, for example
   by including a digital signature verifiable by the receiver computed
   on top of the hash value.  It is also RECOMMENDED that a packet
   authentication protocol such as TESLA [5] be used to detect and
   discard corrupted packets upon arrival.  Furthermore, it is
   RECOMMENDED that Reverse Path Forwarding checks be enabled in all
   network routers and switches along the path from the sender to
   receivers to limit the possibility of a bad agent successfully
   injecting a corrupted packet into the multicast tree data path.

   Another security concern is that some FEC information may be obtained
   by receivers out-of-band in a session description, and if the session
   description is forged or corrupted then the receivers will not use
   the correct protocol for decoding content from received packets.  To
   avoid these problems, it is RECOMMENDED that measures be taken to
   prevent receivers from accepting incorrect session descriptions,
   e.g., by using source authentication to ensure that receivers only
   accept legitimate session descriptions from authorized senders.

















Roca, et al.            Expires November 8, 2007               [Page 26]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


9.  IANA Considerations

   Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA
   registration.  For general guidelines on IANA considerations as they
   apply to this document, see [2].

   This document assigns the Fully-Specified FEC Encoding ID 3 under the
   "ietf:rmt:fec:encoding" name-space to "LDPC Staircase Codes".

   This document assigns the Fully-Specified FEC Encoding ID 4 under the
   "ietf:rmt:fec:encoding" name-space to "LDPC Triangle Codes".








































Roca, et al.            Expires November 8, 2007               [Page 27]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


10.  Acknowledgments

   Section 5.4 is derived from a previous Internet-Draft, and we would
   like to thank S. Peltotalo and J. Peltotalo for their contribution.
   We would also like to thank Pascal Moniot, Laurent Fazio, Aurelien
   Francillon and Shao Wenjian for their comments.













































Roca, et al.            Expires November 8, 2007               [Page 28]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


11.  References

11.1.  Normative References

   [1]   Bradner, S., "Key words for use in RFCs to Indicate Requirement
         Levels", RFC 2119, BCP 14, March 1997.

   [2]   Watson, M., Luby, M., and L. Vicisano, "Forward Error
         Correction (FEC) Building Block",
          draft-ietf-rmt-fec-bb-revised-07.txt (work in progress),
         April 2007.

   [3]   Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M.,
         and J. Crowcroft, "The Use of Forward Error Correction (FEC) in
         Reliable Multicast", RFC 3453, December 2002.

   [4]   "HMAC: Keyed-Hashing for Message Authentication", RFC 2104,
         February 1997.

   [5]   "Timed Efficient Stream Loss-Tolerant Authentication (TESLA):
         Multicast Source Authentication Transform Introduction",
         RFC 4082, June 2005.

11.2.  Informative References

   [6]   Roca, V. and C. Neumann, "Design, Evaluation and Comparison of
         Four Large Block FEC Codecs: LDPC, LDGM, LDGM-Staircase and
         LDGM-Triangle, Plus a Reed-Solomon Small Block FEC Codec",
          INRIA Research Report RR-5225, June 2004.

   [7]   Neumann, C., Roca, V., Francillon, A., and D. Furodet, "Impacts
         of Packet Scheduling and Packet Loss Distribution on FEC
         Performances: Observations and Recommendations",  ACM CoNEXT'05
         Conference, Toulouse, France (an extended version is available
         as INRIA Research Report RR-5578), October 2005.

   [8]   Roca, V., Neumann, C., and J. Laboure, "LDPC-Staircase/
         LDPC-Triangle Codec Reference Implementation",  INRIA Rhone-
         Alpes and STMicroelectronics,
         http://planete-bcast.inrialpes.fr/.

   [9]   MacKay, D., "Information Theory, Inference and Learning
         Algorithms", Cambridge University Press, ISBN: 0521642981,
         2003.

   [10]  Park, S. and K. Miller, "Random Number Generators: Good Ones
         are Hard to Find",  Communications of the ACM, Vol. 31, No. 10,
         pp.1192-1201, 1988.



Roca, et al.            Expires November 8, 2007               [Page 29]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


   [11]  Carta, D., "Two Fast Implementations of the Minimal Standard
         Random Number Generator",  Communications of the ACM, Vol. 33,
         No. 1, pp.87-88, January 1990.

   [12]  Zyablov, V. and M. Pinsker, "Decoding Complexity of Low-Density
         Codes for Transmission in a Channel with Erasures",  Translated
         from Problemy Peredachi Informatsii, Vol.10, No. 1, pp.15-28,
         January-March 1974.

   [13]  Luby, M., Watson, M., and L. Vicisano, "Asynchronous Layered
         Coding (ALC) Protocol Instantiation",
          draft-ietf-rmt-pi-alc-revised-04.txt (work in progress),
         February 2007.

   [14]  Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V. Roca,
         "FLUTE - File Delivery over Unidirectional Transport",
          draft-ietf-rmt-flute-revised-03.txt (work in progress),
         January 2007.

   [15]  Adamson, B., Bormann, C., Handley, M., and J. Macker,
         "Negative-acknowledgment (NACK)-Oriented Reliable Multicast
         (NORM) Protocol",  draft-ietf-rmt-pi-norm-revised-04.txt (work
         in progress), March 2007.




























Roca, et al.            Expires November 8, 2007               [Page 30]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


Appendix A.  Trivial Decoding Algorithm (Informative Only)

   A trivial decoding algorithm is sketched below (please see [8] for
   the details omitted here):

   Initialization: allocate a table partial_sum[n-k] of buffers, each
                   buffer being of size the symbol size. There's one
                   entry per equation since the buffers are meant to
                   store the partial sum of each equation; Reset all
                   the buffers to zero;

   /*
    * For each newly received or decoded symbol, try to make progress
    * in the decoding of the associated source block.
    * NB: in case of a symbol group (G>1), this function is called for
    * each symbol of the received packet.
    * NB: a callback function indicates to the caller that new symbol(s)
    *     has(have) been decoded.
    * new_esi  (IN):  ESI of the new symbol received or decoded
    * new_symb (IN):  Buffer of the new symbol received or decoded
    */
   void
   decoding_step(ESI_t     new_esi,
                 symbol_t  *new_symb)
   {
       If (new_symb is an already decoded or received symbol) {
           Return;        /* don't waste time with this symbol */
       }

       If (new_symb is the last missing source symbol) {
           Remember that decoding is finished;
           Return;        /* work is over now... */
       }

       Create an empty list of equations having symbols decoded
       during this decoding step;

       /*
        * First add this new symbol to the partial sum of all the
        * equations where the symbol appears.
        */
       For (each equation eq in which new_symb is a variable and
            having more than one unknown variable) {

           Add new_symb to partial_sum[eq];

           Remove entry(eq, new_esi) from the H matrix;




Roca, et al.            Expires November 8, 2007               [Page 31]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


           If (the new degree of equation eq == 1) {
               /* a new symbol can be decoded, remember the
                * equation */
               Append eq to the list of equations having symbols
               decoded during this decoding step;
           }
       }

       /*
        * Then finish with recursive calls to decoding_step() for each
        * newly decoded symbol.
        */
       For (each equation eq in the list of equations having symbols
            decoded during this decoding step) {

           /*
            * Because of the recursion below, we need to check that
            * decoding is not finished, and that the equation is
            * __still__ of degree 1
            */
           If (decoding is finished) {
               break;        /* exit from the loop */
           }

           If ((degree of equation eq == 1) {
               Let dec_esi be the ESI of the newly decoded symbol in
               equation eq;

               Remove entry(eq, dec_esi);

               Allocate a buffer, dec_symb, for this symbol and
               copy partial_sum[eq] to dec_symb;

               Inform the caller that a new symbol has been
               decoded via a callback function;

               /* finally, call this function recursively */
               decoding_step(dec_esi, dec_symb);
           }
       }

       Free the list of equations having symbols decoded;
       Return;
   }







Roca, et al.            Expires November 8, 2007               [Page 32]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


Authors' Addresses

   Vincent Roca
   INRIA
   655, av. de l'Europe
   Inovallee; Montbonnot
   ST ISMIER cedex  38334
   France

   Email: vincent.roca@inrialpes.fr
   URI:   http://planete.inrialpes.fr/~roca/


   Christoph Neumann
   Thomson Research
   46, Quai A. Le Gallo
   Boulogne Cedex  92648
   France

   Email: christoph.neumann@thomson.net
   URI:   http://planete.inrialpes.fr/~chneuman/


   David Furodet
   STMicroelectronics
   12, Rue Jules Horowitz
   BP217
   Grenoble Cedex  38019
   France

   Email: david.furodet@st.com
   URI:   http://www.st.com/



















Roca, et al.            Expires November 8, 2007               [Page 33]

Internet-Draft       LDPC Staircase and Triangle FEC            May 2007


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Acknowledgment

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).





Roca, et al.            Expires November 8, 2007               [Page 34]

