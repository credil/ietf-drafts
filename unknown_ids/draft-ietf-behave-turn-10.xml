<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc compact='yes'?>
<?rfc subcompact='no'?>
<?rfc symrefs="yes"?>
<rfc category="std" docName="draft-ietf-behave-turn-10" ipr="full3978">
  <front>
    <title abbrev="TURN">Traversal Using Relays around NAT (TURN): Relay
    Extensions to Session Traversal Utilities for NAT (STUN)</title>

    <author fullname="Jonathan Rosenberg" initials="J." surname="Rosenberg">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street></street>

          <city>Edison</city>

          <region>NJ</region>

          <country>USA</country>
        </postal>

        <email>jdrosen@cisco.com</email>

        <uri>http://www.jdrosen.net</uri>
      </address>
    </author>

    <author fullname="Rohan Mahy" initials="R." surname="Mahy">
      <organization abbrev="Plantronics">Plantronics, Inc.</organization>

      <address>
        <email>rohan@ekabal.com</email>
      </address>
    </author>

    <author fullname="Philip Matthews" initials="P." surname="Matthews">
      <organization>(Unaffiliated)</organization>

      <address>
        <facsimile></facsimile>

        <email>philip_matthews@magma.ca</email>

        <uri></uri>
      </address>
    </author>

    <date year="2008" />

    <area>Transport</area>

    <workgroup>BEHAVE WG</workgroup>

    <keyword>NAT</keyword>

    <keyword>TURN</keyword>

    <keyword>STUN</keyword>

    <keyword>ICE</keyword>

    <abstract>
      <t>If a host is located behind a NAT, then in certain situations it can
      be impossible for that host to communicate directly with other hosts
      (peers) located behind other NATs. In these situations, it is necessary
      for the host to use the services of an intermediate node that acts as a
      communication relay. This specification defines a protocol, called TURN
      (Traversal Using Relays around NAT), that allows the host to control the
      operation of the relay and to exchange packets with its peers using the
      relay.</t>

      <t>The TURN protocol can be used in isolation, but is more properly used
      as part of the ICE (Interactive Connectivity Establishment) approach to
      NAT traversal.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>A host behind a NAT may wish to exchange packets with other hosts,
      some of which may also be behind NATs. To do this, the hosts involved
      can use the ICE (Interactive Connectivity Exchange <xref
      target="I-D.ietf-mmusic-ice"></xref>) protocol to discover a working
      communication path. In many cases, ICE will find a direct communication
      path between two hosts. However, if the NATs along the path have a
      mapping behavior <xref target="RFC4787"></xref> of address or address
      and port dependent mapping, then it can be extremely difficult or
      impossible to find a direct path.</t>

      <t>In these cases, it is necessary to use the services of an
      intermediate host that acts as a relay for the packets. This relay
      typically sits in the public Internet and relays packets between two
      hosts that both sit behind NATs.</t>

      <t>This specification defines a protocol, called TURN, that allows a
      host behind a NAT (called the TURN client) to request that another host
      (called the TURN server) act as a relay. The client can arrange for the
      server to relay packets to certain other hosts (called peers) and can
      control aspects of how the relaying is done.</t>

      <t>Though the use of a relay to enable communication between two hosts
      behind NATs is highly likely to work, it comes at a high cost to the
      provider of the relay, since the relay typically needs a high bandwidth
      connection to the Internet . As a consequence, it is best to use a relay
      only when a direct communication path cannot be found. When the client
      and a peer use the ICE protocol to determine a communication path, ICE
      will search for a direct path first and only use the relay (i.e. TURN
      server) when a direct path cannot be found.</t>

      <t>TURN was originally invented to support multimedia sessions signaled
      using SIP. Since SIP supports forking, TURN supports multiple peers per
      client; a feature not supported by other approaches (e.g., SOCKS <xref
      target="RFC1928"></xref>). However, care has been taken to make sure
      that TURN is suitable for other types of applications.</t>

      <t>TURN is an extension to the STUN (Session Traversal Utilities for NAT
      <xref target="I-D.ietf-behave-rfc3489bis"></xref>) protocol. Most,
      though not all, TURN messages are STUN-formatted messages. A reader of
      this document should be familiar with STUN.</t>
    </section>

    <section title="Overview of Operation">
      <t>This section gives an overview of the operation of TURN. It is
      non-normative.</t>

      <t>In a typical configuration, a TURN client is connected to a <xref
      target="RFC1918">private network</xref> and through one or more NATs to
      the public Internet. On the public Internet is a TURN server. Elsewhere
      in the Internet are one or more peers that the TURN client wishes to
      communicate with. These peers may or may not be behind one or more NATs.
      The client uses the server as a relay to send packets to these peers and
      to receive packets from these peers.</t>

      <figure anchor="fig-turn-model">
        <artwork><![CDATA[
                                                          +---------+
                                                          |         |
                                                          |         |
                          TURN                          / |  Peer A |
    Client's              Server                      //  |         |
    Host Transport        Transport                  /    |         |
    Address               Address              +-+ //     +---------+
   10.1.1.2:17240       192.0.2.15:3478        |N|/  192.168.100.2:16400
            |               |                  |A|
            |   +-+         |                 /|T|
            |   | |         |                / +-+
            |   | |         |               /       192.0.2.210:18200
 +---------+|   | |         |+---------+   /              +---------+
 |         ||   |N|         ||         | //               |         |
 | TURN    |v   | |         v| TURN    |/                 |         |
 | Client  |----|A|----------| Server  |------------------|  Peer B |
 |         |    | |^         |         |^                ^|         |
 |         |    |T||         |         ||                ||         |
 +---------+    | ||         +---------+|                |+---------+
                | ||                    |                |
                | ||                    |                |
                +-+|                    |                |
                   |                    |                |
                   |                    |                |
             Client's                   |            Peer B
             Server-Reflexive    Relayed             Transport
             Transport Address   Transport Address   Address
             192.0.2.1:7000      192.0.2.15:9000     192.0.2.210:18200
]]></artwork>
      </figure>

      <t></t>

      <t><xref target="fig-turn-model"></xref> shows a typical deployment. In
      this figure, the TURN client and the TURN server are separated by a NAT,
      with the client on the private side and the server on the public side of
      the NAT. This NAT is assumed to be a &ldquo;bad&rdquo; NAT; for example,
      it might have a mapping property of address-and-port-dependent mapping
      (see <xref target="RFC4787"></xref> for a description of what this
      means).</t>

      <t>The client talks to the server from a (IP address, port) combination
      called the client's HOST TRANSPORT ADDRESS. (The combination of an IP
      address and port is called a TRANSPORT ADDRESS).</t>

      <t>The client sends TURN messages from its host transport address to a
      transport address on the TURN server which is known as the TURN SERVER
      TRANSPORT ADDRESS. The client learns the server&rsquo;s transport
      address through some unspecified means (e.g., configuration), and this
      address is typically used by many clients simultaneously.</t>

      <t>Since the client is behind a NAT, the server sees packets from the
      client as coming from a transport address on the NAT itself. This
      address is known as the client&rsquo;s SERVER-REFLEXIVE transport
      address; packets sent by the server to the client&rsquo;s
      server-reflexive transport address will be forwarded by the NAT to the
      client&rsquo;s host transport address.</t>

      <t>The client uses TURN commands to create and manipulate an ALLOCATION
      on the server. An allocation is a data structure on the server, an
      important component of which is a RELAYED TRANSPORT ADDRESS. The relayed
      transport address for the allocation is a transport address on the
      server which is used to send and receive packets to the peers.</t>

      <t>Once an allocation is created, the client can send application data
      to the server along with an indication of which peer the data is to be
      sent to, and the server will relay this data to the appropriate peer.
      The client sends the application data to the server inside a TURN
      message; at the server, the data is extracted from the TURN message and
      sent to the peer in a UDP datagram. In the reverse direction, a peer can
      send application data in a UDP datagram to the relayed transport address
      for the allocation; the server will then encapsulate this data inside a
      TURN message and send it to the client along with an indication of which
      peer sent the data. Since the TURN message always contains an indication
      of which peer the client is communicating with, the client can use a
      single allocation to communicate with multiple peers.</t>

      <t>Each allocation on the server belongs to a single client and has
      exactly one relayed transport address which is used only by that
      allocation. Thus when a packet arrives at a relayed transport address on
      the server, the server knows which client the data is intended for.
      However, the client may have multiple allocations on a server at the
      same time.</t>

      <section anchor="sec-transports" title="Transports">
        <t>TURN as defined in this specification always uses UDP between the
        server and the peer. However, this specification allows the use of any
        one of UDP, TCP, or TLS over TCP to carry the TURN messages between
        the client and the server.</t>

        <texttable>
          <ttcol align="center">TURN client to TURN server</ttcol>

          <ttcol align="center">TURN server to peer</ttcol>

          <c>UDP</c>

          <c>UDP</c>

          <c>TCP</c>

          <c>UDP</c>

          <c>TLS over TCP</c>

          <c>UDP</c>
        </texttable>

        <t>If TCP or TLS over TCP is used between the client and the server,
        then the server will convert between these transports and UDP
        transport when relaying data to/from the peer.</t>

        <t>TURN supports TCP transport between the client and the server
        because some firewalls are configured to block UDP entirely. These
        firewalls block UDP but not TCP in part because TCP has properties
        that make the intention of the nodes being protected by the firewall
        more obvious to the firewall. For example, TCP has a three-way
        handshake that makes in clearer that the protected node really wishes
        to have that particular connection established, while for UDP the best
        the firewall can do is guess which flows are desired by using
        filtering rules. Also, TCP has explicit connection teardown, while for
        UDP the firewall has to use timers to guess when the flow is
        finished.</t>

        <t>TURN supports TLS over TCP transport between the client and the
        server because TLS provides additional security properties not
        provided by TURN's default digest authentication; properties which
        some clients may wish to take advantage of. In particular, TLS
        provides a way for the client to ascertain that it is talking to the
        server that it intended to, and also provides for confidentiality of
        TURN control messages. TURN does not require TLS because the overhead
        of using TLS is higher than that of digest authentication; for
        example, using TLS likely means that most application data will be
        doubly encrypted (once by TLS and once to ensure it is still encrypted
        in the UDP datagram).</t>

        <t>There is a planned extension to TURN to add support for TCP between
        the server and the peers <xref
        target="I-D.ietf-behave-turn-tcp"></xref>. For this reason,
        allocations that use UDP between the server and the peers are known as
        UDP allocations, while allocations that use TCP between the server and
        the peers are known as TCP allocations. This specification describes
        only UDP allocations.</t>

        <t>TURN as defined in this specification only supports IPv4. All IP
        addresses in this specification must be IPv4 addresses. However, there
        is a planned extension to TURN to add support for IPv6 and for
        relaying between IPv4 and IPv6 <xref
        target="I-D.ietf-behave-turn-ipv6"></xref>.</t>

        <t>In some applications for TURN, the client may send and received
        packets other than TURN packets on the host transport address it uses
        to communicate with the server. This can happen, for example, when
        using TURN with ICE. In these cases, the client can distinguish TURN
        packets from other packets by examining the source address of the
        arriving packet: those arriving from the TURN server will be TURN
        packets.</t>
      </section>

      <section title="Allocations">
        <t>To create an allocation on the server, the client uses an Allocate
        transaction. The client sends a Allocate request to the server, and
        the server replies with an Allocate success response containing the
        allocated relayed transport address. The client can include attributes
        in the Allocate request that describe the type of allocation it
        desires (e.g., the lifetime of the allocation). Since relaying data
        may require lots of bandwidth, the server typically requires that the
        client authenticate itself using STUN&rsquo;s long-term credential
        mechanism, to show that it is authorized to use the server.</t>

        <t>Once a relayed transport address is allocated, a client must keep
        the allocation alive. To do this, the client periodically sends a
        Refresh request to the server. TURN deliberately uses a different
        method (Refresh rather than Allocate) for refreshes to ensure that the
        client is informed if the allocation vanishes for some reason.</t>

        <t>The frequency of the Refresh transaction is determined by the
        lifetime of the allocation. The client can request a lifetime in the
        Allocate request and may modify its request in a Refresh request, and
        the server always indicates the actual lifetime in the response. The
        client must issue a new Refresh transaction within 'lifetime' seconds
        of the previous Allocate or Refresh transaction. Once a client no
        longer wishes to use an Allocation, it should delete the allocation
        using a Refresh request with a requested lifetime of 0.</t>

        <t>Both the server and client keep track of a value known as the
        5-TUPLE. At the client, the 5-tuple consists of the client's host
        transport address, the server transport address, and the transport
        protocol used by the client to communicate with the server. At the
        server, the 5-tuple value is the same except that the client's host
        transport address is replaced by the client's server-reflexive
        address, since that is the client's address as seen by the server.</t>

        <t>Both the client and the server remember the 5-tuple used in the
        Allocate request. Subsequent messages between the client and the
        server uses the same 5-tuple. In this way, the client and server know
        which allocation is being referred to. If the client wishes to
        allocate a second relayed transport address, it must create a second
        allocation using a different 5-tuple (e.g., by using a different
        client host address or port).</t>

        <t><list>
            <t>NOTE: While the terminology used in this document refers to
            5-tuples, the TURN server can store whatever identifier it likes
            that yields identical results. Specifically, an implementation may
            use a file-descriptor in place of a 5-tuple to represent a TCP
            connection</t>
          </list></t>

        <figure anchor="fig-allocate">
          <artwork><![CDATA[TURN                                 TURN           Peer          Peer
client                               server          A             B
  |-- Allocate request --------------->|             |             |
  |                                    |             |             |
  |<--------------- Allocate failure --|             |             |
  |                 (401 Unauthorized) |             |             |
  |                                    |             |             |
  |-- Allocate request --------------->|             |             |
  |                                    |             |             |
  |<---------- Allocate success resp --|             |             |
  |            (192.0.2.15:9000)       |             |             |
  //                                   //            //            //
  |                                    |             |             |
  |-- Refresh request ---------------->|             |             |
  |                                    |             |             |
  |<----------- Refresh success resp --|             |             |
  |                                    |             |             |
]]></artwork>

          <postamble></postamble>
        </figure>

        <t>In <xref target="fig-allocate"></xref>, the client sends an
        Allocate request to the server without credentials. Since the server
        requires that all requests be authenticated using STUN's long-term
        credential mechanism, the server rejects the request with a 401
        (Unauthorized) error code. The client then tries again, this time
        including credentials (not shown). This time, the server accepts the
        Allocate request and returns an Allocate success response containing
        (amongst other things) the relayed transport address assigned to the
        allocation. Sometime later the client decides to refresh the
        allocation and thus sends a Refresh request to the server. The refresh
        is accepted and the server replies with a Refresh success
        response.</t>
      </section>

      <section anchor="sec-permission-overview" title="Permissions">
        <t>To ease concerns amongst enterprise IT administrators that TURN
        could be used to bypass corporate firewall security, TURN includes the
        notion of permissions. TURN permissions mimic the address-restricted
        filtering mechanism of NATs that comply with <xref
        target="RFC4787"></xref>.</t>

        <t>An allocation can have zero or more permissions. Each permission
        consists of an IP address and a lifetime. When the server receives a
        UDP datagram on the allocation's relayed transport address, it first
        checks the list of permissions. If the source IP address of the
        datagram matches a permission, the application data is relayed to the
        client, otherwise the UDP datagram is silently discarded.</t>

        <t>A permission expires after 5 minutes if it is not refreshed. There
        is no way to explicitly delete a permission.</t>

        <t>The client can install or refresh a permission using either a
        CreatePermission request or a ChannelBind request. For security
        reasons, permissions can only be installed or refreshed by
        transactions that can be authenticated; thus Send indications and
        ChannelData messages (which are used to send data to peers) do not
        install or refresh any permissions.</t>

        <t>Note that permissions are within the context of an allocation, so
        adding or expiring a permission in one allocation does not affect
        other allocations.</t>
      </section>

      <section title="Send Mechanism">
        <t>There are two mechanisms for the client and peers to exchange
        application data using the TURN server. The first mechanism uses the
        Send and Data methods, the second way uses channels. Common to both
        ways is the ability of the client to communicate with multiple peers
        using a single allocated relayed transport address; thus both ways
        include a means for the client to indicate to the server which peer to
        forward the data to, and for the server to indicate which peer sent
        the data.</t>

        <t>The Send mechanism uses Send and Data indications. Send indications
        are used to send application data from the client to the server, while
        Data indications are used to send application data from the server to
        the client.</t>

        <t>When using the Send mechanism, the client sends a Send indication
        to the TURN server containing (a) an XOR-PEER-ADDRESS attribute
        specify the transport address of the peer and (b) a DATA attribute
        holding the application data. When the TURN server receives the Send
        indication, it extracts the application data from the DATA attribute
        and sends it in a UDP datagram to the peer, using the allocated relay
        address as the source address. Note that there is no need to specify
        the relayed transport address, since it is implied by the 5-tuple used
        for the Send indication.</t>

        <t>In the reverse direction, UDP datagrams arriving at the relayed
        transport address on the TURN server are converted into Data
        indications and sent to the client, with the transport address of the
        peer included in an XOR-PEER-ADDRESS attribute and the data itself in
        a DATA attribute. Since the relayed transport address uniquely
        identified the allocation, the server knows which client to relay the
        data to.</t>

        <figure anchor="fig-send-data">
          <artwork><![CDATA[TURN                                 TURN           Peer          Peer
client                               server          A             B
  |                                    |             |             |
  |-- CreatePermission req (Peer A) -->|             |             |
  |<-- CreatePermission success resp --|             |             |
  |                                    |             |             |
  |--- Send ind (Peer A)-------------->|             |             |
  |                                    |=== data ===>|             |
  |                                    |             |             |
  |                                    |<== data ====|             |
  |<-------------- Data ind (Peer A) --|             |             |
  |                                    |             |             |
  |                                    |             |             |
  |--- Send ind (Peer B)-------------->|             |             |
  |                                    |=== data =================>|
  |                                    |             |             |
  |                                    |<== data ==================|
  |                            dropped |             |             |
  |                                    |             |             |
]]></artwork>

          <postamble></postamble>
        </figure>

        <t>In <xref target="fig-send-data"></xref>, the client has already
        created an allocation and now wishes to send data to its peers. The
        client first creates a permission by sending the server a
        CreatePermission request specifying peer A's IP address in the
        XOR-PEER-ADDRESS attribute; this allows peer A to send data to the
        client. The client then sends data to Peer A using a Send indication;
        at the server, the application data is extracted and forwarded in a
        UDP datagram to Peer A, using the relayed transport address as the
        source transport address. When a UDP datagram from Peer A is received
        at the relayed transport address, the contents are placed into a Data
        indication and forwarded to the client. Finally, the client then uses
        a Send indication to send a second data packet to Peer B; here the
        client has not installed a permission for peer B, so the UDP datagram
        from peer B is silently discarded by the server.</t>
      </section>

      <section title="Channels">
        <t>For some applications (e.g. Voice over IP), the 36 bytes of
        overhead that a Send indication or Data indication adds to the
        application data can substantially increase the bandwidth required
        between the client and the server. To remedy this, TURN offers a
        second way for the client and server to associate data with a specific
        peer.</t>

        <t>This second way uses an alternate packet format known as the
        ChannelData message. The ChannelData message does not use the STUN
        header used by other TURN messages, but instead has a 4-byte header
        that includes a number known as a channel number. Each channel number
        in use is bound to a specific peer and thus serves as a shorthand for
        the peer's host transport address.</t>

        <t>To bind a channel to a peer, the client sends a ChannelBind request
        to the server, and includes an unbound channel number and the
        transport address of the peer. Once the channel is bound, the client
        can use a ChannelData message to send the server data destined for the
        peer. Similarly, the server can relay data from that peer towards the
        client using a ChannelData message.</t>

        <t>Channel bindings last for 10 minutes unless refreshed. Channel
        bindings are refreshed by sending another ChannelBind request
        rebinding the channel to the peer. Like permissions (but unlike
        allocations), there is no way to explicitly delete a channel binding;
        the client must simply wait for it to time out.</t>

        <figure anchor="fig-channels">
          <artwork><![CDATA[TURN                                 TURN           Peer          Peer
client                               server          A             B
  |                                    |             |             |
  |-- ChannelBind req ---------------->|             |             |
  | (Peer A to 0x4001)                 |             |             |
  |                                    |             |             |
  |<---------- ChannelBind succ resp --|             |             |
  |                                    |             |             |
  |-- [0x4001] data ------------------>|             |             |
  |                                    |=== data ===>|             |
  |                                    |             |             |
  |                                    |<== data ====|             |
  |<------------------ [0x4001] data --|             |             |
  |                                    |             |             |
  |--- Send ind (Peer A)-------------->|             |             |
  |                                    |=== data ===>|             |
  |                                    |             |             |
  |                                    |<== data ====|             |
  |<------------------ [0x4001] data --|             |             |
  |                                    |             |             |
  |-- Send ind (Peer B)--------------->|             |             |
  |                                    |=== data =================>|
  |                                    |             |             |
]]></artwork>
        </figure>

        <t><xref target="fig-channels"></xref> shows the channel mechanism in
        use. The client has already created an allocation and now wishes to
        bind a channel to peer A. To do this, the client sends a ChannelBind
        request to the server, specifying the transport address of Peer A and
        a channel number (0x4001). After that, the client can send application
        data encapsulated inside ChannelData messages to Peer A: this is shown
        as "[0x4001] data" where 0x4001 is the channel number. When the
        ChannelData message arrives at the server, the server transfers the
        data to a UDP datagram and sends it to the peer A, as indicated by the
        channel number. When peer A sends a UDP datagram to the relayed
        transport address, the data is placed inside a ChannelData message and
        sent to the client.</t>

        <t>Once a channel has been bound, the client is free to intermix
        ChannelData messages and Send indications. In the figure, the client
        later decides to use a Send indication rather than a ChannelData
        message to send additional data to peer A. The client might decide to
        do this, for example, so it can use the DONT-FRAGMENT attribute (see
        the next section). However, once a channel is bound, the server will
        always use a ChannelData message, as shown in the call flow.</t>

        <t>Note that ChannelData messages can only be used for peers to which
        the client has bound a channel. In the example above, Peer A has been
        bound to a channel, but Peer B has not, so application data to and
        from Peer B uses the Send mechanism.</t>
      </section>

      <section title="Other Features">
        <t>This section describes a few other features of TURN.</t>

        <t>Old versions of RTP <xref target="RFC3550"></xref> required that
        the RTP stream be on an even port number and the associated RTCP
        stream, if present, be on the next highest port. To allow clients to
        work with nodes that still require this,TURN allows the client to
        request that the server allocate a relayed-transport-address with an
        even port number, and to optionally request the server reserve the
        next-highest port number for a subsequent allocation.</t>

        <t>If appropriate, a TURN server can reject an Allocate request with
        the suggestion that the client try an alternative server.</t>

        <t>TURN is designed so that the server can be implemented as an
        application that runs in userland under commonly available operating
        systems and which does not requiring special privileges. This design
        decision has the following implications:<list style="symbols">
            <t>There is no end-to-end QOS, since the value of the Diff-Serv
            field is not preserved across the server;</t>

            <t>There is no end-to-end TTL decrementing, since the value of the
            TTL field is reset by the server;</t>

            <t>There is no end-to-end Explicit Congestion Notification, since
            the ECN field is reset by the server;</t>

            <t>ICMP messages are not relayed by the server;</t>

            <t>Path MTU Discovery does not work, except in the limited way
            available using the DONT-FRAGMENT attribute (see below); and</t>

            <t>There is no end-to-end fragmentation, since the packet is
            re-assembled at the server.</t>
          </list>Future work may specify alternate TURN semantics that address
        these limitations.</t>

        <t>To provide a limited form of Path MTU discovery, TURN has a
        DONT-FRAGMENT attribute. The client may include this attribute in a
        Send indication to specify that the server set the DF (Don't Fragment)
        bit in the UDP datagram that it sends to the peer. Since some servers
        may be unable to set the DF bit, the client should also include this
        attribute in the Allocate request; servers that do not support this
        feature will reject the Allocate request.</t>
      </section>
    </section>

    <section title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>

      <t>Readers are expected to be familiar with <xref
      target="I-D.ietf-behave-rfc3489bis"></xref> and the terms defined
      there.</t>

      <t>The following terms are used in this document:</t>

      <t><list style="hanging">
          <t hangText="TURN:">The protocol spoken between a TURN client and a
          TURN server. It is an extension to the STUN protocol <xref
          target="I-D.ietf-behave-rfc3489bis"></xref>. The protocol allows a
          client to allocate and use a relayed transport address.</t>

          <t hangText="TURN client:">A STUN client that implements this
          specification.</t>

          <t hangText="TURN server:">A STUN server that implements this
          specification. It relays data between a TURN client and its
          peer(s).</t>

          <t hangText="Peer:">A host with which the TURN client wishes to
          communicate. The TURN server relays traffic between the TURN client
          and its peer(s). The peer does not interact with the TURN server
          using the protocol defined in this document; rather, the peer
          receives data sent by the TURN server and the peer sends data
          towards the TURN server.</t>

          <t hangText="Transport Address:">The combination of an IP address
          and a port.</t>

          <t hangText="Host Transport Address:">A transport address on a
          client or a peer.</t>

          <t hangText="Server-Reflexive Transport Address:">A transport
          address on the "public side" of a NAT. This address is allocated by
          the NAT to correspond to a specific host transport address.</t>

          <t hangText="Relayed Transport Address:">A transport address on the
          TURN server that is used for relaying packets between the client and
          a peer. A peer sends to this address on the TURN server, and the
          packet is then relayed to the client.</t>

          <t hangText="TURN Server Transport Address:">A transport address on
          the TURN server that is used for sending TURN messages to the
          server. This is the transport address that the client uses to
          communicate with the server.</t>

          <t hangText="Allocation:">The relayed transport address granted to a
          client through an Allocate request, along with related state, such
          as permissions and expiration timers.</t>

          <t hangText="5-tuple:">The combination (client IP address and port,
          server IP address and port, and transport protocol (UDP or TCP))
          used to communicate between the client and the server . The 5-tuple
          uniquely identifies this communication stream. The 5-tuple also
          uniquely identifies the Allocation on the server.</t>

          <t hangText="Channel">A channel number and associated peer transport
          address. Once a channel number is bound to a peer's transport
          address, the client and server can use the more bandwidth-efficient
          ChannelData message to exchange data.</t>

          <t hangText="Permission:">The IP address and transport protocol (but
          not the port) of a peer that is permitted to send traffic to the
          TURN server and have that traffic relayed to the TURN client. The
          TURN server will only forward traffic to its client from peers that
          match an existing permission.</t>
        </list></t>
    </section>

    <!-- Overview -->

    <section anchor="sec-general-behavior" title="General Behavior">
      <t>This section contains general TURN processing rules that apply to all
      TURN messages.</t>

      <t>TURN is an extension to STUN. All TURN messages, with the exception
      of the ChannelData message, are STUN-formatted messages. All the base
      processing rules described in <xref
      target="I-D.ietf-behave-rfc3489bis"></xref> apply to STUN-formatted
      messages. This means that all the message-forming and -processing
      descriptions in this document are implicitly prefixed with the rules of
      <xref target="I-D.ietf-behave-rfc3489bis"></xref>.</t>

      <t>In addition, the server SHOULD demand that all requests from the
      client be authenticated, using the Long-Term Credential mechanism
      described in <xref target="I-D.ietf-behave-rfc3489bis"></xref>, and the
      client MUST be prepared to authenticate requests if required. Note that
      this authentication mechanism applies only to requests and cannot be
      used to authenticate indications, thus indications in TURN are never
      authenticated. If the server requires requests to be authenticated, then
      the server's administrator MUST choose a realm value that will uniquely
      identify the username and password combination that the client must use,
      even if the client uses multiple servers under different
      administrations. The server's administrator MAY choose to allocate a
      unique username to each client, or MAY choose to allocate the same
      username to more than one client (for example, to all clients from the
      same department or company).</t>

      <t>When a TURN message arrives at the server from the client, the server
      uses the 5-tuple in the message to identify the associated allocation.
      For all TURN messages (including ChannelData) EXCEPT an Allocate
      request, if the 5-tuple does not identify an existing allocation, then
      the message MUST either be rejected with a 437 Allocation Mismatch error
      (if it is a request), or silently ignored (if it is an indication or a
      ChannelData message). A client receiving a 437 error response to a
      request other than Allocate MUST assume the allocation no longer
      exists.</t>

      <t>All requests after the initial Allocate must use the same username as
      that used to create the allocation, to prevent attackers from hijacking
      the client's allocation. Specifically, if the server requires the use of
      the Long-Term Credential mechanism, and if a non-Allocate request passes
      authentication under this mechanism, and if the 5-tuple identifies an
      existing allocation, but the request does not use the same username as
      used to create the allocation, then the request MUST be rejected with a
      441 (Wrong Credentials) error.</t>

      <t>The client SHOULD include the SOFTWARE attribute in all Allocate and
      Refresh requests and MAY include it in any other requests or
      indications. The server SHOULD include the SOFTWARE attribute in all
      Allocate and Refresh responses (either success or failure) and MAY
      include it in other responses or indications. The client and the server
      MAY include the FINGERPRINT attribute in any STUN-formatted messages
      defined in this document.</t>

      <t>TURN does not use the backwards-compatibility mechanism described in
      <xref target="I-D.ietf-behave-rfc3489bis"></xref>.</t>

      <t>By default, TURN runs on the same port as STUN. However, either the
      SRV procedures or the ALTERNATE-SERVER procedures described in <xref
      target="sec-create-allocation"></xref> may be used to run TURN on a
      different port.</t>

      <t>TURN as defined in this specification only supports IPv4. The
      client's IP address, the server's IP address and all IP addresses
      appearing in a relayed-transport-address MUST be IPv4 addresses.</t>

      <t>When UDP transport is used between the client and the server, the
      client will retransmit a request if it does not receive a response
      within a certain timeout period. Because of this, the server may receive
      two (or more) requests with the same 5-tuple and same transaction id.
      STUN requires that the server recognize this case and treat the request
      as idempotent (see <xref target="I-D.ietf-behave-rfc3489bis"></xref>).
      Some implementations may choose to meet this requirement by remembering
      all received requests and the corresponding responses for 40 seconds.
      Other implementations may choose to reprocess the request and arrange
      that such reprocessing returns essentially the same response. To aid
      implementors who choose the latter approach (the so-called "stateless
      stack approach"), this specification includes some implementation notes
      on how this might be done. Implementations are free to choose either
      approach or choose some other approach that gives the same results.</t>

      <t>To mitigate either intentional or unintentional denial-of-service
      attacks against the server by clients with valid usernames and
      passwords, it is RECOMMENDED that the server impose limits on both the
      number of allocations active at one time for a given username and on the
      amount of bandwidth those allocations can use. The server should reject
      new allocations that would exceed the limit on the allowed number of
      allocations active at one time with a 486 (Allocation Quota Exceeded)
      (see <xref target="sec-rcv-allocate"></xref>), and should discard
      application data traffic that exceeds the bandwidth quota.</t>
    </section>

    <section anchor="sec-allocations" title="Allocations">
      <t>All TURN operations revolve around allocations, and all TURN messages
      are associated with an allocation. An allocation conceptually consists
      of the following state data:<list style="symbols">
          <t>the relayed transport address</t>

          <t>The 5-tuple: (client's IP address, client's port, server IP
          address, server port, transport protocol)</t>

          <t>the username and password</t>

          <t>the time-to-expiry</t>

          <t>A list of permissions</t>

          <t>A list of channel to peer bindings</t>
        </list>The relayed transport address is the transport address
      allocated by the server for communicating with peers, while the 5-tuple
      describes the communication path between the client and the server. On
      the client, the 5-tuple uses the client's host transport address, while
      on the server the 5-tuple uses the client's server-reflexive transport
      address.</t>

      <t>Both the relayed-transport-address and the 5-tuple MUST be unique
      across all allocations, so either one can be used to uniquely identify
      the allocation.</t>

      <t>The username and password of the allocation is the username and
      password of the authenticated Allocate request that creates the
      allocation. These are used both to verify subsequent requests and to
      compute the message integrity of responses.</t>

      <t>The time-to-expiry is the time in seconds left until the allocation
      expires. Each Allocate or Refresh transaction sets this timer, which
      then ticks down towards 0. By default, each Allocate or Refresh
      transaction resets this timer to 600 seconds (10 minutes), but the
      client can request a different value in the Allocate and Refresh
      request. Allocations can only be refreshed using the Refresh request;
      sending data to a peer does not refresh an allocation. When an
      allocation expires, the state data associated with the allocation can be
      freed.</t>

      <t>The list of permissions is described in <xref
      target="sec-permissions"></xref> and the list of channels is described
      in <xref target="sec-channels"></xref>.</t>
    </section>

    <section anchor="sec-create-allocation" title="Creating an Allocation">
      <t>An allocation on the server is created using an Allocate
      transaction.</t>

      <section title="Sending an Allocate Request">
        <t>The client forms an Allocate request as follows.</t>

        <t>The client first picks a host transport address. It is RECOMMENDED
        that the client pick a currently-unused transport address, typically
        by allowing the underlying OS to pick a currently-unused port for a
        new socket.</t>

        <t>The client then picks a transport protocol to use between the
        client and the server. The transport protocol MUST be one of UDP, TCP,
        or TLS over TCP. Since this specification only allows UDP between the
        server and the peers, it is RECOMMENDED that the client pick UDP
        unless it has a reason to use a different transport. One reason to
        pick a different transport would be that the client believes, either
        through configuration or by experiment, that it is unable to contact
        any TURN server using UDP. See <xref target="sec-transports"></xref>
        for more discussion.</t>

        <t>The client must also pick a server transport address. Typically,
        this is done by the client learning (perhaps through configuration)
        one or more domain names for TURN servers. In this case, the client
        uses the DNS procedures described in <xref
        target="I-D.ietf-behave-rfc3489bis"></xref>, but using an SRV service
        name of "turn" (or "turns" for TURN over TLS) instead of "stun" (or
        "stuns"). For example, to find servers in the example.com domain, the
        client performs a lookup for '_turn._udp.example.com',
        '_turn._tcp.example.com', and '_turns._tcp.example.com' if the client
        wants to communicate with the server using UDP, TCP, or TLS over TCP,
        respectively.</t>

        <t>The client MUST include a REQUESTED-TRANSPORT attribute in the
        request. This attribute specifies the transport protocol between the
        server and the peers (note that this is NOT the transport protocol
        that appears in the 5-tuple). In this specification, the
        REQUESTED-TRANSPORT type is always UDP. This attribute is included to
        allow future extensions specify other protocols.</t>

        <t>If the client wishes the server to initialize the time-to-expiry
        field of the allocation to some value other the default lifetime, then
        it MAY include a LIFETIME attribute specifying its desired value. This
        is just a request, and the server may elect to use a different value.
        Note that the server will ignore requests to initialize the field to
        less than the default value.</t>

        <t>If the client wishes to later use the DONT-FRAGMENT attribute in
        one or more Send indications on this allocation, then the client
        SHOULD include the DONT-FRAGMENT attribute in the Allocate request.
        This allows the client to test whether this attribute is supported by
        the server.</t>

        <t>If the client requires the port number of the relayed-transport
        address be even, the client includes the EVEN-PORT attribute. If this
        attribute is not included, then the port can be even or odd. By
        setting the R bit in the EVEN-PORT attribute to 1, the client can
        request that the server reserve the next highest port number (on the
        same IP address) for a subsequent allocation. If the R bit is 0, no
        such request is made.</t>

        <t>The client MAY also include a RESERVATION-TOKEN attribute in the
        request to ask the server to use a previously reserved port for the
        allocation. If the RESERVATION-TOKEN attribute is included, then the
        client MUST omit the EVEN-PORT attribute.</t>

        <t>Once constructed, the client sends the Allocate request on the
        5-tuple.</t>
      </section>

      <section anchor="sec-rcv-allocate" title="Receiving an Allocate Request">
        <t>When the server receives an Allocate request, it performs the
        following checks:<list style="numbers">
            <t>The server SHOULD require that the request be authenticated
            using the Long-Term Credential mechanism of <xref
            target="I-D.ietf-behave-rfc3489bis"></xref>.</t>

            <t>The server checks if the 5-tuple is currently in use by an
            existing allocation. If yes, the server rejects the request with a
            437 (Allocation Mismatch) error.</t>

            <t>The server checks if the request contain a REQUESTED-TRANPORT
            attribute. If the REQUESTED-TRANSPORT attribute is not included or
            is malformed, the server rejects the request with a 400 (Bad
            Request) error. Otherwise, if the attribute is included but
            specifies a protocol other that UDP, the server rejects the
            request with a 442 (Unsupported Transport Protocol) error.</t>

            <t>The request may contain a DONT-FRAGMENT attribute. If it does,
            but the server does not support sending UDP datagrams with the DF
            bit set to 1 (see <xref target="sec-ip-header-fields"></xref>),
            then the server treats the DONT-FRAGMENT attribute in the Allocate
            request as an unknown comprehension-required attribute.</t>

            <t>The server checks if the request contains a EVEN-PORT
            attribute. If yes, then the server checks that it satisfy the
            request. If the server cannot satisfy the request, then the server
            rejects the request with a 508 (Insufficient Port Capacity)
            error.</t>

            <t>The server checks if the request contains a RESERVATION-TOKEN
            attribute. If yes, and the request also contains a EVEN-PORT
            attribute, then the server rejects the request with a 400 (Bad
            Request) error. Otherwise it checks to see if the token is valid
            (i.e., the token is in range and has not expired, and the
            corresponding relayed transport address is still available). If
            the token is not valid for some reason, the server rejects the
            request with a 508 (Insufficient Port Capacity) error.</t>

            <t>At any point, the server MAY choose to reject the request with
            a 486 (Allocation Quota Reached) error if it feels the client is
            trying to exceed some locally-defined allocation quota. The server
            is free to define this allocation quota any way it wishes, but
            SHOULD define it based on the username used to authenticate the
            request, and not on the client's transport address.</t>

            <t>Also at any point, the server MAY choose to reject the request
            with a 300 (Try Alternate) error if it wishes to redirect the
            client to a different server. The use of this error code and
            attribute follow the specification in <xref
            target="I-D.ietf-behave-rfc3489bis"></xref>, with the modification
            that a TURN server MAY return this error code and attribute in
            unauthenticated error responses as well as in authenticated error
            responses..</t>
          </list></t>

        <t>If all the checks pass, the server creates the allocation. The
        5-tuple is set to the 5-tuple from the Allocate request, while the
        list of permissions and the list of channels are initially empty.</t>

        <t>The server chooses a relayed-transport-address for the allocation
        as follows:<list style="symbols">
            <t>If the request contains an EVEN-PORT attribute with the R bit
            set to 0, then the server allocates a relayed-transport-address
            with an even port number.</t>

            <t>If the request contains an EVEN-PORT attribute with the R bit
            set to 1, then the server looks for a pair of port numbers N and
            N+1 on the same IP address, where N is even. Port N is used in the
            current allocation, while the relayed transport address with port
            N+1 is assigned a token and reserved for a future allocation. The
            server MUST hold this reservation for at least 30 seconds, and MAY
            choose to hold longer (e.g. until the allocation with port N
            expires). The server then includes the token in a
            RESERVATION-TOKEN attribute in the success response.</t>

            <t>If the request contains a RESERVATION-TOKEN, the server uses
            the previously-reserved transport address corresponding to the
            included token (if it is still available). Note that the
            reservation is a server-wide reservation and is not specific to a
            particular allocation, since the Allocate request containing the
            RESERVATION-TOKEN uses a different 5-tuple than the Allocate
            request that made the reservation. The 5-tuple for the Allocate
            request containing the RESERVATION-TOKEN attribute can be any
            allowed 5-tuple; it can use a different client IP address and
            port, a different transport protocol, and even different server IP
            address and port (provided, of course, that the server IP address
            and port is one that the server is listening for TURN requests
            on).</t>

            <t>Otherwise, the server allocates any available
            relayed-transport-address.</t>
          </list></t>

        <t>In all cases, the server SHOULD only allocate ports from the range
        49152 &ndash; 65535 (the Dynamic and/or Private Port range <xref
        target="Port-Numbers"></xref>), unless the TURN server application
        knows, through some means not specified here, that other applications
        running on the same host as the TURN server application will not be
        impacted by allocating ports outside this range. This condition can
        often be satisfied by running the TURN server application on a
        dedicated machine and/or by arranging that any other applications on
        the machine allocate ports before the TURN server application starts.
        In any case, the TURN server SHOULD NOT allocate ports in the range 0
        - 1023 (the Well-Known Port range) to discourage clients from using
        TURN to run standard services.</t>

        <t><list>
            <t>NOTE: The IETF is currently investigating the topic of
            randomized port assignments to avoid certain types of attacks (see
            <xref target="I-D.ietf-tsvwg-port-randomization"></xref>). It is
            recommended that a TURN implementor keep abreast of this topic
            and, if appropriate, implement a randomized port assignment
            algorithm. This is especially applicable to servers that choose to
            pre-allocate a number of ports from the underlying OS and then
            later assign them to allocations; for example, a server may choose
            this technique to implement the EVEN-PORT attribute.</t>
          </list></t>

        <t>The server determines the initial value of the time-to-expiry field
        as follows. If the request contains a LIFETIME attribute, and the
        proposed lifetime value is greater than the default lifetime, and the
        proposed lifetime value is otherwise acceptable to the server, then
        the server uses that value. Otherwise, the server uses the default
        lifetime. It is RECOMMENDED that the server impose a maximum lifetime
        of no more than 3600 seconds (1 hour). Servers that implement
        allocation quotas or charge users for allocations in some way may wish
        to use a smaller maximum lifetime (perhaps as small as the default
        lifetime) to more quickly remove orphaned allocations (that is,
        allocations where the corresponding client has crashed or terminated
        or the client connection has been lost for some reason). Also note
        that the time-to-expiry is recomputed with each successful Refresh
        request, and thus the value computed here applies only until the first
        refresh.</t>

        <t>Once the allocation is created, the server replies with a success
        response. The success response contains:<list style="symbols">
            <t>A XOR-RELAYED-ADDRESS attribute containing the relayed
            transport address;</t>

            <t>A LIFETIME attribute containing the current value of the
            time-to-expiry timer;</t>

            <t>A RESERVATION-TOKEN attribute (if a second relayed transport
            address was reserved).</t>

            <t>An XOR-MAPPED-ADDRESS attribute containing the client's IP
            address and port (from the 5-tuple).</t>
          </list></t>

        <t><list>
            <t>NOTE: The XOR-MAPPED-ADDRESS attribute is included in the
            response as a convenience to the client. TURN itself does not make
            use of this value, but clients running ICE can often need this
            value and can thus avoid having to do an extra Binding transaction
            with some STUN server to learn it.</t>
          </list></t>

        <t>The response (either success or error) is sent back to the client
        on the 5-tuple.</t>

        <t><list>
            <t>NOTE: Implementations may implement the idempotency of the
            Allocate request over UDP using the so-called "stateless stack
            approach" as follows. To detect retransmissions when the original
            request was successful in creating an allocation, the server can
            store the transaction id that created the request with the
            allocation data and compare it with incoming Allocate requests on
            the same 5-tuple. Once such a request is detected, the server can
            stop parsing the request and immediately generate a success
            response. When building this response, the value of the LIFETIME
            attribute can be taken from the time-to-expiry field in the
            allocate state data, even though this value may differ slightly
            from the LIFETIME value originally returned. In addition, the
            server may need to store an indication of any reservation token
            returned in the original response, so that this may be returned in
            any retransmitted responses.</t>

            <t>For the case where the original request was unsuccessful in
            creating an allocation, the server may choose to do nothing
            special. Note, however, that there is a rare case where the server
            rejects the original request but accepts the retransmitted request
            (because conditions have changed in the brief intervening time
            period). If the client receives the first failure response, it
            will ignore the second (success) response and believe that an
            allocation was not created. An allocation created in this matter
            will eventually timeout, since the client will not refresh it.
            Furthermore, if the client later retries with the same 5-tuple but
            different transaction id, it will receive a 437 (Allocation
            Mismatch), which will cause it to retry with a different 5-tuple.
            The server may use a smaller maximum lifetime value to minimize
            the lifetime of allocations "orphaned" in this manner.</t>
          </list></t>
      </section>

      <section title="Receiving an Allocate Success Response">
        <t>If the client receives an Allocate success response, then it MUST
        check that the mapped address and the relayed transport address are in
        an address family that the client understands and is prepared to deal
        with. This specification only covers the case where these two
        addresses are IPv4 addresses. If these two addresses are not in an
        address family that the client is prepared to deal with, then the
        client MUST delete the allocation (<xref
        target="sec-refreshing-allocation"></xref>) and MUST NOT attempt to
        create another allocation on that server until it believes the
        mismatch has been fixed.</t>

        <t><list>
            <t>The IETF is currently considering mechanisms for transitioning
            between IPv4 and IPv6 that could result in a client originating an
            Allocate request over IPv6, but the request would arrive at the
            server over IPv4, or vica-versa. Hence the importance of this
            check.</t>
          </list></t>

        <t>Otherwise, the client creates its own copy of the allocation data
        structure to track what is happening on the server. In particular, the
        client needs to remember the actual lifetime received back from the
        server, rather than the value sent to the server in the request. The
        client must also remember the 5-tuple used for the request and the
        username and password it used to authenticate the request to ensure
        that it reuses them for subsequent messages. The client also needs to
        track the channels and permissions it establishes on the server.</t>

        <t>The client will probably wish to send the relayed transport address
        to peers (using some method not specified here) so the peers can
        communicate with it. The client may also wish to use the
        server-reflexive address it receives in the XOR-MAPPED-ADDRESS
        attribute in its ICE processing.</t>
      </section>

      <section title="Receiving an Allocate Error Response">
        <t>If the client receives an Allocate error response, then the
        processing depends on the actual error code returned:<list
            style="symbols">
            <t>(Request timed out): There is either a problem with the server,
            or a problem reaching the server with the chosen transport. The
            client considers the current transaction as having failed but MAY
            choose to retry the Allocate request using a different transport
            (e.g., TCP instead of UDP).</t>

            <t>300 (Try Alternate): The server would like the client to use
            the server specified in the ALTERNATE-SERVER attribute instead.
            The client considers the current transaction as having failed, but
            SHOULD try the Allocate request with the alternate server before
            trying any other servers (e.g., other servers discovered using the
            SRV procedures). When trying the Allocate request with the
            alternate server, the client follows the ALTERNATE-SERVER
            procedures specified in <xref
            target="I-D.ietf-behave-rfc3489bis"></xref> with the following
            changes: the client SHOULD accept unauthenticated error responses
            containing the 300 (Try Alternate) error code, the client MUST
            ensure that the realm value received from the alternate server is
            as expected, and the client MUST use the same username and
            password as it would have with the original server. The latter
            checks protect against an attacker sending the client an
            unauthenticated Allocate error response that redirects the client
            to some totally different and unexpected server.</t>

            <t>400 (Bad Request): The server believes the client's request is
            malformed for some reason. The client considers the current
            transaction as having failed. The client MAY notify the user or
            operator and SHOULD NOT retry the request with this server until
            it believes the problem has been fixed.</t>

            <t>401 (Unauthorized): If the client has followed the procedures
            of the Long-Term Credential mechanism and still gets this error,
            then the server is not accepting the client's credentials. In this
            case, the client considers the current transaction as having
            failed and SHOULD notify the user or operator. The client SHOULD
            NOT send any further requests to this server until it believes the
            problem has been fixed.</t>

            <t>420 (Unknown Attribute): If the client included a DONT-FRAGMENT
            attribute in the request and the server rejected the request with
            a 420 error code and listed the DONT-FRAGMENT attribute in the
            UNKNOWN-ATTRIBUTES attribute in the error response, then the
            client now knows that the server does not support the
            DONT-FRAGMENT attribute. The client considers the current
            transaction as having failed but MAY choose to retry the Allocate
            request without the DONT-FRAGMENT attribute.</t>

            <t>437 (Allocation Mismatch): This indicates that the client has
            picked a 5-tuple which the server sees as already in use. One way
            this could happen is if an intervening NAT assigned a mapped
            transport address that was used by another client which recently
            crashed. The client considers the current transaction as having
            failed. The client SHOULD pick another client transport address
            and retry the Allocate request (using a different transaction id).
            The client SHOULD try three different client transport addresses
            before giving up on this server. Once the client gives up on the
            server, it SHOULD NOT try to create another allocation on the
            server for 2 minutes.</t>

            <t>438 (Stale Nonce): See the procedures for the Long-Term
            Credential mechanism <xref
            target="I-D.ietf-behave-rfc3489bis"></xref>.</t>

            <t>441 (Wrong Credentials): The client should not receive this
            error in response to a Allocate request. The client MAY notify the
            user or operator and SHOULD NOT retry the same request with this
            server until it believes the problem has been fixed.</t>

            <t>442 (Unsupported Transport Address): The client should not
            receive this error in response to a request for a UDP allocation.
            The client MAY notify the user or operator and SHOULD NOT
            reattempt the request with this server until it believes the
            problem has been fixed.</t>

            <t>486 (Allocation Quota Reached): The server is currently unable
            to create any more allocations with this username. The client
            considers the current transaction as having failed. The client
            SHOULD wait at least 1 minute before trying to create any more
            allocations on the server.</t>

            <t>508 (Insufficient Port Capacity): The server has no more
            relayed transport addresses available, or has none with the
            requested properties, or the one that was reserved is no longer
            available. The client considers the current operation as having
            failed. If the client is using either the EVEN-PORT or the
            RESERVATION-TOKEN attribute, then the client MAY choose to remove
            or modify this attribute and try again immediately. Otherwise, the
            client SHOULD wait at least 1 minute before trying to create any
            more allocations on this server.</t>
          </list></t>
      </section>
    </section>

    <section anchor="sec-refreshing-allocation"
             title="Refreshing an Allocation">
      <t>A Refresh transaction can be used to either (a) refresh an existing
      allocation and update its time-to-expiry, or (b) delete an existing
      allocation.</t>

      <t>If a client wishes to continue using an allocation, then the client
      MUST refresh it before it expires. It is suggested that the client
      refresh the allocation roughly 1 minute before it expires. If a client
      no longer wishes to use an allocation, then it SHOULD explicitly delete
      the allocation. A client MAY also refresh an allocation at any time for
      other reasons.</t>

      <section title="Sending a Refresh Request">
        <t>If the client wishes to immediately delete an existing allocation,
        it includes a LIFETIME attribute with a value of 0. All other forms of
        the request refresh the allocation.</t>

        <t>The Refresh transaction updates the time-to-expiry timer of an
        allocation. If the client wishes the server to set the time-to-expiry
        timer to something other than the default lifetime, it includes a
        LIFETIME attribute with the requested value. The server then computes
        a new time-to-expiry value in the same way as it does for an Allocate
        transaction, with the exception that a requested lifetime of 0 causes
        the server to immediately delete the allocation.</t>
      </section>

      <section title="Receiving a Refresh Request">
        <t>When the server receives a Refresh request, it processes it as
        follows:<list style="numbers">
            <t>The server checks the credentials of the request as per the
            Long-Term Credential mechanism, checks that the allocation exists,
            and does the additional username check of <xref
            target="sec-general-behavior"></xref>.</t>

            <t>The server computes a value called the "desired lifetime" as
            follows: If the request contains a LIFETIME attribute and the
            attribute value is 0, then the desired lifetime is 0. Otherwise,
            if the request contains a LIFETIME attribute and the attribute
            value is greater than the default lifetime, and if the attribute
            value is otherwise acceptable to the server, then the desired
            lifetime is the attribute value. Otherwise the desired lifetime is
            the default value.</t>

            <t>Subsequent processing depends on the desired lifetime
            value:<list style="symbols">
                <t>If desired lifetime is 0, then the request succeeds and the
                allocation is deleted.</t>

                <t>If the desired lifetime is non-zero, then the request
                succeeds and the allocation's time-to-expiry is set to the
                desired lifetime</t>
              </list>If the request succeeds, then server sends a success
            response containing:<list style="symbols">
                <t>A LIFETIME attribute containing the current value of the
                time-to-expiry timer.</t>
              </list></t>
          </list></t>

        <t><list>
            <t>NOTE: A server need not do anything special to implement
            idempotency of Refresh requests over UDP using the "stateless
            stack approach". Retransmitted Refresh requests with a non-zero
            desired lifetime will simply refresh the allocation. A
            retransmitted Refresh request with a zero desired lifetime will
            cause a 437 (Allocation Mismatch) response if the allocation has
            already been deleted, but the client will treat this as equivalent
            to a success response (see below).</t>
          </list></t>
      </section>

      <section title="Receiving a Refresh Response">
        <t>If the client receives a success response to its Refresh request
        with a non-zero lifetime, it updates its copy of the allocation data
        structure with the time-to-expiry value contained in the response.</t>

        <t>If the client receives a 437 (Allocation Mismatch) error response
        to a request to delete the allocation, then the allocation no longer
        exists and it should consider its request as having effectively
        succeeded.</t>
      </section>
    </section>

    <section anchor="sec-permissions" title="Permissions">
      <t>For each allocation, the server keeps a list of zero or more
      permissions. Each permission consists of an IP address which uniquely
      identifies the permission, and an associated time-to-expiry. The IP
      address describes a set of peers that are allowed to send data to the
      client, and the time-to-expiry is the number of seconds until the
      permission expires.</t>

      <t>By sending either CreatePermission requests or ChannelBind requests,
      the client can cause the server to install or refresh a permission for a
      given IP address. This causes one of two things to happen:<list
          style="symbols">
          <t>If no permission for that IP address exists, then a permission is
          created with the given IP address and a time-to-expiry equal to the
          default permission lifetime.</t>

          <t>If a permission for that IP address already exists, then the
          lifetime for that permission is reset to the default permission
          lifetime.</t>
        </list>The default permission lifetime MUST be 300 seconds (= 5
      minutes).</t>

      <t>Each permission&rsquo;s time-to-expiry decreases down once per second
      until it reaches 0, at which point the permission expires and is
      deleted.</t>

      <t>CreatePermission and ChannelBind requests may be freely intermixed on
      a permission. A given permission may be installed or refreshed at one
      point in time with a CreatePermission request, and then refreshed with a
      ChannelBind request at a different point in time, or vica-versa.</t>

      <t>When a UDP datagram arrives at the relayed transport address for the
      allocation, the server checks the list of permissions for that
      allocation. If there is a permission with an IP address that is equal to
      the source IP address of the UDP datagram, then the UDP datagram can be
      relayed to the client. Otherwise, the UDP datagram is silently
      discarded. Note that only IP addresses are compared; port numbers are
      irrelevant.</t>

      <t>The permissions for one allocation are totally unrelated to the
      permissions for a different allocation. If an allocation expires, all
      its permissions expire with it.</t>

      <t><list>
          <t>NOTE: Though TURN permissions expire after 5 minutes, many NATs
          deployed at the time of publication expire their UDP bindings
          considerably faster. Thus an application using TURN will probably
          wish to send some sort of keep-alive traffic at a much faster rate.
          Applications using ICE should follow the keep-alive guidelines of
          ICE <xref target="I-D.ietf-mmusic-ice"></xref>, and applications not
          using ICE are advised to do something similar.</t>
        </list></t>
    </section>

    <section title="CreatePermission">
      <t>TURN supports two ways for the client to install or refresh
      permissions on the server. This section describes one way: the
      CreatePermission request.</t>

      <t>A CreatePermission request may be used in conjunction with either the
      Send mechanism<xref target="sec-sendanddata"></xref> or the Channel
      mechanism<xref target="sec-channels"></xref>.</t>

      <section title="Forming a CreatePermission request">
        <t>The client who wishes to install or refresh a permission can send a
        CreatePermission request to the server.</t>

        <t>When forming a CreatePermission request, the client MUST include a
        XOR-PEER-ADDRESS attribute. The IP address portion of the
        XOR-PEER-ADDRESS attribute contains the IP address for which a
        permission should be installed or refreshed. The port portion of the
        XOR-PEER-ADDRESS attribute will be ignored and can be any arbitrary
        value.</t>
      </section>

      <section title="Receiving a CreatePermission request">
        <t>When the server receives the CreatePermission request, it processes
        it as follows.</t>

        <t>The message is first checked for validity. The CreatePermission
        request MUST contain a XOR-PEER-ADDRESS attribute. If this attribute
        is missing or invalid, then the message is discarded and a 400 (Bad
        Request) error is returned.</t>

        <t>If the message is valid, then the server installs or refreshes a
        permission for the IP address contained in the XOR-PEER-ADDRESS
        attribute as described in <xref target="sec-permissions"></xref>. The
        port portion of the attribute is ignored and may be any arbitrary
        value.</t>

        <t>The server then responds with a CreatePermission success response.
        There are no mandatory attributes in the success response.</t>

        <t><list>
            <t>NOTE: A server need not do anything special to implement
            idempotency of CreatePermission requests over UDP using the
            "stateless stack approach". Retransmitted CreatePermission
            requests will simply refresh the allocation.</t>
          </list></t>
      </section>

      <section title="Receiving a CreatePermission response">
        <t>If the client receives a valid CreatePermission success response,
        then the client updates its data structures to indicate that the
        permission has been installed or refreshed.</t>
      </section>
    </section>

    <section anchor="sec-sendanddata" title="Send and Data Methods">
      <t>TURN supports two mechanisms for sending and receive data from peers.
      This section describes the use of the Send and Data mechanism, while
      <xref target="sec-channels"></xref> describes the use of the Channel
      mechanism.</t>

      <section anchor="sec-forming-indication"
               title="Forming a Send Indication">
        <t>The client can use a Send indication to pass data to the server for
        relaying to a peer. A client may use a Send indication even if a
        channel is bound to that peer.</t>

        <t>When forming a Send indication, the client MUST include a
        XOR-PEER-ADDRESS attribute and a DATA attribute. The XOR-PEER-ADDRESS
        attribute contains the transport address of the peer to which the data
        is to be sent, and the DATA attribute contains the actual application
        data to be sent to the peer.</t>

        <t>The client MAY include a DONT-FRAGMENT attribute in the Send
        indication if it wishes the server to set the DF bit on the UDP
        datagram sent to the peer.</t>
      </section>

      <section title="Receiving a Send Indication">
        <t>When the server receives a Send indication, it processes it as
        follows.</t>

        <t>The message is first checked for validity. The Send indication MUST
        contain both a XOR-PEER-ADDRESS attribute and a DATA attribute. If one
        of these attributes is missing or invalid, then the message is
        discarded.</t>

        <t>The Send indication may also contain the DONT-FRAGMENT attribute.
        If the server is unable to set the DF bit on outgoing UDP datagrams
        when this attribute is present, then the server acts as if the
        DONT-FRAGMENT attribute is an unknown comprehension-required attribute
        (and thus the Send indication is silently ignored).</t>

        <t>If the message is valid, then the server forms a UDP datagram as
        follows:<list style="symbols">
            <t>the source transport address is the relayed transport address
            of the allocation, where the allocation is determined by the
            5-tuple on which the Send indication arrived;</t>

            <t>the destination transport address is taken from the
            XOR-PEER-ADDRESS attribute;</t>

            <t>the data following the UDP header is the contents of the value
            field of the DATA attribute.</t>
          </list></t>

        <t>The handling of the DONT-FRAGMENT attribute (if present), is
        described in <xref target="sec-ip-header-fields"></xref>.</t>

        <t>The resulting UDP datagram is then sent to the peer.</t>

        <t>Send indications do not cause a permission to be installed or
        refresh; thus it is possible for the client to send data to a peer
        without installing a permission.</t>
      </section>

      <section anchor="sec-sending-data-indication"
               title="Receiving a UDP Datagram">
        <t>When the server receives a UDP datagram at a currently allocated
        relayed transport address, the server looks up the allocation
        associated with the relayed transport address. It then checks to see
        if relaying is permitted, as described in <xref
        target="sec-permissions"></xref>.</t>

        <t>If relaying is permitted, then the server checks if there is a
        channel bound to the peer that sent the UDP datagram (see <xref
        target="sec-channels"></xref>). If a channel is bound, then processing
        proceeds as described in <xref
        target="sec-channel-relaying"></xref>.</t>

        <t>If relaying is permitted but no channel is bound to the peer, then
        the server forms and sends a Data indication. The Data indication MUST
        contain both a XOR-PEER-ADDRESS and a DATA attribute. The DATA
        attribute is set to the value of the &lsquo;data octets&rsquo; field
        from the datagram, and the XOR-PEER-ADDRESS attribute is set to the
        source transport address of the received UDP datagram. The Data
        indication is then sent on the 5-tuple associated with the
        allocation.</t>
      </section>

      <section title="Receiving a Data Indication">
        <t>When the client receives a Data indication, it checks that the Data
        indication contains both a XOR-PEER-ADDRESS and a DATA attribute, and
        discards the indication if it does not. The client SHOULD also check
        that the XOR-PEER-ADDRESS attribute value contains an IP address with
        which the client believes there is an active permission, and discard
        the Data indication otherwise.</t>

        <t><list>
            <t>NOTE: The latter check protects the client against an attacker
            who somehow manages to trick the server into installing
            permissions not desired by the client.</t>
          </list></t>

        <t>If the Data indication passes the above checks, the client delivers
        the data octets inside the DATA attribute to the application, along
        with an indication that they were received from the peer whose
        transport address is given by the XOR-PEER-ADDRESS attribute.</t>
      </section>
    </section>

    <!-- Sending and Receiving Data -->

    <section anchor="sec-channels" title="Channels">
      <t>Channels provide a way for the client and server to send application
      data using ChannelData messages, which have less overhead than Send and
      Data indications.</t>

      <t>Channel bindings are always initiated by the client. The client can
      bind a channel to a peer at any time during the lifetime of the
      allocation. The client may bind a channel to a peer before exchanging
      data with it, or after exchanging data with it (using Send and Data
      indications) for some time, or may choose never to bind a channel it.
      The client can also bind channels to some peers while not binding
      channels to other peers.</t>

      <t>Channel bindings are specific to an allocation, so that a binding in
      one allocation has no relationship to a binding in any other allocation.
      If an allocation expires, all its channel bindings expire with it.</t>

      <t>A channel binding consists of:<list style="symbols">
          <t>A channel number;</t>

          <t>A transport address (of the peer);</t>

          <t>A time-to-expiry timer.</t>
        </list>Within the context of an allocation, a channel binding is
      uniquely identified either by the channel number or by the peer's
      transport address. Thus the same channel cannot be bound to two
      different transport addresses, nor can the same transport address be
      bound to two different channels.</t>

      <t>A channel binding lasts for 10 minutes unless refreshed. Refreshing
      the binding (by the server receiving a ChannelBind request rebinding the
      channel to the same peer) resets the time-to-expiry timer back to 10
      minutes.</t>

      <t>When the channel binding expires, the channel becomes unbound. Once
      unbound, the channel number can be bound to a different transport
      address, and the transport address can be bound to a different channel
      number. To prevent race conditions, the client MUST wait 5 minutes after
      the channel binding expires before attempting to bind the channel number
      to a different transport address or the transport address to a different
      channel number.</t>

      <t>When binding a channel to a peer, the client SHOULD be prepared to
      receive ChannelData messages on the channel from the server as soon as
      it has sent the ChannelBind request. Over UDP, it is possible for the
      client to receive ChannelData messages from the server before it
      receives a ChannelBind success response.</t>

      <t>In the other direction, the client MAY elect to send ChannelData
      messages before receiving the ChannelBind success response. Doing so,
      however, runs the risk of having the ChannelData messages dropped by the
      server if the ChannelBind request does not succeed for some reason
      (e.g., packet lost if the request is sent over UDP, or the server being
      unable to fulfill the request). A client that wishes to be safe should
      either queue the data, or use Send indications until the channel binding
      is confirmed.</t>

      <section title="Sending a ChannelBind Request">
        <t>A channel binding is created or refreshed using a ChannelBind
        transaction. A ChannelBind transaction also creates or refreshes a
        permission towards the peer.</t>

        <t>To initiate the ChannelBind transaction, the client forms a
        ChannelBind request. The channel to be bound is specified in a
        CHANNEL-NUMBER attribute, and the peer's transport address is
        specified in a XOR-PEER-ADDRESS attribute. <xref
        target="sec-receiving-ChannelBind"></xref> describes the restrictions
        on these attributes.</t>

        <t>Rebinding a channel to the same transport address that it is
        already bound to provides a way to refresh a channel binding and the
        corresponding permission without sending data to the peer. Note
        however, that permissions need to be refreshed more frequently than
        channels.</t>
      </section>

      <section anchor="sec-receiving-ChannelBind"
               title="Receiving a ChannelBind Request">
        <t>When the server receives a ChannelBind request, it checks the
        following:<list style="symbols">
            <t>The request contains both a CHANNEL-NUMBER and a
            XOR-PEER-ADDRESS attribute;</t>

            <t>The channel number is in the range 0x4000 to 0xFFFE
            (inclusive);</t>

            <t>The channel number is not currently bound to a different
            transport address (same transport address is OK);</t>

            <t>The transport address is not currently bound to a different
            channel number.</t>
          </list>If any of these tests fail, the server replies with an error
        response with error code 400 "Bad Request". Otherwise, the ChannelBind
        request is valid and the server replies with a ChannelBind success
        response. There are no required attributes in a successful ChannelBind
        response.</t>

        <t>If ChannelBind request is valid, then the server creates or
        refreshes the channel binding using the channel number in the
        CHANNEL-ADDRESS attribute and the transport address in the
        XOR-PEER-ADDRESS attribute. The server also installs or refreshes a
        permission for the IP address in the XOR-PEER-ADDRESS attribute as
        described in <xref target="sec-permissions"></xref>.</t>

        <t><list>
            <t>NOTE: A server need not do anything special to implement
            idempotency of ChannelBind requests over UDP using the "stateless
            stack approach". Retransmitted ChannelBind requests will simply
            refresh the channel binding and the corresponding permission.
            Furthermore, the client must wait 5 minutes before binding a
            previously bound channel number or peer address to a different
            channel, eliminating the possibility that the transaction would
            initially fail but succeed on a retransmission.</t>
          </list></t>
      </section>

      <section title="Receiving a ChannelBind Response">
        <t>When the client receives a ChannelBind success response, it updates
        its data structures to record that the channel binding is now active.
        It also updates its data structures to record that the corresponding
        permission has been installed or refreshed.</t>

        <t>If the client receives a ChannelBind failure response that
        indicates that the channel information is out-of-sync between the
        client and the server (e.g., an unexpected 400 "Bad Request"
        response), then it is RECOMMENDED that the client immediately delete
        the allocation and start afresh with a new allocation.</t>
      </section>

      <section anchor="sec-channeldata-msg" title="The ChannelData Message">
        <t>The ChannelData message is used to carry application data between
        the client and the server. It has the following format:</t>

        <figure>
          <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Channel Number        |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                       Application Data                        /
/                                                               /
|                                                               |
|                               +-------------------------------+
|                               |
+-------------------------------+]]></artwork>
        </figure>

        <t>The Channel Number field specifies the number of the channel on
        which the data is traveling, and thus the address of the peer that is
        sending or is to receive the data. The channel number MUST be in the
        range 0x4000 &ndash; 0xFFFF, with channel number 0xFFFF being reserved
        for possible future extensions.</t>

        <t>Channel numbers 0x0000 &ndash; 0x3FFF cannot be used because bits 0
        and 1 are used to distinguish ChannelData messages from STUN-formatted
        messages (i.e., Allocate, Send, Data, ChannelBind, etc).
        STUN-formatted messages always have bits 0 and 1 as &ldquo;00&rdquo;,
        while ChannelData messages use combinations &ldquo;01&rdquo;,
        &ldquo;10&rdquo;, and &ldquo;11&rdquo;.</t>

        <t>The Length field specifies the length in bytes of the application
        data field (i.e., it does not include the size of the ChannelData
        header). Note that 0 is a valid length.</t>

        <t>The Application Data field carries the data the client is trying to
        send to the peer, or that the peer is sending to the client.</t>
      </section>

      <section anchor="sec-sending-channeldata-msg"
               title="Sending a ChannelData Message">
        <t>Once a client has bound a channel to a peer, then when the client
        has data to send to that peer it may use either a ChannelData message
        or a Send indication; that is, the client is not obligated to use the
        channel when it exists and may freely intermix the two message types
        when sending data to the peer. The server, on the other hand, MUST use
        the ChannelData message if a channel has been bound to the peer.</t>

        <t>The fields of the ChannelData message are filled in as described in
        <xref target="sec-channeldata-msg"></xref>.</t>

        <t>Over stream transports, the ChannelData message MUST be padded to a
        multiple of four bytes in order to ensure the alignment of subsequent
        messages. The padding is not reflected in the length field of the
        ChannelData message, so the actual size of a ChannelData message
        (including padding) is (4 + Length) rounded up to the nearest multiple
        of 4. Over UDP, the padding is not required but MAY be included.</t>

        <t>The ChannelData message is then sent on the 5-tuple associated with
        the allocation.</t>
      </section>

      <section title="Receiving a ChannelData Message">
        <t>The receiver of the ChannelData message uses bits 0 and 1 to
        distinguish it from STUN-formatted messages, as described in <xref
        target="sec-channeldata-msg"></xref>.</t>

        <t>If the ChannelData message is received in a UDP datagram, and if
        the UDP datagram is too short to contain the claimed length of the
        ChannelData message (i.e., the UDP header length field value is less
        than the ChannelData header length field value + 4 + 8), then the
        message is silently discarded.</t>

        <t>If the ChannelData message is received over TCP or over TLS over
        TCP, then the actual length of the ChannelData message is as described
        in <xref target="sec-sending-channeldata-msg"></xref>.</t>

        <t>If the ChannelData message is received on a channel which is not
        bound to any peer, then the message is silently discarded.</t>

        <t>On the client, it is RECOMMENDED that the client discard the
        ChannelData message if the client believes there is no active
        permission towards the peer.</t>

        <t>On the server, if no errors are detected, the server relays the
        application data to the peer by forming a UDP datagram as
        follows:<list style="symbols">
            <t>the source transport address is the relayed transport address
            of the allocation, where the allocation is determined by the
            5-tuple on which the ChannelData message arrived;</t>

            <t>the destination transport address is the transport address to
            which the channel is bound;</t>

            <t>the data following the UDP header is the contents of the data
            field of the ChannelData message.</t>
          </list>The resulting UDP datagram is then sent to the peer. Note
        that if the Length field in the ChannelData message is 0, then there
        will be no data in the UDP datagram, but the UDP datagram is still
        formed and sent.</t>
      </section>

      <section anchor="sec-channel-relaying"
               title="Relaying Data from the Peer">
        <t>When the server receives a UDP datagram on the relayed transport
        address associated with an allocation, the server processes it as
        described in <xref target="sec-sending-data-indication"></xref>. If
        that section indicates that a ChannelData message should be sent
        (because there is a channel bound to the peer that sent to UDP
        datagram), then the server forms and sends a ChannelData message as
        described in <xref target="sec-sending-channeldata-msg"></xref>.</t>
      </section>
    </section>

    <section anchor="sec-ip-header-fields" title="IP Header Fields">
      <t>This section describes how the server sets various fields in the IP
      header when relaying between the client and the peer or vica-versa. The
      descriptions in this section apply: (a) when the server sends a UDP
      datagram to the peer, or (b) when the server sends a Data indication or
      ChannelData message to the client over UDP transport. The descriptions
      in this section do not apply to TURN messages sent over TCP or TLS
      transport from the server to the client.</t>

      <t>Time to Live (TTL) field<list style="empty">
          <t>Set the outgoing value to the default for outgoing packets.</t>
        </list><vspace blankLines="1" /></t>

      <t>Diff-Serv Code Point (DSCP) field <xref
      target="RFC2474">]</xref><list style="empty">
          <t>Set the outgoing value to a fixed value, which by default is Best
          Effort unless configured otherwise.</t>
        </list></t>

      <t><vspace blankLines="1" /></t>

      <t>Explicit Congestion Notification (ECN) field <xref
      target="RFC3168"></xref><list style="empty">
          <t>Set the outgoing value to 00 (ECN not supported).</t>
        </list></t>

      <t><vspace blankLines="1" /></t>

      <t>IPv4 Fragmentation fields<list>
          <t>When the server sends a packet to a peer in response to a Send
          indication containing the DONT-FRAGMENT attribute, then the server
          MUST set the DF bit in the outgoing IP header to 1. In all other
          cases (e.g., Data indication, or DONT-FRAGMENT attribute not
          included in the Send indication), the server SHOULD set the DF bit
          in the outgoing packet to 0.</t>

          <t>The server sets the other fragmentation fields (Identification,
          MF, Fragment Offset) as appropriate for a packet originating from
          the server.</t>
        </list></t>

      <t><vspace blankLines="1" /></t>

      <t>IPv4 Options<list>
          <t>The outgoing packet is sent without any IPv4 options.</t>
        </list></t>
    </section>

    <section anchor="sec-stun-methods" title="New STUN Methods">
      <t>This section lists the codepoints for the new STUN methods defined in
      this specification. See elsewhere in this document for the semantics of
      these new methods.</t>

      <figure>
        <preamble></preamble>

        <artwork><![CDATA[  0x003  :  Allocate          (only request/response semantics defined)
  0x004  :  Refresh           (only request/response semantics defined)
  0x006  :  Send              (only indication semantics defined)
  0x007  :  Data              (only indication semantics defined)
  0x008  :  CreatePermission  (only request/response semantics defined
  0x009  :  ChannelBind       (only request/response semantics defined)

]]></artwork>
      </figure>
    </section>

    <section anchor="sec-stun-attributes" title="New STUN Attributes">
      <figure>
        <preamble>This STUN extension defines the following new
        attributes:</preamble>

        <artwork><![CDATA[
  0x000C: CHANNEL-NUMBER
  0x000D: LIFETIME
  0x0010: Reserved (was BANDWIDTH)
  0x0012: XOR-PEER-ADDRESS
  0x0013: DATA
  0x0016: XOR-RELAYED-ADDRESS
  0x0018: EVEN-PORT
  0x0019: REQUESTED-TRANSPORT
  0x001a: DONT-FRAGMENT
  0x0021: Reserved (was TIMER-VAL)
  0x0022: RESERVATION-TOKEN
]]></artwork>
      </figure>

      <section anchor="channelnums" title="CHANNEL-NUMBER">
        <t>The CHANNEL-NUMBER attribute contains the number of the channel. It
        is a 16-bit unsigned integer, followed by a two-octet RFFU (Reserved
        For Future Use) field which MUST be set to 0 on transmission and MUST
        be ignored on reception.</t>

        <figure>
          <artwork><![CDATA[
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |        Channel Number         |         RFFU = 0              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>
      </section>

      <section title="LIFETIME">
        <t>The LIFETIME attribute represents the duration for which the server
        will maintain an allocation in the absence of a refresh. It is a
        32-bit unsigned integral value representing the number of seconds
        remaining until expiration.</t>
      </section>

      <section title="XOR-PEER-ADDRESS">
        <t>The XOR-PEER-ADDRESS specifies the address and port of the peer as
        seen from the TURN server. It is encoded in the same way as
        XOR-MAPPED-ADDRESS.</t>
      </section>

      <section title="DATA">
        <t>The DATA attribute is present in all Send and Data indications. The
        contents of DATA attribute is the application data (that is, the data
        that would immediately follow the UDP header if the data was been sent
        directly between the client and the peer).</t>
      </section>

      <section title="XOR-RELAYED-ADDRESS">
        <t>The XOR-RELAYED-ADDRESS is present in Allocate responses. It
        specifies the address and port that the server allocated to the
        client. It is encoded in the same way as XOR-MAPPED-ADDRESS.</t>
      </section>

      <section title="EVEN-PORT">
        <t>This attribute allows the client to request that the port in the
        relayed-transport-address be even, and (optionally) that the server
        reserve the next-highest port number. The attribute is 8 bits long.
        Its format is:</t>

        <figure>
          <preamble></preamble>

          <artwork><![CDATA[   0               
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+
  |R|             |
  +-+-+-+-+-+-+-+-+]]></artwork>
        </figure>

        <t></t>

        <t>The attribute contains a single 1-bit flag:<list style="hanging">
            <t hangText="R:">If 1, the server is requested to reserve the next
            highest port number (on the same IP address) for a subsequent
            allocation. If 0, no such reservation is requested.</t>
          </list>The other 7 bits of the attribute are ignored.</t>
      </section>

      <section anchor="sec-requested-transport" title="REQUESTED-TRANSPORT">
        <t>This attribute is used by the client to request a specific
        transport protocol for the allocated transport address. It has the
        following format:</t>

        <figure>
          <artwork><![CDATA[   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    Protocol   |                    RFFU                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <t>The Protocol field specifies the desired protocol. The codepoints
        used in this field are taken from those allowed in the Protocol field
        in the IPv4 header and the NextHeader field in the IPv6 header <xref
        target="Protocol-Numbers"></xref>. This specification only allows the
        use of codepoint 17 (User Datagram Protocol).</t>

        <t>The RFFU field MUST be set to zero on transmission and MUST be
        ignored on reception. It is reserved for future uses.</t>
      </section>

      <section title="DONT-FRAGMENT">
        <t>This attribute is used by the client to request that the server set
        the DF (Don't Fragment) bit in the IP header when relaying the
        application data onward to the peer. This attribute has no value part
        and thus the attribute length field is 0.</t>
      </section>

      <section title="RESERVATION-TOKEN">
        <t>The RESERVATION-TOKEN attribute contains a token that uniquely
        identifies a relayed transport address being held in reserve by the
        server. The server includes this attribute in a success response to
        tell the client about the token, and the client includes this
        attribute in a subsequent Allocate request to request the server use
        that relayed transport address for the allocation.</t>

        <t>The attribute value is a 64-bit-long field containing the token
        value.</t>
      </section>
    </section>

    <section anchor="sec-stun-errors" title="New STUN Error Response Codes">
      <t>This document defines the following new error response codes:</t>

      <t><list style="hanging">
          <t hangText="437">(Allocation Mismatch): A request was received by
          the server that requires an allocation to be in place, but there is
          none, or a request was received which requires no allocation, but
          there is one.</t>

          <t hangText="441">(Wrong Credentials): The credentials in the
          (non-Allocate) request, though otherwise acceptable to the server,
          do not match those used to create the allocation.</t>

          <t hangText="442">(Unsupported Transport Protocol): The Allocate
          request asked the server to use a transport protocol between the
          server and the peer that the server does not support. NOTE: This
          does NOT refer to the transport protocol used in the 5-tuple.</t>

          <t hangText="486">(Allocation Quota Reached): No more allocations
          using this username can be created at the present time.</t>

          <t hangText="508">(Insufficient Port Capacity): The server has no
          more relayed transport addresses available right now, or has none
          with the requested properties, or the one that corresponds to the
          specified token is not available.</t>
        </list></t>
    </section>

    <section anchor="sec-security" title="Security Considerations">
      <t>This section considers attacks that are possible in a TURN
      deployment, and discusses how they are mitigated by mechanisms in the
      protocol or recommended practices in the implementation.</t>

      <section title="Outsider Attacks">
        <t>Outsider attacks are ones where the attacker has no credentials in
        the system, and is attempting to disrupt the service seen by the
        client or the server.</t>

        <section title="Obtaining Unauthorized Allocations">
          <t>An attacker might wish to obtain allocations on a TURN server for
          any number of nefarious purposes. A TURN server provides a mechanism
          for sending and receiving packets while cloaking the actual IP
          address of the client. This makes TURN servers an attractive target
          for attackers who wish to use it to mask their true identity.</t>

          <t>An attacker might also wish to simply utilize the services of a
          TURN server without paying for them. Since TURN services require
          resources from the provider, it is anticipated that their usage will
          come with a cost.</t>

          <t>These attacks are prevented using the digest authentication
          mechanism which allows the TURN server to determine the identity of
          the requestor and whether the requestor is allowed to obtain the
          allocation.</t>
        </section>

        <section title="Offline Dictionary Attacks">
          <t>The digest authentication mechanism used by TURN is subject to
          offline dictionary attacks. An attacker that is capable of
          eavesdropping on a message exchange between a client and server can
          determine the password by trying a number of candidate passwords and
          seeing if one of them is correct. This attack works when the
          passwords are low entropy, such as a word from the dictionary. This
          attack can be mitigated by using strong passwords with large
          entropy. In situations where even stronger mitigation is required,
          TLS transport between the client and the server can be used.</t>
        </section>

        <section title="Faked Refreshes and Permissions">
          <t>An attacker might wish to attack an active allocation by sending
          it a Refresh with an immediate expiration, in order to delete it and
          disrupt service to the client. This is prevented by authentication
          of refreshes. Similarly, an attacker wishing to send
          CreatePermission requests to create permissions to undesirable
          destinations is prevented from doing so through authentication. The
          motivations for such an attack are described in <xref
          target="sec-firewall"></xref>.</t>
        </section>

        <section title="Fake Data">
          <t>An attacker might wish to send data to the client or the peer, as
          if they came from the peer or client respectively. To do that, the
          attacker can send the client a faked Data Indication or ChannelData
          message, or send the TURN server a faked Send Indication or
          ChannelData message.</t>

          <t>Indeed, since indications and ChannelData messages are not
          authenticated, this attack is not prevented by TURN. However, this
          attack is generally present in IP-based communications and is not
          substantially worsened by TURN. Consider an normal, non-TURN IP
          session between hosts A and B. An attacker can send packets to B as
          if they came from A by sending packets towards A with a spoofed IP
          address of B. This attack requires the attacker to know the IP
          addresses of A and B. With TURN, an attacker wishing to send packets
          towards a client using a Data indication needs to know its IP
          address (and port), the IP address and port of the TURN server, and
          the IP address and port of the peer (for inclusion in the
          XOR-PEER-ADDRESS attribute). To send a fake ChannelData message to a
          client, an attacker needs to know the IP address and port of the
          client, the IP address and port of the TURN server, and the channel
          number. This particular combination is mildly more guessable than in
          the non-TURN case.</t>

          <t>These attacks are more properly mitigated by application layer
          authentication techniques. In the case of real time traffic, usage
          of SRTP <xref target="RFC3711"></xref> prevents these attacks
          completely.</t>
        </section>

        <section title="Impersonating a Server">
          <t>When a client learns a relayed address from a TURN server, it
          uses that relayed address in application protocols to receive
          traffic. Therefore, an attacker wishing to intercept or redirect
          that traffic might try to impersonate a TURN server and provide the
          client with a faked relayed address.</t>

          <t>This attack is prevented through the digest authentication
          mechanism, which provides message integrity for responses in
          addition to verifying that they came from the server. Furthermore,
          an attacker cannot replay old server responses; the transaction ID
          in the STUN header prevents this.</t>
        </section>

        <section title="Eavesdropping Traffic">
          <t>TURN concerns itself primarily with authentication and message
          integrity. Confidentiality is only a secondary concern, as TURN
          control messages do not include information that is particularly
          sensitive. The primary protocol content of the messages is the IP
          address of the peer. If it is important to prevent an eavesdropper
          on a TURN connection from learning this, TURN can be run over
          TLS.</t>

          <t>Confidentiality for the application data relayed by TURN is best
          provided by the application protocol itself, since running TURN over
          TLS does not protect application data between the server and the
          peer. If confidentiality of application data is important, then the
          application should encrypt or otherwise protect its data. For
          example, for real time media, confidentiality can be provided by
          using SRTP.</t>
        </section>
      </section>

      <section anchor="sec-firewall" title="Firewall Considerations">
        <t>A key aspect of TURN's security considerations is that it should
        not weaken the protections afforded by firewalls deployed between a
        client and a TURN server. It is anticipated that TURN servers will
        often be present on the public Internet, and clients may often be
        inside enterprise networks with corporate firewalls. If TURN servers
        provide a 'backdoor' for reaching into the enterprise, TURN will be
        blocked by these firewalls.</t>

        <t>TURN servers therefore emulate the behavior of NAT devices which
        implement address-dependent filtering <xref target="RFC4787"></xref>,
        a property common in many firewalls as well. When a NAT or firewall
        implements this behavior, packets from an outside IP address are only
        allowed to be sent to an internal IP address and port if the internal
        IP address and port had recently sent a packet to that outside IP
        address. TURN servers introduce the concept of permissions, which
        provide exactly this same behavior on the TURN server. An attacker
        cannot send a packet to a TURN server and expect it to be relayed
        towards the client, unless the client has tried to contact the
        attacker first.</t>

        <t>It is important to note that some firewalls have policies which are
        even more restrictive than address-dependent filtering. Firewalls can
        also be configured with address and port dependent filtering, or can
        be configured to disallow inbound traffic entirely. In these cases, if
        a client is allowed to connect the TURN server, communications to the
        client will be less restrictive than what the firewall would normally
        allow.</t>

        <section title="Faked Permissions">
          <t>In firewalls and NAT devices, permissions are granted implicitly
          through the traversal of a packet from the inside of the network
          towards the outside peer. Thus, a permission cannot, by definition,
          be created by any entity except one inside the firewall or NAT. With
          TURN, this restriction no longer holds. Since the TURN server sits
          outside the firewall, at attacker outside the firewall can now send
          a message to the TURN server and try to create a permission for
          itself.</t>

          <t>This attack is prevented because all messages which create
          permissions (i.e., ChannelBind and CreatePermission) are
          authenticated.</t>
        </section>

        <section title="Blacklisted IP Addresses">
          <t>Many firewalls can be configured with blacklists which prevent a
          client behind the firewall from sending packets to, or receiving
          packets from, ranges of blacklisted IP addresses. This is
          accomplished by inspecting the source and destination addresses of
          packets entering and exiting the firewall, respectively.</t>

          <t>If a client connects to a TURN server, it will be able to bypass
          such blacklisting policies and communicate with IP addresses which
          the firewall would otherwise restrict. This is a problem for other
          protocols that provide tunneling functions, such as VPNs. It is
          possible to build TURN-aware firewalls which inspect TURN messages,
          and check the IP address of the correspondent. TURN messages to
          offending destinations can then be rejected. TURN is designed so
          that this inspection can be done statelessly.</t>
        </section>

        <section title="Running Servers on Well-Known Ports">
          <t>A malicious client behind a firewall might try to connect to a
          TURN server and obtain an allocation which it then uses to run a
          server. For example, a client might try to run a DNS server or FTP
          server.</t>

          <t>This is not possible in TURN. A TURN server will never accept
          traffic from a peer which the client itself has not contacted. Thus,
          peers cannot just connect to the allocated port in order to obtain
          the service.</t>
        </section>
      </section>

      <section title="Insider Attacks">
        <t>In insider attacks, a client has legitimate credentials but defies
        the trust relationship that goes with those credentials. These attacks
        cannot be prevented by cryptographic means but need to be considered
        in the design of the protocol.</t>

        <section title="DoS Against TURN Server">
          <t>A client wishing to disrupt service to other clients might obtain
          an allocation and then flood it with traffic, in an attempt to swamp
          the server and prevent it from servicing other legitimate clients.
          This is mitigated by the recommendation that the server limit the
          amount of bandwidth it will relay for a given username. This won't
          prevent a client from sending a large amount of traffic, but it
          allows the server to immediately discard traffic in excess.</t>

          <t>Since each allocation uses a port number on the IP address of the
          TURN server, the number of allocations on a server is finite. An
          attacker might attempt to consume all of them by requesting a large
          number of allocations. This is prevented by the recommendation that
          the server impose a limit of the number of allocations active at a
          time for a given username.</t>
        </section>

        <section title="Anonymous Relaying of Malicious Traffic">
          <t>TURN servers provide a degree of anonymization. A client can send
          data to correspondent peers without revealing their own IP
          addresses. TURN servers may therefore become attractive vehicles for
          attackers to launch attacks against targets without fear of
          detection. Indeed, it is possible for a client to chain together
          multiple TURN servers, such that any number of relays can be used
          before a target receives a packet.</t>

          <t>Administrators who are worried about this attack can maintain
          logs which capture the actual source IP and port of the client. This
          will allow for forensic tracing to determine the original source,
          should it be discovered that an attack is being relayed through a
          TURN server.</t>
        </section>

        <section title="Manipulating other Allocations">
          <t>An attacker might attempt to disrupt service to other users of
          the TURN server by sending Refresh requests or CreatePermission
          requests which (through source address spoofing) appear to be coming
          from another user of the TURN server. TURN prevents this by
          requiring that the credentials used in CreatePermission, Refresh,
          and ChannelBind messages match those used to create the initial
          allocation. Thus, the fake requests from the attacker will be
          rejected.</t>
        </section>
      </section>

      <section title="Other Considerations">
        <t>Any relay addresses learned through an Allocate request will not
        operate properly with IPSec Authentication Header (AH) <xref
        target="RFC4302"></xref> in transport or tunnel mode. However,
        tunnel-mode IPSec ESP <xref target="RFC4303"></xref> should still
        operate.</t>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>Since TURN is an extension to STUN <xref
      target="I-D.ietf-behave-rfc3489bis"></xref>, the methods, attributes and
      error codes defined in this specification are new methods, attributes,
      and error codes for STUN. This section directs IANA to add these new
      protocol elements to the IANA registry of STUN protocol elements.</t>

      <t>The codepoints for the new STUN methods defined in this specification
      are listed in <xref target="sec-stun-methods"></xref>.</t>

      <t>The codepoints for the new STUN attributes defined in this
      specification are listed in <xref
      target="sec-stun-attributes"></xref>.</t>

      <t>The codepoints for the new STUN error codes defined in this
      specification are listed in <xref target="sec-stun-errors"></xref>.</t>

      <t>Extensions to TURN can be made through IETF consensus.</t>
    </section>

    <section title="IAB Considerations">
      <t>The IAB has studied the problem of "Unilateral Self Address Fixing",
      which is the general process by which a client attempts to determine its
      address in another realm on the other side of a NAT through a
      collaborative protocol reflection mechanism <xref
      target="RFC3424"></xref>. The TURN extension is an example of a protocol
      that performs this type of function. The IAB has mandated that any
      protocols developed for this purpose document a specific set of
      considerations.</t>

      <t>TURN is an extension of the STUN protocol. As such, the specific
      usages of STUN that use the TURN extensions need to specifically address
      these considerations. Currently the only STUN usage that uses TURN is
      <xref target="I-D.ietf-mmusic-ice">ICE</xref>, and the IAB
      considerations for the ICE usage of TURN are discussed in the base ICE
      document.</t>
    </section>

    <section title="Open Issues">
      <t>Note to RFC Editor: Please remove this section prior to publication
      of this document as an RFC.</t>

      <t>This section lists the known issues in this version of the
      specification.</t>

      <t>(No open issues at this time)</t>
    </section>

    <section title="Changes from Previous Versions">
      <t>Note to RFC Editor: Please remove this section prior to publication
      of this document as an RFC.</t>

      <t>This section lists the changes between the various versions of this
      specification.</t>

      <section title="Changes from -09 to -10">
        <t><list style="symbols">
            <t>Changed the recommendation for using the SOFTWARE attribute.
            Previously its use was recommended in all requests and responses;
            now it is only recommended in Allocate and Refresh requests and
            responses, though it may appear elsewhere. Also, version -09
            incorrectly referred to this attribute as "SOFTWARE-TYPE".</t>

            <t>Changed the name of the PEER-ADDRESS and RELAYED-ADDRESS
            attributes to XOR-PEER-ADDRESS and XOR-RELAYED-ADDRESS
            respectively for consistency with other specifications.</t>

            <t>Removed the concept of a "preserving" allocation. All
            allocations are now non-preserving. This simplifies the base
            specification and allows it to advance more rapidly; see the
            discussion in the BEHAVE meeting of 29 July 2008. The concept of a
            preserving allocation will be advanced as an extension to TURN. As
            part of this change, the P bit in the REQUESTED-PROPS attribute,
            the ICMP attribute, and ICMP message relaying was removed.
            Further, in <xref target="sec-ip-header-fields"></xref>, the
            preferred behaviors were removed, leaving the alternate behaviors
            as the specified behaviors.</t>

            <t>Replaced the REQUESTED-PROPS attribute with the EVEN-PORT
            attribute. The new attribute lacks the feature of the old
            attribute of being an alternate way to specify new allocation
            properties. As a consequence, the only way to specify a new
            allocation property is to define a new attribute.</t>

            <t>Added text recommending that the client check that the IP
            address in XOR-PEER-ADDRESS attribute in a received Data
            indication is one with which the client believes there is an
            active permission. Similarly, it is recommended that the client
            check that a permission exist when receiving a ChannelData
            message.</t>

            <t>Added text recommending that the client delete the allocation
            if it receives a ChannelBind failure response on an unbound
            channel.</t>

            <t>Added the CreatePermission request/response transaction which
            adds or updates permissions, and removed the ability for Send
            indications and ChannelBind messages to install or update
            permissions. The net effect is that only authenticate-able
            messages (i.e., CreatePermission requests and ChannelBind
            requests) can install or refresh permissions; unauthenticate-able
            Send indications and ChannelData messages do not.</t>

            <t>Removed all support for IPv6. All IPv6 support, including ways
            of relaying between IPv4 and IPv6, will now be covered in <xref
            target="I-D.ietf-behave-turn-ipv6"></xref>.</t>

            <t>Reserved attribute code point 0x0021. This was previously used
            for the TIMER-VAL attribute, which was removed when the
            SetActiveDestination feature was removed.</t>

            <t>Added the DONT-FRAGMENT attribute which allows the client to
            request that the server set the DF bit when sending the UDP
            datagram to the peer. This attribute may appear in both Allocate
            requests and Send indications.</t>

            <t>Changed how the ALTERNATE-SERVER attribute is used. The
            attribute can no longer be used with any error code, but must be
            used with 300 (Try Alternative). It can now appear in
            unauthenticated responses, however there are restrictions around
            how the subsequent Allocate request is authenticated.</t>

            <t>Reworked the details of how idempotency of requests is handled,
            making it clear that the stack can either remember all
            transactions for 40 seconds, or can handle this using the
            so-called "stateless stack approach". Made some changes to the
            semantics of the Allocate, Refresh, and ChannelBind requests as a
            consequence.</t>

            <t>Added the requirement that a client cannot re-use previously
            bound channel number or transport address until 5 minutes after
            the channel binding expires. This avoids various race
            conditions.</t>

            <t>Removed the requirement that an allocation cannot be re-used
            within 2 minutes of having been deleted. This requirement was put
            in place to prevent mis-delivered packets but is no longer seen as
            having any real value.</t>

            <t>Added a recommendation that the server impose quotas on both
            the number of allocations and the amount of bandwidth a given
            username can use at one time. These quotas help protect against
            denial-of-service attacks.</t>

            <t>Completely rewrote the security considerations section.</t>

            <t>Made quite a few changes to the descriptive text in both the
            Overview and the normative text to try to further clarify
            concepts.</t>
          </list></t>
      </section>

      <section title="Changes from -08 to -09">
        <t><list style="symbols">
            <t>Added text to properly define the ICMP attribute. This
            attribute was introduced in TURN-08, but not fully defined due to
            an oversight. Clarified that the attribute can appear in a Data
            indication, but not a Send indication. Added text to the section
            on receiving a Data indication that points out that this attribute
            may be present.</t>

            <t>Changed the wording around the handling of the DSCP field to
            allow the server to set the DSCP to an arbitrary value if the next
            hop is a Diff-Serv classifier and marker.</t>

            <t>When the server generates a 508 response due to an unsupported
            flag in the REQUESTED-PROPS attribute, the server now includes the
            REQUESTED-PROPS attribute in the response with all the flags it
            supports set to 1. This allows the client to see if the server
            does not understand one of its flags. Similarly, the client is now
            allowed to immediately retry the request if it modifies the
            included REQUESTED-PROPS attribute.</t>

            <t>Clarified that the REQUESTED-PROPS attribute can be used in
            conjunction with the RESERVATION-TOKEN attribute as long as both
            the E and R bits are 0. The spec previously contradicted itself on
            this point.</t>

            <t>Clarified that when the server receives a ChannelData message
            with a length field of 0, it sends a UDP Datagram to the peer that
            contains no application data.</t>

            <t>Rewrote some text around relaying incoming UDP Datagrams to
            avoid duplication of text in the Data indication and Channel
            sections.</t>

            <t>Added a note that points out that the on-going work on
            randomizing port allocations <xref
            target="I-D.ietf-tsvwg-port-randomization"></xref> may be
            applicable to TURN.</t>

            <t>Clarified that the Allocate request containing a
            RESERVATION-TOKEN attribute can use any 5-tuple, and that 5-tuple
            need not have any specific relationship to the 5-tuple of the
            Allocate request that created the reservation.</t>

            <t>Added a note that discusses retransmitted Allocate requests
            over UDP where the first request receives a failure response, but
            the second receives a success response. The server may elect to
            remember transmitted failure responses to avoid this
            situation.</t>

            <t>Added text about the usage of the SOFTWARE-TYPE attribute
            (formerly known as the SERVER attribute) in TURN messages.</t>

            <t>Rewrote the text in the Overview that motivates why TURN
            supports TCP and TLS between the client and the server. The
            previous text had been identified by various readers as inadequate
            and misleading.</t>

            <t>Rewrote the section how a server handles a Refresh request to
            clarify processing in various error conditions. The new text makes
            it clear that it is OK to delete a non-existent allocation. It
            also clarifies how to handle retransmissions of Refresh requests
            over UDP.</t>

            <t>Renamed the "RELAY-ADDRESS" attribute to "RELAYED-ADDRESS",
            since the text consistently uses the term "relayed transport
            address" for the concept and ICE uses the term "relayed
            candidate".</t>

            <t>Changed the codepoint assigned to the error code "Wrong
            Credentials" from 438 to 441 to avoid a conflict with the "Stale
            Nonce" error code of STUN.</t>

            <t>Changed the text to consistently use non-capitalized "request",
            "response" and "indication", except in headings, error code names,
            etc.</t>

            <t>Added a note mentioning that TURN packets can be demuxed from
            other packets arriving on the same socket by looking at the
            5-tuple of the arriving packet.</t>

            <t>Clarified that there are no required attributes is a
            ChannelBind success response.</t>
          </list></t>
      </section>

      <section title="Changes from -07 to -08">
        <t><list style="symbols">
            <t>Removed the BANDWIDTH attribute and all associated text
            (including error code 507 "Insufficient Bandwidth Capacity"), as
            the requirements for this feature were not clear and it was felt
            the feature could be easily added later.</t>

            <t>Changed the format of the REQUESTED-PROPS attribute from a
            one-byte field to a set of bit flags. Changed the semantics of the
            unused portion of the value from RFFU to "MUST be 0" to give a
            more desirable behavior when new flags are defined.</t>

            <t>Introduced the concept of Preserving vs. Non-Preserving
            allocations. As a result, completely revamped the rules for how to
            set the fields in the IP header, and added rules for relaying ICMP
            messages when the allocation is Preserving.</t>
          </list></t>
      </section>

      <section title="Changes from -06 to -07">
        <t><list style="symbols">
            <t>Rewrote the General Behavior section, making various changes in
            the process.</t>

            <t>Changed the usage of authentication from MUST to SHOULD.</t>

            <t>Changed the requirement that subsequent requests use the same
            username and password from MUST to SHOULD to allow for the
            possibility of changing the credentials using some unspecified
            mechanism.</t>

            <t>Introduced a 438 (Wrong Credentials) error which is used when a
            non-Allocate request authenticates but does not use the same
            username and password as the Allocate request. Having a separate
            error code for this case avoids the client being confused over
            what the error actually is.</t>

            <t>The server must now prevent the relayed transport address and
            the 5-tuple from being reused in different allocations for 2
            minutes after the allocation expires.</t>

            <t>Changed the usage of FINGERPRINT from MUST NOT to MAY, to allow
            for the possible multiplexing of TURN with some other
            protocol.</t>

            <t>Rewrote much of the section on Allocations, splitting it into
            three new sections (one on allocations in general, one on creating
            an allocation, and one on refreshing an allocation).</t>

            <t>Replaced the mechanism for requesting relayed transport
            addresses with specific properties. The new mechanism is less
            powerful: a client can request an even port, or a pair of ports,
            but cannot request a single odd port or a specific port as was
            possible under the old mechanism. Nor can the client request a
            specific IP address.</t>

            <t>Changed the rules for handling ALTERNATE-SERVER, removing the
            requirement that the referring server have "positive knowledge"
            about the state of the alternate server. The new rules instead
            rely on text in STUN to prevent referral loops.</t>

            <t>Changed the rules for allocation lifetimes. Allocations
            lifetimes are now a minimum of 10 minutes; the client can ask for
            longer values, but requests for shorter values are ignored. The
            text now recommends that the client refresh an allocation one
            minute before it expires.</t>

            <t>Put in temporary procedures for handling the BANDWIDTH
            attribute, modelled on the LIFETIME attribute. These procedures
            are mostly placeholders and likely to change in the next
            revision.</t>

            <t>Added a detailed description of how a client reacts to the
            various errors it can receive in reply to an Allocate request.
            This replaces the various descriptions that were previously
            scattered throughout the document, which were inconsistent and
            sometimes contradictory.</t>

            <t>Added a new section that gives the normative rules for
            permissions.</t>

            <t>Changed the rules around permission lifetimes. The text used to
            recommend a value of one minute; it MUST now be 5 minutes.</t>

            <t>Removed the errors "Channel Missing or Invalid", "Peer Address
            Missing or Invalid" and "Lifetime Malformed or Invalid" and used
            400 "Bad Request" instead.</t>

            <t>Rewrote portions of the section on Send and Data indications
            and the section on Channels to try to make the client vs. server
            behavior clearer.</t>

            <t>Channel bindings now expire after 10 minutes, and must be
            refreshed to keep them alive.</t>

            <t>Binding a channel now installs or refreshes a permission for
            the IP address of corresponding peer.</t>

            <t>Changed the wording describing the situation when the client
            sends a ChannelData message before receiving the ChannelBind
            success response. -06 said that client SHOULD NOT do this; -07 now
            says that a client MAY, but describes the consequences of doing
            it.</t>

            <t>Added a section discussing the setting of fields in the IP
            header.</t>

            <t>Replaced the REQUESTED-PORT-PROPS attribute with the
            REQUESTED-PROPS attribute that has a different format and
            semantics, but reuses the same code point.</t>

            <t>Replaced the REQUESTED-IP attribute with the RESERVATION-TOKEN
            attribute, which has a different format and semantics, but reuses
            the same code point.</t>

            <t>Removed error codes 443 and 444, and replaced them with 508
            (Insufficient Port Capacity). Also changed the error text for code
            507 from "Insufficient Capacity" to "Insufficient Bandwidth
            Capacity".</t>
          </list></t>
      </section>

      <section title="Changes from -05 to -06">
        <t><list style="symbols">
            <t>Changed the mechanism for allocating channels to the one
            proposed by Eric Rescorla at the Dec 2007 IETF meeting.</t>

            <t>Removed the framing mechanism (which was used to frame all
            messages) and replaced it with the ChannelData message. As part of
            this change, noted that the demux of ChannelData messages from
            TURN messages can be done using the first two bits of the
            message.</t>

            <t>Rewrote the sections on transmitted and receiving data as a
            result of the above to changes, splitting it into a section on
            Send and Data indications and a separate section on channels.</t>

            <t>Clarified the handling of Allocate request messages. In
            particular, subsequent Allocate request messages over UDP with the
            same transaction id are not an error but a retransmission.</t>

            <t>Restricted the range of ports available for allocation to the
            Dynamic and/or Private Port range, and noted when ports outside
            this range can be used.</t>

            <t>Changed the format of the REQUESTED-TRANSPORT attribute. The
            previous version used 00 for UDP and 01 for TCP; the new version
            uses protocol numbers from the IANA protocol number registry. The
            format of the attribute also changed.</t>

            <t>Made a large number of changes to the non-normative portion of
            the document to reflect technical changes and improve the
            presentation.</t>

            <t>Added the Issues section.</t>
          </list></t>
      </section>

      <section title="Changes from -04 to -05">
        <t><list style="symbols">
            <t>Removed the ability to allocate addresses for TCP relaying.
            This is now covered in a separate document. However, communication
            between the client and the server can still run over TCP or
            TLS/TCP. This resulted in the removal of the Connect method and
            the TIMER-VAL and CONNECT-STAT attributes.</t>

            <t>Added the concept of channels. All communication between the
            client and the server flows on a channel. Channels are numbered
            0..65535. Channel 0 is used for TURN messages, while the remaining
            channels are used for sending unencapsulated data to/from a remote
            peer. This concept adds a new Channel Confirmation method and a
            new CHANNEL-NUMBER attribute. The new attribute is also used in
            the Send and Data methods.</t>

            <t>The framing mechanism formally used just for stream-oriented
            transports is now also used for UDP, and the former Type and
            Reserved fields in the header have been replaced by a Channel
            Number field. The length field is zero when running over UDP.</t>

            <t>TURN now runs on its own port, rather than using the STUN port.
            The use of channels requires this.</t>

            <t>Removed the SetActiveDestination concept. This has been
            replaced by the concept of channels.</t>

            <t>Changed the allocation refresh mechanism. The new mechanism
            uses a new Refresh method, rather than repeating the Allocation
            transaction.</t>

            <t>Changed the syntax of SRV requests for secure transport. The
            new syntax is "_turns._tcp" rather than the old "_turn._tls". This
            change mirrors the corresponding change in STUN SRV syntax.</t>

            <t>Renamed the old REMOTE-ADDRESS attribute to PEER-ADDRESS, and
            changed it to use the XOR-MAPPED-ADDRESS format.</t>

            <t>Changed the RELAY-ADDRESS attribute to use the
            XOR-MAPPED-ADDRESS format (instead of the MAPPED-ADDRESS
            format)).</t>

            <t>Renamed the 437 error code from "No Binding" to "Allocation
            Mismatch".</t>

            <t>Added a discussion of what happens if a client's public binding
            on its outermost NAT changes.</t>

            <t>The document now consistently uses the term "peer" as the name
            of a remote endpoint with which the client wishes to
            communicate.</t>

            <t>Rewrote much of the document to describe the new concepts. At
            the same time, tried to make the presentation clearer and less
            repetitive.</t>
          </list></t>
      </section>
    </section>

    <section title="Acknowledgements">
      <t>The authors would like to thank the various participants in the
      BEHAVE working group for their many comments on this draft. Marc
      Petit-Huguenin, Remi Denis-Courmont, Jason Fischl, Derek MacDonald,
      Scott Godin, Cullen Jennings, Lars Eggert, Magnus Westerlund, Benny
      Prijono, and Eric Rescorla have been particularly helpful, with Eric
      also suggesting the channel allocation mechanism, and Cullen suggesting
      the REQUESTED-PORT-PROPS mechanism. Christian Huitema was an early
      contributor to this document and was a co-author on the first few
      drafts. Finally, the authors would like to thank Dan Wing for both his
      contributions to the text and his huge help in restarting progress on
      this draft after work had stalled.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.I-D.ietf-behave-rfc3489bis"?>

      <?rfc include="reference.RFC.2119"?>

      <?rfc include='reference.RFC.2474'?>

      <?rfc include='reference.RFC.3168'?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1918"?>

      <?rfc include="reference.RFC.3424"?>

      <?rfc include='reference.RFC.4787'?>

      <?rfc include="reference.I-D.ietf-mmusic-ice"?>

      <?rfc include="reference.I-D.ietf-behave-turn-tcp"?>

      <?rfc include="reference.I-D.ietf-behave-turn-ipv6"?>

      <?rfc include="reference.I-D.ietf-tsvwg-udp-guidelines"?>

      <?rfc include='reference.I-D.ietf-tsvwg-port-randomization'?>

      <?rfc include='reference.RFC.1928'?>

      <?rfc include='reference.RFC.3550'?>

      <?rfc include='reference.RFC.3711'?>

      <?rfc include='reference.RFC.4302'?>

      <?rfc include='reference.RFC.4303'?>

      <reference anchor="Port-Numbers"
                 target="http://www.iana.org/assignments/port-numbers">
        <front>
          <title>IANA Port Numbers Registry</title>
        </front>
      </reference>

      <reference anchor="Protocol-Numbers"
                 target="http://www.iana.org/assignments/protocol-numbers">
        <front>
          <title>IANA Protocol Numbers Registry</title>

          <author>
            <organization></organization>
          </author>

          <date year="2005" />
        </front>
      </reference>
    </references>
  </back>
</rfc>