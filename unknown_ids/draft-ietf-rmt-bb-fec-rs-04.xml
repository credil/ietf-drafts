<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<rfc category="std" ipr="full3978" docName="draft-ietf-rmt-bb-fec-rs-04.txt">

<?xml-stylesheet type='text/xsl'
                 href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="no" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

	<front>
		<title abbrev='Reed-Solomon Forward Error Correction'>
			Reed-Solomon Forward Error Correction (FEC) Schemes
		</title>

		<author initials="J" surname="Lacan" fullname="Jerome Lacan">
			<organization>ISAE</organization>
			<address>
				<postal>
					<street>1, place Emile Blouin</street>
					<city>Toulouse</city>
					<code>31056</code>
					<country>France</country>
				</postal>
				<email>jerome.lacan@isae.fr</email>
				<uri>http://dmi.ensica.fr/auteur.php3?id_auteur=5</uri>
				
			</address>
		</author>
		<author initials='V' surname="Roca" fullname='Vincent Roca'>
			<organization>INRIA</organization>
			<address>
				<postal>
					<street>655, av. de l'Europe</street>
					<street>Inovallee; Montbonnot</street>
					<city>ST ISMIER cedex</city>
					<code>38334</code>
					<country>France</country>
				</postal>
				<email>vincent.roca@inrialpes.fr</email>
				<uri>http://planete.inrialpes.fr/~roca/</uri>
			</address>
		</author>
		<author initials="J" surname="Peltotalo" fullname="Jani Peltotalo">
			<organization>Tampere University of Technology</organization>
			<address>
				<postal>
					<street>P.O. Box 553 (Korkeakoulunkatu 1)</street>
					<city>Tampere</city>
					<code>FIN-33101</code>
					<country>Finland</country>
				</postal>
				<email>jani.peltotalo@tut.fi</email>
				<uri>http://atm.tut.fi/mad</uri>
			</address>
		</author>
		<author initials="S" surname="Peltotalo" fullname="Sami Peltotalo">
			<organization>Tampere University of Technology</organization>
			<address>
				<postal>
					<street>P.O. Box 553 (Korkeakoulunkatu 1)</street>
					<city>Tampere</city>
					<code>FIN-33101</code>
					<country>Finland</country>
				</postal>
				<email>sami.peltotalo@tut.fi</email>
				<uri>http://atm.tut.fi/mad</uri>
			</address>
		</author>
		<date day="10" month="October" year="2007"/>
		<area>General</area>
		<workgroup>Reliable Multicast Transport</workgroup>
		<keyword>I-D</keyword>
		<keyword>Internet-Draft</keyword>
		<keyword>Forward Error Correction</keyword>
		<keyword>Reed-Solomon</keyword>

		<abstract>
<t>This document describes a Fully-Specified Forward Error Correction (FEC) Scheme for the Reed-Solomon
FEC codes over GF(2^^m), with m in {2..16}, and its application to the reliable delivery of data objects on
the packet erasure channel.
</t>
<t>
This document also describes a Fully-Specified FEC Scheme for the special case of Reed-Solomon
codes over GF(2^^8) when there is no encoding symbol group.
</t>
<t>
Finally, in the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129),
this document assigns an FEC Instance ID to the special case of Reed-Solomon codes over GF(2^^8).</t>

<t>Reed-Solomon codes belong to the class of Maximum Distance Separable (MDS) codes, i.e., they enable
a receiver to recover the k source symbols from any set of k received symbols.
The schemes described here are compatible with the implementation from Luigi Rizzo.</t>
		</abstract>
	</front>

	<middle>

		<section anchor="Introduction" title="Introduction">
		<!-- =========================================== -->

<t>The use of Forward Error Correction (FEC) codes is a classical solution to improve the reliability
of multicast and broadcast transmissions.
The <xref target="rfc5052_fecbb"/> document describes a general framework to use FEC
in Content Delivery Protocols (CDP).
The companion document <xref target="rfc3453"/> describes some applications of FEC codes for content delivery.</t>

<t>Recent FEC schemes like <xref target="draft-ietf-rmt-bb-fec-raptor-object"/> and
<xref target="draft-ietf-rmt-bb-fec-ldpc"/> proposed erasure codes based on sparse graphs/matrices.
These codes are efficient in terms of processing but not optimal in terms of correction
capabilities when dealing with "small" objects.</t>

<t>The FEC scheme described in this document belongs to the class of Maximum Distance Separable codes
that are optimal in terms of erasure correction capability.
In others words, it enables a receiver to recover the k source symbols from any set of exactly k encoding symbols.
Even if the encoding/decoding complexity is larger than that of
<xref target="draft-ietf-rmt-bb-fec-raptor-object"/> or <xref target="draft-ietf-rmt-bb-fec-ldpc"/>,
this family of codes is very useful.</t>

<t>Many applications dealing with content transmission or content storage already rely on packet-based
Reed-Solomon codes.
In particular, many of them use the Reed-Solomon codec of Luigi Rizzo  <xref target="RS-codec"/>.
The goal of the present document to specify an implementation of Reed-Solomon codes that is compatible
with this codec.</t>

<t>The present document:
<list style="symbols">
	<t> introduces the Fully-Specified FEC Scheme with FEC Encoding ID 2
	that specifies the use of Reed-Solomon codes over GF(2^^m), with m in {2..16},</t>
	<t> introduces the Fully-Specified FEC Scheme with FEC Encoding ID 5 that focuses on the special
	case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group (i.e., exactly one symbol
	per packet), and</t>
	<t> in the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129)
        <xref target="draft-ietf-rmt-bb-fec-basic-schemes-revised"/>, assigns the FEC Instance ID 0 to the
	special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group.</t>
</list>
</t>
		</section>


		<section anchor="Terminology" title="Terminology">
		<!-- =========================================== -->

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 <xref target="rfc2119"/>.</t>
		</section>


		<section anchor="DefinitionsNotationsandAbbreviations" title="Definitions Notations and Abbreviations">
		<!-- =========================================== -->


			<section anchor="Definitions" title="Definitions">
			<!-- =========================================== -->

<t>This document uses the same terms and definitions as those specified in  <xref target="rfc5052_fecbb"/>.
Additionally, it uses the following definitions:

<list style="empty">
<t>Source symbol:		unit of data used during the encoding process.</t>
<t>Encoding symbol:		unit of data generated by the encoding process.</t>
<!--
<t>Encoding block:		set of encoding symbols generated by an encoding process.</t>
-->
<t>Repair symbol:		encoding symbol that is not a source symbol.</t>
<t>Systematic code:		FEC code in which the source symbols are part
				of the encoding symbols.</t>
<t>Source block:		a block of k source symbols that are considered
				together for the encoding.</t>
<t>Encoding Symbol Group:	a group of encoding symbols that are
				sent together within the same packet, and
				whose relationships to the source block can be
				derived from a single Encoding Symbol ID.</t>
<t>Source Packet:		a data packet containing only source
				symbols.</t>
<t>Repair Packet:		a data packet containing only repair
				symbols.</t>
</list>
</t>
			</section>


			<section anchor="Notations" title="Notations">
			<!-- =========================================== -->

<t>This document uses the following notations:
<list style="empty">
<t>L		denotes the object transfer length in bytes.</t>
<t>k		denotes the number of source symbols in a source block.</t>
<t>n_r		denotes the number of repair symbols generated for a source block.</t>
<t>n		denotes the encoding block length, i.e., the number of
		encoding symbols generated for a source block.
		Therefore: n = k + n_r.</t>
<t>max_n	denotes the maximum number of encoding symbols generated for any
		source block.</t>
<t>B		denotes the maximum source block length in symbols,
		i.e., the maximum number of source symbols per source block.</t>
<t>N		denotes the number of source blocks into which the object
		shall be partitioned.</t>
<t>E		denotes the encoding symbol length in bytes.</t>
<t>S		denotes the symbol size in units of m-bit elements.
		When m = 8, then S and E are equal.</t>
<t>m		defines the length of the elements in the finite field, in bits.
		In this document, m belongs to {2..16}.</t>
<t>q		defines the number of elements in the finite field. We have: q = 2^^m in this specification.</t>
<t>G		denotes the number of encoding symbols per group, i.e.
		the number of symbols sent in the same packet.</t>
<t>GM		denotes the Generator Matrix of a Reed-Solomon code.</t>
<t>rate		denotes the "code rate", i.e., the k/n ratio.</t>
<t>a^^b		denotes a raised to the power b.</t>
<t>a^^-1	denotes the inverse of a.</t> 
<t>I_k		denotes the k*k identity matrix.</t>
</list></t>
			</section>

			<section anchor="Abbreviations" title="Abbreviations">
			<!-- =========================================== -->

<t>This document uses the following abbreviations:
<list style="empty">
<t>ESI		stands for Encoding Symbol ID.</t>
<t>FEC OTI	stands for FEC Object Transmission Information.</t>
<t>RS		stands for Reed-Solomon.</t>
<t>MDS		stands for Maximum Distance Separable code.</t>
<t>GF(q)	denotes a finite field (also known as Galois Field) with q elements.
		We assume that q = 2^^m in this document.</t>
</list>
</t>
			</section>
		</section>


<section title="Formats and Codes with FEC Encoding ID 2">
<!-- ========================== -->

<t>This section introduces the formats and codes associated to the Fully-Specified FEC Scheme
with FEC Encoding ID 2
that specifies the use of Reed-Solomon codes over GF(2^^m).</t>

  <section title="FEC Payload ID">
  <!-- =========================-->
  
<t>The FEC Payload ID is composed of the Source Block Number and the Encoding Symbol ID.
   The length of these two fields depends on the parameter m 
   (which is transmitted in the FEC OTI) as follows:</t>

<t>
<list style="symbols">
<t>The Source Block Number (field of size 32-m bits) identifies from which source block
   of the object the encoding symbol(s) in the payload is(are) generated.
   There is a maximum of 2^^(32-m) blocks per object.</t>

<t>The Encoding Symbol ID (field of size m bits) identifies which specific encoding
   symbol(s) generated from the source block is(are) carried in the packet payload.
   There is a maximum of 2^^m encoding symbols per block.
   The first k values (0 to k - 1) identify source symbols, the remaining n-k
   values identify repair symbols.</t>
</list>
</t>

<t>There MUST be exactly one FEC Payload ID per source or repair packet.
In case of an Encoding Symbol Group,
when multiple encoding symbols are sent in the same packet,
the FEC Payload ID refers to the first symbol of the packet.
The other symbols can be deduced from the ESI of the first symbol
by incrementing sequentially the ESI.
</t>

<figure anchor="fig_fec_payload_id_for_8" title="FEC Payload ID encoding format for m = 8 (default)"> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Source Block Number (32-8=24 bits)        | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>


<figure anchor="fig_fec_payload_id_for_16" title="FEC Payload ID encoding format for m = 16"> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Src Block Nb (32-16=16 bits)  |  Enc. Symbol ID (m=16 bits)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
The format of the FEC Payload ID for m = 8 and m = 16 is illustrated in 
<xref target="fig_fec_payload_id_for_8"/> and <xref target="fig_fec_payload_id_for_16"/>
respectively.</t>


  </section>

  <section title="FEC Object Transmission Information" anchor="FEC_OTI_EncID2">
  <!-- =============================================-->

    <section title="Mandatory Elements">
    <!-- ============================-->
   
<t>
<list style="symbols">
   <t>FEC Encoding ID:
   the Fully-Specified FEC Scheme described in this section uses FEC Encoding ID 2.
   </t>
</list>
</t>

    </section>

    <section title="Common Elements" anchor="common_elt_EncID2">
    <!-- =========================-->

<t> The following elements MUST be defined with the present FEC scheme:</t>

<t>
<list style="symbols">
   <t>Transfer-Length (L): a non-negative integer indicating the length of the
	object in bytes.
	There are some restrictions on the maximum Transfer-Length that
	can be supported:
	<list style="empty">
	<t>max_transfer_length = 2^^(32-m) * B * E</t>
	</list>
	For instance, for m = 8, for B = 2^^8 - 1 (because the codec operates on a
	finite field with  2^^8 elements) and if E = 1024 bytes,
	then the maximum transfer length is approximately equal to 2^^42 bytes
	(i.e., 4 Tera Bytes).

	Similarly, for m = 16, for B = 2^^16 - 1 and if E = 1024 bytes,
	then the maximum transfer length is also approximately equal to 2^^42 bytes.

	For larger objects, another FEC scheme, with a larger Source Block Number
	field in the FEC Payload ID, could be defined.
	Another solution consists in fragmenting large objects into smaller
	objects, each of them complying with the above limits.
	</t>

   <t>Encoding-Symbol-Length (E): a non-negative integer indicating the length
	of each encoding symbol in bytes.</t>

   <t>Maximum-Source-Block-Length (B): a non-negative integer indicating the
	maximum number of source symbols in a source block.</t>

   <t>Max-Number-of-Encoding-Symbols (max_n): a non-negative integer
	indicating the maximum number of encoding symbols generated for
	any source block.</t>
</list>
</t>

   <t><xref target="procedures"></xref> explains how to derive the values
      of each of these elements.</t>

    </section>

    <section title="Scheme-Specific Elements" anchor="scheme_specific_elt_EncID2">
    <!-- ==================================-->

<t> The following element MUST be defined with the present FEC Scheme.
It contains two distinct pieces of information:</t>

<t>
<list style="symbols">
    <t> G: a non-negative integer indicating the number of encoding symbols
	per group used for the object. The default value is 1, meaning that
	each packet contains exactly one symbol.
	When no G parameter is communicated to the decoder, then this latter
	MUST assume that G = 1.
    </t>

    <t> m:
         The m parameter is the length of the finite field elements, in
         bits. It also characterizes the number of elements in the finite field:
         q = 2^^m elements.
         The default value is m = 8.
         When no finite field size parameter is communicated to the
         decoder, then this latter MUST assume that m = 8.
    </t>

</list>
</t>

    </section>

    <section title="Encoding Format" anchor="FEC_OTI_encoding_format_EncID2">
    <!-- =========================-->
 
    <t>This section shows the two possible encoding formats of the above FEC OTI.
    The present document does not specify when one encoding
    format or the other should be used.</t>

        <section title="Using the General EXT_FTI Format">
        <!-- =========================-->

<t>
The FEC OTI binary format is the following, when the EXT_FTI mechanism
is used (e.g., within the ALC <xref target="draft-ietf-rmt-pi-alc-revised"/>
 or NORM <xref target="draft-ietf-rmt-pi-norm-revised"/> protocols).
</t>

    <figure title="EXT_FTI Header Format" anchor="fig:EXT_FTI_format_EncID2">
    <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   HET = 64    |    HEL = 4    |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                      Transfer-Length (L)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       m       |       G       |   Encoding Symbol Length (E)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Max Source Block Length (B)  |  Max Nb Enc. Symbols (max_n)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      </artwork>
    </figure>

        </section>

        <section title="Using the FDT Instance (FLUTE specific)">
        <!-- =========================-->

<t>When it is desired that the FEC OTI be carried in the FDT (File Delivery Table)
Instance of a FLUTE session <xref target="draft-ietf-rmt-flute-revised"/>,
the following XML attributes must be described 
for the associated object:
<list style="symbols">
	<t>FEC-OTI-FEC-Encoding-ID</t>
	<t>FEC-OTI-Transfer-Length (L)</t>
	<t>FEC-OTI-Encoding-Symbol-Length (E)</t>
	<t>FEC-OTI-Maximum-Source-Block-Length (B)</t>
	<t>FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)</t>
	<t>FEC-OTI-Scheme-Specific-Info</t>
</list>
The FEC-OTI-Scheme-Specific-Info contains the string resulting from
the Base64 encoding (in the XML Schema xs:base64Binary sense) of the
following value:
</t>

<figure anchor="fig_scheme_specific_EncID2"
	title="FEC OTI Scheme Specific Information to be included in the FDT Instance"> 
  <artwork>
 0                   1          
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                
|       m       |       G       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
When no m parameter is to be carried in the FEC OTI, the m field
is set to 0 (which is not a valid seed value).
Otherwise the m field contains a valid value as explained in
<xref target="scheme_specific_elt_EncID2"/>.
Similarly, when no G parameter is to be carried in the FEC OTI, the G field
is set to 0 (which is not a valid seed value).
Otherwise the G field contains a valid value as explained in
<xref target="scheme_specific_elt_EncID2"/>.
When neither m nor G are to be carried in the FEC OTI, then the
sender simply omits the FEC-OTI-Scheme-Specific-Info attribute.
</t>

<t>
After Base64 encoding, the 2 bytes of the FEC OTI Scheme Specific Information
are transformed into a string of 4 printable characters (in the 64-character
alphabet) and added to the FEC-OTI-Scheme-Specific-Info attribute.
</t>
        </section>

    </section>

  </section>

</section>


<section title="Formats and Codes with FEC Encoding ID 5">
<!-- ========================== -->

<t>This section introduces the formats and codes associated to the Fully-Specified FEC Scheme
with FEC Encoding ID 5 that focuses on the special case of Reed-Solomon codes over GF(2^^8)
and no encoding symbol group.</t>

  <section title="FEC Payload ID">
  <!-- =========================-->
  
<t>The FEC Payload ID is composed of the Source Block 
   Number and the Encoding Symbol ID:</t>

<t>
<list style="symbols">
<t>The Source Block Number (24 bit field) identifies from which source block
   of the object the encoding symbol in the payload is generated.
   There is a maximum of 2^^24 blocks per object.</t>

<t>The Encoding Symbol ID (8 bit field) identifies which specific encoding
   symbol generated from the source block is carried in the packet payload.
   There is a maximum of 2^^8 encoding symbols per block.
   The first k values (0 to k - 1) identify source symbols, the remaining n-k
   values identify repair symbols.</t>
</list>
</t>

<t>There MUST be exactly one FEC Payload ID per source or repair packet.
This FEC Payload ID refer to the one and only symbol of the packet.
</t>

<figure anchor="fig_fec_payload_id_EncID5" title="FEC Payload ID encoding format with FEC Encoding ID 5"> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Source Block Number (24 bits)          | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

  </section>

  <section title="FEC Object Transmission Information" anchor="FEC_OTI_EncID5">
  <!-- =============================================-->

    <section title="Mandatory Elements">
    <!-- ============================-->
   
<t>
<list style="symbols">
   <t>FEC Encoding ID:
   the Fully-Specified FEC Scheme described in this section uses FEC Encoding ID 5.
   </t>
</list>
</t>

    </section>

    <section title="Common Elements">
    <!-- =========================-->

<t> The Common Elements are the same as those specified in
<xref target="common_elt_EncID2"/> when m = 8 and G = 1.</t>

    </section>

    <section title="Scheme-Specific Elements" anchor="scheme_specific_elt">
    <!-- ==================================-->

<t>No Scheme-Specific elements are defined by this FEC Scheme.</t>

    </section>

    <section title="Encoding Format" anchor="FEC_OTI_encoding_format">
    <!-- =========================-->
    
    <t>This section shows the two possible encoding formats of the above FEC OTI.
    The present document does not specify when one encoding
    format or the other should be used.</t>
    
        <section title="Using the General EXT_FTI Format">
        <!-- =========================-->

<t>
The FEC OTI binary format is the following, when the EXT_FTI mechanism
is used (e.g., within the ALC <xref target="draft-ietf-rmt-pi-alc-revised"/>
 or NORM <xref target="draft-ietf-rmt-pi-norm-revised"/> protocols).
</t>

    <figure title="EXT_FTI Header Format with FEC Encoding ID 5" anchor="fig:EXT_FTI_format_EncID5">
    <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   HET = 64    |    HEL = 3    |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                      Transfer-Length (L)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  | MaxBlkLen (B) |     max_n     | 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      </artwork>
    </figure>

        </section>

        <section title="Using the FDT Instance (FLUTE specific)">
        <!-- =========================-->

<t>When it is desired that the FEC OTI be carried in the FDT Instance
of a FLUTE session <xref target="draft-ietf-rmt-flute-revised"/>,
the following XML attributes must be described 
for the associated object:
<list style="symbols">
	<t>FEC-OTI-FEC-Encoding-ID</t>
	<t>FEC-OTI-Transfer-Length (L)</t>
	<t>FEC-OTI-Encoding-Symbol-Length (E)</t>
	<t>FEC-OTI-Maximum-Source-Block-Length (B)</t>
	<t>FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)</t>
</list>
</t>

        </section>

    </section>

  </section>

</section>


<section title="Procedures with FEC Encoding IDs 2 and 5" anchor="procedures">
<!-- =================== -->

<t>This section defines procedures that are common to FEC Encoding IDs 2
   and 5. In case of FEC Encoding ID 5, m = 8 and G = 1.
   Note that the block partitioning algorithm is defined in <xref target="rfc5052_fecbb"/>.</t>


  <section title="Determining the Maximum Source Block Length (B)"
           anchor="max_source_block_length">
  <!-- ================ -->

<t>
The finite field size parameter, m, defines the number of non zero elements in
this field which is equal to: q - 1 = 2^^m - 1.
Note that q - 1 is also the theoretical maximum number of encoding symbols that can
be produced for a source block.
For instance, when m = 8 (default) there is a maximum of 2^^8 - 1 = 255 encoding symbols.
</t>

<t>
Given the target FEC code rate (e.g., provided by the user when
starting a FLUTE sending application), the sender calculates:
      <list style="empty">
	<t>max1_B = floor((2^^m - 1) * rate)</t>
      </list>
This max1_B value leaves enough room for the sender to produce the
desired number of parity symbols.
</t>

<t>Additionally, a codec MAY impose other limitations on the maximum block size. 
Yet it is not expected that such limits exist when using the default m = 8 value.
This decision MUST be clarified at implementation time, when the target
use case is known. This results in a max2_B limitation.</t>

<t>
Then, B is given by:
      <list style="empty">
	<t>B = min(max1_B, max2_B)</t>
      </list>
Note that this calculation is only required at the coder, since the
B parameter is communicated to the decoder through the FEC OTI.
</t>

  </section>



  <section title="Determining the Number of Encoding Symbols of a Block"
           anchor="n-algorithm">
  <!-- ================ -->

<t>The following algorithm, also called "n-algorithm", explains how to
determine the actual number of encoding symbols for a given block.</t>

<t> AT A SENDER: </t>

<t> Input:
<list style="empty">
<t>B:		Maximum source block length, for any source block.
		<xref target="max_source_block_length"/> explains how
		to determine its value.</t>

<t>k:		Current source block length. This parameter is given by the
		block partitioning algorithm.</t>

<t>rate:	FEC code rate, which is given by the user (e.g., when
		starting a FLUTE sending application).
		It is expressed as a floating point value.
               	</t>
</list>
</t>

<t>
Output:
<list style="empty">

<t>max_n:	Maximum number of encoding symbols generated for any
		source block.</t>

<t>n:		Number of encoding symbols generated for this source block.</t>
</list>
</t>

<t>
      Algorithm:
      <list style="empty">
	<t>max_n = ceil(B / rate);</t>
	<t>if (max_n &gt; 2^^m - 1) then return an error ("invalid code rate");</t>
	<t>n = floor(k * max_n / B);</t>
      </list>
</t>


<t>AT A RECEIVER: </t>

<t>Input:
<list style="empty">
<t>B:		Extracted from the received FEC OTI.</t>
<t>max_n:	Extracted from the received FEC OTI.</t>
<t>k:		Given by the block partitioning algorithm.</t>
</list>
</t>

<t>Output:
<list style="empty">
<t>n</t>
</list>
</t>

<t>
      Algorithm:
      <list style="empty">
      <t>n = floor(k * max_n / B);</t> 
      </list>
</t>

<t>
Note that a Reed-Solomon decoder does not need to know the n value.
Therefore the receiver part of the "n-algorithm" is not necessary from
the Reed-Solomon decoder point of view.
Yet a receiving application using the Reed-Solomon FEC scheme will sometimes
need to know the n value used by the sender, for instance for memory
management optimizations.
To that purpose, the FEC OTI carries all the parameters needed for a
receiver to execute the above algorithm.
</t>

  </section>

</section>


<section title="Small Block Systematic FEC Scheme (FEC Encoding ID 129) and Reed-Solomon Codes over GF(2^^8)"
anchor="EncID129_InstID0">
<!-- =================== -->

<t>In the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129)
<xref target="draft-ietf-rmt-bb-fec-basic-schemes-revised"/>, this document assigns the FEC Instance ID 0
to the special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group.</t>

<t>The FEC Instance ID 0 uses the Formats and Codes specified in
<xref target="draft-ietf-rmt-bb-fec-basic-schemes-revised"/>.</t>

<t>The FEC Scheme with FEC Instance ID 0 MAY use the algorithm defined in Section 9.1. of
<xref target="rfc5052_fecbb"/> to partition the file into source blocks.
This FEC Scheme MAY also use another algorithm.
For instance the CDP sender may change the length of each source block dynamically, depending on some
external criteria (e.g., to adjust the FEC coding rate to the current loss rate experienced by NORM receivers)
and inform the CDP receivers of the current block length by means of the EXT_FTI mechanism.
This choice is out of the scope of the current document.</t>

</section>


		<section anchor="Reed-SolomonCodes" title="Reed-Solomon Codes Specification for the Erasure Channel">
		<!-- =========================================== -->

<t>Reed-Solomon (RS) codes are linear block codes.
They also belong to the class of MDS codes.
A [n,k]-RS code encodes a sequence of k source elements defined over a finite field GF(q) into
a sequence of n encoding elements, where n is upper bounded by q - 1.
The implementation described in this document is based on a generator matrix built from a
Vandermonde matrix put into systematic form.</t>
<t>

<xref target="FiniteField"/> to <xref target="Decoding"/> specify the [n,k]-RS codes when applied
to m-bit elements, and <xref target="Implementation"/> the use of [n,k]-RS codes when applied to
symbols composed of several m-bit elements, which is the target of this specification.
</t>


			<section anchor="FiniteField" title="Finite Field">
			<!-- =========================================== -->

<t>A finite field GF(q) is defined as a finite set of q elements which has a structure of field. It contains necessarily q = p^^m
elements, where p is a prime number. With packet erasure channels, p is always set to 2. The elements of the field GF(2^^m) can be
represented by polynomials with binary coefficients (i.e., over GF(2)) of degree lower or equal than m-1. The polynomials can be associated to
binary vectors of length m. For example, the vector (11001) represents the polynomial 1 + x + x^^4. This representation is often
called polynomial representation. The addition between two elements is defined as the addition of binary polynomials in GF(2) and
the multiplication is the multiplication modulo a given irreducible polynomial over GF(2) of degree m 
with coefficients in GF(2). Note that all the roots of this  polynomial are in GF(2^^m) but not in GF(2).</t>

<t>A finite field GF(2^^m) is completely characterized by the irreducible polynomial.
The following polynomials are chosen to represent the field GF(2^^m), for m varying from 2 to 16:
<list style="empty">
	<t>m =  2, "111" (1+x+x^^2)</t>
	<t>m =  3, "1101", (1+x+x^^3)</t>
	<t>m =  4, "11001", (1+x+x^^4)</t>
	<t>m =  5, "101001", (1+x^^2+x^^5)</t>
	<t>m =  6, "1100001", (1+x+x^^6)</t>
	<t>m =  7, "10010001", (1+x^^3+x^^7)</t>
	<t>m =  8, "101110001", (1+x^^2+x^^3+x^^4+x^^8)</t>
	<t>m =  9, "1000100001", (1+x^^4+x^^9)</t>
	<t>m = 10, "10010000001", (1+x^^3+x^^10)</t>
	<t>m = 11, "101000000001", (1+x^^2+x^^11)</t>
	<t>m = 12, "1100101000001", (1+x+x^^4+x^^6+x^^12)</t>
	<t>m = 13, "11011000000001", (1+x+x^^3+x^^4+x^^13)</t>
	<t>m = 14, "110000100010001", (1+x+x^^6+x^^10+x^^14)</t>
	<t>m = 15, "1100000000000001", (1+x+x^^15)</t>
	<t>m = 16, "11010000000010001", (1+x+x^^3+x^^12+x^^16)</t>
</list>
In order to facilitate the implementation, these polynomials are also primitive. This means that any element
of GF(2^^m) can be expressed as a power of a given root of this polynomial.
These polynomials are also chosen so that they contain the minimum number of monomials.
</t>

			</section>

			<section anchor="Encoding" title="Reed-Solomon Encoding Algorithm">
			<!-- =========================================== -->

			<section anchor="EncodingPrinciples" title="Encoding Principles">
			<!-- =========================================== -->

<t>Let s = (s_0, ..., s_{k-1}) be a source vector of k elements over GF(2^^m).
Let e = (e_0, ..., e_{n-1}) be the corresponding encoding vector of n elements over GF(2^^m).
Being a linear code, encoding is performed by multiplying the source vector by a generator matrix, GM, of k rows and n columns
over GF(2^^m). Thus:
<list style="empty">
<t>	e = s * GM.</t>
</list>
The definition of the generator matrix completely characterizes the RS code.</t>

<t>Let us consider that: n = 2^^m - 1 and: 0 &lt; k &le; n.
Let us denote by alpha the root of the primitive polynomial of degree m chosen in the list of <xref target="FiniteField"/>
for the corresponding value of m.
Let us consider a Vandermonde matrix of k rows and n columns, denoted by V_{k,n}, and built as follows:
the {i, j} entry of V_{k,n} is v_{i,j} = alpha^^(i*j), where 0 &le; i &le; k - 1 and 0 &le; j &le; n - 1.
This matrix generates a MDS code.
However, this MDS code is not systematic, which is a problem for many networking applications.
To obtain a systematic matrix (and code), the simplest solution consists in considering the matrix V_{k,k}
formed by the first k columns of V_{k,n}, then to invert it and to multiply this inverse by V_{k,n}.
Clearly, the product V_{k,k}^^-1 * V_{k,n} contains the identity matrix I_k on its first k columns, meaning
that the first k encoding elements are equal to source elements. Besides the associated code keeps the MDS property.</t>

<t>Therefore, the generator matrix of the code considered in this document is:
<list style="empty">
<t>	GM = (V_{k,k}^^-1) * V_{k,n}</t>
</list>
</t>


<t>Note that, in practice, the [n,k]-RS code can be shortened to a [n',k]-RS code, where k &le; n' &lt; n,
by considering the sub-matrix formed by the n' first columns of GM.</t>
				</section>


				<section title="Encoding Complexity">
				<!-- =========================================== -->

<t>Encoding can be performed by first pre-computing GM and by multiplying the source vector (k
elements) by GM (k rows and n columns).
The complexity of the pre-computation of the generator matrix can be estimated as the complexity of
the multiplication of the inverse of a Vandermonde matrix by n-k vectors (i.e., the last n-k columns of V_{k,n}).
Since the complexity of the inverse of a k*k-Vandermonde matrix by a vector is O(k * log^^2(k)), the
generator matrix can be computed in 0((n-k)* k * log^^2(k)) operations.
When the generator matrix is pre-computed, the encoding needs k operations per repair element
(vector-matrix multiplication).
</t>

<t>Encoding can also be performed by first computing the product s * V_{k,k}^^-1 and then
by multiplying the result with V_{k,n}.
The multiplication by the inverse of a square Vandermonde matrix is known as the interpolation problem and
its complexity is O(k * log^^2 (k)).
The multiplication by a Vandermonde matrix, known as the multipoint evaluation problem, requires
O((n-k) * log(k)) by using Fast Fourier Transform, as explained in <xref target="GO94" />.
The total complexity of this encoding algorithm is then O((k/(n-k)) * log^^2(k) + log(k)) operations
per repair element.</t>

				</section>
			</section>


			<section anchor="Decoding" title="Reed-Solomon Decoding Algorithm">
			<!-- =========================================== -->

			<section anchor="DecodingPrinciples" title="Decoding Principles">
			<!-- =========================================== -->

<t>The Reed-Solomon decoding algorithm for the erasure channel allows the recovery of the k source elements from any set of k received
elements. It is based on the fundamental property of the generator matrix which is such that any k*k-submatrix is invertible (see <xref target="MWS77" />).
The first step of the decoding consists in extracting the k*k submatrix of the generator matrix obtained by considering the columns
corresponding to the received elements. Indeed, since any encoding element is obtained by multiplying the source vector by one column of
the generator matrix, the received vector of k encoding elements can be considered as the result of the multiplication of the source
vector by a k*k submatrix of the generator matrix. Since this submatrix is invertible, the second step of the algorithm is to invert
this matrix and to multiply the received vector by the obtained matrix to recover the source vector.</t>
				</section>

				<section title="Decoding Complexity">
				<!-- =========================================== -->

<t>The decoding algorithm described previously includes the matrix inversion and the vector-matrix multiplication. With the classical
Gauss-Jordan algorithm, the matrix inversion requires O(k^^3) operations and the vector-matrix multiplication is performed in O(k^^2)
operations.</t>

<t>This complexity can be improved by considering that the received submatrix of GM is the product between the inverse of a Vandermonde
matrix (V_(k,k)^^-1) and another Vandermonde matrix (denoted by V' which is a submatrix of V_(k,n)). The decoding can be done by
multiplying the received vector by V'^^-1 (interpolation problem with complexity O( k * log^^2(k)) ) then by V_{k,k} (multipoint
evaluation with complexity O(k * log(k))). The global decoding complexity is then O(log^^2(k)) operations per source element.</t>


				</section>
			</section>


			<section anchor="Implementation" title="Implementation for the Packet Erasure Channel">
			<!-- =========================================== -->



<t>In a packet erasure channel, each packet (and symbol(s) since packets contain G &ge; 1 symbols)
is either correctly received or erased.
The location of the erased symbols in the sequence of symbols MUST be known.
The following specification describes the use of Reed-Solomon codes for generating redundant symbols
from the k source symbols and for recovering the source symbols from any set of k received symbols.</t>

<t>The k source symbols of a source block are assumed to be composed of S m-bit elements.
Each m-bit element corresponds to an element of the finite field GF(2^^m) through the polynomial
representation (<xref target="FiniteField"/>).
If some of the source symbols contain less than S elements, they MUST be virtually padded with zero
elements (it can be the case for the last symbol of the last block of the object).
However, this padding does not need to be actually sent with the data to the receivers.
</t>

<t>The encoding process produces n encoding symbols of size S m-bit elements, of which k are source symbols
(this is a systematic code) and n-k are repair symbols (<xref target="encodingFigure"/>).
The m-bit elements of the repair symbols are calculated using the corresponding m-bit elements of the source symbol set.
A logical j-th source vector, comprised of the j-th elements from the set of source symbols,
is used to calculate a j-th encoding vector.
This j-th encoding vector then provides the j-th elements for the set encoding symbols calculated for the block.
As a systematic code, the first k encoding symbols are the same as the k source symbols and the last n-k repair
symbols are the result of the Reed-Solomon encoding. 
</t>

<figure anchor="encodingFigure" title="Packet encoding scheme">
<artwork><![CDATA[
       Input:  k source symbols

 0             j                                  S-1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |X|                                   | source symbol 0
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |X|                                   | source symbol 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             . . .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |X|                                   | source symbol k-1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               *

     +--------------------+
     |  generator matrix  |
     |         GM         |
     |       (k x n)      |
     +--------------------+

               |
               V

     Output: n encoding symbols (source + repair)

 0             j                                  S-1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |X|                                   | enc. symbol 0
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |X|                                   | enc. symbol 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             . . .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             |Y|                                   | enc. symbol n-1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
					</figure>

<t>An asset of this scheme is that the loss of some encoding symbols produces the same
erasure pattern for each of the S encoding vectors.
It follows that the matrix inversion must be done only once and will be used by all the
S encoding vectors.
For large S, this matrix inversion cost becomes negligible in front of the S matrix-vector
multiplications.</t>

<t>Another asset is that the n-k repair symbols can be produced on demand.
For instance, a sender can start by producing a limited number of repair symbols
and later on, depending on the observed erasures on the channel, decide to
produce additional repair symbols, up to the n-k upper limit.
Indeed, to produce the repair symbol e_j, where k &le; j &lt; n, it is sufficient
to multiply the S source vectors with column j of GM.
</t>

			</section>
		</section>

<section anchor="SecurityConsiderations" title="Security Considerations">
<!-- ==================================== -->

  <section title="Problem Statement">
  <!-- ================ -->

<t>
A content delivery system is potentially subject to many attacks:
some of them target the network (e.g., to compromise the routing infrastructure,
by compromising the congestion control component), others target
the Content Delivery Protocol (CDP) (e.g., to compromise its normal behavior),
and finally some attacks target the content itself.
Since this document focuses on a FEC building block independently of any
particular CDP (even if ALC and NORM are two natural candidates), this
section only discusses the additional threats that an arbitrary CDP may be exposed
to when using this building block.
</t>

<t>
More specifically, several kinds of attacks exist:
<list style="symbols">
	<t> those that are meant to give access to a confidential content (e.g., in
	  case of a non-free content),</t>
	<t> those that try to corrupt the object being transmitted (e.g., to
	  inject malicious code within an object, or to prevent a receiver
	  from using an object),</t>
	<t> and those that try to compromise the receiver's behavior (e.g., by
	  making the decoding of an object computationally expensive).</t>
</list>
These attacks can be launched either against the data flow itself (e.g.
by sending forged symbols) or against the FEC parameters that are
sent either in-band (e.g., in an EXT_FTI or FDT Instance) or out-of-band (e.g., in
a session description).
</t>

  </section>

  <section title="Attacks Against the Data Flow">
  <!-- ================ -->

<t>
First of all, let us consider the attacks against the data flow.
Access control is typically provided by means of encryption. This encryption
can be done over the whole object (e.g., by the content provider, before the
FEC encoding process), or be done on a packet per packet basis (e.g., when IPSec/ESP
is used <xref target="RFC4303_esp"/>).
If access control is a concern, it is RECOMMENDED that one of these solutions be used.
Even if we mention these attacks here, they are not related nor facilitated by
the use of FEC.
</t>

<t>
Protection against corruptions (forged packets) is achieved by means of a
content integrity verification/sender authentication scheme.
This service can be provided at the object level, but in that case a receiver
has no way to identify which symbol(s) is(are) corrupted if the object is detected
as corrupted. 
This service can also be provided at the packet level, and after having removed
all forged packets, the object can be recovered if the number of symbols remaining
is sufficient.
Several techniques can provide this source authentication/content integrity
service:
<list style="symbols">
<t> at the object level, the object MAY be digitally signed (with public key
  cryptography) (e.g., using RSASSA-PKCS1-v1_5 <xref target="RFC3447_pkcs1"/>).
  This signature enables a receiver to check the object, once this latter has
  been fully decoded. Even if digital signatures are computationally expensive,
  this calculation occurs only once per object, which is usually acceptable;</t>

<t> at the packet level, each packet can be digitally signed. A major limitation is
  the high computational and transmission overheads that this solution incurs (unless
  ECC is used, but ECC is protected by IPR). To avoid this problem, the signature
  may span a set of symbols in order to amortize the signature calculation, but
  if a single symbol is missing, the integrity of the whole set cannot be checked;</t>

<t> at the packet level, a Group Message Authentication Code (MAC) <xref target="rfc2104_hmac"/>
  (e.g., using HMAC-SHA-1 with a secret key shared by all the group members, senders and receivers)
  scheme can be used.
  This technique creates a cryptographically secured (thanks to the secret key)
  digest of a packet that is sent along with the packet.
  The Group MAC scheme  does not incur prohibitive processing load nor transmission
  overhead, but it has a major limitation: it only provides a group authentication/integrity
  service since all group members share the same secret group key, which means that each
  member can send a forged packet. It is therefore restricted to situations where
  group members are fully trusted (or in association with another technique as a
  pre-check);</t>

<t> at the packet level, TESLA <xref target="rfc4082_tesla_intro"/> is a very attractive
  and efficient solution that is robust to losses, provides a true authentication/integrity
  service, and does not incur any prohibitive processing load or transmission overhead.</t>
</list>
</t>

<t>
It is up to the developer, who knows the security requirements of the
target use-case, to define which solution is the most appropriate.
Nonetheless, it is RECOMMENDED that at least one of these techniques be used.
</t>

<t>
Techniques relying on public key cryptography (digital signatures and TESLA during
the bootstrap process) require that public keys be securely associated to the
entities. This can be achieved by a Public Key Infrastructure (PKI), or by a
PGP Web of Trust, or by pre-distributing the public keys of each group member.
It is up to the developer, who knows the features of the target use-case, to
define which solution to use.
</t>

<t>
Techniques relying on symmetric key cryptography (group MAC) require that a
secret key be shared by all group members. This can be achieved by means of a
group key management protocol, or simply by pre-distributing the secret key
(but this manual solution has many limitations).
Here also, it is up to the developer to define which solution to use, taking
into account the target use-case features.
</t>

  </section>

  <section title="Attacks against the FEC parameters">
  <!-- ================ -->

<t>
Let us now consider attacks against the FEC parameters (or FEC OTI).
The FEC OTI can either be sent in-band (i.e., in an EXT_FTI or in an FDT Instance
containing FEC OTI for the object) or out-of-band (e.g., in a session description).
Attacks on these FEC parameters can prevent the decoding of the associated object:
for instance modifying the B parameter will lead to a different block partitioning
at a receiver thereby compromising decoding; or setting the m parameter to 16 instead
of 8 with FEC Encoding ID 2 will increase the processing load while compromising decoding.
</t>

<t>
It is therefore RECOMMENDED that security measures be taken to guarantee the
FEC OTI integrity. To that purpose, the packets carrying the FEC parameters sent in-band
(i.e., in an EXT_FTI header extension or in an FDT Instance) may be protected by one of the
per-packet techniques described above: TESLA, digital signature, or a group MAC.
Alternatively, when FEC OTI is contained in an FDT Instance, this object may
be digitally signed.
Finally, when FEC OTI is sent out-of-band for instance in a session description,
this latter may be protected by a digital signature.
</t>

<t>
The same considerations concerning the key management aspects apply here also.
</t>

  </section>
</section>


			<section anchor="iana-cons" title="IANA Considerations">
			<!-- =============================================== -->
<t>
Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA registration.
For general guidelines on IANA considerations as they
apply to this document, see <xref target="rfc5052_fecbb" />.
</t>

<t>
This document assigns the Fully-Specified FEC Encoding ID 2 
under the "ietf:rmt:fec:encoding" name-space to "Reed-Solomon Codes over GF(2^^m)".
</t>

<t>
This document assigns the Fully-Specified FEC Encoding ID 5 
under the "ietf:rmt:fec:encoding" name-space to "Reed-Solomon Codes over GF(2^^8)".
</t>

<t>
This document assigns the FEC Instance ID 0 scoped by the Under-Specified FEC Encoding ID 129
to "Reed-Solomon Codes over GF(2^^8)".
More specifically, under the "ietf:rmt:fec:encoding:instance" sub-name-space that is scoped
by the "ietf:rmt:fec:encoding" called "Small Block Systematic FEC Codes", this document
assigns FEC Instance ID 0 to "Reed-Solomon Codes over GF(2^^8)".
</t>

			</section>

			<section anchor="Acknowledgments" title="Acknowledgments">
			<!-- =============================================== -->
				<t>
The authors want to thank Brian Adamson, Igor Slepchin, Stephen Kent, and Francis Dupont for
their valuable comments.
The authors also want to thank Luigi Rizzo for his comments and for the design of
the reference Reed-Solomon codec.
            </t>
			</section>
	</middle>
	<back>

		<references title="Normative References">
		<!-- ==================================== -->
			<reference anchor="rfc2119">
				<front>
					<title>Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials="S." surname="Bradner" fullname="Scott Bradner">
						<organization/>
					</author>
					<date year=""/>
				</front>
				<seriesInfo name="RFC" value="2119"/>
			</reference>

			<reference anchor="rfc5052_fecbb">
				<front>
					<title>Forward Error Correction (FEC) Building Block</title>
					<author initials="M." surname="Watson">
						<organization/>
					</author>
					<author initials='M.' surname='Luby'>
						<organization />
					</author>
					<author initials='L.' surname='Vicisano'>
						<organization />
					</author>
					<date month="August" year="2007"/>
				</front>
				<seriesInfo name="RFC" value="5052"/>
			</reference>

			<reference anchor="draft-ietf-rmt-bb-fec-basic-schemes-revised">
				<front>
					<title>Basic Forward Error Correction (FEC) Schemes</title>
					<author initials="M." surname="Watson">
						<organization/>
					</author>
					<date month="February" year="2007"/>
				</front>
				<seriesInfo name="" value="draft-ietf-rmt-bb-fec-basic-schemes-revised-03.txt (work in progress)"/>
			</reference>

		</references>

		<references title="Informative References">
		<!-- ==================================== -->

			<reference anchor="rfc3453">
				<front>
					<title>The Use of Forward Error Correction (FEC) in Reliable Multicast</title>
					<author initials="M." surname="Luby" fullname="M. Luby"> <organization/> </author>
					<author initials="L." surname="Vicisano" fullname="L. Vicisano"> <organization/> </author>
						<author initials="J." surname="Gemmell" fullname="J. Gemmell"> <organization/> </author>
						<author initials="L." surname="Rizzo" fullname="L. Rizzo"> <organization/> </author>
						<author initials="M." surname="Handley" fullname="M. Handley"> <organization/> </author>
						<author initials="J." surname="Crowcroft" fullname="J. Crowcroft"> <organization/> </author>
					<date month="December" year="2002"/>
				</front>
				<seriesInfo name="RFC" value="3453"/>
			</reference>

			<reference anchor="RS-codec">
				<front>
					<title>Reed-Solomon FEC codec (revised version of July 2nd, 1998), available at
http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz and mirrored at http://planete-bcast.inrialpes.fr/</title>
					<author initials="L." surname="Rizzo" fullname="Luigi Rizzo">
						<organization/>
					</author>
					<date month="July" year="1998"/>
				</front>
			</reference>

			<reference anchor="MWS77">
				<front>
					<title>The Theory of Error Correcting Codes</title>
					<author initials="F. J." surname="Mac Williams" fullname="F. J. Mac Williams">
						<organization/>
					</author>
					<author initials="N. J. A." surname="Sloane" fullname="N. J. A. Sloane">
						<organization/>
					</author>
					<date year=""/>
				</front>
				<seriesInfo name="North Holland," value="1977"/>
			</reference>

			<reference anchor="GO94">
				<front>
					<title>Fast algorithms with preprocessing for matrix-vector multiplication problems</title>
					<author initials="I." surname="Gohberg" fullname="Israel Gohberg">
						<organization/>
					</author>
					<author initials="V." surname="Olshevsky" fullname="Vadim Olshevsky">
						<organization/>
					</author><date year=""/>
				</front>
				<seriesInfo name="Journal of Complexity," value="pp. 411-427, vol. 10, 1994"/>
			</reference>

			<reference anchor="draft-ietf-rmt-bb-fec-ldpc">
				<front>
					<title>Low Density Parity Check (LDPC) Forward Error Correction</title>
					<author initials="V." surname="Roca">
						<organization/>
					</author>
					<author initials="C." surname="Neumann">
						<organization />
					</author>
					<author initials="D." surname="Furodet">
						<organization />
					</author>
					<date month="May" year="2007"/>
				</front>
				<seriesInfo name="" value="draft-ietf-rmt-bb-fec-ldpc-06.txt (work in progress)"/>
			</reference>

			<reference anchor="draft-ietf-rmt-bb-fec-raptor-object">
				<front>
					<title>Raptor Forward Error Correction Scheme</title>
					<author initials="M." surname="Luby" fullname="M. Luby">
						<organization/>
					</author>
					<author initials="A" surname="Shokrollahi" fullname="A. Shokrollahi">
						<organization/>
					</author>
					<author initials="M" surname="Watson" fullname="M.  Watson">
						<organization/>
					</author>
					<author initials="T" surname="Stockhammer" fullname="T. Stockhammer">
						<organization/>
					</author>
					<date month="June" year="2007"/>
				</front>
				<seriesInfo name="" value="draft-ietf-rmt-bb-fec-raptor-object-09 (work in progress)"/>
			</reference>

			<reference anchor="draft-ietf-rmt-pi-alc-revised">
				<front>
					<title>Asynchronous Layered Coding (ALC) Protocol Instantiation</title>
					<author initials='M.' surname='Luby'>
						<organization />
					</author>
					<author initials="M." surname="Watson">
						<organization/>
					</author>
					<author initials='L.' surname='Vicisano'>
						<organization />
					</author>
					<date month="February" year="2007"/>
				</front>
				<seriesInfo name="" value="draft-ietf-rmt-pi-alc-revised-04.txt (work in progress)"/>
			</reference>

			<reference anchor="draft-ietf-rmt-pi-norm-revised">
				<front>
					<title>Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol</title>
					<author initials='B.' surname='Adamson'>
						<organization />
					</author>
					<author initials="C." surname="Bormann">
						<organization/>
					</author>
					<author initials='M.' surname='Handley'>
						<organization />
					</author>
					<author initials='J.' surname='Macker'>
						<organization />
					</author>
					<date month="March" year="2007"/>
				</front>
				<seriesInfo name="" value="draft-ietf-rmt-pi-norm-revised-05.txt (work in progress)"/>
			</reference>

			<reference anchor="draft-ietf-rmt-flute-revised">
				<front>
					<title>FLUTE - File Delivery over Unidirectional Transport</title>
					<author initials='T.' surname='Paila'>
						<organization />
					</author>
					<author initials="R." surname="Walsh">
						<organization/>
					</author>
					<author initials='M.' surname='Luby'>
						<organization />
					</author>
					<author initials='R.' surname='Lehtonen'>
						<organization />
					</author>
					<author initials='V.' surname='Roca'>
						<organization />
					</author>
					<date month="October" year="2007"/>
				</front>
				<seriesInfo name="" value="draft-ietf-rmt-flute-revised-04.txt (work in progress)"/>
			</reference>

			<reference anchor="RFC3447_pkcs1">
				<front>
					<title>Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</title>
					<author initials="J." surname="Jonsson" fullname="J. Jonsson"> <organization/> </author>
					<author initials="B." surname="Kaliski" fullname="B. Kaliski"> <organization/> </author>
					<date year="2003" month="February"/>
				</front>
				<seriesInfo name="RFC" value="3447"/>
				<format type="TXT" octets="143173" target="ftp://ftp.isi.edu/in-notes/rfc3447.txt"/>
			</reference>

			<reference anchor="RFC4303_esp">
				<front>
					<title>IP Encapsulating Security Payload (ESP)</title>
					<author initials="S." surname="Kent" fullname="S. Kent"> <organization/> </author>
					<date year="2005" month="December"/>
				</front>
				<seriesInfo name="RFC" value="4303"/>
				<format type="TXT" octets="114315" target="ftp://ftp.isi.edu/in-notes/rfc4303.txt"/>
			</reference>

			<reference anchor="rfc2104_hmac">
				<front>
					<title>HMAC: Keyed-Hashing for Message Authentication</title>
					<author fullname="H. Krawczyk"> <organization/> </author>
					<author fullname="M. Bellare"> <organization/> </author>
					<author fullname="R. Canetti"> <organization/> </author>
					<date month="February" year="1997"/>
				</front>
				<seriesInfo name="RFC" value="2104"/>
			</reference>

			<reference anchor="rfc4082_tesla_intro">
				<front>
					<title>Timed Efficient Stream Loss-Tolerant Authentication (TESLA):
						Multicast Source Authentication Transform Introduction</title>
					<author fullname="A. Perrig"> <organization/> </author>
					<author fullname="D. Song"> <organization/> </author>
					<author fullname="R. Canetti"> <organization/> </author>
					<author fullname="J.D. Tygar"> <organization/> </author>
					<author fullname="B. Briscoe"> <organization/> </author>
					<date month="June" year="2005"/>
				</front>
				<seriesInfo name="RFC" value="4082"/>
			</reference>

		</references>
	</back>
</rfc>
