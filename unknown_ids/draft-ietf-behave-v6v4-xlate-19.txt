

behave                                                             X. Li
Internet-Draft                                                    C. Bao
Obsoletes: 2765 (if approved)          CERNET Center/Tsinghua University
Intended status: Standards Track                                F. Baker
Expires: October 19, 2010                                  Cisco Systems
                                                          April 17, 2010


                     IP/ICMP Translation Algorithm
                    draft-ietf-behave-v6v4-xlate-19

Abstract

   This document forms a replacement of the Stateless IP/ICMP
   Translation Algorithm (SIIT) described in RFC 2765.  The algorithm
   translates between IPv4 and IPv6 packet headers (including ICMP
   headers).

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on October 19, 2010.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as



Li, et al.              Expires October 19, 2010                [Page 1]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.


Table of Contents

   1.  Introduction and Motivation  . . . . . . . . . . . . . . . . .  3
     1.1.  IPv4-IPv6 Translation Model  . . . . . . . . . . . . . . .  3
     1.2.  Applicability and Limitations  . . . . . . . . . . . . . .  3
     1.3.  Stateless vs. Stateful Mode  . . . . . . . . . . . . . . .  4
     1.4.  Path MTU Discovery and Fragmentation . . . . . . . . . . .  5
   2.  Conventions  . . . . . . . . . . . . . . . . . . . . . . . . .  5
   3.  Translating from IPv4 to IPv6  . . . . . . . . . . . . . . . .  5
     3.1.  Translating IPv4 Headers into IPv6 Headers . . . . . . . .  7
     3.2.  Translating ICMPv4 Headers into ICMPv6 Headers . . . . . .  9
     3.3.  Translating ICMPv4 Error Messages into ICMPv6  . . . . . . 13
     3.4.  Translator Sending ICMPv4 Error Message  . . . . . . . . . 14
     3.5.  Transport-layer Header Translation . . . . . . . . . . . . 14
     3.6.  Knowing When to Translate  . . . . . . . . . . . . . . . . 14
   4.  Translating from IPv6 to IPv4  . . . . . . . . . . . . . . . . 15
     4.1.  Translating IPv6 Headers into IPv4 Headers . . . . . . . . 17
     4.2.  Translating ICMPv6 Headers into ICMPv4 Headers . . . . . . 20
     4.3.  Translating ICMPv6 Error Messages into ICMPv4  . . . . . . 22
     4.4.  Translator Sending ICMPv6 Error Message  . . . . . . . . . 23
     4.5.  Transport-layer Header Translation . . . . . . . . . . . . 23
     4.6.  Knowing When to Translate  . . . . . . . . . . . . . . . . 24
   5.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 24
   6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 24
   7.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 25
   8.  Appendix: Stateless translation workflow example . . . . . . . 25
     8.1.  H6 establishes communication with H4 . . . . . . . . . . . 26
     8.2.  H4 establishes communication with H6 . . . . . . . . . . . 27
   9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 28
     9.1.  Normative References . . . . . . . . . . . . . . . . . . . 28
     9.2.  Informative References . . . . . . . . . . . . . . . . . . 29
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 30




Li, et al.              Expires October 19, 2010                [Page 2]

Internet-Draft            IPv4/IPv6 Translation               April 2010


1.  Introduction and Motivation

   This document is a product of the 2008-2010 effort to define a
   replacement for NAT-PT [RFC2766].  It is directly derivative from
   Erik Nordmark's "Stateless IP/ICMP Translation Algorithm (SIIT)"
   [RFC2765], which provides stateless translation between IPv4
   [RFC0791] and IPv6 [RFC2460], and between ICMPv4 [RFC0792] and ICMPv6
   [RFC4443].

   Readers of this document are expected to have read and understood the
   framework described in [I-D.ietf-behave-v6v4-framework].
   Implementations of this IPv4/IPv6 translation specification MUST also
   support the address translation algorithms in
   [I-D.ietf-behave-address-format].  Implementations MAY also support
   stateful translation [I-D.ietf-behave-v6v4-xlate-stateful].

1.1.  IPv4-IPv6 Translation Model

   The translation model consists of two or more network domains
   connected by one or more IP/ICMP translators (XLATs) as shown in
   Figure 1.


                ---------          ---------
              //        \\       //         \\
            /             +----+              \
           |              |XLAT|               | XLAT: IPv6/IPv4
           |   IPv4       +----+   IPv6        |       Translator
           |   Domain     |    |   Domain      |
           |              |    |               |
            \             |    |              /
             \\         //      \\          //
                --------          ---------


                   Figure 1: IPv4-IPv6 Translation Model

   The scenarios of the translation model are discussed in
   [I-D.ietf-behave-v6v4-framework].

1.2.  Applicability and Limitations

   This document specifies the translation algorithms between IPv4
   packets and IPv6 packets.

   As with [RFC2765], the translating function specified in this
   document does not translate any IPv4 options and it does not
   translate IPv6 extension headers except fragmentation header.



Li, et al.              Expires October 19, 2010                [Page 3]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   The issues and algorithms in the translation of datagrams containing
   TCP segments are described in [RFC5382].

   Fragmented IPv4 UDP packets that do not contain a UDP checksum (i.e.,
   the UDP checksum field is zero) are not of significant use in the
   Internet and will not be translated by the IP/ICMP translator.

   Fragmented ICMP/ICMPv6 packets will not be translated by the IP/ICMP
   translator.

   The IP/ICMP header translation specified in this document is
   consistent with requirements of multicast IP/ICMP headers.  However
   IPv4 multicast addresses [RFC5771] cannot be mapped to IPv6 multicast
   addresses [RFC3307] based on the unicast mapping rule
   [I-D.ietf-behave-address-format].

   Translator SHOULD make sure that the packets belonging to the same
   flow leave the translator in the same order in which they arrived.

1.3.  Stateless vs. Stateful Mode

   An IP/ICMP translator has two possible modes of operation: stateless
   and stateful [I-D.ietf-behave-v6v4-framework].  In both cases, we
   assume that a system (a node or an application) that has an IPv4
   address but not an IPv6 address is communicating with a system that
   has an IPv6 address but no IPv4 address, or that the two systems do
   not have contiguous routing connectivity and hence are forced to have
   their communications translated.

   In the stateless mode, a specific IPv6 address range will represent
   IPv4 systems (IPv4-converted addresses), and the IPv6 systems have
   addresses (IPv4-translatable addresses) that can be algorithmically
   mapped to a subset of the service provider's IPv4 addresses.  Note
   that IPv4-translatable addresses is a subset of IPv4-converted
   addresses.  In general, there is no need to concern oneself with
   translation tables, as the IPv4 and IPv6 counterparts are
   algorithmically related.

   In the stateful mode, a specific IPv6 address range will represent
   IPv4 systems (IPv4-converted addresses), but the IPv6 systems may use
   any IPv6 addresses [RFC4291] except in that range.  In this case, a
   translation table is required to bind the IPv6 systems' addresses to
   the IPv4 addresses maintained in the translator.

   The address translation mechanisms for the stateless and the stateful
   translations are defined in [I-D.ietf-behave-address-format].





Li, et al.              Expires October 19, 2010                [Page 4]

Internet-Draft            IPv4/IPv6 Translation               April 2010


1.4.  Path MTU Discovery and Fragmentation

   Due to the different sizes of the IPv4 and IPv6 header, which are 20+
   octets and 40 octets respectively, handling the maximum packet size
   is critical for the operation of the IPv4/IPv6 translator.  There are
   three mechanisms to handle this issue: path MTU discovery (PMTUD),
   fragmentation, and transport-layer negotiation such as the TCP MSS
   option [RFC0879].  Note that the translator MUST behave as a router,
   i.e. the translator MUST send a "Packet Too Big" error message or
   fragment the packet when the packet size exceeds the MTU of the next
   hop interface.

   "Don't Fragment", ICMP "Packet Too Big", and packet fragmentation are
   discussed in sections 3 and 4 of this document.  The reassembling of
   fragmented packets in the stateful translator is discussed in
   [I-D.ietf-behave-v6v4-xlate-stateful], since it requires state
   maintenance in the translator.


2.  Conventions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].


3.  Translating from IPv4 to IPv6

   When an IP/ICMP translator receives an IPv4 datagram addressed to a
   destination towards the IPv6 domain, it translates the IPv4 header of
   that packet into an IPv6 header.  The original IPv4 header on the
   packet is removed and replaced by an IPv6 header.  Since the ICMPv6
   [RFC4443], TCP [RFC0793], UDP [RFC0768] and DCCP [RFC4340] headers
   contain checksums that cover IP header information, if the address
   mapping algorithm is not checksum-neutral, the checksum MUST be
   evaluated before translation and the ICMPv6 and transport-layer
   headers MUST be updated.  The data portion of the packet is left
   unchanged.  The IP/ICMP translator then forwards the packet based on
   the IPv6 destination address.












Li, et al.              Expires October 19, 2010                [Page 5]

Internet-Draft            IPv4/IPv6 Translation               April 2010


              +-------------+                 +-------------+
              |    IPv4     |                 |    IPv6     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |  Transport  |                 |  Fragment   |
              |   Layer     |      ===>       |   Header    |
              |   Header    |                 | (if needed) |
              +-------------+                 +-------------+
              |             |                 |  Transport  |
              ~    Data     ~                 |   Layer     |
              |             |                 |   Header    |
              +-------------+                 +-------------+
                                              |             |
                                              ~    Data     ~
                                              |             |
                                              +-------------+

                    Figure 2: IPv4-to-IPv6 Translation

   Path MTU discovery is mandatory in IPv6 but it is optional in IPv4.
   IPv6 routers never fragment a packet - only the sender can do
   fragmentation.

   When an IPv4 node performs path MTU discovery (by setting the Don't
   Fragment (DF) bit in the header), path MTU discovery can operate end-
   to-end, i.e., across the translator.  In this case either IPv4 or
   IPv6 routers (including the translator) might send back ICMP "Packet
   Too Big" messages to the sender.  When the IPv6 routers send these
   ICMPv6 errors they will pass through a translator that will translate
   the ICMPv6 error to a form that the IPv4 sender can understand.  As a
   result, an IPv6 fragment header is only included if the IPv4 packet
   is already fragmented.

   However, when the IPv4 sender does not set the Don't Fragment (DF)
   bit, the translator MUST ensure that the packet does not exceed the
   path MTU on the IPv6 side.  This is done by fragmenting the IPv4
   packet so that it fits in 1280-byte IPv6 packets, since that is the
   minimum IPv6 MTU.  Also, when the IPv4 sender does not set the DF bit
   the translator MUST always include an IPv6 fragment header to
   indicate that the sender allows fragmentation.

   The rules in section 3.1 ensure that when packets are fragmented,
   either by the sender or by IPv4 routers, the low-order 16 bits of the
   fragment identification are carried end-to-end, ensuring that packets
   are correctly reassembled.  In addition, the rules in section 3.1 use
   the presence of an IPv6 fragment header to indicate that the sender
   might not be using path MTU discovery (i.e., the packet should not
   have the DF flag set should it later be translated back to IPv4).



Li, et al.              Expires October 19, 2010                [Page 6]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   Other than the special rules for handling fragments and path MTU
   discovery, the actual translation of the packet header consists of a
   simple translation as defined below.  Note that ICMPv4 packets
   require special handling in order to translate the content of ICMPv4
   error messages and also to add the ICMPv6 pseudo-header checksum.

3.1.  Translating IPv4 Headers into IPv6 Headers

   If the DF flag is not set and the IPv4 packet will result in an IPv6
   packet larger than 1280 bytes, the packet MUST be fragmented so the
   resulting IPv6 packet (with Fragment header added to each fragment)
   will be less than or equal to 1280 bytes.  For example, if the packet
   is fragmented prior to the translation, the IPv4 packets must be
   fragmented so that their length, excluding the IPv4 header, is at
   most 1232 bytes (1280 minus 40 for the IPv6 header and 8 for the
   Fragment header).  The resulting fragments are then translated
   independently using the logic described below.

   If the DF bit is set and the MTU of the next-hop interface is less
   than the total length value of the IPv4 packet plus 20, the
   translator MUST send an ICMPv4 "Fragmentation Needed" error message
   to the IPv4 source address.

   If the DF bit is set and the packet is not a fragment (i.e., the MF
   flag is not set and the Fragment Offset is equal to zero) then the
   translator SHOULD NOT add a Fragment header to the resulting packet.
   The IPv6 header fields are set as follows:

   Version:  6

   Traffic Class:  By default, copied from IP Type Of Service (TOS)
      octet.  According to [RFC2474] the semantics of the bits are
      identical in IPv4 and IPv6.  However, in some IPv4 environments
      these fields might be used with the old semantics of "Type Of
      Service and Precedence".  An implementation of a translator SHOULD
      support an administratively-configurable option to ignore the IPv4
      TOS and always set the IPv6 traffic class (TC) to zero.  In
      addition, if the translator is at an administrative boundary, the
      filtering and update considerations of [RFC2475] may be
      applicable.

   Flow Label:  0 (all zero bits)

   Payload Length:  Total length value from IPv4 header, minus the size
      of the IPv4 header and IPv4 options, if present.






Li, et al.              Expires October 19, 2010                [Page 7]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   Next Header:  For ICMPv4 (1) changed to ICMPv6 (58), otherwise
      protocol field MUST be copied from IPv4 header.

   Hop Limit:  The hop limit is derived from the TTL value in the IPv4
      header.  Since the translator is a router, as part of forwarding
      the packet it needs to decrement either the IPv4 TTL (before the
      translation) or the IPv6 Hop Limit (after the translation).  As
      part of decrementing the TTL or Hop Limit the translator (as any
      router) MUST check for zero and send the ICMPv4 "TTL Exceeded" or
      ICMPv6 "Hop Limit Exceeded" error.

   Source Address:  The IPv4-converted address derived from the IPv4
      source address per [I-D.ietf-behave-address-format] section 2.1.

      If the translator gets an illegal source address (e.g. 0.0.0.0,
      127.0.0.1, etc.), the translator SHOULD silently drop the packet
      (as discussed in Section 5.3.7 of [RFC1812]).


   Destination Address:  In the stateless mode, which is to say that if
      the IPv4 destination address is within a range of configured IPv4
      stateless translation prefix, the IPv6 destination address is the
      IPv4-translatable address derived from the IPv4 destination
      address per [I-D.ietf-behave-address-format] section 2.1.  A
      workflow example of stateless translation is shown in the Appendix
      of this document.

      In the stateful mode, which is to say that if the IPv4 destination
      address is not within the range of any configured IPv4 stateless
      translation prefix, the IPv6 destination address and corresponding
      transport-layer destination port are derived from the Binding
      Information Bases (BIBs) reflecting current session state in the
      translator as described in [I-D.ietf-behave-v6v4-xlate-stateful].


   If any IPv4 options are present in the IPv4 packet, the IPv4 options
   MUST be ignored and the packet translated normally; there is no
   attempt to translate the options.  However, if an unexpired source
   route option is present then the packet MUST instead be discarded,
   and an ICMPv4 "Destination Unreachable/Source Route Failed" (Type
   3/Code 5) error message SHOULD be returned to the sender.

   If there is a need to add a Fragment header (the DF bit is not set or
   the packet is a fragment) the header fields are set as above with the
   following exceptions:






Li, et al.              Expires October 19, 2010                [Page 8]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   IPv6 fields:

      Payload Length:  Total length value from IPv4 header, plus 8 for
         the fragment header, minus the size of the IPv4 header and IPv4
         options, if present.

      Next Header:  Fragment header (44).

   Fragment header fields:

      Next Header:  For ICMPv4 (1) changed to ICMPv6 (58), otherwise
         protocol field MUST be copied from IPv4 header.

      Fragment Offset:  Fragment Offset copied from the IPv4 header.

      M flag:  More Fragments bit copied from the IPv4 header.

      Identification:  The low-order 16 bits copied from the
         Identification field in the IPv4 header.  The high-order 16
         bits set to zero.

3.2.  Translating ICMPv4 Headers into ICMPv6 Headers

   All ICMPv4 messages that are to be translated require that the ICMPv6
   checksum field be calculated as part of the translation since ICMPv6,
   unlike ICMPv4, has a pseudo-header checksum just like UDP and TCP.

   In addition, all ICMPv4 packets MUST have the Type value translated
   and, for ICMPv4 error messages, the included IP header also MUST be
   translated.

   The actions needed to translate various ICMPv4 messages are as
   follows:

   ICMPv4 query messages:

      Echo and Echo Reply (Type 8 and Type 0):  Adjust the Type values
         to 128 and 129, respectively, and adjust the ICMP checksum both
         to take the type change into account and to include the ICMPv6
         pseudo-header.

      Information Request/Reply (Type 15 and Type 16):  Obsoleted in
         ICMPv6.  Silently drop.

      Timestamp and Timestamp Reply (Type 13 and Type 14):  Obsoleted in
         ICMPv6.  Silently drop.





Li, et al.              Expires October 19, 2010                [Page 9]

Internet-Draft            IPv4/IPv6 Translation               April 2010


      Address Mask Request/Reply (Type 17 and Type 18):  Obsoleted in
         ICMPv6.  Silently drop.

      ICMP Router Advertisement (Type 9):  Single hop message.  Silently
         drop.

      ICMP Router Solicitation (Type 10):  Single hop message.  Silently
         drop.

      Unknown ICMPv4 types:  Silently drop.

      IGMP messages:  While the MLD messages [RFC2710][RFC3590][RFC3810]
         are the logical IPv6 counterparts for the IPv4 IGMP messages
         all the "normal" IGMP messages are single-hop messages and
         SHOULD be silently dropped by the translator.  Other IGMP
         messages might be used by multicast routing protocols and,
         since it would be a configuration error to try to have router
         adjacencies across IP/ICMP translators those packets SHOULD
         also be silently dropped.

       ICMPv4 error messages:

         Destination Unreachable (Type 3):  Translate the Code field as
            described below, set the Type field to 1, and adjust the
            ICMP checksum both to take the type/code change into account
            and to include the ICMPv6 pseudo-header.

            Translate the Code field as follows:

            Code 0, 1 (Net, host unreachable):  Set Code value to 0 (no
               route to destination).

            Code 2 (Protocol unreachable):  Translate to an ICMPv6
               Parameter Problem (Type 4, Code value 1) and make the
               Pointer point to the IPv6 Next Header field.

            Code 3 (Port unreachable):  Set Code value to 4 (port
               unreachable).

            Code 4 (Fragmentation needed and DF set):  Translate to an
               ICMPv6 Packet Too Big message (Type 2) with Code value
               set to 0.  The MTU field MUST be adjusted for the
               difference between the IPv4 and IPv6 header sizes, i.e.
               minimum(advertised MTU+20, MTU_of_IPv6_nexthop,
               (MTU_of_IPv4_nexthop)+20).  Note that if the IPv4 router
               set the MTU field to zero, i.e., the router does not
               implement [RFC1191], then the translator MUST use the
               plateau values specified in [RFC1191] to determine a



Li, et al.              Expires October 19, 2010               [Page 10]

Internet-Draft            IPv4/IPv6 Translation               April 2010


               likely path MTU and include that path MTU in the ICMPv6
               packet.  (Use the greatest plateau value that is less
               than the returned Total Length field.)  In order to avoid
               back holes caused by ICMPv4 filtering or non [RFC2460]
               compatible IPv6 hosts (a workaround discussed in Section
               4), the translator MAY set the MTU to 1280 for any MTU
               values which are smaller than 1280.  The translator
               SHOULD provide a method for operators to enable or
               disable this function.

            Code 5 (Source route failed):  Set Code value to 0 (No route
               to destination).  Note that this error is unlikely since
               source routes are not translated.

            Code 6, 7, 8:  Set Code value to 0 (No route to
               destination).

            Code 9, 10 (Communication with destination host
            administratively prohibited):  Set Code value to 1
               (Communication with destination administratively
               prohibited)

            Code 11, 12:  Set Code value to 0 (no route to destination).

            Code 13 (Communication Administratively Prohibited):  Set
               Code value to 1 (Communication with destination
               administratively prohibited).

            Code 14 (Host Precedence Violation):  Silently drop.

            Code 15 (Precedence cutoff in effect):  Set Code value to 1
               (Communication with destination administratively
               prohibited).

            Other Code values:  Silently drop.

         Redirect (Type 5):  Single hop message.  Silently drop.

         Alternative Host Address (Type 6):  Silently drop.

         Source Quench (Type 4):  Obsoleted in ICMPv6.  Silently drop.

         Time Exceeded (Type 11):  Set the Type field to 3, and adjust
            the ICMP checksum both to take the type change into account
            and to include the ICMPv6 pseudo-header.  The Code field is
            unchanged.





Li, et al.              Expires October 19, 2010               [Page 11]

Internet-Draft            IPv4/IPv6 Translation               April 2010


         Parameter Problem (Type 12):  Set the Type field to 4, and
            adjust the ICMP checksum both to take the type/code change
            into account and to include the ICMPv6 pseudo-header.

            Translate the Code field as follows:

            Code 0 (Pointer indicates the error):  Set the Code value to
               0 (Erroneous header field encountered) and update the
               pointer as defined in Figure 3 (If the Original IPv4
               Pointer Value is not listed or the Translated IPv6
               Pointer Value is listed as "n/a", silently drop the
               packet).

            Code 1 (Missing a required option):  Silently drop

            Code 2 (Bad length):  Set the Code value to 0 (Erroneous
               header field encountered) and update the pointer as
               defined in Figure 3 (If the Original IPv4 Pointer Value
               is not listed or the Translated IPv6 Pointer Value is
               listed as "n/a", silently drop the packet).

            Other Code values:  Silently drop

         Unknown ICMPv4 types:  Silently drop.




     |   Original IPv4 Pointer Value  | Translated IPv6 Pointer Value  |
     +--------------------------------+--------------------------------+
     |  0  | Version/IHL              |  0  | Version/Traffic Class    |
     |  1  | Type Of Service          |  1  | Traffic Class/Flow Label |
     | 2,3 | Total Length             |  4  | Payload Length           |
     | 4,5 | Identification           | n/a |                          |
     |  6  | Flags/Fragment Offset    | n/a |                          |
     |  7  | Fragment Offset          | n/a |                          |
     |  8  | Time to Live             |  7  | Hop Limit                |
     |  9  | Protocol                 |  6  | Next Header              |
     |10,11| Header Checksum          | n/a |                          |
     |12-15| Source Address           |  8  | Source Address           |
     |16-19| Destination Address      | 24  | Destination Address      |
     +--------------------------------+--------------------------------+

             Figure 3: Pointer value for translating from IPv4 to IPv6







Li, et al.              Expires October 19, 2010               [Page 12]

Internet-Draft            IPv4/IPv6 Translation               April 2010


         ICMP Error Payload:  If the received ICMPv4 packet contains an
            ICMPv4 Extension [RFC4884], the translation of the ICMPv4
            packet will cause the ICMPv6 packet to change length.  When
            this occurs, the ICMPv6 Extension length attribute MUST be
            adjusted accordingly (e.g., longer due to the translation
            from IPv4 to IPv6).  If the ICMPv4 Extension exceeds the
            maximum size of an ICMPv6 message on the outgoing interface,
            the ICMPv4 extension SHOULD be simply truncated.  For
            extensions not defined in [RFC4884], the translator passes
            the extensions as opaque bit strings and those containing
            IPv4 address literals will not have those addresses
            translated to IPv6 address literals; this may cause problems
            with processing of those ICMP extensions.

3.3.  Translating ICMPv4 Error Messages into ICMPv6

   There are some differences between the ICMPv4 and the ICMPv6 error
   message formats as detailed above.  In addition, the ICMP error
   messages contain the packet in error, which MUST be translated just
   like a normal IP packet.  If the translation of this "packet in
   error" changes the length of the datagram, the Total Length field in
   the outer IPv6 header MUST be updated.

              +-------------+                 +-------------+
              |    IPv4     |                 |    IPv6     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |   ICMPv4    |                 |   ICMPv6    |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |    IPv4     |      ===>       |    IPv6     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |   Partial   |                 |   Partial   |
              |  Transport  |                 |  Transport  |
              |   Layer     |                 |   Layer     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+

               Figure 4: IPv4-to-IPv6 ICMP Error Translation

   The translation of the inner IP header can be done by invoking the
   function that translated the outer IP headers.  This process MUST
   stop at the first embedded header and drop the packet if it contains
   more.






Li, et al.              Expires October 19, 2010               [Page 13]

Internet-Draft            IPv4/IPv6 Translation               April 2010


3.4.  Translator Sending ICMPv4 Error Message

   If the IPv4 packet is discarded, then the translator SHOULD be able
   to send back an ICMPv4 error message to the original sender of the
   packet, unless the discarded packet is itself an ICMPv4 message.  The
   ICMPv4 message, if sent, has a Type value of 3 (Destination
   Unreachable) and a Code value of 13 (Communication Administratively
   Prohibited), unless otherwise specified in this document or in
   [I-D.ietf-behave-v6v4-xlate-stateful].  The translator SHOULD allow
   an administrator to configure whether the ICMPv4 error messages are
   sent, rate-limited, or not sent.

3.5.  Transport-layer Header Translation

   If the address translation algorithm is not checksum neutral, the
   recalculation and updating of the transport-layer headers which
   contain pseudo headers (e.g. of TCP, UDP and DCCP) MUST be performed.
   For ESP or undefined transport protocol, the translator MUST forward
   the packets to the destination without touching the transport-layer
   header.

   When a translator receives an unfragmented UDP IPv4 packet and the
   checksum field is zero, the translator SHOULD compute the missing UDP
   checksum as part of translating the packet.  Also, the translator
   SHOULD maintain a counter of how many UDP checksums are generated in
   this manner.

   When a stateless translator receives the first fragment of a
   fragmented UDP IPv4 packet and the checksum field is zero, the
   translator SHOULD drop the packet and generate a system management
   event specifying at least the IP addresses and port numbers in the
   packet.

   For stateful translator, the handling of fragmented UDP IPv4 packets
   with a zero checksum is discussed in
   [I-D.ietf-behave-v6v4-xlate-stateful] section 3.1.

3.6.  Knowing When to Translate

   If the IP/ICMP translator also provides normal forwarding function,
   and the destination IPv4 address is reachable by a more specific
   route without translation, the translator MUST forward it without
   translating it.  Otherwise, when an IP/ICMP translator receives an
   IPv4 datagram addressed to an IPv4 destination representing a host in
   the IPv6 domain, the packet MUST be translated to IPv6.






Li, et al.              Expires October 19, 2010               [Page 14]

Internet-Draft            IPv4/IPv6 Translation               April 2010


4.  Translating from IPv6 to IPv4

   When an IP/ICMP translator receives an IPv6 datagram addressed to a
   destination towards the IPv4 domain, it translates the IPv6 header of
   the received IPv6 packet into an IPv4 header.  The original IPv6
   header on the packet is removed and replaced by an IPv4 header.
   Since the ICMPv6 [RFC4443], TCP [RFC0793], UDP [RFC0768] and DCCP
   [RFC4340] headers contain checksums that cover the IP header, if the
   address mapping algorithm is not checksum-neutral, the checksum MUST
   be evaluated before translation and the ICMP and transport-layer
   headers MUST be updated.  The data portion of the packet is left
   unchanged.  The IP/ICMP translator then forwards the packet based on
   the IPv4 destination address.

              +-------------+                 +-------------+
              |    IPv6     |                 |    IPv4     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |  Fragment   |                 |  Transport  |
              |   Header    |      ===>       |   Layer     |
              |(if present) |                 |   Header    |
              +-------------+                 +-------------+
              |  Transport  |                 |             |
              |   Layer     |                 ~    Data     ~
              |   Header    |                 |             |
              +-------------+                 +-------------+
              |             |
              ~    Data     ~
              |             |
              +-------------+

                    Figure 5: IPv6-to-IPv4 Translation

   There are some differences between IPv6 and IPv4 in the area of
   fragmentation and the minimum link MTU that affect the translation.
   An IPv6 link has to have an MTU of 1280 bytes or greater.  The
   corresponding limit for IPv4 is 68 bytes.  Path MTU Discovery across
   a translator relies on ICMP Packet Too Big messages being received
   and processed by IPv6 hosts, including an ICMP Packet Too Big that
   indicates the MTU is less than the IPv6 minimum MTU.  This
   requirement is described in Section 5 of [RFC2460] (for IPv6's 1280
   octet minimum MTU) and Section 5 of [RFC1883] (for IPv6's previous
   576 octet minimum MTU).

   In an environment where an ICMPv4 Packet Too Big message is
   translated to an ICMPv6 Packet Too Big messages, and the ICMPv6
   Packet Too Big message is successfully delivered to and correctly
   processed by the IPv6 hosts (e.g., a network owned/operated by the



Li, et al.              Expires October 19, 2010               [Page 15]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   same entity that owns/operates the translator), the translator can
   rely on IPv6 hosts sending subsequent packets to the same IPv6
   destination with IPv6 fragment headers.  In such an environment, when
   the translator receives an IPv6 packet with a fragmentation header,
   the translator SHOULD generate the IPv4 packet with a cleared Don't
   Fragment bit, and with its identification value from the IPv6
   fragment header, for all of the IPv6 fragments (MF=0 or MF=1).

   In an environment where an ICMPv4 Packet Too Big message are filtered
   (by a network firewall or by the host itself) or not correctly
   processed by the IPv6 hosts, the IPv6 host will never generate an
   IPv6 packet with the IPv6 fragment header.  In such an environment,
   the translator SHOULD set the IPv4 Don't Fragment bit.  While setting
   the Don't Fragment bit may create PMTUD black holes [RFC2923] if
   there are IPv4 links smaller than 1260 octets, this is considered
   safer than causing IPv4 reassembly errors [RFC4963].

   A recent study indicates that only 43.46% of IPv6-capable web servers
   include an IPv6 fragmentation header in their respond packets after
   they were sent an ICMPv6 Packet Too Big message specifying an
   MTU<1280 bytes.  A workaround to this problem (ICMPv6 Packet Too Big
   message with MTU<1280) is that (1) in the IPv4 to IPv6 direction, the
   MTU value in the ICMPv4 Packet Too Big should be maximized with 1280,
   and (2) in the IPv6 to IPv4 direction, if there is no fragmentation
   header in the IPv6 packet, the translator SHOULD set DF to 0 for the
   packets equal to or smaller than 1280 bytes and set DF to 1 for
   packets larger than 1280 bytes.  In addition, the translator SHOULD
   take the identification value from the IPv6 fragmentation header if
   present or generate the identification value otherwise.  This avoids
   the introduction of the path MTU discovery black hole.  Note that
   translator generating the IPv4 identification value is tricky in
   stateless mode.  The Internet Protocol standard [RFC0791] specifies:

      "The choice of the Identifier for a datagram is based on the need
      to provide a way to uniquely identify the fragments of a
      particular datagram.  The protocol module assembling fragments
      judges fragments to belong to the same datagram if they have the
      same source, destination, protocol, and Identifier.  Thus, the
      sender must choose the Identifier to be unique for this source,
      destination pair and protocol for the time the datagram (or any
      fragment of it) could be alive in the Internet."

   Therefore, the translator may require states per three tuple IPv4
   identification field.  However, this does not prevent the deployment
   of the stateless translator, since as discussed in
   [I-D.ietf-behave-v6v4-framework], the stateless translation can be
   used in scenarios 1, 2, 5 and 6.  All of these scenarios involve "An
   IPv6 network" which are managed networks and network firewall, host



Li, et al.              Expires October 19, 2010               [Page 16]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   firewall or host misbehavior can be controlled.  In such a controlled
   environment, it can be assured that hosts and firewalls properly
   process ICMPv6 messages as described in Section 5 of [RFC2460].

   Other than the special rules for handling fragments and path MTU
   discovery, the actual translation of the packet header consists of a
   simple translation as defined below.  Note that ICMPv6 packets
   require special handling in order to translate the contents of ICMPv6
   error messages and also to remove the ICMPv6 pseudo-header checksum.

4.1.  Translating IPv6 Headers into IPv4 Headers

   If there is no IPv6 Fragment header, the IPv4 header fields are set
   as follows:

   Version:  4

   Internet Header Length:  5 (no IPv4 options)

   Type of Service (TOS) Octet:  By default, copied from the IPv6
      Traffic Class (all 8 bits).  According to [RFC2474] the semantics
      of the bits are identical in IPv4 and IPv6.  However, in some IPv4
      environments, these bits might be used with the old semantics of
      "Type Of Service and Precedence".  An implementation of a
      translator SHOULD provide the ability to ignore the IPv6 traffic
      class and always set the IPv4 TOS Octet to a specified value.  In
      addition, if the translator is at an administrative boundary, the
      filtering and update considerations of [RFC2475] may be
      applicable.

   Total Length:  Payload length value from IPv6 header, plus the size
      of the IPv4 header.

   Identification:  All zero.  In order to avoid back holes caused by
      ICMPv4 filtering or non [RFC2460] compatible IPv6 hosts (a
      workaround discussed in Section 4), the translator MAY provide a
      function such as if the packet size is equal to or smaller than
      1280 bytes and greater than 88 bytes, generate the identification
      value.  The translator SHOULD provide a method for operators to
      enable or disable this function.

   Flags:  The More Fragments flag is set to zero.  The Don't Fragments
      flag is set to one.  In order to avoid back holes caused by ICMPv4
      filtering or non [RFC2460] compatible IPv6 hosts (a workaround
      discussed in Section 4), the translator MAY provide a function
      such as if the packet size is equal to or smaller than 1280 bytes
      and greater than 88 bytes, the Don't Fragments (DF) flag is set to
      zero, otherwise the Don't Fragments (DF) flag is set to one.  The



Li, et al.              Expires October 19, 2010               [Page 17]

Internet-Draft            IPv4/IPv6 Translation               April 2010


      translator SHOULD provide a method for operators to enable or
      disable this function.

   Fragment Offset:  All zeros.

   Time to Live:  Time to Live is derived from Hop Limit value in IPv6
      header.  Since the translator is a router, as part of forwarding
      the packet it needs to decrement either the IPv6 Hop Limit (before
      the translation) or the IPv4 TTL (after the translation).  As part
      of decrementing the TTL or Hop Limit the translator (as any
      router) MUST check for zero and send the ICMPv4 "TTL Exceeded" or
      ICMPv6 "Hop Limit Exceeded" error.

   Protocol:  For ICMPv6 (58) changed to ICMPv4 (1), otherwise skip
      extension headers, copy the Next Header field (ESP, transport
      protocol or undefined next header value) in the last known next
      header.

   Header Checksum:  Computed once the IPv4 header has been created.

   Source Address:  In the stateless mode, which is to say that if the
      IPv6 source address is within the range of a configured IPv6
      translation prefix, the IPv4 source address is derived from the
      IPv6 source address per [I-D.ietf-behave-address-format] section
      2.1.  Note that the original IPv6 source address is an IPv4-
      translatable address.  A workflow example of stateless translation
      is shown in Appendix of this document.  If the translator only
      supports stateless mode and if the IPv6 source address is not
      within the range of configured IPv6 prefix(es), the translator
      SHOULD drop the packet and respond with an ICMPv6 Type=1, Code=5
      (Destination Unreachable, Source address failed ingress/egress
      policy).

      In the stateful mode, which is to say that if the IPv6 source
      address is not within the range of any configured IPv6 stateless
      translation prefix, the IPv4 source address and transport-layer
      source port corresponding to the IPv4-related IPv6 source address
      and source port are derived from the Binding Information Bases
      (BIBs) as described in [I-D.ietf-behave-v6v4-xlate-stateful].

      In stateless and stateful modes, if the translator gets an illegal
      source address (e.g. ::1, etc.), the translator SHOULD silently
      drop the packet.

   Destination Address:  The IPv4 destination address is derived from
      the IPv6 destination address of the datagram being translated per
      [I-D.ietf-behave-address-format] section 2.1.  Note that the
      original IPv6 destination address is an IPv4-converted address.



Li, et al.              Expires October 19, 2010               [Page 18]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   Certain IPv6 headers cannot be translated because they have no
   meaning in IPv4.  These headers are skipped over during processing
   and include HOPOPT (0), IPv6-Route (43), and IPv6-Opts (60).  The
   IPv6-Frag (44) header is handled as discussed below.  For the first
   'next header' that does not match one of the values above, its next
   header value (which contains the transport protocol number) is copied
   to the protocol field in the IPv4 header.  This means that all
   transport protocols are translated.  Some translated protocols will
   fail at the receiver for various reasons: some are known to fail when
   translated (e.g., IPsec AH (51)), others are malformed IPv6 packets
   with a useless IPv4 protocol number (e.g., IPv6-NoNxt (59)), and
   others will fail checksum validation if the address translation is
   not checksum neutral [I-D.ietf-behave-address-format] and the
   translator does not update the transport protocol's checksum (because
   the translator doesn't support recalculating the checksum for that
   transport protocol, e.g., SCTP (132)).

   If a Routing header with a non-zero Segments Left field is present
   then the packet MUST NOT be translated, and an ICMPv6 "parameter
   problem/erroneous header field encountered" (Type 4/Code 0) error
   message, with the Pointer field indicating the first byte of the
   Segments Left field, SHOULD be returned to the sender.

   If the IPv6 packet contains a Fragment header, the header fields are
   set as above with the following exceptions:

   Total Length:  Payload length value from IPv6 header, minus 8 for the
      Fragment header, plus the size of the IPv4 header.

   Identification:  Copied from the low-order 16-bits in the
      Identification field in the Fragment header.

   Flags:  The More Fragments (MF) flag is copied from the M flag in the
      Fragment header.  The Don't Fragments (DF) flag is set to zero
      allowing this packet to be fragmented if required by IPv4 routers.

   Fragment Offset:  Copied from the Fragment Offset field in the
      Fragment header.

   Protocol:  For ICMPv6 (58) changed to ICMPv4 (1), otherwise skip
      extension headers, Next Header field copied from the last IPv6
      header.

   If a translated packet with DF set to 1 will be larger than the MTU
   of the next-hop interface, then the translator MUST drop the packet
   and send the ICMPv6 "Packet Too Big" (Type 2/Code 0) error message to
   the IPv6 host with an adjusted MTU in the ICMPv6 message.




Li, et al.              Expires October 19, 2010               [Page 19]

Internet-Draft            IPv4/IPv6 Translation               April 2010


4.2.  Translating ICMPv6 Headers into ICMPv4 Headers

   All ICMPv6 messages that are to be translated require that the ICMPv4
   checksum field be updated as part of the translation since ICMPv6
   (unlike ICMPv4) includes a pseudo-header in the checksum just like
   UDP and TCP.

   In addition all ICMP packets MUST have the Type value translated and,
   for ICMP error messages, the included IP header also MUST be
   translated.  Note that the IPv6 addresses in the IPv6 header may not
   be IPv4-translatable addresses and there will be no corresponding
   IPv4 addresses representing this IPv6 address.  In this case, the
   translator can do stateful translation.  A mechanism by which the
   translator can instead do stateless translation is left for future
   work.

   The actions needed to translate various ICMPv6 messages are:

   ICMPv6 informational messages:

      Echo Request and Echo Reply (Type 128 and 129):  Adjust the Type
         values to 8 and 0, respectively, and adjust the ICMP checksum
         both to take the type change into account and to exclude the
         ICMPv6 pseudo-header.

      MLD Multicast Listener Query/Report/Done (Type 130, 131, 132):
         Single hop message.  Silently drop.

      Neighbor Discover messages (Type 133 through 137):  Single hop
         message.  Silently drop.

      Unknown informational messages:  Silently drop.

   ICMPv6 error messages:

      Destination Unreachable (Type 1)  Set the Type field to 3, and
         adjust the ICMP checksum both to take the type/code change into
         account and to exclude the ICMPv6 pseudo-header.

         Translate the Code field as follows:

         Code 0 (no route to destination):  Set Code value to 1 (Host
            unreachable).

         Code 1 (Communication with destination administratively
         prohibited):  Set Code value to 10 (Communication with
            destination host administratively prohibited).




Li, et al.              Expires October 19, 2010               [Page 20]

Internet-Draft            IPv4/IPv6 Translation               April 2010


         Code 2 (Beyond scope of source address):  Set Code value to 1
            (Host unreachable).  Note that this error is very unlikely
            since an IPv4-translatable source address is typically
            considered to have global scope.

         Code 3 (Address unreachable):  Set Code value to 1 (Host
            unreachable).

         Code 4 (Port unreachable):  Set Code value to 3 (Port
            unreachable).

         Other Code values:  Silently drop.

      Packet Too Big (Type 2):  Translate to an ICMPv4 Destination
         Unreachable (Type 3) with Code value equal to 4, and adjust the
         ICMPv4 checksum both to take the type change into account and
         to exclude the ICMPv6 pseudo-header.  The MTU field MUST be
         adjusted for the difference between the IPv4 and IPv6 header
         sizes taking into account whether or not the packet in error
         includes a Fragment header, i.e. minimum(advertised MTU-20,
         MTU_of_IPv4_nexthop, (MTU_of_IPv6_nexthop)-20)

      Time Exceeded (Type 3):  Set the Type value to 11, and adjust the
         ICMPv4 checksum both to take the type change into account and
         to exclude the ICMPv6 pseudo-header.  The Code field is
         unchanged.

      Parameter Problem (Type 4):  Translate the Type and Code field as
         follows, and adjust the ICMPv4 checksum both to take the type/
         code change into account and to exclude the ICMPv6 pseudo-
         header.

         Translate the Code field as follows:

         Code 0 (Erroneous header field encountered):  Set Type 12, Code
            0 and update the pointer as defined in Figure 6 (If the
            Original IPv6 Pointer Value is not listed or the Translated
            IPv4 Pointer Value is listed as "n/a", silently drop the
            packet).

         Code 1 (Unrecognized Next Header type encountered):  Translate
            this to an ICMPv4 protocol unreachable (Type 3, Code 2).

         Code 2 (Unrecognized IPv6 option encountered):  Silently drop.







Li, et al.              Expires October 19, 2010               [Page 21]

Internet-Draft            IPv4/IPv6 Translation               April 2010


      Unknown error messages:  Silently drop.




     |   Original IPv6 Pointer Value  | Translated IPv4 Pointer Value  |
     +--------------------------------+--------------------------------+
     |  0  | Version/Traffic Class    |  0  | Version/IHL, Type Of Ser |
     |  1  | Traffic Class/Flow Label |  1  | Type Of Service          |
     | 2,3 | Flow Label               | n/a |                          |
     | 4,5 | Payload Length           |  2  | Total Length             |
     |  6  | Next Header              |  9  | Protocol                 |
     |  7  | Hop Limit                |  8  | Time to Live             |
     | 8-23| Source Address           | 12  | Source Address           |
     |24-39| Destination Address      | 16  | Destination Address      |
     +--------------------------------+--------------------------------+


            Figure 6: Pointer Value for translating from IPv6 to IPv4

      ICMP Error Payload:  If the received ICMPv6 packet contains an
         ICMPv6 Extension [RFC4884], the translation of the ICMPv6
         packet will cause the ICMPv4 packet to change length.  When
         this occurs, the ICMPv6 Extension length attribute MUST be
         adjusted accordingly (e.g., shorter due to the translation from
         IPv6 to IPv4).  For extensions not defined in [RFC4884], the
         translator passes the extensions as opaque bit strings and
         those containing IPv6 address literals will not have those
         addresses translated to IPv4 address literals; this may cause
         problems with processing of those ICMP extensions.

4.3.  Translating ICMPv6 Error Messages into ICMPv4

   There are some differences between the ICMPv4 and the ICMPv6 error
   message formats as detailed above.  In addition, the ICMP error
   messages contain the packet in error, which MUST be translated just
   like a normal IP packet.  The translation of this "packet in error"
   is likely to change the length of the datagram thus the Total Length
   field in the outer IPv4 header MUST be updated.












Li, et al.              Expires October 19, 2010               [Page 22]

Internet-Draft            IPv4/IPv6 Translation               April 2010


              +-------------+                 +-------------+
              |    IPv6     |                 |    IPv4     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |   ICMPv6    |                 |   ICMPv4    |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |    IPv6     |      ===>       |    IPv4     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+
              |   Partial   |                 |   Partial   |
              |  Transport  |                 |  Transport  |
              |   Layer     |                 |   Layer     |
              |   Header    |                 |   Header    |
              +-------------+                 +-------------+

               Figure 7: IPv6-to-IPv4 ICMP Error Translation

   The translation of the inner IP header can be done by invoking the
   function that translated the outer IP headers.  This process MUST
   stop at first embedded header and drop the packet if it contains
   more.  Note that the IPv6 addresses in the IPv6 header may not be
   IPv4-translatable addresses and there will be no corresponding IPv4
   addresses.  In this case, the translator can do stateful translation.
   A mechanism by which the translator can instead do stateless
   translation is left for future work.

4.4.  Translator Sending ICMPv6 Error Message

   If the IPv6 packet is discarded, then the translator SHOULD be able
   to send back an ICMPv6 error message to the original sender of the
   packet, unless the discarded packet is itself an ICMPv6 message.

   If the ICMPv6 error message is being sent because the IPv6 source
   address is not an IPv4-translatable address and the translator is
   stateless, the ICMPv6 message, if sent, has a Type value 1 and Code
   value 5 (Source address failed ingress/egress policy).  In other
   cases, the ICMPv6 message has a Type value of 1 (Destination
   Unreachable) and a Code value of 1 (Communication with destination
   administratively prohibited), unless otherwise specified in this
   document or [I-D.ietf-behave-v6v4-xlate-stateful].  The translator
   SHOULD allow an administrator to configure whether the ICMPv6 error
   messages are sent, rate-limited, or not sent.

4.5.  Transport-layer Header Translation

   If the address translation algorithm is not checksum neutral, the
   recalculation and updating of the known transport-layer headers which



Li, et al.              Expires October 19, 2010               [Page 23]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   contain pseudo headers (e.g. of TCP, UDP and DCCP) MUST be performed.
   For ESP or undefined transport protocol, the translator MUST forward
   the packets to the destination without touching the transport-layer
   header.

4.6.  Knowing When to Translate

   If the IP/ICMP translator also provides a normal forwarding function,
   and the destination address is reachable by a more specific route
   without translation, the router MUST forward it without translating
   it.  When an IP/ICMP translator receives an IPv6 datagram addressed
   to an IPv6 address representing a host in the IPv4 domain, the IPv6
   packet MUST be translated to IPv4.


5.  IANA Considerations

   This memo adds no new IANA considerations.

   Note to RFC Editor: This section will have served its purpose if it
   correctly tells IANA that no new assignments or registries are
   required, or if those assignments or registries are created during
   the RFC publication process.  From the author's perspective, it may
   therefore be removed upon publication as an RFC at the RFC Editor's
   discretion.


6.  Security Considerations

   The use of stateless IP/ICMP translators does not introduce any new
   security issues beyond the security issues that are already present
   in the IPv4 and IPv6 protocols and in the routing protocols that are
   used to make the packets reach the translator.

   There are potential issues that might arise by deriving an IPv4
   address from an IPv6 address - particularly addresses like broadcast
   or loopback addresses and the non IPv4-translatable IPv6 addresses,
   etc.  The [I-D.ietf-behave-address-format] addresses these issues.

   As the Authentication Header [RFC4302] is specified to include the
   IPv4 Identification field and the translating function is not able to
   always preserve the Identification field, it is not possible for an
   IPv6 endpoint to verify the AH on received packets that have been
   translated from IPv4 packets.  Thus AH does not work through a
   translator.

   Packets with ESP can be translated since ESP does not depend on
   header fields prior to the ESP header.  Note that ESP transport mode



Li, et al.              Expires October 19, 2010               [Page 24]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   is easier to handle than ESP tunnel mode; in order to use ESP tunnel
   mode, the IPv6 node MUST be able to generate an inner IPv4 header
   when transmitting packets and remove such an IPv4 header when
   receiving packets.


7.  Acknowledgements

   This is under development by a large group of people.  Those who have
   posted to the list during the discussion include Andrew Sullivan,
   Andrew Yourtchenko, Brian Carpenter, Dan Wing, Dave Thaler, David
   Harrington, Ed Jankiewicz, Hiroshi Miyata, Iljitsch van Beijnum, Jari
   Arkko, Jerry Huang, John Schnizlein, Jouni Korhonen, Kentaro Ebisawa,
   Kevin Yin, Magnus Westerlund, Marcelo Bagnulo Braun, Margaret
   Wasserman, Masahito Endo, Phil Roberts, Philip Matthews, Reinaldo
   Penno, Remi Denis-Courmont, Remi Despres, Senthil Sivakumar, Simon
   Perreault and Zen Cao.


8.  Appendix: Stateless translation workflow example

   A stateless translation workflow example is depicted in the following
   figure.  The documentation address blocks 2001:DB8::/32 [RFC3849],
   192.0.2.0/24 and 198.51.100.0/24 [RFC5737] are used in this example.


            +--------------+                   +--------------+
            | IPv4 network |                   | IPv6 network |
            |              |     +-------+     |              |
            |   +----+     |-----| XLAT  |---- |  +----+      |
            |   | H4 |-----|     +-------+     |--| H6 |      |
            |   +----+     |                   |  +----+      |
            +--------------+                   +--------------+


                                 Figure 8

   A translator (XLAT) connects the IPv6 network to the IPv4 network.
   This XLAT uses the Network Specific Prefix (NSP) 2001:DB8:100::/40
   defined in [I-D.ietf-behave-address-format] to represent IPv4
   addresses in the IPv6 address space (IPv4-converted addresses) and to
   represent IPv6 addresses (IPv4-translatable addresses) in the IPv4
   address space.  In this example, 192.0.2.0/24 is the IPv4 block of
   the corresponding IPv4-translatable addresses.

   Based on the address mapping rule, the IPv6 node H6 has an IPv4-
   translatable IPv6 address 2001:DB8:1C0:2:21:: (address mapping from
   192.0.2.33).  The IPv4 node H4 has IPv4 address 198.51.100.2.



Li, et al.              Expires October 19, 2010               [Page 25]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   The IPv6 routing is configured in such a way that the IPv6 packets
   addressed to a destination address in 2001:DB8:100::/40 are routed to
   the IPv6 interface of the XLAT.

   The IPv4 routing is configured in such a way that the IPv4 packets
   addressed to a destination address in 192.0.2.0/24 are routed to the
   IPv4 interface of the XLAT.

8.1.  H6 establishes communication with H4

   The steps by which H6 establishes communication with H4 are:

   1.  H6 performs the destination address mapping, so the IPv4-
       converted address 2001:DB8:1C6:3364:200:: is formed from
       198.51.100.2 based on the address mapping algorithm
       [I-D.ietf-behave-address-format].

   2.  H6 sends a packet to H4.  The packet is sent from a source
       address 2001:DB8:1C0:2:21:: to a destination address 
       2001:DB8:1C6:3364:200::.

   3.  The packet is routed to the IPv6 interface of the XLAT (since
       IPv6 routing is configured that way).

   4.  The XLAT receives the packet and performs the following actions:

       *  The XLAT translates the IPv6 header into an IPv4 header using
          the IP/ICMP Translation Algorithm defined in this document.

       *  The XLAT includes 192.0.2.33 as source address in the packet
          and 198.51.100.2 as destination address in the packet.  Note
          that 192.0.2.33 and 198.51.100.2 are extracted directly from
          the source IPv6 address 2001:DB8:1C0:2:21:: (IPv4-translatable
          address) and destination IPv6 address 2001:DB8:1C6:3364:200::
          (IPv4-converted address) of the received IPv6 packet that is
          being translated.

   5.  The XLAT sends the translated packet out its IPv4 interface and
       the packet arrives at H4.

   6.  H4 node responds by sending a packet with destination address
       192.0.2.33 and source address 198.51.100.2.

   7.  The packet is routed to the IPv4 interface of the XLAT (since
       IPv4 routing is configured that way).  The XLAT performs the
       following operations:





Li, et al.              Expires October 19, 2010               [Page 26]

Internet-Draft            IPv4/IPv6 Translation               April 2010


       *  The XLAT translates the IPv4 header into an IPv6 header using
          the IP/ICMP Translation Algorithm defined in this document.

       *  The XLAT includes 2001:DB8:1C0:2:21:: as destination address
          in the packet and 2001:DB8:1C6:3364:200:: as source address in
          the packet.  Note that 2001:DB8:1C0:2:21:: and 
          2001:DB8:1C6:3364:200:: 
          are formed directly from the destination IPv4
          address 192.0.2.33 and source IPv4 address 198.51.100.2 of the
          received IPv4 packet that is being translated.

   8.  The translated packet is sent out the IPv6 interface to H6.

   The packet exchange between H6 and H4 continues until the session is
   finished.

8.2.  H4 establishes communication with H6

   The steps by which H4 establishes communication with H6 are:

   1.  H4 performs the destination address mapping, so 192.0.2.33 is
       formed from IPv4-translatable address 2001:DB8:1C0:2:21:: based
       on the address mapping algorithm
       [I-D.ietf-behave-address-format].

   2.  H4 sends a packet to H6.  The packet is sent from a source
       address 198.51.100.2 to a destination address 192.0.2.33.

   3.  The packet is routed to the IPv4 interface of the XLAT (since
       IPv4 routing is configured that way).

   4.  The XLAT receives the packet and performs the following actions:

       *  The XLAT translates the IPv4 header into an IPv6 header using
          the IP/ICMP Translation Algorithm defined in this document.

       *  The XLAT includes 2001:DB8:1C6:3364:200:: as source address in
          the packet and 2001:DB8:1C0:2:21:: as destination address in
          the packet.  Note that 2001:DB8:1C6:3364:200:: (IPv4-converted
          address) and 2001:DB8:1C0:2:21:: (IPv4-translatable address)
          are obtained directly from the source IPv4 address
          198.51.100.2 and destination IPv4 address 192.0.2.33 of the
          received IPv4 packet that is being translated.

   5.  The XLAT sends the translated packet out its IPv6 interface and
       the packet arrives at H6.

   6.  H6 node responds by sending a packet with destination address
       2001:DB8:1C6:3364:200:: and source address 2001:DB8:1C0:2:21::.



Li, et al.              Expires October 19, 2010               [Page 27]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   7.  The packet is routed to the IPv6 interface of the XLAT (since
       IPv6 routing is configured that way).  The XLAT performs the
       following operations:

       *  The XLAT translates the IPv6 header into an IPv4 header using
          the IP/ICMP Translation Algorithm defined in this document.

       *  The XLAT includes 198.51.100.2 as destination address in the
          packet and 192.0.2.33 as source address in the packet.  Note
          that 198.51.100.2 and 192.0.2.33 are formed directly from the
          destination IPv6 address 2001:DB8:1C6:3364:200:: and source
          IPv6 address 2001:DB8:1C0:2:21:: of the received IPv6 packet
          that is being translated.

   8.  The translated packet is sent out the IPv4 interface to H4.

   The packet exchange between H4 and H6 continues until the session
   finished.


9.  References

9.1.  Normative References

   [I-D.ietf-behave-address-format]
              Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X.
              Li, "IPv6 Addressing of IPv4/IPv6 Translators",
              draft-ietf-behave-address-format-07 (work in progress),
              April 2010.

   [I-D.ietf-behave-v6v4-xlate-stateful]
              Bagnulo, M., Matthews, P., and I. Beijnum, "Stateful
              NAT64: Network Address and Protocol Translation from IPv6
              Clients to IPv4 Servers",
              draft-ietf-behave-v6v4-xlate-stateful-11 (work in
              progress), March 2010.

   [RFC0768]  Postel, J., "User Datagram Protocol", STD 6, RFC 768,
              August 1980.

   [RFC0791]  Postel, J., "Internet Protocol", STD 5, RFC 791,
              September 1981.

   [RFC0792]  Postel, J., "Internet Control Message Protocol", STD 5,
              RFC 792, September 1981.

   [RFC0793]  Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, September 1981.



Li, et al.              Expires October 19, 2010               [Page 28]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   [RFC1812]  Baker, F., "Requirements for IP Version 4 Routers",
              RFC 1812, June 1995.

   [RFC1883]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 1883, December 1995.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 2460, December 1998.

   [RFC2765]  Nordmark, E., "Stateless IP/ICMP Translation Algorithm
              (SIIT)", RFC 2765, February 2000.

   [RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, February 2006.

   [RFC4340]  Kohler, E., Handley, M., and S. Floyd, "Datagram
              Congestion Control Protocol (DCCP)", RFC 4340, March 2006.

   [RFC4443]  Conta, A., Deering, S., and M. Gupta, "Internet Control
              Message Protocol (ICMPv6) for the Internet Protocol
              Version 6 (IPv6) Specification", RFC 4443, March 2006.

   [RFC4884]  Bonica, R., Gan, D., Tappan, D., and C. Pignataro,
              "Extended ICMP to Support Multi-Part Messages", RFC 4884,
              April 2007.

   [RFC5382]  Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P.
              Srisuresh, "NAT Behavioral Requirements for TCP", BCP 142,
              RFC 5382, October 2008.

   [RFC5771]  Cotton, M., Vegoda, L., and D. Meyer, "IANA Guidelines for
              IPv4 Multicast Address Assignments", BCP 51, RFC 5771,
              March 2010.

9.2.  Informative References

   [I-D.ietf-behave-v6v4-framework]
              Baker, F., Li, X., Bao, C., and K. Yin, "Framework for
              IPv4/IPv6 Translation",
              draft-ietf-behave-v6v4-framework-08 (work in progress),
              March 2010.

   [RFC0879]  Postel, J., "TCP maximum segment size and related topics",
              RFC 879, November 1983.




Li, et al.              Expires October 19, 2010               [Page 29]

Internet-Draft            IPv4/IPv6 Translation               April 2010


   [RFC1191]  Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,
              November 1990.

   [RFC2474]  Nichols, K., Blake, S., Baker, F., and D. Black,
              "Definition of the Differentiated Services Field (DS
              Field) in the IPv4 and IPv6 Headers", RFC 2474,
              December 1998.

   [RFC2475]  Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.,
              and W. Weiss, "An Architecture for Differentiated
              Services", RFC 2475, December 1998.

   [RFC2710]  Deering, S., Fenner, W., and B. Haberman, "Multicast
              Listener Discovery (MLD) for IPv6", RFC 2710,
              October 1999.

   [RFC2766]  Tsirtsis, G. and P. Srisuresh, "Network Address
              Translation - Protocol Translation (NAT-PT)", RFC 2766,
              February 2000.

   [RFC2923]  Lahey, K., "TCP Problems with Path MTU Discovery",
              RFC 2923, September 2000.

   [RFC3307]  Haberman, B., "Allocation Guidelines for IPv6 Multicast
              Addresses", RFC 3307, August 2002.

   [RFC3590]  Haberman, B., "Source Address Selection for the Multicast
              Listener Discovery (MLD) Protocol", RFC 3590,
              September 2003.

   [RFC3810]  Vida, R. and L. Costa, "Multicast Listener Discovery
              Version 2 (MLDv2) for IPv6", RFC 3810, June 2004.

   [RFC3849]  Huston, G., Lord, A., and P. Smith, "IPv6 Address Prefix
              Reserved for Documentation", RFC 3849, July 2004.

   [RFC4302]  Kent, S., "IP Authentication Header", RFC 4302,
              December 2005.

   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler, "IPv4 Reassembly
              Errors at High Data Rates", RFC 4963, July 2007.

   [RFC5737]  Arkko, J., Cotton, M., and L. Vegoda, "IPv4 Address Blocks
              Reserved for Documentation", RFC 5737, January 2010.







Li, et al.              Expires October 19, 2010               [Page 30]

Internet-Draft            IPv4/IPv6 Translation               April 2010


Authors' Addresses

   Xing Li
   CERNET Center/Tsinghua University
   Room 225, Main Building, Tsinghua University
   Beijing,   100084
   China

   Phone: +86 10-62785983
   Email: xing@cernet.edu.cn


   Congxiao Bao
   CERNET Center/Tsinghua University
   Room 225, Main Building, Tsinghua University
   Beijing,   100084
   China

   Phone: +86 10-62785983
   Email: congxiao@cernet.edu.cn


   Fred Baker
   Cisco Systems
   Santa Barbara, California  93117
   USA

   Phone: +1-408-526-4257
   Email: fred@cisco.com






















Li, et al.              Expires October 19, 2010               [Page 31]


