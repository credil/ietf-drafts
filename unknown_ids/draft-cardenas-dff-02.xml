<?xml version="1.0" encoding="US-ASCII"?>
    
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" []>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->



<rfc category="exp" docName="draft-cardenas-dff-02" ipr="trust200902">
	<!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes ups="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->
	<!-- ***** FRONT MATTER ***** -->
	<front>
		<!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->
		<title abbrev="DFF">Depth-First Forwarding in Unreliable Networks</title>
		<!-- add 'role="editor"' below for the editors if appropriate -->
		<!-- Another author who claims to be an editor -->
		
		<author fullname="Ulrich Herberg" initials="U.H." surname="Herberg">
			<organization>Fujitsu Laboratories</organization>
			<address>
				<postal>
					<street>1240 E. Arques Avenue, M/S 345</street>
					<city>Sunnyvale</city>
					<region>CA</region>
					<code>94085</code>
					<country>US</country>
				</postal>
				<phone>+1 408 530-4528</phone>
				<email>ulrich.herberg@us.fujitsu.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Alvaro A. Cardenas" initials="A.C." surname="Cardenas">
			<organization>Fujitsu Laboratories</organization>
			<address>
				<postal>
					<street>1240 E. Arques Avenue, M/S 345</street>
					<city>Sunnyvale</city>
					<region>CA</region>
					<code>94085</code>
					<country>US</country>
				</postal>
				<phone>+1 408 530-4516</phone>
				<email>alvaro.cardenas-mora@us.fujitsu.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Sandra L. Cespedes" initials="S.C." surname="Cespedes">
			<organization>U. Icesi/U. of Waterloo</organization>
			<address>
				<postal>
					<street>Calle 18 No. 122-135 Pance</street>
					<city>Cali</city>
					<region>Valle</region>
					<code/>
					<country>Colombia</country>
				</postal>
				<phone>+1 (519) 8884567 x37448</phone>
				<email>slcesped@bbcr.uwaterloo.ca</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Tadashige Iwao" initials="T.I." surname="Iwao">
			<organization>Fujitsu Limited</organization>
			<address>
				<postal>
					<street>Shiodome City Center, 5-2, Higashi-shimbashi 1-chome, Minato-ku</street>
					<city>Tokyo</city>
					<region/>
					<code/>
					<country>JP</country>
				</postal>
				<phone>+81-44-754-3343</phone>
				<email>smartnetpro-iwao_std@ml.css.fujitsu.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		

		
		<date year="2011"/>

		<!-- Meta-data Declarations -->
		<area>General</area>
		
		<workgroup>Internet Engineering Task Force</workgroup>
		<!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->
        
		<keyword>DFF</keyword>
		<!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->
        
		<abstract>
			<t>This document describes the Depth-First Forwarding (DFF) protocol for IPv6 networks based on the IEEE 802.15.4 link layer (6lowpan). The protocol is a mesh-under data forwarding mechanism that increases reliability of data delivery in cases where the next hop along the path to the destination, as determined by the underlying routing protocol, is not reachable. In that case, a node running DFF tries to forward the packet successively to all neighbors, and - if the packet makes no forward progress - returns it to the previous hop, similar to a "depth-first search" in graph theory.
			</t>
		</abstract>
	</front>
	
	
	<middle>
		<section title="Introduction">			
			<t>This document describes the Depth-First Forwarding (DFF) protocol for IPv6 networks based on the IEEE 802.15.4 link layer, as specified in <xref target="RFC4944"/>. The protocol is a mesh-under data forwarding mechanism that increases reliability of data delivery in cases where the next hop along the path to the destination, as determined by the underlying routing protocol, is not reachable. In that case, a node running DFF tries to forward the packet successively to all neighbors, and - if the packet makes no forward progress - returns it to the previous hop, similar to a "depth-first search" in graph theory.</t>
			
			<t>As network topologies do not necessarily form a tree, loops can occur. Therefore, DFF contains a loop detection and avoidance mechanism.</t>
			
			<t>While rerouting the packet through alternative next hops, the routing table can be updated, and thus, DFF provides an optional local route repair mechanism.</t>
			
			<t>Any underlying mesh-under routing mechanism can be used with DFF, as long as such routing mechanism provides lists of bidirectional neighbors for each node. This specification assumes there is such a protocol in place and outlines the requirements for that protocol, as well as the interaction between the specified forwarding mechanism and the routing protocol.</t>
			
			
			<section title="Motivation">
				<t>In networks with very dynamic topologies, even frequent exchanges of control messages between nodes for updating the routing tables cannot guarantee freshness of routes: packets may not be delivered to their destination because the topology has changed since the last routing protocol update.</t> 
				
				<t>While more frequent routing protocol updates could mitigate that problem to a certain extent, more frequent routing protocol updates require network bandwidth (e.g. when flooding control messages through the network for route discovery). This is an issue in networks with very lossy links, where further control traffic exchange can worsen the network stability. Moreover, additional control traffic exchange (e.g. network-wide floods) drains energy from battery-driven nodes.</t>
				
				<t>The data-forwarding mechanism specified in this document allows forwarding data packets along alternate paths for increasing reliability of data delivery, using a depth-first search. The objective is to decrease the necessary control traffic overhead of the underlying routing protocol, and in the same time to increase delivery success rates. Optionally, the underlying routing protocol can be informed about the updated topology, and routes can then be repaired.</t>
			</section>
    	</section>
    	
			
		<section title="Notation and Terminology">
			<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.
       		</t>
       		
       		<t>Additionally, this document uses the notation in <xref target="notation"/> and the terminology in <xref target="terminology"/>.</t>
       		
       		<section anchor="notation" title="Notation">
       			<t>The following notations are used in this document:
       				<list style="hanging">
       					<t hangText="List"> - A list of elements is defined as [] for an empty list, [element] for a list with one element, and [element1, element2, ...] for a list with multiple elements.</t>
       					
       					<t hangText="Concatenation of lists:">If L1 and L2 are lists, then L1@L2 is a new list with all elements of L2 concatenated to L1. 
       					</t>
       				</list>
       			
       			</t>
       		</section>
       		
       		<section anchor="terminology" title="Terminology">
				<t>All terms introduced in <xref target="RFC4944"/> are to be interpreted as described therein.</t>
				
				<t>Additionally, this document uses the following terminology:
				
					<list style="hanging">
						<t hangText="Address"> - An address is either a 16-bit short or a EUI-64 link layer address, as specified in <xref target="RFC4944"/>.</t>
					
						<t hangText="Packet"> - An IPv6 packet encapsulated in a IEEE 802.15.4 frame, using the LoWPAN adaption layer as specified in <xref target="RFC4944"/>.</t>
					
						<t hangText="Originator Address"> - An address of a node that is included as source address in the packet header.</t>

					</list>
				</t>
			</section>
		</section>
		
		
		<section anchor="applicability" title="Applicability Statement">
			<t>This protocol:
			
				<list style="symbols">
					<t>Is applicable for use in IEEE 802.15.4 based networks, using the frame format for transmission of IPv6 packets defined in <xref target="RFC4944"/>.</t>
					
					<t>Assumes addresses used in the network are either 16-bit short or EUI-64 link layer address, as specified in <xref target="RFC4944"/>.</t>
					
					<t>Operates as "mesh-under" forwarding protocol, i.e. on the link layer. While the proposed mechanism could also be used as "route-over", this is not specified in this document and thus out of scope.</t>
					
					<t>Is designed to work in networks with lossy links or with a dynamic topology.</t>
					
					<t>Relies on an underlying mesh-under routing protocol. This routing protocol MUST provide a list of bidirectional neighbors of a node, and MAY provide one more multiple paths to destinations in the network (i.e. store one or more next hop nodes for a destination with an associated routing cost).</t>
					
					<t>Increases reliability of data delivery by trying alternative paths, using a "depth-first forwarding" approach.</t>
					
					<t>Provides a loop detection mechanism, and an optional local route repair mechanism.</t>	
					
					<t>Is designed to work in a completely distributed manner, and does not depend on any central entity.</t>
				</list>
			</t>
		</section>
		
		
		<section anchor="overview" title="Protocol Overview and Functioning">
			<t>DFF is a mesh-under data forwarding mechanism responsible for detecting loops, choosing alternate next hops, and optionally updating the cost metrics in the routing tables to reflect information gathered by forwarding data packets. DFF operates on 6lowpan based networks (using the frame format and the transmission of IPv6 packets defined in <xref target="RFC4944"/>).</t>
			
			<t>DFF is intended to work in a network where nodes maintain a bidirectional neighbor table as candidates for a possible next hop of a packet, and a routing table with one or more candidate next hops for each final destination.</t>
			
			<t>DFF provides advantages in networks where the reliability of links is low and the link quality may change rapidly. It assumes that the control plane mechanism cannot guarantee up-to-date routing tables, nor necessarily the absence of loops. Therefore, whenever a data packet is forwarded, DFF stores a data packet identifier to detect loops, and uses alternate paths to reroute the packet to the destination, optionally updating routing tables if a loop is detected.</t>
			
			<t>DFF achieves this functionality by implementing a distributed depth-first search over the network graph. If the routing tables are up-to-date, the search only involves the default route (i.e. uses the shortest path as calculated by the underlying routing protocol). However, if the routing table is not up-to-date and forwarding of a data packet results in a loop, or if the link layer fails to successfully transmit the packet to the next hop, the data packet is sent to an alternate next hop neighbor. This alternate next hop is selected from the neighbor set of the underlying mesh-under routing protocol, using a descending order of priority which takes into account link metrics. DFF lists for each recently forwarded packet  which neighbors that packet has been sent to, allowing for trying to forward the packet to all candidates for the next hop.</t>
			
			<t>If none of the transmissions to the neighbors has succeeded, the packet is returned to the previous hop, indicated by setting a return (RET) flag, which is defined in a 6lowpan dispatch byte. The previous hop then continues to try other neighbors in turn, resulting in a depth-first search in the network.</t>
			
			<t>Whenever a packet has been sent to a neighbor and no link layer acknowledgment (ACK) has been received, the duplicate (DUP) flag is set in the packet header for the following transmissions. The rationale is that the packet may have been successfully received by the neighbor and only the ACK has been lost, resulting in duplicates of the packet in the network. The DUP flag tags such a possible duplicate.</t>
			
			<t>Whenever a node receives a packet that it has already forwarded, and which is not a duplicate (as indicated by the DUP flag), it will assume a loop and return the packet to the previous hop (with the RET flag set). Optionally, the link to the next hop to which the node has originally sent the packet may be "poisoned" (i.e. the link cost will be increased).</t>

			<t>DFF requires an underlying mechanism that minimally provides a list of bidirectional neighbors of a node. However, in order to avoid sending a packet to any random neighbor as next hop, and therefore possibly performing a network-wide depth-first search, it is recommended to implement DFF in combination with a routing protocol that provides multiple paths to a destination, in order to efficiently choose alternative next hops.</t>
		</section>
		
		
		<section title="Data Structures">
			<t>This section specifies optional and mandatory data structures of DFF. DFF itself is no routing protocol, but a data forwarding protocol. However, DFF relies on some information from the underlying routing protocol, in order to perform the depth-first search.</t>
			
			
			<section title="Neighbor Set" anchor="neighbor_set">
				<t>DFF MUST have read access to a list of bidirectional neighbors, henceforth called "Neighbor Set", provided by the underlying routing protocol. The Neighbor Set MUST at least provide the addresses of the direct neighbors of the node, and MAY provide additional information representing the cost of sending a packet to each neighbor (e.g. using a link metric). If DFF has write access to the Neighbor Set, updating link costs ("poisoning") is supported.</t>
			</section>
			
			<section title="Routing Set" anchor="routing_set">
				<t>DFF MAY have read access to a list of destinations in the network with one or more possible next hops for reaching each destination, henceforth called "Routing Set", provided by the underlying routing protocol. If the routing protocol provides a Routing Set, it MUST at least provide the addresses of destinations and one or more possible next hops to reach that destination, and MAY provide additional information representing the cost of sending a packet to the destination (e.g. using a route metric). If DFF has write access to the Routing Set, updating route costs ("poisoning") is supported.</t>
			</section>

			<section title="Processed Set" anchor="processed_set">
				<t>Each node MUST maintain a Processed Set in order to support the loop detection functionality. The Processed Set lists sequence numbers of previously received packets, as well as a list of next hops to which the packet has been sent successively as part of the depth-first search mechanism. The set consists of Processed Tuples:
			
				<list style="hanging">
					<t hangText="">(P_orig_address, P_seq_number, P_prev_hop, P_next_hop_neighbor_list, P_time)</t>
				</list>
			
				where
			
				<list style="hanging">
					<t hangText="">P_orig_address is is the originator address of the received message;</t>
				
					<t hangText="">P_seq_number is the sequence number of the received packet;</t>
				
					<t hangText="">P_prev_hop is the address of the previous hop  of the packet;</t>
				
					<t hangText="">P_next_hop_neighbor_list is a list of addresses of next hops to which the packet has been sent previously, as part of the depth-first search mechanism, as explained in <xref target="packet_processing"/>;</t>
				
					<t hangText="">P_time specifies when this Tuple expires and MUST be removed.</t>
				</list>
				</t>
			</section>
		</section>
		
		
		<section anchor="packet_format" title="Packet Format">
			<t>This document assumes that the data forwarding as well as the underlying routing protocol are based on the LoWPAN adaptation layer ("mesh-under"), and that data packets are conform with the packet format specified in <xref target="RFC4944"/>. In particular, <xref target="RFC4944"/> states that
			<list style="hanging">
				<t>Additional mesh routing capabilities, such as specifying the mesh routing protocol, source routing, and so on may be expressed by defining additional routing headers that precede the fragmentation or addressing header in the header stack.
				</t>
			</list>
			
			Hence, all data packets to be forwarded using DFF MUST be preceded by the standard mesh (L2) addressing header defined in <xref target="RFC4944"/>, and MAY be preceded by a header that identifies the DFF data forwarding mechanism, which is defined in the following.</t>
			
			<t>After these two headers, any other LoWPAN header, e.g. hop-by-hop options, header compression or fragmentation, MAY also be added before the actual payload. (<xref target="mesh-header"/>) depicts the mesh header of a data frame to be forwarded with DFF.</t>


			<figure anchor="mesh-header" title="Mesh Header for DFF data frames">
				<artwork align="center"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Mesh type and header                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 1| Mesh Forw |D|R|x|         DID             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
			</figure>

			<t>Field definitions are as follows: 
				<list style="hanging">
            		<t hangText="Mesh type and header"> - The mesh (L2) addressing header and its associated dispatch byte as defined in <xref target="RFC4944"/>.</t>
            		
            		<t hangText="Mesh Forw"> - A 6-bit identifier that allows for the use of different mesh forwarding mechanisms. As specified in <xref target="RFC4944"/>, additional mesh forwarding mechanisms should use the reserved dispatch byte values following LOWPAN_BCO; therefore, 0 1 MUST precede Mesh Forw. The value of Mesh Forw is LOWPAN_DFF.</t>
            		
            		<t hangText="Duplicate packet flag (D)"> - This flag is included in the DFF mesh header to indicate that the packet has been re-sent as a duplicate. The flag MUST be set to 1 by the node that re-sends the packet after detecting link-layer failure to deliver through the last attempted next-hop, as specified in <xref target="packet_processing"/>. Once the flag is set to 1, it MUST not be modified by nodes forwarding the packet.</t>
            
          			<t hangText="Return packet flag (R)"> - This flag is included in the DFF mesh header to indicate that the packet has been returned to the previous hop after failure to deliver to all the available next-hops. The flag MUST be set to 1 prior to forwarding the packet back to the previous hop and MUST be set to 0 prior to forwarding the packet to the selected next-hop, as specified in <xref target="packet_processing"/>. This flag is modified in a hop-by-hop basis.</t>
            
           			<t hangText="Reserved flag (x)"> - This bit is reserved for future flag definitions.</t>
           			
            
            		<t hangText="DID"> - This is the data packet identifier. It is a sequence number generated by the originator, unique on a node for each new generated packet. The originator address concatenated with the DID sequence number represent an identifier of previously seen data packets. </t>
      		  </list>
   		 </t>
		</section>
		
				
		<section anchor="parameters" title="Protocol Parameters and Constants">
			<t>
				The parameters and constants used in this specification are described in this section.
				
				<list style="hanging">
					<t hangText="P_HOLD_TIME"> - is the time period after which a newly created Processed Tuple expires and MUST be deleted.</t>
				</list>
			</t>
		</section>
		
		
		
		<section title="Data Packet Generation and Processing">
			<t>The following sections describe the process of handling a new packet, generated on a node (<xref target="packet_generation"/>), as well as forwarding a packet from another node (<xref target="packet_processing"/>).</t>
			
			<section title="Data Packet Generation" anchor="packet_generation">
				<t>Before a new packet (the "current packet") is transmitted on a node, the following steps MUST be performed:
				
					<list style="numbers">
						<t>
							Add the mesh header to the current packet, as specified in <xref target="packet_format"/>, with:
						
							<list style="symbols">
      							<t>Duplicate packet flag (D) := 0;</t>
      							<t>Return packet flag (R) := 0;</t>
      							<t>DID := a new sequence number of the packet.</t>
       						</list>
						
						</t>
					
						<t>
							Select the next hop (denoted "next_hop") for the current packet, as specified in <xref target="getnexthop"/>.
						</t>
					
					
						<t>
							Add a Processed Tuple to the Processed Set with:
					
							<list style="symbols">
      							<t>P_orig_address := the originator address of this node;</t>
      							<t>P_seq_number := the sequence number of the current packet, as added in the header in Step 1;</t>
      							<t>P_prev_hop := the originator address of this node;</t>
      							<t>P_next_hop_neighbor_list := [next_hop];</t>
      							<t>P_time := current time + P_HOLD_TIME.</t>
       						</list>
       					</t>
       					
       					<t>
       						Forward the current packet to next_hop.
       					</t>
       				
					</list>
				</t>
			</section>
		
		
		
		
			<section anchor="packet_processing" title="Data Packet Processing">
				<t>
					If a packet (the "current packet") is received on the node, then the following tasks MUST be performed:

					<list style="numbers">
						<t>
							If the packet does not contain the DFF header, specified in <xref target="packet_format"/>, select the next hop (denoted "next_hop") for the current packet, as specified in <xref target="getnexthop"/>, and then forward it to next_hop. This allows for interoperability of nodes sending packets without DFF, by forwarding them without the specified depth-first forwarding mechanism.
						</t>
					
						<t>
							Otherwise, if no Processed Tuple (the "current tuple") exists in the Processed Set, with:

							<list style="hanging">
            					<t hangText="+">P_orig_address = the originator address of the current packet, AND;</t>

            					<t hangText="+">P_seq_number = the sequence number of the current packet,</t>
            				</list>

          					then:
          					
          					<list style="format %d." counter="my_count1">
          						<t>
          							add a Processed Tuple (the "current tuple") with:
					
									<list style="symbols">

      									<t>P_orig_address := the originator address of the current packet;</t>
      					
      									<t>P_seq_number := the sequence number (DID) of the current packet;</t>
      					
      									<t>P_prev_hop := address of the previous hop of the current packet;</t>
      					
      									<t>P_next_hop_neighbor_list := 	[next_hop];</t>
      					
      									<t>P_time := current time + P_HOLD_TIME.</t>
      					
       								</list>
       							</t>
       			
       							<t>
       								Set RET to 0 in the packet DFF header.
       							</t>
       							
       							
       							<t>
       								Select the next hop (denoted "next_hop") for the current packet, as specified in <xref target="getnexthop"/>, and then forward the current packet to next_hop. If the transmission fails (determined by missing link layer acknowledgments), the procedures in <xref target="missed_ACK"/> SHOULD be executed.
       							</t>
       							
       						</list>
          				</t>
          					
          				<t>
          					Otherwise, if a tuple exists:
					
							<list style="numbers">
								<t>If the return flag of the current packet is not set (RET=0), set RET:=1 and return the packet to the previous hop of the packet (i.e. a loop has been detected, and the packet is returned).</t>
								
								<t>Otherwise, if the return flag of the current packet is set (RET=1):
								
									<list style="numbers">
										<t>Set RET:=0</t>
      						
      									<t>Increase the route cost in the routing table entry for the packet destination with the next hop of the current packet, as defined in <xref target="poison"/>.</t>
      							
      									<t>Select the next hop (denoted "next_hop") for the current packet, as specified in <xref target="getnexthop"/>.
      									</t>
      							
      									<t>Modify the current tuple:
      								
      										<list style="symbols">
      											<t>P_next_hop_neighbor_list := 	P_next_hop_neighbor_list@[next_hop];</t>
      					
      											<t>P_time := current time + P_HOLD_TIME.</t>
       										</list>
      									</t>
      							
      									<t>
      										If the selected next hop is equal to P_prev_hop of the current tuple (i.e. all neighbors have been unsuccessfully tried), set the RET flag (RET := 1), otherwise reset it (RET := 0).
      									</t>
      							
      							
      									<t>
       										Forward the current packet to next_hop. If the transmission fails (determined by missing link layer acknowledgments), the procedures in <xref target="missed_ACK"/> SHOULD be executed.
       									</t>
      								</list>
       							</t>
          					</list>
          				</t>
          			</list>
				</t>
				
			</section>
		</section>
		


		<section anchor="missed_ACK" title="Missed Link Layer Acknowledgment when Sending a Packet">
			<t>
				If a packet (the "current packet") has been sent to the next hop, as specified in <xref target="packet_generation"/> and <xref target="packet_processing"/>, and no link layer acknowledgment has been received after several retries (as specified in <xref target="ieee802.15.4"/>), then:
				
				<list style="numbers">
      				<t>
      					Set the duplicate flag (DUP) of the DFF header of the current packet to 1.
      				</t>      				
      							
      				<t>
      					Select the next hop (denoted "next_hop") for the current packet, as specified in <xref target="getnexthop"/>.
      				</t>
      				
      				<t>Find the Processed Tuple (the "current tuple") in the Processed Set, with:

						<list style="hanging">
            				<t hangText="+">P_orig_address = the originator address of the current packet, AND;</t>

            				<t hangText="+">P_seq_number = the sequence number of the current packet,</t>
            			</list>
      		
      				and modify the current tuple:
      								
      					<list style="symbols">
  
      						<t>P_next_hop_neighbor_list := 	P_next_hop_neighbor_list@[next_hop];</t>
      					
      						<t>P_time := current time + P_HOLD_TIME.</t>
      					
       					</list>	
      				</t>
      				
      							
      				<t>
      					If the selected next hop is equal to P_prev_hop of the current tuple, set the RET flag (RET := 1), otherwise reset it (RET := 0).
      				</t>
      							
      				<t>
       					Forward the current packet to next_hop.
       				</t>
      			
       			</list>
			</t>
		</section>
		
		
		<section anchor="getnexthop" title="Getting the Next Hop for a Packet">
			<t>
				Before a packet (the "current packet") is sent from a node towards the packet destination, a valid next hop along the path has to be selected. This section describes how to select the next hop (denoted "next_hop"). As a Processed Tuple was either existing when receiving the packet, or otherwise was created, it can be assumed the a Processed Tuple for that packet (the "current tuple") is available. 
			</t>
			
			<t>
				The next hop is chosen from the Neighbor Set in order of decreasing preference of the following conditions. This list is only a suggestion, any other order of priority MAY be used.
				
				<list style="numbers">
					<t>The neighbor is listed in the Routing Set as next hop for the destination of the current packet, with lower route costs having a higher priority, and the neighbor is not listed in P_next_hop_neighbor_list of the current tuple.</t>
					
					<t>The neighbor is not listed in the Routing Set as any next hop destination of the current packet, and the neighbor is not listed in P_next_hop_neighbor_list of the current tuple.</t>
					
					<t>The neighbor is the same as P_prev_hop of the current tuple; this case is only used for returning the packet to the previous hop, in which case the RET flag MUST be set to 1.</t>
				</list>
			</t>
		</section>
		

		<section anchor="poison" title="Poisoning">
			<t>When a packet is returned (i.e. a packet with RET=1 is received by a node) or a link layer acknowledgment (ACK) has not been received for a forwarded packet, the cost for the route MAY be increased, so that future transmissions prefer other routes. For the case of a missing link layer ACK, in addition to increasing the route cost, the link cost to the neighbor may also be increased.
			</t>
			
			<t>It is up to the implementation to decide by how much the route and link cost should be increased and out of scope of this document.</t>
		</section>
		
		<section anchor="proposed_values" title="Proposed Values for Parameters and Constants">
			<t>
				This section lists the parameters and constants used in the   specification of the protocol, and proposed values of each that MAY be used when a single value of each is used.
				
				<list style="symbols">
					<t>P_HOLD_TIME := 5 seconds</t>
				</list>
   			</t>
		</section>
		
		
		
		<section anchor="Security" title="Security Considerations">
			<t>The security of the underlying mesh routing protocol depends on the integrity, authentication, and confidentiality of the control messages. The security mechanisms for protecting the network can be provided by link-layer technologies. Further details are presented in the Security Considerations section of <xref target="RFC4944"/>.</t>
		</section>
		

		<section anchor="IANA" title="IANA Considerations">
			<t>IANA is requested to allocate a value from the Dispatch Type Field registry for LOWPAN_DFF.
			</t>
		</section>
		

		<section anchor="Acknowledgements" title="Acknowledgements">
			<t>Yuichi Igarashi (Hitachi), Kazuya Monden (Hitachi), Geoff Mulligan (IPSO), Hiroki Satoh (Hitachi), and Ganesh Venkatesh (UC San Diego) provided useful discussions which helped to improve this document.</t>
		</section>	
		
		
	</middle>
	

	<back>
	
		<references title="Normative References">
			<reference anchor='RFC2119'>
				<front>
					<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
						<organization>Harvard University</organization>
					</author>
					<date year='1997' month='March' />
				</front>
				<seriesInfo name='BCP' value='14' />
				<seriesInfo name='RFC' value='2119' />
				<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
				<format type='HTML' octets='17491' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
				<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
			</reference>

			<reference anchor='RFC4944'>
				<front>
					<title>Transmission of IPv6 Packets over IEEE 802.15.4 Networks</title>
					<author initials='G.' surname='Montenegro' fullname='G. Montenegro'>
						<organization /></author>
					<author initials='N.' surname='Kushalnagar' fullname='N. Kushalnagar'>
						<organization /></author>
					<author initials='J.' surname='Hui' fullname='J. Hui'>
						<organization /></author>
					<author initials='D.' surname='Culler' fullname='D. Culler'>
						<organization /></author>
					<date year='2007' month='September' />
				</front>

				<seriesInfo name='RFC' value='4944' />
				<format type='TXT' octets='67232' target='http://www.rfc-editor.org/rfc/rfc4944.txt' />
			</reference>

			<reference anchor='ieee802.15.4'>
				<front>
					<title>IEEE Std. 802.15.4-2003</title>
					<author initials = 'IEEE' surname='Computer Society' fullname='IEEE Computer Society'>
						<organization/>
					</author>
					<date year='2003' month='October'/>
				</front>
			</reference>

		</references>
		
		<!--references title="Informative References">
		</references-->
	
		
		<section anchor="Appendix1" title="Examples">
			<t>In this section, some example network topologies are depicted, using the DFF mechanism for data forwarding. In these examples, it is assumed that the underlying routing protocol provides a list of neighbors of each node, and a routing table with one or more next hops to a destination, if the topology provides a path from the node to the destination.
			</t>
			
			<section anchor="example1" title="Example 1: Normal Delivery">
				<t>
					<xref target="example1_fig"/> depicts a network topology with seven nodes A to G, with links between them as indicated by lines. It is assumed that node A sends a packet to G, through B and D, according to the underlying routing protocol.
					
					<figure anchor="example1_fig" title="Example 1: normal delivery">
						<artwork align="center"><![CDATA[
                  +---+
              +---+ D +-----+
              |   +---+     |
      +---+   |             |
  +---+ B +---+             |
  |   +---+   |             |
+-+-+         |   +---+   +-+-+
| A |         +---+ E +---+ G +
+-+-+             +---+   +-+-+
  |   +---+                 |
  +---+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					If no link fails in this topology, and no loop occurs, then DFF will not modify the usual data forwarding mechanism. Each node adds a Processed Tuple for the incoming packet, and selects the next hop according to <xref target="getnexthop"/>, i.e. it will first select the next hop for node G as determined by the underlying routing protocol.
				</t>
			</section>
			
			<section anchor="example2" title="Example 2: Forwarding with Link Failure">
				<t>
					<xref target="example2_fig"/> depicts the same topology as the Example 1, but both links between B and D and between B and E are unavailable (e.g. because of wireless link characteristics). 
					
					<figure anchor="example2_fig" title="Example 2: link failure">
						<artwork align="center"><![CDATA[
                  +---+
              XXX-+ D +-----+
              X   +---+     |
      +---+   X             |
  +---+ B +---+             |
  |   +---+   X             |
+-+-+         X   +---+   +-+-+
| A |         XXXX+ E +---+ G +
+-+-+             +---+   +-+-+
  |   +---+                 |
  +---+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					When B receives the packet from node a, it adds a Processed Tuple, and then tries to forward the packet to D. Once B detects that the packet cannot be successfully delivered to D because it does not receive link layer ACKs, it will follow the procedures listed in <xref target="missed_ACK"/>, by setting the DUP flag to 1, selecting E as new next hop, adding E to the list of next hops in the Processed Tuple, and then forwarding the packet to E.
				</t>
					
				<t>
					As the link to E also fails, B will again follow the procedure in <xref target="missed_ACK"/>. As all possible next hops (D and E) are listed in the Processed Tuple, B will set the RET flag in the packet and return it to A.
				</t>
					
				<t>
					A determines that it already has a Processed Tuple for the returned packet, reset the RET flag of the packet and select a new next hop for the packet. As B is already in the list of next hops in the Processed Tuple, it will select C as next hop and forward the packet to it. C will then forward the packet to F, and F delivers the packet to its destination G.
				</t>
			</section>
			
			
			<section anchor="example3" title="Example 3: Forwarding with Missed Link Layer Acknowledgment">
				<t>
					<xref target="example3_fig"/> depicts the same topology as the Example 1, but the link layer acknowledgments from C to A are lost (e.g. because the link is uni-directional). It is assumed that A prefers a path to G through C and F.
					
					<figure anchor="example3_fig" title="Example 3: missed link layer acknowledgment">
						<artwork align="center"><![CDATA[
                  +---+
              +---+ D +-----+
              |   +---+     |
      +---+   |             |
  +---+ B +---+             |
  |   +---+   |             |
+-+-+         |   +---+   +-+-+
| A |         +---+ E +---+ G +
+-+-+             +---+   +-+-+
  .   +---+                 |
  +...+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					While C successfully receives the packet from A, A does not receive the ACK and assumes the packet has not been delivered to C. Therefore, it sets the DUP flag of the packet to 1, in order to indicate that this packet is a duplicate. Then, it forwards the packet to B.
				</t>

			</section>
			
			
			
			<section anchor="example4" title="Example 4: Forwarding with a Loop">
				<t>
					<xref target="example4_fig"/> depicts the same topology as the Example 1, but there is a loop from D to A, and A sends the packet through B and D.
					
					<figure anchor="example4_fig" title="Example 4: loop">
						<artwork align="center"><![CDATA[
  +-----------------+
  |                 |
  |               +-+-+
  |           +---+ D +
  |           |   +---+
 \|/  +---+   |
  +---+ B +---+
  |   +---+   |
+-+-+         |   +---+   +-+-+
| A |         +---+ E +---+ G +
+-+-+             +---+   +-+-+
  |   +---+                 |
  +---+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					When A receives the packet through the loop from D, it will find a Processed Tuple for the packet. Node A will set the RET flag and return the packet to D, which in turn will return it to B. B will then select E as next hop, which will then forward it to G.
				</t>
			</section>
			
		</section>
		
	
	
	</back>
</rfc>
