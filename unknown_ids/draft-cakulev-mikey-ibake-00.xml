<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY rfc3830 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3830.xml'>
    <!ENTITY rfc3711 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml'>
    <!ENTITY rfc4738 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4738.xml'>
    <!ENTITY rfc4650 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4650.xml'>
    <!ENTITY rfc4120 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml'>
    <!ENTITY rfc4563 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4563.xml'>
    <!ENTITY rfc5091 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5091.xml'>
    <!ENTITY rfc5408 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5408.xml'>
    <!ENTITY rfc5409 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5409.xml'>
     <!ENTITY I-D.ietf-msec-mikey-ecc SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-msec-mikey-ecc-03">
]>

<!--<rfc category="info" ipr="full3978" category="std" docName="draft-cakulev-mikey-ibake-00.txt"> -->
<rfc ipr="pre5378Trust200902" category="std" docName="draft-cakulev-mikey-ibake-00.txt">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

    <front>
      <title abbrev='MIKEY-IBAKE'>
MIKEY-IBAKE: Identity-Based Mode of Key Distribution
                 in Multimedia Internet KEYing (MIKEY)
      </title>
      <author initials='V.' surname='Cakulev' fullname='Violeta Cakulev'>
	<organization>Alcatel Lucent</organization>

	<address>
	  <postal>
	    <street>600 Mountain Ave.</street>
	    <street>3D-517</street>
	    <city>Murray Hill</city> <region>NJ</region> <code>07974</code>
	    <country>US</country>
	  </postal>

	  <phone>+1 908 582 3207</phone>
	  <email>cakulev@alcatel-lucent.com</email>
	</address>
      </author>

      <author initials='G.' surname='Sundaram'  fullname='Ganapathy Sundaram'>
	<organization>Alcatel Lucent</organization>

	<address>
	  <postal>
	    <street>600 Mountain Ave.</street>
	    <street>3D-517</street>
	    <city>Murray Hill</city> <region>NJ</region> <code>07974</code>
	    <country>US</country>
	  </postal>

	  <phone>+1 908 582 3209</phone>
	  <email>ganeshs@alcatel-lucent.com</email>
	</address>
      </author>

        <date/>
        <abstract><t>
	    This document describes a key management protocol variant for the
   multimedia Internet keying (MIKEY) protocol which relies on
   trusted key management service. In particular, this variant utilizes
   Identity Based Authenticated Key Exchange framework which allows the
   participating clients to perform mutual authentication and derive a 
	    session key  in an 'asymmetric
   identity based encryption' framework. This framework, in addition to
   providing mutual authentication, eliminates the key escrow problem that 
	    is common in standard Identity Based Encryption while 
	    simultaneously providing  perfect forward and backwards secrecy.
	</t></abstract>
    </front>

    <middle>

      <section title="Introduction">
        
   <t> Multimedia Internet Keying (MIKEY) 
     <xref target="RFC3830"/> specification describes
     several modes of key distribution solution that address multimedia
     scenarios using pre-shared keys, public keys, and optionally a
     Diffie-Hellman key exchange. Following MIKEY specification, multiple 
     extensions of MIKEY have been specified.</t>

   <t>Recently, it has been noted that the currently defined MIKEY modes
     are insufficient to address deployment scenarios in which
     security systems serve a large number of users. In these scenarios, 
     a key management service is often preferred. With such a service in place, 
     it would be possible for a user to request credentials for any other 
     user when they are needed. Some proposed solutions rely on Key Management Services (KMS) in 
     the network that create, distribute, and manage keys in a real time. Due to this broad 
     functionality, key management services will have to be online, maintain high 
     availability, and have to be networked across operator boundaries.
     In some applications, this architecture creates a huge burden on 
     operators to install, and manage these boxes. Moreover, since the keys 
     are created and distributed by the KMS, these servers are de-facto 
     escrow points leading to increased vulnerability and operational discomfort 
     on the part of end-users. In fact, this feature is a violation 
     of the “end-to-end security” design goals in Section 2.2 of 
     <xref target="RFC3830"/>.</t>

   <t>Here, a solution is described in which KMS’s are offline servers that 
     communicate with end-user clients periodically (e.g., once a month) to 
     create a secure identity-based encryption framework, while the on-line 
     transactions between the end-user clients (for media plane security) are 
     based on an Identity Based Authenticated Key Exchange framework which 
     allows the participating clients to perform mutual authentication 
     and derive a session key in an 
     ‘asymmetric identity based encryption’ framework. This framework, in 
     addition to eliminating passive escrow, allows for end-user clients 
     to mutually authenticate each other (at the IMS media plane layer) and 
     provides perfect forwards and backwards secrecy. Observe that the KMS 
     to client exchange is used sparingly (e.g., once a month) – hence the 
     KMS is no longer required to be a high availability server, and in 
     particular different KMS’s don’t have to communicate with each other 
     (across operator boundaries). Moreover, given asymmetric identity-based 
     encryption framework is used, the need for costly Public Key 
     Infrastructure (PKI) and all the operational costs of certificate 
     management and revocation is eliminated. This is achieved by 
     concatenating public keys with a date field, thereby ensuring 
     corresponding private keys change with the date and more importantly 
     limiting the damage due to loss of a private key to just that date. 
     The granularity in the date field, is a matter of security policy 
     and deployment scenario. For instance, an operator may choose to use 
     one key per day and hence the KMS may issue private keys for a whole 
     month (more generally subscription cycle) at the beginning of a 
     subscription cycle.</t>
   <t>Additionally, various IMS 
     media plane features are securely supported – this includes secure 
     forking, retargeting, deferred delivery and pre-encoded content. 
	    </t>
	    </section>

        <section title="Requirements notation">
            <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
            "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
            and "OPTIONAL" in this document are to be interpreted as
            described in <xref target="RFC2119"/>.</t>

	    <section title="Definitions and Notation">

	      <t>IBE Encryption: Identity-based encryption (IBE) is a 
		public-key encryption technology
   that allows a public key to be calculated from an identity, and the
   corresponding private key to be calculated from the public key. 
	      IBE framework is defined in <xref target="RFC5091"/>, 
		<xref target="RFC5408"/> and <xref target="RFC5409"/>.</t>


		<t>(Media) session: The communication session intended to be 
		  secured by the MIKEY-IBAKE provided key(s).</t>

   
<t>
            <figure>
              <artwork><![CDATA[
   E(k, x)  Encryption of x with the key k
   K_PUBx   Public Key of x
   [x]      x is optional
   {x}      Zero or more occurrences of x
   (x)      One or more occurrences of x
   ||       Concatenation
   |        OR (selection operator)
]]></artwork>
            </figure>
</t>
		       </section>

	    <section title="Abbreviations">
	      <t><list style="hanging">
		  <t hangText="EC"> Elliptic Curve</t>
		  <t hangText="ESK:"> Encrypted Secret Key</t>
		  <t hangText="IBE:"> Identity Based Encryption</t>
		  <t hangText="I:"> Initiator</t>
		  <t hangText="IBAKE:"> Identity Based Authenticated Key 
		    Exchange</t>
		 <t hangText="IDi:"> Initiator's Identity </t>
		 <t hangText="IDr:"> Responder's Identity </t>
		 <t hangText="KMS:"> Key Management Service</t>
		 <t hangText="K_PR:"> Private Key</t>
		 <t hangText="K_PUB:"> Public Key</t>
		 <t hangText="MAC:"> Message Authentication Code</t>
		 <t hangText="MIKEY:"> Multimedia Internet KEYing</t>
		 <t hangText="PKI:"> Public Key Infrastructure</t> 
		 <t hangText="R:"> Responder</t>
		 <t hangText="SK:"> Secret Key</t>
	      </list></t>	
	    </section>

        </section>


	<section title="Use Case Scenarios" anchor="usecases">
	  <t>This section describes some of the use case scenarios supported by 
	    MIKEY-IBAKE.</t>

	  <section title="Forking">
	    <t>Forking is the delivery of a request (e.g., SIP INVITE message) 
	      to multiple locations. This happens when a single user 
	      is registered more than once.  An example of forking is when a 
	      user has a desk phone, PC client, and mobile handset all 
	      registered with the same public identity.</t>
<t>
            <figure title="Forking" anchor="forking">
              <artwork><![CDATA[
      +---+             +-------+             +---+             +---+
      | A |             | PROXY |             | B |             | C |
      +---+             +-------+             +---+             +---+
            Request
        -------------------->      
                                   Request
			    -------------------->
                                   Request
			    ------------------------------------->
    ]]></artwork>
            </figure>
</t>

	  </section>

	  <section title="Retargeting">
	    <t>Retargeting is a scenario in which a functional element 
	      decides to redirect the call to a different 
	      destination. This decision to redirect a session may be made 
	      for different reasons by a number of different functional 
	      elements, and at different points in the establishment of 
	      the session.</t>

	    <t>There are two basic scenarios of session redirection. 
	      In scenario one, a functional element (e.g., Proxy) decides 
	      to redirect the session by passing the new destination 
	      information to the originator. As a result the originator 
	      initiates a new session to the redirected destination provided 
	      by the Proxy. For the case of MIKEY-IBAKE this 
	      means that the originator will initiate a new session with the 
	      identity of the redirected destination. This scenario is 
	      depicted in <xref target="retargeting"/> below.</t> 
<t>
            <figure title="Retargeting" anchor="retargeting">
              <artwork><![CDATA[
      +---+             +-------+             +---+             +---+
      | A |             | PROXY |             | B |             | C |
      +---+             +-------+             +---+             +---+
            Request
        -------------------->      
                                   Request
			    -------------------->
                                   Redirect
			    <--------------------
	    Redirect		       
        <-------------------
                                   Request
        ---------------------------------------------------------->
    ]]></artwork>
            </figure>
</t>

	    <t>In the second scenario, a proxy decides to redirect the 
	      session without informing the originator. A common scenario in 
	      IMS applications is one in which the S-CSCF of the destination 
	      user determines that the session is to be redirected. 
	      The user profile information obtained from the HSS by 
	      the 'Cx-pull' during registration may contain complex 
	      logic and triggers causing session redirection.</t>

	  </section>
	  
	  <section title="Deferred Delivery">
	    <t>Deferred delivery is a type of service such that the session 
	      content cannot be delivered to the destination at the time that 
	      it is being sent (e.g., the destination user is not currently 
	      online). Nevertheless, the sender expects the network to deliver 
	      the message as soon as the recipient becomes available. A 
	      typical example of deferred delivery is voicemail.</t>
	  </section>

	

  </section>

	<section title="MIKEY-IBAKE Protocol Description">
	  
	  <section title="Overview" anchor="overview">

	    <t>Most of the previously defined MIKEY modes consist of a single 
	      (or half) roundtrip between two peers.
	      MIKEY-IBAKE consists of up to three  
	      roundtrips. In the first roundtrip, users (Initiators and 
	      Responders) obtain their Private Key(s) (K_PR) from the KMS. This 
	      roundtrip can be performed at anytime, and as explained earlier 
	      takes place for example once a month (or once per subscription 
	      cycle). The second and the third 
	      roundtrip are between the Initiator and the Responder. Observe 
	      that the Key Management Service is only involved in the first 
	      roundtrip. In <xref target="example"/>, a conceptual
	      signaling diagram for the MIKEY-IBAKE mode is depicted.</t>
<t>
            <figure title="Example Message Exchange" anchor="example">
              <artwork><![CDATA[
   +---+             +------+         +------+                 +---+
   | I |             | KMS1 |         | KMS2 |                 | R |
   +---+             +------+         +------+                 +---+
       REQUEST_KEY_INIT                       REQUEST_KEY_INIT
     ------------------>                  <---------------------- 
       REQUEST_KEY_RESP                       REQUEST_KEY_RESP
     <------------------                  ---------------------->        
                               I_MESSAGE_1
     ----------------------------------------------------------->
                               R_MESSAGE_1
     <-----------------------------------------------------------
                               I_MESSAGE_2
     ----------------------------------------------------------->
                               R_MESSAGE_2
     <-----------------------------------------------------------

]]></artwork>
            </figure>
</t>

<t>The Initiator (I) wants to establish a secure media session with the
   Responder (R).  The Initiator and the Responder trust a third party, 
  the Key Management
   Services (KMS), with which they both have, or can establish, shared
   credentials.  Rather than a single KMS, several different KMSs may be
   involved, e.g. one for the Initiator and one for the Responder as shown 
  in <xref target="example"/> above. The Initiator and the Responder 
  do not share any 
 credentials, however the Initiator knows Responder's public identity.</t> 

   <t>The Initiator obtains Private Key(s) 
   from the KMS by sending a REQUEST_KEY_INIT message.  The REQUEST_KEY_INIT
   message includes Initiator's public identity(s) (if the Initiator has 
   more than one public identity it may request an Private Key for 
  every identity registered) and is protected via a MAC based on a 
  pre-shared key or
   via a signature (similar to the MIKEY-PSK and MIKEY-RSA modes).  If
   the Initiator is authorized to make the request, the KMS generates
   the requested keys, encodes them, and returns them 
   in a REQUEST_KEY_RESP message. The KMS can also select a set of IBE 
     public parameters to use in the
         subsequent steps in accordance with its local security
         policy and include them in the same message. 
     This exchange takes place periodically and 
     does not need to be performed every time an Initiator needs to 
     establish a secure connection with a Responder.</t>

   <t> The Initiator next chooses a random x and computes xP (i.e. adds P to 
itself x times), where P is a point on elliptic curve E known to all users. 
The Initiator uses the Responder's public identity to generate Responder's 
public key (e.g., K_PUBr=H1(IDr)||date), where Hi is hash function known to all 
     users, and the granularity in date is a matter of security policy and 
     known publicly). 
The Initiator then uses this generated public key to encrypt xP, IDi and IDr and includes 
this encrypted information in a I_MESSAGE_1 message,
   which is sent to the Responder. The encryption is Identity Based Encryption 
(IBE) as specified in <xref target="RFC5091"/> and <xref target="RFC5408"/>. 
The Responder in turn IBE-decrypts the received  message using its private key for that date, chooses 
random y and 
computes 
yP. Next, the Responder uses Initiator's public identity to generate 
Initiator's public key (e.g., K_PUBi=H1(IDi)||date) and IBE-encrypts (IDi, IDr, xP, yP) 
     using K_PUBi, 
and includes it in R_MESSAGE_1 message sent to the Initiator. At 
this point the Responder is able to generate the session key as 
xyP. This session key is then used to generate TGK as specified in 
 <xref target="Ksess"/>.</t>

    <t> The Initiator upon receiving and IBE-decrypting R_MESSAGE_1 message 
sends I_MESSAGE_2 message to the Responder, including IBE-encrypted IDi, IDr  
      and yP. At 
this point the Initiator is able to generate the same session key  
      as xyP. The Responder sends a R_MESSAGE_2 message 
      to the Initiator as verification. </t>

<t>  The above described is the most typical use case; in
  <xref target="usecases"/>, some alternative use cases are discussed. </t>

<t>MIKEY-IBAKE is based on <xref target="RFC3830"/>, therefore the same terminology,
   processing and considerations still apply unless otherwise stated.
   Diffie-Hellman values and keys exchanged in I_MESSAGE/R_MESSAGE are IBE 
  encrypted as specified in <xref target="RFC5091"/> and 
  <xref target="RFC5408"/>, while the keys exchanged 
  in KEY_REQUES_INIT/KEY_REQUEST_RESPONSE are encrypted as specified in 
   <xref target="RFC3830"/>.  In all exchanges encryption is only applied to the keys and 
  key components and
   not to the entire messages.</t>


	  </section>
	<section title="Message Exchanges and Processing">
	  <section title="REQUEST_KEY_INIT/REQUEST_KEY_RESP Message Exchange">

   <t>This exchange is used by a user (e.g. Initiator or Responder) to 
     request private keys from a trusted Key Management Service, with which the 
     user have pre-shared credentials.  A full roundtrip is
   required for a user to receive keys.  As
   this message must ensure the identity of the Initiator to the KMS, it
   is protected via a MAC based on a pre-shared key or via a signature.
   The initiation message REQUEST_KEY_INIT comes in two variants
   corresponding to the pre-shared key (PSK) and public-key encryption
   (PKE) methods of <xref target="RFC3830"/>.  The response message 
     REQUEST_KEY_RESP is the
   same for the two variants and SHALL be protected by using the pre-
   shared/envelope key indicated in the REQUEST_KEY_INIT message.</t>

<t>
            <figure>
              <artwork><![CDATA[
   Initiator/Responder                    KMS

   REQUEST_KEY_INIT_PSK =          ---->
   HDR, T, RAND, (IDi/r),
   IDkms, [IDpsk], [KEMAC], V      <----  REQUEST_KEY_RESP =
				              HDR, T, [IDi/r], [IDkms], 
				              KEMAC, V
                                              

   REQUEST_KEY_INIT_PKE =          ---->
   HDR, T, RAND, (IDi/r),
      {CERTi/r}, IDkms,            <----  REQUEST_KEY_RESP =
      [KEMAC], [CHASH],                       HDR, T, [IDi/r], [IDkms], 
      PKE, SIGNi/r, V                         KEMAC, V
]]></artwork>
            </figure>
</t>


   <section title="Components of the REQUEST_KEY_INIT Message">
     <t>The main objective of the REQUEST_KEY_INIT message is for a user to
       request one or more Private Keys (K_PR) from the KMS. The user may 
       request
       a K_PR for each public identity it possesses. </t>  

     <t>The REQUEST_KEY_INIT message MUST always include the Header (HDR),
       Timestamp (T), and RAND payloads. The user SHALL select a random CSB ID 
       (Crypto Session Bundle ID) and include it in the CSB ID field of the 
       Header. The user SHALL
       set the #CS field to '0' since CS (Crypto Session(s))
       SHALL NOT be handled. The CS ID map
       type SHALL be the "Empty map" as defined in  <xref target="RFC4563"/>.
     </t>

     <t>IDi/r contains the identity of the user. Since the user may 
       have multiple 
       identities, multiple IDi/r fields may appear in the message.</t>

     <t>IDkms SHALL be included.</t>

     <t>The KEMAC payload SHOULD be used only when the user needs to use
       specific keys. Otherwise, this payload SHALL not be used.</t>

     <section title="Components of the REQUEST_KEY_INIT_PSK Message">
       <t>The IDpsk payload MAY be used to indicate the pre-shared key used.</t>

       <t>The last payload SHALL be a Verification payload (V) where the
	 authentication key (auth_key) is derived from the pre-shared key (see
	 <xref target="RFC3830"/> Section 4.1.4 for key derivation 
	       specification).</t>

     </section>

     <section title="Components of the REQUEST_KEY_INIT_PKE Message">
       <t>CERTi SHOULD may be included.  If a certificate chain is to be
   provided, each certificate in the chain MUST be included in a
   separate CERT payload.</t>

   <t>PKE payload contains the encrypted envelope key: 
     PKE = E(PKkms, env_key).  It
   is encrypted using the KMS's public key (PKkms).  If the KMS
   possesses several public keys, the user can indicate the key
   used in the CHASH payload.</t>

   <t>SIGNi/r is a signature covering the entire MIKEY message, using the
   Initiator's signature key.</t>


     </section>
</section>
     <section title="Processing of the REQUEST_KEY_INIT Message">
       <t>If the KMS can correctly parse the received message, and the
	 user is authorized to receive the requested Private Key(s),
	 the KMS MUST send a REQUEST_KEY_RESP
   message.  In case of a REQUEST_KEY_INIT_PKE message, the KMS MUST ensure
   that the IDcert is equal to the identity specified in the
   certificate.</t>

   <t>If the KMS cannot correctly parse the received message, or the
   user is not authorized to receive the requested Private Keys, the KMS
   SHOULD send an appropriate Error message.</t>

     </section>
     <section title="Components of the REQUEST_KEY_RESP Message">
     <t>The Header payload SHOULD be identical to the Header payload in the
       REQUEST_KEY_INIT message with the exception of data type, next payload,
       and V flag.  The V flag can be set to anything as it has no meaning
       in this context.</t>

     <t>The timestamp type and value SHALL be identical to the one used in
       the REQUEST_KEY_INIT message.</t>
<t>
            <figure>
              <artwork><![CDATA[
                   KEMAC = E(encr_key, {ID || K_PR})
]]></artwork>
            </figure>
</t>

    <t>The KEMAC payload SHOULD use the NULL authentication algorithm, as a
      MAC is included in the V payload.  Depending on the type of
      REQUEST_KEY_INIT message, either the pre-shared key or the envelope key
      SHALL be used to derive the encr_key.</t>

   <t>The last payload SHALL be a Verification payload (V).  Depending on
   the type of REQUEST_KEY_INIT message, either the pre-shared key or the
   envelope key SHALL be used to derive the auth_key.</t>


       </section>

     <section title="Processing of the REQUEST_KEY_RESP Message">

       <t>If the Initiator/Responder can correctly parse the received message, 
	 the received session information SHOULD be stored.  Otherwise
	 the Initiator/Responder SHOULD silently discard the message and 
	 abort the protocol.</t>

     </section>
</section>
      <section title="I_MESSAGE/R_MESSAGE Message Exchanges">
	<t>This exchange is used for Initiator and Responder to mutually 
	  authenticate each other and to exchange ECC Diffie-Hellman values 
	  used to generate TGK. These exchanges are
	  modeled after the pre-shared key mode , with the exception 
	  that the Elliptic Curve Diffie-Hellman values and Secret Keys (SKs) 
	  are encoded 
	  in IBAKE and ESK payloads instead of a KEMAC payload.   
	  Two full roundtrips are required for 
	  this exchange to successfully complete. The messages are preferably 
	  included in the session setup signaling (e.g. SIP INVITE).</t>

<t>
            <figure>
              <artwork><![CDATA[
Initiator                               Responder

   I_MESSAGE_1 =                    ---->
   HDR, T, RAND, IDi, IDr,
      IBAKE, [ESK], V               <----  R_MESSAGE_1 =
                                             HDR, T, IDi,
                                             IDr, IBAKE, V

   I_MESSAGE_2 =                    ---->
   HDR, T, RAND, IDi, IDr,
      IBAKE, [ESK], V               <----  R_MESSAGE_2 =
                                           HDR, T, [IDi], [IDr],
                                           [IBAKE], V

]]></artwork>
            </figure>
</t>
      

      <section title="Components of the I_MESSAGE_1 Message">
	<t>The I_MESSAGE_1 message MUST always include the Header (HDR),
	  Timestamp (T), and RAND payloads.  The CSB ID (Crypto Session 
	  Bundle ID) SHALL be randomly selected by the Initiator.  As the
	  R_MESSAGE_1 message is mandatory, the Initiator indicates with 
	  the V flag that a verification message is expected.</t>

	<t>The IDi and IDr payloads SHALL be included.</t>

	<t>The IBAKE payload 
	  contains Initiator's Identity and EC Diffie-Hellman values (ECCPTi), 
	  and 
	  Responder's Identity all encrypted using Responder's 
	  public key 
	  (i.e. encr_key = K_PUBr) as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
                   IBAKE = E(encr_key, IDi || ECCPTi || IDr)
]]></artwork>
            </figure>
</t>
   <!--    <t>The details of EC Diffie-Hellman value generation are provided 
	  in Section 5.</t> -->
	
	<t>Optionally, Encrypted Secret Key (ESK) payload MAY be included.  
	  If included, ESK contains an identity and a Secret Key (SK) 
	  encrypted using intended Responder's Public Key (i.e. encr_key = K_PUBr).</t>
<t>
            <figure>
              <artwork><![CDATA[
                   ESK = E(encr_key, ID || SK)
]]></artwork>
            </figure>
</t>
 
	<t>The last payload SHALL be a Verification payload (V) where the
	  authentication key (auth_key) is derived as specified in 
	  <xref target="Kmikeymes"/>.</t>
			      
     </section>

      <section title="Processing of the I_MESSAGE_1 Message">
	<t>The parsing of I_MESSAGE_1 message SHALL be done as in 
	  <xref target="RFC3830"/>. If the received message is correctly 
	  parsed, the Responder shall use the Private Key (K_PRr) 
	  corresponding to the 
	  received IDr to decrypt the IBAKE payload. If the message contains 
	  encrypted 
	  ESK payload, the Responder SHALL decrypt the SK and use it to decrypt 
	  the received IBAKE payload. Otherwise, if the Responder is not able 
	  to 
	  decrypt the IBAKE payload, 
	  the Responder SHALL indicate it to the Initiator 
	  by including only its own EC Diffie-Hellman value (ECCPTr) in the 
	  next message it sends to the 
	  Initiator.</t>

	  <t>If the received message cannot be 
	  correctly parsed, the Responder SHOULD silently discard the 
	  message and abort the protocol.</t>



	</section>

<section title="Components of the R_MESSAGE_1 Message">
	<t>The Header payload SHOULD be identical to the Header payload in the
	  I_MESSAGE_1 message with the exception that the V flag can be set
	  to anything as it has no meaning in this context.</t>

	<t>The timestamp type and value SHALL be identical to the one used in
	  the I_MESSAGE_1 message.</t>



	<t>The IDi and IDr payloads SHALL be included.</t>

	<t>The Responder's IBAKE payload
	  contains the Initiator’s EC Diffie-Hellman value (ECCPTi) 
	  received in I_MESSAGE_1 (if successfully 
	  decrypted), and Initiator’s EC Diffie-Hellman value generated by 
	  Responder (ECCPTr), as well as corresponding Initiator and 
	  Responder's 
	  identities. If the responder is unable to decrypt the IBAKE payload received in I_MESSAGE_1, the Responder SHALL include only its own  EC Diffie-Hellman value (ECCPTr). The IBAKE payload in R_MESSAGE_1 is encrypted using Initiator's public key 
	  (i.e. encr_key = P_PUBi) as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
        IBAKE = E(encr_key, IDi || {ECCPTi} || IDr || ECCPTr)
]]></artwork>
            </figure>
</t>
  <!--     <t>The details of EC Diffie-Hellman value generation are provided 
	  in Section 5.</t> -->

	
	<t>The last payload SHALL be a Verification payload (V) where the
	  authentication key (auth_key) is derived as specified in 
	  <xref target="Kmikeymes"/>.</t>
			      
     </section>

      <section title="Processing of the R_MESSAGE_1 Message">
	<t>The parsing of R_MESSAGE_1 message SHALL be done as in 
	  <xref target="RFC3830"/>. If the received message is correctly 
	  parsed, the Initiator shall use the Private Key corresponding to the 
	  received IDi to decrypt the IBAKE payload. If the ECCPTi sent in 
	  I_MESSAGE_1 is not 
	  present in the received IBAKE payload (e.g., the Responder is 
	  currently 
	  offline and the R_MESSAGE_1 is received from Responder's mailbox), 
	  it SHALL be included again in the next message, I_MESSAGE_2. 
	  In this case I_MESSAGE_2  
	  SHALL also contain a ESK payload encrypted using Responder's 
	  K_PUB.</t>

	<t>If the received message cannot be 
	  correctly parsed, the Initiator SHOULD silently discard the 
	  message and abort the protocol.</t>

	</section>

 <section title="Components of the I_MESSAGE_2 Message">
	<t>The I_MESSAGE_2 message MUST always include the Header (HDR),
	  Timestamp (T), and RANDi payloads.  The CSB ID (Crypto Session 
	  Bundle ID) and RAND payloads SHALL be the same is in the corresponding I_MESSAGE_1.  
	  As the R_MESSAGE_2 message is mandatory, the Initiator indicates with 
	  the V flag that a verification message is expected.</t>

	<t>The IDi and IDr payloads SHALL be included. The IDr payload SHALL 
	  be the same as the IDr payload received in the R_MESSAGE_1.</t>

	<t>The Initiator's IBAKE payload SHALL
	  contain Initiator's EC Diffie-Hellman value (ECCPTi) is the ECCPTi was not received in R_MESSAGE_1. Otherwise ECCPTi SHALL NOT be included. The IBAKE payload in I_MESSAGE_2 SHALL contain  
	  the Initiator's and Responder's identities as well as Responder's EC Diffie-Hellman value received in message R_MESSAGE_1. IBAKE payload SHALL be 
	  encrypted using Responder's 
	  public key (i.e. encr_key = K_PUBr) as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
          IBAKE = E(encr_key, IDi || {ECCPTi} || IDr || ECCPTr)
]]></artwork>
            </figure>
</t>
 
<t>Optionally, Encrypted Secret Key (ESK) payload can be included. 
  ESK SHALL be included in case of deferred delivery.
	  If included, it contains an identity and Initiator generated
  Secret Key (SK) 
	  encrypted using intended recipient Public Key (PK) 
	  (i.e. encr_key = P_PUB) as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
                   ESK = E(encr_key, ID || SK)
]]></artwork>
            </figure>
</t>
 
	<t>The last payload SHALL be a Verification payload (V) where the
	  authentication key (auth_key) is derived as specified in 
	   <xref target="Kmikeymes"/>.</t>
			      
     </section>

      <section title="Processing of the I_MESSAGE_2 Message">
	<t>The parsing of I_MESSAGE_2 message SHALL be done as in 
	  <xref target="RFC3830"/>. If the received message is correctly 
	  parsed, the Responder shall use the K_PRr corresponding to the 
	  received IDr to decrypt the IBAKE payload. If ESK is received, 
	  the responder 
	  SHALL store it for the future use.</t>
	
	<t>If the received message cannot be 
	  correctly parsed, the Responder SHOULD silently discard the 
	  message and abort the protocol.</t>
	</section>

<section title="Components of the R_MESSAGE_2 Message">
	<t>The Header payload SHOULD be identical to the Header payload in the
	  I_MESSAGE_2 message with the exception that the V flag can be set
	  to anything as it has no meaning in this context.</t>

	<t>The timestamp type and value SHALL be identical to the one used in
	  the I_MESSAGE_2 message.</t>

	<t>The IDi and IDr payloads SHOULD be included.</t>

	<t>Optionally, the Responder's IBAKE  
	  payload MAY be included. The IBAKE payload is included in the case of 
	  deferred delivery. If included, it contains
	  Initiator's EC Diffie-Hellman value (ECCPTi), 
	  and the Initiator's identity, 
	  encrypted using Initiator's 
	  public key (i.e. encr_key = K_PUBi) as follows:</t>
<t>
            <figure>
              <artwork><![CDATA[
                 IBAKE = E(encr_key, IDi || ECCPTi)
]]></artwork>
            </figure>
</t>

	<t>The last payload SHALL be a Verification payload (V) where the
	  authentication key (auth_key) is derived as specified in
	  <xref target="Kmikeymes"/>.</t>
			      
     </section>

      <section title="Processing of the R_MESSAGE_2 Message">
	<t>The parsing of R_MESSAGE_2 message SHALL be done as in 
	  <xref target="RFC3830"/>. If the received message is correctly 
	  parsed, the Responder shall use the K_PRr corresponding to the 
	  received IDr to decrypt the IBAKE payload.</t>

	<t>If the received message cannot be 
	  correctly parsed, the Initiator SHOULD silently discard the 
	  message and abort the protocol.</t>

	</section>
	</section>
	</section>			       
	</section>
	

	<section title="Key Derivation">
	  <t>The keys used in REQUEST_KEY_INIT/REQUEST_KEY_RESP 
	    exchange are derived from the pre-shared key or the envelope 
	    key as specified in <xref target="RFC3830"/>.  As crypto
   sessions are not handled in this exchange, further keying material (i.e TEKs)
   for this message exchanges SHALL NOT be derived.</t>

	  <section title="Generating Keys from the Session Key" anchor="Ksess">
	    <t>As stated above, the session key xyP is generated using 
	      exchanged key components, where x and y are randomly chosen 
	      by Initiator and Responder. The session key as a point on an 
	      elliptic curve is then 
	      converted into octet string  as specified 
	      in <xref target="SEC1"/>. This octet string is used as TGK. 
	      Finally, 
	      the keys (e.g., TEK) are generated
   from TGK as specified in <xref target="RFC3830"/>.

</t>
 
	    </section>
	  <section title="Generating Keys for MIKEY Messages" anchor="Kmikeymes">
	    
	    <t> The keys for MIKEY messages are used to protect the MIKEY
   messages exchanged between the Initiator and Responder (i.e., I_MESSAGE 
	      and R_MESSAGE).  In the REQUEST_KEY_INIT/REQUEST_KEY_RESP 
	      exchange, the
   key derivation SHALL be done exactly as in <xref target="RFC3830"/>.</t>

	    <t>The initiator and Responder SHALL convert their respective 
	       EC Diffie-Hellman values (i.e., ECCPTi and ECCPTr) to obtain 
	      the MIKEY 
	      Protection Key (MPK) and then use this MPK to derive keys to 
	      protect I_MESSAGE and R_MESSAGE messages.</t>
<t>
            <figure>
              <artwork><![CDATA[
   inkey      : MPK
   inkey_len  : bit length of the MPK
   label      : constant || 0xFF || csb_id || RAND
   outkey_len : desired bit length of the output key
]]></artwork>
            </figure>
</t>
   <t>where the constants are as defined in <xref target="RFC3830"/>.  
     </t>

	     

	    </section>

	  <section title="CSB Update">
	    <t>Similar to <xref target="RFC3830"/>, MIKEY-IBAKE provides 
	      means for updating the
   CSB (Crypto Session Bundle), e.g. transporting new EC Diffe-Hellman values
	      or adding
   new crypto sessions.  The CSB updating is done by executing the
   exchange of I_MESSAGE_1/R_MESSAGE_1. The CSB updating MAY be started by
   either the Initiator or the Responder.</t>

<t>
            <figure>
              <artwork><![CDATA[
   Initiator                               Responder

   I_MESSAGE_1 =                 ---->
   HDR, T, [IDi], [IDr],
      [IBAKE], V                 <----     R_MESSAGE_1 =
                                           HDR, T, [IDi], [IDr], V


   Responder                               Initiator

   I_MESSAGE_1 =                 ---->
   HDR, T, [IDr], [IDi],
      [IBAKE], V                 <----  R_MESSAGE_1 =
                                           HDR, T, [IDi], V
]]></artwork>
            </figure>
</t>
<t>The new message exchange MUST use the same CSB ID as the initial
   exchange, but MUST use a new timestamp. Other 
   payloads that were provided in the initial exchange SHOULD NOT be
   included.  New RANDs MUST NOT be included in the message exchange
   (the RANDs will only have effect in the initial exchange).</t>

   <t>IBAKE payload with new EC Diffie-Hellman values SHOULD be included. 
     If new EC Diffie-Hellman values  are
     being exchanged during CSB updating, both messages SHALL be protected 
     with keys
   derived from EC Diffie-Hellman values exchanged as specified in 
     <xref target="Kmikeymes"/>.
     Otherwise, if new EC Diffie-Hellman values are not being exchanged 
     during CSB update 
     exchange, both messages
   SHALL be protected with the keys that protected the I_MESSAGE/R_MESSAGE
   messages in the initial exchange.  
</t>  


	    </section>

	  <section title="Generating MAC and Verification Message">
	    <t>Authentication tag in all MIKEY-IBAKE  messages is generated 
	      as described in <xref target="RFC3830"/>. The MPK as described 
	      above is used to derive the auth_key. The MAC/Signature in the 
	      V/SIGN payloads covers the entire MIKEY
   message, except the MAC/Signature field itself.  The identities (not
   whole payloads) of the involved parties MUST directly follow the
   MIKEY message in the Verification MAC/Signature calculation.  Note
   that in the I_MESSAGE/R_MESSAGE exchange, ID_r in R_MESSAGE_1
   MAY not be the same as that appearing in I_MESSAGE_1.
</t>
	</section>
	</section>



	<section title="Payload Encoding">

	  <t>This section does not describe all the payloads that are used 
	    in the new message types.  It describes in detail the new IBAKE and
	    ESK
	    payloads and in less detail the payloads for which changes has 
	    been made compared to <xref target="RFC3830"/>. For a detailed 
	    description of 
	    the MIKEY payloads, see <xref target="RFC3830"/>.</t>

	  <section title="Common Header Payload (HDR)">

	    <t>For the Common Header Payload, new values are added to the 
	      data type and the next payload name spaces.</t>
<t>
	    <list style='symbols'>
                <t>Data type (8 bits): describes the type of message.</t>
                
            </list>
</t>
<texttable title='Data type (Additions)' anchor='DTtable'>
<ttcol align='center'>Data Type</ttcol>
<ttcol align='center'>Value</ttcol>
<ttcol align='center'>Comment</ttcol>
<c>REQUEST_KEY_PSK</c>
<c>TBD1</c>
<c>Secret Keys request message (PSK)</c>
<c>REQUEST_KEY_PKE</c>
<c>TBD2</c>
<c>Secret Keys request message (PKE)</c>
<c>REQUEST_KEY_RESP</c>
<c>TBD3</c>
<c>Secret Keys response message</c>
<c>I_MESSAGE_1</c>
<c>TBD4</c>
<c>First Initiator's message</c>
<c>R_MESSAGE_1</c>
<c>TBD5</c>
<c>First Responder's message</c>
<c>I_MESSAGE_2</c>
<c>TBD6</c>
<c>Second Initiator's message</c>
<c>R_MESSAGE_2</c>
<c>TBD7</c>
<c>Second Responder's message</c>
</texttable>


<t>
	    <list style='symbols'>
                <t>Next payload (8 bits): identifies the payload that is 
		  added after this payload.</t>
                
            </list>
</t>
<texttable title='Next Payload (Additions)' anchor='NPtable'>
<ttcol align='center'>Next Payload</ttcol>
<ttcol align='center'>Value</ttcol>
<ttcol align='center'>Section</ttcol>
<c>IBAKE</c>
<c>TBD8</c>
<c><xref target="IBAKEpld"/></c>
<c>ESK</c>
<c>TBD9</c>
<c><xref target="ESKpld"/></c>
<c>SK</c>
<c>TBD10</c>
<c><xref target="SKpld"/></c>
</texttable>

<t>
	    <list style='symbols'>
                <t>V (1 bits): flag to indicate whether a response message is
		  expected or not (this only has meaning when it is set in an
		  initiation message).  If a response is required, the V flag 
		  SHALL always be set to 1 in the
		  initiation messages and the receiver of the initiation message
		  (Responder or KMS) SHALL ignore it.</t>

		<t>#CS (8 bits): indicates the number of crypto sessions 
		  that will be handled within the CBS.  It SHALL be set to 0 
		  in the Request Key exchange, as crypto sessions SHALL NOT
		  be handled.</t>

		<t>CS ID map type (8 bits): specifies the method of uniquely 
		  mapping crypto sessions to the security protocol sessions.  
		  In the Request Key exchange, the CS ID map type SHALL be
		  the "Empty map" (defined in <xref target="RFC4563"/>) as 
		  crypto sessions SHALL NOT be handled.</t>

</list>
</t>

      <section title="IBAKE Payload" anchor="IBAKEpld">
	<t>The IBAKE payload contains IBE encrypted (see 
	  <xref target="RFC5091"/>) and <xref target="RFC5408"/>) for details
	  about IBE encryption) Initiator and Responder's Identities and 
	  EC Diffie-Hellman
	  sub-payloads (see <xref target="ECDHpld"/> for the definition of 
	  EC Diffie-Hellman
	  sub-payload). It may contain one or more EC Diffie-Hellman
	  sub-payloads and 
	  its associated identities. The last EC Diffie-Hellman or Identity
	  sub-payload has its
	  Next payload field set to Last payload.</t>

  
<t>
            <figure>
              <artwork><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ! Next payload  ! Encr data len                 !  Encr data    !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                        Encr data                              ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ]]></artwork>
            </figure>
</t>
<t>
	    <list style='symbols'>
	      <t>Next payload (8 bits): identifies the payload that is added 
		after this payload.</t>

	      <t>Encr data len (16 bits): length of Encr data (in bytes).</t>

	      <t>Encr data (variable length): the encrypted EC Diffie-Hellman sub-payloads 
		(see <xref target="ECDHpld"/>).</t>

</list>
</t>
      </section>

      <section title="Encrypted Secret Key (ESK) Payload"  anchor="ESKpld">
	<t>The Encrypted Secret Key payload contains IBE encrypted (see 
	  <xref target="RFC5091"/>) and <xref target="RFC5408"/>) for details
	  about IBE encryption) Secret Key sub-payload and its associated 
	  identity (see  <xref target="SKpld"/> for the definition of the 
	  Secret Key sub-payload).</t>
<t>
            <figure>
              <artwork><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ! Next payload  ! Encr data len                 !  Encr data    !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                        Encr data                              ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ]]></artwork>
            </figure>
</t>
<t>
	    <list style='symbols'>
	      <t>Next payload (8 bits): identifies the payload that is added 
		after this payload.</t>

	      <t>Encr data len (16 bits): length of Encr data (in bytes).</t>

	      <t>Encr data (variable length): the encrypted secret key sub-payloads 
		(see <xref target="SKpld"/>).</t>

</list>
</t>
      </section>

      <section title="Key Data Sub-Payload"  anchor="KDpld">

   <t>For the key data sub-payload, a new type of key is defined.  The
   Private Key (K_PR) is used to decrypt the content encrypted using the 
     corresponding Public Key (K_PUB). KEMAC in the REQUEST_KEY_RESP SHALL 
     contain one or more Private Keys.</t>
<t>
	    <list style='symbols'>
                <t>Type (4 bits): indicates the type of key included in the 
		  payload.</t>
</list>
</t>

<texttable title='Key Data Type (Additions)' anchor='KDtable'>
<ttcol align='center'>Type</ttcol>
<ttcol align='center'>Value</ttcol>
<ttcol align='center'>Comments</ttcol>
<c>K_PR</c>
<c>TBD11</c>
<c>Private Key</c>
</texttable>

        </section>

<section title="EC Diffie-Hellman Sub-Payload" anchor="ECDHpld">

   <t> The EC Diffie-Hellman Sub-Payload uses the same format as ECC Point 
     Payload (ECCPT) defined in <xref target="I-D.ietf-msec-mikey-ecc"/>. However, ECCPT in MIKEY-IBAKE is never included in clear, but as an encrypted part of the
   IBAKE payload. The payload identifier is 22.</t>
<t>
            <figure>
              <artwork><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ! Next payload  ! ECC Curve     ! ECC Point                     ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ! Auth alg      ! TGK len                       ! Reserv! KV    !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ! KV data (optional)                                            ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
            </figure>
</t>
<t>
	    <list style='symbols'>
	      <t>Next payload (8 bits): identifies the payload that is added 
		after
     this payload.  See Section 6.1 of <xref target="RFC3830"/> for values.</t>

	      <t>ECC curve (8 bits): identifies the ECC curve used.</t>
	      <t>ECC point (variable length): ECC point data, padded to end on a
     32-bit boundary, encoded in octet string representation.</t>

	      <t>Auth alg (8 bits): specifies the MAC algorithm used for the
     verification message. For MIKEY-IBAKE this field is ignored. </t>

	      <t>TGK len (16 bits): the length of the TGK (in bytes).
		 For MIKEY-IBAKE this field is ignored. </t>

	      <t>KV (4 bits): indicates the type of key validity period 
		specified.
     This may be done by using an SPI (alternatively an MKI in SRTP) or
     by providing an interval in which the key is valid (e.g., in the
     latter case, for SRTP this will be the index range where the key
     is valid).  See Section 6.13 of <xref target="RFC3830"/> for pre-defined values.</t>

	      <t>KV data (variable length): This includes either the 
		SPI/MKI or an
     interval (see Section 6.14 of <xref target="RFC3830"/>).  If KV is NULL, this
     field is not included.</t>


</list>
</t>
</section>

<section title="Secret Key Sub-Payload" anchor="SKpld">

  <t>Secret Key payload is included as a sub-payload in Encrypted Secret 
    Key payload. Similar to EC Diffie-Hellman sub-payload, it is never 
    included in clear, but as an encrypted part of the
   ESK payload.</t>
<t>
            <figure>
              <artwork><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !  Next Payload ! Type  ! KV    ! Key data len                  !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                         Key data                              ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                        KV data (optional)                     ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
            </figure>
</t>
<t>
	    <list style='symbols'>
	      <t>Next payload (8 bits): identifies the payload that is added 
		after this payload.</t>

	      <t> Type (4 bits): indicates the type of the key included in the 
		payload.</t>
</list>
</t>
<texttable title='Secret Key Types' anchor='SKtable'>
<ttcol align='center'>Type</ttcol>
<ttcol align='center'>Value</ttcol>
<c>SK</c>
<c>0</c>
</texttable>

<t>
	    <list style='symbols'>
	      <t>KV (4 bits): indicates the type of key validity period 
		specified.
      This may be done by using an SPI (or MKI in the case of 
		<xref target="RFC3711"/>) or
      by providing an interval in which the key is valid (e.g., in the
      latter case, for SRTP this will be the index range where the key
      is valid). KV values are the same as in Section 6.13 of 
		<xref target="RFC3830"/></t>
	      
	      <t>Key data len (16 bits): the length of the Key data field (in
      bytes). </t>

	      <t>Key data (variable length): The SK data.</t>

	      <t>KV data (variable length): This includes either the SPI or an
      interval.  If KV is NULL, this field is not
      included.</t>


</list>
</t>



        </section>
	  </section>
</section>

        <section title="Security Considerations">
        
	  <t>This draft is based on the basic Identity Based Encryption 
	    protocol, as specified in <xref target="RFC5091"/>), 
	    <xref target="RFC5408"/> and <xref target="RFC5409"/>, and as 
	    such inherits some properties of that protocol. For instance, 
	    by concatenating the “date” with the identity (to derive the 
	    public key), the need for any key 
	    revocation mechanisms is virtually eliminated. Moreover, by allowing the participants 
	    to acquire multiple private keys (e.g., for duration of contract) 
	    the availability requirements on the KMS are also reduced without 
	    any reduction in security.</t>

	  <t>Some additional security considerations are outlined below:</t>
<t>
	    <list style='symbols'>
	      <t>Attacks on the cryptographic algorithms used in Identity 
		Based Encryption are outside the scope of this document. 
		It is assumed that any administrator will pay attention to 
		the desired strengths of the relevant cryptographic algorithms 
		based on an up to date understanding of the strength of these 
		algorithms from published literature as well as known 
		attacks.</t>

	      <t>It is assumed that the Key Management Services are secure, not compromised, trusted, 
		and will not engage in launching active attacks independently 
		or in a collaborative environment.</t>
	      <t>However, any malicious insider could potentially launch 
		passive attacks (by decryption of one or more message 
		exchanges offline). While it is in the best interest of 
		administrators to prevent such issue, it is hard to eliminate 
		this problem. Hence, it it assumed that such problems will persist, 
		and hence the protocols are designed to protect participants 
		from passive adversaries.</t>
	      <t>Communication between participants and their respective 
		Key Management Servers is expected to be secure, and as 
		such outside the scope of this document. In any implementation 
		of the protocols described in this document, administrators 
		of any KMS have to ensure that communication with participants 
		is secure and not compromised.</t>
	      <t>The basic IBAKE protocol from a cryptographic perspective is 
		secure based on the following considerations.

	    <list style='symbols'>
	      <t>In every step Identity Based Encryption (IBE) is used, with 
		the recipient’s public key. This guarantees that only the 
		intended recipient of the message can decrypt the message.</t>
	      <t>Next, the use of identities within the encrypted payload is 
		intended to eliminate some basic reflection attacks. For 
		instance, suppose we did not use identities as part of the 
		encrypted payload, in the first step of the IBAKE protocol 
		(i.e., I_message 1 of <xref target="example"/> in  
		<xref target="overview"/>).

	    <list style='symbols'>
	      <t>Assume an adversary who has access to the conversation 
		between initiator and responder and can actively snoop into 
		packets and drop/modify them before routing them to the 
		destination.</t>
	      <t>For instance, assume that the IP source address and 
		destination address can be modified by the adversary.</t>
	      <t>After the first message is sent by the initiator (to the 
		responder), the adversary can take over and trap the 
		packet.</t> 
	      <t>Next the adversary can modify the IP source address to 
		include adversary’s IP address, before routing it onto 
		the responder.</t>
	      <t>The responder will assume the request for an IBAKE session 
		came from the adversary, and will execute step 2 of the IBAKE 
		protocol (i.e., R_message 1 of <xref target="example"/> in 
		<xref target="overview"/>) but 
		encrypt it using the adversary’s public key.</t> 
	      <t>The above message can be decrypted by the adversary (and 
		only by the adversary). In particular, since the second 
		message includes the challenge sent by the initiator to the 
		responder, the adversary will now learn the challenge sent 
		by the initiator.</t>
	      <t>Following this, the adversary can carry on a conversation 
		with the initiator “pretending” to be the responder.</t>
	      <t>This attack will be eliminated if identities are used as 
		part of the encrypted payload.</t>
</list>
</t>
<t>In summary, at the end of the exchange both initiator and responder can 
  mutually authenticate each other and agree on a session key.</t>
<t>Recall that Identity Based Encryption guarantees that only the recipient 
  of the message can decrypt the message using the private key. The caveat 
  being, the KMS which generated the private key of recipient of message can 
  decrypt the message as well. However, the KMS cannot learn the session 
  key “xyP” given “xP” and “yP” based on the Elliptic Curve Diffie-Hellman 
  problem. This property of resistance to passive key escrow from the KMS, 
  is not applicable to the basic IBE protocols proposed in 
  <xref target="RFC5091"/>), 
	    <xref target="RFC5408"/> and <xref target="RFC5409"/>.</t>
<t>Observe that the protocol works even if the initiator and responder 
  belong to two different Key Management Systems. In particular, the 
  parameters used for encryption to the responder and parameters used for 
  encryption to the initiator can be completely different and independent of 
  each other. Moreover, the Elliptic Curve used to generate the session key 
  “abP” can be completely different. If such flexibility is desired, then it 
  would be advantageous to add optional extra data and/or to the protocol to 
  exchange the algebraic primitives used in deriving the session key.</t>
<t>In addition to mutual authentication, and resistance to passive escrow, 
  the Diffie-Hellman property of the session key exchange guarantees perfect 
  secrecy of keys. In others, accidental leakage of one session key does not 
  compromise of past or future session keys between the same initiator and 
  responder.</t>
</list>
</t>
	    <t>The security of all additional security features rely on the 
	      security of IBAKE. Moreover each feature has additional 
	      security features. For instance:

	    <list style='symbols'>
	      <t>In the Forking feature, given that there are multiple 
		potential responders, it is important to observe that there 
		is one ‘common responder’ identity (and corresponding public 
		and private keys) and each responder has a unique identity 
		(and corresponding keys). Observe that, in this framework if 
		responder 2 is the who responds to the invite from the 
		initiator then the protocol guarantees that responder 1 does 
		not learn the session key.</t>
	      <t>In the Retargeting feature, the forwarding server does not 
		learn the private key of the intended responder since it is 
		encrypted using the retargeted responder’s public key. 
		Additionally, the initiator will learn that the retargeted 
		responder answered the phone (and not the intended responder). 
		This will allow the initiator to decide whether or not to 
		carry on the conversation. Finally, the session key cannot 
		be discovered by intended responder since the random number 
		chosen by the retargeted responder is secret.</t>
	      <t>In the Deferred Delivery feature, the initiator and the 
		responder’s mailbox will mutually authenticate each other 
		thereby preventing server side “phishing” attacks and 
		conversely guarantees to the server (and eventually to the 
		responder) the identity of the initiator. Moreover, the key 
		used by initiator to encrypt the contents of the message is 
		completely independent from the session key derived between 
		the initiator and the server. Finally, the key used to 
		encrypt the message is encrypted using the responder’s public 
		key by the initiator which allows the contents of the message 
		to remain unknown to the mailbox server.</t>
	<!--      <t>The conferencing protocol, is based on an adaptation of the 
		Burmester and Desmedt to the Identity Based Authenticated 
		Key Exchange context. In particular:

	    <list style='symbols'>
	      <t>The participants in the call authenticate themselves with 
		the conference server, and the conference can then authorize 
		their participation by verifying the participant’s identity 
		with an authorization list.</t>
	      <t>The group key generated by the participants will not be 
		known to the conference server. The proof of security of this 
		feature relies on the security of the Burmester and Desmedt 
		protocol.</t>
	      <t>Observe that when new participants are added or existing 
		participants leave the call, the group key is re-calculated. 
		This will ensure that the keys stay fresh and new participants 
		will not have access to old key, and exiting participants 
		will not have access to new keys.</t>
	    </list></t> -->


</list>
</t>

</list>
</t>

        </section>

	<section title="IANA Considerations">

	  <t>This document defines several new values for the namespaces Data
	    Type, Next Payload, and Key Data Type defined in 
	    <xref target="RFC3830"/>.  The
	    following IANA assignments were added to the MIKEY Payload registry
	    (in bracket is a reference to the table containing the registered
	    values):</t>
<t>
	    <list style='symbols'>
	      <t>Data Type (see <xref target="DTtable"/>)</t>

	      <t>Next Payload (see <xref target="NPtable"/>)</t>

	      <t>Key Data Type (see <xref target="KDtable"/>)</t>
</list>
</t>
</section>
    </middle>

    <back>


        <references title='Normative References'>
	    &rfc2119; &rfc3830; &rfc4563; &rfc5091; &rfc5408; &rfc5409; &I-D.ietf-msec-mikey-ecc;
	 <reference anchor="SEC1">
	<front>
		<title>Elliptic Curve Cryptography</title>
		<author>
			<organization>Standards for Efficient Cryptography Group</organization>
		</author>
		<date month="September" year="2000"></date>
	</front>
   </reference>
	    
	</references>
	<references title="Informative References">
            &rfc4650; &rfc4738; &rfc4120; &rfc3711;
        </references>
    </back>

</rfc>
