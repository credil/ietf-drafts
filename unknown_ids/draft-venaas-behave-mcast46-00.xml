<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href='http://xml.resource.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!--
<!ENTITY rfc3956 PUBLIC ''
         'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3956.xml'>
<!ENTITY rfc4291 PUBLIC ''
         'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4291.xml'>
<!ENTITY rfc4601 PUBLIC ''
         'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4601.xml'>
-->
]>
<?rfc toc="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc symrefs="no" ?>
<?rfc sortrefs="yes"?>
<rfc category="info" ipr="full3978" docName="draft-venaas-behave-mcast46-00.txt">
  <front>
    <title>An IPv4 - IPv6 multicast translator</title>
    <author initials='S.' surname='Venaas' fullname='Stig Venaas'>
      <organization>UNINETT</organization>
      <address>
        <postal>
          <city>Trondheim</city>
          <code>NO-7465</code>
          <country>Norway</country>
        </postal>
        <email>venaas@uninett.no</email>
      </address>
    </author>
    <date month="December" year="2008" />
    <abstract><t>This document describes an IPv4 - IPv6 translator device that embeds
all IPv4 multicast group addresses into IPv6, and allows IPv6 hosts
to receive from and send to IPv4 multicast groups.
    </t></abstract>
  </front>
  <middle>
    <section title="Introduction" anchor="intro">
<t>IPv4 and IPv6 will co-exist for many years, possibly decades. There
are several solutions for how IPv4 and IPv6 hosts and networks can
inter-operate. This is usually easy if a host is dual stack. If
however an IPv6-only host needs to communicate with an IPv4-only
host, then somewhere along the data path there must be some form of
translation. There are several ways of doing this for unicast, but
not much work has been done on multicast.
</t><t>
Here we describe a multicast translator solution. This translator
could be placed at the border between IPv6-only and IPv4-only
networks to allow multicast access between them, or it may also be
placed in a dual-stack network, where it can support hosts or other
networks that are IPv6-only or IPv4-only. The goal is to give
an IPv6 host full access to send to and receive from any IPv4
multicast group by using the usual IPv6 multicast protocols and
applications which will then operate on the respective IPv6 groups.
It should also allow this for multiple hosts. Multiple IPv4 hosts
should be able to use a single IPv4 group, multiple IPv6 hosts a
corresponding IPv6 group, and all hosts should be able to send to
and receive from all the others. Similar to hosts using the same
group from the same address family.
The translator solution should work with no changes to other
infrastructure.
</t><t>
We will define a one-to-one mapping of multicast IPv4 addresses
onto a subset of the IPv6 multicast addresses. An IPv6 host will
then be able to receive data from any IPv4 multicast group by joining the
corresponding IPv6 group. An IPv6 host can also send, without
necessarily joining, to any IPv4 multicast group by sending to the
corresponding IPv6 group. Some way of translating unicast addresses
is also needed to translate addresses of multicast sources.
</t>
    </section>
    <section title="Embedding IPv4 multicast group addresses into IPv6" anchor="embed">
<t>We need a way of referring to an IPv4 multicast group using an IPv6
address. One could embed IPv4 multicast addresses into IPv6 by simply
prepending them with a specific /96 IPv6 prefix such that for each
IPv4 multicast address we have a respective IPv6 multicast address.
However, both IPv4 and IPv6 have special ranges for SSM usage, and
one might want to take scoping into account. We suggest using one
specific /96 IPv6 SSM prefix for all IPv4 SSM addresses, and one
specific /96 IPv6 ASM (non-SSM) prefix for all IPv4 ASM (non-SSM)
addresses.
</t><t>
An administrator may choose the exact prefixes used, and depending
on the prefix, also which IPv6 scope. The prefix must be in
accordance with the IPv6 multicast address format defined in section
2.7 of <xref target="RFC4291"/>.
The addresses used will then be of the form FFxx:&lt;blah&gt;:&lt;IPv4&gt; where
flags, scope and the value of "blah" are chosen by the administrator.
"IPv4" is the last 32 bits specifying the IPv4 address of the IPv4
multicast group. For ASM it may be useful to use an Embedded-RP
<xref target="RFC3956"/> prefix based on an IPv6 unicast address of
the translator.
</t><t>
The unicast addresses of multicast sources also need to be
translated. We recommend embedding all IPv4 unicast addresses into
a /96 IPv6 prefix. This allows different IPv4 unicast addresses to
be mapped to different IPv6 unicast addresses, and for IPv6 SSM joins
to address specific IPv4 SSM sources. Note that for ASM use, it
may be sufficient to map all IPv4 sources to one single IPv6 address.
For translating IPv6 sources into IPv4 sources, one may use a single
address, or a pool of IPv4 addresses. The same IPv4 address may need
to be re-used for different IPv6 sources. If the translator also
translates unicast packets, then it should use the same unicast
translation mechanism for source addresses in multicast packets. Due
to multicast RPF checks, the IPv4 and IPv6 unicast addresses used need
to be routed towards the translator.
</t>
    </section>
    <section title="Architecture" anchor="arch">
<t>We propose that the translator makes use of PIM-SM (Sparse Mode)
<xref target="RFC4601"/> for IPv6. For ASM it should then be the
RP for the /96 IPv6 prefix used for ASM. This allows the translator
to know which IPv4 groups the IPv6 hosts join, and also to learn of
IPv6 sources for those groups. It is sufficient to support MLD
if there are no IPv6 PIM neighbors (e.g. a single link or MLD
proxies).
</t><t>
With respect to the IPv4 network, it may be sufficient to behave as
an IPv4 multicast host. When it receives a PIM or MLD join for a new
IPv6 group corresponding to some IPv4 multicast group, x, it simply
joins the IPv4 multicast group. If it learns of an IPv6 source for
IPv6 group corresponding to some IPv4 multicast group, it will send
the IPv6 packets to the IPv4 group. As an RP, it may receive IPv6 PIM
registers, it may then as a regular IPv6 RP, join towards the source
to receive packets natively. If it is an IPv4 host, it will not know
whether there are IPv4 receivers, and hence it must alway do this.
</t><t>
One can improve on this by making the translator behave as an IPv4
RP, or be an IPv4 PIM router running MSDP to exchange information
about active IPv4 sources. The translator can then use MSDP to signal
its active IPv4 sources (that may be translated IPv6 sources) so that
it will receive PIM joins if there are IPv4 receivers for the groups.
It can also use MSDP to see if there are IPv4 sources for IPv4 groups
that IPv6 hosts have joined.
</t><t>
Note that for SSM this is much simpler with no RP nor MSDP involved.
It may still be an advantage to act as an IPv4 PIM router, in order to
only do translation from IPv6 to IPv4 when there are IPv4 listeners.
</t>
    </section>
    <section title="Address rewriting" anchor="rewrite">
<t>When IPv4 packets are resent as IPv6 we will need to replace the
source and destination addresses with suitable IPv6 addresses. And
similar replacement going from IPv6 to IPv4.
</t><t>
The destination address is easy. That is the multicast address. As
described above, we map IPv4 multicast addresses into IPv6 by
prepending them with a /96 prefix, using different prefixes for
SSM and ASM. Going the other direction, we simply extract the last
32 bits.
</t><t>
For the source addresses we propose a similar mapping from IPv4 to
IPv6, using some /96 unicast prefix. In the other direction we
suggest having a pool of IPv4 addresses (possibly just a single
address) that is used for all IPv6 multicast translated to IPv4.
If unicast traffic is translated, then similar translation should
be used for the multicast source addresses. Note that for RTP the
application can know the real source and tell streams apart, even
if they are translated into the same multicast source address. 
</t><t>
One could consider using just a single IPv6 unicast address for
all IPv4 multicast translated into IPv6. For ASM it has the same
issues as using a single IPv4 unicast address for translating into
IPv4. However, for SSM one would like an IPv6 SSM join to uniquely
specify a corresponding IPv4 SSM join. In order to do this, the
simplest is what we propose above with a /96 prefix used for all
IPv4 unicast addresses.
</t>
    </section>
    <section title="Examples" anchor="examples">
<t>To illustrate how the translator works, we will look at two examples. In
both examples we assume that there is no previous state in the translator.
</t>
      <section title="IPv6 host joining a group inside the /96 prefix" anchor="join6">
<t>An IPv6 host joins the group FFxx:&lt;blah&gt;:a.b.c.d. If the translator
is the DR for the host, it will receive an MLD membership report. If
not, it will receive a PIM join since it is the RP for the group. The
translator will then get (*, G) state for the group. So far this is
normal PIM behaviour. The translator checks whether the address is
inside the /96 prefix, and whether the last 32 bits (a.b.c.d) is an
IPv4 multicast address. If it is, it joins a.b.c.d using IGMP, and
stays joined as long as it has state for the group.
</t><t>
For SSM the translator would in addition check if the source in the
join is inside the /96 unicast prefix used. If this is the case, it
then uses the last 32 bits as the IPv4 source. It can then do a
source-specific IPv4 join.
</t><t>
When the translator receives a multicast packet for a.b.c.d it prepends
the /96 prefix to form the IPv6 address FFxx:&lt;blah&gt;:a.b.c.d. If the
translator has outgoing interfaces for this group, it will send an IPv6
packet to the same interfaces to which it would have forwarded an
IPv6 packet for the group.  The destination address will be
FFxx:&lt;blah&gt;:a.b.c.d, and the source address will be computed using the
/96 unicast prefix. For SSM, the translator would also check that it
got an outgoing interface for the specific source.
</t>
      </section>
      <section title="IPv6 host sending to group inside the /96 prefix" anchor="send6">
<t>An IPv6 host sends to the group FFxx:&lt;blah&gt;:a.b.c.d. If the translator
is the DR for the host, it will receive the data natively. If not, it
will receive PIM register messages containing the data since it is the
RP. For each packet received, either natively or inside register
messages, it will first check that the destination address is inside
the /96 prefix and that the last 32 bits (a.b.c.d) is an IPv4
multicast address. If this is okay, it will resend the packet to the
IPv4 address a.b.c.d. The source address would be chosen from a given
pool of IPv4 unicast addresses (this may just be a single fixed address).
</t><t>
If the translator is also an IPv4 PIM router, then we do some further
steps. For ASM, if the translator is an RP and uses MSDP, it should announce
the translated source in MSDP, and only forward translated packets if it
has a join for the group. For SSM, it should only forward translated packets
if it has a join for the specific source and group.
</t>
      </section>
    </section>
    <section title="Acknowledgments" anchor="acks">
<t>The author wishes to thank Michal Przybylski and Pekka Savola for
valuable comments, and also people from the M6Bone community for
testing a prototype implementation.
</t>
    </section>
    <section title="Security Considerations" anchor="seccon">
<t>When using such a translator one needs to take some care of
scoping and TTL values. Due to differences in IPv4 and IPv6 scoping,
a narrow scope might be translated into a wider one.
</t><t>
One may wish to limit who can access the translator. If for instance one
wishes to restrict it to a site, one can use a /96 prefix of
site-local scope, and then filter at the site border, just like one would
for multicast in general. A translator implementation could also offer a
way of restricting which groups and sources should be accepted.
</t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.3956" ?>
      <?rfc include="reference.RFC.4291" ?>
      <?rfc include="reference.RFC.4601" ?>
    </references>
  </back>
</rfc>
