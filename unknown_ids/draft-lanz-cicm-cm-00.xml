<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!-- General -->
<?rfc strict="yes" ?>   <!-- Enforce Internet-Drafts nits & DTD validity? -->
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<!-- References -->
<?rfc symrefs="yes"?>   <!-- Show symbolic links (yes) or numbers (no). -->
<?rfc sortrefs="yes" ?> <!-- Sort references? -->
<!-- Comments -->
<?rfc comments="yes" ?> <!-- Display <cref> elements? -->
<?rfc inline="yes" ?>   <!-- Place comments inline (yes) or in comments section (no). -->
<?rfc editing="no" ?>   <!-- Insert editing marks? -->
<!-- Table of Contents -->
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc tocompact="yes"?>
<!-- End of directives; start of RFC. -->
<rfc category="info" ipr="trust200902" docName="draft-lanz-cicm-cm-00">
  <front>
    <title abbrev="CICM Channel Management">
      Common Interface to Cryptographic Modules (CICM) Channel Management
    </title>
    <author fullname="Daniel J. Lanz" initials="D." surname="Lanz">
      <organization abbrev="MITRE">The MITRE Corporation</organization>
      <address>
        <email>dlanz@mitre.org</email>
      </address>
    </author>
    <author fullname="Lev Novikov" initials="L." surname="Novikov">
      <organization abbrev="MITRE">The MITRE Corporation</organization>
      <address>
        <email>lnovikov@mitre.org</email>
      </address>
    </author>
    <date year="2011" month="January" />
    <area>Security</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <abstract>
      <t>[RFC Editor: Please update the RFC references prior to publication.]</t>
      <t>This memo defines a programming interface for the management of
      cryptographic channels as outlined in draft-lanz-cicm-lm-00 and required
      by draft-lanz-cicm-02 including creating and negotiating channels for
      encryption, decryption, bypass, data integrity, or to generate random
      data.</t>
      <t>Comments are solicited and should be addressed to the mailing list at cicm@ietf.org.</t>
    </abstract>
  </front>
  <middle><!-- Content. -->
    <section title="Introduction">
      <t>This document defines the key management functions for the Common Interface to
      Cryptographic Modules (CICM) as defined in <xref target="CICM" />. The underlying logical
      model and terminology is defined in <xref target="CICM-LM" />.</t>
      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
        and "OPTIONAL" in this document are to be interpreted as
        described in <xref target="RFC2119" />.</t>
      </section>
      <section title="Definition Language">
        <t>This document uses the Interface Definition Language (IDL) <xref target="IDL" /> to
        specify language-neutral interfaces and is not intended to prescribe or preclude a particular
        communications protocol such as General Inter-ORB Protocol (GIOP) <xref target="CORBA" />
        between programs in different address spaces or on different devices. In other words, any specific
        protocol is strictly OPTIONAL. See Definition Language in <xref target="CICM" />
        for more information.
        </t>
      </section>
      <section title="Conformance and Extension Language">
        <t>This document contains definitions for several opaque data parameters whose
        format is not defined by CICM. Instead, implementers are required to create an
        Implementation Conformance Statement which MUST reference a standard format or
        define a module developer-specific format implemented by the module for these
        datatypes. See Conformance and Extensions in <xref target="CICM" /> for more details.</t>
      </section>
    </section>
    <section title="CICM Dependencies">
      <t>This document depends on type definitions and interfaces that
      are defined in other CICM documents.</t>

      <section title="Namespaces">
        <t>The CICM namespace is defined in <xref target="CICM" />.</t>
      </section>
      <section title="Types">
        <t>The following type definitions are defined in <xref target="CICM" />:
          <list>
            <t>CICM::UInt32</t>
            <t>CICM::CharString</t>
            <t>CICM::Buffer</t>
            <t>CICM::Status (including all return values)</t>
            <t>CICM::LocalPort</t>
            <t>CICM::RemotePort</t>
            <t>CICM::Classification</t>
          </list>
        </t>
      </section>
      <section title="Interfaces">
        <t>The interface CICM::Iterator is defined in <xref target="CICM" />; CICM::Key,
        CICM::AsymKey and CICM::SymKey are defined in <xref target="CICM-KM" />.</t>
      </section>
    </section>
      <section title="Channel Namespaces">
        <t>Due to the large number of potential configurations, the definitions of the
        channel types and their operations are divided into ten namespaces which group together
        similar or related types of channels.</t>
        <t>The namespaces are:
        <list style="numbers">
          <t>CICM::Encrypt (<xref target="sec-encrypt" />)</t>
          <t>CICM::Decrypt (<xref target="sec-decrypt" />)</t>
          <t>CICM::Duplex (<xref target="sec-duplex" />)</t>
          <t>CICM::BypassWrite (<xref target="sec-bypass-write" />)</t>
          <t>CICM::BypassRead (<xref target="sec-bypass-read" />)</t>
          <t>CICM::EncryptBypass (<xref target="sec-encrypt-bypass" />)</t>
          <t>CICM::DecryptBypass (<xref target="sec-decrypt-bypass" />)</t>
          <t>CICM::Emit (<xref target="sec-emit" />)</t>
          <t>CICM::Answer (<xref target="sec-answer" />)</t>
          <t>CICM::Coprocessor (<xref target="sec-coprocessor" />)</t>
        </list>
        See <xref target="CICM-LM" /> for a high level description of the channel types
        or below for the channel definitions.</t>
      </section>
			<section title="Channel Abstractions">
      <section title="Algorithm Types">
        <figure>
          <preamble>Type CICM::HashAlgorithmId</preamble>
          <artwork><![CDATA[typedef CICM::CharString HashAlgorithmId;]]></artwork>
          <postamble>Unique hash algorithm identifier.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::AsymEncrAlgorithmId</preamble>
          <artwork><![CDATA[typedef CICM::CharString AsymEncrAlgorithmId;]]></artwork>
          <postamble>Unique asymmetric encryption algorithm identifier.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::IMPLICIT_ASYM_ENCR_ALGO</preamble>
<artwork><![CDATA[const CICM::AsymEncrAlgorithmId
IMPLICIT_ASYM_ENCR_ALGO = "IMPLICIT";]]></artwork>
          <postamble>Value that indicates that the encryption algorithm is
          implicit in the key being provided to the module.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::AsymSigAlgorithmId</preamble>
<artwork><![CDATA[typedef CICM::CharString
AsymSigAlgorithmId;]]></artwork>
          <postamble>Unique asymmetric signature algorithm identifier.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::IMPLICIT_ASYM_SIG_ALGO</preamble>
<artwork><![CDATA[const CICM::AsymSigAlgorithmId
IMPLICIT_ASYM_SIG_ALGO = "IMPLICIT";]]></artwork>
          <postamble>Value that indicates that the signature algorithm is
          implicit in the key being provided to the module.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::KeyWrapAlgorithmId</preamble>
<artwork><![CDATA[typedef CICM::CharString
KeyWrapAlgorithmId;]]></artwork>
          <postamble>Unique key wrap algorithm identifier, incorporating both the
        algorithm and the mode.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::IMPLICIT_KEY_WRAP_ALGO</preamble>
<artwork><![CDATA[const CICM::KeyWrapAlgorithmId
IMPLICIT_KEY_WRAP_ALGO = "IMPLICIT";]]></artwork>
          <postamble>Value that indicates that the key wrap algorithm is
          implicit in the key being provided to the module.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::SymEncrAlgorithmId</preamble>
          <artwork><![CDATA[typedef CICM::CharString SymEncrAlgorithmId;]]></artwork>
          <postamble>Unique symmetric encryption algorithm identifier,
          incorporating both the algorithm and the mode.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::IMPLICIT_SYM_ENCR_ALGO</preamble>
<artwork><![CDATA[const CICM::SymEncrAlgorithmId
IMPLICIT_SYM_ENCR_ALGO = "IMPLICIT";]]></artwork>
          <postamble>Value that indicates that the encryption algorithm is
          implicit in the key being provided to the module.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::SymMacAlgorithmId</preamble>
          <artwork><![CDATA[typedef CICM::CharString SymMacAlgorithmId;]]></artwork>
          <postamble>Unique symmetric MAC algorithm identifier.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::IMPLICIT_SYM_MAC_ALGO</preamble>
<artwork><![CDATA[const CICM::SymMacAlgorithmId
IMPLICIT_SYM_MAC_ALGO = "IMPLICIT";]]></artwork>
          <postamble>Value that indicates that the MAC algorithm is implicit in
          the key being provided to the module.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::ProtocolId</preamble>
          <artwork><![CDATA[typedef CICM::CharString ProtocolId;]]></artwork>
          <postamble>Unique key agreement protocol identifier.</postamble>
        </figure>
        <figure>
          <preamble>Constant CICM::IMPLICIT_PROTOCOL_ID</preamble>
<artwork><![CDATA[const CICM::ProtocolId
IMPLICIT_PROTOCOL_ID = "IMPLICIT";]]></artwork>
          <postamble>Value that indicates that the key agreement protocol is
          implicit in the message being provided to the module.</postamble>
        </figure>
      </section>
      <section title="State Vector">
        <figure>
          <preamble>Type CICM::Vector</preamble>
          <artwork><![CDATA[typedef CICM::Buffer Vector;]]></artwork>
          <postamble>State vector, used to represent initialization vectors,
          synchronization vectors, counter values, and time-of-day values.</postamble>
        </figure>
      </section>
      <section title="Integrity Buffers">
        <figure>
          <preamble>Type CICM::HashBuffer</preamble>
          <artwork><![CDATA[typedef CICM::Buffer HashBuffer;]]></artwork>
          <postamble>Cryptographic hash.</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::MACBuffer</preamble>
          <artwork><![CDATA[typedef CICM::Buffer MACBuffer;]]></artwork>
          <postamble>Message authentication code (MAC).</postamble>
        </figure>
        <figure>
          <preamble>Type CICM::SigBuffer</preamble>
          <artwork><![CDATA[typedef CICM::Buffer SigBuffer;]]></artwork>
          <postamble>Cryptographic signature.</postamble>
        </figure>
      </section>
				<section title="Interface CICM::ChannelManager">
					<figure>
					  <preamble>Interface CICM::ChannelManager</preamble>
<artwork><![CDATA[interface ChannelManager :
	CICM::Answer::ChannelManager,
	CICM::BypassRead::ChannelManager,
	CICM::BypassWrite::ChannelManager,
	CICM::Coprocessor::ChannelManager,
	CICM::Decrypt::ChannelManager,
	CICM::DecryptBypass::ChannelManager,
	CICM::Duplex::ChannelManager,
	CICM::Emit::ChannelManager,
	CICM::Encrypt::ChannelManager,
	CICM::EncryptBypass::ChannelManager {]]></artwork>
					<postamble>CICM::ChannelManager supports the creation and negotiation of
					cryptographic channels. It is accessed from CICM::CryptoModule via
					the CICM::CryptoModule::channel_manager attribute.
					CICM::ChannelManager enables a variety of different channel types
					to be constructed.</postamble>
					</figure>
					<t>Note:
						<list>
						  <t>Conforming implementations need only implement one or more of
						  the ChannelManager's dependencies thereby limiting which
						  negotiators, controllers, streams, and channels are
						  available. See Conformance and Extensions in <xref target="CICM" /> for
              more information.</t>
						</list>
					</t>

					<section title="CICM::ChannelManager Inheritance">
						<t>CICM::ChannelManager inherits from: CICM::Answer::ChannelManager,
						CICM::BypassRead::ChannelManager,
						CICM::BypassWrite::ChannelManager,
						CICM::Coprocessor::ChannelManager, CICM::Decrypt::ChannelManager,
						CICM::DecryptBypass::ChannelManager, CICM::Duplex::ChannelManager,
						CICM::Emit::ChannelManager, CICM::Encrypt::ChannelManager and
						CICM::EncryptBypass::ChannelManager.</t>
					</section>
					<section title="CICM::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::ChannelManager::create_controller_group()</preamble>
<artwork><![CDATA[CICM::Status create_controller_group(
	out CICM::ControllerGroup controller_group_ref
);]]></artwork>
						<postamble>Creates a CICM::ControllerGroup to group controllers and
						conduits together.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_group_ref Reference to the created controller group.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Channel">
					<figure>
					  <preamble>Interface CICM::Channel</preamble>
					  <artwork><![CDATA[interface Channel {]]></artwork>
					<postamble>Defines the logical path through the module. Interface from
					which all conduit, streams and controllers inherit.
					Channels are created via the CICM::ChannelManager interface.</postamble>
					</figure>

					<section title="CICM::Channel Attributes">
						<figure>
						  <preamble>AttributeCICM::Channel::event_manager</preamble>
						  <artwork><![CDATA[readonly attribute CICM::ChannelEventManager event_manager;]]></artwork>
						  <postamble>Provides access to the event manager.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::Conduit">
					<figure>
					  <preamble>Interface CICM::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Controller,
	CICM::Stream {]]></artwork>
					<postamble>Interface from which all other conduits are inherited. A
					conduit is a combination of a stream and controller.</postamble>
					</figure>

					<section title="CICM::Conduit Inheritance">
						<t>CICM::Conduit inherits from: CICM::Controller and CICM::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Controller">
					<figure>
					  <preamble>Interface CICM::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::Channel {]]></artwork>
					<postamble>Interface from which all other controllers are inherited.
					Controls general characteristics of a cryptographic transformation,
					but does not provide data to be transformed.</postamble>
					</figure>
					<t>Remarks:
						<list>
						  <t>There may be cases in which a client program wishes to
						  delegate responsibility for sending or receiving data from the
						  module to another process while retaining the authority to manage
						  the channel. To support this task, both processes must share a
						  known local port. The client-program responsible for controlling
						  the channel creates a CICM::Controller of the appropriate type
						  after which the corresponding CICM::Stream may be obtained by the
						  second process. A stream is tied to the specific controller that
						  configured the channel by a common port value.</t>
						</list>
					</t>

					<section title="CICM::Controller Inheritance">
						<t>CICM::Controller inherits from: CICM::Channel.</t>
					</section>
					<section title="CICM::Controller Methods">
						<figure>
						  <preamble>Method CICM::Controller::destroy()</preamble>
						  <artwork><![CDATA[CICM::Status destroy();]]></artwork>
						  <postamble>Destroys the controller.</postamble>
						</figure>
						<t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Stream">
					<figure>
					  <preamble>Interface CICM::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::Channel {};]]></artwork>
					<postamble>Interface from which all streams inherit. Streams manage the
					flow of data on a channel, but not its attributes.</postamble>
					</figure>
					<section title="CICM::Stream Inheritance">
						<t>CICM::Stream inherits from: CICM::Channel.</t>
					</section>
				</section>
			</section>
			<section title="Conduit Abstractions">
				<section title="Interface CICM::AbstractMACConduit">
					<figure>
					  <preamble>Interface CICM::AbstractMACConduit</preamble>
					  <artwork><![CDATA[interface AbstractMACConduit : CICM::Conduit {]]></artwork>
					<postamble>Interface from which other MAC conduits are inherited.</postamble>
					</figure>

					<section title="CICM::AbstractMACConduit Inheritance">
						<t>CICM::AbstractMACConduit inherits from: CICM::Conduit.</t>
					</section>
					<section title="CICM::AbstractMACConduit Attributes">
						<figure>
						  <preamble>AttributeCICM::AbstractMACConduit::mac_key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymKey mac_key;]]></artwork>
						<postamble>The key used for computing the MAC.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::AbstractMACConduit::mac_algorithm</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymMacAlgorithmId mac_algorithm;]]></artwork>
						<postamble>The algorithm used to MAC the data.</postamble>
						</figure>
					</section>
					<section title="CICM::AbstractMACConduit Methods">
						<figure>
						  <preamble>Method CICM::AbstractMACConduit::end_get_mac()</preamble>
<artwork><![CDATA[CICM::Status end_get_mac(
	out CICM::MACBuffer mac
);]]></artwork>
						<postamble>Direct the module to compute and output the MAC value, and
						reset the channel to accept additional data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] mac Computed MAC value.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AbstractSignConduit">
					<figure>
					  <preamble>Interface CICM::AbstractSignConduit</preamble>
					  <artwork><![CDATA[interface AbstractSignConduit : CICM::Conduit {]]></artwork>
					<postamble>Interface from which other sign conduits are inherited.</postamble>
					</figure>

					<section title="CICM::AbstractSignConduit Inheritance">
						<t>CICM::AbstractSignConduit inherits from: CICM::Conduit.</t>
					</section>
					<section title="CICM::AbstractSignConduit Attributes">
						<figure>
						  <preamble>AttributeCICM::AbstractSignConduit::sign_key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymKey sign_key;]]></artwork>
						<postamble>Key used for signing the data.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::AbstractSignConduit::sign_algorithm</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymSigAlgorithmId sign_algorithm;]]></artwork>
						<postamble>Algorithm used to sign the data.</postamble>
						</figure>
					</section>
					<section title="CICM::AbstractSignConduit Methods">
						<figure>
						  <preamble>Method CICM::AbstractSignConduit::end_get_signature()</preamble>
<artwork><![CDATA[CICM::Status end_get_signature(
	out CICM::SigBuffer signature
);]]></artwork>
						<postamble>Direct the module to compute and output the signature, and
						reset the conduit to accept additional data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] signature The computed signature.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AbstractVerifyConduit">
					<figure>
					  <preamble>Interface CICM::AbstractVerifyConduit</preamble>
					  <artwork><![CDATA[interface AbstractVerifyConduit : CICM::Conduit {]]></artwork>
						<postamble>Interface from which other verification conduits are inherited.</postamble>
					</figure>

					<section title="CICM::AbstractVerifyConduit Inheritance">
						<t>CICM::AbstractVerifyConduit inherits from: CICM::Conduit.</t>
					</section>
					<section title="CICM::AbstractVerifyConduit Types and Constants">
						<figure>
						  <preamble>Type CICM::AbstractVerifyConduit::VerifyStatus</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 VerifyStatus;]]></artwork>
						<postamble>Verification status (data verifies/does not verify).</postamble>
						</figure>
						<figure>
							  <preamble>Constant CICM::AbstractVerifyConduit::C_DATA_VERIFIED</preamble>
<artwork><![CDATA[const CICM::AbstractVerifyConduit::VerifyStatus
	C_DATA_VERIFIED = 0x00006025;]]></artwork>
							  <postamble>Data verifies.</postamble>
						</figure>
						<figure>
							  <preamble>Constant CICM::AbstractVerifyConduit::C_DATA_NOT_VERIFIED</preamble>
<artwork><![CDATA[const CICM::AbstractVerifyConduit::VerifyStatus
C_DATA_NOT_VERIFIED = 0x00006026;]]></artwork>
							  <postamble>Data does not verify.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::AbstractMACVerifyConduit">
					<figure>
					  <preamble>Interface CICM::AbstractMACVerifyConduit</preamble>
					  <artwork><![CDATA[interface AbstractMACVerifyConduit : CICM::AbstractVerifyConduit {]]></artwork>
					<postamble>Interface from which other MAC verify conduits are inherited.</postamble>
					</figure>

					<section title="CICM::AbstractMACVerifyConduit Inheritance">
						<t>CICM::AbstractMACVerifyConduit inherits from: CICM::AbstractVerifyConduit.</t>
					</section>
					<section title="CICM::AbstractMACVerifyConduit Attributes">
						<figure>
						  <preamble>AttributeCICM::AbstractMACVerifyConduit::verify_key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymKey verify_key;]]></artwork>
						<postamble>Key used to verify the MAC.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::AbstractMACVerifyConduit::verify_algorithm</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymMacAlgorithmId verify_algorithm;]]></artwork>
						<postamble>Algorithm used to verify the data.</postamble>
						</figure>
					</section>
					<section title="CICM::AbstractMACVerifyConduit Methods">
						<figure>
						  <preamble>Method CICM::AbstractMACVerifyConduit::end_get_verified()</preamble>
<artwork><![CDATA[CICM::Status end_get_verified(
	in  CICM::MACBuffer mac,
	out CICM::AbstractVerifyConduit::VerifyStatus status
);]]></artwork>
						<postamble>Direct the module to compute and output the MAC verification
						status, and reset the channel to accept additional data for
						verification.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] mac Message authentication code.</t>
							<t>[out] status Status indicating whether or not the data
								  verifies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AbstractSigVerifyConduit">
					<figure>
					  <preamble>Interface  CICM::AbstractSigVerifyConduit</preamble>
					  <artwork><![CDATA[interface AbstractSigVerifyConduit : CICM::AbstractVerifyConduit {]]></artwork>
					<postamble>Interface from which other signature verification conduits
					are inherited.</postamble>
					</figure>

					<section title="CICM::AbstractSigVerifyConduit Inheritance">
						<t>CICM::AbstractSigVerifyConduit inherits from: CICM::AbstractVerifyConduit.</t>
					</section>
					<section title="CICM::AbstractSigVerifyConduit Attributes">
						<figure>
						  <preamble>AttributeCICM::AbstractSigVerifyConduit::verify_key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymKey verify_key;]]></artwork>
						<postamble>Key used to verify the signature.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::AbstractSigVerifyConduit::verify_algorithm</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymSigAlgorithmId verify_algorithm;]]></artwork>
						<postamble>Algorithm used to verify the data.</postamble>
						</figure>
					</section>
					<section title="CICM::AbstractSigVerifyConduit Methods">
						<figure>
						  <preamble>Method CICM::AbstractSigVerifyConduit::end_get_verified()</preamble>
<artwork><![CDATA[CICM::Status end_get_verified(
	in  CICM::SigBuffer signature,
	out CICM::AbstractVerifyConduit::VerifyStatus status
);]]></artwork>
						<postamble>Direct the module to compute and output the verification
						status, and reset the channel to accept additional data for
						verification.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] signature Signature.</t>
							<t>[out] status Status indicating whether or not the data
								  verifies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Stream Abstractions">
				<section title="Interface CICM::WriteStream">
					<figure>
					  <preamble>Interface CICM::WriteStream</preamble>
					  <artwork><![CDATA[interface WriteStream : CICM::Stream {]]></artwork>
					<postamble>Interface from which other streams that write data to the
					module inherit.</postamble>
					</figure>

					<section title="CICM::WriteStream Inheritance">
						<t>CICM::WriteStream inherits from: CICM::Stream.</t>
					</section>
					<section title="CICM::WriteStream Types and Constants">
						<figure>
						  <preamble>Type CICM::WriteStream::WriteStatus</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 WriteStatus;]]></artwork>
						<postamble>Status of an non-blocking write.</postamble>
						</figure>
						<figure>
							  <preamble>Constant   CICM::WriteStream::C_WRITE_NOT_READY</preamble>
<artwork><![CDATA[const CICM::WriteStream::WriteStatus
	C_WRITE_NOT_READY = 0x00006067;]]></artwork>
							  <postamble>Module is not ready to receive data for writing.</postamble>
						</figure>
						<figure>
							  <preamble>Constant   CICM::WriteStream::C_WRITE_READY</preamble>
<artwork><![CDATA[const CICM::WriteStream::WriteStatus
	C_WRITE_READY = 0x00006068;]]></artwork>
							  <postamble>Module is ready to receive data for writing.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::ReadStream">
					<figure>
					  <preamble>Interface CICM::ReadStream</preamble>
					  <artwork><![CDATA[interface ReadStream : CICM::Stream {]]></artwork>
					<postamble>Interface from which all other streams that read data from
					the module inherit.</postamble>
					</figure>

					<section title="CICM::ReadStream Inheritance">
						<t>CICM::ReadStream inherits from: CICM::Stream.</t>
					</section>
					<section title="CICM::ReadStream Types and Constants">
						<figure>
						  <preamble>Type CICM::ReadStream::ReadStatus</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 ReadStatus;]]></artwork>
						<postamble>Status of a non-blocking read.</postamble>
						</figure>
						<figure>
							  <preamble>Constant   CICM::ReadStream::C_READ_NOT_READY</preamble>
<artwork><![CDATA[const CICM::ReadStream::ReadStatus
	C_READ_NOT_READY = 0x0000605E;]]></artwork>
							  <postamble>Module does not have data ready for reading.</postamble>
						</figure>
						<figure>
							  <preamble>Constant   CICM::ReadStream::C_READ_READY</preamble>
<artwork><![CDATA[const CICM::ReadStream::ReadStatus
	C_READ_READY = 0x00006061;]]></artwork>
							  <postamble>Module has data ready for reading.</postamble>
						</figure>
					</section>
				</section>
			</section>
			<section title="Controller Abstractions">
				<section title="Interface CICM::MultiDomainController">
					<figure>
					  <preamble>Interface CICM::MultiDomainController</preamble>
					  <artwork><![CDATA[interface MultiDomainController : CICM::Controller {]]></artwork>
					<postamble>Interface from which any other multi-domain-related
					controller or conduit inherits.</postamble>
					</figure>
					<t>Remarks:
						<list>
						  <t>Provides read access to the local and remote port values
						  associated with the controller.</t>
						</list>
					</t>

					<section title="CICM::MultiDomainController Inheritance">
						<t>CICM::MultiDomainController inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::MultiDomainController Attributes">
						<figure>
						  <preamble>AttributeCICM::MultiDomainController::local_port</preamble>
						  <artwork><![CDATA[readonly attribute CICM::LocalPort local_port;]]></artwork>
						  <postamble>Local port associated with this controller.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::MultiDomainController::remote_port</preamble>
						  <artwork><![CDATA[readonly attribute CICM::RemotePort remote_port;]]></artwork>
						  <postamble>Remote port associated with this controller.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::SymKeyController">
					<figure>
					  <preamble>Interface CICM::SymKeyController</preamble>
					  <artwork><![CDATA[interface SymKeyController : CICM::Controller {]]></artwork>
					<postamble>Interface from which all controllers using a symmetric key
					inherit.</postamble>
					</figure>

					<section title="CICM::SymKeyController Inheritance">
						<t>CICM::SymKeyController inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::SymKeyController Attributes">
						<figure>
						  <preamble>Attribute CICM::SymKeyController::key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::SymKey key;]]></artwork>
              <postamble>The key associated with this controller.</postamble>
						</figure>
					</section>
					<section title="CICM::SymKeyController Methods">
						<figure>
						  <preamble>Method CICM::SymKeyController::update_key()</preamble>
						  <artwork><![CDATA[CICM::Status update_key();]]></artwork>
						<postamble>Cryptographically update the key associated with this
						controller using the key's native algorithm.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>To update an arbitrary key, use CICM::SymKey::update.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::update_key_with_algo for the version of this
							method that accepts an algorithm.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyController::update_key_with_algo()</preamble>
<artwork><![CDATA[CICM::Status update_key_with_algo(
	in  CICM::SymEncrAlgorithmId algorithm
);]]></artwork>
						<postamble>Cryptographically update the key associated with this
						controller using the specified algorithm.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>To update an arbitrary key, use CICM::SymKey::update.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] algorithm Cryptographic algorithm/mode to use to effect the key
								  update.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::update_key for the version of this method
							that does not require an algorithm to be specified.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyController::rollover_key()</preamble>
						  <artwork><![CDATA[CICM::Status rollover_key();]]></artwork>
						<postamble>Specify that the next pre-placed key be used with this
						controller.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>A call to this method may be required when a key reaches
							the end of its specified or usable lifespan or for other
							reasons that require that a controller move to a new key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_NO_NEXT,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::rollover_key_with_key for the version of this
							method that accepts a key.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SymKeyController::rollover_key_with_key()</preamble>
<artwork><![CDATA[CICM::Status rollover_key_with_key(
	in  CICM::SymKey next_key
);]]></artwork>
						<postamble>Specify the next pre-placed key to be used with this
						controller.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>A call to this method may be required when a key reaches
							the end of its specified or usable lifespan or for other
							reasons that require that a controller move to a new key.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] next_key Reference to pre-placed key to use with this
								  controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_CLASSIFICATION,
							  S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::SymKey::rollover_key for the version of this method for which the key is implicit.</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::AsymKeyController">
					<figure>
					  <preamble>Interface CICM::AsymKeyController</preamble>
					  <artwork><![CDATA[interface AsymKeyController : CICM::Controller {]]></artwork>
					<postamble>Interface from which all controllers using an asymmetric key
					inherit.</postamble>
					</figure>

					<section title="CICM::AsymKeyController Inheritance">
						<t>CICM::AsymKeyController inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::AsymKeyController Attributes">
						<figure>
						  <preamble>AttributeCICM::AsymKeyController::key</preamble>
						  <artwork><![CDATA[readonly attribute CICM::AsymKey key;]]></artwork>
						<postamble>Provides read-only access to the key associated with a
						controller.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::NegotiatedController">
					<figure>
					  <preamble>Interface CICM::NegotiatedController</preamble>
<artwork><![CDATA[interface NegotiatedController :
	CICM::MultiDomainController,
	CICM::AsymKeyController,
	CICM::Negotiator {]]></artwork>
					<postamble>Interface from which all other negotiated controllers inherit.
						A controller that uses a negotiated key.</postamble>
					</figure>

					<section title="CICM::NegotiatedController Inheritance">
						<t>CICM::NegotiatedController inherits from:
							CICM::MultiDomainController, CICM::AsymKeyController and
							CICM::Negotiator.</t>
					</section>
					<section title="CICM::NegotiatedController Attributes">
						<figure>
						  <preamble>AttributeCICM::NegotiatedController::negotiated_grade</preamble>
						  <artwork><![CDATA[readonly attribute CICM::Classification negotiated_grade;]]></artwork>
						<postamble>Returns the grade (classification level) of the channel.</postamble>
						</figure>
					</section>
					<section title="CICM::NegotiatedController Methods">
						<figure>
						  <preamble>Method CICM::NegotiatedController::renegotiate()</preamble>
						  <artwork><![CDATA[CICM::Status renegotiate();]]></artwork>
						<postamble>Renegotiates the traffic encryption key with the associated
						peer.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In cases where the key is no longer usable, e.g. it expired
							or was zeroized, the session MUST be torn down and rebuilt.
							Note that renegotiation MAY NOT need to be explicitly initiated
							in all cases because some modules will automatically initiate a
							renegotiation when sensing a certain condition (e.g., key
							expiration, cumulative traffic volume threshold passed,
							etc.).</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH,
							  S_CHANNEL_ERROR</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::NegotiatedController::initiate_grade_change()</preamble>
<artwork><![CDATA[CICM::Status initiate_grade_change(
	in  CICM::Classification new_grade
);]]></artwork>
						<postamble>Requests a change of grade (classification level) for the
						current traffic.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] new_grade
								  New grade for the traffic.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::NegotiatedController::acknowledge_grade_change()</preamble>
						  <artwork><![CDATA[CICM::Status acknowledge_grade_change();]]></artwork>
						  <postamble>Positively acknowledges the requested change of grade.</postamble>
						</figure>
						<t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::SetVectorController">
					<figure>
					  <preamble>Interface CICM::SetVectorController</preamble>
					  <artwork><![CDATA[interface SetVectorController : CICM::Controller {]]></artwork>
					<postamble>Provides access to the state vector associated with a
					controller.</postamble>
					</figure>
					<!-- t>{FIGURE REMOVED}</t>
					<t>Figure 27. Interface Inheritance Diagram for SetVectorController</t-->

					<section title="CICM::SetVectorController Inheritance">
						<t>CICM::SetVectorController inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::SetVectorController Attributes">
						<figure>
						  <preamble>AttributeCICM::SetVectorController::vec</preamble>
						  <artwork><![CDATA[readonly attribute CICM::Vector vec;]]></artwork>
						<postamble>State vector associated with this controller.</postamble>
						</figure>
					</section>
					<section title="CICM::SetVectorController Methods">
						<figure>
						  <preamble>Method CICM::SetVectorController::set_vector()</preamble>
<artwork><![CDATA[CICM::Status set_vector(
	in  CICM::Vector vec
);]]></artwork>
						<postamble>Set channel state vector.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This state value may be set when a controller is initially
							created (initialization vector). It may also be set on a
							block-by-block basis for appropriate algorithms/modes or for
							each time epoch (e.g., for time-of-day encryption).</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] vec State vector.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SetVectorController::set_vector_no_check()</preamble>
<artwork><![CDATA[CICM::Status set_vector_no_check(
	in  CICM::Vector vec
);]]></artwork>
						  <postamble>Set channel state vector without a policy check.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This state value may be set when a controller is initially
							created (initialization vector) or on a per-message basis,
							depending upon how the cryptographic algorithm uses the vector.
							The length and format of the vector are specific to the
							algorithm associated with the channel and system in which the
							channel is being used.</t>
							<t>This version of the set_vector() method may be used on the
							decrypt side, for example, to specify no TOD check in cases
							where TOD rules are not enforced for decryption.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] vec State vector.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::SetVectorController::reset_vector()</preamble>
						  <artwork><![CDATA[CICM::Status reset_vector();]]></artwork>
						  <postamble>Reset channel state vector to system-dependent value.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This can be used by the client program to manage
							time-of-day or counter rollover.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::GenVectorController">
					<figure>
					  <preamble>Interface CICM::GenVectorController</preamble>
					  <artwork><![CDATA[interface GenVectorController : CICM::SetVectorController {]]></artwork>
					<postamble>Enables an state vector to be generated.</postamble>
					</figure>
					<!-- t>{FIGURE REMOVED}</t>
					<t>Figure 28. Interface Inheritance Diagram
					  for GenVectorController</t -->

					<section title="CICM::GenVectorController Inheritance">
						<t>CICM::GenVectorController inherits from: CICM::SetVectorController.</t>
					</section>
					<section title="CICM::GenVectorController Methods">
						<figure>
						  <preamble>Method CICM::GenVectorController::generate_vector()</preamble>
						  <artwork><![CDATA[CICM::Status generate_vector();]]></artwork>
						<postamble>Generate a vector for this controller utilizing new random
						state.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>It may not be necessary for a client program to explicitly
							generate a vector. Some cryptographic modules will implicitly
							generate an IV, for example, as a byproduct of channel
							creation. In other cases, an existing vector will be associated
							with a controller by calling the
							CICM::SetVectorController::set_vector method.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::GenVectorController::generate_vector_existing_state()</preamble>
						  <artwork><![CDATA[CICM::Status generate_vector_existing_state();]]></artwork>
						<postamble>Generate a vector for this controller utilizing the latest
						unused state.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>It may not be necessary for a client program to explicitly
							generate a vector. Some cryptographic modules will implicitly
							generate an IV, for example, as a byproduct of channel
							creation. In other cases, an existing vector will be associated
							with a controller by calling the
							CICM::SetVectorController::set_vector method.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::ResyncController">
					<figure>
					  <preamble>Interface CICM::ResyncController</preamble>
					  <artwork><![CDATA[interface ResyncController : CICM::Controller {]]></artwork>
					<postamble>Provides methods to resynchronize a controller or conduit.</postamble>
					</figure>

					<section title="CICM::ResyncController Inheritance">
						<t>CICM::ResyncController inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::ResyncController Methods">
						<figure>
						  <preamble>Method CICM::ResyncController::resync()</preamble>
						  <artwork><![CDATA[CICM::Status resync();]]></artwork>
						<postamble>Resynchronize the channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>A client program-initiated resync is required when the host
							is responsible for ensuring cryptographic synchronization is
							maintained because the operating mode used does not enable the
							module to determine that it is out of sync. The action taken by
							the module as the result of a call to this method will differ
							based upon characteristics of the cryptographic algorithm,
							communications path framing, and details of the protocol used
							to achieve cryptographic synchronization between two
							modules.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::ResyncController::resync_with_sync_vector for the
							version of this method that accepts a synchronization
							vector.</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::ResyncController::resync_with_sync_vector()</preamble>
<artwork><![CDATA[CICM::Status resync_with_sync_vector(
	in  CICM::Vector vec
);]]></artwork>
						<postamble>Resynchronize the channel, using the specified
						synchronization vector (required by certain operating modes to
						initiate a resync).</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>A client program-initiated resync is required when the host
							is responsible for ensuring cryptographic synchronization is
							maintained because the operating mode used does not enable the
							module to determine that it is out of sync. The action taken by
							the module as the result of a call to this method will differ
							based upon characteristics of the cryptographic algorithm,
							communications path framing, and details of the protocol used
							to achieve cryptographic synchronization among modules.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] vec Synchronization vector to use to resynchronize the
								  channel.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_INVALID_VECTOR,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::ResyncController::resync for the version of this
							method that does not require a synchronization vector.</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Channel Negotiation" anchor="sec_channel_negotiation">
				<section title="Negotiating Channels and Controllers">
					<t>When creating an
					encryption or decryption channel using an asymmetric keyset, a
					negotiation process must be initiated between the two communicating
					entities, resulting in an ephemeral symmetric key held by each
					entity. The following details the steps in the negotiation process:
					<list style="numbers">
					  <t>Retrieve a negotiator. The client program uses the
					  CICM::ChannelManager to create the appropriate CICM::Negotiator,
					  thus initiating the negotiation.</t>
					  <t>Validate remote peer. Most systems will use a trust anchor to
					  validate that the remote peer is legitimate and will further
					  verify the peer appears on the appropriate access control
					  list(s). In some cases, the above validation will be sufficient.
					  In others, it will be necessary to display information about the
					  remote peer to a human user to receive a positive response from
					  the user that the displayed peer is the expected peer. This
					  validation procedure differs depending upon the display
					  configuration:
					  <list style="symbols">
						<t>If the system is configured with a trusted display,
						information about the remote peer is displayed to the trusted
						display and the user is solicited for a response which is
						returned to the module. The trusted display interactions take
						place independent of the API.</t>
						<t>If the system is not configured with a trusted display, the
						client program uses CICM::Negotiator::get_remote_info to
						retrieve information about the remote peer and then displays
						this information to the user (independent of CICM) to allow the
						user to determine if this is the expected remote peer; the
						client program calls CICM::Negotiator::abort_negotiation to
						abort the negotiation if the user rejects the remote peer.</t>
					  </list></t>
					  <t>Complete negotiation. The client program explicitly completes
					  the negotiation using the negotiator's complete() method.</t>
					</list></t>
					<t>A successful negotation results in a negotiated controller.</t>
				</section>
				<section title="Interface CICM::Negotiator">
					<figure>
					  <preamble>Interface CICM::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator {]]></artwork>
					<postamble>CICM::Negotiator is an abstraction inherited by controllers
					and CICM::KeyProtocolSender to assist in the management of the
					negotiation process.</postamble>
					</figure>

					<section title="CICM::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::Negotiator::get_remote_info()</preamble>
              <artwork><![CDATA[CICM::Status get_remote_info(
	out CICM::PeerInfo peer_info
);]]></artwork>
              <postamble>Retrieve remote peer identification information.
               The peer information must be displayed to the
               local user to enable determination to be made as
               to whether negotiation should continue or be aborted.  If
               the decision is made to abort negotiation, the
               CICM::Negotiator::abort_negotiation method MUST be called to
               destroy any protocol session state.</postamble>
						</figure>
            <t>Parameters:
                <list>
                <t>[out] peer_info
                    Identifying information about the remote peer.</t>
                </list>
            </t><t>Returns:
                <list>
                  <t>S_OK,  S_GENERAL_ERROR,  S_NON_FUNCTIONAL,
                  S_OPERATION_FAILED,  S_POLICY_VIOLATION,
                  S_MODULE_RESOURCES,  S_HOST_RESOURCES,  S_INVALID_STATE,
                  S_ALARM_STATE,  S_MODULE_NOT_AVAILABLE,  S_TIMEOUT,
                  S_NOT_AUTHENTICATED,  S_NOT_AUTHORIZED,  S_NOT_AVAILABLE,
                  S_TOKEN_NOT_PRESENT,  S_TOKEN_ADMIN_NOT_PRESENT,  S_TRUSTED_DISPLAY,
                  S_NEGOTIATION_ABORTED,  S_NEGOTIATION_FAILURE,
                  S_NEGOTIATION_NOT_IN_PROGRESS,  S_NEGOTIATION_TIMEOUT,
                  S_CERT_LOCAL_INVALID,  S_CERT_LOCAL_EXPIRED,  S_CERT_REMOTE_INVALID,
                  S_CERT_REMOTE_EXPIRED,  S_CERT_REMOTE_PATH,  S_CHANNEL_ERROR,
                  S_CHANNEL_PEER_RESET</t>
                </list>
            </t>
						<figure>
							<preamble>Method CICM::Negotiator::abort_negotiation()</preamble>
							<artwork><![CDATA[CICM::Status abort_negotiation();]]></artwork>
              <postamble>Abort negotiation or renegotiation.
               This method must be called in the event the identification
               information for the remote host does not correspond
               to the expected host.</postamble>
						</figure>
            <t>Returns:
              <list>
                <t>S_OK, S_GENERAL_ERROR, S_NON_FUNCTIONAL, S_OPERATION_FAILED,
                S_POLICY_VIOLATION, S_MODULE_RESOURCES, S_HOST_RESOURCES,
                S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
                S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
                S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_NOT_IN_PROGRESS,
                S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET</t>
              </list>
            </t>
					</section>
				</section>
				<section title="Interface CICM::PeerInfo">
					<figure>
					  <preamble>Interface CICM::PeerInfo</preamble>
					  <artwork><![CDATA[interface PeerInfo {]]></artwork>
					<postamble>Information about a peer entity participating in a key
					negotiation.</postamble>
					</figure>

					<section title="CICM::PeerInfo Attributes">
						<figure>
						  <preamble>Attribute CICM::PeerInfo::peer_name</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString peer_name;]]></artwork>
						<postamble>Name/organization of remote entity participating in key
						agreement prototcol.</postamble>
						</figure>
						<figure>
						  <preamble>AttributeCICM::PeerInfo::classification</preamble>
						  <artwork><![CDATA[readonly attribute CICM::Classification classification;]]></artwork>
						<postamble>Highest security classification level at which the remote
						entity participating in the key agreement protocol is capable of
						communicating.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::PeerInfo::compartment</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString compartment;]]></artwork>
						<postamble>Compartment of remote entity participating in key agreement
						protocol.</postamble>
						</figure>
						<figure>
						  <preamble>Attribute CICM::PeerInfo::message</preamble>
						  <artwork><![CDATA[readonly attribute CICM::CharString message;]]></artwork>
						<postamble>Message to be displayed regarding the remote entities'
						participation in key agreement protocol.</postamble>
						</figure>
					</section>
				</section>
			</section>
			<section anchor="sec-encrypt" title="Encryption">
				<figure>
				  <preamble>Namespace CICM::Encrypt</preamble>
				  <artwork><![CDATA[module Encrypt {]]></artwork>
				<postamble>The CICM::Encrypt namespace contains interfaces that support
				encryption operations between two independent security domains.</postamble>
				</figure>
				<!--t>{FIGURE REMOVED}</t>
				<t>Figure 29. Interface Relationship Diagram
				  for Encryption Channels</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 30. Interface Relationship Diagram
				  for Negotiated Encryption Channels</t-->

				<section title="Interface CICM::Encrypt::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::Encrypt::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Encrypt::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of encryption
					negotiators, conduits, controllers, and streams. See
					CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::Encrypt::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Encrypt::Negotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will encrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::SymKey mac_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	out CICM::Encrypt::WithMACNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will MAC and encrypt a stream of data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Negotiation applies only to the negotiation key, not the
							MAC key.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] mac_key_ref
								  Reference to MAC key.</t>
							<t>[in] nego_key_ref
								  Reference to negotiation key.</t>
							<t>[in] mac_algorithm
								  MAC algorithm.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_with_sign_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_with_sign_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey sign_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	out CICM::Encrypt::WithSignNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will sign and encrypt a stream of
						data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Negotiation applies only to the negotiation key, not the
							signature key.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] sign_key_ref
								  Reference to signature key.</t>
							<t>[in] nego_key_ref
								  Reference to negotiation key.</t>
							<t>[in] sign_algorithm
								  Signature algorithm.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::negotiate_encrypt_controller()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Encrypt::ControllerNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage an encryption channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::create_encrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Encrypt::Conduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to encrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[in] algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::create_encrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encr_algorithm,
	out CICM::Encrypt::WithMACConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to MAC and encrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] mac_key_ref
								  Reference to MAC key.</t>
							<t>[in] encrypt_key_ref
								  Reference to encryption key.</t>
							<t>[in] mac_algorithm
								  MAC algorithm.</t>
							<t>[in] encr_algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::create_encrypt_with_sign_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_with_sign_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::AsymKey sign_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	in  CICM::SymEncrAlgorithmId encr_algorithm,
	out CICM::Encrypt::WithSignConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to sign and encrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] sign_key_ref
								  Reference to signature key.</t>
							<t>[in] encrypt_key_ref
								  Reference to encryption key.</t>
							<t>[in] sign_algorithm
								  Signature algorithm.</t>
							<t>[in] encr_algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::create_key_wrap_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_key_wrap_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey kek_ref,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::Encrypt::KeyWrapConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to wrap a key.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This type of conduit may be used to wrap key material bound
							for a peer cryptographic module. To wrap individual keys
							already in the module, use CICM::Symkey::wrap or
							CICM::Asymkey::wrap.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] kek_ref
								  Reference to key encryption key.</t>
							<t>[in] algorithm
								  Key wrapping algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::create_encrypt_controller()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Encrypt::Controller controller_ref
);]]></artwork>
						<postamble>Create controller to configure and control an encryption
						channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and MUST be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[in] algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::ChannelManager::get_encrypt_stream()</preamble>
<artwork><![CDATA[CICM::Status get_encrypt_stream(
	in  CICM::LocalPort local_port,
	out CICM::Encrypt::Stream stream_ref
);]]></artwork>
						<postamble>Create stream associated with previously created controller
						to accept data for transformation.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::Stream">
					<figure>
					  <preamble>Interface CICM::Encrypt::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::WriteStream {]]></artwork>
					<postamble>CICM::Encrypt::Stream supports encryption operations between
					two independent security domains. The resulting stream is capable
					of accepting data for transformation, but not managing the channel.
					It is created by calling CICM::ChannelManager::get_encrypt_stream.</postamble>
					</figure>

					<section title="CICM::Encrypt::Stream Inheritance">
						<t>CICM::Encrypt::Stream inherits from: CICM::WriteStream.</t>
					</section>
					<section title="CICM::Encrypt::Stream Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::Stream::encrypt()</preamble>
<artwork><![CDATA[CICM::Status encrypt(
	in  CICM::Buffer buffer
);]]></artwork>
						<postamble>Sends data to the module to be encrypted. The method blocks
						until data is sent.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] buffer
								  Plaintext to encrypt.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::Stream::encrypt_non_blocking()</preamble>
<artwork><![CDATA[CICM::Status encrypt_non_blocking(
	in  CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);]]></artwork>
						<postamble>Registers a buffer of data to be sent to the module for
						encryption and then immediately returns control to the caller. The
						length of the data is encapsulated in the buffer parameter. The
						caller may use the CICM::Encrypt::Stream::encrypt_poll method to
						proactively poll the channel to determine the status of the
						operation. The caller is responsible for maintaining any necessary
						metadata associated with the transaction_id parameter. Memory
						responsibilities and calling conventions MUST follow the
						appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] buffer
								  Plaintext to encrypt.</t>
							<t>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::Encrypt::Stream::encrypt_poll method to determine
								  to which buffer the poll status applies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Encrypt::Stream::encrypt_poll()</preamble>
<artwork><![CDATA[CICM::Status encrypt_poll(
	in  CICM::TransId transaction_id,
	out CICM::WriteStream::WriteStatus status
);]]></artwork>
						<postamble>Returns the status of the non-blocking encryption operation
						specified by the transaction_id parameter. Memory responsibilities
						and calling conventions shall follow the appropriate IDL language
						mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::Encrypt::Stream::encrypt_non_blocking method that
								  allows the poll operation to determine to which buffer
								  the poll status applies.</t>
							<t>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::KeyWrapStream">
					<figure>
					  <preamble>Interface  CICM::Encrypt::KeyWrapStream</preamble>
					  <artwork><![CDATA[interface KeyWrapStream : CICM::Stream {]]></artwork>
					<postamble>CICM::Encrypt::KeyWrapStream is an abstraction that allows
					key material to be presented to a stream for wrapping prior to
					passing into a different security domain.</postamble>
					</figure>

					<section title="CICM::Encrypt::KeyWrapStream Inheritance">
						<t>CICM::Encrypt::KeyWrapStream inherits from: CICM::Stream.</t>
					</section>
					<section title="CICM::Encrypt::KeyWrapStream Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::KeyWrapStream::wrap_key()</preamble>
<artwork><![CDATA[CICM::Status wrap_key(
	in CICM::Key key_ref
);]]></artwork>
						<postamble>Write the key to be wrapped to the channel stream.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The method blocks until the key has been written.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to key to be wrapped.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_CLASSIFICATION, S_KEY_WRAPPED,
							  S_KEY_NOT_WRAPPABLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::Controller">
					<figure>
					  <preamble>Interface CICM::Encrypt::Controller</preamble>
<artwork><![CDATA[interface Controller :
	CICM::MultiDomainController,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::ResyncController {]]></artwork>
					<postamble>CICM::Encrypt::Controller supports encryption operations
					between two independent security domains. The resulting controller
					is capable of managing the channel, but not accepting data for
					transformation. It is created by calling
					CICM::ChannelManager::create_encrypt_controller.</postamble>
					</figure>

					<section title="CICM::Encrypt::Controller Inheritance">
						<t>CICM::Encrypt::Controller inherits from:
						CICM::MultiDomainController, CICM::SymKeyController,
						CICM::GenVectorController and CICM::ResyncController.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::NegotiatedController">
					<figure>
					  <preamble>Interface  CICM::Encrypt::NegotiatedController</preamble>
<artwork><![CDATA[interface NegotiatedController :
	CICM::NegotiatedController,
	CICM::GenVectorController,
	CICM::ResyncController {]]></artwork>
					<postamble>CICM::Encrypt::NegotiatedController is the negotiated version
					of CICM::Encrypt::Controller. It is the result of a successful
					negotiation by CICM::Encrypt::ControllerNegotiator.</postamble>
					</figure>
					<section title="CICM::Encrypt::NegotiatedController Inheritance">
						<t>CICM::Encrypt::NegotiatedController inherits from:
						CICM::NegotiatedController, CICM::GenVectorController and
						CICM::ResyncController.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::Conduit">
					<figure>
					  <preamble>Interface CICM::Encrypt::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Conduit,
	CICM::Encrypt::Controller,
	CICM::Encrypt::Stream {]]></artwork>
					<postamble>CICM::Encrypt::Conduit supports encryption operations between
					two independent security domains. The resulting conduit is capable
					of both managing the channel and accepting data for transformation.
					It is created by calling
					CICM::ChannelManager::create_encrypt_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::Conduit Inheritance">
						<t>CICM::Encrypt::Conduit
						inherits from: CICM::Conduit, CICM::Encrypt::Controller and
						CICM::Encrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::NegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Encrypt::NegotiatedConduit</preamble>
<artwork><![CDATA[interface NegotiatedConduit :
CICM::Conduit,
CICM::Encrypt::NegotiatedController,
CICM::Encrypt::Stream {]]></artwork>
					<postamble>CICM::Encrypt::NegotiatedConduit is the negotiated version of
					CICM::Encrypt::Conduit. It is the result of a successful
					negotiation by CICM::Encrypt::Negotiator.</postamble>
					</figure>
					<section title="CICM::Encrypt::NegotiatedConduit Inheritance">
						<t>CICM::Encrypt::NegotiatedConduit inherits from:
						CICM::Conduit, CICM::Encrypt::NegotiatedController and
						CICM::Encrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithMACConduit">
					<figure>
					  <preamble>Interface CICM::Encrypt::WithMACConduit</preamble>
<artwork><![CDATA[interface WithMACConduit :
CICM::AbstractMACConduit,
CICM::Encrypt::Conduit {]]></artwork>
					<postamble>CICM::Encrypt::WithMACConduit supports encryption operations
					between two independent security domains with the receipt of a MAC
					value in the initiating domain. The resulting conduit is capable of
					both managing the channel and accepting data for transformation. It
					is created by calling
					CICM::ChannelManager::create_encrypt_with_mac_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithMACConduit Inheritance">
						<t>CICM::Encrypt::WithMACConduit inherits from:
						CICM::AbstractMACConduit and CICM::Encrypt::Conduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithMACNegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Encrypt::WithMACNegotiatedConduit</preamble>
<artwork><![CDATA[interface WithMACNegotiatedConduit :
CICM::AbstractMACConduit,
CICM::Encrypt::NegotiatedConduit {]]></artwork>
					<postamble>CICM::Encrypt::WithMACNegotiatedConduit is the negotiated
					version of CICM::Encrypt::WithMACConduit. It is the result of a
					successful negotiation by CICM::Encrypt::WithMACNegotiator.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithMACNegotiatedConduit Inheritance">
						<t>CICM::Encrypt::WithMACNegotiatedConduit inherits
						from: CICM::AbstractMACConduit and
						CICM::Encrypt::NegotiatedConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithSignConduit">
					<figure>
					  <preamble>Interface  CICM::Encrypt::WithSignConduit</preamble>
<artwork><![CDATA[interface WithSignConduit :
CICM::AbstractSignConduit,
CICM::Encrypt::Conduit {]]></artwork>
					<postamble>CICM::Encrypt::WithSignConduit supports encryption operations
					between two independent security domains with the receipt of a
					signature value in the initiating domain. The resulting conduit is
					capable of both managing the channel and accepting data for
					transformation. It is created by calling
					CICM::ChannelManager::create_encrypt_with_sign_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithSignConduit Inheritance">
						<t>CICM::Encrypt::WithSignConduit inherits from:
						CICM::AbstractSignConduit and CICM::Encrypt::Conduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithSignNegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Encrypt::WithSignNegotiatedConduit</preamble>
<artwork><![CDATA[interface WithSignNegotiatedConduit :
CICM::AbstractSignConduit,
CICM::Encrypt::NegotiatedConduit {]]></artwork>
					<postamble>CICM::Encrypt::WithSignNegotiatedConduit is the negotiated
					version of CICM::Encrypt::WithSignConduit. It is the result of a
					successful negotiation by CICM::Encrypt::WithSignNegotiator.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithSignNegotiatedConduit Inheritance">
						<t>CICM::Encrypt::WithSignNegotiatedConduit inherits
						from: CICM::AbstractSignConduit and
						CICM::Encrypt::NegotiatedConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::KeyWrapConduit">
					<figure>
					  <preamble>Interface  CICM::Encrypt::KeyWrapConduit</preamble>
<artwork><![CDATA[interface KeyWrapConduit :
CICM::Encrypt::Controller,
CICM::Encrypt::KeyWrapStream {]]></artwork>
					<postamble>CICM::Encrypt::KeyWrapConduit supports key wrapping
					operations between two independent security domains. The resulting
					conduit is capable of both managing the channel and accepting keys
					for transformation. It is created by calling
					CICM::ChannelManager::create_key_wrap_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::KeyWrapConduit Inheritance">
						<t>CICM::Encrypt::KeyWrapConduit inherits from:
						CICM::Encrypt::Controller and CICM::Encrypt::KeyWrapStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::ControllerNegotiator">
					<figure>
					  <preamble>Interface  CICM::Encrypt::ControllerNegotiator</preamble>
					  <artwork><![CDATA[interface ControllerNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Encrypt::ControllerNegotiator initiates a negotiation
					to establish a shared key with a remote entity that is used to
					support encryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Encrypt::NegotiatedController which is capable of managing
					the channel, but not accepting data for transformation.
					CICM::Encrypt::ControllerNegotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_controller.</postamble>
					</figure>
					<section title="CICM::Encrypt::ControllerNegotiator Inheritance">
						<t>CICM::Encrypt::ControllerNegotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::Encrypt::ControllerNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::ControllerNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Encrypt::NegotiatedController controller_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated negotiated
						encrypt controller.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::Negotiator">
					<figure>
					  <preamble>Interface CICM::Encrypt::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Encrypt::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains. The
					result of a successful negotiation is a
					CICM::Encrypt::NegotiatedConduit which is capable of both managing
					the channel and accepting data for transformation. CICM::Negotiator
					is created by calling
					CICM::Encrypt::ChannelManager::negotiate_encrypt_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::Negotiator Inheritance">
						<t>CICM::Encrypt::Negotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::Encrypt::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::Negotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Encrypt::NegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated encrypt
						conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithMACNegotiator">
					<figure>
					  <preamble>Interface  CICM::Encrypt::WithMACNegotiator</preamble>
					  <artwork><![CDATA[interface WithMACNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Encrypt::WithMACNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains.
					Additionally, a message authentication code (MAC) is received in the
					initiating domain. The result of a successful negotiation is a
					CICM::Encrypt::WithMACNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Encrypt::WithMACNegotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_with_mac_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithMACNegotiator Inheritance">
						<t>CICM::Encrypt::WithMACNegotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::Encrypt::WithMACNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::WithMACNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Encrypt::WithMACNegotiatedConduit conduit_ref
);]]></artwork>
							<postamble>Complete negotiation and retrieve a negotiated MAC encrypt conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Encrypt::WithSignNegotiator">
					<figure>
					  <preamble>Interface  CICM::Encrypt::WithSignNegotiator</preamble>
					  <artwork><![CDATA[interface WithSignNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Encrypt::WithSignNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains.
					Additionally, a signature value is received in the initiating
					domain. The result of a successful negotiation is a
					CICM::Encrypt::WithSignNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Encrypt::WithSignNegotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_with_sign_conduit.</postamble>
					</figure>
					<section title="CICM::Encrypt::WithSignNegotiator Inheritance">
						<t>CICM::Encrypt::WithSignNegotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::Encrypt::WithSignNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Encrypt::WithSignNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Encrypt::WithSignNegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated sign encrypt
						conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section anchor="sec-decrypt" title="Decryption">
				<figure>
				  <preamble>Namespace CICM::Decrypt</preamble>
				  <artwork><![CDATA[module Decrypt {]]></artwork>
				<postamble>The CICM::Decrypt namespace contains interfaces that support
				decryption operations between two independent security domains.</postamble>
				</figure>
				<!-- t>{FIGURE REMOVED}</t>
				<t>Figure 31. Interface Relationship Diagram
				  for Decryption Channels</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 32. Interface Relationship Diagram
				  for Negotiated Decryption Channels</t-->

				<section title="Interface CICM::Decrypt::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::Decrypt::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Decrypt::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of decryption
					negotiators, conduits, controllers, and streams. See
					CICM::ChannelManager for additional information.</postamble>
					</figure>
					<section title="CICM::Decrypt::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Decrypt::Negotiator negotiator_ref
);]]></artwork>
						<postamble>Creates a negotiator that, upon successful negotiation,
						results in a CICM::Decrypt::NegotiatedConduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::SymKey verify_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::SymMacAlgorithmId verify_algorithm,
	out CICM::Decrypt::WithMACNegotiator negotiator_ref
);]]></artwork>
						<postamble>Creates a negotiator that, upon successful negotiation,
						results in a CICM::Decrypt::MACNegotiatedConduit.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Negotiation applies only to the negotiation key, not the
							MAC key.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] verify_key_ref
								  Reference to verification key.</t>
							<t>[in] nego_key_ref
								  Reference to negotiation key.</t>
							<t>[in] verify_algorithm
								  Verification algorithm.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_with_verify_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_with_verify_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey verify_key_ref,
	in  CICM::AsymKey nego_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	out CICM::Decrypt::WithVerifyNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will decrypt and verify a stream of
						data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Negotiation applies only to the negotiation key, not the
							signature verification key.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] verify_key_ref
								  Reference to verification key.</t>
							<t>[in] nego_key_ref
								  Reference to negotiation key.</t>
							<t>[in] verify_algorithm
								  Verification algorithm.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::negotiate_decrypt_controller()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Decrypt::ControllerNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage a decryption channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::create_decrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Decrypt::Conduit conduit_ref
);]]></artwork>
						  <postamble>Create channel to decrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::create_decrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_with_mac_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::SymMacAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Decrypt::WithMACConduit conduit_ref
);]]></artwork>
						<postamble>Create channel to MAC verify and decrypt a stream of
						data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] verify_key_ref
								  Reference to verification key.</t>
							<t>[in] decrypt_key_ref
								  Reference to decryption key.</t>
							<t>[in] verify_algorithm
								  Verification algorithm.</t>
							<t>[in] decrypt_algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::create_decrypt_with_verify_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_with_verify_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::AsymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Decrypt::WithVerifyConduit conduit_ref
);]]></artwork>
						  <postamble>Create channel to verify and decrypt a stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] verify_key_ref
								  Reference to verification key.</t>
							<t>[in] decrypt_key_ref
								  Reference to decryption key.</t>
							<t>[in] verify_algorithm
								  Verification algorithm.</t>
							<t>[in] decrypt_algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::create_key_unwrap_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_key_unwrap_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey kek_ref,
	in  CICM::KeyWrapAlgorithmId algorithm,
	out CICM::Decrypt::KeyUnwrapConduit conduit_ref
);]]></artwork>
						<postamble>Create channel to unwrap a key. This type of channel may be
						used to bulk unwrap key material originating at a key
						infrastructure component or from a peer cryptographic module. Note
						that, to unwrap individual keys already in the module, use
						CICM::Symkey::unwrap or CICM::Asymkey::unwrap.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] kek_ref
								  Reference to key encryption key.</t>
							<t>[in] algorithm
								  Key unwrapping algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::create_decrypt_controller()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Decrypt::Controller controller_ref
);]]></artwork>
						<postamble>Create controller to configure and control an decryption
						channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::ChannelManager::get_decrypt_stream()</preamble>
<artwork><![CDATA[CICM::Status get_decrypt_stream(
	in  CICM::LocalPort local_port,
	out CICM::Decrypt::Stream stream_ref
);]]></artwork>
						<postamble>Create stream associated with previously created controller
						to receive transformed data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::Stream">
					<figure>
					  <preamble>Interface CICM::Decrypt::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::ReadStream {]]></artwork>
					<postamble>CICM::Decrypt::Stream supports decryption operations between
					two independent security domains. The resulting stream is capable
					of accepting transformed data, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_decrypt_stream.</postamble>
					</figure>

					<section title="CICM::Decrypt::Stream Inheritance">
						<t>CICM::Decrypt::Stream inherits from: CICM::ReadStream.</t>
					</section>
					<section title="CICM::Decrypt::Stream Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::Stream::decrypt()</preamble>
<artwork><![CDATA[CICM::Status decrypt(
	out CICM::Buffer buffer
);]]></artwork>
						<postamble>Read plaintext data off of decrypt channel stream. The method
						blocks until data becomes available.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] buffer
								  Plaintext resulting from decryption operation.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INTEGRITY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::Stream::decrypt_non_blocking()</preamble>
<artwork><![CDATA[CICM::Status decrypt_non_blocking(
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);]]></artwork>
						<postamble>Registers a buffer into which plaintext resulting from the
						decryption operation will be copied, and then immediately returns
						control to the caller. The size of the allocated buffer and length
						of the resulting plaintext is encapsulated in the buffer parameter.
						The caller may use the CICM::Decrypt::Stream::decrypt_poll method
						to proactively poll the channel to determine the status of the
						operation. The caller is responsible for maintaining any necessary
						metadata associated with the transaction_id parameter. Memory
						responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] buffer
								  Plaintext resulting from decryption operation.</t>
							<t>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::Decrypt::Stream::decrypt_poll method to determine
								  to which buffer the poll status applies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INTEGRITY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::Stream::decrypt_poll()</preamble>
<artwork><![CDATA[CICM::Status decrypt_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);]]></artwork>
						<postamble>Returns the status of the non-blocking decryption operation
						specified by the transaction_id parameter. Upon completion of the
						operation, the caller must use the metadata associated with the
						transaction_id parameter to determine which buffer has been
						populated. Memory responsibilities and calling conventions shall
						follow the appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::Decrypt::Stream::decrypt_non_blocking method that
								  allows the poll operation to determine to which buffer
								  the poll status applies.</t>
							<t>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::KeyUnwrapStream">
					<figure>
					  <preamble>Interface  CICM::Decrypt::KeyUnwrapStream</preamble>
					  <artwork><![CDATA[interface KeyUnwrapStream : CICM::Stream {]]></artwork>
					<postamble>CICM::Decrypt::KeyUnwrapStream is an abstraction that allows
					unwrapped key material received from another domain to be
					retrieved.</postamble>
					</figure>

					<section title="CICM::Decrypt::KeyUnwrapStream Inheritance">
						<t>CICM::Decrypt::KeyUnwrapStream inherits from:
						CICM::Stream.</t>
					</section>
					<section title="CICM::Decrypt::KeyUnwrapStream Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::KeyUnwrapStream::unwrap_sym_key()</preamble>
<artwork><![CDATA[CICM::Status unwrap_sym_key(
	out CICM::SymKey key_ref
);]]></artwork>
						<postamble>Read one unwrapped symmetric key off of channel stream and
						return a reference to the key. The method blocks until a key
						becomes available.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to key encryption key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Decrypt::KeyUnwrapStream::unwrap_asym_key()</preamble>
<artwork><![CDATA[CICM::Status unwrap_asym_key(
	out CICM::AsymKey key_ref
);]]></artwork>
						<postamble>Read one unwrapped asymmetric key off of channel stream and
						return a reference to the key. The method blocks until a key
						becomes available.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to key encryption key.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::Controller">
					<figure>
					  <preamble>Interface CICM::Decrypt::Controller</preamble>
<artwork><![CDATA[interface Controller :
	CICM::MultiDomainController,
	CICM::SymKeyController,
	CICM::SetVectorController,
	CICM::ResyncController {]]></artwork>
					<postamble>CICM::Decrypt::Controller supports decryption operations
					between two independent security domains. The resulting controller
					is capable of managing the channel, but not accepting transformed
					data. It is created by calling
					CICM::ChannelManager::create_decrypt_controller.</postamble>
					</figure>
					<section title="CICM::Decrypt::Controller Inheritance">
						<t>CICM::Decrypt::Controller inherits from:
						CICM::MultiDomainController, CICM::SymKeyController,
						CICM::SetVectorController and CICM::ResyncController.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::NegotiatedController">
					<figure>
					  <preamble>Interface  CICM::Decrypt::NegotiatedController</preamble>
<artwork><![CDATA[interface NegotiatedController :
	CICM::NegotiatedController,
	CICM::SetVectorController,
	CICM::ResyncController {]]></artwork>
					<postamble>CICM::Decrypt::NegotiatedController is the negotiated version
					of CICM::Decrypt::Controller. It is the result of a successful
					negotiation by CICM::Decrypt::ControllerNegotiator.</postamble>
					</figure>

					<section title="CICM::Decrypt::NegotiatedController Inheritance">
						<t>CICM::Decrypt::NegotiatedController inherits from:
						CICM::NegotiatedController, CICM::SetVectorController and
						CICM::ResyncController.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::Conduit">
					<figure>
					  <preamble>Interface CICM::Decrypt::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Conduit,
	CICM::Decrypt::Controller,
	CICM::Decrypt::Stream {]]></artwork>
					<postamble>CICM::Decrypt::Conduit supports decryption operations between
					two independent security domains. The resulting conduit is capable
					of both managing the channel and accepting transformed data. It is
					created by calling CICM::ChannelManager::create_decrypt_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::Conduit Inheritance">
						<t>CICM::Decrypt::Conduit
						inherits from: CICM::Conduit, CICM::Decrypt::Controller and
						CICM::Decrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::NegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::NegotiatedConduit</preamble>
<artwork><![CDATA[interface NegotiatedConduit :
	CICM::Conduit,
	CICM::Decrypt::NegotiatedController,
	CICM::Decrypt::Stream {]]></artwork>
					<postamble>CICM::Decrypt::NegotiatedConduit is the negotiated version of
					CICM::Decrypt::Conduit. It is the result of a successful
					negotiation by CICM::Decrypt::Negotiator.</postamble>
					</figure>
					<section title="CICM::Decrypt::NegotiatedConduit Inheritance">
						<t>CICM::Decrypt::NegotiatedConduit inherits from:
						CICM::Conduit, CICM::Decrypt::NegotiatedController and
						CICM::Decrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithMACConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithMACConduit</preamble>
<artwork><![CDATA[interface WithMACConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Decrypt::Conduit {]]></artwork>
					<postamble>CICM::Decrypt::WithMACConduit supports decryption operations
					between two independent security domains with the receipt of an
					indication as to whether MAC verification succeeded or failed in
					the initiating domain. The resulting conduit is capable of both
					managing the channel and accepting data for transformation. It is
					created by calling
					CICM::ChannelManager::create_decrypt_with_mac_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithMACConduit Inheritance">
						<t>CICM::Decrypt::WithMACConduit inherits from:
						CICM::AbstractMACVerifyConduit and CICM::Decrypt::Conduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithMACNegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithMACNegotiatedConduit</preamble>
<artwork><![CDATA[interface WithMACNegotiatedConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Decrypt::NegotiatedConduit {]]></artwork>
					<postamble>CICM::Decrypt::WithMACNegotiatedConduit is the negotiated
					version of CICM::Decrypt::WithMACConduit. It is the result of a
					successful negotiation by CICM::Decrypt::WithMACNegotiator.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithMACNegotiatedConduit Inheritance">
						<t>CICM::Decrypt::WithMACNegotiatedConduit inherits
						from: CICM::AbstractMACVerifyConduit and
						CICM::Decrypt::NegotiatedConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithVerifyConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithVerifyConduit</preamble>
<artwork><![CDATA[interface WithVerifyConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Decrypt::Conduit {]]></artwork>
					<postamble>CICM::Decrypt::WithVerifyConduit supports decryption
					operations between two independent security domains with the
					receipt of an indication as to whether signature verification
					succeeded or failed in the initiating domain. The resulting conduit
					is capable of both managing the channel and accepting transformed
					data. It is created by calling
					CICM::ChannelManager::create_decrypt_with_verify_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithVerifyConduit Inheritance">
						<t>CICM::Decrypt::WithVerifyConduit inherits from:
						CICM::AbstractSigVerifyConduit and CICM::Decrypt::Conduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithVerifyNegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithVerifyNegotiatedConduit</preamble>
<artwork><![CDATA[interface WithVerifyNegotiatedConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Decrypt::NegotiatedConduit {]]></artwork>
					<postamble>CICM::Decrypt::WithVerifyNegotiatedConduit is the negotiated
					version of CICM::Decrypt::WithVerifyConduit. It is the result of a
					successful negotiation by CICM::Decrypt::WithVerifyNegotiator.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithVerifyNegotiatedConduit Inheritance">
						<t>CICM::Decrypt::WithVerifyNegotiatedConduit inherits
						from: CICM::AbstractSigVerifyConduit and
						CICM::Decrypt::NegotiatedConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::KeyUnwrapConduit">
					<figure>
					  <preamble>Interface  CICM::Decrypt::KeyUnwrapConduit</preamble>
<artwork><![CDATA[interface KeyUnwrapConduit :
	CICM::Decrypt::Controller,
	CICM::Decrypt::KeyUnwrapStream {]]></artwork>
					<postamble>CICM::Decrypt::KeyUnwrapConduit supports key unwrapping
					operations between two independent security domains. The resulting
					conduit is capable of both managing the channel and accepting
					transformed keys. It is created by calling
					CICM::ChannelManager::create_key_unwrap_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::KeyUnwrapConduit Inheritance">
						<t>CICM::Decrypt::KeyUnwrapConduit inherits from:
						CICM::Decrypt::Controller and CICM::Decrypt::KeyUnwrapStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::Negotiator">
					<figure>
					  <preamble>Interface CICM::Decrypt::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Decrypt::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains. The
					result of a successful negotiation is a
					CICM::Decrypt::NegotiatedConduit which is capable of both managing
					the channel and accepting data for transformation.
					CICM::Decrypt::Negotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_conduit.</postamble>
					</figure>

					<section title="CICM::Decrypt::Negotiator Inheritance">
						<t>CICM::Decrypt::Negotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Decrypt::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::Negotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Decrypt::NegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated decrypt
						conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::ControllerNegotiator">
					<figure>
					  <preamble>Interface  CICM::Decrypt::ControllerNegotiator</preamble>
					  <artwork><![CDATA[interface ControllerNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Decrypt::ControllerNegotiator initiates a negotiation
					to establish a shared key with a remote entity that is used to
					support decryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Decrypt::NegotiatedController which is capable of managing
					the channel, but not accepting data for transformation.
					CICM::Decrypt::ControllerNegotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_controller.</postamble>
					</figure>
					<section title="CICM::Decrypt::ControllerNegotiator Inheritance">
						<t>CICM::Decrypt::ControllerNegotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Decrypt::ControllerNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::ControllerNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Decrypt::NegotiatedController controller_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated control-only
						decrypt channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithMACNegotiator">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithMACNegotiator</preamble>
					  <artwork><![CDATA[interface WithMACNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Decrypt::WithMACNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					decryption operations between two independent security domains.
					Additionally, a message authentication code is received in the
					initiating domain. The result of a successful negotiation is a
					CICM::Decrypt::WithMACNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Decrypt::WithMACNegotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_with_mac_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithMACNegotiator Inheritance">
						<t>CICM::Decrypt::WithMACNegotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Decrypt::WithMACNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::WithMACNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Decrypt::WithMACNegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated MAC verify
						decrypt conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Decrypt::WithVerifyNegotiator">
					<figure>
					  <preamble>Interface  CICM::Decrypt::WithVerifyNegotiator</preamble>
					  <artwork><![CDATA[interface WithVerifyNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Decrypt::WithVerifyNegotiator initiates a negotiation
					to establish a shared key with a remote entity that is used to
					support decryption operations between two independent security
					domains. Additionally, an indication as to whether verification
					succeeded or failed is received in the initiating domain. The
					result of a successful negotiation is a
					CICM::Decrypt::WithVerifyNegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::Decrypt::WithVerifyNegotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_with_verify_conduit.</postamble>
					</figure>
					<section title="CICM::Decrypt::WithVerifyNegotiator Inheritance">
						<t>CICM::Decrypt::WithVerifyNegotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Decrypt::WithVerifyNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Decrypt::WithVerifyNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Decrypt::WithVerifyNegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated verify and
						decrypt conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section anchor="sec-duplex" title="Duplex">
				<figure>
				  <preamble>Namespace CICM::Duplex</preamble>
				  <artwork><![CDATA[module Duplex {]]></artwork>
				<postamble>The CICM::Duplex namespace contains interfaces that support
				encryption/decryption operations between two independent security
				domains.</postamble>
				</figure>
				<!-- t>{FIGURE REMOVED}</t>
				<t>Figure 33. Interface Relationship Diagram
				  for Duplex Channels</t -->

				<section title="Interface CICM::Duplex::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::Duplex::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Duplex::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of
					encryption/decryption negotiators, conduits, controllers, and
					streams. See CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::Duplex::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Duplex::ChannelManager::negotiate_duplex_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_duplex_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Duplex::Negotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a conduit that results will encrypt/decrypt data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Duplex::ChannelManager::negotiate_duplex_controller()</preamble>
<artwork><![CDATA[CICM::Status negotiate_duplex_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::Duplex::ControllerNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage a duplex channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Duplex::ChannelManager::create_duplex_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_duplex_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Duplex::Conduit conduit_ref
);]]></artwork>
						<postamble>Create duplex channel to encrypt/decrypt a stream of
						data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Encryption/decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Duplex::ChannelManager::create_duplex_controller()</preamble>
<artwork><![CDATA[CICM::Status create_duplex_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Duplex::Controller controller_ref
);]]></artwork>
						<postamble>Create controller to configure and control a duplex
						channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[in] algorithm
								  Encryption/decryption algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Duplex::ChannelManager::get_duplex_stream()</preamble>
<artwork><![CDATA[CICM::Status get_duplex_stream(
	in  CICM::LocalPort local_port,
	out CICM::Duplex::Stream stream_ref
);]]></artwork>
						<postamble>Create stream associated with previously created controller
						to accept data for transformation.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::Stream">
					<figure>
					  <preamble>Interface CICM::Duplex::Stream</preamble>
<artwork><![CDATA[interface Stream :
	CICM::Encrypt::Stream,
	CICM::Decrypt::Stream {]]></artwork>
					<postamble>CICM::Duplex::Stream supports encryption/decryption
					operations between two independent security domains. The resulting
					stream is capable of accepting data for transformation and
					receiving transformed data, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_duplex_stream.</postamble>
					</figure>
					<section title="CICM::Duplex::Stream Inheritance">
						<t>CICM::Duplex::Stream
						inherits from: CICM::Encrypt::Stream and
						CICM::Decrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::Controller">
					<figure>
					  <preamble>Interface CICM::Duplex::Controller</preamble>
<artwork><![CDATA[interface Controller :
	CICM::Encrypt::Controller,
	CICM::Decrypt::Controller {]]></artwork>
					<postamble>CICM::Duplex::Controller supports encryption/decryption
					operations between two independent security domains. The resulting
					controller is capable of managing the channel, but not accepting
					data for transformation and receiving transformed data. It is
					created by calling CICM::ChannelManager::create_duplex_controller.</postamble>
					</figure>
					<section title="CICM::Duplex::Controller Inheritance">
						<t>CICM::Duplex::Controller inherits from:
						CICM::Encrypt::Controller and CICM::Decrypt::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::NegotiatedController">
					<figure>
					  <preamble>Interface  CICM::Duplex::NegotiatedController</preamble>
<artwork><![CDATA[interface NegotiatedController :
	CICM::Encrypt::NegotiatedController,
	CICM::Decrypt::NegotiatedController {]]></artwork>
					<postamble>CICM::Duplex::NegotiatedController is the negotiated version
					of CICM::Duplex::Controller. It is the result of a successful
					negotiation by CICM::Duplex::ControllerNegotiator.</postamble>
					</figure>
					<section title="CICM::Duplex::NegotiatedController Inheritance">
						<t>CICM::Duplex::NegotiatedController inherits from:
						CICM::Encrypt::NegotiatedController and
						CICM::Decrypt::NegotiatedController.</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::Conduit">
					<figure>
					  <preamble>Interface CICM::Duplex::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Conduit,
	CICM::Duplex::Controller,
	CICM::Duplex::Stream {]]></artwork>
					<postamble>CICM::Duplex::Conduit supports encryption/decryption
					operations between two independent security domains. The resulting
					conduit is capable of both managing the channel and accepting data
					for transformation and receiving transformed data. It is created by
					calling CICM::ChannelManager::create_duplex_conduit.</postamble>
					</figure>
					<section title="CICM::Duplex::Conduit Inheritance">
						<t>CICM::Duplex::Conduit
						inherits from: CICM::Conduit, CICM::Duplex::Controller and
						CICM::Duplex::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::NegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::Duplex::NegotiatedConduit</preamble>
<artwork><![CDATA[interface NegotiatedConduit :
	CICM::Duplex::NegotiatedController,
	CICM::Duplex::Stream {]]></artwork>
					<postamble>CICM::Duplex::NegotiatedConduit is the negotiated version of
					CICM::Duplex::Conduit. It is the result of a successful negotiation
					by CICM::Duplex::Negotiator.</postamble>
					</figure>
					<section title="CICM::Duplex::NegotiatedConduit Inheritance">
						<t>CICM::Duplex::NegotiatedConduit inherits from:
						CICM::Duplex::NegotiatedController and CICM::Duplex::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::ControllerNegotiator">
					<figure>
					  <preamble>Interface  CICM::Duplex::ControllerNegotiator</preamble>
					  <artwork><![CDATA[interface ControllerNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Duplex::ControllerNegotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption/decryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Duplex::NegotiatedController which is capable of managing the
					channel, but not accepting data for transformation.
					CICM::Duplex::ControllerNegotiator is created by calling
					CICM::ChannelManager::negotiate_duplex_controller.</postamble>
					</figure>
					<section title="CICM::Duplex::ControllerNegotiator Inheritance">
						<t>CICM::Duplex::ControllerNegotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Duplex::ControllerNegotiator Methods">
						<figure>
						  <preamble>Method CICM::Duplex::ControllerNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::Duplex::NegotiatedController controller_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated control-only
						duplex conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Duplex::Negotiator">
					<figure>
					  <preamble>Interface CICM::Duplex::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::Duplex::Negotiator initiates a negotiation to establish
					a shared key with a remote entity that is used to support
					encryption/decryption operations between two independent security
					domains. The result of a successful negotiation is a
					CICM::Duplex::NegotiatedConduit which is capable of both managing
					the channel and accepting data for transformation.
					CICM::Duplex::Negotiator is created by calling
					CICM::ChannelManager::negotiate_duplex_conduit.</postamble>
					</figure>
					<section title="CICM::Duplex::Negotiator Inheritance">
						<t>CICM::Duplex::Negotiator inherits from:
						CICM::Negotiator.</t>
					</section>
					<section title="CICM::Duplex::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::Duplex::Negotiator::complete()</preamble>
<artwork><![CDATA[ CICM::Status complete(
	out CICM::Duplex::NegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated duplex
						channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting channel.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section anchor="sec-bypass-write" title="Bypass (Send)">
				<figure>
				  <preamble>Namespace CICM::BypassWrite</preamble>
				  <artwork><![CDATA[module BypassWrite {]]></artwork>
				<postamble>The CICM::BypassWrite namespace contains channels that
				support full bypass write operations between two independent
				security domains.</postamble>
				</figure>
				<!-- t>{FIGURE REMOVED}</t>
				<t>Figure 34. Interface Relationship Diagram
				  for Sending Bypass Data</t -->

				<section title="Interface CICM::BypassWrite::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::BypassWrite::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::BypassWrite::ChannelManager is an abstraction inherited
					by CICM::ChannelManager that supports the creation of full bypass
					conduits, controllers, and streams for writing. See
					CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::BypassWrite::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::BypassWrite::ChannelManager::create_bypass_write_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_bypass_write_conduit(
	in  CICM::RemotePort remote_port,
	out CICM::BypassWrite::Conduit conduit_ref
);]]></artwork>
						<postamble>Creates a conduit to write bypass data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassWrite::ChannelManager::create_bypass_write_controller()</preamble>
<artwork><![CDATA[CICM::Status create_bypass_write_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	out CICM::BypassWrite::Controller controller_ref
);]]></artwork>
						<postamble>Returns the controller of a channel that writes bypass
						data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>See also:
							<list>
								<t>CICM::BypassWrite::ChannelManager::get_bypass_write_stream
								for the method that returns the channel stream.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassWrite::ChannelManager::get_bypass_write_stream()</preamble>
<artwork><![CDATA[CICM::Status get_bypass_write_stream(
	in  CICM::LocalPort local_port,
	out CICM::BypassWrite::Stream stream_ref
);]]></artwork>
						<postamble>Returns the stream corresponding to a pre-existing controller
						on the given local port.</postamble>
						</figure>
						<t>See also:
							<list>
								<t>CICM::BypassWrite::ChannelManager::create_bypass_write_controller
								for the method that returns the channel controller.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::BypassWrite::Stream">
					<figure>
					  <preamble>Interface CICM::BypassWrite::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::WriteStream {]]></artwork>
					<postamble>CICM::BypassWrite::Stream supports full bypass between two
					independent security domains. The resulting stream is capable of
					accepting data for bypass, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_bypass_write_stream.</postamble>
					</figure>

					<section title="CICM::BypassWrite::Stream Inheritance">
						<t>CICM::BypassWrite::Stream inherits from: CICM::WriteStream.</t>
					</section>
					<section title="CICM::BypassWrite::Stream Methods">
						<figure>
						  <preamble>Method CICM::BypassWrite::Stream::write_bypass()</preamble>
<artwork><![CDATA[CICM::Status write_bypass(
	in  CICM::Buffer buffer
);]]></artwork>
						<postamble>Write bypass data to a channel stream. The method blocks
						until the data has been sent.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] buffer
								  Data to bypass.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN,
							  S_BYPASS_DATARATE_EXCEEDED,
							  S_BYPASS_DATALIMIT_EXCEEDED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassWrite::Stream::write_bypass_non_blocking()</preamble>
<artwork><![CDATA[CICM::Status write_bypass_non_blocking(
	in  CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);]]></artwork>
						<postamble>Registers a buffer of data to be sent to the module for
						bypass and then immediately returns control to the caller. The
						length of the data is encapsulated in the buffer parameter. The
						caller may use the CICM::BypassWrite::Stream::write_bypass_poll
						method to proactively poll the channel to determine the status of
						the operation. The caller is responsible for maintaining any
						necessary metadata associated with the transaction_id parameter.
						Memory responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] buffer
								  Data to bypass.</t>
							<t>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::BypassWrite::Stream::write_bypass_poll method to
								  determine to which buffer the poll status applies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_DATA_INVALID, S_CHANNEL_DATA_INVALID_LEN,
							  S_BYPASS_DATARATE_EXCEEDED,
							  S_BYPASS_DATALIMIT_EXCEEDED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassWrite::Stream::write_bypass_poll()</preamble>
<artwork><![CDATA[CICM::Status write_bypass_poll(
	in  CICM::TransId transaction_id,
	out CICM::WriteStream::WriteStatus status
);]]></artwork>
						<postamble>Returns the status of the non-blocking bypass operation
						specified by the transaction_id parameter. Memory responsibilities
						and calling conventions shall follow the appropriate IDL language
						mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::BypassWrite::Stream::write_bypass_non_blocking
								  method that allows the poll operation to determine to
								  which buffer the poll status applies.</t>
							<t>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::BypassWrite::Controller">
					<figure>
					  <preamble>Interface  CICM::BypassWrite::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::MultiDomainController {};]]></artwork>
					<postamble>CICM::BypassWrite::Controller supports full bypass between
					two independent security domains. The resulting controller is
					capable of managing the channel, but not accepting data for bypass.
					It is created by calling
					CICM::ChannelManager::create_bypass_write_controller.</postamble>
					</figure>
					<section title="CICM::BypassWrite::Controller Inheritance">
						<t>CICM::BypassWrite::Controller inherits from: CICM::MultiDomainController.</t>
					</section>
				</section>
				<section title="Interface CICM::BypassWrite::Conduit">
					<figure>
					  <preamble>Interface CICM::BypassWrite::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Conduit,
	CICM::BypassWrite::Controller,
	CICM::BypassWrite::Stream {]]></artwork>
					<postamble>CICM::BypassWrite::Conduit supports full bypass between two
					security domains. The resulting conduit is capable of both managing
					the channel and accepting data for bypass. It is created by calling
					CICM::ChannelManager::create_bypass_write_conduit.</postamble>
					</figure>
					<section title="CICM::BypassWrite::Conduit Inheritance">
						<t>CICM::BypassWrite::Conduit inherits from:
						CICM::Conduit, CICM::BypassWrite::Controller and
						CICM::BypassWrite::Stream.</t>
					</section>
				</section>
			</section>
			<section anchor="sec-bypass-read" title="Bypass (Read)">
				<figure>
				  <preamble>Namespace CICM::BypassRead</preamble>
				  <artwork><![CDATA[module BypassRead {]]></artwork>
				<postamble>The CICM::BypassRead namespace contains channels that support
				full bypass read operations between two independent security
				domains.</postamble>
				</figure>
				<!-- t>{FIGURE REMOVED}</t>
				<t>Figure 35. Interface Relationship Diagram for Receiving Bypass Data</t -->

				<section title="Interface CICM::BypassRead::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::BypassRead::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::BypassRead::ChannelManager is an abstraction inherited
					by CICM::ChannelManager that supports the creation of full bypass
					conduits, controllers, and streams for reading. See
					CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::BypassRead::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::BypassRead::ChannelManager::create_bypass_read_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_bypass_read_conduit(
	in  CICM::RemotePort remote_port,
	out CICM::BypassRead::Conduit conduit_ref
);]]></artwork>
						<postamble>Creates a conduit to read bypass data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassRead::ChannelManager::create_bypass_read_controller()</preamble>
<artwork><![CDATA[CICM::Status create_bypass_read_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	out CICM::BypassRead::Controller controller_ref
);]]></artwork>
						<postamble>Returns the controller of a channel that reads bypass data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>See also:
							<list>
							<t>CICM::BypassRead::ChannelManager::get_bypass_read_stream
							for the method that returns the channel stream.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassRead::ChannelManager::get_bypass_read_stream()</preamble>
<artwork><![CDATA[CICM::Status get_bypass_read_stream(
	in  CICM::LocalPort local_port,
	out CICM::BypassRead::Stream stream_ref
);]]></artwork>
						<postamble>Returns the stream corresponding to a pre-existing controller
						on the given local port.</postamble>
						</figure>
						<t>See also:
							<list>
							<t>CICM::BypassRead::ChannelManager::get_bypass_read_controller
							for the method that returns the channel controller.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::BypassRead::Stream">
					<figure>
					  <preamble>Interface CICM::BypassRead::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::ReadStream {]]></artwork>
					<postamble>CICM::BypassRead::Stream supports full bypass between two
					independent security domains. The resulting stream is capable of
					accepting bypassed data, but not managing the channel. It is
					created by calling CICM::ChannelManager::get_bypass_read_stream.</postamble>
					</figure>

					<section title="CICM::BypassRead::Stream Inheritance">
						<t>CICM::BypassRead::Stream inherits from: CICM::ReadStream.</t>
					</section>
					<section title="CICM::BypassRead::Stream Methods">
						<figure>
						  <preamble>Method CICM::BypassRead::Stream::read_bypass()</preamble>
<artwork><![CDATA[CICM::Status read_bypass(
	out CICM::Buffer buffer
);]]></artwork>
						<postamble>Read bypass data off of channel stream. The method blocks
						until data becomes available.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] buffer
								  Bypassed data read from module.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassRead::Stream::read_bypass_non_blocking()</preamble>
<artwork><![CDATA[CICM::Status read_bypass_non_blocking(
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);]]></artwork>
						<postamble>Registers a buffer into which bypass data will be copied, and
						then immediately returns control to the caller. The size of the
						allocated buffer and length of the resulting bypassed data is
						encapsulated in the buffer parameter. The caller may use the
						CICM::BypassRead::Stream::read_bypass_poll method to proactively
						poll the channel to determine the status of the operation. The
						caller is responsible for maintaining any necessary metadata
						associated with the transaction_id parameter. Memory
						responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] buffer
								  Bypassed data to read.</t>
							<t>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::BypassRead::Stream::read_bypass_poll method to
								  determine to which buffer the poll status applies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::BypassRead::Stream::read_bypass_poll()</preamble>
<artwork><![CDATA[CICM::Status read_bypass_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);]]></artwork>
						<postamble>Returns the status of the non-blocking bypass operation
						specified by the transaction_id parameter. Upon completion of the
						operation, the caller must use the metadata associated with the
						transaction_id parameter to determine which buffer has been
						populated. Memory responsibilities and calling conventions shall
						follow the appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::BypassRead::Stream::read_bypass_non_blocking method
								  that allows the poll operation to determine to which
								  buffer the poll status applies.</t>
							<t>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::BypassRead::Controller">
					<figure>
					  <preamble>Interface  CICM::BypassRead::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::MultiDomainController {};]]></artwork>
					<postamble>CICM::BypassRead::Controller supports full bypass between two
					independent security domains. The resulting controller is capable
					of managing the channel, but not accepting bypassed data. It is
					created by calling
					CICM::ChannelManager::create_bypass_read_controller.</postamble>
					</figure>

					<section title="CICM::BypassRead::Controller Inheritance">
						<t>CICM::BypassRead::Controller inherits from: CICM::MultiDomainController.</t>
					</section>
				</section>
				<section title="Interface CICM::BypassRead::Conduit">
					<figure>
					  <preamble>Interface CICM::BypassRead::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Conduit,
	CICM::BypassRead::Controller,
	CICM::BypassRead::Stream {]]></artwork>
					<postamble>CICM::BypassRead::Conduit supports full bypass between two
					independent security domains. The resulting conduit is capable of
					both managing the channel and accepting bypassed data. It is
					created by calling
					CICM::ChannelManager::create_bypass_read_conduit.</postamble>
					</figure>

					<section title="CICM::BypassRead::Conduit Inheritance">
						<t>CICM::BypassRead::Conduit inherits from:
						CICM::Conduit, CICM::BypassRead::Controller and
						CICM::BypassRead::Stream.</t>
					</section>
				</section>
			</section>
			<section anchor="sec-encrypt-bypass" title="Encryption with Selective Bypass">
				<figure>
				  <preamble>Namespace CICM::EncryptBypass</preamble>
				  <artwork><![CDATA[module EncryptBypass {]]></artwork>
				<postamble>The CICM::EncryptBypass namespace contains interfaces that
				support encryption with selective bypass operations between two
				indepenent security domains.</postamble>
				</figure>
				<!-- t>{FIGURE REMOVED}</t>
				<t>Figure 36. Interface Relationship Diagram
				  for Encryption Channels with Selective Bypass</t -->

				<section title="Interface CICM::EncryptBypass::ChannelManager">
					<figure>
					  <preamble>Interface CICM::EncryptBypass::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::EncryptBypass::ChannelManager is an abstraction
					inherited by CICM::ChannelManager that supports the creation of
					encryption with selective bypass negotiators, conduits,
					controllers, and streams. See CICM::ChannelManager for additional
					information.</postamble>
					</figure>
					<t>Remarks:
						<list>
					  <t>Note that if a system is using selective bypass channels to
					  perform header bypass, policy may govern that a system performs
					  the bypass function before the encryption function and performs
					  the bypass function only once.</t>
					</list></t>

					<section title="CICM::EncryptBypass::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::EncryptBypass::ChannelManager::negotiate_encrypt_bypass_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::EncryptBypass::Negotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will selectively encrypt or bypass a
						stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::EncryptBypass::ChannelManager::negotiate_encrypt_bypass_controller()</preamble>
<artwork><![CDATA[CICM::Status negotiate_encrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::EncryptBypass::ControllerNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage an encrypt with bypass
						channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Remote port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::EncryptBypass::ChannelManager::create_encrypt_bypass_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::EncryptBypass::Conduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to selectively encrypt or bypass a stream of  data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[in] algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::EncryptBypass::ChannelManager::create_encrypt_bypass_controller()</preamble>
<artwork><![CDATA[CICM::Status create_encrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::EncryptBypass::Controller controller_ref
);]]></artwork>
						<postamble>Create controller to configure and control an encrypt with
						bypass channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[in] algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::EncryptBypass::ChannelManager::get_encrypt_bypass_stream()</preamble>
<artwork><![CDATA[CICM::Status get_encrypt_bypass_stream(
	in  CICM::LocalPort local_port,
	out CICM::EncryptBypass::Stream stream_ref
);]]></artwork>
						<postamble>Create stream associated with previously created controller
						to accept data for transformation.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::Stream">
					<figure>
					  <preamble>Interface CICM::EncryptBypass::Stream</preamble>
<artwork><![CDATA[interface Stream :
	CICM::Encrypt::Stream,
	CICM::BypassWrite::Stream {]]></artwork>
					<postamble>CICM::EncryptBypass::Stream supports encryption and selective
					bypass operations between two independent security domains. The
					resulting stream is capable of accepting data for transformation,
					but not managing the channel. It is created by calling
					CICM::ChannelManager::get_encrypt_bypass_stream.</postamble>
					</figure>

					<section title="CICM::EncryptBypass::Stream Inheritance">
						<t>CICM::EncryptBypass::Stream inherits from:
						CICM::Encrypt::Stream and CICM::BypassWrite::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::NegotiatedController">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::NegotiatedController</preamble>
					  <artwork><![CDATA[interface NegotiatedController : CICM::Encrypt::NegotiatedController {};]]></artwork>
					<postamble>CICM::EncryptBypass::NegotiatedController is the negotiated
					version of CICM::EncryptBypass::Controller. It is the result of a
					successful negotiation by
					CICM::EncryptBypass::ControllerNegotiator.</postamble>
					</figure>

					<section title="CICM::EncryptBypass::NegotiatedController Inheritance">
						<t>CICM::EncryptBypass::NegotiatedController inherits
						from: CICM::Encrypt::NegotiatedController.</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::Controller">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::Encrypt::Controller {};]]></artwork>
					<postamble>CICM::EncryptBypass::Controller supports encryption and
					selective bypass operations between two independent security
					domains. The resulting controller is capable of managing the
					channel, but not accepting data for transformation/bypass. It is
					created by calling
					CICM::ChannelManager::create_encrypt_bypass_controller.</postamble>
					</figure>
					<section title="CICM::EncryptBypass::Controller Inheritance">
						<t>CICM::EncryptBypass::Controller inherits from:
						CICM::Encrypt::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::Conduit">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Encrypt::Conduit,
	CICM::EncryptBypass::Stream {]]></artwork>
					<postamble>CICM::EncryptBypass::Conduit supports encryption and
					selective bypass operations between two independent security
					domains. The resulting conduit is capable of both managing the
					channel and accepting data for transformation/bypass. It is created
					by calling CICM::ChannelManager::create_encrypt_bypass_conduit.</postamble>
					</figure>

					<section title="CICM::EncryptBypass::Conduit Inheritance">
						<t>CICM::EncryptBypass::Conduit inherits from:
						CICM::Encrypt::Conduit and CICM::EncryptBypass::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::NegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::NegotiatedConduit</preamble>
<artwork><![CDATA[interface NegotiatedConduit :
	CICM::Encrypt::NegotiatedController,
	CICM::EncryptBypass::Stream {]]></artwork>
					<postamble>CICM::EncryptBypass::NegotiatedConduit is the negotiated
					version of CICM::EncryptBypass::Conduit. It is the result of a
					successful negotiation by CICM::EncryptBypass::Negotiator.</postamble>
					</figure>

					<section title="CICM::EncryptBypass::NegotiatedConduit Inheritance">
						<t>CICM::EncryptBypass::NegotiatedConduit inherits
						from: CICM::Encrypt::NegotiatedController and
						CICM::EncryptBypass::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::ControllerNegotiator">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::ControllerNegotiator</preamble>
					  <artwork><![CDATA[interface ControllerNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::EncryptBypass::ControllerNegotiator initiates a
					negotiation to establish a shared key with a remote entity that is
					used to support encryption and selective bypass operations between
					two independent security domains. The result of a successful
					negotiation is a CICM::EncryptBypass::NegotiatedController which is
					capable of managing the channel, but not accepting data for
					transformation/bypass. CICM::EncryptBypass::ControllerNegotiator is
					created by calling
					CICM::ChannelManager::negotiate_encrypt_bypass_controller.</postamble>
					</figure>

					<section title="CICM::EncryptBypass::ControllerNegotiator Inheritance">
						<t>CICM::EncryptBypass::ControllerNegotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::EncryptBypass::ControllerNegotiator Methods">
						<figure>
						  <preamble>Method CICM::EncryptBypass::ControllerNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::EncryptBypass::NegotiatedController controller_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated encrypt bypass
						control-only channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::EncryptBypass::Negotiator">
					<figure>
					  <preamble>Interface  CICM::EncryptBypass::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::EncryptBypass::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption and bypass operations between two independent security
					domains. Additionally, selective bypass is supported on the same
					conduit. The result of a successful negotiation is a
					CICM::EncryptBypass::NegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation/bypass.
					CICM::EncryptBypass::Negotiator is created by calling
					CICM::ChannelManager::negotiate_encrypt_bypass_conduit.</postamble>
					</figure>
					<section title="CICM::EncryptBypass::Negotiator Inheritance">
						<t>CICM::EncryptBypass::Negotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::EncryptBypass::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::EncryptBypass::Negotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::EncryptBypass::NegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated encrypt bypass
						conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
  							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section anchor="sec-decrypt-bypass" title="Decryption with Selective Bypass">
				<figure>
				  <preamble>Namespace CICM::DecryptBypass</preamble>
				  <artwork><![CDATA[module DecryptBypass {]]></artwork>
				<postamble>The CICM::DecryptBypass namespace contains interfaces that
				support decryption with selective bypass operations between two
				independent security domains.</postamble>
				</figure>
				<!-- t>{FIGURE REMOVED}</t>
				<t>Figure 37. Interface Relationship Diagram
				  for Decryption Channels with Selective Bypass</t -->

				<section title="Interface CICM::DecryptBypass::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::DecryptBypass::ChannelManager is an abstraction
					inherited by CICM::ChannelManager that supports the creation of
					decryption with selective bypass negotiators, conduits,
					controllers, and streams. See CICM::ChannelManager for additional
					information.</postamble>
					</figure>
					<t>Remarks:
						<list>
						  <t>CICM does not specify the structure of the data that is read
						  from a selective bypass channel which may contain special
						  formatting to indicate which subset of the data was bypassed. The
						  Implementation Conformance Statement (see Conformance and Extensions 
              in <xref target="CICM" />) MUST reference a standard format or define a
						  module developer-specific format implemented by the module for
						  data read from selective bypass channels.</t>
						</list>
					</t>

					<section title="CICM::DecryptBypass::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::DecryptBypass::ChannelManager::negotiate_decrypt_bypass_conduit()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::DecryptBypass::Negotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer.
						The channel that results will selectively decrypt or bypass a
						stream of data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_NEGOTIATION_ABORTED, S_NEGOTIATION_FAILURE,
							  S_NEGOTIATION_IN_PROGRESS, S_NEGOTIATION_TIMEOUT,
							  S_CERT_LOCAL_INVALID, S_CERT_LOCAL_EXPIRED,
							  S_CERT_REMOTE_INVALID, S_CERT_REMOTE_EXPIRED,
							  S_CERT_REMOTE_PATH, S_PROTO_INVALID, S_PROTO_INCOMPATIBLE,
							  S_PROTO_UNDETERMINED, S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::DecryptBypass::ChannelManager::negotiate_decrypt_bypass_controller()</preamble>
<artwork><![CDATA[CICM::Status negotiate_decrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::ProtocolId protocol,
	in  CICM::AsymKey key_ref,
	out CICM::DecryptBypass::ControllerNegotiator negotiator_ref
);]]></artwork>
						<postamble>Initiate a negotiation to establish a shared key with a peer,
						resulting in a controller to manage a decrypt with bypass
						channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] protocol
								  Protocol identifier.</t>
							<t>[in] key_ref
								  Reference to negotiation key.</t>
							<t>[out] negotiator_ref
								  Reference to resulting negotiator.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_LOCAL_PORT_INVALID, S_LOCAL_PORT_INCOMPATIBLE,
							  S_LOCAL_PORT_IN_USE, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_PROTO_INVALID,
							  S_PROTO_INCOMPATIBLE, S_PROTO_UNDETERMINED, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::DecryptBypass::ChannelManager::create_decrypt_bypass_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_bypass_conduit(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::DecryptBypass::Conduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to selectively decrypt or bypass a stream of data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Both decrypted and bypassed data are read from the same
							stream using the appropriate decrypt() call; the entity reading
							from this stream must distinguish between decrypted and
							bypassed data, if necessary.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::DecryptBypass::ChannelManager::create_decrypt_bypass_controller()</preamble>
<artwork><![CDATA[CICM::Status create_decrypt_bypass_controller(
	in  CICM::LocalPort local_port,
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::DecryptBypass::Controller controller_ref
);]]></artwork>
						<postamble>Create controller to configure and control a decrypt with
						bypass channel.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In some cases, hosts may depend upon separate processes to
							control and use a channel. This method returns the channel
							controller and must be called before the corresponding stream
							is retrieved.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::DecryptBypass::ChannelManager::get_decrypt_bypass_stream()</preamble>
<artwork><![CDATA[CICM::Status get_decrypt_bypass_stream(
	in  CICM::LocalPort local_port,
	out CICM::DecryptBypass::Stream stream_ref
);]]></artwork>
						<postamble>Create stream associated with previously created controller
						to receive transformed data.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>Both decrypted and bypassed data are read from the same
							stream using the appropriate decrypt() call; the entity reading
							from this stream must distinguish between decrypted and
							bypassed data, if necessary.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] local_port
								  Local port.</t>
							<t>[out] stream_ref
								  Reference to resulting stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_LOCAL_PORT_INVALID,
							  S_LOCAL_PORT_INCOMPATIBLE, S_LOCAL_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_PEER_RESET,
							  S_CHANNEL_NOT_FOUND</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::Stream">
					<figure>
					  <preamble>Interface CICM::DecryptBypass::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::Decrypt::Stream {};]]></artwork>
					<postamble>CICM::DecryptBypass::Stream supports decryption and selective
					bypass operations between two independent security domains. The
					resulting stream is capable of accepting transformed/bypassed data,
					but not managing the channel. It is created by calling
					CICM::ChannelManager::get_decrypt_bypass_stream.</postamble>
					</figure>
					<t>Remarks:
						<list>
						  <t>CICM does not specify the structure of the data that is read
						  from a selective bypass channel which may contain special
						  formatting to indicate which subset of the data was bypassed. The
						  Implementation Conformance Statement (see
							Conformance and Extensions in <xref target="CICM" />) MUST
              reference a standard format or define a
						  module developer-specific format implemented by the module for
						  data read from selective bypass channels.</t>
						</list>
					</t>

					<section title="CICM::DecryptBypass::Stream Inheritance">
						<t>CICM::DecryptBypass::Stream inherits from:
						CICM::Decrypt::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::Controller">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::Decrypt::Controller {]]></artwork>
					<postamble>CICM::DecryptBypass::Controller supports decryption and
					selective bypass operations between two independent security
					domains. The resulting controller is capable of managing the
					channel, but not accepting transformed/bypassed data. It is created
					by calling CICM::ChannelManager::create_decrypt_bypass_controller.</postamble>
					</figure>
					<section title="CICM::DecryptBypass::Controller Inheritance">
						<t>CICM::DecryptBypass::Controller inherits from:
						CICM::Decrypt::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::NegotiatedController">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::NegotiatedController</preamble>
					  <artwork><![CDATA[interface NegotiatedController : CICM::Decrypt::NegotiatedController {]]></artwork>
					<postamble>CICM::DecryptBypass::NegotiatedController is the negotiated
					version of CICM::DecryptBypass::Controller. It is the result of a
					successful negotiation by
					CICM::DecryptBypass::ControllerNegotiator.</postamble>
					</figure>

					<section title="CICM::DecryptBypass::NegotiatedController Inheritance">
						<t>CICM::DecryptBypass::NegotiatedController inherits from: CICM::Decrypt::NegotiatedController.</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::Conduit">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::Conduit</preamble>
<artwork><![CDATA[interface Conduit :
	CICM::Decrypt::Conduit,
	CICM::DecryptBypass::Controller,
	CICM::DecryptBypass::Stream {]]></artwork>
					<postamble>CICM::DecryptBypass::Conduit supports decryption and
					selective bypass operations between two independent security
					domains. The resulting conduit is capable of both managing the
					channel and accepting transformed/bypassed data. It is created by
					calling CICM::ChannelManager::create_decrypt_bypass_conduit.</postamble>
					</figure>

					<section title="CICM::DecryptBypass::Conduit Inheritance">
						<t>CICM::DecryptBypass::Conduit inherits from:
						CICM::Decrypt::Conduit, CICM::DecryptBypass::Controller and
						CICM::DecryptBypass::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::NegotiatedConduit">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::NegotiatedConduit</preamble>
<artwork><![CDATA[interface NegotiatedConduit :
	CICM::Decrypt::NegotiatedConduit,
	CICM::DecryptBypass::NegotiatedController,
	CICM::DecryptBypass::Stream {]]></artwork>
					<postamble>CICM::DecryptBypass::NegotiatedConduit is the negotiated
					version of CICM::DecryptBypass::Conduit. It is the result of a
					successful negotiation by CICM::DecryptBypass::Negotiator.</postamble>
					</figure>

					<section title="CICM::DecryptBypass::NegotiatedConduit Inheritance">
						<t>CICM::DecryptBypass::NegotiatedConduit inherits
						from: CICM::Decrypt::NegotiatedConduit,
						CICM::DecryptBypass::NegotiatedController and
						CICM::DecryptBypass::Stream.</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::ControllerNegotiator">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::ControllerNegotiator</preamble>
					  <artwork><![CDATA[interface ControllerNegotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::DecryptBypass::ControllerNegotiator initiates a
					negotiation to establish a shared key with a remote entity that is
					used to support encryption and selective bypass operations between
					two independent security domains. The result of a successful
					negotiation is a CICM::DecryptBypass::NegotiatedController which is
					capable of managing the channel, but not accepting data for
					transformation. CICM::DecryptBypass::ControllerNegotiator is
					created by calling
					CICM::ChannelManager::negotiate_decrypt_bypass_controller.</postamble>
					</figure>

					<section title="CICM::DecryptBypass::ControllerNegotiator Inheritance">
						<t>CICM::DecryptBypass::ControllerNegotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::DecryptBypass::ControllerNegotiator Methods">
						<figure>
						  <preamble>Method CICM::DecryptBypass::ControllerNegotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::DecryptBypass::NegotiatedController controller_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated control-only
						decrypt bypass channel.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::DecryptBypass::Negotiator">
					<figure>
					  <preamble>Interface  CICM::DecryptBypass::Negotiator</preamble>
					  <artwork><![CDATA[interface Negotiator : CICM::Negotiator {]]></artwork>
					<postamble>CICM::DecryptBypass::Negotiator initiates a negotiation to
					establish a shared key with a remote entity that is used to support
					encryption operations between two independent security domains.
					Additionally, selective bypass is supported on the same conduit.
					The result of a successful negotiation is a
					CICM::DecryptBypass::NegotiatedConduit which is capable of both
					managing the channel and accepting data for transformation.
					CICM::DecryptBypass::Negotiator is created by calling
					CICM::ChannelManager::negotiate_decrypt_bypass_conduit.</postamble>
					</figure>

					<section title="CICM::DecryptBypass::Negotiator Inheritance">
						<t>CICM::DecryptBypass::Negotiator inherits from: CICM::Negotiator.</t>
					</section>
					<section title="CICM::DecryptBypass::Negotiator Methods">
						<figure>
						  <preamble>Method CICM::DecryptBypass::Negotiator::complete()</preamble>
<artwork><![CDATA[CICM::Status complete(
	out CICM::DecryptBypass::NegotiatedConduit conduit_ref
);]]></artwork>
						<postamble>Complete negotiation and retrieve a negotiated decrypt bypass
						conduit.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_NEGOTIATION_ABORTED,
							  S_NEGOTIATION_FAILURE, S_NEGOTIATION_NOT_IN_PROGRESS,
							  S_NEGOTIATION_TIMEOUT, S_CERT_LOCAL_INVALID,
							  S_CERT_LOCAL_EXPIRED, S_CERT_REMOTE_INVALID,
							  S_CERT_REMOTE_EXPIRED, S_CERT_REMOTE_PATH, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section anchor="sec-emit" title="Random, Pseudorandom and Keystream">
				<figure>
				  <preamble>Namespace CICM::Emit</preamble>
				  <artwork><![CDATA[module Emit {]]></artwork>
				<postamble>The CICM::Emit namespace contains interfaces that generate
				data originating in a cryptographic module such as random,
				pseudorandom, and keystream data.</postamble>
				</figure>
				<!-- t>{FIGURE REMOVED}</t>
				<t>Figure 38. Interface Relationship Diagram for Keystream Generation and Random Channels</t -->

				<section title="Interface CICM::Emit::ChannelManager">
					<figure>
					  <preamble>Interface CICM::Emit::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Emit::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of conduits and
					controllers to generate keystream, pseudorandom, and random data.
					See CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::Emit::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_key_stream_gen_controller()</preamble>
<artwork><![CDATA[CICM::Status create_key_stream_gen_controller(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Emit::KeyStreamGenController controller_ref
);]]></artwork>
						<postamble>Create controller to generate keystream.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] key_ref
								  Reference to keystream generation key.</t>
							<t>[in] algorithm
								  Keystream generation algorithm/mode.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_ALGO_INVALID, S_ALGO_INCOMPATIBLE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_pseudorandom_controller()</preamble>
<artwork><![CDATA[CICM::Status create_pseudorandom_controller(
	in  CICM::RemotePort remote_port,
	in  CICM::SymKey seed,
	out CICM::Emit::PseudoRandomController controller_ref
);]]></artwork>
						  <postamble>Create controller to generate pseudorandom data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[in] seed
								  Seed material for pseudorandom generator.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_REMOTE_PORT_INVALID,
							  S_REMOTE_PORT_IN_USE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX,
							  S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_random_controller()</preamble>
<artwork><![CDATA[CICM::Status create_random_controller(
	in  CICM::RemotePort remote_port,
	out CICM::Emit::RandomController controller_ref
);]]></artwork>
						  <postamble>Create controller to generate random data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] remote_port
								  Remote port.</t>
							<t>[out] controller_ref
								  Reference to resulting controller.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_REMOTE_PORT_INVALID, S_REMOTE_PORT_IN_USE,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_CHANNEL_ERROR, S_CHANNEL_MAX, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_key_stream_gen_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_key_stream_gen_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Emit::KeyStreamGenConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to generate keystream.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to keystream generation key.</t>
							<t>[in] algorithm
								  Keystream generation algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_pseudorandom_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_pseudorandom_conduit(
	in  CICM::SymKey seed,
	out CICM::Emit::PseudoRandomConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to generate pseudorandom data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] seed
								  Seed material for pseudorandom generator.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX,
							  S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::ChannelManager::create_random_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_random_conduit(
	out CICM::Emit::RandomConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to generate random data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR, S_CHANNEL_MAX,
							  S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::GetStream">
					<figure>
					  <preamble>Interface CICM::Emit::GetStream</preamble>
					  <artwork><![CDATA[interface GetStream : CICM::ReadStream {]]></artwork>
					<postamble>CICM::Emit::GetStream is an abstraction inherited by conduits
					in the CICM::Emit namespace that allows data to be read from the
					stream.</postamble>
					</figure>

					<section title="CICM::Emit::GetStream Inheritance">
						<t>CICM::Emit::GetStream inherits from: CICM::ReadStream.</t>
					</section>

					<section title="CICM::Emit::GetStream Methods">
						<figure>
						  <preamble>Method CICM::Emit::GetStream::get()</preamble>
<artwork><![CDATA[CICM::Status get(
	in  CICM::UInt32 length,
	out CICM::Buffer buffer
);]]></artwork>
						<postamble>Reads a buffer of data from the module. The method blocks
						until data becomes available.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] length
								  Number of bytes to retrieve.</t>
							<t>[out] buffer
								  Buffer of data read from stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::GetStream::get_non_blocking()</preamble>
<artwork><![CDATA[CICM::Status get_non_blocking(
	in  CICM::UInt32 length,
	out CICM::Buffer buffer,
	in  CICM::TransId transaction_id
);]]></artwork>
						<postamble>Registers a buffer into which transformed data will be
						copied, and then control immediately returns to the caller. The
						size of the allocated buffer and length of the resulting
						transformed data is encapsulated in the buffer parameter. The
						caller may use the CICM::Emit::GetStream::get_poll method to
						proactively poll the channel to determine the status of the
						operation. The caller is responsible for maintaining any necessary
						metadata associated with the transaction_id parameter. Memory
						responsibilities and calling conventions shall follow the
						appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] length
								  Number of bytes to retrieve.</t>
							<t>[out] buffer
								  Transformed data.</t>
							<t>[in] transaction_id
								  Unique transaction id that will be used by the
								  CICM::Emit::GetStream::get_poll method to determine to
								  which buffer the poll status applies.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR,
							  S_CHANNEL_BUFFER_LEN, S_INSUFFICIENT_ENTROPY</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Emit::GetStream::get_poll()</preamble>
<artwork><![CDATA[CICM::Status get_poll(
	in  CICM::TransId transaction_id,
	out CICM::ReadStream::ReadStatus status
);]]></artwork>
						<postamble>Returns the status of the non-blocking get operation
						specified by the transaction_id parameter. Upon completion of the
						operation, the caller must use the metadata associated with the
						transaction_id parameter to determine which buffer has been
						populated. Memory responsibilities and calling conventions shall
						follow the appropriate IDL language mapping conventions.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] transaction_id
								  Unique transaction id previously specified to the
								  CICM::Emit::GetStream::get_non_blocking method that
								  allows the poll operation to determine to which buffer
								  the poll status applies.</t>
							<t>[out] status
								  Status of the non-blocking operation corresponding to
								  the transaction_id parameter.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_KEY_WRAPPED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_PEER_RESET, S_CHANNEL_IO_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::Controller">
					<figure>
					  <preamble>Interface CICM::Emit::Controller</preamble>
					  <artwork><![CDATA[interface Controller : CICM::Controller {]]></artwork>
					<postamble>CICM::Emit::Controller is an abstraction from which all other
					controllers in the CICM::Emit namespace inherit.</postamble>
					</figure>

					<section title="CICM::Emit::Controller Inheritance">
						<t>CICM::Emit::Controller inherits from: CICM::Controller.</t>
					</section>
					<section title="CICM::Emit::Controller Attributes">
						<figure>
						  <preamble>AttributeCICM::Emit::Controller::remote_port</preamble>
						  <artwork><![CDATA[readonly attribute CICM::RemotePort remote_port;]]></artwork>
						<postamble>The remote port associated with this controller.</postamble>
						</figure>
					</section>
				</section>
				<section title="Interface CICM::Emit::RandomController">
					<figure>
					  <preamble>Interface  CICM::Emit::RandomController</preamble>
					  <artwork><![CDATA[interface RandomController : CICM::Emit::Controller {};]]></artwork>
					<postamble>CICM::Emit::RandomController supports creating a channel to
					read random data from a module. The resulting controller is capable
					of managing the channel, but not reading random data. It is created
					by calling CICM::ChannelManager::create_random_controller.</postamble>
					</figure>
					<section title="CICM::Emit::RandomController Inheritance">
						<t>CICM::Emit::RandomController inherits from: CICM::Emit::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::RandomConduit">
					<figure>
					  <preamble>Interface CICM::Emit::RandomConduit</preamble>
<artwork><![CDATA[interface RandomConduit :
	CICM::Conduit,
	CICM::Emit::GetStream {]]></artwork>
					<postamble>CICM::Emit::RandomConduit supports reading random data from a
					module. The resulting conduit is capable of both managing the
					channel and reading random data. It is created by calling
					CICM::ChannelManager::create_random_conduit.</postamble>
					</figure>

					<section title="CICM::Emit::RandomConduit Inheritance">
						<t>CICM::Emit::RandomConduit inherits from:
						CICM::Conduit and CICM::Emit::GetStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::PseudoRandomController">
					<figure>
					  <preamble>Interface  CICM::Emit::PseudoRandomController</preamble>
<artwork><![CDATA[interface PseudoRandomController :
	CICM::SymKeyController,
	CICM::Emit::Controller {]]></artwork>
					<postamble>CICM::Emit::PseudoRandomController supports creating a
					channel to read pseudorandom data from a module. The resulting
					controller is capable of managing the channel, but not reading
					pseudorandom data. It is created by calling
					CICM::ChannelManager::create_pseudorandom_controller.</postamble>
					</figure>

					<section title="CICM::Emit::PseudoRandomController Inheritance">
						<t>CICM::Emit::PseudoRandomController inherits from:
						CICM::SymKeyController and CICM::Emit::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::PseudoRandomConduit">
					<figure>
					  <preamble>Interface  CICM::Emit::PseudoRandomConduit</preamble>
<artwork><![CDATA[interface PseudoRandomConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::Emit::GetStream {]]></artwork>
					<postamble>CICM::Emit::PseudoRandomConduit supports reading pseudorandom
					data from a module. The resulting conduit is capable of both
					managing the channel and reading pseudorandom data. It is created
					by calling CICM::ChannelManager::create_pseudorandom_conduit.</postamble>
					</figure>
					<section title="CICM::Emit::PseudoRandomConduit Inheritance">
						<t>CICM::Emit::PseudoRandomConduit inherits from:
						CICM::Conduit, CICM::SymKeyController and
						CICM::Emit::GetStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::KeyStreamGenController">
					<figure>
					  <preamble>Interface  CICM::Emit::KeyStreamGenController</preamble>
<artwork><![CDATA[interface KeyStreamGenController :
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::Emit::Controller {]]></artwork>
					<postamble>CICM::Emit::KeyStreamGenController supports creating a
					channel to read keystream from a module. The resulting controller
					is capable of managing the channel, but not reading keystream. It
					is created by calling
					CICM::ChannelManager::create_key_stream_gen_controller.</postamble>
					</figure>

					<section title="CICM::Emit::KeyStreamGenController Inheritance">
						<t>CICM::Emit::KeyStreamGenController inherits from:
						CICM::SymKeyController, CICM::GenVectorController and
						CICM::Emit::Controller.</t>
					</section>
				</section>
				<section title="Interface CICM::Emit::KeyStreamGenConduit">
					<figure>
					  <preamble>Interface  CICM::Emit::KeyStreamGenConduit</preamble>
<artwork><![CDATA[interface KeyStreamGenConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::Emit::GetStream {]]></artwork>
					<postamble>CICM::Emit::KeyStreamGenConduit supports reading keystream
					from a module. The resulting conduit is capable of both managing
					the channel and reading keystream. It is created by calling
					CICM::ChannelManager::create_key_stream_gen_conduit.</postamble>
					</figure>

					<section title="CICM::Emit::KeyStreamGenConduit Inheritance">
						<t>CICM::Emit::KeyStreamGenConduit inherits from:
						CICM::Conduit, CICM::SymKeyController, CICM::GenVectorController
						and CICM::Emit::GetStream.</t>
					</section>
				</section>
			</section>
			<section anchor="sec-answer" title="Data Integrity">
				<figure>
				  <preamble>Namespace CICM::Answer</preamble>
				  <artwork><![CDATA[module Answer {]]></artwork>
				<postamble>The CICM::Answer namespace contains interfaces that support
				cryptographic operations that return an "answer" such a hash or a
				signature within a single security domain.</postamble>
				</figure>
				<!-- t>{FIGURE REMOVED}</t>
				<t>Figure 39. Interface Relationship Diagram for Channels that Return an "Answer"</t -->

				<section title="Interface CICM::Answer::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::Answer::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Answer::ChannelManager is an abstraction inherited by
					CICM::ChannelManager that supports the creation of conduits to
					sign, MAC, and hash data. See CICM::ChannelManager for additional
					information.</postamble>
					</figure>

					<section title="CICM::Answer::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_hash_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_hash_conduit(
	in  CICM::HashAlgorithmId algorithm,
	out CICM::Answer::HashConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to calculate and generate a hash value.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] algorithm
								  Hash algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_mac_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymMacAlgorithmId algorithm,
	out CICM::Answer::MACConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to calculate and generate a MAC.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to MAC key.</t>
							<t>[in] algorithm
								  MAC algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_mac_verify_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_mac_verify_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymMacAlgorithmId algorithm,
	out CICM::Answer::MACVerifyConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to verify a MAC.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to verification key.</t>
							<t>[in] algorithm
								  MAC algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_sign_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_sign_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::SignConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to calculate and generate a signature.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to signature key.</t>
							<t>[in] algorithm
								  Signature algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_sign_hash_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_sign_hash_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::SignHashConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to calculate and generate a signature
						accepting a previously generated hash value as input.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to signature key.</t>
							<t>[in] algorithm
								  Signature algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_verify_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_verify_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::VerifyConduit conduit_ref
);]]></artwork>
						  <postamble>Create conduit to verify a signature.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to verification key.</t>
							<t>[in] algorithm
								  Verification algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Answer::ChannelManager::create_verify_hash_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_verify_hash_conduit(
	in  CICM::AsymKey key_ref,
	in  CICM::AsymSigAlgorithmId algorithm,
	out CICM::Answer::VerifyHashConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to verify a signature accepting a previously
						generated hash value as input.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to verification key.</t>
							<t>[in] algorithm
								  Verification algorithm.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::PutStream">
					<figure>
					  <preamble>Interface CICM::Answer::PutStream</preamble>
					  <artwork><![CDATA[interface PutStream : CICM::Stream {]]></artwork>
					<postamble>A stream that can write data to a module.</postamble>
					</figure>

					<section title="CICM::Answer::PutStream Inheritance">
						<t>CICM::Answer::PutStream inherits from: CICM::Stream.</t>
					</section>
					<section title="CICM::Answer::PutStream Methods">
						<figure>
						  <preamble>Method CICM::Answer::PutStream::put()</preamble>
<artwork><![CDATA[CICM::Status put(
	in  CICM::Buffer buffer
);]]></artwork>
						<postamble>Sends data to the module for transformation.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>This method blocks until the data is sent to the
							module.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] buffer
								  Buffer to write to the module.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::HashConduit">
					<figure>
					  <preamble>Interface CICM::Answer::HashConduit</preamble>
<artwork><![CDATA[interface HashConduit :
	CICM::Conduit,
	CICM::Answer::PutStream {]]></artwork>
					<postamble>CICM::Answer::HashConduit supports hashing operations within
					a single security domain. It is created by calling
					CICM::ChannelManager::create_hash_conduit.</postamble>
					</figure>
					<t>Remarks:
						<list>
							<t>Keyed hashes are supported by MAC channels.</t>
						</list>
					</t>

					<section title="CICM::Answer::HashConduit Inheritance">
						<t>CICM::Answer::HashConduit inherits from:
						CICM::Conduit and CICM::Answer::PutStream.</t>
					</section>
					<section title="CICM::Answer::HashConduit Attributes">
						<figure>
						  <preamble>AttributeCICM::Answer::HashConduit::algorithm</preamble>
						  <artwork><![CDATA[readonly attribute CICM::HashAlgorithmId algorithm;]]></artwork>
						<postamble>Algorithm used to compute the hash.</postamble>
						</figure>
					</section>
					<section title="CICM::Answer::HashConduit Methods">
						<figure>
						  <preamble>Method CICM::Answer::HashConduit::end_get_hash()</preamble>
<artwork><![CDATA[CICM::Status end_get_hash(
	out HashBuffer hash
);]]></artwork>
						<postamble>Direct the module to compute and output the message digest
						value, and reset the conduit to accept additional data.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[out] hash
								  Resulting hash.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::MACConduit">
					<figure>
					  <preamble>Interface CICM::Answer::MACConduit</preamble>
<artwork><![CDATA[interface MACConduit :
	CICM::AbstractMACConduit,
	CICM::Answer::PutStream {]]></artwork>
					<postamble>CICM::Answer::MACConduit supports message authentication code
					operations within a single security domain. It is created by
					calling CICM::ChannelManager::create_mac_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::MACConduit Inheritance">
						<t>CICM::Answer::MACConduit inherits from:
						CICM::AbstractMACConduit and CICM::Answer::PutStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::MACVerifyConduit">
					<figure>
					  <preamble>Interface  CICM::Answer::MACVerifyConduit</preamble>
<artwork><![CDATA[interface MACVerifyConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Answer::PutStream {]]></artwork>
					<postamble>CICM::Answer::MACVerifyConduit supports message
					authentication code verification operations within a single
					security domain. It is created by calling
					CICM::ChannelManager::create_mac_verify_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::MACVerifyConduit Inheritance">
						<t>CICM::Answer::MACVerifyConduit inherits from:
						CICM::AbstractMACVerifyConduit and CICM::Answer::PutStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::SignConduit">
					<figure>
					  <preamble>Interface CICM::Answer::SignConduit</preamble>
<artwork><![CDATA[interface SignConduit :
	CICM::AbstractSignConduit,
	CICM::Answer::PutStream {]]></artwork>
					<postamble>CICM::Answer::SignConduit supports signature operations
					within a single security domain. It is created by calling
					CICM::ChannelManager::create_sign_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::SignConduit Inheritance">
						<t>CICM::Answer::SignConduit inherits from:
						CICM::AbstractSignConduit and CICM::Answer::PutStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::SignHashConduit">
					<figure>
					  <preamble>Interface  CICM::Answer::SignHashConduit</preamble>
					  <artwork><![CDATA[interface SignHashConduit : CICM::Answer::SignConduit {};]]></artwork>
					<postamble>CICM::Answer::SignHashConduit supports signature operations
					accepting a pre-generated hash value within a single security
					domain. It is created by calling
					CICM::ChannelManager::create_sign_hash_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::SignHashConduit Inheritance">
						<t>CICM::Answer::SignHashConduit inherits from:
						CICM::Answer::SignConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::VerifyConduit">
					<figure>
					  <preamble>Interface CICM::Answer::VerifyConduit</preamble>
<artwork><![CDATA[interface VerifyConduit :
	CICM::AbstractSigVerifyConduit,
	CICM::Answer::PutStream {]]></artwork>
					<postamble>CICM::Answer::VerifyConduit supports verification operations
					within a single security domain. It is created by calling
					CICM::ChannelManager::create_verify_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::VerifyConduit Inheritance">
						<t>CICM::Answer::VerifyConduit inherits from:
						CICM::AbstractSigVerifyConduit and CICM::Answer::PutStream.</t>
					</section>
				</section>
				<section title="Interface CICM::Answer::VerifyHashConduit">
					<figure>
					  <preamble>Interface  CICM::Answer::VerifyHashConduit</preamble>
					  <artwork><![CDATA[interface VerifyHashConduit : CICM::Answer::VerifyConduit {};]]></artwork>
					<postamble>CICM::Answer::VerifyHashConduit supports verification
					operations accepting a pre-generated hash value within a single
					security domain. It is created by calling
					CICM::ChannelManager::create_verify_hash_conduit.</postamble>
					</figure>

					<section title="CICM::Answer::VerifyHashConduit Inheritance">
						<t>CICM::Answer::VerifyHashConduit inherits from:
						CICM::Answer::VerifyConduit.</t>
					</section>
				</section>
			</section>
			<section anchor="sec-coprocessor" title="Single-Domain">
				<figure>
				  <preamble>Namespace CICM::Coprocessor</preamble>
				  <artwork><![CDATA[module Coprocessor {]]></artwork>
				<postamble>The CICM::Coprocessor namespace contains interfaces that
				support encryption/decryption operations within a single security
				domain.</postamble>
				</figure>
				<!-- t>{FIGURE REMOVED}</t>
				<t>Figure 40. Interface Relationship Diagram
				  for Single-Domain Encryption Channels</t>
				<t>{FIGURE REMOVED}</t>
				<t>Figure 41. Interface Relationship Diagram
				  for Single-Domain Decryption Channels</t -->

				<section title="Interface CICM::Coprocessor::ChannelManager">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::ChannelManager</preamble>
					  <artwork><![CDATA[interface ChannelManager {]]></artwork>
					<postamble>CICM::Coprocessor::ChannelManager is an abstraction inherited
					by CICM::ChannelManager that supports the creation of conduits to
					encrypt and decrypt data within a single security domain. See
					CICM::ChannelManager for additional information.</postamble>
					</figure>

					<section title="CICM::Coprocessor::ChannelManager Methods">
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_encrypt_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Coprocessor::EncryptConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to encrypt a stream of data within a single
						security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to encryption key.</t>
							<t>[in] algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_encrypt_with_mac_conduit(
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::EncryptWithMACConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to MAC and encrypt a stream of data within a
						single security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] mac_key_ref
								  Reference to MAC key.</t>
							<t>[in] encrypt_key_ref
								  Reference to encryption key.</t>
							<t>[in] mac_algorithm
								  MAC algorithm.</t>
							<t>[in] encrypt_algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_encrypt_with_sign_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_encrypt_with_sign_conduit(
	in  CICM::AsymKey sign_key_ref,
	in  CICM::SymKey encrypt_key_ref,
	in  CICM::AsymSigAlgorithmId sign_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::EncryptWithSignConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to sign and encrypt a stream of data within a
						single security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] sign_key_ref
								  Reference to signature key.</t>
							<t>[in] encrypt_key_ref
								  Reference to encryption key.</t>
							<t>[in] sign_algorithm
								  Signature algorithm.</t>
							<t>[in] encrypt_algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_decrypt_conduit(
	in  CICM::SymKey key_ref,
	in  CICM::SymEncrAlgorithmId algorithm,
	out CICM::Coprocessor::DecryptConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to decrypt a stream of data within a single
						security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] key_ref
								  Reference to decryption key.</t>
							<t>[in] algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_with_mac_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_decrypt_with_mac_conduit(
	in  CICM::SymKey mac_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::SymMacAlgorithmId mac_algorithm,
	in  CICM::SymEncrAlgorithmId encrypt_algorithm,
	out CICM::Coprocessor::DecryptWithMACConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to MAC verify and decrypt a stream of data
						within a single security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] mac_key_ref
								  Reference to MAC key.</t>
							<t>[in] decrypt_key_ref
								  Reference to decryption key.</t>
							<t>[in] mac_algorithm
								  MAC algorithm.</t>
							<t>[in] encrypt_algorithm
								  Encryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_INVALID, S_KEY_EXPIRED, S_ALGO_INVALID,
							  S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::Coprocessor::ChannelManager::create_coprocessor_decrypt_with_verify_conduit()</preamble>
<artwork><![CDATA[CICM::Status create_coprocessor_decrypt_with_verify_conduit(
	in  CICM::AsymKey verify_key_ref,
	in  CICM::SymKey decrypt_key_ref,
	in  CICM::AsymSigAlgorithmId verify_algorithm,
	in  CICM::SymEncrAlgorithmId decrypt_algorithm,
	out CICM::Coprocessor::DecryptWithVerifyConduit conduit_ref
);]]></artwork>
						<postamble>Create conduit to verify and decrypt a stream of data within
						a single security domain.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] verify_key_ref
								  Reference to verification key.</t>
							<t>[in] decrypt_key_ref
								  Reference to decryption key.</t>
							<t>[in] verify_algorithm
								  Verification algorithm.</t>
							<t>[in] decrypt_algorithm
								  Decryption algorithm/mode.</t>
							<t>[out] conduit_ref
								  Reference to resulting conduit.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_USED_INVALID,
							  S_KEY_USED_EXPIRED, S_KEY_USED_WRAPPED, S_KEY_USED_CONTEXT,
							  S_KEY_USED_COMPONENT_NOT_AVAIL, S_KEY_INVALID, S_KEY_EXPIRED,
							  S_ALGO_INVALID, S_ALGO_INCOMPATIBLE, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_MAX</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::Stream">
					<figure>
					  <preamble>Interface CICM::Coprocessor::Stream</preamble>
					  <artwork><![CDATA[interface Stream : CICM::Stream {]]></artwork>
					<postamble>CICM::Coprocessor::Stream is an abstraction inherited by all
					conduits in the CICM::Coprocessor namespace.</postamble>
					</figure>

					<section title="CICM::Coprocessor::Stream Inheritance">
						<t>CICM::Coprocessor::Stream inherits from: CICM::Stream.</t>
					</section>
					<section title="CICM::Coprocessor::Stream Methods">
						<figure>
						  <preamble>Method CICM::Coprocessor::Stream::get_final_buffer()</preamble>
<artwork><![CDATA[CICM::Status get_final_buffer(
	out CICM::Buffer buffer
);]]></artwork>
						<postamble>Returns the final block of transformed data, if available.
						The method blocks until data becomes available.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>In certain cases, it may be necessary to retrieve the last
							transformed block of data, if, for example, a partial block
							remains after the last full block was retrieved. This call
							MUST be called after all data is supplied to the module
							and MUST precede any end_get_* calls.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[out] buffer
								  Buffer of data read from stream.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_KEY_INVALID,
							  S_KEY_EXPIRED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::EncryptConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::EncryptConduit</preamble>
<artwork><![CDATA[interface EncryptConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::GenVectorController,
	CICM::ResyncController,
	CICM::Coprocessor::Stream {]]></artwork>
					<postamble>CICM::Coprocessor::EncryptConduit supports encryption
					operations within a single security domain. The resulting conduit
					is capable of managing the channel, accepting data for
					transformation, and receiving the result. It is created by calling
					CICM::ChannelManager::create_coprocessor_encrypt_conduit.</postamble>
					</figure>
					<section title="CICM::Coprocessor::EncryptConduit Inheritance">
						<t>CICM::Coprocessor::EncryptConduit inherits from:
						CICM::Conduit, CICM::SymKeyController, CICM::GenVectorController,
						CICM::ResyncController and CICM::Coprocessor::Stream.</t>
					</section>
					<section title="CICM::Coprocessor::EncryptConduit Methods">
						<figure>
						  <preamble>Method CICM::Coprocessor::EncryptConduit::encrypt()</preamble>
<artwork><![CDATA[CICM::Status encrypt(
	in  CICM::Buffer plaintext,
	out CICM::Buffer ciphertext
);]]></artwork>
						<postamble>Send plaintext to the module to be encrypted, receiving the
						ciphertext resulting from the transformation as the result.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] plaintext
								  Plaintext to encrypt.</t>
							<t>[out] ciphertext
								  Ciphertext resulting from encryption operation.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN, S_CHANNEL_BUFFER_LEN</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::EncryptWithMACConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::EncryptWithMACConduit</preamble>
<artwork><![CDATA[interface EncryptWithMACConduit :
	CICM::AbstractMACConduit,
	CICM::Coprocessor::EncryptConduit {]]></artwork>
					<postamble>CICM::Coprocessor::EncryptWithMACConduit supports encryption
					with MAC operations within a single security domain. The resulting
					conduit is capable of managing the channel, accepting data for
					transformation, and receiving the result (both ciphertext and a MAC
					value). It is created by calling
					CICM::ChannelManager::create_coprocessor_encrypt_with_mac_conduit.</postamble>
					</figure>

					<section title="CICM::Coprocessor::EncryptWithMACConduit Inheritance">
						<t>CICM::Coprocessor::EncryptWithMACConduit inherits
						from: CICM::AbstractMACConduit and
						CICM::Coprocessor::EncryptConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::EncryptWithSignConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::EncryptWithSignConduit</preamble>
<artwork><![CDATA[interface EncryptWithSignConduit :
	CICM::AbstractSignConduit,
	CICM::Coprocessor::EncryptConduit {]]></artwork>
					<postamble>CICM::Coprocessor::EncryptWithSignConduit supports encryption
					with signature operations within a single security domain. The
					resulting conduit is capable of managing the channel, accepting
					data for transformation, and receiving the result (both ciphertext
					and a signature). It is created by calling
					CICM::ChannelManager::create_coprocessor_encrypt_with_sign_conduit.</postamble>
					</figure>

					<section title="CICM::Coprocessor::EncryptWithSignConduit Inheritance">
						<t>CICM::Coprocessor::EncryptWithSignConduit inherits
						from: CICM::AbstractSignConduit and
						CICM::Coprocessor::EncryptConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::DecryptConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::DecryptConduit</preamble>
<artwork><![CDATA[interface DecryptConduit :
	CICM::Conduit,
	CICM::SymKeyController,
	CICM::SetVectorController,
	CICM::ResyncController,
	CICM::Coprocessor::Stream {]]></artwork>
					<postamble>CICM::Coprocessor::DecryptConduit supports decryption
					operations within a single security domain. The resulting conduit
					is capable of managing the channel, accepting data for
					transformation, and receiving the result. It is created by calling
					CICM::ChannelManager::create_coprocessor_decrypt_conduit.</postamble>
					</figure>

					<section title="CICM::Coprocessor::DecryptConduit Inheritance">
						<t>CICM::Coprocessor::DecryptConduit inherits from:
						CICM::Conduit, CICM::SymKeyController, CICM::SetVectorController,
						CICM::ResyncController and CICM::Coprocessor::Stream.</t>
					</section>
					<section title="CICM::Coprocessor::DecryptConduit Methods">
						<figure>
						  <preamble>Method CICM::Coprocessor::DecryptConduit::decrypt()</preamble>
<artwork><![CDATA[CICM::Status decrypt(
	in  CICM::Buffer ciphertext,
	out CICM::Buffer plaintext
);]]></artwork>
						<postamble>Send ciphertext to the module to be decrypted, receiving the
						plaintext resulting from the transformation as the result.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] ciphertext
								  Ciphertext to decrypt.</t>
							<t>[out] plaintext
								  Plaintext resulting from decryption operation.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_ERROR,
							  S_CHANNEL_IO_ERROR, S_CHANNEL_DATA_INVALID,
							  S_CHANNEL_DATA_INVALID_LEN, S_CHANNEL_BUFFER_LEN</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::DecryptWithMACConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::DecryptWithMACConduit</preamble>
<artwork><![CDATA[interface DecryptWithMACConduit :
	CICM::AbstractMACVerifyConduit,
	CICM::Coprocessor::DecryptConduit {]]></artwork>
					<postamble>CICM::Coprocessor::DecryptWithMACConduit supports encryption
					with MAC verification operations within a single security domain.
					The resulting conduit is capable of managing the channel, accepting
					data for transformation, and receiving the result (both plaintext
					and an indication as to whether verification succeeded or failed).
					It is created by calling
					CICM::ChannelManager::create_coprocessor_decrypt_with_mac_conduit.</postamble>
					</figure>

					<section title="CICM::Coprocessor::DecryptWithMACConduit Inheritance">
						<t>CICM::Coprocessor::DecryptWithMACConduit inherits
						from: CICM::AbstractMACVerifyConduit and
						CICM::Coprocessor::DecryptConduit.</t>
					</section>
				</section>
				<section title="Interface CICM::Coprocessor::DecryptWithVerifyConduit">
					<figure>
					  <preamble>Interface  CICM::Coprocessor::DecryptWithVerifyConduit</preamble>
<artwork><![CDATA[interface DecryptWithVerifyConduit :
CICM::AbstractSigVerifyConduit,
CICM::Coprocessor::DecryptConduit {]]></artwork>
					<postamble>CICM::Coprocessor::DecryptWithVerifyConduit supports
					encryption with signature verification operations within a single
					security domain. The resulting conduit is capable of managing the
					channel, accepting data for transformation, and receiving the
					result (both plaintext and an indication as to whether verification
					succeeded or failed). It is created by calling
					CICM::ChannelManager::create_coprocessor_decrypt_with_verify_conduit.</postamble>
					</figure>

					<section title="CICM::Coprocessor::DecryptWithVerifyConduit Inheritance">
						<t>CICM::Coprocessor::DecryptWithVerifyConduit
						inherits from: CICM::AbstractSigVerifyConduit and
						CICM::Coprocessor::DecryptConduit.</t>
					</section>
				</section>
			</section>
			<section title="Channel Events">
				<section title="Interface CICM::ChannelEventManager">
					<figure>
					  <preamble>Interface CICM::ChannelEventManager</preamble>
					  <artwork><![CDATA[interface ChannelEventManager {]]></artwork>
					<postamble>CICM::ChannelEventManager supports registering and
					unregistering user-defined channel event listeners
					(CICM::ChannelEventListener) for specific channel events. It is
					accessed from any channel via its CICM::Channel::event_manager
					attribute.</postamble>
					</figure>
					<t>Remarks:
						<list>
						<t>In certain cases it may be necessary for a channel to
						asynchronously notify a client program of an event. Client
						programs can register to receive channel notifications using
						CICM::ChannelEventManager. This manager enables a client
						program to register a listener (callback) method designed to
						handle a specific condition. The event method prototype
						provided by the client program is defined in
						CICM::ChannelEventListener. CICM::ChannelEventListener also
						defines the conditions that may result in a notification,
						including: channel failure or channel destruction.</t>
						</list>
					</t>
					<!-- t>{FIGURE REMOVED}</t>
					<t>Figure 42. Interface Relationship Diagram for ChannelEventManager</t -->

					<section title="CICM::ChannelEventManager Methods">
						<figure>
						  <preamble>Method CICM::ChannelEventManager::register()</preamble>
<artwork><![CDATA[CICM::Status register(
	in  CICM::ChannelEventListener::ChannelEvent event,
	in  CICM::ChannelEventListener listener
);]]></artwork>
						<postamble>Registers the listener for a specific channel event.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The provided listener applies only to the client program
							from which the registration is initiated.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] event
								  Event for which this listener is being
								  registered.</t>
							<t>[in] listener
								  Listener that will receive a notification about the
								  specified event.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_HOST_RESOURCES,
							  S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE,
							  S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_EVENT_REGISTERED, S_EVENT_NOT_SUPPORTED</t>
							</list>
						</t>
						<figure>
						  <preamble>Method CICM::ChannelEventManager::unregister()</preamble>
<artwork><![CDATA[CICM::Status unregister(
	in  CICM::ChannelEventListener::ChannelEvent event
);]]></artwork>
						<postamble>Unregisters the listener associated with the specified
						event.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The listener associated with the specified event is only
							unregistered from the client program from which this method is
							called.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] event
								  Event that will no longer have a listener associated
								  with it.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_HOST_RESOURCES,
							  S_INVALID_STATE, S_ALARM_STATE, S_MODULE_NOT_AVAILABLE,
							  S_TIMEOUT, S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED,
							  S_TOKEN_NOT_PRESENT, S_TOKEN_ADMIN_NOT_PRESENT,
							  S_EVENT_NOT_REGISTERED</t>
							</list>
						</t>
					</section>
				</section>
				<section title="Interface CICM::ChannelEventListener">
					<figure>
					  <preamble>Interface CICM::ChannelEventListener</preamble>
					  <artwork><![CDATA[interface ChannelEventListener {]]></artwork>
					<postamble>CICM::ChannelEventListener is unlike other CICM interfaces in
					that the interface is implemented by the developer of the client
					program to service a specific channel event and is then registered
					via the CICM::ChannelEventManager.</postamble>
					</figure>

					<section title="CICM::ChannelEventListener Types and Constants">
						<figure>
						  <preamble>Type CICM::ChannelEventListener::ChannelEvent</preamble>
						  <artwork><![CDATA[typedef CICM::UInt32 ChannelEvent;]]></artwork>
						<postamble>Events for which a ChannelEventListener can be notified.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ChannelEventListener::C_CHANNEL_DATA_AVAILABLE</preamble>
<artwork><![CDATA[const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_DATA_AVAILABLE = 0x00004001;]]></artwork>
							<postamble>Data from remote peer is available.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ChannelEventListener::C_CHANNEL_ERROR</preamble>
<artwork><![CDATA[const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_ERROR = 0x00004002;]]></artwork>
							<postamble>General error has occurred on the channel.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ChannelEventListener::C_CHANNEL_INSUFFICIENT_ENTROPY</preamble>
<artwork><![CDATA[const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_INSUFFICIENT_ENTROPY = 0x00004004;]]></artwork>
							<postamble>Insufficient entropy available on the channel.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ChannelEventListener::C_CHANNEL_LOST_SYNC</preamble>
<artwork><![CDATA[const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_LOST_SYNC = 0x00004007;]]></artwork>
						  <postamble>Cryptographic synchronization with remote peer has been
						  lost; this may not be detectable by the cryptographic
						  module.</postamble>
						</figure>
						<figure>
							<preamble>Constant CICM::ChannelEventListener::C_CHANNEL_PEER_RESET</preamble>
<artwork><![CDATA[const CICM::ChannelEventListener::ChannelEvent
	C_CHANNEL_PEER_RESET = 0x00004008;]]></artwork>
						  <postamble>Remote peer is no longer available; this may not be
						  detectable by the cryptographic module.</postamble>
						</figure>
					</section>
					<section title="CICM::ChannelEventListener Methods">
						<figure>
						  <preamble>Method CICM::ChannelEventListener::event_occurred()</preamble>
<artwork><![CDATA[ void event_occurred(
	in  CICM::ChannelEventListener::ChannelEvent event,
	in  CICM::Buffer event_data
);]]></artwork>
						<postamble>Method implemented by client program that receives a message
						about a channel event that occurred. An opaque data field with
						additional information about the event in a module-specific format
						may optionally be provided with the event itself.</postamble>
						</figure>
						<t>Remarks:
							<list>
							<t>The format of the event data value is not defined by CICM.
							The Implementation Conformance Statement (see
							Conformance and Extensions in <xref target="CICM" />) MUST
              reference a standard format or
							define a module-specific format for this datatype.</t>
							</list>
						</t><t>Note:
							<list>
							<t>Because this method is called by the runtime system and not
							a client program, it does not return a status value.</t>
							</list>
						</t><t>Parameters:
							<list>
							<t>[in] event
								  Event that occurred.</t>
							<t>[in] event_data
								  Opaque data associated with the event.</t>
							</list>
						</t>
					</section>
				</section>
			</section>
			<section title="Channel Groups">
				<section title="Interface CICM::ControllerGroup">
					<figure>
					  <preamble>Interface CICM::ControllerGroup</preamble>
					  <artwork><![CDATA[interface ControllerGroup {]]></artwork>
					<postamble>Group of controllers and/or conduits.</postamble>
					</figure>
					<t>Remarks:
						<list>
						  <t>All of the controllers in a controller group share certain
						  characteristics, such as a state vector. Whenever a shared
						  characteristic is changed on a member of the group, the change is
						  applied to all members of the group. Thus, if a client program
						  has grouped controllers/conduits to follow advancing TOD rules,
						  for example, when one controller/conduit performs an operation at
						  time X as expressed in the TOD value, all other grouped
						  controllers/conduits are prohibited from using a TOD value
						  earlier than time X.</t>
						</list>
					</t>
					<section title="CICM::ControllerGroup Methods">
						<figure>
						  <preamble>Method CICM::ControllerGroup::add()</preamble>
<artwork><![CDATA[CICM::Status add(
	in CICM::Controller controller_ref
);]]></artwork>
						  <postamble>Add a controller or conduit to this controller group.</postamble>
						</figure>
						<t>Parameters:
							<list>
							<t>[in] controller_ref
								  Controller to add to the group.</t>
							</list>
						</t><t>Returns:
							<list>
							<t>
							  S_OK, S_GENERAL_ERROR,
							  S_NON_FUNCTIONAL, S_OPERATION_FAILED, S_POLICY_VIOLATION,
							  S_MODULE_RESOURCES, S_HOST_RESOURCES, S_INVALID_STATE,
							  S_ALARM_STATE, S_MODULE_NOT_AVAILABLE, S_TIMEOUT,
							  S_NOT_AUTHENTICATED, S_NOT_AUTHORIZED, S_TOKEN_NOT_PRESENT,
							  S_TOKEN_ADMIN_NOT_PRESENT, S_CHANNEL_IN_GROUP,
							  S_CHANNEL_CLASSIFICATION</t>
							</list>
						</t>
					</section>
				</section>
			</section>
      <section title="IANA Considerations">
        <t>[RFC Editor: Please remove this section prior to publication.]</t>
        <t>This document has no IANA actions.</t>
      </section>
      <section title="Security Considerations">
        <section title="Confidentiality">
          <t>This document defines several channels that provide confidentiality
          services such encryption and decryption as defined in the CICM::Encrypt,
          CICM::Decrypt, CICM::Duplex, CICM::EncryptBypass, CICM::DecryptBypass,
          and CICM::Coprocessor namespaces. Note, however, that the CICM::EncryptBypass
          and CICM::DecryptBypass namespaces are capable of sending unencrypted data
          (see Bypass below).</t>
        </section>
        <section title="Bypass">
          <t>This document defines four namespaces related to sending and receiving
          bypass data. CICM::BypassWrite and CICM::BypassRead are for full bypass while
          CICM::EncryptBypass and CICM::DecryptBypass are for selective bypass.</t>
          <t>Unintentional sending of bypass data is typically considered a comprimise
          in the confidentiality of a system, and therefore implementors are urged to
          consider their security policies carefully.</t>
          <t>To mitigate against accidental programming errors related to bypass, this document 
          ensures that:
            <list style="numbers">
              <t>All bypass functionality is contained four clearly labeled distinct namespaces.</t>
              <t>Each method that touches bypass data contains bypass as part of its name 
              (e.g., CICM::BypassWrite::Stream::write_bypass()).</t>
            </list>
          </t>
        </section>
        <section title="Data Integrity">
          <t>This document defines several data integrity services either as stand-alone or 
          hybrid channels. The CICM::Answer namespace contains channels for hashing, signing,
          and verifying signed data. Similarly, CICM::Encrypt, CICM::Decrypt, CICM::Coprocessor 
          have channels that, in addition to encrypting or decrypting, sign or verify the 
          transmitted data.</t>
        </section>
        <section title="Peer Entity Authentication">
          <t>This document defines a CICM::Negotiator which defines the basic peer-entity authentication
          mechanism. Channels defined in the CICM::Encrypt, CICM::Decrypt, CICM::Duplex, 
          CICM::EncryptBypass, and CICM::DecryptBypass namespaces define negotiated versions of
          most of the channels. See Channel Negotiation (<xref target="sec_channel_negotiation" />)
          for more information.</t>
        </section>
      </section>
  </middle>
  <back><!-- Back material. -->
    <references title="Normative References">
      <?rfc include="reference.RFC.2119" ?>

      <reference anchor="CICM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM)
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-02.txt" />
      </reference>

      <reference anchor="CICM-KM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Key Management
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-keys-00.txt" />
      </reference>

      <reference anchor="IDL">
        <front>
          <title>Information technology — Open Distributed Processing — Interface Definition Language</title>
          <author>
            <organization>International Standards Organization</organization>
          </author>
          <date year="1999" month="March" day="15" />
        </front>
        <seriesInfo name="ISO/IEC" value="14750:1999(E)" />
      </reference>
    </references>
    <references title="Informative References">
      <?rfc include="reference.RFC.3552" ?>

      <reference anchor="CICM-LM">
        <front>
          <title>Common Interface to Cryptographic Modules (CICM) Logical Model
          [RFC Editor: Please update the RFC reference and date prior to publication.]</title>
          <author fullname="Daniel J. Lanz" initials="D." surname="Lanz" />
          <author fullname="Lev Novikov" initials="L." surname="Novikov" />
          <date year="2011" month="January" />
        </front>
        <format type="TXT" target="http://tools.ietf.org/id/draft-lanz-cicm-model-00.txt" />
      </reference>

      <reference anchor="CORBA">
        <front>
          <title>Common Object Request Broker Architecture (CORBA) Specification, Version 3.1</title>
          <author>
            <organization>Object Management Group</organization>
          </author>
          <date year="2008" month="January" />
        </front>
      </reference>
    </references>
    <section anchor="idl-code" title="IDL Definitions"><figure><artwork><![CDATA[module CICM {
  typedef CICM::Buffer MACBuffer;
  typedef CICM::Buffer SigBuffer;
  typedef CICM::Buffer HashBuffer;
  typedef CICM::Buffer Vector;

  typedef CICM::UInt32 TransId;

  typedef CICM::CharString HashAlgorithmId;

  typedef CICM::CharString AsymEncrAlgorithmId;
  const CICM::AsymEncrAlgorithmId IMPLICIT_ASYM_ENCR_ALGO = "IMPLICIT";

  typedef CICM::CharString AsymSigAlgorithmId;
  const CICM::AsymSigAlgorithmId IMPLICIT_ASYM_SIG_ALGO = "IMPLICIT";

  typedef CICM::CharString SymEncrAlgorithmId;
  const CICM::SymEncrAlgorithmId IMPLICIT_SYM_ENCR_ALGO = "IMPLICIT";

  typedef CICM::CharString SymMacAlgorithmId;
  const CICM::SymMacAlgorithmId IMPLICIT_SYM_MAC_ALGO = "IMPLICIT";

  typedef CICM::CharString KeyWrapAlgorithmId;
  const CICM::KeyWrapAlgorithmId IMPLICIT_KEY_WRAP_ALGO = "IMPLICIT";

  typedef CICM::CharString ProtocolId;
  const CICM::ProtocolId IMPLICIT_PROTOCOL_ID = "IMPLICIT";

  interface PeerInfo {
    readonly attribute CICM::CharString peer_name;
    readonly attribute CICM::Classification classification;
    readonly attribute CICM::CharString compartment;
    readonly attribute CICM::CharString message;
  };

  interface Negotiator {
    CICM::Status get_remote_info(
      out CICM::PeerInfo peer_info );

    CICM::Status abort_negotiation();
  };

  interface ChannelEventListener {
    typedef CICM::UInt32 ChannelEvent;
    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_DATA_AVAILABLE = 0x00004001;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_ERROR = 0x00004002;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_INSUFFICIENT_ENTROPY = 0x00004004;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_LOST_SYNC = 0x00004007;

    const CICM::ChannelEventListener::ChannelEvent
      C_CHANNEL_PEER_RESET = 0x00004008;

    void event_occurred(
      in  CICM::ChannelEventListener::ChannelEvent event,
      in  CICM::Buffer event_data );
  };

  interface ChannelEventManager {
    CICM::Status register(
      in  CICM::ChannelEventListener::ChannelEvent event,
      in  CICM::ChannelEventListener listener );

    CICM::Status unregister(
      in  CICM::ChannelEventListener::ChannelEvent event );
  };

  interface Channel {
    readonly attribute CICM::ChannelEventManager event_manager;
  };

  interface Stream : CICM::Channel {};

  interface WriteStream : CICM::Stream {
    typedef CICM::UInt32 WriteStatus;
    const CICM::WriteStream::WriteStatus C_WRITE_NOT_READY = 0x00006067;
    const CICM::WriteStream::WriteStatus C_WRITE_READY = 0x00006068;
  };

  interface ReadStream : CICM::Stream {
    typedef CICM::UInt32 ReadStatus;
    const CICM::ReadStream::ReadStatus C_READ_NOT_READY = 0x0000605E;
    const CICM::ReadStream::ReadStatus C_READ_READY = 0x00006061;
  };

  interface Controller : CICM::Channel {
    CICM::Status destroy();
  };

  interface MultiDomainController : CICM::Controller {
    readonly attribute CICM::LocalPort local_port;
    readonly attribute CICM::RemotePort remote_port;
  };

  interface SymKeyController : CICM::Controller {
    readonly attribute CICM::SymKey key;

    CICM::Status update_key();

    CICM::Status update_key_with_algo(
      in  CICM::SymEncrAlgorithmId algorithm );

    CICM::Status rollover_key();

    CICM::Status rollover_key_with_key(
      in  CICM::SymKey next_key );
  };

  interface AsymKeyController : CICM::Controller {
    readonly attribute CICM::AsymKey key;
  };

  interface NegotiatedController :
    CICM::MultiDomainController,
    CICM::AsymKeyController,
    CICM::Negotiator {

    readonly attribute CICM::Classification negotiated_grade;

    CICM::Status renegotiate();

    CICM::Status initiate_grade_change(
      in  CICM::Classification new_grade );

    CICM::Status acknowledge_grade_change();
  };

  interface SetVectorController : CICM::Controller {
    readonly attribute CICM::Vector vec;

    CICM::Status set_vector(
      in  CICM::Vector vec );

    CICM::Status set_vector_no_check(
      in  CICM::Vector vec );

    CICM::Status reset_vector();
  };

  interface GenVectorController : CICM::SetVectorController {
    CICM::Status generate_vector();
    CICM::Status generate_vector_existing_state();
  };

  interface ResyncController : CICM::Controller {
    CICM::Status resync();
    CICM::Status resync_with_sync_vector(
      in  CICM::Vector vec );
  };

  interface ControllerGroup {
    CICM::Status add(
      in CICM::Controller controller_ref );
  };

  interface Conduit :
    CICM::Controller,
    CICM::Stream {
  };

  interface AbstractMACConduit : CICM::Conduit {
    readonly attribute CICM::SymKey mac_key;
    readonly attribute CICM::SymMacAlgorithmId mac_algorithm;

    CICM::Status end_get_mac(
      out CICM::MACBuffer mac );
  };

  interface AbstractSignConduit : CICM::Conduit {
    readonly attribute CICM::AsymKey sign_key;
    readonly attribute CICM::AsymSigAlgorithmId sign_algorithm;

    CICM::Status end_get_signature(
      out CICM::SigBuffer signature );
  };

  interface AbstractVerifyConduit : CICM::Conduit {
    typedef CICM::UInt32 VerifyStatus;
    const CICM::AbstractVerifyConduit::VerifyStatus
      C_DATA_VERIFIED = 0x00006025;

    const CICM::AbstractVerifyConduit::VerifyStatus
      C_DATA_NOT_VERIFIED = 0x00006026;

  };

  interface AbstractMACVerifyConduit : CICM::AbstractVerifyConduit {
    readonly attribute CICM::SymKey verify_key;
    readonly attribute CICM::SymMacAlgorithmId verify_algorithm;

    CICM::Status end_get_verified(
      in  CICM::MACBuffer mac,
      out CICM::AbstractVerifyConduit::VerifyStatus status );
  };

  interface AbstractSigVerifyConduit : CICM::AbstractVerifyConduit {
    readonly attribute CICM::AsymKey verify_key;
    readonly attribute CICM::AsymSigAlgorithmId verify_algorithm;

    CICM::Status end_get_verified(
      in  CICM::SigBuffer signature,
      out CICM::AbstractVerifyConduit::VerifyStatus status );
  };

  module Encrypt {
    interface Stream : CICM::WriteStream {
      CICM::Status encrypt(
        in  CICM::Buffer buffer );

      CICM::Status encrypt_non_blocking(
        in  CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status encrypt_poll(
        in  CICM::TransId transaction_id,
        out CICM::WriteStream::WriteStatus status );
    };

    interface KeyWrapStream : CICM::Stream {
      CICM::Status wrap_key(
        in CICM::Key key_ref );
    };

    interface Controller :
      CICM::MultiDomainController,
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::ResyncController {};

    interface NegotiatedController :
      CICM::NegotiatedController,
      CICM::GenVectorController,
      CICM::ResyncController {};

    interface Conduit :
      CICM::Conduit,
      CICM::Encrypt::Controller,
      CICM::Encrypt::Stream {};

    interface NegotiatedConduit :
      CICM::Conduit,
      CICM::Encrypt::NegotiatedController,
      CICM::Encrypt::Stream {};

    interface WithMACConduit :
      CICM::AbstractMACConduit,
      CICM::Encrypt::Conduit {};

    interface WithMACNegotiatedConduit :
      CICM::AbstractMACConduit,
      CICM::Encrypt::NegotiatedConduit {};

    interface WithSignConduit :
      CICM::AbstractSignConduit,
      CICM::Encrypt::Conduit {};

    interface WithSignNegotiatedConduit :
      CICM::AbstractSignConduit,
      CICM::Encrypt::NegotiatedConduit {};

    interface KeyWrapConduit :
      CICM::Encrypt::Controller,
      CICM::Encrypt::KeyWrapStream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::NegotiatedConduit conduit_ref );
    };

    interface WithMACNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::WithMACNegotiatedConduit conduit_ref );
    };

    interface WithSignNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Encrypt::WithSignNegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_encrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Encrypt::Negotiator negotiator_ref );

      CICM::Status negotiate_encrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::SymKey mac_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        out CICM::Encrypt::WithMACNegotiator negotiator_ref );

      CICM::Status negotiate_encrypt_with_sign_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey sign_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::AsymSigAlgorithmId sign_algorithm,
        out CICM::Encrypt::WithSignNegotiator negotiator_ref );

      CICM::Status negotiate_encrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Encrypt::ControllerNegotiator negotiator_ref );

      CICM::Status create_encrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Encrypt::Conduit conduit_ref );

      CICM::Status create_encrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey mac_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        in  CICM::SymEncrAlgorithmId encr_algorithm,
        out CICM::Encrypt::WithMACConduit conduit_ref );

      CICM::Status create_encrypt_with_sign_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::AsymKey sign_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::AsymSigAlgorithmId sign_algorithm,
        in  CICM::SymEncrAlgorithmId encr_algorithm,
        out CICM::Encrypt::WithSignConduit conduit_ref );
      CICM::Status create_key_wrap_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey kek_ref,
        in  CICM::KeyWrapAlgorithmId algorithm,
        out CICM::Encrypt::KeyWrapConduit conduit_ref );

      CICM::Status create_encrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Encrypt::Controller controller_ref );

      CICM::Status get_encrypt_stream(
        in  CICM::LocalPort local_port,
        out CICM::Encrypt::Stream stream_ref );
    };
  };

  module Decrypt {
    interface Stream : CICM::ReadStream {
      CICM::Status decrypt(
        out CICM::Buffer buffer );

      CICM::Status decrypt_non_blocking(
        out CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status decrypt_poll(
        in  CICM::TransId transaction_id,
        out CICM::ReadStream::ReadStatus status );
    };

    interface KeyUnwrapStream : CICM::Stream {
      CICM::Status unwrap_sym_key(
        out CICM::SymKey key_ref );

      CICM::Status unwrap_asym_key(
        out CICM::AsymKey key_ref );
    };

    interface Controller :
      CICM::MultiDomainController,
      CICM::SymKeyController,
      CICM::SetVectorController,
      CICM::ResyncController {};

    interface NegotiatedController :
      CICM::NegotiatedController,
      CICM::SetVectorController,
      CICM::ResyncController {};

    interface Conduit :
      CICM::Conduit,
      CICM::Decrypt::Controller,
      CICM::Decrypt::Stream {};

    interface NegotiatedConduit :
      CICM::Conduit,
      CICM::Decrypt::NegotiatedController,
      CICM::Decrypt::Stream {};

    interface WithMACConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Decrypt::Conduit {};

    interface WithMACNegotiatedConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Decrypt::NegotiatedConduit {};

    interface WithVerifyConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Decrypt::Conduit {};

    interface WithVerifyNegotiatedConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Decrypt::NegotiatedConduit {};

    interface KeyUnwrapConduit :
      CICM::Decrypt::Controller,
      CICM::Decrypt::KeyUnwrapStream {};

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::NegotiatedConduit conduit_ref );
    };

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::NegotiatedController controller_ref );
    };

    interface WithMACNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::WithMACNegotiatedConduit conduit_ref );
    };

    interface WithVerifyNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Decrypt::WithVerifyNegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_decrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Decrypt::Negotiator negotiator_ref );

      CICM::Status negotiate_decrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::SymKey verify_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::SymMacAlgorithmId verify_algorithm,
        out CICM::Decrypt::WithMACNegotiator negotiator_ref );

      CICM::Status negotiate_decrypt_with_verify_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey verify_key_ref,
        in  CICM::AsymKey nego_key_ref,
        in  CICM::AsymSigAlgorithmId verify_algorithm,
        out CICM::Decrypt::WithVerifyNegotiator negotiator_ref );

      CICM::Status negotiate_decrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Decrypt::ControllerNegotiator negotiator_ref );

      CICM::Status create_decrypt_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Decrypt::Conduit conduit_ref );

      CICM::Status create_decrypt_with_mac_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey verify_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::SymMacAlgorithmId verify_algorithm,
        in  CICM::SymEncrAlgorithmId decrypt_algorithm,
        out CICM::Decrypt::WithMACConduit conduit_ref );

      CICM::Status create_decrypt_with_verify_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::AsymKey verify_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::AsymSigAlgorithmId verify_algorithm,
        in  CICM::SymEncrAlgorithmId decrypt_algorithm,
        out CICM::Decrypt::WithVerifyConduit conduit_ref );

      CICM::Status create_key_unwrap_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey kek_ref,
        in  CICM::KeyWrapAlgorithmId algorithm,
        out CICM::Decrypt::KeyUnwrapConduit conduit_ref );

      CICM::Status create_decrypt_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Decrypt::Controller controller_ref );

      CICM::Status get_decrypt_stream(
        in  CICM::LocalPort local_port,
        out CICM::Decrypt::Stream stream_ref );
    };
  };

  module Duplex {
    interface Stream :
      CICM::Encrypt::Stream,
      CICM::Decrypt::Stream {};

    interface Controller :
      CICM::Encrypt::Controller,
      CICM::Decrypt::Controller {};

    interface NegotiatedController :
      CICM::Encrypt::NegotiatedController,
      CICM::Decrypt::NegotiatedController {};

    interface Conduit :
      CICM::Conduit,
      CICM::Duplex::Controller,
      CICM::Duplex::Stream {};

    interface NegotiatedConduit :
      CICM::Duplex::NegotiatedController,
      CICM::Duplex::Stream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::Duplex::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
       CICM::Status complete(
        out CICM::Duplex::NegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_duplex_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Duplex::Negotiator negotiator_ref );

      CICM::Status negotiate_duplex_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::Duplex::ControllerNegotiator negotiator_ref );

      CICM::Status create_duplex_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Duplex::Conduit conduit_ref );

      CICM::Status create_duplex_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Duplex::Controller controller_ref );

      CICM::Status get_duplex_stream(
        in  CICM::LocalPort local_port,
        out CICM::Duplex::Stream stream_ref );
    };
  };

  module BypassWrite {
    interface Stream : CICM::WriteStream {
      CICM::Status write_bypass(
        in  CICM::Buffer buffer );

      CICM::Status write_bypass_non_blocking(
        in  CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status write_bypass_poll(
        in  CICM::TransId transaction_id,
        out CICM::WriteStream::WriteStatus status );
    };

    interface Controller : CICM::MultiDomainController {};

    interface Conduit :
      CICM::Conduit,
      CICM::BypassWrite::Controller,
      CICM::BypassWrite::Stream {};

    interface ChannelManager {
      CICM::Status create_bypass_write_conduit(
        in  CICM::RemotePort remote_port,
        out CICM::BypassWrite::Conduit conduit_ref );

      CICM::Status create_bypass_write_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        out CICM::BypassWrite::Controller controller_ref );

      CICM::Status get_bypass_write_stream(
        in  CICM::LocalPort local_port,
        out CICM::BypassWrite::Stream stream_ref );
    };
  };

  module BypassRead {
    interface Stream : CICM::ReadStream {
      CICM::Status read_bypass(
        out CICM::Buffer buffer );

      CICM::Status read_bypass_non_blocking(
        out CICM::Buffer buffer,
        in   CICM::TransId transaction_id );

      CICM::Status read_bypass_poll(
        in  CICM::TransId transaction_id,
        out CICM::ReadStream::ReadStatus status );
    };

    interface Controller : CICM::MultiDomainController {};

    interface Conduit :
      CICM::Conduit,
      CICM::BypassRead::Controller,
      CICM::BypassRead::Stream {};

    interface ChannelManager {
      CICM::Status create_bypass_read_conduit(
        in  CICM::RemotePort remote_port,
        out CICM::BypassRead::Conduit conduit_ref );

      CICM::Status create_bypass_read_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        out CICM::BypassRead::Controller controller_ref );

      CICM::Status get_bypass_read_stream(
        in  CICM::LocalPort local_port,
        out CICM::BypassRead::Stream stream_ref );
    };
  };

  module EncryptBypass {
    interface Stream :
      CICM::Encrypt::Stream,
      CICM::BypassWrite::Stream {
    };

    interface NegotiatedController :
      CICM::Encrypt::NegotiatedController {};

    interface Controller : CICM::Encrypt::Controller {};

    interface Conduit :
      CICM::Encrypt::Conduit,
      CICM::EncryptBypass::Stream {};

    interface NegotiatedConduit :
      CICM::Encrypt::NegotiatedController,
      CICM::EncryptBypass::Stream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::EncryptBypass::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::EncryptBypass::NegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_encrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::EncryptBypass::Negotiator negotiator_ref );

      CICM::Status negotiate_encrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::EncryptBypass::ControllerNegotiator negotiator_ref );

      CICM::Status create_encrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::EncryptBypass::Conduit conduit_ref );

      CICM::Status create_encrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::EncryptBypass::Controller controller_ref );

      CICM::Status get_encrypt_bypass_stream(
        in  CICM::LocalPort local_port,
        out CICM::EncryptBypass::Stream stream_ref );
    };
  };

  module DecryptBypass {
    interface Stream : CICM::Decrypt::Stream {};

    interface NegotiatedController :
      CICM::Decrypt::NegotiatedController {};

    interface Controller : CICM::Encrypt::Controller {};

    interface Conduit :
      CICM::Decrypt::Conduit,
      CICM::DecryptBypass::Controller,
      CICM::DecryptBypass::Stream {};

    interface NegotiatedConduit :
      CICM::Decrypt::NegotiatedConduit,
      CICM::DecryptBypass::NegotiatedController,
      CICM::DecryptBypass::Stream {};

    interface ControllerNegotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::DecryptBypass::NegotiatedController controller_ref );
    };

    interface Negotiator : CICM::Negotiator {
      CICM::Status complete(
        out CICM::DecryptBypass::NegotiatedConduit conduit_ref );
    };

    interface ChannelManager {
      CICM::Status negotiate_decrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::DecryptBypass::Negotiator negotiator_ref );

      CICM::Status negotiate_decrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::ProtocolId protocol,
        in  CICM::AsymKey key_ref,
        out CICM::DecryptBypass::ControllerNegotiator negotiator_ref );

      CICM::Status create_decrypt_bypass_conduit(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::DecryptBypass::Conduit conduit_ref );

      CICM::Status create_decrypt_bypass_controller(
        in  CICM::LocalPort local_port,
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::DecryptBypass::Controller controller_ref );

      CICM::Status get_decrypt_bypass_stream(
        in  CICM::LocalPort local_port,
        out CICM::DecryptBypass::Stream stream_ref );
    };
  };

  module Emit {
    interface GetStream : CICM::ReadStream {
      CICM::Status get(
        in  CICM::UInt32 length,
        out CICM::Buffer buffer );

      CICM::Status get_non_blocking(
        in  CICM::UInt32 length,
        out CICM::Buffer buffer,
        in  CICM::TransId transaction_id );

      CICM::Status get_poll(
        in  CICM::TransId transaction_id,
        out CICM::ReadStream::ReadStatus status );
    };

    interface Controller : CICM::Controller {
      readonly attribute CICM::RemotePort remote_port;
    };

    interface KeyStreamGenController :
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::Emit::Controller {};

    interface PseudoRandomController :
      CICM::SymKeyController,
      CICM::Emit::Controller {};

    interface RandomController : CICM::Emit::Controller {};

    interface KeyStreamGenConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::Emit::GetStream {};

    interface PseudoRandomConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::Emit::GetStream {};

    interface RandomConduit :
      CICM::Conduit,
      CICM::Emit::GetStream {};

    interface ChannelManager {
      CICM::Status create_key_stream_gen_controller(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Emit::KeyStreamGenController controller_ref );

      CICM::Status create_pseudorandom_controller(
        in  CICM::RemotePort remote_port,
        in  CICM::SymKey seed,
        out CICM::Emit::PseudoRandomController controller_ref );

      CICM::Status create_random_controller(
        in  CICM::RemotePort remote_port,
        out CICM::Emit::RandomController controller_ref );

      CICM::Status create_key_stream_gen_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Emit::KeyStreamGenConduit conduit_ref );

      CICM::Status create_pseudorandom_conduit(
        in  CICM::SymKey seed,
        out CICM::Emit::PseudoRandomConduit conduit_ref );

      CICM::Status create_random_conduit(
        out CICM::Emit::RandomConduit conduit_ref );
    };
  };

  module Answer {
    interface PutStream : CICM::Stream {
      CICM::Status put(
        in  CICM::Buffer buffer );
    };

    interface HashConduit :
      CICM::Conduit,
      CICM::Answer::PutStream {

      readonly attribute CICM::HashAlgorithmId algorithm;

      CICM::Status end_get_hash(
        out HashBuffer hash );
    };

    interface MACConduit :
      CICM::AbstractMACConduit,
      CICM::Answer::PutStream {};

    interface MACVerifyConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Answer::PutStream {};

    interface SignConduit :
      CICM::AbstractSignConduit,
      CICM::Answer::PutStream {};

    interface SignHashConduit : CICM::Answer::SignConduit {};

    interface VerifyConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Answer::PutStream {};

    interface VerifyHashConduit : CICM::Answer::VerifyConduit {};

    interface ChannelManager {
      CICM::Status create_hash_conduit(
        in  CICM::HashAlgorithmId algorithm,
        out CICM::Answer::HashConduit conduit_ref );

      CICM::Status create_mac_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymMacAlgorithmId algorithm,
        out CICM::Answer::MACConduit conduit_ref );

      CICM::Status create_mac_verify_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymMacAlgorithmId algorithm,
        out CICM::Answer::MACVerifyConduit conduit_ref );

      CICM::Status create_sign_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::SignConduit conduit_ref );

      CICM::Status create_sign_hash_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::SignHashConduit conduit_ref );

      CICM::Status create_verify_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::VerifyConduit conduit_ref );

      CICM::Status create_verify_hash_conduit(
        in  CICM::AsymKey key_ref,
        in  CICM::AsymSigAlgorithmId algorithm,
        out CICM::Answer::VerifyHashConduit conduit_ref );
    };
  };

  module Coprocessor {
    interface Stream : CICM::Stream {
      CICM::Status get_final_buffer(
        out CICM::Buffer buffer );
    };

    interface EncryptConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::GenVectorController,
      CICM::ResyncController,
      CICM::Coprocessor::Stream {

      CICM::Status encrypt(
        in  CICM::Buffer plaintext,
        out CICM::Buffer ciphertext );
    };

    interface EncryptWithMACConduit :
      CICM::AbstractMACConduit,
      CICM::Coprocessor::EncryptConduit {};

    interface EncryptWithSignConduit :
      CICM::AbstractSignConduit,
      CICM::Coprocessor::EncryptConduit {};

    interface DecryptConduit :
      CICM::Conduit,
      CICM::SymKeyController,
      CICM::SetVectorController,
      CICM::ResyncController,
      CICM::Coprocessor::Stream {

      CICM::Status decrypt(
        in  CICM::Buffer ciphertext,
        out CICM::Buffer plaintext );
    };

    interface DecryptWithMACConduit :
      CICM::AbstractMACVerifyConduit,
      CICM::Coprocessor::DecryptConduit {};

    interface DecryptWithVerifyConduit :
      CICM::AbstractSigVerifyConduit,
      CICM::Coprocessor::DecryptConduit {};

    interface ChannelManager {
      CICM::Status create_coprocessor_encrypt_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Coprocessor::EncryptConduit conduit_ref );

      CICM::Status create_coprocessor_encrypt_with_mac_conduit(
        in  CICM::SymKey mac_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        in  CICM::SymEncrAlgorithmId encrypt_algorithm,
        out CICM::Coprocessor::EncryptWithMACConduit conduit_ref );

      CICM::Status create_coprocessor_encrypt_with_sign_conduit(
        in  CICM::AsymKey sign_key_ref,
        in  CICM::SymKey encrypt_key_ref,
        in  CICM::AsymSigAlgorithmId sign_algorithm,
        in  CICM::SymEncrAlgorithmId encrypt_algorithm,
        out CICM::Coprocessor::EncryptWithSignConduit conduit_ref );

      CICM::Status create_coprocessor_decrypt_conduit(
        in  CICM::SymKey key_ref,
        in  CICM::SymEncrAlgorithmId algorithm,
        out CICM::Coprocessor::DecryptConduit conduit_ref );

      CICM::Status create_coprocessor_decrypt_with_mac_conduit(
        in  CICM::SymKey mac_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::SymMacAlgorithmId mac_algorithm,
        in  CICM::SymEncrAlgorithmId encrypt_algorithm,
        out CICM::Coprocessor::DecryptWithMACConduit conduit_ref );

      CICM::Status create_coprocessor_decrypt_with_verify_conduit(
        in  CICM::AsymKey verify_key_ref,
        in  CICM::SymKey decrypt_key_ref,
        in  CICM::AsymSigAlgorithmId verify_algorithm,
        in  CICM::SymEncrAlgorithmId decrypt_algorithm,
        out CICM::Coprocessor::DecryptWithVerifyConduit conduit_ref );
    };
  };

  interface ChannelManager :
    CICM::Answer::ChannelManager,
    CICM::BypassRead::ChannelManager,
    CICM::BypassWrite::ChannelManager,
    CICM::Coprocessor::ChannelManager,
    CICM::Decrypt::ChannelManager,
    CICM::DecryptBypass::ChannelManager,
    CICM::Duplex::ChannelManager,
    CICM::Emit::ChannelManager,
    CICM::Encrypt::ChannelManager,
    CICM::EncryptBypass::ChannelManager {

    CICM::Status create_controller_group(
      out CICM::ControllerGroup controller_group_ref );
  };
};]]></artwork></figure>
    </section>
  </back>
</rfc>