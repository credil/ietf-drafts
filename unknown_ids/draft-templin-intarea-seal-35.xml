<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict='yes'?>
<?rfc iprnotified='no'?>
<rfc category="std" docName="draft-templin-intarea-seal-35.txt"
     ipr="trust200902">
  <front>
    <title abbrev="SEAL">The Subnetwork Encapsulation and Adaptation Layer
    (SEAL)</title>

    <author fullname="Fred L. Templin" initials="F. L." role="editor"
            surname="Templin">
      <organization>Boeing Research &amp; Technology</organization>

      <address>
        <postal>
          <street>P.O. Box 3707</street>

          <city>Seattle</city>

          <region>WA</region>

          <code>98124</code>

          <country>USA</country>
        </postal>

        <email>fltemplin@acm.org</email>
      </address>
    </author>

    <date day="28" month="October" year="2011" />

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <abstract>
      <t>For the purpose of this document, a subnetwork is defined as a
      virtual topology configured over a connected IP network routing region
      and bounded by encapsulating border nodes. These virtual topologies are
      manifested by tunnels that may span multiple IP and/or sub-IP layer
      forwarding hops, and can introduce failure modes due to packet
      duplication and/or links with diverse Maximum Transmission Units (MTUs).
      This document specifies a Subnetwork Encapsulation and Adaptation Layer
      (SEAL) that accommodates such virtual topologies over diverse underlying
      link technologies.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>As Internet technology and communication has grown and matured, many
      techniques have developed that use virtual topologies (including tunnels
      of one form or another) over an actual network that supports the
      Internet Protocol (IP) <xref target="RFC0791"></xref><xref
      target="RFC2460"></xref>. Those virtual topologies have elements that
      appear as one hop in the virtual topology, but are actually multiple IP
      or sub-IP layer hops. These multiple hops often have quite diverse
      properties that are often not even visible to the endpoints of the
      virtual hop. This introduces failure modes that are not dealt with well
      in current approaches.</t>

      <t>The use of IP encapsulation (also known as "tunneling") has long been
      considered as the means for creating such virtual topologies. However,
      the insertion of an outer IP header reduces the effective path MTU
      visible to the inner network layer. When IPv4 is used, this reduced MTU
      can be accommodated through the use of IPv4 fragmentation, but
      unmitigated in-the-network fragmentation has been found to be harmful
      through operational experience and studies conducted over the course of
      many years <xref target="FRAG"></xref><xref target="FOLK"></xref><xref
      target="RFC4963"></xref>. Additionally, classical path MTU discovery
      <xref target="RFC1191"></xref> has known operational issues that are
      exacerbated by in-the-network tunnels <xref
      target="RFC2923"></xref><xref target="RFC4459"></xref>. The following
      subsections present further details on the motivation and approach for
      addressing these issues.</t>

      <section title="Motivation">
        <t>Before discussing the approach, it is necessary to first understand
        the problems. In both the Internet and private-use networks today,
        IPv4 is ubiquitously deployed as the Layer 3 protocol. The two primary
        functions of IPv4 are to provide for 1) addressing, and 2) a
        fragmentation and reassembly capability used to accommodate links with
        diverse MTUs. While it is well known that the IPv4 address space is
        rapidly becoming depleted, there is a lesser-known but growing
        consensus that other IPv4 protocol limitations have already or may
        soon become problematic.</t>

        <t>First, the IPv4 header Identification field is only 16 bits in
        length, meaning that at most 2^16 unique packets with the same
        (source, destination, protocol)-tuple may be active in the Internet at
        a given time <xref target="I-D.ietf-intarea-ipv4-id-update"></xref>.
        Due to the escalating deployment of high-speed links, however, this
        number may soon become too small by several orders of magnitude for
        high data rate packet sources such as tunnel endpoints <xref
        target="RFC4963"></xref>. Furthermore, there are many well-known
        limitations pertaining to IPv4 fragmentation and reassembly &ndash;
        even to the point that it has been deemed &ldquo;harmful&rdquo; in
        both classic and modern-day studies (see above). In particular, IPv4
        fragmentation raises issues ranging from minor annoyances (e.g.,
        in-the-network router fragmentation <xref target="RFC1981"></xref>) to
        the potential for major integrity issues (e.g., mis-association of the
        fragments of multiple IP packets during reassembly <xref
        target="RFC4963"></xref>).</t>

        <t>As a result of these perceived limitations, a
        fragmentation-avoiding technique for discovering the MTU of the
        forward path from a source to a destination node was devised through
        the deliberations of the Path MTU Discovery Working Group (PMTUDWG)
        during the late 1980&rsquo;s through early 1990&rsquo;s (see Appendix
        D). In this method, the source node provides explicit instructions to
        routers in the path to discard the packet and return an ICMP error
        message if an MTU restriction is encountered. However, this approach
        has several serious shortcomings that lead to an overall
        &ldquo;brittleness&rdquo; <xref target="RFC2923"></xref>.</t>

        <t>In particular, site border routers in the Internet are being
        configured more and more to discard ICMP error messages coming from
        the outside world. This is due in large part to the fact that
        malicious spoofing of error messages in the Internet is trivial since
        there is no way to authenticate the source of the messages <xref
        target="RFC5927"></xref>. Furthermore, when a source node that
        requires ICMP error message feedback when a packet is dropped due to
        an MTU restriction does not receive the messages, a path MTU-related
        black hole occurs. This means that the source will continue to send
        packets that are too large and never receive an indication from the
        network that they are being discarded. This behavior has been
        confirmed through documented studies showing clear evidence of path
        MTU discovery failures in the Internet today <xref
        target="TBIT"></xref><xref target="WAND"></xref><xref
        target="SIGCOMM"></xref>.</t>

        <t>The issues with both IPv4 fragmentation and this
        &ldquo;classical&rdquo; method of path MTU discovery are exacerbated
        further when IP tunneling is used <xref target="RFC4459"></xref>. For
        example, an ingress tunnel endpoint (ITE) may be required to forward
        encapsulated packets into the subnetwork on behalf of hundreds,
        thousands, or even more original sources within the end site that it
        serves. If the ITE allows IPv4 fragmentation on the encapsulated
        packets, persistent fragmentation could lead to undetected data
        corruption due to Identification field wrapping. If the ITE instead
        uses classical IPv4 path MTU discovery, it may be inconvenienced by
        excessive ICMP error messages coming from the subnetwork that may be
        either suspect or contain insufficient information for translation
        into error messages to be returned to the original sources.</t>

        <t>Although recent works have led to the development of a robust
        end-to-end MTU determination scheme <xref target="RFC4821"></xref>,
        they do not excuse tunnels from delivering path MTU discovery feedback
        when packets are lost due to size restrictions. Moreover, in current
        practice existing tunneling protocols mask the MTU issues by selecting
        a "lowest common denominator" MTU that may be much smaller than
        necessary for most paths and difficult to change at a later date.
        Therefore, a new approach to accommodate tunnels over links with
        diverse MTUs is necessary.</t>
      </section>

      <section title="Approach">
        <t>For the purpose of this document, a subnetwork is defined as a
        virtual topology configured over a connected network routing region
        and bounded by encapsulating border nodes. Example connected network
        routing regions include Mobile Ad hoc Networks (MANETs), enterprise
        networks and the global public Internet itself. Subnetwork border
        nodes forward unicast and multicast packets over the virtual topology
        across multiple IP and/or sub-IP layer forwarding hops that may
        introduce packet duplication and/or traverse links with diverse
        Maximum Transmission Units (MTUs).</t>

        <t>This document introduces a Subnetwork Encapsulation and Adaptation
        Layer (SEAL) for tunneling network layer protocols (e.g., IP, OSI,
        etc.) over IP subnetworks that connect Ingress and Egress Tunnel
        Endpoints (ITEs/ETEs) of border nodes. It provides a modular
        specification designed to be tailored to specific associated tunneling
        protocols. A transport-mode of operation is also possible, and
        described in Appendix C.</t>

        <t>SEAL provides a minimal mid-layer encapsulation that accommodates
        links with diverse MTUs and allows routers in the subnetwork to
        perform efficient duplicate packet detection. The encapsulation
        further ensures packet header integrity, data origin authentication
        and anti-replay <xref target="I-D.ietf-savi-framework"></xref><xref
        target="RFC4302"></xref>.</t>

        <t>SEAL treats tunnels that traverse the subnetwork as ordinary links
        that must support network layer services. Moreover, SEAL provides
        dynamic mechanisms to ensure a maximal per-destination path MTU over
        the tunnel. This is in contrast to static approaches which avoid MTU
        issues by selecting a lowest common denominator MTU value that may be
        overly conservative for the vast majority of tunnel paths and
        difficult to change even when larger MTUs become available.</t>

        <t>The following sections provide the SEAL normative specifications,
        while the appendices present non-normative additional
        considerations.</t>
      </section>
    </section>

    <section title="Terminology and Requirements">
      <t>The following terms are defined within the scope of this
      document:</t>

      <t><list style="hanging">
          <t hangText="subnetwork"><vspace />a virtual topology configured
          over a connected network routing region and bounded by encapsulating
          border nodes.</t>

          <t hangText="Ingress Tunnel Endpoint"><vspace />a virtual interface
          over which an encapsulating border node (host or router) sends
          encapsulated packets into the subnetwork.</t>

          <t hangText="Egress Tunnel Endpoint"><vspace />a virtual interface
          over which an encapsulating border node (host or router) receives
          encapsulated packets from the subnetwork.</t>

          <t hangText="inner packet"><vspace />an unencapsulated network layer
          protocol packet (e.g., IPv6 <xref target="RFC2460"></xref>, IPv4
          <xref target="RFC0791"></xref>, OSI/CLNP <xref
          target="RFC1070"></xref>, etc.) before any outer encapsulations are
          added. Internet protocol numbers that identify inner packets are
          found in the IANA Internet Protocol registry <xref
          target="RFC3232"></xref>.</t>

          <t hangText="outer IP packet"><vspace />a packet resulting from
          adding an outer IP header (and possibly other outer headers) to a
          SEAL-encapsulated inner packet.</t>

          <t hangText="packet-in-error"><vspace />the leading portion of an
          invoking data packet encapsulated in the body of an error control
          message (e.g., an ICMPv4 <xref target="RFC0792"></xref> error
          message, an ICMPv6 <xref target="RFC4443"></xref> error message,
          etc.).</t>

          <t hangText="Packet Too Big (PTB)"><vspace />a control plane message
          indicating an MTU restriction (e.g., an ICMPv6 "Packet Too Big"
          message <xref target="RFC4443"></xref>, an ICMPv4 "Fragmentation
          Needed" message <xref target="RFC0792"></xref>, etc.).</t>

          <t hangText="IP"><vspace />used to generically refer to either IP
          protocol version, i.e., IPv4 or IPv6.</t>
        </list></t>

      <t>The following abbreviations correspond to terms used within this
      document and/or elsewhere in common Internetworking nomenclature:</t>

      <t><list>
          <t>DF - the IPv4 header "Don't Fragment" flag <xref
          target="RFC0791"></xref><vspace /></t>

          <t>ETE - Egress Tunnel Endpoint<vspace /></t>

          <t>HLEN - the length of the SEAL header plus outer
          headers<vspace /></t>

          <t>ICV - Integrity Check Vector<vspace /></t>

          <t>ITE - Ingress Tunnel Endpoint<vspace /></t>

          <t>MTU - Maximum Transmission Unit<vspace /></t>

          <t>SCMP - the SEAL Control Message Protocol<vspace /></t>

          <t>SDU - SCMP Destination Unreachable message<vspace /></t>

          <t>SNA - SCMP Neighbor Advertisement message<vspace /></t>

          <t>SNS - SCMP Neighbor Solicitation message<vspace /></t>

          <t>SPP - SCMP Parameter Problem message<vspace /></t>

          <t>SPTB - SCMP Packet Too Big message<vspace /></t>

          <t>SEAL - Subnetwork Encapsulation and Adaptation
          Layer<vspace /></t>

          <t>SEAL_PORT - a transport-layer service port number used for
          SEAL<vspace /></t>

          <t>SEAL_PROTO - an IPv4 protocol number used for SEAL<vspace /></t>

          <t>TE - Tunnel Endpoint (i.e., either ingress or egress)
          <vspace /></t>

          <t>VET - Virtual Enterprise Traversal<vspace /></t>
        </list></t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>. When used in lower case (e.g., must, must not,
      etc.), these words MUST NOT be interpreted as described in <xref
      target="RFC2119"></xref>, but are rather interpreted as they would be in
      common English.</t>
    </section>

    <section title="Applicability Statement">
      <t>SEAL was originally motivated by the specific case of subnetwork
      abstraction for Mobile Ad hoc Networks (MANETs), however the domain of
      applicability also extends to subnetwork abstractions over enterprise
      networks, ISP networks, SOHO networks, the global public Internet
      itself, and any other connected network routing region. SEAL along with
      the Virtual Enterprise Traversal (VET) <xref
      target="I-D.templin-intarea-vet"></xref> tunnel virtual interface
      abstraction are the functional building blocks for the Internet Routing
      Overlay Network (IRON) <xref target="I-D.templin-ironbis"></xref> and
      Routing and Addressing in Networks with Global Enterprise Recursion
      (RANGER) <xref target="RFC5720"></xref><xref target="RFC6139"></xref>
      architectures.</t>

      <t>SEAL provides a network sublayer for encapsulation of an inner
      network layer packet within outer encapsulating headers. SEAL can also
      be used as a sublayer within a transport layer protocol data payload,
      where transport layer encapsulation is typically used for Network
      Address Translator (NAT) traversal as well as operation over subnetworks
      that give preferential treatment to certain "core" Internet protocols
      (e.g., TCP, UDP, etc.). The SEAL header is processed the same as for
      IPv6 extension headers, i.e., it is not part of the outer IP header but
      rather allows for the creation of an arbitrarily extensible chain of
      headers in the same way that IPv6 does.</t>

      <t>To accommodate MTU diversity, the Egress Tunnel Endpoint (ETE) acts
      as a passive observer that simply informs the Ingress Tunnel Endpoint
      (ITE) of any packet size limitations. This allows the ITE to return
      appropriate path MTU discovery feedback even if the network path between
      the ITE and ETE filters ICMP messages.</t>

      <t>SEAL further ensures data origin authentication <xref
      target="I-D.ietf-savi-framework"></xref>, packet header integrity, and
      anti-replay. The SEAL framework resembles a lightweight version of the
      IP Security (IPsec) <xref target="RFC4301"></xref> Authentication Header
      (AH) <xref target="RFC4302"></xref>, however its purpose is to provide
      minimal hop-by-hop authenticating services along a path while leaving
      full data integrity, authentication and confidentiality services as an
      end-to-end consideration.</t>

      <t>SEAL supports both "nested" tunneling and "re-encapsulating"
      tunneling. Nested tunneling occurs when a first tunnel is encapsulated
      within a second tunnel, which may then further be encapsulated within a
      third tunnel, etc. Nested tunneling can be useful, and stands in
      contrast to "recursive" tunneling which is an anomalous condition
      incurred due to misconfiguration or a routing loop. Considerations for
      nested tunneling are discussed in Section 4 of <xref
      target="RFC2473"></xref>.</t>

      <t>Re-encapsulating tunneling occurs when a packet emerges from a first
      ETE, which then acts as an ITE to re-encapsulate and forward the packet
      to a second ETE connected to the same subnetwork. In that case each
      ITE/ETE transition represents a segment of a bridged path between the
      ITE nearest the source and the ETE nearest the destination. Combinations
      of nested and re-encapsulating tunneling are also naturally supported by
      SEAL.</t>
    </section>

    <section title="SEAL Specification">
      <t>The following sections specify the operation of SEAL:</t>

      <section title="VET Interface Model">
        <t>SEAL is an encapsulation sublayer used within VET non-broadcast,
        multiple access (NBMA) tunnel virtual interfaces. Each VET interface
        connects an ITE to one or more ETE "neighbors" via tunneling across an
        underlying subnetwork. The tunnel neighbor relationship between the
        ITE and each ETE may be either unidirectional or bidirectional.</t>

        <t>A unidirectional tunnel neighbor relationship allows the near end
        ITE to send data packets forward to the far end ETE, while the ETE
        only returns control messages when necessary. A bidirectional tunnel
        neighbor relationship is one over which both TEs can exchange both
        data and control messages.</t>

        <t>Implications of the VET unidirectional and bidirectional models are
        discussed in <xref target="I-D.templin-intarea-vet"></xref>.</t>
      </section>

      <section title="SEAL Model of Operation">
        <t>SEAL-enabled ITEs encapsulate each inner packet in a SEAL header,
        any outer header encapsulations, and in some instances a SEAL trailer
        as shown in <xref target="encaps1"></xref>:</t>

        <t><figure anchor="encaps1" title="SEAL Encapsulation">
            <artwork><![CDATA[                             +--------------------+
                             ~   outer IP header  ~
                             +--------------------+
                             ~  other outer hdrs  ~
                             +--------------------+
                             ~    SEAL Header     ~
+--------------------+       +--------------------+
|                    |  -->  |                    |
~        Inner       ~  -->  ~        Inner       ~
~       Packet       ~  -->  ~       Packet       ~
|                    |  -->  |                    |
+--------------------+       +--------------------+
                             |    SEAL Trailer    |
                             +--------------------+
]]></artwork>
          </figure></t>

        <t>The ITE inserts the SEAL header according to the specific tunneling
        protocol. For simple encapsulation of an inner network layer packet
        within an outer IP header (e.g., <xref target="RFC1070"></xref><xref
        target="RFC2003"></xref><xref target="RFC2473"></xref><xref
        target="RFC4213"></xref>, etc.), the ITE inserts the SEAL header
        between the inner packet and outer IP headers as: IP/SEAL/{inner
        packet}.</t>

        <t>For encapsulations over transports such as UDP (e.g., in the same
        manner as for <xref target="RFC4380"></xref>), the ITE inserts the
        SEAL header between the outer transport layer header and the inner
        packet, e.g., as IP/UDP/SEAL/{inner packet}. (Here, the UDP header is
        seen as an "other outer header" as depicted in <xref
        target="encaps1"></xref>.)</t>

        <t>Finally, in some instances the ITE appends a SEAL trailer at the
        end of the SEAL packet. In that case, the trailer is added after the
        final byte of the encapsulated packet, and need not be aligned on an
        even byte boundary.</t>

        <t>The following sections specify the SEAL header format and
        SEAL-related operations of the ITE and ETE.</t>
      </section>

      <section title="SEAL Header Format">
        <t>The SEAL header is formatted as follows:</t>

        <t><figure anchor="minimal" title="SEAL Header Format ">
            <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |VER|C|A|R|F|P|X|     NEXTHDR   |    PREFLEN    | LINK_ID |LEVEL|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             PKT_ID                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              ICV1                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                      PREFIX (when present)                    ~
   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
]]></artwork>
          </figure></t>

        <t>where the header fields are defined as:</t>

        <t><list style="hanging">
            <t hangText="VER (2)"><vspace />a 2-bit version field. This
            document specifies Version 0 of the SEAL protocol, i.e., the VER
            field encodes the value 0.</t>

            <t hangText="C (1)"><vspace />the "Control/Data" bit. Set to 1 by
            the ITE in SEAL Control Message Protocol (SCMP) control messages,
            and set to 0 in ordinary data packets.</t>

            <t hangText="A (1)"><vspace />the "Acknowledgement Requested" bit.
            Set to 1 by the ITE in SEAL data packets for which it wishes to
            receive an explicit acknowledgement from the ETE.</t>

            <t hangText="R (1)"><vspace />the "Redirects Permitted" bit. For
            data packets, set to 1 by the ITE to inform the ETE that the
            source is accepting Redirects (see:<xref
            target="I-D.templin-intarea-vet"> </xref>).</t>

            <t hangText="F (1)"><vspace />the "Fragmentation Needed" bit. Set
            to 1 if the ITE was obliged to perform outer fragmentation before
            sending the packet.</t>

            <t hangText="P (1)"><vspace />the "Prefix Included" bit. Set to 1
            if the header includes a Prefix Field. Used for SCMP messages that
            do not include a packet-in-error (see: <xref
            target="I-D.templin-intarea-vet"></xref>), and for NULL SEAL data
            packets used as probes (see: Section 4.4.6).</t>

            <t hangText="X (1)"><vspace />the "Reserved" bit. Must be set to 0
            for this version of the SEAL specification.</t>

            <t hangText="NEXTHDR (8)">an 8-bit field that encodes the next
            header Internet Protocol number the same as for the IPv4 protocol
            and IPv6 next header fields.</t>

            <t hangText="PREFLEN (8)">an 8-bit field that encodes the length
            of the prefix to be applied to the source address of inner
            packets.</t>

            <t hangText="LINK_ID (5)"><vspace />an 5-bit link identification
            value, set to a unique value by the ITE for each underlying link
            over which it will send encapsulated packets to ETEs. Up to 32
            underlying links are therefore supported.</t>

            <t hangText="LEVEL (3)"><vspace />an 3-bit nesting level; use to
            limit the number of nestings of tunnels-within-tunnels. Set to an
            integer value up to 7 in the initial SEAL encapsulation, and
            decremented by 1 for each successive additional SEAL encapsulation
            nesting level. Up to 8 levels of nesting are therefore
            supported.</t>

            <t hangText="PKT_ID (32)"><vspace />a 32-bit per-packet
            identification field. Set to a monotonically-incrementing 32-bit
            value for each SEAL packet transmitted to this ETE, beginning with
            0.</t>

            <t hangText="ICV1 (32)"><vspace />a 32-bit header integrity check
            value that covers the leading 128 bytes of the packet beginning
            with the SEAL header. The value 128 is chosen so that at least the
            SEAL header as well as the inner packet network and transport
            layer headers are covered by the integrity check.</t>

            <t hangText="PREFIX (variable)"><vspace />a variable-length string
            of bytes; present only when P=1. The length is found by
            determining the equation Len=(Ceiling(PREFLEN / 32) * 4). For
            example, if PREFLEN=63, the Prefix field is 8 bytes in length. The
            Prefix field encodes an inner network layer prefix beginning with
            the most significant bit, and with zero-padding in the least
            significant bits when PREFLEN is not properly divisible by 32.</t>
          </list></t>
      </section>

      <section title="SEAL Trailer Format">
        <t>The SEAL trailer is formatted as follows:</t>

        <t><figure anchor="min2" title="SEAL Trailer Format ">
            <artwork><![CDATA[     0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              ICV2                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure>When present, the trailer includes a single 32-bit field
        formatted as follows:</t>

        <t><list style="hanging">
            <t hangText="ICV22 (32)"><vspace />a 32-bit packet body integrity
            check value. Present only when F=1, and covers the remaining
            length of the encapsulated packet beyond the leading 128 bytes
            (i.e., the remaining portion that was not covered by ICV1). Added
            as a trailing 32 bit field following the final byte of the
            encapsulated SEAL packet. Need not be aligned on an even byte
            boundary.</t>
          </list></t>
      </section>

      <section title="ITE Specification">
        <section title="Tunnel Interface Soft State">
          <t>The ITE maintains a per-ETE integrity check vector (ICV)
          calculation algorithm and a symmetric secret key to verify the
          ICV(s) in received packets. The ITE also maintains a window of
          PKT_ID values for the packets it has recently sent to this ETE.
          Finally, for each underlying link of each ETE, the ITE maintains a
          boolean variable "USE_MIN_MTU" initialized to "FALSE". (The ITE may
          maintain USE_MIN_MTU as a per-ETE instead of a per-link value, but
          in that case a lowest-common-denominator MTU value may be
          chosen.)</t>
        </section>

        <section title="Tunnel Interface MTU">
          <t>The tunnel interface must present a constant MTU value to the
          inner network layer as the size for admission of inner packets into
          the interface. Since VET NBMA tunnel virtual interfaces may support
          a large set of ETEs that accept widely varying maximum packet sizes,
          however, a number of factors should be taken into consideration when
          selecting a tunnel interface MTU.</t>

          <t>Due to the ubiquitous deployment of standard Ethernet and similar
          networking gear, the nominal Internet cell size has become 1500
          bytes; this is the de facto size that end systems have come to
          expect will either be delivered by the network without loss due to
          an MTU restriction on the path or a suitable ICMP Packet Too Big
          (PTB) message returned. When large packets sent by end systems incur
          additional encapsulation at an ITE, however, they may be dropped
          silently within the tunnel since the network may not always deliver
          the necessary PTBs <xref target="RFC2923"></xref>.</t>

          <t>The ITE should therefore set a tunnel interface MTU of at least
          1500 bytes plus extra room to accommodate any additional
          encapsulations that may occur on the path from the original source.
          The ITE can also set smaller MTU values; however, care must be taken
          not to set so small a value that original sources would experience
          an MTU underflow. In particular, IPv6 sources must see a minimum
          path MTU of 1280 bytes, and IPv4 sources should see a minimum path
          MTU of 576 bytes.</t>

          <t>The ITE can alternatively set an indefinite MTU on the tunnel
          interface such that all inner packets are admitted into the
          interface without regard to size. For ITEs that host applications
          that use the tunnel interface directly, this option must be
          carefully coordinated with protocol stack upper layers since some
          upper layer protocols (e.g., TCP) derive their packet sizing
          parameters from the MTU of the outgoing interface and as such may
          select too large an initial size. This is not a problem for upper
          layers that use conservative initial maximum segment size estimates
          and/or when the tunnel interface can reduce the upper layer's
          maximum segment size, e.g., by reducing the size advertised in the
          MSS option of outgoing TCP messages (sometimes known as "MSS
          clamping").</t>

          <t>The inner network layer protocol consults the tunnel interface
          MTU when admitting a packet into the interface. For non-SEAL inner
          IPv4 packets with the IPv4 Don't Fragment (DF) bit set to 0, if the
          packet is larger than the tunnel interface MTU the inner IPv4 layer
          uses IPv4 fragmentation to break the packet into fragments no larger
          than the tunnel interface MTU. The ITE then admits each fragment
          into the interface as an independent packet.</t>

          <t>For all other inner packets, the inner network layer admits the
          packet if it is no larger than the tunnel interface MTU; otherwise,
          it drops the packet and sends a PTB error message to the source with
          the MTU value set to the tunnel interface MTU. The message contains
          as much of the invoking packet as possible without the entire
          message exceeding the network layer minimum MTU (e.g., 576 bytes for
          IPv4, 1280 bytes for IPv6, etc.).</t>

          <t>In light of the above considerations, the ITE SHOULD configure an
          indefinite MTU on tunnel *router* interfaces. The ITE MAY instead
          set a finite MTU on tunnel *host* interfaces.</t>
        </section>

        <section title="Submitting Packets for Encapsulation">
          <t>For each inner packet, if the packet is itself a SEAL packet
          (i.e., one with either SEAL_PROTO in the IP protocol/next-header
          field, or with SEAL_PORT in the transport layer destination port
          field) and the LEVEL field of the SEAL header contains the value 0,
          the ITE discards the inner packet and treats it as an auditable
          indication of excessive nesting.</t>

          <t>Otherwise, the ITE calculates HLEN as the sum of the lengths of
          the SEAL header plus outer transport and network layer headers that
          will be used for encapsulation of the inner packet. The ITE must
          include the length of the uncompressed outer headers when
          calculating HLEN even if the tunnel is using header compression. The
          ITE next sets the variable "EMTU" to the MTU of the underlying link
          minus HLEN. If EMTU is less than 1280, the ITE also sets the boolean
          variable USE_MIN_MTU for this ETE link path to TRUE. The ITE then
          prepares the inner packet for encapsulation according to its
          length.</t>

          <t>For IPv4 inner packets with DF=0 in the IPv4 header, if the
          packet is not the first fragment of a SEAL data packet (i.e., not a
          SEAL packet with Offset=0 in the IPv4 header and with C=0 in the
          SEAL header) the ITE fragments the packet into inner fragments no
          larger than the minimum of EMTU and 512 bytes. The ITE then submits
          each inner fragment for SEAL encapsulation as specified in Section
          4.5.4.</t>

          <t>For all other inner packets, if the packet is no larger than EMTU
          the ITE submits it for SEAL encapsulation; otherwise the ITE
          processes it further according to its size. If the packet is no
          larger than 1280 bytes, the ITE submits it for SEAL encapsulation.
          Otherwise, the ITE sends a PTB message toward the source address of
          the inner packet.</t>

          <t>To send the PTB message, the ITE first checks its forwarding
          tables to discover the previous hop toward the source address of the
          inner packet. If the previous hop is reached via the same tunnel
          interface, the ITE sends an SCMP PTB (SPTB) message to the previous
          hop with the MTU field set to EMTU (see: Section 4.7.1). Otherwise,
          the ITE prepares an ordinary PTB message appropriate to the inner
          protocol version.</t>

          <t>When preparing the PTB message, the ITE sets the MTU field to
          EMTU the same as for an SPTB message. When the inner packet is an
          IPv4 packet that includes the first fragment of a SEAL data packet,
          the ITE first sets DF=1 in the inner header then re-calculates the
          inner header checksum before generating the PTB.</t>

          <t>After sending the (S)PTB message, the ITE discards the inner
          packet.</t>
        </section>

        <section title="SEAL Encapsulation">
          <t>The ITE next encapsulates the inner packet in a SEAL header
          formatted as specified in Section 4.3. The ITE sets NEXTHDR to the
          Internet Protocol number corresponding to the encapsulated inner
          packet. For example, the ITE sets NEXTHDR to the value '4' for
          encapsulated IPv4 packets <xref target="RFC2003"></xref>, the value
          '41' for encapsulated IPv6 packets <xref
          target="RFC2473"></xref><xref target="RFC4213"></xref>, the value
          '80' for encapsulated OSI/CLNP packets <xref
          target="RFC1070"></xref>, etc.</t>

          <t>The ITE then sets R=1 if redirects are permitted (see: <xref
          target="I-D.templin-intarea-vet"></xref>) and sets PREFLEN to the
          length of the prefix to be applied to the inner source address. The
          ITE's claimed PREFLEN is subject to verification by the ETE; hence,
          the ITE MUST set PREFLEN to the exact prefix length that it is
          authorized to use. (Note that if this process is entered via
          re-encapsulation (see: Section 4.6.4), PREFLEN and R are instead
          copied from the SEAL header of the re-encapsulated packet. This
          implies that the PREFLEN and R values are propagated across a
          re-encapsulating chain of ITE/ETEs that must all be authorized to
          represent the prefix.)</t>

          <t>The ITE next sets C=0, P=0 and sets A=1 if an explicit
          acknowledgement is required from the ETE (see: Section 4.5.6). The
          ITE then sets LINK_ID to the value assigned to the underlying link
          and sets PKT_ID to a monotonically-increasing integer value,
          beginning with the value 0 in the first packet transmitted to this
          ETE.</t>

          <t>Next, if the inner packet is not itself a SEAL packet the ITE
          sets LEVEL to an integer value between 0 and 7 as a specification of
          the number of additional layers of nested SEAL encapsulations
          permitted. Otherwise, the ITE sets LEVEL to the value that appears
          in the inner packet's SEAL header minus 1. If the inner packet is no
          larger than 1280 and the variable USE_MIN_MTU for this ETE link path
          is TRUE, the ITE then sets F=1; otherwise, it sets F=0.</t>

          <t>The ITE finally sets ICV1 and ICV2 (when F=1) to 0 and calculates
          the ICVs over the packet beginning with the SEAL header and leading
          portion of the inner packet. The ICVs are calculated using an
          algorithm agreed on by the ITE and ETE. The algorithm uses a
          symmetric secret key so that the ETE can verify that the ICVs were
          generated by the ITE.</t>

          <t>The ITE first calculates the ICV value over the leading 128 bytes
          of the packet beginning with the SEAL header (or up to the end of
          the packet if there are fewer than 128 bytes) then places result in
          the ICV1 field in the header. If F=1, and if the packet includes
          more than 128 bytes beginning with the SEAL header, the ITE next
          calculates the ICV over the remainder of the packet beyond the
          leading 128 bytes and places the result in the ICV2 field in the
          SEAL trailer. The ITE then submits the packet for outer
          encapsulation.</t>
        </section>

        <section title="Outer Encapsulation">
          <t>Following SEAL encapsulation, the ITE next encapsulates the
          packet in the requisite outer headers according to the specific
          encapsulation format (e.g., <xref target="RFC1070"></xref>, <xref
          target="RFC2003"></xref>, <xref target="RFC2473"></xref>, <xref
          target="RFC4213"></xref>, etc.), except that it writes 'SEAL_PROTO'
          in the protocol field of the outer IP header (when simple IP
          encapsulation is used) or writes 'SEAL_PORT' in the outer
          destination transport service port field (e.g., when IP/UDP
          encapsulation is used).</t>

          <t>When UDP encapsulation is used, the ITE sets the UDP header
          fields as specified in Section 5.5.4 of <xref
          target="I-D.templin-intarea-vet"></xref>. The ITE then performs
          outer IP header encapsulation as specified in Section 5.5.5 of <xref
          target="I-D.templin-intarea-vet"></xref>. If this process is entered
          via re-encapsulation (see: Section 4.6.4), the ITE instead follows
          the outer IP/UDP re-encapsulation procedures specified in Section
          5.5.6 of <xref target="I-D.templin-intarea-vet"></xref>.</t>

          <t>When IPv4 is used as the outer encapsulation layer, the ITE sets
          DF=0 in the IPv4 header if the ETE correctly implements IP
          fragmentation (see: Section 4.5.6); otherwise, it sets DF=1.</t>

          <t>When IPv6 is used as the outer encapsulation layer, the "DF" flag
          is absent but implicitly set to 1. The packet therefore will not be
          fragmented within the subnetwork, since IPv6 deprecates
          in-the-network fragmentation.</t>

          <t>Next, if the SEAL header has F=1 the ITE uses IP fragmentation if
          necessary to fragment it into outer IP fragments that are no larger
          than (EMTU + HLEN). During fragmentation, the ITE should fragment
          the packet into fragments of approximately equal length, i.e.,
          instead of causing the first fragment to be approximately
          MTU-sized.</t>

          <t>The ITE then sends each outer packet via the underlying link
          corresponding to LINK_ID.</t>
        </section>

        <section title="Probing Strategy">
          <t>The ITE can perform a qualification exchange over an underlying
          link to ensure that the subnetwork path to the ETE correctly
          delivers IP fragments. This procedure could be employed, e.g., to
          determine whether there are middleboxes on the path that violate the
          <xref target="RFC1812"></xref>, Section 5.2.6 requirement that: "A
          router MUST NOT reassemble any datagram before forwarding it".</t>

          <t>To perform this qualification, the ITE constructs a NULL SEAL
          data packet to be used as a probe. The ITE sets (C=0; A=1; R=0; F=0;
          P=1) in the SEAL header, writes the length of the ITE's claimed
          prefix in the PREFLEN field, and writes the ITE's claimed prefix in
          the PREFIX field. The ITE then sets NEXTHDR to the value '4' for an
          IPv4 prefix, the value '41' for an IPv6 prefix , the value '80' for
          an OSI/CLNP prefix, etc. The ITE can further add padding following
          the SEAL header to a length that would not cause the size of the
          packet to exceed 512 bytes before outer encapsulation. The ITE then
          sets PKT_ID to an appropriate value for this ETE, calculates the ICV
          over the first 128 bytes of the packet beginning with the SEAL
          header, and writes the value in the ICV1 field.</t>

          <t>Next, the ITE encapsulates the packet in the appropriate outer
          headers, splits it into two outer IP fragments, then sends both
          fragments to the ETE over the same underlying link. If the ETE
          returns an SCMP PTB message with a non-zero MTU (see Section
          4.7.1.1), then the subnetwork path correctly delivers IP fragments.
          If the ETE returns an SCMP PTB message with MTU=0, however, then a
          middlebox in the subnetwork is reassembling the fragments before
          they are delivered to the ETE <xref target="RFC1812"></xref>.</t>

          <t>In addition to any control plane probing, all SEAL data packets
          sent from the ITE to the ETE are considered implicit probes. SEAL
          data packets will elicit SPTB messages from the ETE if any outer IP
          fragmentation occurs in the path. SEAL data packets that are too
          large may also be dropped by a router on the path, which will return
          an ICMP PTB message.</t>

          <t>The ITE should also send explicit probes, periodically, to verify
          that the ETE is still reachable. The ITE sets A=1 in the SEAL header
          of a data packet to be used as an explicit probe. The probe will
          elicit an SPTB message with MTU=0 from the ETE as an acknowledgement
          (see Section 4.7.1.1). The ITE can also send an SCMP Neighbor
          Solicitation (SNS) message to elicit an SCMP Neighbor Advertisement
          (SNA) response from the ETE when there are no convenient data
          packets to use as explicit probes (see: <xref
          target="I-D.templin-intarea-vet"></xref>.</t>

          <t>The ITE processes ICMP PTB messages as specified in Section
          4.5.7. The ITE processes SCMP messages as specified in Section
          4.7.2.</t>
        </section>

        <section title="Processing ICMP Messages">
          <t>When the ITE sends SEAL packets, it may receive raw ICMP error
          messages<xref target="RFC0792"></xref><xref target="RFC4443"></xref>
          from either the ETE or from a router within the subnetwork. Each
          ICMP message includes an outer IP header, followed by an ICMP
          header, followed by a portion of the SEAL data packet that generated
          the error (also known as the "packet-in-error") beginning with the
          outer IP header.</t>

          <t>The ITE should process raw ICMPv4 Protocol Unreachable messages
          and ICMPv6 Parameter Problem messages with Code "Unrecognized Next
          Header type encountered" as a hint that the ETE does not implement
          the SEAL protocol. The ITE can also process other raw ICMP messages
          that do not include sufficient information in the packet-in-error as
          a hint that the path to the ETE may be failing. Specific actions
          that the ITE may take in these cases are out of scope.</t>

          <t>For other ICMP messages, the ITE examines the packet-in-error
          beginning with the SEAL header. If the value in the SEAL header ICV1
          field is incorrect and/or the value in the PKT_ID field is not
          within the window of packets the ITE has recently sent to this ETE,
          the ITE discards the message.</t>

          <t>Next, the ITE processes the ICMP message if there is operational
          assurance that it has not been crafted by a malicious middlebox
          (e.g., if the source of the ICMP message is within the same
          administrative domain as the ITE). If the received ICMP message is a
          PTB, and the MTU field encodes a non-zero value, the ITE deducts the
          length of the outer IP headers and SEAL header of the
          packet-in-error from the MTU value. If the resulting MTU value is
          less than 1280, the ITE marks the ETE link path as USE_MIN_MTU and
          discards the ICMP message.</t>

          <t>Otherwise, the ITE transcribes the ICMP message into a message to
          return to the previous hop. If the previous hop toward the inner
          source address is reached via the same tunnel interface the SEAL
          data packet was sent on, the ITE transcribes the ICMP message into
          an SCMP message (see: Section 4.7.1) and forwards it to the previous
          hop. Otherwise, the ITE transcribes the ICMP message into a message
          appropriate for the inner protocol version and forwards it to the
          inner source address.</t>

          <t>To transcribe the message, the ITE extracts the inner packet from
          within the ICMP message packet-in-error field and generates a new
          SCMP/ICMP message corresponding to the type of the received ICMP
          message.</t>
        </section>
      </section>

      <section title="ETE Specification">
        <section title="Tunnel Interface Soft State">
          <t>The ETE maintains a per-ITE ICV calculation algorithm and a
          symmetric secret key to verify the ICVs in the SEAL header and
          trailer. The ETE also maintains a window of PKT_ID values for the
          packets it has recently received from this ITE.</t>
        </section>

        <section title="Reassembly Buffer Requirements">
          <t>The ETE must maintain a minimum IP reassembly buffer size of 1500
          bytes for both IPv4 <xref target="RFC0791"></xref> and IPv6 <xref
          target="RFC2460"></xref>. The ETE must also be capable of partially
          reassembling and delivering at least the leading 1280 byte portion
          of the inner packet even if the completely reassembled packet would
          exceed that size.</t>

          <t>The ETE should maintain conservative IP-layer reassembly cache
          high- and low-water marks. When the size of the reassembly cache
          exceeds this high-water mark, the ETE should actively discard stale
          incomplete reassemblies (e.g., using an Active Queue Management
          (AQM) strategy) until the size falls below the low-water mark. The
          ETE should also actively discard any pending reassemblies that
          clearly have no opportunity for completion, e.g., when a
          considerable number of new fragments have arrived before a fragment
          that completes a pending reassembly arrives.</t>
        </section>

        <section title="IP-Layer Reassembly">
          <t>The ETE processes non-SEAL IP packets as specified in the
          normative references, i.e., it performs any necessary IP reassembly
          then delivers the (reassembled) packet to the appropriate upper
          layer protocol.</t>

          <t>For each SEAL packet received, if the packet did not undergo
          outer IP fragmentation the ETE submits it for decapsulation as
          specified in Section 4.6.4. Otherwise, the ETE gathers the outer IP
          fragments of the SEAL packet until it has received at least the
          first 1280 bytes beyond the SEAL header or up to the end of the
          packet.</t>

          <t>The ETE then examines the SEAL header within this (partially)
          reassembled SEAL packet. If the PKT_ID value is not acceptable for
          this ITE, or if the value in the ICV1 field is incorrect, the ETE
          silently discards the packet. Otherwise, the ETE processes the
          packet further according to the F bit.</t>

          <t>If the SEAL header has F=0, the ETE sends an SPTB message back to
          the ITE (see Section 4.7.1.1) with MTU set to the size of the IP
          first fragment.</t>

          <t>Next, if the inner packet is larger than 1280 bytes the ETE
          silently discards the packet regardless of the F bit setting.</t>

          <t>Finally, if the SEAL header has F=1 and the packet contains more
          than 128 beginning with the SEAL header, the ETE verifies the ICV2
          value over the remainder of the packet and silently discards the
          packet if the value is incorrect.</t>

          <t>If the reassembled SEAL packet has not been discarded, the ETE
          finally submits it for decapsulation.</t>
        </section>

        <section title="Decapsulation and Re-Encapsulation">
          <t>For each SEAL packet submitted for decapsulation, if the packet
          did not undergo the integrity checks specified in Section 4.6.4 the
          ETE examines the PKT_ID and ICV fields. If the PKT_ID is not within
          the window of acceptable values from this ITE, or if an ICV field
          includes an incorrect value, the ETE silently discards the
          packet.</t>

          <t>Next, if the SEAL header has C=1 the ETE processes the packet as
          an SCMP packet as specified in Section 4.7.2. Otherwise the ETE
          process the packet as a SEAL data packet as follows.</t>

          <t>If there is an incorrect value in a SEAL header field, the
          returns an SCMP "Parameter Problem" (SPP) message (see Section
          4.7.1.2) then discards the packet. Otherwise, if the SEAL header has
          A=1 the ETE next sends an SPTB message with MTU=0 back to the ITE
          (see Section 4.7.1.1) but does not discard the packet.</t>

          <t>Thee ETE next discards the outer headers and processes the inner
          packet according to the header type indicated in the SEAL NEXTHDR
          field. If the next hop toward the inner destination address is via a
          different interface than the SEAL packet arrived on, the ETE
          discards the SEAL header and delivers the inner packet either to the
          local host or to the next hop interface if the packet is not
          destined to the local host.</t>

          <t>If the next hop is on the same interface the SEAL packet arrived
          on, however, the ETE submits the packet for SEAL re-encapsulation
          beginning with the specification in Section 4.5.3 above.</t>
        </section>
      </section>

      <section title="The SEAL Control Message Protocol (SCMP)">
        <t>SEAL provides a companion SEAL Control Message Protocol (SCMP) that
        uses the same message types and formats as for the Internet Control
        Message Protocol for IPv6 (ICMPv6) <xref target="RFC4443"></xref>.
        When the TE prepares an SCMP message, it sets the Type and Code fields
        to the same values that would appear in the corresponding ICMPv6
        message, but it does not calculate the SCMP message checksum. The TE
        then formats the Message Body the same as for the corresponding ICMPv6
        message. The TE then encapsulates the SCMP message in the SEAL header
        and trailer as well as the outer headers as shown in <xref
        target="scmpencaps"></xref>:</t>

        <t><figure anchor="scmpencaps" title="SCMP Message Encapsulation">
            <artwork><![CDATA[                                    +--------------------+
                                    ~   outer IP header  ~
                                    +--------------------+
                                    ~  other outer hdrs  ~
                                    +--------------------+
                                    ~    SEAL Header     ~
       +--------------------+       +--------------------+
       ~ SCMP message header~  -->  ~ SCMP message header~
       +--------------------+  -->  +--------------------+
       ~  SCMP message body ~  -->  ~  SCMP message body ~
       +--------------------+  -->  +--------------------+
                                    |    SEAL Trailer    |
                                    +--------------------+

            SCMP Message                  SCMP Packet
        before encapsulation          after encapsulation]]></artwork>
          </figure></t>

        <t>The following sections specify the generation, processing and
        relaying of SCMP messages.</t>

        <section title="Generating SCMP Error Messages">
          <t>ETEs generate SCMP error messages in response to receiving
          certain SEAL data packets using the format shown in <xref
          target="control2"></xref>:</t>

          <t><figure anchor="control2" title="SCMP Error Message Format">
              <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |     Code      |           Reserved            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Type-Specific Data                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           As much of invoking SEAL data packet as             |
   ~    possible (beginning immediately after the SEAL header)     ~
   |        without the SCMP packet exceeding 576 bytes (*)        |

   (*) also known as the "packet-in-error"]]></artwork>
            </figure>The error message includes the 4 byte SCMP message
          header, followed by a 4 byte Type-Specific Data field, followed by
          the leading portion of the invoking SEAL data packet (beginning
          immediately after the SEAL header) as the "packet-in-error". The
          packet-in-error includes as much of the leading portion of the
          invoking SEAL data packet as possible extending to a length that
          would not cause the entire SCMP packet following outer encapsulation
          to exceed 576 bytes.</t>

          <t>When the ETE processes a SEAL data packet for which the ICVs are
          correct but an error must be returned, it prepares an SCMP error
          message as shown in <xref target="control2"></xref>. The ETE sets
          the Type and Code fields in the SCMP header according to the
          appropriate error message type, sets the Reserved field to 0, fills
          out the Type-Specific Data field and includes the
          packet-in-error.</t>

          <t>The ETE next encapsulates the SCMP message in the requisite SEAL
          header, outer headers and SEAL trailer as shown in <xref
          target="scmpencaps"></xref>. During encapsulation, the ETE sets the
          outer destination address/port numbers of the SCMP packet to the
          outer source address/port numbers of the original SEAL data packet
          and sets the outer source address/port numbers to its own outer
          address/port numbers.</t>

          <t>The ETE then sets (C=1; A=0; R=0; F=1; P=0; NEXTHDR=0) in the
          SEAL header, then sets PREFLEN and LEVEL to the same values that
          appeared in the SEAL data packet header. The ETE then writes the
          value 0 in the LINK_ID field and writes a value from within the
          current window for this ITE in the PKT_ID .</t>

          <t>The ETE then calculates and sets the ICV1 and ICV2 fields the
          same as specified for SEAL data packet encapsulation in Section
          4.5.4 (the ETE instead omits the SEAL trailer if the SCMP message
          includes fewer than 128 bytes beyond the SEAL header). Next, the ETE
          encapsulates the SCMP message in the requisite outer encapsulations
          the same as specified for SEAL data packets in Section 4.5.5 (while
          performing outer fragmentation on the packet if necessary) then
          sends the resulting SCMP packet to the ITE.</t>

          <t>The following sections describe additional considerations for
          various SCMP error messages:</t>

          <section title="Generating SCMP Packet Too Big (SPTB) Messages">
            <t>An ETE generates an SCMP "Packet Too Big" (SPTB) message when
            it receives a SEAL data packet that arrived as multiple outer IP
            fragments but for which F=0 in the SEAL header. The ETE prepares
            the SPTB message the same as for the corresponding ICMPv6 PTB
            message, and writes the length of the outer IP first fragment
            (i.e., the fragment with MF=1 and Offset=0) in the MTU field of
            the message.</t>

            <t>The ETE also generates an SPTB message when it accepts a SEAL
            protocol data packet with A=1 in the SEAL header. The ETE prepares
            the SPTB message the same as above, except that it writes the
            value 0 in the MTU field. The message is therefore a control plane
            acknowledgement of a data plane probe, and does not signify a
            packet size restriction.</t>
          </section>

          <section title="Generating Other SCMP Error Messages">
            <t>An ETE generates an SCMP "Destination Unreachable" (SDU)
            message under the same circumstances that an IPv6 system would
            generate an ICMPv6 Destination Unreachable message.</t>

            <t>An ETE generates an SCMP "Parameter Problem" (SPP) message when
            it receives a SEAL packet with an incorrect value in the SEAL
            header. IN THIS CASE ALONE, the ETE prepares the packet-in-error
            beginning with the SEAL header instead of beginning immediately
            after the SEAL header.</t>

            <t>TEs generate other SCMP message types using methods and
            procedures specified in other documents. For example, SCMP message
            types used for tunnel neighbor coordinations are specified in VET
            <xref target="I-D.templin-intarea-vet"></xref>.</t>
          </section>
        </section>

        <section title="Processing SCMP Error Messages">
          <t>For each SCMP error message it receives, the ITE first verifies
          that the outer addresses of the SCMP packet are correct and that the
          PKT_ID is within its window of values for this ETE. The ITE then
          verifies the ICV1 and ICV2 values. If the identifying information
          and/or ICVs are incorrect, the ITE discards the message; otherwise,
          it processes the message as follows:</t>

          <section title="Processing SCMP PTB Messages">
            <t>After an ITE sends a SEAL data packet to an ETE, it may receive
            an SPTB message with a packet-in-error containing the leading
            portion of the inner packet (see: Section 4.7.1.1). If the SPTB
            message has MTU=0, the ITE processes the message as confirmation
            that the ETE has accepted the packet indicated by the
            packet-in-error; the ITE then discards the SPTB message. If the
            SPTB message is the response to a fragmented SNS message used for
            path qualification (see Section 4.5.6), the ITE processes the
            message as a confirmation that the path supports IP fragmentation.
            Otherwise, the ITE processes the message as an indication of a
            packet size limitation.</t>

            <t>If the MTU value in the SPTB message is less than 1280+HLEN,
            and the length of the inner packet within the packet-in-error is
            no larger than 1280, the ITE sets the boolean variable USE_MIN_MTU
            for this ETE link path to TRUE. The ITE then discards the SPTB
            message.</t>

            <t>If the MTU value in the SPTB message is not substantially less
            that 1500, the value is likely to represent the true MTU of the
            restricting link on the path to the ETE; otherwise, a router on
            the path may be generating runt first fragments. In that case, the
            ITE can consult a plateau table (e.g., as described in <xref
            target="RFC1191"></xref>) to rewrite the MTU value to a reduced
            size. For example, if the ITE receives an SPTB message with
            MTU=256 and inner header length 1500, it can rewrite the MTU to
            1400. If the ITE subsequently receives an SPTB message with
            MTU=256 and inner header length 1400, it can rewrite the MTU to
            1300, etc.</t>

            <t>The ITE then checks its forwarding tables to determine the
            previous hop on the reverse path toward the source address of the
            inner packet in the packet-in-error. If the previous hop is
            reached over a different interface than the SPTB message arrived
            on, the ITE transcribes the message into a format appropriate for
            the inner packet (i.e., the same as described for transcribing
            ICMP messages in Section 4.5.7) and sends the resulting
            transcribed message to the original source.</t>

            <t>If the previous hop is reached over the same tunnel interface
            that the SPTB message arrived on, the ITE instead relays the
            message to the previous hop. In order to relay the message, the
            ITE rewrites the SEAL header fields with values corresponding to
            the previous hop. Next, the ITE replaces the SPTB's outer headers
            with headers of the appropriate protocol version and fills in the
            header fields as specified in Sections 5.5.4-5.5.6 of <xref
            target="I-D.templin-intarea-vet"></xref>, where the destination
            address/port correspond to the previous hop and the source
            address/port correspond to the ITE. The ITE then sends the message
            to the previous hop the same as if it were issuing a new SPTB
            message.</t>
          </section>

          <section title="Processing Other SCMP Error Messages">
            <t>An ITE may receive an SDU message with an appropriate code
            under the same circumstances that an IPv6 node would receive an
            ICMPv6 Destination Unreachable message. The ITE either transcribes
            or relays the message toward the source address of the inner
            packet within the packet-in-error the same as specified for SPTB
            messages in Section 4.7.2.1.</t>

            <t>An ITE may receive an SPP message when the ETE receives a SEAL
            packet with an incorrect value in the SEAL header. The ITE should
            examine the SEAL header within the packet-in-error to determine
            whether a different setting should be used in subsequent packets,
            but does not relay the message further.</t>

            <t>TEs process other SCMP message types using methods and
            procedures specified in other documents. For example, SCMP message
            types used for tunnel neighbor coordinations are specified in VET
            <xref target="I-D.templin-intarea-vet"></xref>.</t>
          </section>
        </section>
      </section>
    </section>

    <section title="Link Requirements">
      <t>Subnetwork designers are expected to follow the recommendations in
      Section 2 of <xref target="RFC3819"></xref> when configuring link
      MTUs.</t>
    </section>

    <section title="End System Requirements">
      <t>End systems are encouraged to implement end-to-end MTU assurance
      (e.g., using Packetization Layer Path MTU Discovery per <xref
      target="RFC4821"></xref>) even if the subnetwork is using SEAL.</t>
    </section>

    <section title="Router Requirements">
      <t>Routers within the subnetwork are expected to observe the router
      requirements found in the normative references, including the
      implementation of IP fragmentation and reassembly <xref
      target="RFC1812"></xref><xref target="RFC2460"></xref> as well as the
      generation of ICMP messages <xref target="RFC0792"></xref><xref
      target="RFC4443"></xref>.</t>
    </section>

    <section title="IANA Considerations">
      <t>The IANA is instructed to allocate an IP protocol number for
      'SEAL_PROTO' in the 'protocol-numbers' registry.</t>

      <t>The IANA is instructed to allocate a Well-Known Port number for
      'SEAL_PORT' in the 'port-numbers' registry.</t>

      <t>The IANA is instructed to establish a "SEAL Protocol" registry to
      record SEAL Version values. This registry should be initialized to
      include the initial SEAL Version number, i.e., Version 0.</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>SEAL provides a segment-by-segment data origin authentication and
      anti-replay service across the (potentially) multiple segments of a
      re-encapsulating tunnel. It further provides a segment-by-segment
      integrity check of the headers of encapsulated packets, but does not
      verify the integrity of the rest of the packet beyond the headers unless
      fragmentation is unavoidable. SEAL therefore considers full message
      integrity checking, authentication and confidentiality as end-to-end
      considerations in a manner that is compatible with securing mechanisms
      such as TLS/SSL <xref target="RFC5246"></xref>.</t>

      <t>An amplification/reflection attack is possible when an attacker sends
      IP first fragments with spoofed source addresses to an ETE in an attempt
      to generate a stream of SCMP messages returned to a victim ITE. The SCMP
      message ICVs, PKT_ID, as well as the inner headers of the
      packet-in-error, provide mitigation for the ETE to detect and discard
      SEAL segments with spoofed source addresses.</t>

      <t>The SEAL header is sent in-the-clear the same as for the outer IP and
      other outer headers. In this respect, the threat model is no different
      than for IPv6 extension headers. Unlike IPv6 extension headers, however,
      the SEAL header is protected by an integrity check that also covers the
      inner packet headers.</t>

      <t>Security issues that apply to tunneling in general are discussed in
      <xref target="RFC6169"></xref>.</t>
    </section>

    <section title="Related Work">
      <t>Section 3.1.7 of <xref target="RFC2764"></xref> provides a high-level
      sketch for supporting large tunnel MTUs via a tunnel-level segmentation
      and reassembly capability to avoid IP level fragmentation. This
      capability was implemented in the first edition of SEAL, but is now
      deprecated.</t>

      <t>Section 3 of <xref target="RFC4459"> </xref> describes inner and
      outer fragmentation at the tunnel endpoints as alternatives for
      accommodating the tunnel MTU.</t>

      <t>Section 4 of <xref target="RFC2460"></xref> specifies a method for
      inserting and processing extension headers between the base IPv6 header
      and transport layer protocol data. The SEAL header is inserted and
      processed in exactly the same manner.</t>

      <t>IPsec/AH is <xref target="RFC4301"></xref><xref
      target="RFC4301"></xref> is used for full message integrity verification
      between tunnel endpoints, whereas SEAL only ensures integrity for the
      inner packet headers. The AYIYA proposal <xref
      target="I-D.massar-v6ops-ayiya"></xref> uses similar means for providing
      full message authentication and integrity.</t>

      <t>The concepts of path MTU determination through the report of
      fragmentation and extending the IP Identification field were first
      proposed in deliberations of the TCP-IP mailing list and the Path MTU
      Discovery Working Group (MTUDWG) during the late 1980's and early
      1990's. An historical analysis of the evolution of these concepts, as
      well as the development of the eventual path MTU discovery mechanism for
      IP, appears in Appendix D of this document.</t>
    </section>

    <section anchor="acknowledge" title="Acknowledgments">
      <t>The following individuals are acknowledged for helpful comments and
      suggestions: Jari Arkko, Fred Baker, Iljitsch van Beijnum, Oliver
      Bonaventure, Teco Boot, Bob Braden, Brian Carpenter, Steve Casner, Ian
      Chakeres, Noel Chiappa, Remi Denis-Courmont, Remi Despres, Ralph Droms,
      Aurnaud Ebalard, Gorry Fairhurst, Washam Fan, Dino Farinacci, Joel
      Halpern, Sam Hartman, John Heffner, Thomas Henderson, Bob Hinden,
      Christian Huitema, Eliot Lear, Darrel Lewis, Joe Macker, Matt Mathis,
      Erik Nordmark, Dan Romascanu, Dave Thaler, Joe Touch, Mark Townsley, Ole
      Troan, Margaret Wasserman, Magnus Westerlund, Robin Whittle, James
      Woodyatt, and members of the Boeing Research &amp; Technology NST
      DC&amp;NT group.</t>

      <t>Discussions with colleagues following the publication of RFC5320 have
      provided useful insights that have resulted in significant improvements
      to this, the Second Edition of SEAL.</t>

      <t>Path MTU determination through the report of fragmentation was first
      proposed by Charles Lynn on the TCP-IP mailing list in 1987. Extending
      the IP identification field was first proposed by Steve Deering on the
      MTUDWG mailing list in 1989.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.0791"?>

      <?rfc include="reference.RFC.0792"?>

      <?rfc include="reference.RFC.4443"?>

      <?rfc include="reference.RFC.3971"?>

      <?rfc include="reference.RFC.4861"?>

      <?rfc include="reference.RFC.2119"?>

      <?rfc include="reference.RFC.2460"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1063"?>

      <?rfc include="reference.RFC.1191"?>

      <?rfc include="reference.RFC.1981"?>

      <?rfc include="reference.RFC.2003"?>

      <?rfc include="reference.RFC.2473"?>

      <?rfc include="reference.RFC.2923"?>

      <?rfc include="reference.RFC.3366"?>

      <?rfc include="reference.RFC.3819"?>

      <?rfc include="reference.RFC.4213"?>

      <?rfc include="reference.RFC.1812"?>

      <?rfc include="reference.RFC.4380"?>

      <?rfc include="reference.RFC.4301"?>

      <?rfc include="reference.RFC.4302"?>

      <?rfc include="reference.RFC.5246"?>

      <?rfc include="reference.RFC.4459"?>

      <?rfc include="reference.RFC.4821"?>

      <?rfc include="reference.RFC.4963"?>

      <?rfc include="reference.RFC.2764"?>

      <?rfc include="reference.RFC.2675"?>

      <?rfc include="reference.RFC.5445"?>

      <?rfc include="reference.RFC.1070"?>

      <?rfc include="reference.RFC.3232"?>

      <?rfc include="reference.RFC.4191"?>

      <?rfc include="reference.RFC.4987"?>

      <?rfc include="reference.RFC.5720"?>

      <?rfc include="reference.I-D.templin-intarea-vet"?>

      <?rfc include="reference.I-D.ietf-savi-framework"?>

      <?rfc include="reference.I-D.templin-ironbis"?>

      <?rfc include="reference.RFC.6139"?>

      <?rfc include="reference.RFC.5927"?>

      <?rfc include="reference.RFC.6169"?>

      <?rfc include="reference.I-D.ietf-intarea-ipv4-id-update"?>

      <?rfc include="reference.I-D.templin-aero"?>

      <?rfc include="reference.I-D.massar-v6ops-ayiya"?>

      <reference anchor="FRAG">
        <front>
          <title>Fragmentation Considered Harmful</title>

          <author fullname="Christopher Kent" initials="C" surname="Kent">
            <organization></organization>
          </author>

          <author fullname="Jeffrey Mogul" initials="J" surname="Mogul">
            <organization></organization>
          </author>

          <date month="October" year="1987" />
        </front>
      </reference>

      <reference anchor="FOLK">
        <front>
          <title>Beyond Folklore: Observations on Fragmented Traffic</title>

          <author fullname="Colleen Shannon" initials="C" surname="Shannon">
            <organization></organization>
          </author>

          <author fullname="David Moore" initials="D" surname="Moore">
            <organization></organization>
          </author>

          <author fullname="k claffy" initials="k" surname="claffy">
            <organization></organization>
          </author>

          <date month="December" year="2002" />
        </front>
      </reference>

      <reference anchor="MTUDWG">
        <front>
          <title>IETF MTU Discovery Working Group mailing list,
          gatekeeper.dec.com/pub/DEC/WRL/mogul/mtudwg-log, November 1989 -
          February 1995.</title>

          <author fullname="" initials="" surname="">
            <organization></organization>
          </author>

          <date month="" year="" />
        </front>
      </reference>

      <reference anchor="TCP-IP">
        <front>
          <title>Archive/Hypermail of Early TCP-IP Mail List,
          http://www-mice.cs.ucl.ac.uk/multimedia/misc/tcp_ip/, May 1987 - May
          1990.</title>

          <author fullname="" initials="" surname="">
            <organization></organization>
          </author>

          <date month="" year="" />
        </front>
      </reference>

      <reference anchor="TBIT">
        <front>
          <title>Measuring Interactions Between Transport Protocols and
          Middleboxes</title>

          <author fullname="Alberto Medina" initials="A" surname="Medina">
            <organization></organization>
          </author>

          <author fullname="Mark Allman" initials="M" surname="Allman">
            <organization></organization>
          </author>

          <author fullname="Sally Floyd" initials="S" surname="Floyd">
            <organization></organization>
          </author>

          <date month="October" year="2004" />
        </front>
      </reference>

      <reference anchor="WAND">
        <front>
          <title>Inferring and Debugging Path MTU Discovery Failures</title>

          <author fullname="Matthew Luckie" initials="M" surname="Luckie">
            <organization></organization>
          </author>

          <author fullname="Kenjiro Cho" initials="K" surname="Cho">
            <organization></organization>
          </author>

          <author fullname="Bill Owens" initials="B" surname="Owens">
            <organization></organization>
          </author>

          <date month="October" year="2005" />
        </front>
      </reference>

      <reference anchor="SIGCOMM">
        <front>
          <title>Measuring Path MTU Discovery Behavior</title>

          <author fullname="Matthew Luckie" initials="M" surname="Luckie">
            <organization></organization>
          </author>

          <author fullname="Ben Stasiewicz" initials="B" surname="Stasiewicz">
            <organization></organization>
          </author>

          <date month="November" year="2010" />
        </front>
      </reference>
    </references>

    <section title="Reliability">
      <t>Although a SEAL tunnel may span an arbitrarily-large subnetwork
      expanse, the IP layer sees the tunnel as a simple link that supports the
      IP service model. Links with high bit error rates (BERs) (e.g., IEEE
      802.11) use Automatic Repeat-ReQuest (ARQ) mechanisms <xref
      target="RFC3366"></xref> to increase packet delivery ratios, while links
      with much lower BERs typically omit such mechanisms. Since SEAL tunnels
      may traverse arbitrarily-long paths over links of various types that are
      already either performing or omitting ARQ as appropriate, it would
      therefore often be inefficient to also require the tunnel endpoints to
      also perform ARQ.</t>
    </section>

    <section title="Integrity">
      <t>The SEAL header includes an ICV field that covers the SEAL header and
      at least the inner packet headers. This provides for header integrity
      verification on a segment-by-segment basis for a segmented
      re-encapsulating tunnel path. When fragmentation is needed, the SEAL
      packet also contains a trailer with a secondary ICV that covers the
      remainder of the packet.</t>

      <t>Fragmentation and reassembly schemes must consider packet-splicing
      errors, e.g., when two fragments from the same packet are concatenated
      incorrectly, when a fragment from packet X is reassembled with fragments
      from packet Y, etc. The primary sources of such errors include
      implementation bugs and wrapping IP ID fields.</t>

      <t>In terms of wrapping ID fields, when IPv4 is used as the outer IP
      protocol, the 16-bit IP ID field can wrap with only 64K packets with the
      same (src, dst, protocol)-tuple alive in the system at a given time
      <xref target="RFC4963"></xref> increasing the likelihood of reassembly
      mis-associations</t>

      <t>SEAL avoids reassembly mis-associations through the use of extended
      ICVs, and also discards any reassembled packets larger than 1280
      bytes.</t>
    </section>

    <section title="Transport Mode">
      <t>SEAL can also be used in "transport-mode", e.g., when the inner layer
      comprises upper-layer protocol data rather than an encapsulated IP
      packet. For instance, TCP peers can negotiate the use of SEAL (e.g., by
      inserting a 'SEAL_OPTION' TCP option during connection establishment)
      for the carriage of protocol data encapsulated as IPv4/SEAL/TCP. In this
      sense, the "subnetwork" becomes the entire end-to-end path between the
      TCP peers and may potentially span the entire Internet.</t>

      <t>If both TCPs agree on the use of SEAL, their protocol messages will
      be carried as IPv4/SEAL/TCP and the connection will be serviced by the
      SEAL protocol using TCP (instead of an encapsulating tunnel endpoint) as
      the transport layer protocol. The SEAL protocol for transport mode
      otherwise observes the same specifications as for Section 4.</t>
    </section>

    <section title="Historic Evolution of PMTUD">
      <t>The topic of Path MTU discovery (PMTUD) saw a flurry of discussion
      and numerous proposals in the late 1980's through early 1990. The
      initial problem was posed by Art Berggreen on May 22, 1987 in a message
      to the TCP-IP discussion group <xref target="TCP-IP"></xref>. The
      discussion that followed provided significant reference material for
      [FRAG]. An IETF Path MTU Discovery Working Group <xref
      target="MTUDWG"></xref> was formed in late 1989 with charter to produce
      an RFC. Several variations on a very few basic proposals were
      entertained, including:</t>

      <t><list style="numbers">
          <t>Routers record the PMTUD estimate in ICMP-like path probe
          messages (proposed in [FRAG] and later <xref
          target="RFC1063"></xref>)</t>

          <t>The destination reports any fragmentation that occurs for packets
          received with the "RF" (Report Fragmentation) bit set (Steve
          Deering's 1989 adaptation of Charles Lynn's Nov. 1987 proposal)</t>

          <t>A hybrid combination of 1) and Charles Lynn's Nov. 1987 (straw
          RFC draft by McCloughrie, Fox and Mogul on Jan 12, 1990)</t>

          <t>Combination of the Lynn proposal with TCP (Fred Bohle, Jan 30,
          1990)</t>

          <t>Fragmentation avoidance by setting "IP_DF" flag on all packets
          and retransmitting if ICMPv4 "fragmentation needed" messages occur
          (Geof Cooper's 1987 proposal; later adapted into <xref
          target="RFC1191"></xref> by Mogul and Deering).</t>
        </list></t>

      <t>Option 1) seemed attractive to the group at the time, since it was
      believed that routers would migrate more quickly than hosts. Option 2)
      was a strong contender, but repeated attempts to secure an "RF" bit in
      the IPv4 header from the IESG failed and the proponents became
      discouraged. 3) was abandoned because it was perceived as too
      complicated, and 4) never received any apparent serious consideration.
      Proposal 5) was a late entry into the discussion from Steve Deering on
      Feb. 24th, 1990. The discussion group soon thereafter seemingly lost
      track of all other proposals and adopted 5), which eventually evolved
      into <xref target="RFC1191"></xref> and later <xref
      target="RFC1981"></xref>.</t>

      <t>In retrospect, the "RF" bit postulated in 2) is not needed if a
      "contract" is first established between the peers, as in proposal 4) and
      a message to the MTUDWG mailing list from jrd@PTT.LCS.MIT.EDU on Feb 19.
      1990. These proposals saw little discussion or rebuttal, and were
      dismissed based on the following the assertions:</t>

      <t><list style="symbols">
          <t>routers upgrade their software faster than hosts</t>

          <t>PCs could not reassemble fragmented packets</t>

          <t>Proteon and Wellfleet routers did not reproduce the "RF" bit
          properly in fragmented packets</t>

          <t>Ethernet-FDDI bridges would need to perform fragmentation (i.e.,
          "translucent" not "transparent" bridging)</t>

          <t>the 16-bit IP_ID field could wrap around and disrupt reassembly
          at high packet arrival rates</t>
        </list>The first four assertions, although perhaps valid at the time,
      have been overcome by historical events. The final assertion is
      addressed by the mechanisms specified in SEAL.</t>
    </section>
  </back>
</rfc>
