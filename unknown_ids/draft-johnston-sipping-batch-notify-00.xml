<?xml version="1.0"?><!DOCTYPE rfc SYSTEM "rfc2629.dtd"><?rfc compact="yes"?><?rfc toc="yes"?><rfc ipr="trust200811" docName="draft-johnston-sipping-batch-notify-00" category="info"><front><title abbrev="SIP Batch NOTIFYs">A Batch Notification Extension for the Session Initiation Protocol (SIP)</title><author initials="A." surname="Johnston" fullname="Alan Johnston" role="editor"><organization>Avaya</organization> <address>  <postal>   <city>St. Louis</city><region>MO</region><code>63124</code>   </postal>  <email>alan@sipstation.com</email>  </address></author><author initials="W." surname="Mertka" fullname="Bill Mertka"><organization>RedSky</organization><address><postal><city>Chicago</city><region>IL</region><code>60622</code> </postal><email> bmertka@redskytech.com</email></address></author><date month="March" year="2009"/><workgroup>SIPPING WG</workgroup><abstract> <t>This memo specifies the requirements and mechanism for a SIP events extension where bulk SIP event information can be shared between two peers both with the ability and authority to act as notifiers for this information.   An example application use case is the transition of event state information during a backup/recovery sequence between event state servers.  This document is targeted at addressing server overflow conditions that include the possibilities of the size of individual notification messages getting excessive and the processing of state information by both the subscriber and notifier also becoming excessive.</t></abstract></front><middle><section title="Overview"> <t>  The SIP <xref target="RFC3261" /> event framework <xref target="RFC3265" />  was developed as a way for SIP UAs to request and exchange various information.  It has proven to be very useful, with many event packages being defined.  Some of these event packages result in notifiers which have large databases of information which is provided to subscribers.  For example, the conferencing event package defines a mechanism for a focus to share state information about a conference.  The registration event package allows a registrar to share information about current registrations.  And presence allows a presence server to store and share presence information.</t><t>The SIP event framework includes the ability to combine event state from multiple contacts associated with the same AOR and provide this information in a single subscription, through an event state compositor (ESC).  Besides this mechanism, one subscription generally only provides event state information about one AOR.  The resource list and resource list server (RLS) extensions <xref target="RFC4662" />  were developed to allow a single subscription to a RLS to be used to convey event state about all the AORs in a resource list to be delivered over a single subscription.  The mechanism assumes that resource list of URIs is stored on a RLS and represented by a single resource list URI.  When a UA subscribes to the resource list URI, the RLS initiates "back-end" subscriptions, and subscribes to the individual state of each URI, then combines this information into the single subscription.  The Resource List Meta Information (RLMI) data format <xref target="RFC4662" />  was defined as a way to map the event state from these backend subscriptions to the list subscription.</t><t>The SIP event filter extension <xref target='RFC4660' /> provides a mechanism where a UA can control the content of event notifications.  For example, a filter can be created to control what exact types of events will generate notifications or generate notifications only for certain resources.</t><t>This draft discusses the requirements and mechanism for another SIP events extension where bulk SIP event information can be shared between two peers both with the ability and authority to act as notifiers for this information.  We call requests for this transfer a "batch" subscription, and the notifications generated during this transfer as "batch" notifications where this full state information is transferred for a particular event package in a managed way. An example application use case is the transition of event state information during a backup/recovery sequence between event state servers.  It is desirable that this transfer occurs in a timely way without overloading either server.</t><t>The way in which these batch notifications are generated and delivered needs to be managed carefully, otherwise:</t><list style="numbers"><t>The rate of notifications could become excessive.</t><t>The size of individual notification messages could become excessive.</t><t>The processing of state information by both the subscriber and notifier could become excessive.</t></list><t>The first could be solved by <xref target='I-D.niemi-sipping-event-throttle' /> which provides a throttling mechanism where the subscriber can choose the maximum and average rate of notifications.  The second and third represent the requirements that will be discussed in this draft.  Note that the SIP event filter extension <xref target='RFC4660' /> does not help in this case as it is assumed that all events by all users are of interest for the batch notification.</t></section><section title="Terminology"><t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this   document are to be interpreted as described in BCP 14, RFC 2119 <xref target="RFC2119"/>.</t></section><section title="Requirements"><t>This section discusses the requirements for the batch notification mechanism.</t><t>REQ-1: The mechanism will allow a subscriber to set the maximum number of bodies in a batch notification.</t><t>REQ-2: The mechanism must work together with other throttling mechanisms and filtering mechanisms.</t><t>REQ-3: The mechanism will not be event package specific.</t><t>REQ-4: The mechanism will permit the notifier to indicate to the subscriber that the full event state has been transferred.  </t><t>REQ-5: The mechanism will minimize the processing of the event state data by both the batch subscriber and batch notifier.</t></section><section title="Use Cases"><t>This section discusses a number of use cases for the batch notification mechanism. </t><t>For example, consider a SIP conferencing service.  A key part is the conference notification service <xref target="RFC4575" />   which provides notifications on conference participants and states.  A single conference service may have multiple concurrent SIP conferences, each identified by a conference URI.  However, all or a set of these URIs may resolve to a single server which has access to the state of multiple conferences and provides the notification service.  If this conference service is being taken out of service and replaced by another instance of the conferencing service, the first step is for the new instance to learn the state of all active conferences.  Once this information is known, the process of using SIP call control techniques to move the focus to the new server can begin.  This could be done by individual subscriptions to each of the active conferences on the server.  However, for a large conferencing system, this is inefficient and slow, and would use up resources on both systems.  A batch notification mechanism would allow the efficient transfer of conference information.</t><t>Another example is a registrar which implements the registration information event package <xref target="RFC3680" />.  A new location service or proxy implementing a location service might need to obtain the current registration data for a domain.  While it is possible to do with outside of SIP, there are valid reasons why this might sometimes be done inside SIP such as:</t><t></t><list style="symbols"><t>Reuse of authentication, routing, and NAT and firewall traversal</t><t>Mobility and distribution</t><t>Simplicity</t></list><t>A related example is that of a failure case.  While a server may retain previously provisioned and/or computed information within its internal data store, a planned or unplanned outage creates the need to re-synchronize components within a network infrastructure.  The batch mechanism provides the capability for a server to request the list of current registrations from a registrar or other component within the network architecture.</t><t>Again, the three issues associated with the bulk notification scheme would be critical to the performance of such a system.</t><t>Presence <xref target="RFC3856" /> is another example where this mechanism could be utilized.  Aggregated presence servers within a domain could use an approach such as this to share presence information between them and to synchronize and transfer event state compositor information.</t><t>All these use cases would use a call flow similar to Figure 1 below.  The subscription is created by the SUBSCRIBE in F1, which utilizes the mechanism to set the maximum batch size for notifications, meeting REQ-1.  The notifier has a large volume of state information to send, but it is broken up into three batches (F3, F5, and F7) based on the settings in the SUBSCRIBE.  Future notifications of state occur later in the subscription and may or may not be batch NOTIFYs. </t><figure><artwork><![CDATA[           Subscriber                 Notifier                            |                        |                |  SUBSCRIBE (batch) F1  |                  |----------------------->|                   |     202 Accepted F2    |                |<-----------------------|                |    NOTIFY (batch) F3   |                |<-----------------------|                |        200 OK F4       |                |----------------------->|                |    NOTIFY (batch) F5   |                |<-----------------------|                |        200 OK F6       |                |----------------------->|                |    NOTIFY (batch) F7   |                |<-----------------------|                |        200 OK F8       |                |----------------------->|                |                        |                |                        |                |  NOTIFY Subscription-State:terminated F9                  |<-----------------------|                |       200 OK F10       |                |----------------------->|                |                        |     ]]></artwork></figure><t>Figure 1. Batch Notification Call Flow.</t><t>If the notifier wants to indicate to the subscriber that the full event state has been transferred, the notifier can terminate the subscription with a NOTIFY with Subscription-State: terminated as shown in F9.  This meets REQ-4.</t><t>OPEN ISSUE:  What reason parameter should be used in this case?  Perhaps a new one needs to be defined.</t></section><section title="Possible Mechanism">  <t> This document proposes a possible mechanism for the batch notification.  The proposed mechanism is similar to that used in <xref target='I-D.niemi-sipping-event-throttle' />  where a new Event header field parameter, "batch" is defined and used as in Figure 1. Other filtering and throttling mechanisms could still be used for this subscription, as other header field parameters and bodies could be included in the SUBSCRIBE, meeting REQ-2.  </t><t>This mechanism could be used with resource lists and RLMI body types.  In this case, the batch count would refer to the number of resource bodies, not RLMI bodies.  However, to better meet REQ-5, this mechanism could be used with an alternative body type.  For applications that meet the following requirements, an optimization could be used.  They are:</t><list style="numbers"><t>There is no back-end subscription as is the case with a RLS.</t><t>Each individual body is self-contained and does not need any meta information for processing.</t><t>Only full state event information is included.</t></list><t>For example, any of the three use cases mentioned above meet these requirements.  In all of these cases, there is no back-end subscription.  As such, there is no meta information, such as that included in RLMI bodies.  For these cases, the RLMI body can be omitted and each event state body included as multipart/mixed.  For example, </t><figure><artwork><![CDATA[   NOTIFY sip:app.example.com SIP/2.0   Via: SIP/2.0/UDP server19.example.com;branch=z9hG4bKnasaij   From: sip:joe@example.com;tag=xyzygg   To: sip:app.example.com;tag=123aa9   Call-ID: 9987@app.example.com   CSeq: 1289 NOTIFY   Contact: sip:server19.example.com   Event: reg   Max-Forwards: 70   Content-Type: multipart/mixed;boundary="boundary1"   Content-Length: ...      --boundary1    Content-Type: application/reginfo+xml      <?xml version="1.0"?>   <reginfo xmlns="urn:ietf:params:xml:ns:reginfo"             version="1" state="partial">     <registration aor="sip:joe@example.com" id="a7" state="active">       <contact id="1976" state="active" event="registered"             duration-registered="3210">          <uri>sip:joe@pc34.example.com</uri>       </contact>     </registration>   </reginfo>   --boundary1    Content-Type: application/reginfo+xml      <?xml version="1.0"?>   <reginfo xmlns="urn:ietf:params:xml:ns:reginfo"             version="1" state="partial">     <registration aor="sip:fred@example.com" id="54a7" state="active">       <contact id="7446" state="active" event="registered"             duration-registered="190">          <uri>sip:fred@pc.example.com</uri>       </contact>     </registration>   </reginfo>   --boundary1    Content-Type: application/reginfo+xml      <?xml version="1.0"?>   <reginfo xmlns="urn:ietf:params:xml:ns:reginfo"             version="1" state="partial">     <registration aor="sip:bob@example.com" id="4a6437" state="active">       <contact id="176" state="active" event="registered"             duration-registered="282">          <uri>sip:bob@lab.example.com</uri>       </contact>     </registration>   </reginfo>   --boundary1-- ]]></artwork></figure><t>The considerations <xref target='I-D.ietf-sip-body-handling' /> apply to this usage.</t></section><section title="Appendix - Syntax for batch parameter"><t>Editor's Note: Eventually this text will move to a SIP Working Group document to define the new Event header field parameters.</t><t>This parameter is defined as:</t><t>event-param =/  batch-param</t><t>batch-param = "batch" EQUAL 1*DIGIT</t></section><section title="IANA Considerations"><section title="Registration of Header Field Parameter"><t>   This document defines a new parameter, "batch", for the Event header field defined in RFC 3265.  </t><t>   The following rows shall be added to the "Header Field Parameters and   Parameter Values" section of the SIP parameter registry:</t><figure><artwork><![CDATA[   +------------------+----------------+-------------------+-----------+   | Header Field     | Parameter Name | Predefined Values | Reference |   +------------------+----------------+-------------------+-----------+   | Event            | batch          | No                | [RFCXXXX] |   +------------------+----------------+-------------------+-----------+]]></artwork></figure><t>   Editor's Note: [RFCXXXX] should be replaced with the designation ofthe eventual SIP Working Group document.</t></section></section><section title="Security Considerations"><t>The security considerations for the SIP Events framework <xref target="RFC3265" /> apply to this extension.  As such, both the subscriber and notifier should use normal SIP methods for authentication and message integrity for subscriptions generated for this extension.</t></section><section title="Acknowledgements"><t>Thanks to Brian Schwarz and Dan Romascanu for their contributions.</t></section></middle><back><references title="Informative References"><?rfc include="reference.RFC.3261" ?><?rfc include="reference.RFC.2119" ?><?rfc include="reference.RFC.3265" ?><?rfc include="reference.RFC.4662" ?><?rfc include="reference.RFC.4660" ?><?rfc include="reference.RFC.3680" ?><?rfc include="reference.RFC.4575" ?><?rfc include="reference.RFC.3856" ?><?rfc include="reference.I-D.niemi-sipping-event-throttle" ?><?rfc include="reference.I-D.ietf-sip-body-handling" ?></references></back></rfc>