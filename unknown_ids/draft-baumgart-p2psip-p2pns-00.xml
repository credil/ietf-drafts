<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3261 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY RFC1035 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml">
<!ENTITY RFC3489 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3489.xml">
<!ENTITY RFC3920 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3920.xml">
<!ENTITY RFC4423 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4423.xml">
<!ENTITY I-D.draft-ietf-mmusic-ice SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-mmusic-ice-18.xml">
<!ENTITY I-D.draft-bryan-p2psip-reload SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-bryan-p2psip-reload-01.xml">
<!ENTITY I-D.draft-ietf-p2psip-concepts SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-p2psip-concepts-00.xml">
<!ENTITY I-D.draft-baset-p2psip-p2pp SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-baset-p2psip-p2pp-00.xml">
<!ENTITY I-D.draft-cheshire-dnsext-dns-sd SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-cheshire-dnsext-dns-sd-04.xml">
<!ENTITY I-D.draft-ahrenholz-hiprg-dht SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ahrenholz-hiprg-dht-01.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="no" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="no"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-baumgart-p2psip-p2pns-00" ipr="full3978">
  <!--ns category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="">Peer-to-Peer Name Service (P2PNS)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Ingmar Baumgart" initials="I." surname="Baumgart">
      <organization>Institute of Telematics, Universitaet Karlsruhe
      (TH)</organization>

      <address>
        <postal>
          <street>Zirkel 2</street>

          <!-- Reorder these if your country does things differently -->

          <city>Karlsruhe</city>

          <region></region>

          <code>76128</code>

          <country>Germany</country>
        </postal>

        <phone>+49 721 608 8281</phone>

        <email>baumgart@tm.uka.de</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <date year="2007" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>

    <workgroup>P2PSIP Working Group</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>name service</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>This document describes P2PNS, a secure distributed name service for
      P2PSIP. P2PNS can be used to resolve SIP AoRs to Contact URIs without
      using DNS or central SIP servers. P2PNS provides
      several security mechanisms to efficiently prevent identity theft and to
      ensure the uniqueness of SIP AoRs in a completely decentralized and
      untrusted network without login servers. The proposed proxy architecture
      allows a seamless integration of legacy SIP UAs, avoids modifications to
      the complex SIP protocol stack and facilitates the deployment of P2PSIP
      networks. Because P2PNS provides a generic name service it is not
      limited to P2PSIP but can also be used e.g. to build a distributed DNS
      system.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>An emerging use case for peer-to-peer protocols are decentralized
      VoIP networks. The IETF P2PSIP working group has been formed to develop
      protocols for using the <xref target="RFC3261">Session Initiation
      Protocol (SIP)</xref> in networks without centralized servers. These
      decentralized VoIP networks can e.g. be used as failover for traditional
      server-based SIP networks in emergency cases.</t>

      <t>In traditional SIP networks the main task of a SIP server is to
      resolve an Address of Record (AoR) to the current IP address (Contact
      URI) of a user. This name resolution usually depends on DNS. In this
      paper we present a distributed name service using a DHT to resolve AoRs
      to Contact URIs without relying on DNS and central SIP servers. Apart
      from this decentralized name resolution the call setup is based on the
      standard SIP protocol. The benefit of this approach is that we can
      easily connect legacy SIP phones to our P2PSIP network. This connection
      is accomplished by a SIP proxy located between SIP phone and DHT which
      handles the name resolution.</t>

      <t>Currently there are several other P2PSIP proposals like <xref
      target="I-D.bryan-p2psip-reload">RELOAD</xref> and <xref
      target="I-D.baset-p2psip-p2pp">P2PP</xref> which are similar to our
      P2PNS approach. We therefore focus on two aspects in this document which
      we think have been neglected by similar proposals. The first aspect is
      flexibility: P2PNS is a generic name service and not limited to P2PSIP.
      Other applications for P2PNS are e.g. decentralized <xref
      target="RFC1035">DNS</xref>, decentralized <xref
      target="RFC3920">XMPP</xref> or decentralized <xref
      target="RFC4423">HIP</xref>. In P2PNS there is a clear separation
      between the overlay layer (key-based routing), the data storage layer
      (distributed hash table), the name resolution layer (P2PNS Cache) and
      the protocols, that utilize the name service (like SIP or DNS). In this
      architecture the specification of the key-based routing protocol is independent
      from P2PSIP and KBR protocol implementations can therefore easily be reused
      for other peer-to-peer applications.</t>

      <t>The second aspect is security: We propose several security mechanisms
      to provide a high level of security in a completely decentralized
      network without login severs. In particular P2PNS provides mechanisms to
      guarantee the uniqueness of P2PNames and to prevent identity theft.
      These security mechanisms are based on a cryptographically generated
      nodeID, which is used to authenticate overlay nodes.</t>
    </section>

    <section title="Background">
      <section title="Structured Peer-to-Peer Networks">
        <t>In this section we provide some background on structured
        peer-to-peer networks. A common service which is provided by all
        structured peer-to-peer networks is the <xref
        target="CommonAPI">key-based routing layer (KBR)</xref>. This layer
        provides efficient routing to identifiers called keys from a large
        identifier space. Every participating node in the overlay chooses a
        unique nodeID from the same id space and maintains a routing table
        with nodeIDs and IP addresses of neighbors in the overlay topology.
        Every node is responsible for a particular range in the identifier
        space, usually for all keys close to its nodeID in the id space. The
        KBR layer provides a route() method to efficiently route a message to
        an arbitrary key by successively forwarding the message to overlay
        neighbors which have a nodeID closer to the destination key. For P2PNS
        we propose to use the <xref target="Kademlia">Kademlia</xref> protocol
        as KBR layer, although our findings can also be applied to other KBR
        protocols.</t>

        <t>On top of the KBR we use a distributed hash table (DHT), which is a
        distributed storage service for storing (key, value) data records. The
        DHT layer provides the two methods get(key) and put(key, value). The
        node responsible for storing a data record with a specific key is
        discovered by using the route() method of the underlying KBR
        layer.</t>
      </section>
    </section>

    <section title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>

      <t>Terminology defined in <xref target="RFC3261">RFC 3261</xref> and the
      <xref target="I-D.ietf-p2psip-concepts">Concepts and Terminology for
      Peer-to-Peer SIP</xref> draft is used without definition.</t>

      <t><list style="empty">
          <t>DHT: Distributed hash table as defined in <xref
          target="CommonAPI"></xref>.</t>

          <t>KBR: Key-based routing layer as defined in <xref
          target="CommonAPI"></xref>.</t>

          <t>Node: An instance of an participant in the overlay.</t>

          <t>NodeID: A unique 160 bit identifier used to address nodes in the
          overlay. In <xref target="I-D.ietf-p2psip-concepts">Concepts and
          Terminology for Peer-to-Peer SIP</xref> this is called Peer-ID.</t>

          <t>P2PName: An arbitrary string which can be resolved to a Transport
          Address by using P2PNS.</t>
          
          <t>ServiceName: An well-known name for a service which can be
          resolved to the Transport Address of a node offering this
          service.</t>

          <t>Transport Address: The IP address and port used to address a
          node.</t>

          <t></t>
        </list></t>
    </section>

    <section title="Goals for P2PNS">
      <t>The name service P2PNS should fulfill the following requirements:</t>

      <t><list style="symbols">
          <t>The name service should not be limited to P2PSIP, but also
          support e.g. distributed DNS. Therefore the name service should be
          independent from the SIP protocol.</t>

          <t>The P2PNS architecture should be completely decentralized. In
          particular it should not depend on any central login servers or
          other trustworthy authorities.</t>

          <t>The user should be able to choose an arbitrary P2PName.</t>

          <t>P2PNS should provide mechanisms to guarantee the uniqueness of
          P2PNames and prevent identity theft.</t>

          <t>For P2PSIP applications P2PNS should support unmodified legacy
          SIP UAs and provide gateway functionality between P2PSIP and
          server-based SIP networks.</t>
        </list></t>
    </section>

    <section title="Design Overview">
      <t>In this section we describe our P2PNS architecture and several
      security extensions for the KBR and DHT layer.</t>

      <t></t>

      <section title="P2PNS Architecture">
        <t>The P2PNS architecture comprises a name resolution and caching
        layer (P2PNS Cache) on top of an external overlay which provides KBR
        and DHT services. The KBR service can be provided by any structured
        peer-to-peer protocol which provides a <xref target="CommonAPI">Common
        API</xref> interface and contains the security extensions from <xref
        target="KBRSec"></xref>. Applications like a SIP proxy connect to
        P2PNS by using a XML-RPC interface which provides register() and
        resolve() functions. The P2PNS architecture is shown in the
        following figure.</t>

        <figure>
          <preamble></preamble>

          <artwork align="left"><![CDATA[
+-------------+             +---------------------------------------+
| P2PNS Cache |<----------->| Application (SIP proxy, DNS Resolver) |
+-------------+  register() +---------------------------------------+
  ^         ^    resolve()        
  | put()   |                     
  | get()   |                     
  v         |                     
+-----+     |                     
| DHT |     |             
+-----+     |          
  |         |          
  | join()  |
  | route() |
  | lookup()|
  v         v
+-------------+
|     KBR     |
+-------------+
     ]]></artwork>
        </figure>

        <t></t>
      </section>

      <section title="P2PNS Name Resolution">
        <t>P2PNS offers two alternatives for resolving a P2PName to the
        current transport address:</t>

        <section anchor="twostage" title="Two-stage Name Resolution">
          <t>The preferred alternative is to use a two-stage approach to
          resolve a P2PName to the current transport address. For this purpose
          every peer chooses once a 160 bit nodeID for joining the overlay.
          This nodeID is retained even if the peer changes its IP address or
          leaves the overlay from time to time. The KBR layer allows us to
          efficiently resolve the nodeID to the current IP address of a peer
          by using the lookup() or route() methods. By choosing the nodeID as
          P2PName the name resolution layer could therefore use the KBR
          service to resolve a P2PName without using a DHT.</t>

          <t>Because using the nodeID as P2PName is against the requirement of
          letting the user choose an arbitrary string as P2PName we
          additionally store a mapping from the arbitrary P2PName to the
          corresponding nodeID in the DHT. In this case the name resolution
          layer first queries the DHT for the nodeID of the destination node
          and in a second step resolves this nodeID to the node's current IP
          address. If the user wants to register a transport address different
          from the node's current IP address this mapping is stored locally at
          the destination node. In this case the name resolution process
          involves the lookup of this mapping at the destination node as the
          final step.</t>
        </section>

        <section title="Direct Name Resolution">
          <t>Instead of using the two-stage name resolution approach, it is
          also possible to directly store a P2PName to transport address
          mapping in the DHT. But due to the proposed security mechanisms in
          <xref target="DHTSec"></xref> storing and modifying data records in
          the DHT is very bandwidth consuming, because data records are
          replicated on several nodes. However by using the two-stage approach
          it is not necessary to modify data records, because the P2PName to
          nodeID mapping doesn't change. So an IP address change has an effect
          on the KBR layer only, which can be handled very efficiently.</t>
        </section>

        <section title="P2PNS Cache">
          <t>To reduce communication overhead and lookup latency when
          resolving the same P2PName several times, the static P2PName to
          nodeID mappings are cached locally.</t>

          <t>The nodeID to transport address mapping may also be cached.
          Because this mapping can be outdated, it has to be verified. This is
          done by trying to directly contact the destination node using the
          stored destination transport address. If this verification fails, the
          mapping is refreshed by using the KBR lookup() method.</t>
        </section>
      </section>

      <section title="KBR Design">
        <t>The current P2PNS implementation uses <xref
      target="Kademlia">Kademlia</xref> as KBR protocol,
        although the P2PNS approach is not limited to a specific KBR protocol.
        Kademlia was chosen, because it is simple to implement, is already
        insusceptible to several common attacks and is the only widely
        deployed structured overlay network in the Internet today (i.e.
        BitTorrent, OverNet and eMule). The specification of a KBR protocol is
        out of scope of this document. Instead we propose to use the P2PP
        proposal <xref target="I-D.baset-p2psip-p2pp"></xref> and extend it by
        the following security extensions.</t>

        <section anchor="KBRSec" title="KBR Security">
          <t>The security of the P2PNS architecture largely depends on the
          security of the KBR layer. As shown in <xref
          target="SecureRouting"></xref> KBR protocols have to fulfill three
          requirements to provide a high level of security. On the basis of
          these requirements we decided to use Kademlia as KBR protocol and
          extended it by several security enhancements (<xref
          target="SKademlia">S/Kademlia</xref>). In the following these
          requirements and security enhancements are summarized:</t>

          <t></t>

          <section title="Secure NodeID Assignment">
            <t>Most important it should be hard for an attacker to generate a
            large number of nodeIDs (Sybil attack) or to choose a particular
            nodeID freely (Eclipse attack). In P2PNS every node generates a
            224 bit <xref target="X9.62">ECDSA</xref> public key pair and
            calculates its nodeID by applying a cryptographic hash function
            H(x) on its public key k_pub. The current implementation uses the
            <xref target="FIPS180-2">SHA-1</xref> hash function. To impede the
            generation of a large number of nodeIDs we additionally make use
            of crypto puzzles. A simple crypto puzzle is given below:</t>

            <t><list style="numbers">
                <t>Generate a new public key pair (k_priv, k_pub).</t>

                <t>Calculate H(H(k_pub)) and check, if the first c bit are
                0.</t>

                <t>If the condition in step 2 is not true, repeat step 1.
                Otherwise the crypto puzzle is solved and the nodeID is
                H(k_pub).</t>
              </list>This approach has several benefits compared to the usual
            approach to generate the nodeID by applying a hash function on the
            IP address of the node. First the node may keep the nodeID if the
            IP address changes. Furthermore the public key approach can be
            used in networks with NAT (Network Address Translation), in which
            several nodes share the same public IP address.</t>

            <t>The public key pair (k_priv, k_pub) is used in the following to
            authenticate overlay signaling. For this purpose overlay messages
            are signed with k_priv. In this way the receiving node may use the
            public key k_pub attached to the message to verify the
            authorship.</t>

            <t>To provide a higher level of security the nodeID assignment can
            additionally be restricted by using certificates of an offline
            CA.</t>
          </section>

          <section title="Lookup over Disjoint Paths">
            <t>As second requirement the overlay should provide several
            disjoint and preferably short paths to all destination keys to
            successfully deliver messages in presence of malicious nodes. The
            number of disjoint paths depends particularly on the employed
            overlay topology (e.g. ring, hypercube or de Bruijn graph). The
            Kademlia protocol is based on a hypercube topology and provides
            the bucket size parameter k, which can be used to tune routing
            table redundancy to the required level of security.</t>

            <t>We studied the influence of disjoint paths on lookup success in
            a network with malicious nodes by using the OverSim framework. The
            simulation results <xref target="SKademlia"></xref> for Kademlia
            showed a significant increase in lookup success by using several
            disjoint paths.</t>

            <t>Most overlay protocols can be used with recursive as well as
            iterative routing. In P2PNS iterative routing is used to ensure
            the resulting paths are really disjoint. Furthermore with
            iterative routing the originator of the lookup can constantly
            monitor the lookup progress. Yet iterative routing exhibits the
            disadvantage of roughly doubling the time for a lookup to finish
            in comparison to recursive routing.</t>
          </section>

          <section title="Secure Routing Table Maintenance">
            <t>An important security property of KBR protocols is the
            robustness of the signaling protocol for routing table maintenance
            in the presence of malicious nodes. As long as the nodeID
            selection is limited, Kademlia is very robust against adversarial
            routing table manipulations due to is implicit stabilization by
            incoming lookup requests. Because Kademlia uses a
            least-recently-used replacement strategy for routing table
            updates, new nodes are only added if older nodes fail. Therefore
            Kademlia is not vulnerable to the flooding of bogus routing
            updates once the network is bootstrapped.</t>
          </section>
        </section>
      </section>

      <section title="DHT Design">
        <t>The DHT layer is a distributed storage service for storing (key,
        value) data records. The DHT layer provides the two methods get(key)
        and put(key, value) to the upper layer. The nodes responsible for
        storing a data record with a specific key are discovered by using the
        route() or lookup() method of the underlying KBR layer.</t>

        <section anchor="DHTSec" title="DHT Security">
          <t>The proposed security mechanisms in <xref target="KBRSec"></xref>
          are the basis for providing a secure DHT service. Yet the DHT layer
          has to fulfill additional requirements to secure the stored P2PName
          to nodeID mappings:</t>

          <t><list style="symbols">
              <t>Data records may only be deleted or modified by the owner of
              the record.</t>

              <t>Data records should be replicated on several nodes to inhibit
              manipulation by single malicious nodes.</t>

              <t>The DHT should be secure against insertion DoS attacks.</t>
            </list>In order to prevent the unauthorized modification of data
          records the DHT layer additionally stores the nodeID of the owner
          along with the data. If a node wants to subsequently modify a data
          record, it has to sign the modification request with its private key
          k_priv. The receiver of the request has verify the signature and to
          ensure that H(k_pub) coincides with the nodeID of the data record's
          owner.</t>

          <t>The node, that is responsible for storing a data record is
          determined by means of the key of the record. In this case the key
          is the hash value of the P2PName. In order to prevent users from
          choosing an already existing P2PName, the DHT only stores a single
          data record for a each key. Consequently the user how stores his
          P2PName first is eligible for this name.</t>

          <t>Data records are replicated on several nodes, because a malicious
          node may arbitrarily tamper with locally stored data records. The
          replicas are stored on neighbor nodes close to the key as these
          nodes can be efficiently discovered by a single KBR lookup.</t>

          <t>A peer resolves a P2PName to nodeID mapping by querying all
          replicas in parallel. Thereupon the peer makes a majority decision
          on all received replies to determine the most plausible destination
          nodeID. In order to handle churn every newly joined node first
          requests all data records in his responsibility from his neighbor
          nodes and stores them locally.</t>

          <t>Finally the DHT has to be protected against adversarial flooding
          of insertion requests. This is important because the verification of
          the signature of a STORE message is computational expensive.
          Moreover the storage of unnecessary data records consums valuable
          peer ressources. To compensate for the computational ressources for
          verifying the signature of a STORE message, the requesting node has
          to solve the following crypto puzzle:</t>

          <t>For the key k of the data record determine an appropriate b, so
          that the first c bits of H(k XOR b) are equal to the first c bits of
          the own nodeID. The constant c is used to specify the complexity of
          the puzzle and b is the solution of the puzzle.</t>

          <t>The crypto puzzle makes the insertion of a large number of data
          records harder, but doesn't completely prevent an insertion DoS
          attack. Therefore we additionally limit the allow number of data
          records per owner by using the following approach: To store a new
          data record the owner O sends a GRANT message to all neighbors close
          to his own nodeID after solving the crypto puzzle. These neighbors
          store all keys of the data records that O has already stored in the
          DHT. If the maximum number of allowed data records per owner is
          exceeded the GRANT message is rejected. In a second step the node O
          sends a STORE message with his data record containing the AoR to
          nodeID mapping to all replicating nodes. These nodes use a CHECK
          message to verify if the neighbor nodes of O have authorized the
          storage and finally store the data record locally.</t>

          <t>These proposed security mechanisms make the storage and
          modification of data records rather expensive in terms of
          computational and communication costs. But by using the two-stage
          approach of <xref target="twostage"></xref> the static P2PName to
          nodeID mapping has to be stored only once when new P2PName is
          registered for the first time. If a node later change its IP address
          or temporarily leaves the network, this is efficiently handled by
          the KBR layer without involving complex DHT operations.</t>

          <t></t>
        </section>
      </section>
    </section>

    <section anchor="Service" title="Service Discovery">
      <t>P2PNS also supports service discovery in a similar way to name
      resolution. This can e.g. be used to locate STUN servers or bootstrap
      nodes.</t>

      <t>A node registers a service by calling register() (see <xref
      target="REGISTER"></xref>) with a well-known service name (e.g. "STUN").
      This service registration is stored in the DHT by a put(H(ServiceName),
      nodeID) call similar to storing a P2PName/nodeID mapping. Because the
      same service may be provided by different nodes, a ServiceName/nodeID
      mapping in the DHT is allowed to contain several different nodeIDs.
      Consequently a ServiceName record has no dedicated owner like a P2PName
      record (see <xref target="DHTSec"></xref>). To anyhow inhibit malicious nodes
      from arbitrarily modifying ServiceName records, the only allowed
      modification is to add the own nodeID to a record.</t>

      <t>If the service directory is used to store a large number of nodes for
      a ServiceName, the load in the DHT should be balanced by using multiple
      hash functions <xref target="MultipleHash"></xref>.</t>
    </section>

    <section title="P2PNS Interface">
      <t>P2PNS provides a XML-RPC interface with the following procedures to
      register and resolve P2PNames:</t>

      <section anchor="REGISTER" title="REGISTER">
        <t>The register() procedure is used to register a new P2PName or to
        update the transport address for an existing P2PName. The same
        procedure is also used to register a service (see <xref
        target="Service"></xref>). The register() procedure uses the following
        parameters:</t>

        <t><list style="symbols">
            <t>Name (&lt;base64&gt;): The name to register.</t>

            <t>Transport Address (&lt;base64&gt;): The current IP address and
            port for the given P2PName. If this is empty, the node's current
            IP address and KBR port is used.</t>

            <t>Type (&lt;int&gt;):<list style="symbols">
                <t>0: The name is registered as P2PName.</t>

                <t>1: The name is registered as a service.</t>
              </list></t>

            <t>TTL (&lt;int&gt;): The time-to-live for this mapping in
            seconds.</t>
          </list></t>

        <t>The return value is an &lt;int&gt;:</t>

        <t><list style="symbols">
            <t>0: The registration was successful.</t>

            <t>1: The registration was rejected, because the name is already
            registered by another node.</t>

            <t>2: The registration failed, because the overlay is not
            available.</t>
          </list></t>
      </section>

      <section title="RESOLVE">
        <t>The resolve() procedure is used to resolve a registered P2PName to
        the current corresponding transport address. The same procedure is
        also used for service discovery (see <xref target="Service"></xref>).
        The resolve() procedure uses the following parameters:</t>

        <t><list style="symbols">
            <t>Name (&lt;base64&gt;): The name to resolve.</t>

            <t>Type (&lt;int&gt;):<list style="symbols">
                <t>0: The given name is a P2PName.</t>

                <t>1: The given name is a service.</t>
              </list></t>
          </list></t>

        <t>The return value is an &lt;array&gt;:</t>

        <t><list style="symbols">
            <t>Transport Address (&lt;base64&gt;): The current IP address and
            port for the given name.</t>

            <t>Error code (&lt;int&gt;):<list style="symbols">
                <t>0: The name resolution was successful.</t>

                <t>1: The name resolution failed, because the name is not
                registered.</t>

                <t>2: The name resolution failed, because the overlay is not
                available.</t>
              </list></t>
          </list></t>
      </section>
    </section>

    <section title="P2PNS Usage">
      <t>This section describes how P2PNS can be utilized for different
      application scenarios like P2PSIP or distributed DNS.</t>

      <section anchor="P2PSIP" title="P2PSIP">
        <t>In order to facilitate the use of legacy server-based SIP phones,
        we propose to employ a proxy architecture. In this architecture every
        P2PSIP peer consists of a SIP UA, a local SIP proxy as well as a P2PNS
        implementation. The proxy is used as a location server for resolving
        AoRs to Contact URIs by using the P2PNS services. To facilitate the
        interconnection of P2PSIP and server-based SIP networks we propose to
        use AoRs of the form username@p2pname.org. The username part can be
        freely chosen by the user whereas the domain part p2pname.org is fixed
        and used to identify the P2PSIP network. In order to connect the
        P2PSIP network to the server-based SIP network DNS is used. In this
        case the domain name p2pname.org
        should contain a SRV DNS record pointing to several of the P2PSIP
        proxies which are used to forward SIP INVITEs to the appropriate P2PSIP nodes.
        This can also be used to interconnect multiple P2PSIP networks by
        using different domain parts for each overlay. In a pure P2PSIP
        network DNS is not used at all. The following figure shows the P2PNS
        architecture for P2PSIP:</t>

        <figure>
          <preamble></preamble>

          <artwork align="left"><![CDATA[
+-------------+             +-----------+
| P2PNS Cache |<----------->| SIP proxy |
+-------------+  register() +-----------+
  ^         ^    resolve()        ^
  | put()   |                     |
  | get()   |                     | SIP
  v         |                     |
+-----+     |                     v
| DHT |     |               +-----------+
+-----+     |               |  SIP UA   |
  ^         |               +-----------+
  | join()  |
  | route() |
  | lookup()|
  v         v
+-------------+
|     KBR     |
+-------------+
          ]]></artwork>

          <postamble></postamble>
        </figure>

        <t>The following figure illustrates an example of
        an AoR registration. In the first step the UA at peer Y sends a SIP
        REGISTER message with the AoR U to the local P2PSIP proxy. The proxy
        then connects to the P2PNS XML-RPC interface and calls register(U). If the
        the P2PNS layer is not already connected to the overlay, it joins with
        the nodeID ID_Y. Finally the P2PNS layer stores the AoR to nodeID mapping in the
        DHT.</t>

        <figure>
          <preamble></preamble>

          <artwork align="left"><![CDATA[
..................................................
.                      2.register(U)             .
.       +-------------+            +-----------+ .
.       | P2PNS Cache |<-----------| SIP proxy | .
.       +-------------+            +-----------+ .
.         |         |                    ^       .
. 4.put(  |         |    1.REGISTER(To:U)|       .
. U,ID_Y) |         |       (SIP)        |       .
.         v         |                    |       .
.       +-----+     |                    |       .
.       | DHT |     |3.join(ID_Y)  +-----------+ .
.       +-----+     |              |  SIP UA   | .
.                   v              +-----------+ .
.       +-------------+               User U     .
.       |     KBR     |                          .
.       +-------------+                          .
..................................................
  Peer Y
]]></artwork>

          <postamble></postamble>
        </figure>

        <t>The following figure shows how the user at peer
        X establishes a call to the AoR U. At first the UA sends an INVITE to
        the local P2PSIP proxy. Subsequently the proxy queries P2PNS by a
        resolve(U) call. The P2PNS layer first fetches the corresponding
        nodeID for the AoR U from the DHT (if the mapping is not already
        cached). In the next step the obtained
        nodeID gets resolved to the current IP address of peer Y. Finally the
        INVITE message gets forwarded to the UA of U via the proxy at peer Y.</t>

        <figure>
          <preamble></preamble>

          <artwork align="left"><![CDATA[
............................................
.                2.resolve(U)       5.INVITE(To:U) (SIP)
. +-------------+            +-----------+ .  ..........
. | P2PNS Cache |<-----------| SIP proxy |--->.User U  .
. +-------------+            +-----------+ .  .@ Peer Y.
.   |         |                    ^       .  ..........
.   |3.get(U) |      1.INVITE(To:U)|       .
.   |         |         (SIP)      |       .
.   v         |                    |       .
. +-----+     |4.lookup(ID_X)      |       .
. | DHT |     |              +-----------+ .
. +-----+     |              |  SIP UA   | .
.             v              +-----------+ .
. +-------------+               User V     .
. |     KBR     |                          .
. +-------------+                          .
............................................
  Peer X
]]></artwork>

          <postamble></postamble>
        </figure>
      </section>

      <section title="Distributed DNS">
        <t>Similar to the P2PSIP approach P2PNS can be used to build
        a distributed DNS system by adding P2PNS support to a caching-only name server.
        For distributed DNS a P2PName is a FQDN of the form
        arbitrary_hostname.p2pname.org. For all name resolution requests to
        *.p2pname.org the name server queries P2PNS using a XML-RPC resolve() call.</t>

        <t></t>
      </section>

      <section title="Zeroconf Service Discovery">
        <t>P2PNS could also be used for wide-area service discovery by adding P2PNS
        support to a mDNS/DNS-SD<xref target="I-D.cheshire-dnsext-dns-sd">
        </xref> implementation. This way legacy applications with DNS-SD support
        can use P2PNS for service discovery, if DNS is not available.</t>
      </section>

      <section title="HIP">
        <t>The <xref target="RFC4423">Host Identity Protocol</xref> uses DNS
        to resolve Host Identity Tags (HITs) to IP addresses. Alternatively
        the <xref
        target="I-D.ahrenholz-hiprg-dht"> HIP DHT Interface</xref> draft
        proposes to use OpenDHT for HIT lookups. Similarly P2PNS can be used in two
        ways to resolve a HIT without DNS:</t>

        <t><list style="symbols">
            <t>Register the HIT as P2PName (This is similar to the <xref
            target="I-D.ahrenholz-hiprg-dht">HIP DHT Interface</xref>
            proposal)</t>

            <t>Use the HIT as nodeID. This allows an efficient HIT resolution
            by only using the KBR layer (Only the second stage of the
            two-stage approach described in <xref target="twostage"></xref> is
            needed).</t>
          </list></t>
      </section>

      <section title="Jabber / XMPP">
        <t>A decentralized <xref target="RFC3920">XMPP</xref> network, which
        is independent from DNS can be realized with P2PNS analogous to <xref
        target="P2PSIP"></xref> by adding a P2PNS interface to a XMPP server.
        In this case the Jabber ID (JID) is of the form username@p2pname.org
        with the fixed domain part p2pname.org.</t>
      </section>
    </section>

    <section title="Bootstrapping">
      <t>P2PNS uses a combination of the following bootstrap mechanisms to
      find a bootstrap node:</t>

      <t><list style="symbols">
          <t>Locate local peers by using mDNS as described in the <xref
          target="I-D.garcia-p2psip-dns-sd-bootstrapping">P2PSIP bootstrapping
          using DNS-SD </xref> draft.</t>

          <t>If DNS is available, try to use DNS-SD as described in the <xref
          target="I-D.garcia-p2psip-dns-sd-bootstrapping">P2PSIP bootstrapping
          using DNS-SD</xref> draft.</t>

          <t>Try to connect to a node from a list of stored nodes known from previous
          sessions.</t>

          <t>Probe random IP addresses from a list of given IP address
          ranges (e.g. dial-in networks).</t>
        </list></t>
    </section>

    <section title="NAT Traversal">
      <t>The current implementation uses <xref target="RFC3489">STUN</xref>
      for NAT traversal. Further versions of P2PNS should also support ICE
      <xref target="I-D.ietf-mmusic-ice"></xref> for better NAT traversal.</t>
    </section>

    <section title="Open Issues">
      <t>There are a lot of open issues. Some of these are:</t>

      <t><list style="numbers">
          <t>Which KBR protocols shows the best performance for P2PNS? The
          Broose protocol seems to be a promising alternative to Kademlia.</t>

          <t>Where should the private key k_priv be stored (DHT, P2PNS Cache,
          SIP proxy)?</t>

          <t>Is it necessary to sign all messages or should only "important"
          messages be signed?</t>

          <t>What is the performance (bandwidth consumption/latency) of the
          two-stage approach compared to the direct approach?</t>
        </list></t>
    </section>

    <!-- This PI places the pagebreak correctly (before the section title) in the text output. -->

    <?rfc needLines="8" ?>

    <section anchor="Acknowledgments" title="Acknowledgments">
      <t>This research was supported by the German Federal Ministry of
      Education and Research as part of the ScaleNet project 01BU567. The
      author likes to thank Sebastian Mies for his valuable contributions to
      this work.</t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This document has no actions for IANA.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Using crypto puzzles as defense against Sybil attacks is currently
      the most promising approach in completely decentralized networks.
      However crypto puzzles only make a Sybil attack harder and cannot
      completely prevent it. If the attacker has sufficient computing
      ressources to solve a large number of crypto puzzles particularly small
      networks as well as the bootstrap phase are still vulnerable to attacks.
      In these cases the nodeID assignment should additionally be restricted
      by using certificates of an offline CA.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->

      &RFC2119;

      &RFC3261;
    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

      &RFC1035;

      &RFC3489;

      &RFC3920;

      &RFC4423;

      &I-D.draft-ietf-mmusic-ice;

      &I-D.draft-bryan-p2psip-reload;

      &I-D.draft-ietf-p2psip-concepts;

      &I-D.draft-baset-p2psip-p2pp;

      &I-D.draft-cheshire-dnsext-dns-sd;

      &I-D.draft-ahrenholz-hiprg-dht;

      <reference anchor="I-D.garcia-p2psip-dns-sd-bootstrapping">
        <front>
          <title>P2PSIP bootstrapping using DNS-SD</title>

          <author initials="G." surname="Garcia">
            <organization></organization>
          </author>

          <date month="October" year="2007" />
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-garcia-p2psip-dns-sd-bootstrapping-00" />
      </reference>

      <reference anchor="X9.62">
        <front>
          <title>ANSI X9.62-2005, Public Key Cryptography for the Financial
          Services Industry: The Elliptic Curve Digital Signature Algorithm
          (ECDSA)</title>

          <author>
            <organization>American National Standards Institute</organization>
          </author>

          <date year="" />
        </front>
      </reference>

      <reference anchor="FIPS180-2">
        <front>
          <title>FIPS 180-2, "Secure Hash Standard"</title>

          <author>
            <organization>National Insitute of Standards and
            Technology</organization>
          </author>

          <date year="2002" />
        </front>
      </reference>

      <reference anchor="SKademlia">
        <front>
          <title>S/Kademlia: A Practicable Approach Towards Secure Key-Based
          Routing</title>

          <author initials="I." surname="Baumgart">
            <organization></organization>
          </author>

          <author initials="S." surname="Mies">
            <organization></organization>
          </author>

          <date month="December" year="2007" />
        </front>

        <seriesInfo name="Proceedings of the International Workshop on Peer-to-Peer Networked Virtual Environments 2007 (P2P-NVE 2007), Hsinchu, Taiwan"
                    value="" />
      </reference>

      <reference anchor="SecureRouting">
        <front>
          <title>Secure routing for structured peer-to-peer overlay
          networks</title>

          <author initials="M." surname="Castro">
            <organization></organization>
          </author>

          <author initials="P." surname="Druschel">
            <organization></organization>
          </author>

          <author initials="A." surname="Ganesh">
            <organization></organization>
          </author>

          <author initials="A." surname="Rowstron">
            <organization></organization>
          </author>

          <author initials="D.S." surname="Wallach">
            <organization></organization>
          </author>

          <date year="2002" />
        </front>

        <seriesInfo name="SIGOPS Oper. Syst. Rev, ACM Press" value="" />
      </reference>

      <reference anchor="Kademlia">
        <front>
          <title>Kademlia: A Peer-to-Peer Information System Based on the XOR
          Metric</title>

          <author initials="P." surname="Maymounkov">
            <organization></organization>
          </author>

          <author initials="D." surname="Mazieres">
            <organization></organization>
          </author>

          <date month="March" year="2002" />
        </front>

        <seriesInfo name="Lecture Notes in Computer Science, Peer-to-Peer         Systems: First International Workshop (IPTPS 2002)"
                    value="" />
      </reference>

      <reference anchor="MultipleHash">
        <front>
          <title>Load Balancing with Multiple Hash Functions in Peer-to-Peer
          Networks</title>

          <author initials="Y." surname="Xia">
            <organization></organization>
          </author>

          <author initials="S." surname="Chen">
            <organization></organization>
          </author>

          <author initials="V." surname="Korgaonkar">
            <organization></organization>
          </author>

          <date year="2006" />
        </front>

        <seriesInfo name="Proceedings of the 12th International Conference         on Parallel and Distributed Systems (ICPADS'06)"
                    value="" />
      </reference>

      <reference anchor="CommonAPI">
        <front>
          <title>Towards a Common API for Structured Peer-to-Peer
          Overlays</title>

          <author initials="F." surname="Dabek">
            <organization></organization>
          </author>

          <author initials="B." surname="Zhao">
            <organization></organization>
          </author>

          <author initials="P." surname="Druschel">
            <organization></organization>
          </author>

          <author initials="J." surname="Kubiatowicz">
            <organization></organization>
          </author>

          <author initials="I." surname="Stoica">
            <organization></organization>
          </author>

          <date year="2003" />
        </front>

        <seriesInfo name="Proceedings of the 2nd International Workshop on         Peer-to-Peer Systems (IPTPS '03)"
                    value="" />
      </reference>
    </references>

    <!-- A reference written by by an organization not a person.

      <reference anchor="DOMINATION"
                 target="http://www.example.com/dominator.html">
        <front>
          <title>Ultimate Plan for Taking Over the World</title>

          <author>
            <organization>Mad Dominators, Inc.</organization>
          </author>

          <date year="1984" />
        </front>
      </reference>
      -->

    <!-- Change Log

v00 2007-11-09  IB    Initial version


-->
  </back>
</rfc>