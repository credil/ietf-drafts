<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
     <!ENTITY rfc2119 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
     <!ENTITY rfc2406 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2406.xml'>
     <!ENTITY rfc2407 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2407.xml'>
     <!ENTITY rfc2409 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2409.xml'>
     <!ENTITY rfc2410 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2410.xml'>
     <!ENTITY rfc2412 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2412.xml'>
     <!ENTITY rfc3979 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3979.xml'>
     <!ENTITY rfc4879 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4879.xml'>
     <!ENTITY rfc4301 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml'>
     <!ENTITY rfc4306 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4306.xml'>
     <!ENTITY rfc3264 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml'>
     <!ENTITY rfc3394 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3394.xml'>
     <!ENTITY rfc3548 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3548.xml'>
     <!ENTITY rfc3550 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml'>
     <!ENTITY rfc3610 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3610.xml'>
     <!ENTITY rfc3602 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3602.xml'>
     <!ENTITY rfc3686 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3686.xml'>
     <!ENTITY rfc3830 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3830.xml'>
     <!ENTITY rfc3711 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml'>
     <!ENTITY rfc4563 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4563.xml'>
     <!ENTITY rfc4753 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4753.xml'>
     <!ENTITY rfc4771 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4771.xml'>
     <!ENTITY rfc4568 PUBLIC ''
       'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4568.xml'>
     <!ENTITY I-D.wing-avt-dtls-srtp-key-transport SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.wing-avt-dtls-srtp-key-transport">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

<rfc category="std" 
     docName="draft-mcgrew-fundamental-ecc-00.txt" 
     ipr="trust200902" 
     category="info">

<front>
<title abbrev="Fundamental ECC">
Fundamental Elliptic Curve Cryptography Algorithms
</title>

<author initials="D.A.M." surname="McGrew" fullname="David A. McGrew">
<organization>Cisco Systems</organization>
<address>
<postal>
<street>510 McCarthy Blvd.</street>
<city>Milpitas</city>
<region>CA</region>
<code>95035</code>
<country>US</country>
</postal>
<phone>(408) 525 8651</phone>
<email>mcgrew@cisco.com</email>
<uri>http://www.mindspring.com/~dmcgrew/dam.htm</uri>
</address>
</author>


<date month="July" year="2009" />

<area>Network</area>
<keyword>Elliptic Curve Cryptography</keyword>

<abstract>
<t>
This note describes the fundamental algorithms of Elliptic Curve
Cryptography (ECC) as they are defined in some early references.
These descriptions may be useful to those who want to implement the
fundamental algorithms without using any of the specialized methods
that were developed in following years.  Only elliptic curves based on
fields of character greater than three are in scope.
</t>

</abstract>
</front>
				
<middle>
<section title="Introduction">
<t>
ECC is a public-key technology that offers performance advantages at
higher security levels.  It includes an Elliptic Curve version of
Diffie-Hellman key exchange protocol <xref target="DH1976"/> and an
Elliptic Curve version of the ElGamal Signature Algorithm
<xref target="E1985"/>.  The elliptic curve versions of these
algorithms are referred to as ECDH and ECES, respectively.  The
adoption of ECC has been slower than had been anticipated, perhaps due
to the lack of freely available normative documents and uncertainty
over intellectual property rights.
</t>
<t>
This note contains a description of the fundamental algorithms of ECC
over fields with characteristic greater than three, based directly on
original references.  Its intent is to provide the Internet community
with a normative specification of the basic algorithms that predate
any specialized or optimized algorithms.  
</t>
<t>
The rest of the note is organized as follows.  <xref target="Mod"/>,
<xref target="GROUP"/>, and <xref target="FIELD"/> furnish the
necessary terminology and notation from modular arithmetic, group
theory and the theory of finite fields, respectively.  <xref
target="ECG"/> defines the groups based on elliptic curves over finite
fields of characteristic greater than three.  <xref target="ECDH"/>
and <xref target="ECES"/> present the fundamental ECDH and ECES
algorithms, respectively.  <xref target="AECES"/> presents an
abbreviated form of ECES.  The previous sections contain all of the
normative text (the text that defines the norm for
implementations conforming to this specification), and all of the
following sections are purely informative.  Interoperability is
discussed in <xref target="Interop"/>.  <xref target="IPR"/> reviews
intellectual property issues.  <xref target="SEC"/> summarizes
security considerations.  <xref target="rng"/> describes random number
generation and <xref target="Example"/> provides an example of an
Elliptic Curve group.
</t>
<!--
 <section title="Conventions Used In This Document">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
   </section>
-->
</section>

<section title="Mathematical Background">
<t>
This section reviews mathematical preliminaries and establishes
terminology and notation that is used below.
</t>
<section anchor="Mod" title="Modular Arithmetic">
<t>
This section reviews modular arithmetic.  Two integers x and y are
said to be congruent modulo n if x - y is an integer multiple of n.
</t>
<t>
Two integers x and y are coprime when their greatest common divisor is
1; in this case, there is no third number z such that z divides x and
z divides y.
</t>
<t>
The set Zp = { 0, 1, 2, ..., p-1 } is closed under the operations of
modular addition, modular subtraction, modular multiplication, and
modular inverse.  These operations are as follows.  
<list>
<t>
For each pair of integers a and b in Zp, a + b mod p is equal to
<vspace blankLines="0"/> a + b if a + b < p, and is equal to a + b - p
otherwise.
</t>
<t>
For each pair of integers a and b in Zp, a - b mod p is equal to
<vspace blankLines="0"/> a - b if a + b > p, and is equal to a + b
otherwise.
</t>
<t>
For each pair of integers a and b in Zp, a * b mod p is equal to the remainder
of a * b divided by p.
</t>
<t>
For each integer x in Zp that is coprime with p, the inverse of x modulo p is
denoted as 1 / x mod p, and can be computed using the extended
euclidean algorithm (see Section 4.5.2 of <xref target="K1981v2"/>, for
example).
</t>
</list>
Algorithms for these operations are well known; for instance, see Chapter
4 of <xref target="K1981v2"/>.
</t>
</section>

<section anchor="GROUP" title="Group Operations">
<t>
This section establishes some terminology and notation for
mathematical groups, which is needed later on.  Background references
abound; see <xref target="D1966"/>, for example.
</t>
<t>
A group is a set of elements G and an associated operation that
combines any two elements in G and returns a third element in G.
The operation is denoted as * and its application is denoted
as a * b, for any two elements a and b in G.  Repeated application
of the group operation n times to the element a is denoted as 
a^N, for any element a in G and any positive integer N.   That is,
a^2, = a * a, <vspace /> a^3 = a * a * a, and so on.    
</t>
<t>
The above definition of a group operation uses multiplicative
notation.  Sometimes an alternative called additive notation is used,
in which a * b is denoted as a + b, and a^N is denoted as N * a.  In
multiplicative notation, g^N is called exponentiation, while the
equivalent operation in additive notation is called scalar
multiplication.  In this document, multiplicative notation is used
throughout for consistency.
</t>
<t>
Every group has an special element called the identity element, which
we denote as e.  For each element a in G, e * a = a * e = a.  By 
convention, a^0 is equal to the identity element for any a in G.  
</t>
<t>
A cyclic group of order R is a group that contains the R elements
<vspace blankLines="0"/> g, g^2, g^3, ..., g^R.  The element g is
called the generator of the group.  The element g^R is equal to the
identity element e.  Note that g^X is equal to g^(X modulo R) for any
non-negative integer X.
</t>
<t>
Given the element a of order N, and an integer i between 1 and N-1,
inclusive, the element a^i can be computed by the "square and
multiply" method outlined in Section 2.1
of <xref target="M1983"></xref> (see also Knuth, Vol. 2, Section
4.6.3.), or other methods.
</t>
</section>


<section anchor="FIELD" title="Finite Fields">
<t>
This section establishes terminology and notation for finite fields
with prime characteristic.
</t>
<t>
When p is a prime number, then the set Zp, with the associated
addition, subtraction, multiplication and division operations, is a
finite field with character p.  There is a one-to-one correspondence
between the integers between zero and p-1 and the elements of the
field.  The field is denoted as Fp.
</t>
<t>
Equations involving field elements do not include the "mod p"
operation, but it is understood to be implicit.  For example,
the statement that x, y, and z are in Fp and 
<list>
<t>
  z = x + y 
</t>
</list>
is equivalent to the statement that x, y, and z are in Zp and
<list>
<t>
  z = x + y mod p.
</t>
</list>
</t>
</section>
</section>


<section anchor="ECG" title="Elliptic Curve Groups">
<t>
This note only covers elliptic curves over fields with characteristic
greater than three.  For other fields, the definition of the elliptic
curve group would be different.
</t>
<t>
An elliptic curve over a field F is defined by the curve equation 
<list style="empty">
<t>
y^2 = x^3 + a*x + b,  
</t>
</list>
where x, y, a, and b are elements of the field Fp <xref
target="M1985"/>.  A point on an elliptic curve is a pair (x,y) of
values in Fp that satisfy the curve equation, such that x and y are
both in Fp, or it is a special point (@,@) that represents the identity
element (which is called the "point at infinity").  The order of an
elliptic curve group is the number of distinct points.
</t>
<t>
Two elliptic curve points (x1,y1) and (x2,y2) are equal whenever x1=x2
and y1=y2, or when both points are the point at infinity.
</t>
<t> 
The group operation associated with the elliptic curve group is as
follows <xref target="BC1989"/>.  To an arbitrary pair of points P and
Q specified by their coordinates (x1,y1) and (x2,y2) respectively, the
group operation assigns a third point P*Q with the coordinates
(x3,y3).  These coordinates are computed as follows
<list style="empty">
<t>
  (x3,y3) = (@,@) when P is not equal to Q and x1 is equal to x2.
</t>
<t>
   x3 = ((y2-y1)/(x2-x1))^2 - x1 - x2  and <vspace blankLines="0"/>
   y3 = (x1-x3)*(y2-y1)/(x2-x1) - y1 when P is not equal to Q and <vspace/> 
x1 is not equal to x2.
</t>
<t>
(x3,y3) = (@,@) when P is equal to Q, P is equal to (0,0) and P is an element of the group.
</t>
<t>
x3 = ((3*x1^2 + a)/(2*y1))^2 - 2*x1  and <vspace blankLines="0"/>
y3 = (x1-x3)*(3*x1^2 + a)/(2*y1) - y1 if P is equal to Q.
</t>
</list>
In the above equations, a, x1, x2, x3, y1, y2, and y3 are elements of
the field Fp; thus, computation of x3 and y3 in practice use a "mod p"
operation.
</t>
<t>
The representation of elliptic curve points as a pair of integers in
Zp is known as the affine coordinate representation.  This
representation is suitable as an external data representation for
communicating or storing group elements, though the point at infinity
must be treated as a special case.

</t>
<t>
Some pairs of integers are not valid elliptic curve points.  A valid
pair will satisfy the curve equation, while an invalid pair will not.
</t>

<section title="Homogenous Coordinates">
<t>
An alternative way to implement the group operation is to use
homogeneous coordinates <xref target="K1987"/> (see also <xref
target="KMOV1991"/>).  This method is typically more efficient because
it does not require a modular inverse operation.
</t>
<t>
An elliptic curve point (x,y) is equivalent to a point (X,Y,Z) in
homogeneous coordinates whenever x=X/Z and y=Y/Z.
</t>
<t>
Let P1=(X1,Y1,Z1) and P2=(X2,Y2,Z2) be points on an elliptic curve and
suppose that the points P1, P2 are not equal to (@,@), P1 is not equal
to P2, and P1 is not equal to -P2.  Then the product P3=(X3,Y3,Z3) =
P1 * P2 is given by
<list style="empty">
<t>
X3 = v * (Z2 * (Z1 * u^2 - 2 * X1 * v^2) - v^3),
</t>
<t>
Y3 = z2 * (3 * X1 * u * v^2 - Y1 * v^3 - Z1 * u^3),
</t>
<t>
Z3 = 8 * (Y1)^3 * (Z1)^3,
</t>
</list>
where u = Y2 * Z1 - Y1 * Z2 and v = X2 * Z1 - X1 * Z2.
</t>
<t>
The product P3=(X3,Y3,Z3) = P1 * P1 is given by 
<list style="empty">
<t>
  X3 = 2 * Y1 * Z1 * (w^2 - 8 * X1 * Y1^2 * Z1),
</t>
<t>
  Y3 = 4 * Y1^2 * Z1 * (3 * w * X1 - 2 * Y1^2 * Z1) - w^3,
</t>
<t>
  Z3 = 8 * (Y1 * Z1)^3.
</t>
</list>
</t>
<t>
In the above equations, a, u, v, w, X1, X2, X3, Y1, Y2, Y3, Z1, Z2,
and Z3 are elements of the field Fp; thus, computation of X3, Y3, and
Z3 in practice use a "mod p" operation.
</t>
<t>
When converting from affine coordinates to homogeneous coordinates, 
it is convenient to set Z to 1.   When converting from homogeneous
coordinates to affine coordinates, it is necessary to perform
a modular inverse to find 1/Z mod p.  
</t>
</section>


<section anchor="params" title="Group Parameters">
<t>
An elliptic curve group over a finite field with characteristic
greater than three is completely specified by the following
parameters:
<list>
<t>
The prime number p that indicates the order of the field Fp.
</t>
<t>
The value a used in the curve equation.   
</t>
<t>
The value b used in the curve equation.
</t>
<t>
The generator g of the group.  
</t>
</list>
The order n of the group generated by g.
</t>
<t>
An example of an Elliptic Curve Group is provided in <xref target="Example"/>.
</t>
<t>
Each elliptic curve point is associated with with a particular group,
i.e a particular parameter set.  Two elliptic curve groups are equal
if and only if each of the parameters in the set are equal.  The
elliptic curve group operation is only defined between two points on
the same group.  It is an error to apply the group operation to two
elements that are from different groups, or to apply the group
operation to a pair of coordinates that are not a valid point.
See <xref target="twogroups"/> for further information.
</t>

<section title="Security">
<t>
Security is highly dependent on the choice of these parameters.
This section gives normative guidance on acceptable choices.
See also <xref target="SEC"/> for more information.
</t>
<t>
The order of the group generated by g should be divisible by a large
prime, in order to preclude easy solution of the discrete logarithm
problem <xref target="K1987"/>
</t>
<t>
With some parameter choices, the discrete log problem is significantly
easier to solve.  This includes parameter sets in which b = 0 and p = 3
(mod 4), and parameter sets in which a = 0 and 
<vspace blankLines="0"/>
p = 2 (mod 3)
<xref target="MOV1993"/>.  These parameter choices are inferior for
cryptographic purposes and should not be used.
</t>

</section>
</section>


</section>


<section anchor="ECDH" title="Elliptic Curve Diffie-Hellman (ECDH)">
<t>
The Diffie-Hellman (DH) key exchange protocol <xref target="DH1976"/>
allows two parties communicating over an insecure channel to agree on
a secret key.  It was originally defined in terms of operations in the
multiplicative group of a field with a large prime characteristic.
Massey <xref target="M1983"/> observed that it can be easily
generalized so that it is defined in terms of an arbitrary
mathematical group.  Miller <xref target="M1985"/> and Koblitz <xref
target="K1987"/> analyzed the DH protocol over an elliptic curve
group.  We describe DH following the former reference.
</t>
<t>
Let G be a group, and g be a generator for that group, and let t
denote the order of G.  The DH protocol runs as follows.  Party A
chooses an exponent j between 1 and t-1 uniformly at random, computes
g^j and sends that element to B.  Party B chooses an exponent k
between 1 and t-1 uniformly at random, computes g^k and sends that
element to A.  Each party can compute g^(j*k); party A computes
(g^k)^j, and party B computes (g^j)^k.
</t>
<t>
See <xref target="rng"/> regarding generation of random numbers.
</t>

<section title="Data Types">
<t>
An ECDH private key a is an integer in Zt.  
</t>
<t>
The corresponding ECDH public key Y is group element, where Y = g^a.
Each public key is associated with a particular group, i.e. a
particular parameter set as per <xref target="params"/>.  
</t>
<t> 
The shared secret computed by both parties is a group element.
</t>
<t>
Each run of the ECDH protocol is associated with a particular group,
and both of the public keys and the shared secret are elements of that
group.
</t>
</section>
<!--
<section title="Operations">
<t>
The ECDH protocol can be described as two distinct steps:
<list>
<t>
Key Generation
</t>
<t>
Secret Generation
</t>
</list>
</t>
</section>
-->


<section anchor="REP" title="Compact Representation">
<t>
As described in the final paragraph of <xref target="M1985"/>, the
x-coordinate of the shared secret value g^(j*k) is a suitable
representative for the entire point whenever exponentiation is used as
a one-way function.  In the ECDH key exchange protocol, after the element
g^(j*k) has been computed, the x-coordinate of that value can be used
as the shared secret.  We call this compact output.
</t>
<t>
Following <xref target="M1985"/> again, when compact output is used in
ECDH, only the x-coordinate of an elliptic curve point needs to be
transmitted, instead of both coordinates as in the typical affine
coordinate representation.  We call this the compact representation.
</t>
<t>
ECDH can be used with or without compact output.  Both parties in a
particular run of the ECDH protocol must use the same method.  ECDH
can be used with or without compact representation.  If compact
representation is used in a particular run of the ECDH protocol, then
compact output must be used as well.
</t>

</section>







</section>


<section anchor="ECES" title="Elliptic Curve ElGamal Signatures (ECES)">
<t>
The ElGamal signature algorithm was introduced in 1984
<xref target="E1984a"/> <xref target="E1984b"/>
<xref target="E1985"/>.  It is based on the discrete logarithm problem
in the multiplicative group of the integers modulo a large prime
number.  It is straightforward to extended it to use an elliptic curve
group.  In this section we recall a well-specified elliptic curve
version of the ElGamal Signature Algorithm, as described in
<xref target="A1992"/> and <xref target="MV1993"/>.
This signature method is called Elliptic Curve ElGamal Signatures (ECES).
</t>
<t>
The algorithm uses an elliptic curve group, as described in <xref
target="params"/>.  We denote the generator as alpha, and the order of
the generator as n.  We follow <xref target="MV1993"/> in describing
the algorithms in terms of mathematical groups.
</t>
<t>
ECES uses a collision-resistant hash function, so that it can
sign messages of arbitrary length.  We denote the hash function as
h().  Its input is a bit string of arbitrary length, and its output is
an integer between zero and n-1, inclusive.
</t>
<t>
ECES uses a function g() from the set of group elements to the set of
integers Zn.  This function returns the x-coordinate of the affine
coordinate representation of the elliptic curve point.
</t>
<section anchor="kpair" title="Keypair Generation">
<t>
The private key a is an integer between 0 and n - 1, inclusive,
generated uniformly at random.  The public key is the group element <vspace />
Q = alpha^a.  
</t>
</section>
<section title="Signature Creation">
<t>
To sign message m, using the private key a:
<list style="numbers">
  <t>
    First, choose an integer k uniformly at random from the set of all
    integers k in Zn that are coprime to n.  (If n is a prime, then
    choose an integer uniformly at random between 1 and n-1.)  (See
    <xref target="rng"/> regarding random integers.)
  </t>
  <t>
    Next, compute the group element r = alpha^k.
  </t>
  <t>
    Finally, compute the integer s as
  <list style="empty">
    <t> s = (h(m) + a * g(r)) / k (mod n). </t>
  </list>
  </t>
  <t>
    If s is equal to zero, then the signature creation 
    must be repeated, starting at Step 1 and using
    a newly chosen k value.
  </t>
</list>
The signature for message m is the ordered pair (r, s).  Note that the
first component is a group element, and the second is a non-negative
integer.
</t>
</section>

<section title="Signature Verification">
<t>
To verify the message m and the signature (r,s) using
the public key Q:
<list>
  <t>
    Compute the group element r^s * Q^(-g(r)).
  </t>
  <t>
    Compute the group element alpha^h(m).
  </t>
  <t>
  Verify that the two elements previously computed are the same.  If
  they are identical, then the signature and message pass the
  verification; otherwise, they fail.
  </t>
</list>
</t>
</section>

<section anchor="hash" title="Hash Functions">
<t>
Let H() denote a hash function whose output is a fixed-length bit
string.  To use H in ECES, we define the mapping between that output
and the integers between zero and n-1; this realizes the function h()
described above.   Given a bit string m, the function h(m) is computed
as follows:
<list style="numbers">
<t>
H(m) is evaluated; the result is a fixed-length bit string.
</t>
<t>
Convert the resulting bit string to an integer i by treating its
leftmost (initial) bit as the most significant bit of i, and treating
its rightmost (final) bit as the least significant bit of i.
</t>
<t>
After conversion, reduce i modulo n, where n is the group order.
</t>
</list>
</t>
</section>

<section title="Rationale">
<t>
This subsection is not normative and is provided only as background information.
</t>
<t>
The signature verification will pass whenever the signature is
properly generated, because
<list style="empty">
<t>
r^s * Q^(-g(r)) = alpha^(k*s - a*g(r)) = alpha^h(m).
</t>
</list>
</t>
<t>
The reason that the random variable k must be coprime with n is so
that 1/k mod n is defined.
</t>
<t>
A valid signature with s=0 leaks the secret key, since in that case 
a = h(m) / g(r) mod n.  We adopt Rivest's suggestion to avoid
this problem <xref target="R1992"/>.
</t>
<t>
As described in the final paragraph of <xref target="M1985"/>, for it
is suitable to use the x-coordinate of a particular elliptic curve
point as a representative for that point.  This is what the function
g() does.
</t>
</section>

</section>






<section anchor="AECES" title="Abbreviated ECES Signatures (AECES)">
<t>
The ECES system is secure and efficient, but has signatures that are
slightly larger than they need to be.  Koyama and Tsuruoka described a
signature system based on Elliptic Curve ElGamal, but with shorter
signatures <xref target="KT1994"/>.  Their idea is to include only the
x-coordinate of the EC point in the signature, instead of both
coordinates.  Menezes, Qu, and Vanstone independently developed the
same idea, which was the basis for the "Elliptic Curve Signature
Scheme with Appendix (ECSSA)" submission to the IEEE 1363 working
group <xref target="MQV1994"/>.
</t>
<t>
In this section we describe an Elliptic Curve Signature Scheme that
hash a single elliptic curve coordinate in the signature instead of
both coordinates.  It is based on ECSSA, but with an inversion
operation moved from the signature operation to the verification
operation, so that the signing operation is more compatible with ECES.
(See <xref target="AMV1990"/> and <xref target="A1992"/> for a
discussion of these alternatives; the security of the methods is
equivalent.)  We refer to this scheme as Abbreviated ECES, or AECES.
</t>
<section title="Keypair Generation">
<t>
Keypairs are the same as for ECES and are as described in <xref target="kpair"/>.
</t>
</section>
<section title="Signature Creation">
<t>
In this section we describe how to compute the signature for a message m
using the private key a.  
</t>
<t>
Signature creation is as for ECES, with the following additional step:
<list style="numbers">
  <t>
    Let the integer s1 be equal to the x-coordinate of r.
  </t>
</list>
The signature is the ordered pair (s1, s).    Both signature components
are non-negative integers.
</t>
</section>
<section title="Signature Verification">
<t>
Given the message m, the public key Q, and the signature (s1,s) verification is as follows:
<list style="numbers">
  <t>
    Compute the inverse of s modulo q.  We denote this value as w. 
  </t>
  <t>
    Compute the non-negative integers u and v, where 
    <list style="empty">
      <t>
	u = w * h(m) mod q, and 
      </t>
      <t>
	v = w * s1 mod q.
      </t>
    </list> 
  </t>
  <t>
    Compute the elliptic curve point R' = alpha^u * Q^v
  </t>
  <t>
    If the x-coordinate of R' is equal to s1, then the signature and
    message pass the verification; otherwise, they fail.
  </t>
</list>
</t>
</section>


</section>


<section anchor="Interop" title="Interoperability">
<t>
The algorithms in this note can be used to interoperate with
some other ECC specifications.  This section provides details
for each algorithm.
</t>
<section title="ECDH">
<t>
<xref target="ECDH"/> can be used with the Internet Key Exchange (IKE)
versions one <xref target="RFC2409"/> or two <xref
target="RFC4306"/>.  These algorithms are compatible
with the ECP groups for the defined by
<xref target="RFC4753"/>, <xref target="RFC2409"/>, and <xref
target="RFC2412"/>.   The group definition used in this protocol
uses an affine coordinate representation of the public key
and uses neither the compact output nor the compact representation
of <xref target="REP"/>.
Note that some groups use a negative curve
parameter "a" and express this fact in the curve equation rather than
in the parameter.  The test cases in Section 8 of <xref
target="RFC4753"/> can be used to test an implementation; these cases
use the multiplicative notation, as does this note.  The KEi and KEr
payloads are equal to g^i and g^r, respectively, with 64 bits of
encoding data prepended to them.
</t>
<t>
The algorithms in <xref target="ECDH"/> can be used to interoperate
with the IEEE <xref target="P1363"/> and ANSI <xref target="X9.62"/>
standards for ECDH based on fields of characteristic greater than
three.  
</t>
</section>
<section anchor="SigInterop" title="ECES, AECES, and ECDSA">
<t>
The Digital Signature Algorithm (DSA) is based on the discrete
logarithm problem over the multiplicative subgroup of the finite field
large prime order <xref target="DSA1991"/><xref target="FIPS186"/>.
The Elliptic Curve Digital Signature Algorithm (ECDSA) <xref
target="P1363"/> <xref target="X9.62"/> is an elliptic curve version
of DSA.
</t><t>
AECES can interoperate with the IEEE <xref target="P1363"/> and ANSI
<xref target="X9.62"/> standards for Elliptic Curve DSA (ECDSA) based
on fields of characteristic greater than three.
</t>
<t>
An ECES signature can be converted into an ECDSA signature by discarding
the y-coordinate from the elliptic curve point.
</t>

<t>
There is a strong correspondence between ECES signatures and ECDSA signatures.  
In the notation of <xref target="ECES"/>, an ECDSA signature
consists of the pair of integers (g(r), s), and signature verification
passes if and only if 
<list style="empty">
  <t>
  A^(h(m)/s) * Q^(g(r)/s) = r,
  </t>
</list>
where the equality of the elliptic curve elements is checked by
checking for the equality of their x-coordinates.  For valid
signatures, (h(m)+a*r)/s mod q = k, and thus the two sides are equal.
An ECDSA signature contains only the x-coordinate g(r), but this is
sufficient to allow the signatures to be checked with the above
method.
</t>
<t>
Whenever the ECES signature (r, s) is valid for a particular message m,
and public key Q, then there is a valid ECDSA signature (g(r), s) for the same
message and public key.
</t>
<t>
Whenever the ECDSA signature (c, d) is valid for a particular message
m, and public key Q, then there is a valid ECES signature for the same
message and public key.  This signature has the form ((c, f(c)), d),
or ((c, q-f(c)), d) where the function f takes as input an integer in
Zq and is defined as
<list style="empty">
  <t>
   f(x) = sqrt(x^3 + a*x + b) (mod q).
  </t>
</list>
It is possible to compute the square root modulo q, for instance, by
using Shanks's method <xref target="K1987"/>.  However, it is not as
efficient to convert an ECDSA signature (or an AECES signature) to an
ECES signature.
</t>
</section>
</section>


<section anchor="IPR" title="Intellectual Property">
<t>
Concerns about intellectual property have slowed the adoption of ECC,
because a number of optimizations and specialized algorithms have
been patented in recent years.  
</t>
<t>
All of the normative references in this note were published during or
before October, 1994, and all of the normative text in this note is
based solely on those references.
</t>
<section title="Disclaimer">
<t>
   This document is not intended as legal advice.  Readers are advised
   to consult their own legal advisers if they would like a legal
   interpretation of their rights.
</t>
<t>
   The IETF policies and processes regarding intellectual property and
   patents are outlined in <xref target="RFC3979"/> and
   <xref target="RFC4879"/> and at
   https://datatracker.ietf.org/ipr/about/.
</t>
</section>

</section>


<section anchor="SEC" title="Security Considerations">
<t>
The security level of an elliptic curve cryptosystem is determined by
the cryptanalytic algorithm that is the least expensive for an
attacker to implement.   There are several algorithms to consider.
</t>
<t>
The Polhig-Hellman method is a divide-and-conquer technique
<xref target="PH1978"/>.  If the group order n can be 
factored as
<list style="empty">
  <t>
    n = q1 * q2 *  ... * qz,
    </t>
</list>
then the discrete log problem over the group can be solved by
independently solving a discrete log problem in groups of order q1,
q2, ..., qz, then combining the results using the Chinese remainder
theorem.   The overall computational cost is dominated by 
that of the discrete log problem in the subgroup with the
largest order. 
</t>
<t>
Shanks algorithm <xref target="K1981v3"/> computes a discrete
logarithm in a group of order n using O(sqrt(n)) operations and
O(sqrt(n)) storage.  The Pollard rho algorithm <xref target="P1978"/>
computes a discrete logarithm in a group of order n using O(sqrt(n))
operations, with a negligible amount of storage, and can be
efficiently parallelized.
</t>
<t>
The Pollard lambda algorithm  <xref target="P1978"/> can 
solve the discrete logarithm problem using O(sqrt(w))
operations and O(log(w)) storage, when the exponent
belongs to a set of w elements.  
</t>

<t>
The algorithms described above work in any group.  There
are specialized algorithms that specifically target
elliptic curve groups.  There are no subexponential algorithms
against general elliptic curve groups, though
there are methods that target certain special 
elliptic curve groups; see <xref target="MOV1993"/>
and <xref target="FR1994"/>.
</t>
<section title="Subgroups">
<t>
A group consisting of a set of elements S with associated group
operation * is a subgroup of the group with the set of elements G, if
the latter group uses the same group operation and S is a subset of G.
For each elliptic curve equation, there is an elliptic curve group
whose group order is equal to the order of the elliptic curve; that
is, there is a group that contains every point on the curve.  
</t>
<t>
The order m of the elliptic curve is divisible by the order n of the
group associated with the generator; that is, for each elliptic curve
group, m = n * c for some number c.  The number c is called the
"cofactor" <xref target="P1363"/>.  Each elliptic curve group (e.g.
each parameter set as in <xref target="params"/>) is associated with a
particular cofactor.
</t>
<t>
It is possible and desirable to use a cofactor equal to 1.  
</t>
<t>
It is common to use a "safe prime group" in the conventional
Diffie-Hellman protocol over the multiplicative group of the prime
field Fp (see Appendix E of <xref target="RFC2412"/> for example).  A
safe prime group is the subgroup of prime order q of the
multiplicative group of Zp, where p-1 = 2*q.  The use of safe prime
groups simplifies protocol design, implementation and use, because they
minimize the effectiveness of some cryptanalytic attacks.  Elliptic
curve groups with a cofactor of 1 have similar benefits.
</t>


</section>



<section title="Diffie-Hellman">
<t>
Note that the key exchange protocol as defined in
<xref target="ECDH"/> does not protect against active attacks; Party A
must use some method to ensure that (g^k) originated with the intended
communicant B, rather than an attacker, and Party B must do the same
with (g^j).
</t>
<t>
It is not sufficient to authenticate the shared secret g^(j*k), since
this leaves the protocol open to attacks that manipulate the public
keys.  Instead, the values of the public keys g^x and g^y that are
exchanged should be directly authenticated.  This is the strategy used
by protocols that build on Diffie-Hellman and which use end-entity
authentication to protect against active attacks, such as OAKLEY <xref
target="RFC2412"/> and the Internet Key Exchange <xref
target="RFC2409"/><xref target="RFC4306"/>.
</t>
<t>
When the cofactor of a group is not equal to 1, there are a number of
attacks that are possible against ECDH.   See <xref target="VW1996"/>,
<xref target="AV1996"/>, and <xref target="LL1997"/>.
</t>

</section>

<section anchor="twogroups" title="Group Representation and Security">
<t>
The elliptic curve group operation does not explicitly incorporate the
parameter b from the curve equation.  This opens the possibility that
a malicious attacker could learn information about an ECDH private key
by submitting a bogus public key <xref target="BMM2000"/>.  An
attacker can craft an elliptic curve group G' that has identical
parameters to a group G that is being used in an ECDH protocol, except
that b is different.  An attacker can submit a point on G' into a run
of the ECDH protocol that is using group G, and gain information from
the fact that the group operations using the private key of the device
under attack are effectively taking place in G' instead of G.
</t>
<t>
This attack can gain useful information about an ECDH private key that
is associated with a static public key, that is, a public key that is
used in more than one run of the protocol.  However, it does not
gain any useful information against ephemeral keys.
</t>
<t>
This sort of attack is thwarted if an ECDH implementation does not
assume that each pair of coordinates in Zp is actually a point on the
appropriate elliptic curve.
</t>
</section>



<section title="Signatures">
<t>
Elliptic curve parameters should only be used if they come from a
trusted source; otherwise, some attacks are possible
<xref target="AV1996"/>, <xref target="V1996"/>.
</t>
<t>
In principle, any collision-resistant hash function is suitable
for use in ECES.  To facilitate interoperability, we recognize
the following hashes as suitable for use as the function H defined in 
<xref target="hash"/>:
<list style="empty">
  <t>
    SHA-256, which has a 256-bit output.  
  </t>
  <t>
    SHA-384, which has a 384-bit output.
  </t>
  <t>
    SHA-512, which has a 512-bit output.
  </t>
</list>
All of these hash functions are defined in <xref target="FIPS180-2"/>.
</t>
<t>
The number of bits in the output of the hash used in ECES should be
equal or close to the number of bits needed to represent the
group order.
</t>
</section>

</section>



<section title="IANA Considerations">
<t>
This note has no actions for IANA.  This section should be removed by
the RFC editor before publication as an RFC.
</t>
</section>

<section title="Acknowledgements">
<t>
The author expresses his thanks to the originators of elliptic curve
cryptography, whose work made this note possible.
</t>
</section>

</middle>

<back>
  
  <references title="Normative References">
	
<!--
         &rfc2119;
-->
	<reference anchor="D1966">
         <front>
           <title> Abstract Algebra</title>
	   <author initials="W.E." surname="Deskins">
	     <organization/>
           </author>
	  <date year="1966"/>
         </front>
         <seriesInfo name="MacMillan Company" value="" />
        </reference>

	<reference anchor="K1981v2">
         <front>
           <title> The Art of Computer Programming, Vol. 2: Seminumerical Algorithms</title>
	   <author initials="D.E." surname="Knuth">
	     <organization/>
           </author>
	  <date year="1981"/>
         </front>
         <seriesInfo name="Addison Wesley" value="" />
        </reference>

	<reference anchor="DH1976">
         <front>
           <title> New Directions in Cryptography </title>
	   <author initials="W." surname="Diffie" >
	     <organization/>
           </author>
	   <author initials="M." surname="Hellman" >
	     <organization/>
           </author>
	  <date  year="1976"/>
         </front>
         <seriesInfo name="IEEE Transactions in Information Theory" 
		     value="IT-22, pp 644-654" />
        </reference>

	<reference anchor="M1983">
         <front>
           <title> Logarithms in finite cyclic groups - cryptographic issues </title>
	   <author initials="J.L." surname="Massey" >
	     <organization/>
           </author>
	  <date  year="1983"/>
         </front>
         <seriesInfo name="Processings of the 4th Symposium on Information Theory" 
		     value="" />
<!--
http://www.isiweb.ee.ethz.ch/archive/massey_pub/pdf/BI518.pdf
-->
        </reference>

	
	<reference anchor="E1984a">
         <front>
           <title> Cryptography and logarithms over finite fields</title>
	   <author initials="T." surname="ElGamal" >
	     <organization/>
           </author>
	  <date  year="1984"/>
         </front>
         <seriesInfo name="Stanford University" 
		     value="UMI Order No. DA 8420519" />
        </reference>
	
	<reference anchor="E1984b">
         <front>
           <title> Cryptography and logarithms over finite fields</title>
	   <author initials="T." surname="ElGamal" >
	     <organization/>
           </author>
	  <date  year="1984"/>
         </front>
         <seriesInfo name="Advances in Cryptology - CRYPTO '84 Proceedings" 
		     value="Springer Lecture Notes in Computer Science (LNCS) volume 196" />
        </reference>

	<reference anchor="E1985">
         <front>
           <title> A public key cryptosystem and a signature scheme
           based on discrete logarithms
	   </title>
	   <author initials="T." surname="ElGamal" >
	     <organization/>
           </author>
	  <date  year="1985"/>
         </front>
         <seriesInfo name="IEEE Transactions on Information Theory" 
		     value="Vol 30, No. 4, pp. 469-472" />
        </reference>

	<reference anchor="M1985">
         <front>
           <title> Use of elliptic curves in cryptography</title>
	   <author initials="V." surname="Miller" >
	     <organization/>
           </author>
	  <date  year="1985"/>
         </front>
         <seriesInfo name="Advances in Cryptology - CRYPTO '85 Proceedings" 
		     value="Springer Lecture Notes in Computer Science (LNCS) volume 218" />
        </reference>



	<reference anchor="K1987">
         <front>
           <title> Elliptic Curve Cryptosystems</title>
	   <author initials="N." surname="Koblitz" >
	     <organization/>
           </author>
	  <date  year="1987"/>
         </front>
         <seriesInfo name="Mathematics of Computation" 
		     value="Vol. 48, 1987, 203-209" />
        </reference>


	<reference anchor="BC1989">
	  <front>
	    <title> On the Implementation of Elliptic Curve Cryptosystems </title>
	    <author initials="A." surname="Bender">
	      <organization/>
	      </author>
	    <author initials="G." surname="Castagnoli">
	      <organization/>
	      </author>
	    <date year="1989"/>
	    </front>
         <seriesInfo name="Advances in Cryptology - CRYPTO '89 Proceedings" 
		     value="Spinger Lecture Notes in Computer Science (LNCS) volume 435" />	  
	  </reference>


	<reference anchor="AMV1990">
	  <front>
	    <title>
	      Improved Digital Signature Scheme based on Discrete Exponentiation
	    </title>
	    <author initials="G.B." surname="Agnew">
	      <organization/>
	      </author>
	    <author initials="R.C." surname="Mullin">
	      <organization/>
	      </author>
	    <author initials="S.A." surname="Vanstone">
	      <organization/>
	      </author>
	    <date year="July, 1990"/>
	    </front>
         <seriesInfo name="Electronics Letters" 
		     value="Vol. 26, No. 14" />	  
	  </reference>


	<reference anchor="R1992">
         <front>
           <title> Response to the proposed DSS</title>
	   <author initials="R." surname="Rivest" fullname="Ronald Rivest">
	     <organization/>
           </author>
	  <date month="July" year="1992"/>
         </front>
         <seriesInfo name="Communications of the ACM" value="v.35 n.7 p.41-47." />
        </reference>

	<reference anchor="A1992">
         <front>
           <title> Response to the proposed DSS</title>
	   <author initials="J." surname="Anderson" fullname="John C. Anderson">
	     <organization/>
           </author>
	  <date month="July" year="1992"/>
         </front>
         <seriesInfo name="Communications of the ACM" value="v.35 n.7 p.50-52" />
        </reference>

	<reference anchor="MV1993">
	  <front>
	    <title> Elliptic Curve Cryptosystems and Their Implementation </title>
	    <author initials="A.J." surname="Menezes">
	      <organization/>
	      </author>
	    <author initials="S.A." surname="Vanstone">
	      <organization/>
	      </author>
	    <date year="1993"/>
	    </front>
         <seriesInfo name="Journal of Cryptology" 
		     value="Volume 6, No. 4, pp209-224" />	  
	  </reference>

	<reference anchor="MOV1993">
         <front>
           <title> 
	     Reducing Elliptic Curve Logarithms to
	     Logarithms in a Finite Field
	   </title>
	    <author initials="A.J." surname="Menezes">
	      <organization/>
	      </author>
	    <author initials="S.A." surname="Vanstone">
	      <organization/>
	      </author>
	    <author initials="T." surname="Okamoto">
	      <organization/>
	      </author>
	  <date  year="September, 1993"/>
         </front>
         <seriesInfo name="IEEE Transactions on Information Theory" 
		     value="Vol 39, No. 5, pp. 1639-1646" />
        </reference>

	<reference anchor="FR1994">
         <front>
           <title> 
	     A remark concerning m-divisibility and the discrete
	     logarithm in the divisor class group of curves.
	   </title>
	    <author initials="G." surname="Frey">
	      <organization/>
	      </author>
	    <author initials="H." surname="Ruck">
	      <organization/>
	      </author>
	  <date  year="1994"/>
         </front>
         <seriesInfo name="Mathematics of Computation" 
		     value="Vol. 62, No. 206, pp. 865-874" />
        </reference>


	<reference anchor="MQV1994">
	  <front>
	    <title>
	      Submission to the IEEE P1363 Working Group (Part 6:
	    Elliptic Curve Systems, Draft 2) 
	    </title>
	    <author initials="A.J." surname="Menezes">
	      <organization/>
	      </author>
	    <author initials="M." surname="Qu">
	      <organization/>
	      </author>
	    <author initials="S.A." surname="Vanstone">
	      <organization/>
	      </author>
	    <date year="October, 1994"/>
	    </front>
         <seriesInfo name="Working Document" 
		     value="" />	  
	  </reference>

	</references>
   <references title="Informative References">

	<reference anchor="PH1978">
         <front>
           <title>
	     An Improved Algorithm for Computing Logarithms over
	     GF(p) and its Cryptographic Significance
	   </title>
	   <author initials="S." surname="Polhig" >
	     <organization/>
           </author>
	   <author initials="M." surname="Hellman" >
	     <organization/>
           </author>
	  <date  year="1978"/>
         </front>
         <seriesInfo name="IEEE Transactions on Information Theory" 
		     value="Vol 24, pp. 106-110" />
        </reference>


	<reference anchor="K1981v3">
         <front>
           <title> The Art of Computer Programming, Vol. 3:
           Sorting and Searching</title>
	   <author initials="D.E." surname="Knuth">
	     <organization/>
           </author>
	  <date year="1981"/>
         </front>
         <seriesInfo name="Addison Wesley" value="" />
        </reference>


	<reference anchor="P1978">
         <front>
           <title> 
	     Monte Carlo methods for index computation mod p
	   </title>
	   <author initials="J." surname="Pollard" >
	     <organization/>
           </author>
	  <date  year="1978"/>
         </front>
         <seriesInfo name="Mathematics of Computation" 
		     value="Vol. 32" />
        </reference>

	<reference anchor="KMOV1991">
         <front>
           <title> 
	     New Public-Key Schemes Based on Elliptic Curves over the Ring Zn
	   </title>
	    <author initials="K." surname="Koyama">
	      <organization/>
	      </author>
	    <author initials="A.J." surname="Menezes">
	      <organization/>
	      </author>
	    <author initials="S.A." surname="Vanstone">
	      <organization/>
	      </author>
	    <author initials="T." surname="Okamoto">
	      <organization/>
	      </author>
	  <date  year="1991"/>
         </front>
        <seriesInfo name="Advances in Cryptology - CRYPTO '91 Proceedings" 
		     value="Spinger Lecture Notes in Computer Science (LNCS) volume 576" />	  

        </reference>




	<reference anchor="KT1994">
         <front>
           <title> Digital signature system based on elliptic curve
	     and signer device and verifier device for said system
	   </title>
	   <author initials="K." surname="Koyama" >
	     <organization/>
           </author>
	   <author initials="Y." surname="Tsuruoka" >
	     <organization/>
           </author>
	  <date  year="1994"/>
         </front>
         <seriesInfo name="Japanese Unexamined Patent Application
		     Publication" value="H6-43809" />
        </reference>

	<reference anchor="AV1996">
         <front>
           <title>  
	     Minding Your P's and Q's 
	   </title>
	   <author initials="R." surname="Anderson" >
	     <organization/>
           </author>
	   <author initials="S." surname="Vaudenay" >
	     <organization/>
           </author>
	  <date  year="1996"/>
         </front>
         <seriesInfo name="Advances in Cryptology - ASIACRYPT '96
		     Proceedings" 
		     value="Spinger Lecture Notes in
		     Computer Science (LNCS) volume 1163" />
        </reference>


	<reference anchor="VW1996">
         <front>
           <title>  On Diffie-Hellman key agreement with short exponents 
	   </title>
	   <author initials="P." surname="van Oorschot" >
	     <organization/>
           </author>
	   <author initials="M." surname="Wiener" >
	     <organization/>
           </author>
	  <date  year="1996"/>
         </front>
         <seriesInfo name="Advances in Cryptology - EUROCRYPT '96 Proceedings" 
		     value="Spinger Lecture Notes in Computer Science (LNCS) volume 1070" />
        </reference>

	<reference anchor="V1996">
         <front>
           <title>  
	     Hidden Collisions on DSS
	   </title>
	   <author initials="S." surname="Vaudenay" >
	     <organization/>
           </author>
	  <date  year="1996"/>
         </front>
         <seriesInfo name="Advances in Cryptology - CRYPTO '96
		     Proceedings" value="Spinger Lecture Notes in
		     Computer Science (LNCS) volume 1109" />
        </reference>


	<reference anchor="LL1997">
         <front>
           <title>  
	     A Key Recovery Attack on Discrete Log-based Schemes
	     Using a Prime Order Subgroup
	   </title>
	   <author initials="C.H." surname="Lim" >
	     <organization/>
           </author>
	   <author initials="P.J." surname="Lee" >
	     <organization/>
           </author>
	  <date  year="1997"/>
         </front>
         <seriesInfo name="Advances in Cryptology - CRYPTO '97 Proceedings" 
		     value="Spinger Lecture Notes in Computer Science (LNCS) volume 1294" />
        </reference>


	<reference anchor="BMM2000">
         <front>
           <title>  
	     Differential fault analysis on elliptic curve cryptosystems
	   </title>
	   <author initials="I." surname="Biehl" >
	     <organization/>
           </author>
	   <author initials="B." surname="Meyer" >
	     <organization/>
           </author>
	   <author initials="V." surname="Muller" >
	     <organization/>
           </author>
	  <date  year="2000"/>
         </front>
         <seriesInfo name="Advances in Cryptology - CRYPTO 2000 Proceedings" 
		     value="Spinger Lecture Notes in Computer Science (LNCS) volume 1880" />
        </reference>


	<reference anchor="X9.62">
         <front>
           <title> Public Key Cryptography for the Financial Services
                   Industry: The Elliptic Curve Digital Signature
                   Algorithm (ECDSA) </title>
	  <author fullname="American National Standards Institute">
	      <organization/>
           </author>
         </front>
         <seriesInfo name="American National Standards Institute (ANSI)" value=" X9.62" />
        </reference>

	<reference anchor="P1363">
         <front>
           <title> Standard Specifications for Public Key Cryptography </title>
	  <author fullname="Institute of Electric and Electronic Engineers">
	      <organization/>
           </author>
	  <date year="2000"/>
         </front>	 
         <seriesInfo name="Institute of Electric and Electronic Engineers (IEEE)" value="P1363" />
        </reference>

	<reference anchor="FIPS186">
         <front>
           <title>  DIGITAL SIGNATURE STANDARD</title>
	  <author fullname="U.S. National Institute of Standards and Technology">
	      <organization/>
           </author>
	  <date year="1994"/>
         </front>	 
         <seriesInfo name="Federal Information Processing Standard" value="FIPS-186" />
        </reference>

	<reference anchor="DSA1991">
         <front>
           <title>  DIGITAL SIGNATURE STANDARD</title>
	  <author fullname="U.S. National Institute of Standards and Technology">
	      <organization/>
           </author>
	  <date month="August" year="1991"/>
         </front>	 
         <seriesInfo name="Federal Register" value="Vol. 56" />
        </reference>

	<reference anchor="FIPS180-2">
         <front>
           <title>  SECURE HASH STANDARD</title>
	  <author fullname="U.S. National Institute of Standards and Technology">
	      <organization/>
           </author>
	  <date month="August" year="2002"/>
         </front>	 
         <seriesInfo name="Federal Information Processing Standard (FIPS)" value="180-2" />
        </reference>



         &rfc2409;
         &rfc2412;
         &rfc4306;
         &rfc4753;

	&rfc3979;
	&rfc4879;


   </references>


<section anchor="rng" title="Random Number Generation">
<t>
It is easy to generate an integer uniformly at random between zero and
2^t, for some positive integer t.  Generate a random bit string that
contains exactly t bits, and then convert the bit string to a
non-negative integer by treating the bits as the coefficients in a
base-two expansion of an integer.
</t>
<t>
It is sometimes necessary to generate an integer r uniformly at random
so that r satisfies a certain property P, for example, lying within a
certain interval.  A simple way to do this is with the rejection
method:
<list style="numbers">
<t>
Generate a candidate number c uniformly at random from a set that
includes many numbers that satisfy property P.
</t>
<t>
If c satisfies property P, then return c.  Otherwise, return to Step
1.
</t>
</list> 
For example, to generate a number between 1 and n-1,
repeatedly generate integers between zero and 2^t, stopping at the
first integer that falls within that interval.
</t>
</section>



<section anchor="Example" title="Example Elliptic Curve Group">
<t>
For concreteness, we recall an elliptic curve defined by Solinas and
Yu in <xref target="RFC4753"/> and referred to as P-256, which is
believed to provide a 128-bit security level.  We use the notation of 
<xref target="params"/>, and express the generator in the affine
coordinate representation g=(gx,gy), where the values gx and gy are 
in Zp.  
</t>
<t>
p: FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF
</t>
<t>
a: - 3
</t>
<t>
b: 5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B
</t>
<t>
n: FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551

</t>


<t>
gx: 6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296
</t>
<t>
gy: 4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5
</t>
<t>
Note that p can also be expressed as 
<list>
   <t>
     p = 2^(256)-2^(224)+2^(192)+2^(96)-1.
   </t>
</list>
</t>


</section>



</back>
</rfc>
