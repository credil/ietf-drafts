<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc2130 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2130.xml">
<!ENTITY rfc2141 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2141.xml">
<!ENTITY rfc2192 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2192.xml">
<!ENTITY rfc2277 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2277.xml">
<!ENTITY rfc2368 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2368.xml">
<!ENTITY rfc2384 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2384.xml">
<!ENTITY rfc2396 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2396.xml">
<!ENTITY rfc2397 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2397.xml">
<!ENTITY rfc2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY rfc2640 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2640.xml">
<!ENTITY rfc2718 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2718.xml">
<!ENTITY rfc3490 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3490.xml">
<!ENTITY rfc3491 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3491.xml">
<!ENTITY rfc3629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
]>
<!-- <?rfc strict='yes'?>
     complains about too long lines (2 cases)
     and appendix, but otherwise is okay
-->
<?xml-stylesheet type='text/css' href='rfc2629.css' ?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc symrefs='yes'?>
<?rfc sortrefs='yes'?>
<?rfc iprnotified="no" ?>
<?rfc toc='yes'?>
<?rfc compact='yes'?>
<?rfc subcompact='no'?>
<rfc ipr="pre5378Trust200902" docName="draft-duerst-iri-bis-06" category="std" xml:lang="en" obsoletes="RFC 3987">
<front>
<title abbrev="Internationalized Resource Identifiers">Internationalized Resource Identifiers (IRIs)</title>

<author initials="M.J." surname="Duerst" fullname='Martin Duerst (Note: Please write "Duerst" with u-umlaut wherever possible, for example as "D&amp;#252;rst" in XML and HTML.)'>
  <organization abbrev="Aoyama Gakuin University">Aoyama Gakuin University</organization>
  <address>
  <postal>
  <street>5-10-1 Fuchinobe</street>
  <city>Sagamihara</city>
  <region>Kanagawa</region>
  <code>229-8558</code>
  <country>Japan</country>
  </postal>
  <phone>+81 42 759 6329</phone>
  <facsimile>+81 42 759 6495</facsimile>
  <email>mailto:duerst@it.aoyama.ac.jp</email>
  <uri>http://www.sw.it.aoyama.ac.jp/D%C3%BCrst/ (Note: This is the percent-encoded form of an IRI.)</uri>
  </address>
</author>

<author initials="M.L." surname="Suignard" fullname="Michel Suignard">
   <organization>Unicode Consortium</organization>
   <address>
   <postal>
   <street></street>
   <street>P.O. Box 391476</street>
   <city>Mountain View</city>
   <region>CA</region>
   <code>94039-1476</code>
   <country>U.S.A.</country>
   </postal>
   <phone>+1-650-693-3921</phone>
   <email>mailto:michel@unicode.org</email>
   <uri>http://www.suignard.com</uri>
   </address>
</author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
   <organization>Adobe</organization>
   <address>
   <postal>
   <street>345 Park Ave</street>
   <city>San Jose</city>
   <region>CA</region>
   <code>95110</code>
   <country>U.S.A.</country>
   </postal>
   <phone>+1-408-536-3024</phone>
   <email>mailto:masinter@adobe.com</email>
   <uri>http://larry.masinter.net</uri>
   </address>
</author>

<date year="2009" month="July" day="12"/>
<keyword>IRI</keyword>
<keyword>Internationalized Resource Identifier</keyword>
<keyword>UTF-8</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>IDN</keyword>
<keyword>LEIRI</keyword>

<abstract>
<t>This document defines a new protocol element, the Internationalized
Resource Identifier (IRI), as an extension of the Uniform Resource Identifier (URI).
An IRI is a sequence of characters from the Universal Character Set (Unicode/ISO 10646).
A mapping from IRIs to URIs is defined, which provides a means for IRIs to be used instead
of URIs, where appropriate, to identify resources.</t>
<t>To accomodate widespread current practice, additional derivative protocol elements are defined, and current practice for resolving IRI-based hypertext references in HTML are outlined. </t>
<t>The approach of defining new protocol elements, rather than updating or extending the definition of URI, was chosen to allow independent orderly transitions as appropriate: other protocols and languages that use URIs and their processing may explicitly choose to allow IRIs or derivative forms.</t>
<t> Guidelines are provided for the use and deployment of IRIs and related protocol elements when revising protocols, formats, and software components that currently deal only with URIs.</t>

<t>[RFC Editor: Please remove this paragraph before publication.] This is a draft to update RFC 3987 and move towards IETF Draft Standard.
For an issues list/change log and additional information (including mailing list information), please see
http://www.w3.org/International/iri-edit. For discussion and comments on this draft, please use the public-iri@w3.org mailing list.</t>

</abstract>
</front>
<middle>

<section title="Introduction">
<section title="Overview and Motivation">
<t>A Uniform Resource Identifier (URI) is defined in <xref target="RFC3986"/>
as a sequence of characters
chosen from a limited subset of the repertoire of US-ASCII <xref target="ASCII"/>
characters.</t>

<t>The characters in URIs are frequently used for representing words of
natural languages.  This usage has many advantages: Such URIs are easier to
memorize, easier to interpret, easier to transcribe, easier to create,
and easier to guess. For most languages other than English, however,
the natural script uses characters other than A - Z. For many people,
handling Latin characters is as difficult as handling the characters
of other scripts is for those who use only the Latin alphabet. Many
languages with non-Latin scripts are transcribed with Latin
letters. These transcriptions are now often used in URIs, but they
introduce additional difficulties.</t>

<t>The infrastructure for the appropriate handling of characters from
additional scripts is now widely deployed in operating system and
application software. Software that can handle a wide variety of
scripts and languages at the same time is increasingly common. Also,
increasing numbers of protocols and formats can carry a wide range of
characters.</t>

<t>URIs are used both as a protocol element (for transmission and
processing by software) and also a presentation element (for
display and handling by people who read, interpret, coin, or
guess them. The transition between these roles is more
difficult and complex when dealing with the larger set of 
characters than allowed in <xref target="RFC3986"/>.
 </t>

<t>This document defines a new protocol element called
Internationalized Resource Identifier (IRI), extending the syntax of
URIs to a much wider repertoire of characters. It also defines
corresponding "internationalized" versions of other constructs from
<xref target="RFC3986"/>, such as URI references. The syntax of IRIs
is defined in <xref target="syntax"/>, and the relationship between
IRIs and URIs in <xref target="iriuri"/>.
</t>

<t>Using characters outside of A - Z in IRIs brings a number of
difficulties. <xref target="Bidi"/> discusses the special case of
bidirectional IRIs using characters from scripts written
right-to-left.  <xref target="equivalence"/> discusses various forms of
equivalence between IRIs. <xref target="IRIuse"/> discusses the use of
IRIs in different situations. <xref target="LEIRIHREF"/> describes
extensions to the IRI syntax used in some XML languages <xref target="LEIRI"/> and
the handling of IRIs in commonly deployed web browsers <xref target="HTML5"/>. 
<xref target="guidelines"/> gives additional informative guidelines. 
<xref target="security"/> discusses security considerations.</t>

</section>

<section title="Applicability" anchor="Applicability">
<t>IRIs are designed to be compatible with recommendations for new URI
schemes <xref target="RFC2718"/>. The compatibility is provided by specifying
a well-defined and deterministic mapping from the IRI character sequence to
the functionally equivalent URI character sequence. Practical use of IRIs
(or IRI references) in place of URIs (or URI references) depends on the
following conditions being met:</t>

<t><list style="hanging">
<t hangText="a.">
  A protocol or format element should be explicitly designated to be able to carry IRIs. The intent is not to
    introduce IRIs into contexts that are not defined to accept them.
    For example, XML schema <xref target="XMLSchema"/> has an explicit type "anyURI"
    that includes IRIs and IRI references. Therefore, IRIs and IRI references
    can be in attributes and elements of type "anyURI".
    On the other hand, in the HTTP protocol <xref target="RFC2616"/>, the Request URI is
    defined as a URI, which means that direct use of IRIs is not allowed
    in HTTP requests.</t>

<t hangText="b.">The protocol or format carrying the IRIs should have a
    mechanism to represent the wide range of characters used in IRIs, either
    natively or by some protocol- or format-specific escaping mechanism
    (for example, numeric character references in <xref target="XML1"/>).</t>

<t hangText="c.">The URI corresponding to the IRI in question has to
    encode original characters into octets using UTF-8. For new URI schemes,
    this is recommended in <xref target="RFC2718"/>. It can apply to a whole
    scheme (e.g., IMAP URLs <xref target="RFC2192"/> and POP
    URLs <xref target="RFC2384"/>, or the URN syntax <xref target="RFC2141"/>).
    It can apply to a specific part of a URI, such as the fragment identifier
    (e.g., <xref target="XPointer"/>). It can apply to a specific URI or part(s)
    thereof. For details, please see <xref target="UTF8use"/>.</t>
</list></t>

</section>

<section title="Definitions" anchor="sec-Definitions">
<t>The following definitions are used in this document; they follow the
terms in <xref target="RFC2130"/>, <xref target="RFC2277"/>, and
<xref target="ISO10646"/>.</t>
<t><list style="hanging">
<t hangText="character:">A member of a set of elements used for the organization,
     control, or representation of data. For example, "LATIN CAPITAL LETTER A" names
     a character.</t>
<t hangText="octet:">An ordered sequence of eight bits considered as a unit.</t>
<t hangText="character repertoire:">A set of characters (in the mathematical sense).</t>
<t hangText="sequence of characters:">A sequence of characters (one after another).</t>
<t hangText="sequence of octets:">A sequence of octets (one after another).</t>
<t hangText="character encoding:">A method of representing a sequence of
     characters as a sequence of octets (maybe with variants). Also, a method of
     (unambiguously) converting a sequence of octets into a sequence of characters.</t>
<t hangText="charset:">The name of a parameter or attribute used
     to identify a character encoding.</t>
<t hangText="UCS:">Universal Character Set. The coded character set defined by
     ISO/IEC 10646 <xref target="ISO10646"/> and
     the Unicode Standard <xref target="UNIV4"/>.</t>
<t hangText="IRI reference:">Denotes the common usage
     of an Internationalized Resource Identifier. An IRI reference may be absolute or relative.
     However, the "IRI" that results from such a reference only includes absolute IRIs;
     any relative IRI references are resolved to their absolute form.
     Note that in <xref target="RFC2396"/> URIs did not include fragment identifiers,
     but in <xref target="RFC3986"/> fragment identifiers are part of URIs.</t>
<t hangText="running text:">Human text (paragraphs, sentences, phrases)
     with syntax according to orthographic conventions of a natural language,
     as opposed to syntax defined for ease of processing by machines (e.g., markup,
     programming languages).</t>
<t hangText="protocol element:">Any portion of a message that affects
     processing of that message by the protocol in question.</t>
<t hangText="presentation element:">A presentation form corresponding to a
     protocol element; for example, using a wider range of characters.</t>
<t hangText="create (a URI or IRI):">With respect to URIs and IRIs, the
     term is used for the initial creation. This may be the
     initial creation of a resource with a certain identifier, or the initial
     exposition of a resource under a particular identifier.</t>
<t hangText="generate (a URI or IRI):">With respect to URIs and IRIs,
     the term  is used when the IRI is generated by derivation
     from other information.</t>
</list></t>
</section>
<section title="Notation" anchor="sec-Notation">
<t>RFCs and Internet Drafts currently do not allow any characters outside
the US-ASCII repertoire. Therefore, this document uses various special
notations to denote such characters in examples.</t>
<t>In text, characters outside US-ASCII are sometimes referenced by
using a prefix of 'U+', followed by four to six hexadecimal digits.</t>
<t>To represent characters outside US-ASCII in examples, this document
uses two notations: 'XML Notation' and 'Bidi Notation'.</t>
<t>XML Notation uses a leading '&amp;#x', a trailing ';', and the
hexadecimal number of the character in the UCS in between. For example,
&amp;#x44F; stands for CYRILLIC CAPITAL LETTER YA. In this notation, an
actual '&amp;' is denoted by '&amp;amp;'.</t>
<t>Bidi Notation is used for bidirectional examples: Lower case
letters stand for Latin letters or other letters that are written left to right,
whereas upper case letters represent Arabic or Hebrew letters that are
written right to left.</t>
<t>To denote actual octets in examples (as opposed to percent-encoded octets),
the two hex digits denoting the octet are enclosed in "&lt;" and "&gt;".
For example, the octet often denoted as 0xc9 is denoted here as &lt;c9&gt;.</t>
<t> In this document, the key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
"OPTIONAL" are to be interpreted as described in
<xref target="RFC2119"/>.</t>
</section>
</section>

<section title="IRI Syntax" anchor="syntax">
<t>This section defines the syntax of Internationalized Resource
Identifiers (IRIs).</t>

<t>As with URIs, an IRI is defined as a sequence of characters, not as
a sequence of octets. This
definition accommodates the fact that IRIs may be written on paper or
read over the radio as well as stored or transmitted digitally.
The same IRI might be represented as different sequences of octets
in different protocols or documents if these protocols or documents
use different character encodings (and/or transfer encodings).
Using the same character encoding
as the containing protocol or document ensures that the characters in
the IRI can be handled (e.g., searched, converted, displayed) in the
same way as the rest of the protocol or document.</t>

<section title="Summary of IRI Syntax">
<t>IRIs are defined similarly to URIs in <xref target="RFC3986"/>,
but the class of unreserved characters is extended by
adding the characters of the UCS (Universal Character Set,
<xref target="ISO10646"/>) beyond U+007F, subject to the limitations given
in the syntax rules below and in <xref target="limitations"/>.</t>

<t>Otherwise, the syntax and use of components and reserved characters is
the same as that in <xref target="RFC3986"/>. All the operations defined in
<xref target="RFC3986"/>, such as the resolution of relative references, can be
applied to IRIs by IRI-processing software in exactly the same way as they are for URIs by URI-processing software.</t>

<t>Characters outside the US-ASCII repertoire are not reserved and therefore
MUST NOT be used for syntactical
purposes, such as to delimit components in newly defined schemes. For
example, U+00A2, CENT SIGN, is not allowed as a delimiter in IRIs,
because it is in the 'iunreserved' category. This is similar to the fact that it is
not possible to use '-' as a delimiter in URIs, because it is in the
'unreserved' category.</t>
</section>

<section title="ABNF for IRI References and IRIs" anchor="abnf">
<t>Although it might be possible to define IRI references and IRIs merely by
their transformation to URI references and URIs, they can also be
accepted and processed directly. Therefore, an ABNF definition for
IRI references (which are the most general concept and the start of the
grammar) and IRIs is given here. The syntax of this ABNF is described in
<xref target="STD68"/>. Character numbers are taken from the UCS,
without implying any actual binary encoding. Terminals in the ABNF
are characters, not bytes.</t>
<t>The following grammar closely follows the URI grammar in
<xref target="RFC3986"/>, except that the range of unreserved characters
is expanded to include UCS characters, with the restriction that private
UCS characters can occur only in query parts. The
grammar is split into two parts: Rules that differ from <xref target="RFC3986"/>
because of the above-mentioned expansion, and rules that are the same
as those in <xref target="RFC3986"/>. For rules that are different than those in
<xref target="RFC3986"/>, the names of the non-terminals have been
changed as follows. If the non-terminal contains 'URI', this has
been changed to 'IRI'. Otherwise, an 'i' has been prefixed.</t>

<!--
for line length measuring in artwork (max 72 chars, three chars at start):
      1         2         3         4         5         6         7
456789012345678901234567890123456789012345678901234567890123456789012
-->
<figure>
<preamble>The following rules are different from those in <xref target="RFC3986"/>:</preamble>
<artwork>
IRI            = scheme ":" ihier-part [ "?" iquery ]
                 [ "#" ifragment ]

ihier-part     = "//" iauthority ipath-abempty
               / ipath-absolute
               / ipath-rootless
               / ipath-empty

IRI-reference  = IRI / irelative-ref

absolute-IRI   = scheme ":" ihier-part [ "?" iquery ]

irelative-ref  = irelative-part [ "?" iquery ] [ "#" ifragment ]

irelative-part = "//" iauthority ipath-abempty
               / ipath-absolute
               / ipath-noscheme
               / ipath-empty

iauthority     = [ iuserinfo "@" ] ihost [ ":" port ]
iuserinfo      = *( iunreserved / pct-encoded / sub-delims / ":" )
ihost          = IP-literal / IPv4address / ireg-name

ireg-name      = *( iunreserved / pct-encoded / sub-delims )

ipath          = ipath-abempty   ; begins with "/" or is empty
               / ipath-absolute  ; begins with "/" but not "//"
               / ipath-noscheme  ; begins with a non-colon segment
               / ipath-rootless  ; begins with a segment
               / ipath-empty     ; zero characters

ipath-abempty  = *( "/" isegment )
ipath-absolute = "/" [ isegment-nz *( "/" isegment ) ]
ipath-noscheme = isegment-nz-nc *( "/" isegment )
ipath-rootless = isegment-nz *( "/" isegment )
ipath-empty    = 0&lt;ipchar&gt;

isegment       = *ipchar
isegment-nz    = 1*ipchar
isegment-nz-nc = 1*( iunreserved / pct-encoded / sub-delims
                     / "@" )
               ; non-zero-length segment without any colon ":"                      

ipchar         = iunreserved / pct-encoded / sub-delims / ":"
               / "@"
 
iquery         = *( ipchar / iprivate / "/" / "?" )

ifragment      = *( ipchar / "/" / "?" )

iunreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~" / ucschar

ucschar        = %xA0-D7FF / %xF900-FDCF / %xFDF0-FFEF
               / %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD
               / %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD
               / %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD
               / %xA0000-AFFFD / %xB0000-BFFFD / %xC0000-CFFFD
               / %xD0000-DFFFD / %xE1000-EFFFD

iprivate       = %xE000-F8FF / %xE0000-E0FFF / %xF0000-FFFFD
               / %x100000-10FFFD
</artwork>
</figure>

<t>Some productions are ambiguous. The "first-match-wins" (a.k.a. "greedy")
algorithm applies. For details, see <xref target="RFC3986"/>.</t>

<figure>
<preamble>The following rules are the same as those in <xref target="RFC3986"/>:</preamble>
<artwork>
scheme         = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
 
port           = *DIGIT
 
IP-literal     = "[" ( IPv6address / IPvFuture  ) "]"
 
IPvFuture      = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
 
IPv6address    =                            6( h16 ":" ) ls32
               /                       "::" 5( h16 ":" ) ls32
               / [               h16 ] "::" 4( h16 ":" ) ls32
               / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
               / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
               / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
               / [ *4( h16 ":" ) h16 ] "::"              ls32
               / [ *5( h16 ":" ) h16 ] "::"              h16
               / [ *6( h16 ":" ) h16 ] "::"
               
h16            = 1*4HEXDIG
ls32           = ( h16 ":" h16 ) / IPv4address

IPv4address    = dec-octet "." dec-octet "." dec-octet "." dec-octet

dec-octet      = DIGIT                 ; 0-9
               / %x31-39 DIGIT         ; 10-99
               / "1" 2DIGIT            ; 100-199
               / "2" %x30-34 DIGIT     ; 200-249
               / "25" %x30-35          ; 250-255
            
pct-encoded    = "%" HEXDIG HEXDIG
 
unreserved     = ALPHA / DIGIT / "-" / "." / "_" / "~"
reserved       = gen-delims / sub-delims
gen-delims     = ":" / "/" / "?" / "#" / "[" / "]" / "@"
sub-delims     = "!" / "$" / "&amp;" / "'" / "(" / ")"
               / "*" / "+" / "," / ";" / "="
</artwork></figure>
<t>This syntax does not support IPv6 scoped addressing zone identifiers.</t>
</section>

</section>


<section title="Relationship between IRIs and URIs" anchor="iriuri">

<t>IRIs are meant to replace URIs in identifying resources within new versions of protocols,
formats, and software components that use a UCS-based character repertoire.
These protocols and components may never need to use URIs directly,
especially when the resource identifier is used simply for identification
purposes. However, when the resource identifier is used for resource retrieval,
it is in many cases necessary to determine the associated URI, because
retrieval mechanisms are only defined for URIs. 
When used to access a resource, the meaning of an IRI SHOULD be
the same as the meaning of the equivalent URI. This relationship
insures that the resources identified continue to be also available to URI-based
software. 
</t>

<t>This mapping has two purposes:</t>

<t>
<list style="hanging">
<t hangText="Syntactical.">Many URI schemes and components define additional
     syntactical restrictions not captured in <xref target="abnf"/>.
     Scheme-specific restrictions are applied to IRIs by converting
     IRIs to URIs and checking the URIs against the scheme-specific
     restrictions.</t>
<t hangText="Interpretational.">URIs are used to identify resources in various ways. 
     IRIs also identify resources; an IRI identifies the same resource 
as does URI that it maps to. In some contexts, it may actually not be 
  necessary to map the IRI to a URI to determine the resource it identifies (see <xref target="equivalence"/>).
     However, when an IRI is used for resource retrieval, the resource that the IRI
     locates is the same as the one located by the URI obtained after
     converting the IRI according to the procedure defined below.
     For this reason, there is no separate definition of resolution for IRIs.</t>
</list></t>

<section title="Mapping of IRIs to URIs" anchor="mapping">

<t>This section defines how to map IRI-related protocol elements
to strings in the URI character set. This mapping is intended for
mapping  IRIs to URIs, IRI references and URI references, as
well as to components thereof (for example, fragment identifiers).</t>
<t>Note that <xref target="LEIRIHREF"/> describes variants of this algorithm used in some applications for mappings related protocol elements.</t>

<t>The mapping is defined through an algorithm: </t>

<t><list style="hanging">
<t hangText="Step 1.">Generate a UCS character sequence from
the original IRI format.
This step has the following three variants, depending on the form of the input:<list style="hanging">
<t hangText="a.">
If the IRI is written on paper, read aloud, or
otherwise represented as a sequence of characters independent of any
character encoding,
represent the IRI as a sequence of characters from the UCS
normalized according to Normalization Form C (NFC, <xref target="UTR15"/>).</t>

<t hangText="b.">
If the IRI is in some digital representation
(e.g., an octet stream) in some known non-Unicode character encoding,
convert the IRI to a sequence of characters from the UCS. The resulting sequence of characters SHOULD be 
normalized using NFC.</t>

<t hangText="c.">
If the IRI is in a Unicode-based character encoding (for example, UTF-8 or UTF-16),
do not normalize (see <xref target="normalization"/> for details). Apply the next steps directly to the encoded Unicode character sequence.</t>
</list></t>

<t hangText="Step 2." anchor="Step2">
   For each character which is in either 'ucschar' or 'iprivate', apply
   steps 2.1 through 2.3 below.
<list style="hanging">
<t hangText="2.1.">Convert the character to a sequence of one or more octets
      using UTF-8 <xref target="RFC3629"/>.</t>
<t hangText="2.2.">Convert each octet to %HH, where HH is the hexadecimal
      notation of the octet value. Note that this is identical to the
      percent-encoding mechanism in Section 2.1 of <xref target="RFC3986"/>.
      To reduce variability, the hexadecimal notation SHOULD use uppercase letters.</t>
<t hangText="2.3.">Replace the original character with the resulting character
      sequence (i.e., a sequence of %HH triplets).</t>
</list></t>
</list></t>

<t>The above mapping, when applied a valid IRI, produces a URI fully conforming to
<xref target="RFC3986"/>. The mapping is also an identity transformation for URIs
and is idempotent; applying the mapping a second time will not change
anything. Every URI is by definition an IRI.</t>

<t>Systems accepting IRIs MAY convert the ireg-name
component of an IRI as follows (before step 2 above) for schemes
known to use domain names in ireg-name, if the
scheme definition does not allow percent-encoding for ireg-name:
Replace the ireg-name part of the IRI by the part converted using
the ToASCII operation specified in Section 4.1 of <xref target="RFC3490"/>
on each dot-separated label, and by using U+002E (FULL STOP) as a label
separator, with the flag UseSTD3ASCIIRules set to TRUE, and with the flag
AllowUnassigned set to FALSE for creating IRIs and set to TRUE otherwise.
The ToASCII operation may fail, but this would mean that the IRI cannot
be resolved. This conversion SHOULD be used when the goal is to
maximize interoperability with legacy URI resolvers.
For example, the IRI<vspace/>"http://r&amp;#xE9;sum&amp;#xE9;.example.org"<vspace/>may be converted to<vspace/>"http://xn--rsum-bpad.example.org"<vspace/>instead of<vspace/>"http://r%C3%A9sum%C3%A9.example.org".</t>
<t>An IRI with a scheme that is known to use domain names in ireg-name,
but where the scheme definition does not allow percent-encoding for ireg-name,
meets scheme-specific restrictions if either the straightforward
conversion or the conversion using the ToASCII operation on ireg-name
result in an URI that meets the scheme-specific restrictions.</t><t>Such an IRI
resolves to the URI obtained after converting the IRI and uses the ToASCII operation on ireg-name. Implementations do not have  to
do this conversion as long as they produce the same result.</t>
<t><list style="hanging">
<t hangText="Note:">The difference between variants b and c
in step 1 (using normalization with NFC, versus not using any normalization) accounts for the
fact that in many non-Unicode character encodings, some text
cannot be represented directly. For example, the word "Vietnam" is
natively written "Vi&amp;#x1EC7;t Nam" (containing a LATIN SMALL
LETTER E WITH CIRCUMFLEX AND DOT BELOW) in NFC, but a direct
transcoding from the windows-1258 character encoding leads to
"Vi&amp;#xEA;&amp;#x323;t Nam" (containing a LATIN SMALL LETTER E WITH CIRCUMFLEX
followed by a COMBINING DOT BELOW). Direct transcoding
of other 8-bit encodings of Vietnamese may lead to other
representations.</t>
<t hangText="Note:">The uniform treatment of the whole IRI in step 2 is important to make processing independent of URI scheme.
See <xref target="Gettys"/> for an in-depth discussion.</t>
<t hangText="Note:">In practice, whether the general mapping (steps 1 and 2) or the ToASCII operation of <xref target="RFC3490"/> is used for ireg-name will not be
noticed if mapping from IRI to URI and resolution is tightly
integrated (e.g., carried out in the same user agent). But conversion
using <xref target="RFC3490"/> may be able to better deal with
backwards compatibility issues in case mapping and resolution
are separated, as in the case of using an HTTP proxy.</t>
<t hangText="Note:">Internationalized Domain Names may be contained in parts
of an IRI other than the ireg-name part.
It is the responsibility of scheme-specific
implementations (if the Internationalized Domain Name is part of the
scheme syntax) or of server-side implementations (if the Internationalized
Domain Name is part of 'iquery') to apply the necessary conversions
at the appropriate point. Example: Trying to validate the Web page at<vspace/>
http://r&amp;#xE9;sum&amp;#xE9;.example.org would lead to an IRI of<vspace/>
http://validator.w3.org/check?uri=http%3A%2F%2Fr&amp;#xE9;sum&amp;#xE9;.<vspace/>example.org,
which would convert to a URI of<vspace/>
http://validator.w3.org/check?uri=http%3A%2F%2Fr%C3%A9sum%C3%A9.<vspace/>example.org.
The server side implementation would be responsible for making the necessary
conversions to be able to retrieve the Web page.</t>

</list></t>

<t>Systems accepting IRIs MAY also deal with the printable characters
in US-ASCII that are not allowed in URIs, namely "&lt;", "&gt;", '"', space,
"{", "}", "|", "\", "^", and "`", in step 2 above. If these characters are
found but are not converted, then the conversion SHOULD fail. Protocols and formats that have used earlier definitions of IRIs
including these characters MAY require percent-encoding of these characters
as a preprocessing step to extract the actual IRI from a given field.
This preprocessing MAY also be used by applications allowing the user
to enter an IRI.
Please note that the number sign ("#"), the percent sign ("%"), and the
square bracket characters ("[", "]")
are not part of the above list and MUST NOT be converted.</t>

<t><list style="hanging"> 
<t hangText="Note:">In this process (in step 2.3), characters allowed in URI
references and existing percent-encoded sequences are not encoded further.
(This mapping is similar to, but different from, the encoding applied
when arbitrary content is included in some part of a URI.)
For example, an IRI of
<vspace/>"http://www.example.org/red%09ros&amp;#xE9;#red"
(in XML notation) is converted to
<vspace/>"http://www.example.org/red%09ros%C3%A9#red", not to
something like
<vspace/>"http%3A%2F%2Fwww.example.org%2Fred%2509ros%C3%A9%23red".</t>

<t hangText="Note:">Some older software transcoding to UTF-8 may produce
illegal output for some input, in particular for characters outside
the BMP (Basic Multilingual Plane). As an example, for the IRI with non-BMP characters (in XML Notation):
<vspace/>"http://example.com/&amp;#x10300;&amp;#x10301;&amp;#x10302";
<vspace/>which contains the first three letters of the Old Italic alphabet,
the correct conversion to a URI is
<vspace/>"http://example.com/%F0%90%8C%80%F0%90%8C%81%F0%90%8C%82"</t>
</list></t>


</section>

<section title="Converting URIs to IRIs" anchor="URItoIRI">
<t>In some situations, converting a URI into an
equivalent IRI may be desirable. This section gives a procedure for this conversion.
The conversion described in this section
will always result in an IRI that maps back to the URI used
as an input for the conversion (except for potential case differences
in percent-encoding and for potential percent-encoded unreserved characters).
However, the IRI resulting from this conversion
may not be exactly the same as the original IRI (if there ever was one).</t>
<t>URI-to-IRI conversion removes percent-encodings, but not all
percent-encodings can be eliminated. There are several reasons for this:</t>

<t><list style="hanging">
<t hangText="1.">Some percent-encodings are necessary to distinguish
    percent-encoded and unencoded uses of reserved characters.</t>

<t hangText="2.">Some percent-encodings cannot be interpreted as sequences
    of UTF-8 octets.<vspace blankLines="1"/>
    (Note: The octet patterns of UTF-8 are highly regular.
    Therefore, there is a very high probability, but no guarantee,
    that percent-encodings that can be interpreted as sequences of UTF-8
    octets actually originated from UTF-8. For a detailed discussion,
    see <xref target="Duerst97"/>.)</t>

<t hangText="3.">The conversion may result in a character that is not
    appropriate in an IRI. See <xref target="abnf"/>, <xref target="visual"/>,
      and <xref target="limitations"/> for further details.</t>
</list></t>
<t>Conversion from a URI to an IRI is done by using the following steps
(or any other algorithm that produces the same result):

<list style="hanging">
<t hangText="1.">Represent the URI as a sequence of octets in US-ASCII.</t>
<t hangText="2.">Convert all percent-encodings ("%" followed by two hexadecimal
      digits) to the corresponding octets, except those corresponding to "%", characters in "reserved",
      and characters in US-ASCII not allowed in URIs.</t>
<t hangText="3.">Re-percent-encode any octet produced in step 2 that is not part of a
      strictly legal UTF-8 octet sequence.</t>
<t hangText="4.">Re-percent-encode all octets produced in step 3 that in UTF-8 represent
      characters that are not appropriate according to <xref target="abnf"/>,
      <xref target="visual"/>, and <xref target="limitations"/>.</t>
<t hangText="5.">Interpret the resulting octet sequence as a sequence of characters
      encoded in UTF-8.</t>
</list>
This procedure will convert as many percent-encoded characters as
possible to characters in an IRI. Because there are some choices
when step 4 is applied (see <xref target="limitations"/>), results may vary.</t>
<t>Conversions from URIs to IRIs MUST NOT use any character encoding other than
UTF-8 in steps 3 and 4, even if it might be possible to guess from the context
that another character encoding than UTF-8 was used in the URI.
For example, the URI "http://www.example.org/r%E9sum%E9.html" might with
some guessing be interpreted to contain two e-acute characters encoded as
iso-8859-1. It must not be converted to an IRI containing these e-acute
characters. Otherwise, in the future the IRI will be mapped to
"http://www.example.org/r%C3%A9sum%C3%A9.html", which is a different URI
from "http://www.example.org/r%E9sum%E9.html".</t>

<section title="Examples">
<t>This section shows various examples of converting URIs to IRIs.
Each example shows the
result after each of the steps 1 through 5 is applied. XML Notation is
used for the final result.
Octets are  
            denoted by "&lt;" followed by two hexadecimal digits followed by "&gt;".</t>
<t>The following example contains the sequence "%C3%BC", which is a strictly
legal UTF-8 sequence, and which is converted into the actual character
U+00FC, LATIN SMALL LETTER U WITH DIAERESIS (also known as u-umlaut).
<list style="hanging">
<t hangText="1.">http://www.example.org/D%C3%BCrst</t>
<t hangText="2.">http://www.example.org/D&lt;c3&gt;&lt;bc&gt;rst</t>
<t hangText="3.">http://www.example.org/D&lt;c3&gt;&lt;bc&gt;rst</t>
<t hangText="4.">http://www.example.org/D&lt;c3&gt;&lt;bc&gt;rst</t>
<t hangText="5.">http://www.example.org/D&amp;#xFC;rst</t>
</list>
</t>
<t>The following example contains the sequence "%FC", which might represent U+00FC,
LATIN SMALL LETTER U WITH DIAERESIS, in the<vspace/>iso-8859-1 character encoding.
(It might represent other characters in other character encodings. For example, the octet
&lt;fc&gt; in iso-8859-5 represents U+045C, CYRILLIC SMALL LETTER KJE.)
Because &lt;fc&gt; is not part of a
strictly legal UTF-8 sequence, it is re-percent-encoded in step 3.<list style="hanging">
<t hangText="1.">http://www.example.org/D%FCrst</t>
<t hangText="2.">http://www.example.org/D&lt;fc&gt;rst</t>
<t hangText="3.">http://www.example.org/D%FCrst</t>
<t hangText="4.">http://www.example.org/D%FCrst</t>
<t hangText="5.">http://www.example.org/D%FCrst</t>
</list>
</t>
<t>The following example contains "%e2%80%ae", which is the percent-encoded<vspace/>UTF-8
character encoding of U+202E, RIGHT-TO-LEFT OVERRIDE. <xref target="visual"/>
forbids the direct use of this character in an IRI. Therefore, the
corresponding octets are re-percent-encoded in step 4. This example shows
that the case (upper- or lowercase) of letters used in percent-encodings may not be preserved.
The example also contains a punycode-encoded domain name label (xn--99zt52a),
which is not converted.
<list style="hanging">
<t hangText="1.">http://xn--99zt52a.example.org/%e2%80%ae</t>
<t hangText="2.">http://xn--99zt52a.example.org/&lt;e2&gt;&lt;80&gt;&lt;ae&gt;</t>
<t hangText="3.">http://xn--99zt52a.example.org/&lt;e2&gt;&lt;80&gt;&lt;ae&gt;</t>
<t hangText="4.">http://xn--99zt52a.example.org/%E2%80%AE</t>
<t hangText="5.">http://xn--99zt52a.example.org/%E2%80%AE</t>
</list></t>
<t hangText="Note:">Implementations with scheme-specific knowledge MAY convert
punycode-encoded domain name labels to the corresponding characters using the
ToUnicode procedure. Thus, for the example above, the label "xn--99zt52a" may
be converted to U+7D0D U+8C46 (Japanese Natto), leading to the overall
IRI of<vspace/>"http://&amp;#x7D0D;&amp;#x8C46;.example.org/%E2%80%AE".</t>
</section>
</section>
</section>

<section title="Bidirectional IRIs for Right-to-Left Languages" anchor="Bidi">
<t>Some UCS characters, such as those used in the Arabic and Hebrew
scripts, have an inherent right-to-left (rtl) writing direction. IRIs
containing these characters (called bidirectional IRIs or Bidi IRIs)
require additional attention because of the non-trivial relation
between logical representation (used for digital representation and for reading/spelling) and visual representation (used for
display/printing).</t>
<t>Because of the complex interaction between the logical representation,
the visual representation, and the syntax of a Bidi IRI, a balance is
needed between various requirements.
The main requirements are<list style="hanging">
<t hangText="1.">user-predictable conversion between visual and
    logical representation;</t>
<t hangText="2.">the ability to include a wide range of characters
    in various parts of the IRI; and</t>
<t hangText="3.">minor or no changes or restrictions for
      implementations.</t>
</list></t>

<section title="Logical Storage and Visual Presentation" anchor="visual">
<t>When stored or transmitted in digital representation,
bidirectional IRIs MUST be in full logical order and
MUST conform to the IRI syntax rules (which includes the rules
relevant to their scheme). This ensures that bidirectional
IRIs can be processed in the same way as other IRIs.</t>
<t>Bidirectional IRIs MUST be rendered by using the
Unicode Bidirectional Algorithm <xref target="UNIV4"/>, <xref target="UNI9"/>.
Bidirectional IRIs MUST be rendered in the same way as they would
be if they were in a left-to-right embedding; i.e., as if
they were preceded by U+202A, LEFT-TO-RIGHT EMBEDDING (LRE),
and followed by U+202C, POP DIRECTIONAL FORMATTING (PDF).
Setting the embedding direction can also be done in a
higher-level protocol (e.g., the dir='ltr' attribute in HTML).</t>
<t>There is no requirement to use the above embedding
if the display is still the same without the embedding. For
example, a bidirectional IRI in a text with left-to-right base
directionality (such as used for English or Cyrillic) that is
preceded and followed by whitespace and  strong left-to-right
characters does not need an embedding.
Also, a bidirectional relative IRI reference that only contains strong
right-to-left characters and weak characters and that starts and
ends with a strong right-to-left character and appears in a text with
right-to-left base directionality (such as used for Arabic or Hebrew)
and is preceded and followed by whitespace and strong characters
does not need an embedding.</t>
<t>In some other cases, using U+200E, LEFT-TO-RIGHT MARK (LRM),
may be sufficient to force the correct display behavior.
However, the details of the Unicode Bidirectional algorithm are
not always easy to understand. Implementers are strongly advised
to err on the side of caution and to use embedding in all cases
where they are not completely sure that the display behavior
is unaffected without the embedding.</t>
<t>The Unicode Bidirectional Algorithm (<xref target="UNI9"/>,
section 4.3) permits higher-level protocols to influence bidirectional
rendering. Such changes by higher-level protocols MUST NOT be used
if they change the rendering of IRIs.</t>
<t>The bidirectional formatting characters that may be used before or
after the IRI to ensure correct display are not themselves part of the IRI.
IRIs MUST NOT contain bidirectional formatting characters (LRM,
RLM, LRE, RLE, LRO, RLO, and PDF). They affect the visual rendering
of the IRI but do not appear themselves. It would therefore
not be possible to input an IRI with such characters correctly.</t>
</section>

<section title="Bidi IRI Structure" anchor="bidi-structure">
<t>The Unicode Bidirectional Algorithm is designed mainly for running text.
To make sure that it does not affect the rendering of bidirectional IRIs
too much, some restrictions on bidirectional IRIs are necessary. These
restrictions are given in terms of delimiters (structural characters,
mostly punctuation such as "@", ".", ":", and<vspace/>"/") and components (usually
consisting mostly of letters and digits).</t>

<t>The following syntax rules from <xref target="abnf"/> correspond to components
for the purpose of Bidi behavior: iuserinfo, ireg-name, isegment, isegment-nz,
isegment-nz-nc, ireg-name, iquery, and ifragment.
</t>
<t>Specifications that define the syntax of any of the above components
MAY divide them further and define smaller parts to be components according
to this document. As an example, the restrictions of <xref target="RFC3490"/> on
bidirectional domain names correspond to treating each label of a domain
name as a component for schemes with ireg-name as a domain name.
Even where the components are not defined formally, it may be helpful to
think about some syntax in terms of components and to apply the relevant restrictions.
For example, for the usual name/value syntax in query parts, it is convenient to
treat each name and each value as a component. As another example, the
extensions in a resource name can be treated as separate components.</t>

<t>For each component, the following restrictions apply:</t>
<t>
<list style="hanging">
<t hangText="1.">A component SHOULD NOT use both right-to-left and left-to-right
characters.</t>
<t hangText="2.">A component using right-to-left characters SHOULD start and end 
with right-to-left characters.</t>
</list>
</t>
<t>The above restrictions are given as shoulds, rather than as musts.
For IRIs that are never presented visually, they are not relevant.
However, for IRIs in general, they are very important to ensure
consistent conversion between visual presentation and logical
representation, in both directions.
</t>
<t><list style="hanging">
<t hangText="Note:">In some components, the above restrictions may actually be
strictly enforced.
For example, <xref target="RFC3490"></xref> requires that these restrictions apply
to the labels of a host name for those schemes where ireg-name is a host name.
In some other components
(for example, path components) following these restrictions may not be too difficult.
For other components, such as parts of the query part, it may be very difficult
to enforce the restrictions because the values of query parameters may be
arbitrary character sequences.</t></list></t>

<t>If the above restrictions cannot be satisfied otherwise, the affected
component can always be mapped to URI notation as described in
<xref target="mapping"/>. Please note that the whole component has
to be mapped (see also Example 9 below).
</t>
</section>

<section title="Input of Bidi IRIs" anchor="bidiInput">
<t>Bidi input methods MUST generate Bidi IRIs in logical
order while rendering them according to <xref target="visual"/>.
During input, rendering SHOULD be updated after every new character is input to avoid end-user confusion.</t>
</section>

<section title="Examples">
<t>This section gives examples of bidirectional IRIs, in Bidi Notation.
It shows legal IRIs with the relationship between logical and
visual representation and explains how certain phenomena in
this relationship may look strange to somebody not familiar
with bidirectional behavior, but familiar to users of Arabic
and Hebrew. It also shows what happens if the
restrictions given in <xref target="bidi-structure"/> are not
followed. The examples below can be seen at <xref target="BidiEx"/>,
in Arabic, Hebrew, and Bidi Notation variants.</t>

<t>To read the bidi text in the examples, read the visual
representation from left to right until you encounter a block of
rtl text. Read the rtl block (including slashes and other special
characters) from right to left, then continue at the next unread ltr 
character.</t>

<t>Example 1: A single component with rtl
characters is inverted:
<vspace/>Logical representation: "http://ab.CDEFGH.ij/kl/mn/op.html"<vspace/>Visual representation: "http://ab.HGFEDC.ij/kl/mn/op.html"<vspace/>
Components can be read one by one, and each component can be
read in its natural direction.</t>

<t>Example 2: More than one consecutive component with rtl
characters is inverted as a whole:
<vspace/>Logical representation: "http://ab.CDE.FGH/ij/kl/mn/op.html"<vspace/>Visual representation: "http://ab.HGF.EDC/ij/kl/mn/op.html"<vspace/>
A sequence of rtl components is read rtl, in the same way
as a sequence of rtl words is read rtl in a bidi text.</t>

<t>Example 3: All components of an IRI (except for the scheme) are rtl.
All rtl components are inverted overall:
<vspace/>Logical representation: "http://AB.CD.EF/GH/IJ/KL?MN=OP;QR=ST#UV"<vspace/>Visual representation: "http://VU#TS=RQ;PO=NM?LK/JI/HG/FE.DC.BA"<vspace/>
The whole IRI (except the scheme) is read rtl. Delimiters
between rtl components stay between the respective components;
delimiters between ltr and rtl components don't move.</t>

<t>Example 4: Each of several sequences of rtl components is
inverted on its own:
<vspace/>Logical representation: "http://AB.CD.ef/gh/IJ/KL.html"<vspace/>Visual representation: "http://DC.BA.ef/gh/LK/JI.html"<vspace/>
Each sequence of rtl components is read rtl, in the same way
as each sequence of rtl words in an ltr text is read rtl.</t>

<t>Example 5: Example 2, applied to components of different
kinds:
<vspace/>Logical representation: "http://ab.cd.EF/GH/ij/kl.html"
<vspace/>Visual representation: "http://ab.cd.HG/FE/ij/kl.html"<vspace/>
The inversion of the domain name label and the path component
may be unexpected, but it is consistent with other bidi behavior.
For reassurance that the domain component really is "ab.cd.EF",
it may be helpful to read aloud the visual representation following
the bidi algorithm. After "http://ab.cd." one reads the RTL block  
"E-F-slash-G-H", which corresponds to the logical representation.
</t>

<t>Example 6: Same as Example 5, with more rtl components:
<vspace/>Logical representation: "http://ab.CD.EF/GH/IJ/kl.html"<vspace/>Visual representation: "http://ab.JI/HG/FE.DC/kl.html"<vspace/>
The inversion of the domain name labels and the path components
may be easier to identify because the delimiters also move.</t>

<t>Example 7: A single rtl component includes digits:
<vspace/>Logical representation: "http://ab.CDE123FGH.ij/kl/mn/op.html"<vspace/>Visual representation: "http://ab.HGF123EDC.ij/kl/mn/op.html"<vspace/>
Numbers are written ltr in all cases but are treated as
an additional embedding inside a run of rtl characters. This
is completely consistent with usual bidirectional text.</t>

<t>Example 8 (not allowed): Numbers are at the start or end of an rtl component:<vspace/>Logical representation: "http://ab.cd.ef/GH1/2IJ/KL.html"<vspace/>Visual representation: "http://ab.cd.ef/LK/JI1/2HG.html"<vspace/>
The sequence "1/2" is interpreted by the bidi algorithm
as a fraction, fragmenting the components and leading to
confusion. There are other characters that are interpreted
in a special way close to numbers; in particular, "+", "-",
"#", "$", "%", ",", ".", and ":".</t>

<t>Example 9 (not allowed): The numbers in the previous
example are percent-encoded:
<vspace/>Logical representation:    "http://ab.cd.ef/GH%31/%32IJ/KL.html",<vspace/>Visual representation: "http://ab.cd.ef/LK/JI%32/%31HG.html"</t>

<t>Example 10 (allowed but not recommended):
<vspace/>Logical representation: "http://ab.CDEFGH.123/kl/mn/op.html"<vspace/>Visual representation: "http://ab.123.HGFEDC/kl/mn/op.html"<vspace/>
Components consisting
of only numbers are allowed (it would be rather difficult to prohibit
them), but these may interact with adjacent RTL components in ways that are
not easy to predict.</t>
<t>Example 11 (allowed but not recommended):
<vspace/>Logical representation: "http://ab.CDEFGH.123ij/kl/mn/op.html"<vspace/>Visual representation: "http://ab.123.HGFEDCij/kl/mn/op.html"<vspace/>
Components consisting of numbers and  left-to-right characters are 
   allowed, but these may interact with adjacent RTL components in ways 
   that are not easy to predict.</t></section>

</section>

<section title="Normalization and Comparison" anchor="equivalence">
<t hangText="Note:"><list style="hanging"><t>Note: The structure and much of the material for this
  section is taken from section 6 of <xref target="RFC3986"></xref>; the
  differences are due to the specifics of IRIs.</t></list></t><t>One of the most common operations on IRIs is simple comparison: Determining
whether two IRIs are equivalent without using the IRIs or the mapped URIs to access
their respective resource(s). A comparison is performed whenever a response
cache is accessed, a browser checks its history to color a link, or an XML
parser processes tags within a namespace. Extensive normalization prior to
comparison of IRIs may be used by spiders and indexing engines to prune a
search space or reduce duplication of request actions and
response storage.</t>

<t>IRI comparison is performed for some particular purpose. Protocols or implementations that compare IRIs for  different purposes will often be subject to differing
design trade-offs in regards to how much effort should be spent in
reducing aliased identifiers. This section describes various methods
that may be used to compare IRIs, the trade-offs between them, and the types
of applications that might use them.</t>

<section title="Equivalence">
<t>Because IRIs exist to identify resources, presumably they should be considered
equivalent when they identify the same resource. However, this definition of
equivalence is not of much practical use, as there is no
way for an implementation to compare two resources unless it has full knowledge or control of them. For this reason, determination of equivalence or difference of IRIs
is based on string comparison, perhaps augmented by reference to additional
rules provided by URI scheme definitions.
We use the terms "different" and
"equivalent" to describe the possible outcomes of such comparisons, but there
are many application-dependent versions of equivalence.</t>

<t>Even though it is possible to determine that two IRIs are equivalent,
IRI comparison is not sufficient to determine whether two IRIs identify different
resources. For example, an owner of two different domain names
could decide to serve the same resource from both, resulting in two
different IRIs. Therefore, comparison methods are designed to minimize
false negatives while strictly avoiding false positives.</t>

<t>In testing for equivalence, applications should not directly compare
relative references; the references should be converted to their respective
target IRIs before comparison. When IRIs are compared to select (or avoid) a network action, such as
retrieval of a representation, fragment components (if any)
should be excluded from the comparison.</t>

<t>Applications using IRIs as identity tokens with no relationship to a
protocol MUST use the Simple String Comparison (see <xref target="stringcomp"></xref>).
All other applications MUST select one of the comparison practices from
the Comparison Ladder (see <xref target="ladder"></xref> or, after IRI-to-URI conversion,
select one of the comparison practices from the URI comparison
ladder in <xref target="RFC3986"></xref>, section 6.2).</t>
</section>
<section title="Preparation for Comparison">



<t>Any kind of  IRI comparison REQUIRES that all escapings or encodings in the protocol or format that carries an IRI are resolved. This is usually done when the protocol or format is parsed. Examples of such escapings or encodings are entities and numeric character references  in <xref target="HTML4"></xref> and <xref target="XML1"></xref>. As an example, "http://example.org/ros&amp;eacute;" (in HTML), "http://example.org/ros&amp;#233;" (in HTML or XML), and  <vspace/>"http://example.org/ros&amp;#xE9;" (in HTML or XML) are all resolved into what is denoted in this document (see <xref target="sec-Notation"></xref>) as "http://example.org/ros&amp;#xE9;" (the "&amp;#xE9;" here standing for the actual e-acute character, to compensate for the fact that this document cannot contain non-ASCII characters).</t><t>Similar considerations apply to encodings such as Transfer Codings in HTTP (see <xref target="RFC2616"></xref>) and Content Transfer Encodings in MIME (<xref target="RFC2045"></xref>), although in these cases, the encoding is based not on characters but on octets, and additional care is required to make sure that characters, and not just arbitrary octets, are compared (see <xref target="stringcomp"></xref>).</t></section>

<section title="Comparison Ladder" anchor="ladder">
<t>In practice, a variety of methods are used, to test
IRI equivalence. These methods fall into a range
distinguished by the amount of processing required
and the degree to which the probability of false
negatives is reduced. As noted above, false negatives
cannot be eliminated. In practice, their probability can
be reduced, but this reduction requires more processing
and is not cost-effective for all applications.</t>
<t>If this range of comparison practices is considered
as a ladder, the following discussion will climb the ladder,
starting with practices that are cheap but have
a relatively higher chance of producing false negatives,
and proceeding to those that have higher computational
cost and lower risk of false negatives.</t>

<section title="Simple String Comparison" anchor="stringcomp">
<t>If two IRIs, when considered as character strings,
are identical, then it is safe to conclude that they are equivalent.
This type of equivalence test has very low computational
cost and is in wide use in a variety of applications,
particularly in the domain of parsing. It is also used when a definitive
answer to the question of IRI equivalence is
needed that is independent of the scheme used and that
can be calculated quickly and without accessing a
network. An example of such a case is XML Namespaces (<xref target="XMLNamespace"></xref>).</t>
<t>Testing strings for equivalence requires some basic precautions.
This procedure is often referred to as "bit-for-bit" or "byte-for-byte" comparison,
which is potentially misleading. Testing strings for equality is
normally based on pair comparison of the characters
that make up the strings, starting from the first and
proceeding until both strings are exhausted and all
characters are found to be equal, until a pair of characters
compares unequal, or until one of the strings is exhausted
before the other.</t>
<t>This character comparison requires that each pair
of characters be put in comparable encoding form. For
example, should one IRI be stored in a byte array in
UTF-8 encoding form and the second in a UTF-16
encoding form, bit-for-bit comparisons applied naively
will produce errors. It is better to speak of equality on
a character-for-character rather than on a byte-for-byte or  bit-for-bit basis.
In practical terms, character-by-character comparisons should be done
codepoint by codepoint after conversion to a common character encoding form.
When comparing character by character, the comparison function MUST NOT map IRIs to
URIs, because such a mapping would create additional
spurious equivalences. It follows that an IRI SHOULD
NOT be modified when being transported if there is
any chance that this IRI might be used as an identifier.</t>
<t>False negatives are caused by the production and
use of IRI aliases. Unnecessary aliases can be reduced,
regardless of the comparison method, by consistently
providing IRI references in an already normalized
form (i.e., a form identical to what would be produced
after normalization is applied, as described below).
Protocols and data formats often limit some
IRI comparisons to simple string comparison, based
on the theory that people and implementations will,
in their own best interest, be consistent in providing IRI
references, or at least be consistent enough to negate
any efficiency that might be obtained from further
normalization.</t></section>

<section title="Syntax-Based Normalization">
<figure><preamble>Implementations may use logic based on the definitions provided 
by this specification to reduce the probability of false negatives. This processing
is moderately higher in cost than character-for-character
string comparison. For example, an application using this approach
could reasonably consider the following two IRIs equivalent:</preamble>
<artwork>
   example://a/b/c/%7Bfoo%7D/ros&amp;#xE9;
   eXAMPLE://a/./b/../b/%63/%7bfoo%7d/ros%C3%A9
</artwork></figure>
<t>Web user agents, such as browsers, typically apply this
type of IRI normalization when determining whether
a cached response is available. Syntax-based normalization
includes such techniques as case normalization,
character normalization, percent-encoding normalization,
and removal of dot-segments.</t>

<section title="Case Normalization">
<t>For all IRIs, the hexadecimal digits within a percent-encoding
triplet (e.g., "%3a" versus "%3A") are case-insensitive
and therefore should be normalized to use uppercase letters
for the digits A-F.</t>
<t>When an IRI uses components of the generic syntax, the
component syntax equivalence rules always apply;
namely, that the scheme and US-ASCII only host are case insensitive
and therefore should be normalized to
lowercase. For example, the URI "HTTP://www.EXAMPLE.com/" is equivalent to
"http://www.example.com/". Case equivalence for non-ASCII characters in IRI components that are IDNs are discussed in <xref target="schemecomp"></xref>.
The other generic syntax components are
assumed to be case sensitive unless specifically
defined otherwise by the scheme.</t>
<t>Creating schemes that allow case-insensitive syntax
components containing non-ASCII characters should
be avoided. Case normalization of non-ASCII characters can be
culturally dependent and is always a complex
operation. The only exception concerns non-ASCII host
names for which the character normalization
includes a mapping step derived from case folding.</t>
</section>

<section title="Character Normalization" anchor="normalization">
<t>The Unicode Standard <xref target="UNIV4"></xref> defines various equivalences
between sequences of characters for various
purposes. Unicode Standard Annex #15 <xref target="UTR15"></xref> defines
various Normalization Forms for these
equivalences, in particular Normalization Form C
(NFC, Canonical Decomposition, followed by Canonical
Composition) and Normalization Form KC (NFKC,
Compatibility Decomposition, followed by Canonical
Composition).</t>
<t>Equivalence of IRIs MUST rely on the assumption that
IRIs are appropriately pre-character-normalized
rather than apply character normalization when
comparing two IRIs. The exceptions are conversion from a non-digital form, and conversion from a non-UCS-based character encoding
to a UCS-based character encoding. In these cases, NFC or a normalizing transcoder
using NFC MUST be used for interoperability. To
avoid false negatives and problems with transcoding,
IRIs SHOULD be created by using NFC. Using NFKC
may avoid even more problems; for example, by choosing
half-width Latin letters instead of full-width ones, and
full-width instead of half-width Katakana.</t>


<t>As an example, "http://www.example.org/r&amp;#xE9;sum&amp;#xE9;.html"
(in XML Notation) is in NFC. On the other
hand, "http://www.example.org/re&amp;#x301;sume&amp;#x301;.html"
is not in NFC.</t><t>The former uses precombined e-acute
characters, and the latter uses "e" characters followed
by combining acute accents. Both usages are
defined as canonically equivalent in <xref target="UNIV4"></xref>.</t>
<t><list style="hanging">
<t hangText="Note:">
Because it is unknown how a particular sequence of characters
is being treated with respect to character
normalization, it would be inappropriate to allow third
parties to normalize an IRI arbitrarily. This does not
contradict the recommendation that when a resource is created,
its IRI should be as character normalized as
possible (i.e., NFC or even NFKC). This is similar to the uppercase/lowercase problems.   Some parts of a URI are case insensitive (domain name). For others, it is unclear whether they are case sensitive, case insensitive, or something in between (e.g.,  case sensitive, but with a multiple choice selection if the wrong case is used, instead of a direct negative result).  The best recipe is 
         

      that the creator use a reasonable capitalization and, when  
         

      transferring the URI, capitalization never be changed.</t></list></t>
<t>Various IRI schemes may allow the usage of
Internationalized Domain Names (IDN) <xref target="RFC3490"></xref> either in
the ireg-name part or elsewhere. Character Normalization also applies to IDNs, as discussed in <xref target="schemecomp"></xref>.</t></section>

<section title="Percent-Encoding Normalization">
<t>The percent-encoding mechanism (Section 2.1 of <xref target="RFC3986"></xref>)
is a frequent source of variance among
otherwise identical IRIs. In addition to the case
normalization issue noted above, some IRI producers
percent-encode octets that do not require percent-encoding,
resulting in IRIs that are equivalent to their nonencoded
counterparts. These IRIs should be normalized by decoding
any percent-encoded octet  sequence that
corresponds to an unreserved character, as described
in section 2.3 of <xref target="RFC3986"></xref>.</t>
<t>For actual resolution, differences in percent-encoding
(except for the percent-encoding of reserved
characters) MUST always result in the same resource.
For example, "http://example.org/~user",
"http://example.org/%7euser", and "http://example.org/%7Euser",
must resolve to the same resource.</t>
<t>If this kind of equivalence is to be tested, the
percent-encoding of both IRIs to be compared has to be
aligned; for example, by converting both IRIs to URIs
(see Section 3.1), eliminating escape differences in the
resulting URIs, and making sure that the case of the
hexadecimal characters in the percent-encoding is
always the same (preferably upper case). If the IRI
is to be passed to another application or used further in
some other way, its original form MUST be preserved.
The conversion described here should be performed
only for local comparison.</t></section>

<section title="Path Segment Normalization">
<t>The complete path segments "." and ".." are intended
only for use within relative references (Section 4.1 of
<xref target="RFC3986"></xref>) and are removed as part
of the reference resolution process (Section 5.2 of <xref target="RFC3986"></xref>).
However, some implementations may incorrectly assume
that reference resolution is not necessary when
the reference is already an IRI, and thus fail to remove
dot-segments when they occur in non-relative paths.
IRI normalizers should remove dot-segments by applying
the remove_dot_segments algorithm to the path,
as described in Section 5.2.4 of <xref target="RFC3986"></xref>.</t>
</section>
</section>

<section title="Scheme-Based Normalization" anchor="schemecomp">
<t>The syntax and semantics of IRIs vary from scheme
to scheme, as described by the defining specification
for each scheme. Implementations may use scheme-specific
rules, at further processing cost, to reduce the
probability of false negatives. For example, because the
"http" scheme makes use of an authority component,
has a default port of "80", and defines an empty path
to be equivalent to "/", the following four IRIs are
equivalent:</t>
<figure><artwork>
   http://example.com
   http://example.com/
   http://example.com:/
   http://example.com:80/</artwork></figure>
<t>In general, an IRI that uses the generic syntax for
authority with an empty path should be normalized to a
path of "/". Likewise, an explicit ":port", for which the
port is empty or the default for the scheme, is equivalent to
one where the port and its ":" delimiter are elided
and thus should be removed by scheme-based
normalization. For example, the second IRI above is
the normal form for the "http" scheme.</t>
<t>Another case where normalization varies by scheme
is in the handling of an empty authority component or
empty host subcomponent. For many scheme specifications,
an empty authority or host is considered an
error; for others, it is considered equivalent to "localhost"
or the end-user's host. When a scheme defines a
default for authority and an IRI reference to that default
is desired, the reference should be normalized to an
empty authority for the sake of uniformity, brevity,
and internationalization. If, however, either the userinfo or
port subcomponents are non-empty, then the host should
be given explicitly even if it matches the default.</t>
<t>Normalization should not remove delimiters when their
associated component is empty unless it is licensed to do
so by the scheme specification. For example, the IRI
"http://example.com/?" cannot be assumed to be
equivalent to any of the examples above. Likewise, the
presence or absence of delimiters within a userinfo
subcomponent is usually significant to its interpretation.
The fragment component is not subject to any
scheme-based normalization; thus, two IRIs that differ
only by the suffix "#" are considered different
regardless of the scheme.</t>
<t>Some IRI schemes may allow the usage of
Internationalized Domain Names (IDN) <xref target="RFC3490"></xref> either in
their ireg-name part or elsewhere. When in use in IRIs,
those names SHOULD be validated by using the
ToASCII operation defined in <xref target="RFC3490"></xref>, with the flags
"UseSTD3ASCIIRules" and "AllowUnassigned". An
IRI containing an invalid IDN cannot successfully be resolved.
Validated IDN components of IRIs SHOULD
be character normalized by using the Nameprep process <xref target="RFC3491"></xref>;
however, for legibility purposes, they
SHOULD NOT be converted into ASCII Compatible Encoding (ACE).</t><t>Scheme-based normalization may also consider IDN components and their conversions to punycode as equivalent. As an example, "http://r&amp;#xE9;sum&amp;#xE9;.example.org" may be considered equivalent to
"http://xn--rsum-bpad.example.org".</t><t>Other scheme-specific normalizations are possible.</t>
</section>

<section title="Protocol-Based Normalization">
<t>Substantial effort to reduce the
incidence of false negatives is often cost-effective for web spiders. Consequently, they implement even more aggressive techniques
in IRI comparison. For example, if they
observe that an IRI such as</t>
<figure><artwork>
   http://example.com/data</artwork></figure>
<t>redirects to an IRI differing only in the trailing slash</t>
<figure><artwork>
   http://example.com/data/</artwork></figure>
<t>they will likely regard the two as equivalent in the future.
This kind of technique is only appropriate when
equivalence is clearly indicated by both the result of
accessing the resources and the common conventions
of their scheme's dereference algorithm (in this case,
use of redirection by HTTP origin servers to avoid
problems with relative references).</t></section>
</section>

</section>

<section title="Use of IRIs" anchor="IRIuse">
<section title="Limitations on UCS Characters Allowed in IRIs" anchor="limitations">
<t>This section discusses limitations on characters and
character sequences usable for IRIs beyond those given in <xref target="abnf"/>
and <xref target="visual"/>. The considerations in this
section are relevant when IRIs are created  and when URIs
are converted to IRIs.</t>

<t>
<list style="hanging"><t hangText="a.">The repertoire of characters allowed
    in each IRI component is limited by the definition of that component.
    For example, the definition of the scheme component does not allow
    characters beyond US-ASCII.
    <vspace blankLines="1"/>
    (Note: In accordance with URI practice, generic IRI
    software cannot and should not check for such limitations.)</t>

<t hangText="b.">The UCS contains many areas of characters for which there are
    strong visual look-alikes. Because of the likelihood of
    transcription errors, these also should be avoided. This includes
    the full-width equivalents of Latin characters, half-width
    Katakana characters for Japanese, and many others. It also
    includes many look-alikes of "space", "delims", and "unwise",
    characters excluded in <xref target="RFC3491"/>.</t>
</list>
</t>

<t>Additional information is available from <xref target="UNIXML"/>.
    <xref target="UNIXML"/> is written in the context of running text rather
    than in that of identifiers. Nevertheless, it discusses many of the
    categories of characters not appropriate for IRIs.</t>
</section>

<section title="Software Interfaces and Protocols">

<t>Although an IRI is defined as a sequence of characters,
software interfaces for URIs typically function on sequences of
octets or other kinds of code units. Thus, software interfaces
and protocols MUST define which character encoding is used.</t>

<t>Intermediate software interfaces between IRI-capable components and
URI-only components MUST map the IRIs per <xref target="mapping"/>,
when transferring from IRI-capable to URI-only components. This mapping SHOULD be applied as late as possible. It SHOULD NOT be
applied between components that are known to be able to handle IRIs.</t>
</section>

<section title="Format of URIs and IRIs in Documents and Protocols">
<t>Document formats that transport URIs may have to be upgraded to allow
the transport of IRIs. In cases where the document as a whole
has a native character encoding, IRIs MUST also be encoded in this
character encoding and converted accordingly by a parser or interpreter.
IRI characters not expressible in the native character encoding SHOULD
be escaped by using the escaping conventions of the document format
if such conventions are available. Alternatively, they MAY be percent-encoded
according to <xref target="mapping"/>. For example, in HTML or
XML, numeric character references SHOULD be used. If a document
as a whole has a native character encoding and that character encoding
is not UTF-8, then IRIs MUST NOT be placed into the document in the
UTF-8 character encoding.</t>

<t>Note: Some formats already accommodate IRIs, although they use
different terminology. HTML 4.0 <xref target="HTML4"/> defines the conversion from
IRIs to URIs as error-avoiding behavior. XML 1.0 <xref target="XML1"/>, XLink
<xref target="XLink"/>, XML Schema <xref target="XMLSchema"/>, and specifications
based upon them allow IRIs. Also, it is expected that all relevant new W3C
formats and protocols will be required to handle IRIs <xref target="CharMod"/>.</t>
</section>

<section title="Use of UTF-8 for Encoding Original Characters" anchor="UTF8use">
<t>This section discusses details and gives examples
for point c) in <xref target="Applicability"/>. To be able to
use IRIs, the URI corresponding to the IRI in question has to
encode original characters into octets by using UTF-8.
This can be specified for all URIs of a URI scheme or can apply to individual
URIs for schemes that do not specify how to encode original characters.
It can apply to the whole URI, or only to some part. For background information
on encoding characters into URIs, see also Section 2.5 of <xref target="RFC3986"/>.</t>

<t>For new URI schemes, using UTF-8 is recommended in <xref target="RFC2718"/>.
Examples where UTF-8 is already used are the URN syntax <xref target="RFC2141"/>,
IMAP URLs <xref target="RFC2192"/>, and POP URLs <xref target="RFC2384"/>.
On the other hand, because the HTTP URL scheme does not specify how to encode
original characters, only some HTTP URLs can have corresponding but different IRIs.</t>

<t>For example, for a document with a URI of<vspace/>"http://www.example.org/r%C3%A9sum%C3%A9.html",
it is possible to construct a corresponding IRI (in XML notation,
see <xref target="sec-Notation"/>):
"http://www.example.org/r&amp;#xE9;sum&amp;#xE9;.html" ("&amp;#xE9;" stands for the
e-acute character, and "%C3%A9" is the UTF-8 encoded and percent-encoded representation
of that character). On the other hand, for a document with
a URI of "http://www.example.org/r%E9sum%E9.html", the percent-encoding
octets cannot be converted to actual characters in an IRI,
as the percent-encoding is not based on UTF-8.</t>

<t>This means that for most URI schemes, there is no need to upgrade their
scheme definition in order for them to work with IRIs.
The main case where
upgrading makes sense is when a scheme definition,
or a particular component of a scheme,
is strictly limited to the use of US-ASCII characters
with no provision to include  non-ASCII characters/octets via percent-encoding,
or if a scheme definition currently uses
highly scheme-specific provisions for the encoding of non-ASCII characters.
An example of this is the mailto: scheme <xref target="RFC2368"/>.</t>

<t>This specification does not upgrade any scheme specifications in any
way; this has to be done separately. Also, note that there
is no such thing as an "IRI scheme"; all IRIs use URI schemes, and all
URI schemes can be used with IRIs, even though in some cases only
by using URIs directly as IRIs, without any conversion.</t>

<t>URI schemes can impose restrictions on the syntax of 
scheme-specific URIs; i.e., URIs that are admissible under the 
generic URI syntax <xref target="RFC3986"/> may not be admissible due to 
narrower syntactic constraints imposed by a URI scheme 
specification. URI scheme definitions cannot broaden the 
syntactic restrictions of the generic URI syntax; otherwise, 
it would be possible to generate URIs that satisfied the 
scheme-specific syntactic constraints without satisfying the 
syntactic constraints of the generic URI syntax. However, 
additional syntactic constraints imposed by URI scheme 
specifications are applicable to IRI, as the 
corresponding URI resulting from the mapping defined in 
<xref target="mapping"/> MUST be a valid URI under the syntactic 
restrictions of generic URI syntax and any narrower 
restrictions imposed by the corresponding URI scheme 
specification.</t>

<t>The requirement for the use of UTF-8 applies to all parts of a URI
(with the potential exception of the ireg-name part;
see <xref target="mapping"/>). However, it is possible that
the capability of IRIs to represent a wide range of characters directly
is used just in some parts of the IRI (or IRI reference). The other parts
of the IRI may only contain US-ASCII characters, or they may not be based
on UTF-8. They may be based on another character encoding, or they may
directly encode raw binary data (see also <xref target="RFC2397"/>).</t>

<t>For example, it is possible to have a URI reference of<vspace/>"http://www.example.org/r%E9sum%E9.xml#r%C3%A9sum%C3%A9",
where the document name is encoded in iso-8859-1 based on server
settings, but where the fragment identifier is encoded in UTF-8 according
to <xref target="XPointer"/>. The IRI corresponding to the above
URI would be (in XML notation)<vspace/>"http://www.example.org/r%E9sum%E9.xml#r&amp;#xE9;sum&amp;#xE9;".</t>
<t>Similar considerations apply to query parts. The functionality
of IRIs (namely, to be able to include non-ASCII characters) can
only be used if the query part is encoded in UTF-8.</t>

</section>

<section title="Relative IRI References">
<t>Processing of relative IRI references against a base is handled
straightforwardly; the algorithms of <xref target="RFC3986"/> can
be applied directly, treating the characters additionally allowed
in IRI references in the same way that unreserved characters are in URI
references.</t>

</section>
</section>

<section title="Legacy Extended IRIs (LEIRIs) and Hypertext References" anchor="LEIRIHREF"><t>For historic reasons, some formats have allowed variants of IRIs that are somewhat less restricted in syntax. This section provides definitions and names (<xref target="LEIRI">Legacy Extended IRI or LEIRI</xref>, and <xref target="HTML5">Hypertext Reference or HREF</xref>) for these variants, for easier reference. These variants have to be used with care; they require further processing before being fully interchangeable as IRIs. New protocols and formats SHOULD NOT use Legacy Extended IRIs or Hypertext References. Even where they are allowed, only IRIs fully conforming to the syntax definition in <xref target="abnf"/> SHOULD be created, generated, and used. The provisions in this section also apply to Legacy Extended IRI references and other related forms.</t>
<section title="Legacy Extended IRI Syntax"  anchor="LEIRIspec"><figure>
<preamble>The syntax of Legacy Extended IRIs is the same as that for IRIs, except that ucschar is redefined as follows:</preamble>
<artwork>
   ucschar        = " " / "&lt;" / "&gt;" / '"' / "{" / "}" / "|"
                  / "\" / "^" / "`" / %x0-1F / %x7F-D7FF
                  / %xE000-FFFD / %x10000-10FFFF
</artwork><postamble>The restriction on bidirectional formatting characters in <xref target="visual"></xref> is lifted. The iprivate production becomes redundant.</postamble></figure><t>Likewise, the syntax for Legacy Extended IRI references (LEIRI references) is the same as that for IRI references with the above redefinition of ucschar applied.</t><t>Formats that use Legacy Extended IRIs or Legacy Extended IRI references MAY further restrict the characters allowed therein, either implicitly by the fact that the format as such does not allow some characters, or explicitly. An example of a character not allowed implicitly may be  the NUL character (U+0000). However, all the characters allowed in IRIs MUST still be allowed.</t></section>
<section title="Conversion of Legacy Extended IRIs to IRIs"><t>To convert a Legacy Extended IRI (reference) to
 an IRI (reference), each character allowed in a Legacy Extended IRI (reference) but not allowed in an IRI (reference) (see <xref target="notAllowed"></xref>)  MUST be percent-encoded
 by applying steps 2.1 to 2.3 of <xref target="mapping"></xref>.</t></section>
<section title="Characters Allowed in Legacy Extended IRIs but not in IRIs" anchor="notAllowed"><t>This section provides a list of the groups of characters and code points that are allowed in Legacy Extedend IRIs, but are not allowed in IRIs or are allowed in IRIs only in the query part. For each group of characters, advice on the usage of these characters is also given, concentrating on the reasons for why not to use them.</t><t><list><t>Space (U+0020): Some formats and applications use space as a delimiter, e.g. for items in a list. Appendix C of <xref target="RFC3986"></xref> also mentions that white space may have to be added when displaying or printing long URIs; the same applies to long IRIs. This means that spaces can disappear, or can make the Legacy Extended IRI to be interpreted as two or more separate IRIs.</t><t>Delimiters "&lt;" (U+003C), "&gt;" (U+003E), and '"' (U+0022): Appendix C of <xref target="RFC3986"></xref> suggests the use of double-quotes ("http://example.com/") and angle brackets
   (&lt;http://example.com/&gt;) as delimiters for URIs in plain text. These conventions are often used, and also apply to IRIs. Legacy Extended IRIs using these characters will be cut off at the wrong place.</t><t>Unwise characters "\" (U+005C),
    "^" (U+005E), "`" (U+0060), "{" (U+007B), "|" (U+007C), and "}" (U+007D): These characters originally have been excluded from URIs because the respective codepoints are assigned to different graphic characters in some 7-bit or 8-bit encoding. Despite the move to Unicode, some of these characters are still occasionally displayed differently on some systems, e.g. U+005C as a Japanese Yen symbol. Also, the fact that these characters are not used in URIs or IRIs has encouraged their use outside URIs or IRIs in contexts that may include URIs or IRIs. In case a Legacy Extended IRI with such a character is used in such a context, the Legacy Extended IRI will be interpreted piecemeal.</t><t>The controls (C0 controls, DEL, and C1 controls, #x0  - #x1F  #x7F - #x9F): There is no way to transmit these characters reliably except potentially in electronic form. Even when in electronic form, some software components might silently filter out some of these characters,       or may stop processing alltogether when encountering some of them. These characters may affect text display in subtle, unnoticable ways or in drastic, global, and irreversible ways depending on the hardware and software involved. The use of some of these characters may allow malicious users to manipulate the display of a Legacy Extended IRI and its context.</t><t>Bidi formatting characters (U+200E, U+200F, U+202A-202E): These characters affect the display ordering of characters. Displayed Legacy Extended IRIs containing these characters cannot be converted back to electronic form (logical order) unambiguously. These characters may allow malicious users to manipulate the display of a Legacy Extended IRI and its context.</t><t>Specials (U+FFF0-FFFD): These code points provide functionality beyond that useful in a Legacy Extended IRI, for example byte order identification, annotation, and replacements for unknown characters and objects. Their use and interpretation in a Legacy Extended IRI serves no purpose and may lead to confusing display variations.</t><t>Private use code points (U+E000-F8FF, U+F0000-FFFFD, U+100000-10FFFD): Display and interpretation of these code points is by definition undefined without private agreement. Therefore, these code points are not suited for use on the Internet. They are not interoperable and may have
  unpredictable effects.</t><t>Tags (U+E0000-E0FFF): These characters provide a way to language tag in Unicode plain text. They are not appropriate for Legacy Extended IRIs because language information in identifiers cannot reliably be input, transmitted (e.g. on a visual medium such as paper), or recognized.</t><t>Non-characters (U+FDD0-FDEF, U+1FFFE-1FFFF, U+2FFFE-2FFFF, U+3FFFE-3FFFF, U+4FFFE-4FFFF, U+5FFFE-5FFFF, U+6FFFE-6FFFF, U+7FFFE-7FFFF, U+8FFFE-8FFFF, U+9FFFE-9FFFF, U+AFFFE-AFFFF, U+BFFFE-BFFFF, U+CFFFE-CFFFF, U+DFFFE-DFFFF, U+EFFFE-EFFFF, U+FFFFE-FFFFF, U+10FFFE-10FFFF): These code points are defined as non-characters. Applications may use some of them internally, but are not prepared to interchange them.</t></list></t><t>For reference, we here also list the code points and code units not even allowed in Legacy Extended IRIs:<list><t>Surrogate code units (D800-DFFF): These do not represent Unicode codepoints.</t></list></t></section>

<section title="HyperText References" anchor="href">

<t>((NOTE: This section is intended to integrate the specification of browser behavior originally written in the public working draft of the HTML5 specification http://www.w3.org/TR/html5/infrastructure.html#parsing-urls into this document. This definition is an initial draft.))</t>

<t>A construct named <xref target="href">Hypertext Reference</xref> (HRef, sometimes called a "web address") describes the extension of IRIs as actually deployed in popular web browsers, for use in both HTML and in a JavaScript scripting interface.

The interpretation of a HRef is given as a modification of the mapping from a string of octets into a useful &lt;URI-reference&gt;. The mapping is an extension of the mapping from IRI to URI. 

The differences are:


<list style="symbols">
   <t>There is an additional parameter to the conversion, a character set used for encoding of the query component.</t>
   <t>Leading and trailing spaces are removed.</t>
   <t>Additional characters are escaped because of HRef parsing.</t>
</list>
</t>


<t>The HRef-charset is determined by the context. If the context does not supply a HRef-charset, then the HRef-charset is UTF-8. For web browsers interpreting HTML, it is determined as follows:
    <list style="hanging"><t hangText="If the HRef came from a script (e.g. as an argument to a method)">The HRef-charset is the script's character.
       encoding.</t><t hangText="If the HRef came from a DOM node (e.g. from an element)">The node has a Document, and the HRef-charset is the Document's character encoding.</t><t hangText="If the HRef had a character encoding defined when the HRef was created or defined">The HRef-charset is as defined.</t></list>
</t>

<t>The following steps define the mapping from an HRef into an URI-reference.
<list style="numbers">

<t>Strip leading and trailing instances of the space (U+0020) character.</t>

<t>  Apply the algorithm in <xref target="mapping"/>, mapping the result to a string of characters in the URI repertoire. </t>


<t> If the result begins with either of:
      <list style="symbols">
       <t>a string matching the &lt;scheme&gt; production,
       followed by "://"</t>
       <t>the string "//"</t>
      </list>
      then percent-encode any left or right square brackets
       (U+005B, U+005D, "[" and "]")
       following the first occurrence of "/",
       "?", or
       "#" which follows the
       first occurrence of "//".</t>
      <t>Otherwise, percent-encode all left and right square brackets.</t>
     
      <t>Percent-encode all occurrences of U+0023 (Number sign, "#")
       after the first.</t>
     
      <t>Parse the result using the production for URI-reference in 
       <xref target="RFC3986">RFC 3986</xref>.</t>
     
      <t>If the result doesn't match 
       &lt;URI-reference&gt; production
       then perform no further action.
      
        Otherwise, parsing was successful.
       Parsing the encoded URI is needed to accomodate
       two changes to the IRI to URI mapping.</t>

       <t>If there is a &lt;scheme&gt; component and a &lt;port&gt; component and the port given by the &lt;port&gt; component is the same as the default port defined for the protocol given by
	 the &lt;scheme&gt; component, then replace the &lt;hostport&gt; in the
         parsed result with the &lt;host&gt; component. (NOTE: Is this step necessary? Well-defined? Only used for HTTP?)</t>

        <t>If the HRef-charset is UTF-8, or if there is no query component, or if the query component contains no percent-encodings, no further processing is necessary. However, if the HRef-charset is not UTF-8 and there is a query component in the parsed results, then the query string is translated into the HRef-charset before percent-encoding. This can be accomplished as:
          <list style="numbers">
              <t>Decode any hex-encoded components of the portion of the URI matching the &lt;query&gt; production (which will yield a UTF-8 encoded sequence of characters.)</t>
              <t>Decode the UTF-8 encoding to create a sequence of (abstract) characters.</t>
              <t>Encode the resulting character sequence into a sequence of octets
              as specified by the HRef-charset; any characters which cannot be expressed
              in HRef-charset should be replaced with an (ASCII) '?'. </t>
              <t>Percent-encode the resulting set of octets.</t>
         </list> 
        </t>
     </list>
</t>

</section></section>


<section title="URI/IRI Processing Guidelines (Informative)" anchor="guidelines">
<t>This informative section provides guidelines for supporting IRIs
in the same software components and operations that currently process
URIs: Software interfaces that handle URIs, software that allows users
to enter URIs, software that creates or generates URIs, software that displays
URIs, formats and protocols that transport URIs, and software that
interprets URIs. These may all require modification before
functioning properly with IRIs. The considerations in this section
also apply to URI references and IRI references.</t>

<section title="URI/IRI Software Interfaces">
<t>Software interfaces that handle URIs, such as URI-handling APIs and
protocols transferring URIs, need interfaces and protocol elements
that are designed to carry IRIs.</t>

<t>In case the current handling in an API or protocol is based on
US-ASCII, UTF-8 is recommended as the character encoding for IRIs,
as it is compatible with US-ASCII, is in accordance with the
recommendations of <xref target="RFC2277"/>, and makes converting to URIs easy. In any case, the API or protocol
definition must clearly define the character encoding to be used.</t>

<t>The transfer from URI-only to IRI-capable components requires no
mapping, although the conversion described in <xref target="URItoIRI"/> above may be
performed. It is preferable not to perform this inverse conversion
when there is a chance that this cannot be done correctly.</t>
</section>

<section title="URI/IRI Entry">
<t>Some components allow users to enter URIs into the system
by typing or dictation, for example. This software must be updated to allow
for IRI entry.</t>

<t>A person viewing a visual representation of an IRI (as a sequence of
glyphs, in some order, in some visual display) or hearing an IRI
will use an entry method for characters in the user's language to input
the IRI. Depending on the script and the input method used, this may
be a more or less complicated process.</t>

<t>The process of IRI entry must ensure, as much as possible, that the
restrictions defined in <xref target="abnf"/> are met. This may be done by
choosing appropriate input methods or variants/settings thereof, by
appropriately converting the characters being input, by eliminating
characters that cannot be converted, and/or by issuing a warning or
error message to the user.</t>

<t>As an example of variant settings, input method editors for East
Asian Languages usually allow the input of Latin letters and related
characters in full-width or half-width versions. For IRI input, the
input method editor should be set so that it produces half-width
Latin letters and punctuation and full-width Katakana.</t>

<t>An input field primarily or solely used for the input of URIs/IRIs
may allow the user to view an IRI as it is  mapped to a URI.  Places
where the input of IRIs is frequent may provide the possibility for
viewing an IRI as mapped to a URI. This will help users when some
of the software they use does not yet accept IRIs.</t>

<t>An IRI input component interfacing to components that handle URIs,
but not IRIs, must map the IRI to a URI before passing it to these
components.</t>

<t>For the input of IRIs with right-to-left characters, please see
<xref target="bidiInput"></xref>.</t>
</section>

<section title="URI/IRI Transfer between Applications">
<t>Many applications, particularly mail user agents, try to detect
URIs appearing in plain text. For this, they use some heuristics based
on URI syntax. They then allow the user to click on such
URIs and retrieve the corresponding resource in an appropriate (usually
scheme-dependent) application.</t>

<t>Such applications have to be upgraded to use the IRI syntax as a base for heuristics. In particular, a non-ASCII
character should not be taken as the indication of the end of an IRI.
Such applications also have to make sure that they correctly convert the
detected IRI from the character encoding of the document or application where
the IRI appears to the character encoding used by the system-wide IRI invocation
mechanism, or to a URI (according to <xref target="mapping"/>) if
the system-wide invocation mechanism only accepts URIs.</t>

<t>The clipboard is another frequently used way to transfer URIs and
IRIs from one application to another. On most platforms, the clipboard
is able to store and transfer text in many languages and scripts.
Correctly used, the clipboard transfers characters, not bytes,
which will do the right thing with IRIs.</t>
</section>

<section title="URI/IRI Generation">
<t>Systems that offer resources through the Internet, where those
resources have logical names, sometimes automatically generate URIs
for the resources they offer. For example, some HTTP servers can
generate a directory listing for a file directory
and then respond to the generated URIs with the files.</t>

<t>Many legacy character encodings are in use in various file systems.
Many currently deployed systems do not transform the local character
representation of the underlying system before generating URIs.</t>

<t>For maximum interoperability, systems that generate resource
identifiers should make the appropriate transformations. For example,
if a file system contains a file named "r&amp;#xE9;sum&amp;#xE9;.html",
a server should expose this as "r%C3%A9sum%C3%A9.html" in a URI, which
allows use of "r&amp;#xE9;sum&amp;#xE9;.html" in an IRI,
even if  locally the file name is kept in a character
encoding other than UTF-8.
</t>

<t>This recommendation particularly applies to HTTP servers. For FTP
servers, similar considerations apply; see <xref target="RFC2640"/>.</t>
</section>

<section title="URI/IRI Selection" anchor="selection">
<t>In some cases, resource owners and publishers have control over the
IRIs used to identify their resources. This control is mostly
executed by controlling the resource names, such as file names,
directly.</t>

<t>In these cases, it is recommended to avoid choosing IRIs that are
easily confused. For example, for US-ASCII, the lower-case ell ("l") is
easily confused with the digit one ("1"), and the upper-case oh ("O") is
easily confused with the digit zero ("0"). Publishers should avoid
confusing users with "br0ken" or "1ame" identifiers.</t>

<t>Outside the US-ASCII repertoire, there are many more opportunities for
confusion; a complete set of guidelines is too lengthy to include
here. As long as names are limited to characters from a single script,
native writers of a given script or language will know best when
ambiguities can appear, and how they can be avoided. What may look
ambiguous to a stranger may be completely obvious to the average
native user. On the other hand, in some cases, the UCS contains
variants for compatibility reasons; for example, for typographic purposes.
These should be avoided wherever possible. Although there may be exceptions,
newly created resource names should generally be in NFKC
<xref target="UTR15"></xref> (which means that they are also in NFC).</t>

<t>As an example, the UCS contains the "fi" ligature at U+FB01
for compatibility reasons.
Wherever possible, IRIs should use the two letters "f" and "i" rather
than the "fi" ligature. An example where the latter may be used is
in the query part of an IRI for an explicit search for a word written
containing the "fi" ligature.</t>

<t>In certain cases, there is a chance that characters from different
scripts look the same. The best known example is the similarity of the Latin "A", the
Greek "Alpha", and the Cyrillic "A". To avoid such cases, only IRIs
should be created where all the characters in a single component are
used together in a given language. This usually means that all of these
characters will be from the same script, but there are languages that
mix characters from different scripts (such as Japanese).
This is similar to the heuristics used to distinguish between
letters and numbers in the examples above. Also, for Latin, Greek,
and Cyrillic, using lowercase letters results in fewer ambiguities
than using uppercase letters would.</t>
</section>

<section title="Display of URIs/IRIs" anchor="display">
<t>
In situations where the rendering software is not expected to display
non-ASCII parts of the IRI correctly using the available layout and font
resources, these parts should be percent-encoded before being displayed.</t>

<t>For display of Bidi IRIs, please see <xref target="visual"/>.</t>
</section>

<section title="Interpretation of URIs and IRIs">
<t>Software that interprets IRIs as the names of local resources should
accept IRIs in multiple forms and convert and match them with the
appropriate local resource names.</t>

<t>First, multiple representations include both IRIs in the native
character encoding of the protocol and also their URI counterparts.</t>

<t>Second, it may include URIs constructed based on character
encodings other than UTF-8. These URIs may be produced by user agents that do
not conform to this specification and that use legacy character encodings to
convert non-ASCII characters to URIs. Whether this is necessary, and what
character encodings to cover, depends on a number of factors, such as
the legacy character encodings used locally and the distribution of
various versions of user agents. For example, software for Japanese
may accept URIs in Shift_JIS and/or EUC-JP in addition to UTF-8.</t>

<t>Third, it may include additional mappings to be more user-friendly and
robust against transmission errors. These would be similar to how
some servers currently treat URIs as case insensitive or perform
additional matching to account for spelling errors. For characters
beyond the US-ASCII repertoire, this may, for example, include ignoring the
accents on received IRIs or resource names. Please
note that such mappings, including case mappings, are
language dependent.</t>

<t>It can be difficult to identify a resource unambiguously if too
many mappings are taken into consideration. However, percent-encoded
and not percent-encoded parts of IRIs can always be clearly distinguished.
Also, the regularity of UTF-8 (see <xref target="Duerst97"/>) makes the
potential for collisions lower than it may seem at first.</t>
</section>

<section title="Upgrading Strategy">
<t>Where this recommendation places further constraints on software
for which many instances are already deployed, it is important to
introduce upgrades carefully and to be aware of the various
interdependencies.</t>

<t>If IRIs cannot be interpreted correctly, they should not be created,
generated, or transported. This suggests that upgrading URI interpreting
software to accept IRIs should have highest priority.</t>

<t>On the other hand, a single IRI is interpreted only by a single or
very few interpreters that are known in advance, although it may be
entered and transported very widely.</t>

<t>Therefore, IRIs benefit most from a broad upgrade of software to be
able to enter and transport IRIs. However, before an
individual IRI is published, care should be taken to upgrade the corresponding
interpreting software in order to cover the forms expected to be
received by various versions of entry and transport software.</t>

<t>The upgrade of generating software to generate IRIs instead of using a
local character encoding should happen only after the service is upgraded
to accept IRIs. Similarly, IRIs should only be generated when the service
accepts IRIs and the intervening infrastructure and protocol is known
to transport them safely.</t>

<t>Software converting from URIs to IRIs for display should be upgraded
only after upgraded entry software has been widely deployed to the
population that will see the displayed result.</t>

<t>Where there is
a free choice of character encodings, it is often possible to reduce the effort and dependencies for upgrading
to IRIs by using UTF-8 rather than another encoding. For example, when a
new file-based Web server is set up, using UTF-8 as the character encoding for file
names will make the transition to IRIs easier. Likewise, when a
new Web form is set up using UTF-8 as the character encoding of the form page, the
returned query URIs will use UTF-8 as the character encoding (unless the user,
for whatever reason, changes the character encoding) and will therefore be
compatible with IRIs.</t>

<t>These recommendations, when taken together, will allow for the
extension from URIs to IRIs in order to handle characters other than
US-ASCII while minimizing interoperability problems. For considerations
regarding the upgrade of URI scheme definitions, see <xref target="UTF8use"/>.</t>
</section>
</section>

<section title="IANA Considerations"><t>Note to the RFC Editor: Please remove this section before publication.</t><t>This document does not require any actions by IANA.</t></section>
<section title="Security Considerations" anchor="security">
<t>The security considerations discussed in <xref target="RFC3986"/>
also apply to IRIs. In addition, the following issues require
particular care for IRIs.</t>
<t>Incorrect encoding or decoding can lead to security problems.
In particular, some UTF-8 decoders do not check against overlong
byte sequences. As an example, a "/" is encoded with the byte 0x2F
both in UTF-8 and in US-ASCII, but some UTF-8 decoders also wrongly
interpret the sequence 0xC0 0xAF as a "/". A sequence such as "%C0%AF.."
may pass some security tests and then be interpreted
as "/.." in a path if UTF-8 decoders are fault-tolerant, if conversion
and checking are not done in the right order, and/or if reserved
characters and unreserved characters are not clearly distinguished.</t>

<t>There are various ways in which "spoofing" can occur with IRIs.
"Spoofing" means that somebody may add a resource name that looks the
same or similar to the user, but that points to a different resource.
The added resource may pretend to be the real resource by looking
very similar but may contain all kinds of changes that may be
difficult to spot and that can cause all kinds of problems.
Most spoofing possibilities for IRIs are extensions of those for URIs.</t>

<t>Spoofing can occur for various reasons. First, a user's normalization expectations or actual normalization
when entering an IRI or  transcoding an IRI from a legacy character
encoding do not match the normalization used on the
server side. Conceptually, this is no different from the problems
surrounding the use of case-insensitive web servers. For example,
a popular web page with a mixed-case name ("http://big.example.com/PopularPage.html")
might be "spoofed" by someone who is able to create "http://big.example.com/popularpage.html".
However, the use of unnormalized character sequences, and of additional
mappings for user convenience, may increase the chance for spoofing.
Protocols and servers that allow the creation of resources with
names that are not normalized are particularly vulnerable to such
attacks. This is an inherent
security problem of the relevant protocol, server, or resource
and is not specific to IRIs, but it is mentioned here for completeness.</t>

<t>Spoofing can occur in various IRI components, such as the
domain name part or a path part. For considerations specific
to the domain name part, see <xref target="RFC3491"/>.
For the path part, administrators of sites that allow independent
users to create resources in the same sub area may have to be careful
to check for spoofing.</t>

<t>Spoofing can occur because in the UCS many characters look very similar. Details are discussed in <xref target="selection"/>.
Again, this is very similar to spoofing possibilities on US-ASCII,
e.g., using "br0ken" or "1ame" URIs.</t>

<t>Spoofing can occur when URIs with percent-encodings based on various
character encodings are accepted to deal with older user agents. In some
cases, particularly for Latin-based resource names, this is usually easy to
detect because UTF-8-encoded names, when interpreted and viewed as
legacy character encodings, produce mostly garbage.</t><t>When
concurrently used character encodings have a similar structure but there
are no characters that have exactly the same encoding, detection is more
difficult.</t>

<t>Spoofing can occur with bidirectional IRIs, if the restrictions
in <xref target="bidi-structure"/> are not followed. The same visual
representation may be interpreted as different logical representations,
and vice versa. It is also very important that a correct Unicode bidirectional
implementation be used.</t><t>The use of Legacy Extended IRIs introduces additional security issues.</t>
</section>

<section title="Acknowledgements">
<t>For contributions to this update, we would like to thank Ian Hickson, Michael Sperberg-McQueen, Dan Connolly, Norman Walsh, Richard Tobin, Henry S. Thomson, and the XML Core Working Group of the W3C.</t>

<t>The discussion on the issue addressed here started a long time
ago. There was a thread in the HTML working
group in August 1995 (under the topic of "Globalizing URIs") and in the
www-international mailing list in July 1996 (under the topic of
"Internationalization and URLs"), and there were ad-hoc meetings at the Unicode
conferences in September 1995 and September 1997.</t>

<t>For contributions to the previous version of this document, RFC 3987, many thanks go to Francois Yergeau, Matitiahu Allouche,
Roy Fielding, Tim Berners-Lee, Mark Davis,
M.T. Carrasco Benitez, James Clark, Tim Bray, Chris Wendt, Yaron Goland,
Andrea Vine, Misha Wolf, Leslie Daigle, Ted Hardie, Bill Fenner, Margaret Wasserman,
Russ Housley, Makoto MURATA, Steven Atkin,
Ryan Stansifer, Tex Texin, Graham Klyne, Bjoern Hoehrmann, Chris Lilley, Ian Jacobs,
Adam Costello, Dan Oscarson, Elliotte Rusty Harold, Mike J. Brown,
Roy Badami, Jonathan Rosenne, Asmus Freytag, Simon Josefsson, Carlos Viegas Damasio,
Chris Haynes, Walter Underwood, and many others.</t>
<t>The definition of HyperText Reference was initially produced by Ian Hixson, and further edited by Dan Connolly and C. M. Spergerg-McQueen.</t>
<t>This document is a product of the Internationalization Working
Group (I18N WG) of the World Wide Web Consortium (W3C).
Thanks to the members of the W3C
I18N Working Group and Interest Group for their contributions and their
work on <xref target="CharMod"/>. Thanks also go
to the members of many other W3C Working Groups for adopting IRIs, and to
the members of the Montreal IAB Workshop on Internationalization and
Localization for their review.</t>
</section>

<section title="Change Log"><t>Note to RFC Editor: Please completely remove this section before publication.</t>

<section title="Changes from -05 to -06"><t><list style="symbols">
<t>Add HyperText Reference, change abstract, acks and references for it</t>
<t>Add Masinter back as another editor.</t>
<t>Masinter integrates HRef material from HTML5 spec.</t>
<t>Rewrite introduction sections to modernize.</t>
</list></t></section>

<section title="Changes from -04 to -05"><t><list style="symbols"><t>Updated references.</t><t>Changed IPR text to pre5378Trust200902.</t></list></t></section>

<section title="Changes from -03 to -04"><t><list style="symbols"><t>Added explicit abbreviation for LEIRIs.</t><t>Mentioned LEIRI references.</t><t>Completed text in LEIRI section about tag characters and about specials.</t></list></t></section>

<section title="Changes from -02 to -03"><t><list style="symbols"><t>Updated some references.</t><t>Updated Michel Suginard's coordinates.</t></list></t></section>

<section title="Changes from -01 to -02"><t><list style="symbols"><t>Added tag range to iprivate (issue private-include-tags-115).</t><t>Added Specials (U+FFF0-FFFD) to Legacy Extended IRIs.</t></list></t></section>
<section title="Changes from -00 to -01"><t><list style="symbols"><t>Changed from "IRIs with Spaces/Controls" to "Legacy Extended IRI" based on input from the W3C XML Core WG. Moved the relevant subsections to the back and promoted them to a section.</t><t>Added some text re. Legacy Extended IRIs to the security section.</t><t>Added a IANA Consideration Section.</t><t>Added this Change Log Section.</t><t>Added a section about "IRIs with Spaces/Controls" (converting from a Note in RFC 3987).</t></list></t></section>
<section title="Changes from RFC 3987 to -00"><t><list><t>Fixed errata (see http://www.rfc-editor.org/cgi-bin/errataSearch.pl?rfc=3987).</t></list></t></section></section></middle>

<back>
<references title="Normative References">

<reference anchor="ASCII">
<front>
<title>Coded Character Set -- 7-bit American Standard Code for Information
Interchange</title>
<author>
<organization>American National Standards Institute</organization>
</author>
<date year="1986"/>
</front>
<seriesInfo name="ANSI" value="X3.4"/>
</reference>

<reference anchor="ISO10646">
<front>
<title>ISO/IEC 10646:2003: Information Technology -
Universal Multiple-Octet Coded Character Set (UCS)</title>
<author>
<organization>International Organization for Standardization</organization>
</author>
<date month="December" year="2003"/>
</front>
<seriesInfo name="ISO" value="Standard 10646"/>
</reference>

&rfc2119;
&rfc3490;
&rfc3491;
&rfc3629;
&rfc3986;

<reference anchor="STD68">
<front>
<title abbrev="ABNF">Augmented BNF for Syntax Specifications: ABNF</title>
<author initials="D." surname="Crocker" fullname="Dave Crocker"><organization/></author>
<author initials="P." surname="Overell" fullname="Paul Overell"><organization/></author>
<date month="January" year="2008"/></front>
<seriesInfo name="STD" value="68"/><seriesInfo name="RFC" value="5234"/>
</reference>

<reference anchor="UNIV4">
<front>
<title>The Unicode Standard, Version 5.1.0, defined by: The Unicode Standard,
Version 5.0 (Boston, MA, Addison-Wesley, 2007. ISBN 0-321-48091-0),
as amended by Unicode 4.1.0 (http://www.unicode.org/versions/Unicode5.1.0/)</title>
<author><organization>The Unicode Consortium</organization></author>
<date year="2008" month="April"/>
</front>
</reference>

<reference anchor="UNI9" target="http://www.unicode.org/reports/tr9/tr9-13.html">
<front>
<title>The Bidirectional Algorithm</title>
<author initials="M." surname="Davis" fullname="Mark Davis"><organization/></author>
<date year="2004" month="March"/>
</front>
<seriesInfo name="Unicode Standard Annex" value="#9"/>
</reference>

<reference anchor="UTR15" target="http://www.unicode.org/unicode/reports/tr15/tr15-23.html">
<front>
<title>Unicode Normalization Forms</title>
<author initials="M." surname="Davis" fullname="Mark Davis"><organization/></author>
<author initials="M.J." surname="Duerst" fullname="Martin Duerst"><organization/></author>
<date year="2008" month="March"/>
</front>
<seriesInfo name="Unicode Standard Annex" value="#15"/>
</reference>

</references>

<references title="Informative References">

<reference anchor="BidiEx" target="http://www.w3.org/International/iri-edit/BidiExamples">
<front>
<title>Examples of bidirectional IRIs</title>
<author><organization/></author>
<date year="" month=""/>
</front>
</reference>

<reference anchor="CharMod" target="http://www.w3.org/TR/charmod-resid">
<front>
<title>Character Model for the World Wide Web: Resource Identifiers</title>
<author initials="M." surname="Duerst" fullname="Martin Duerst"><organization/></author>
<author initials="F." surname="Yergeau" fullname="Francois Yergeau"><organization/></author>
<author initials="R." surname="Ishida" fullname="Richard Ishida"><organization/></author>
<author initials="M." surname="Wolf" fullname="Misha Wolf"><organization/></author>
<author initials="T." surname="Texin" fullname="Tex Texin"><organization/></author>
<date year="2004" month="November" day="25"/>
</front>
<seriesInfo name="World Wide Web Consortium" value="Candidate Recommendation"/>
</reference>

<reference anchor="Duerst97" target="http://www.ifi.unizh.ch/mml/mduerst/papers/PDF/IUC11-UTF-8.pdf">
<front>
<title>The Properties and Promises of UTF-8</title>
<author initials="M.J." surname="Duerst" fullname="Martin Duerst"><organization/></author>
<date year="1997" month="September"/>
</front>
<seriesInfo name="Proc. 11th International Unicode Conference, San Jose" value=""/>
</reference>

<reference anchor="Gettys" target="http://www.w3.org/DesignIssues/ModelConsequences">
<front>
<title>URI Model Consequences</title>
<author initials="J." surname="Gettys" fullname="Jim Gettys"><organization/></author>
<date month="" year=""/>
</front>
</reference>

<reference anchor="HTML4" target="http://www.w3.org/TR/html401/appendix/notes.html#h-B.2">
<front>
<title>HTML 4.01 Specification</title>
<author initials="D." surname="Raggett" fullname="Dave Raggett"><organization/></author>
<author initials="A." surname="Le Hors" fullname="Arnaud Le Hors"><organization/></author>
<author initials="I." surname="Jacobs" fullname="Ian Jacobs"><organization/></author>
<date year="1999" month="December" day="24"/>
</front>
<seriesInfo name="World Wide Web Consortium" value="Recommendation"/>
</reference>

<reference anchor="LEIRI" target="http://www.w3.org/TR/leiri/">
<front>
<title>Legacy extended IRIs for XML resource identification</title>
<author initials="H." surname="Thompson" fullname="Henry Thompson"><organization/></author>
<author initials="R." surname="Tobin"    fullname="Richard Tobin"><organization/></author>
<author initials="N." surname="Walsh" fullname="Norman Walsh"><organization/></author>


</front>
<seriesInfo name="World Wide Web Consortium" value="Note"/>
</reference>


&rfc2045;
&rfc2130;
&rfc2141;
&rfc2192;
&rfc2277;
&rfc2368;
&rfc2384;
&rfc2396;
&rfc2397;
&rfc2616;
&rfc2640;
&rfc2718;

<reference anchor="UNIXML" target="http://www.w3.org/TR/unicode-xml/">

<front>
<title>Unicode in XML and other Markup Languages</title>
<author initials="M.J." surname="Duerst" fullname="Martin Duerst"><organization/></author>
<author initials="A." surname="Freytag" fullname="Asmus Freytag"><organization/></author>
<date year="2003" month="June" day="18"/>
</front>
<seriesInfo name="Unicode Technical Report" value="#20"/>
<seriesInfo name="World Wide Web Consortium" value="Note"/>
</reference>

<reference anchor="XLink" target="http://www.w3.org/TR/xlink/#link-locators">
<front>
<title>XML Linking Language (XLink) Version 1.0</title>
<author initials="S." surname="DeRose" fullname="Steve DeRose"><organization/></author>
<author initials="E." surname="Maler" fullname="Eve Maler"><organization/></author>
<author initials="D." surname="Orchard" fullname="David Orchard"><organization/></author>
<date year="2001" month="June" day="27"/>
</front>
<seriesInfo name="World Wide Web Consortium" value="Recommendation"/>
</reference>

<reference anchor="XML1" target="http://www.w3.org/TR/REC-xml">
  <front>
    <title>Extensible Markup Language (XML) 1.0 (Forth Edition)</title>
    <author initials="T." surname="Bray" fullname="Tim Bray"><organization/></author>
    <author initials="J." surname="Paoli" fullname="Jean Paoli"><organization/></author>
    <author initials="C.M." surname="Sperberg-McQueen" fullname="C. M. Sperberg-McQueen">
      <organization/></author>
    <author initials="E." surname="Maler" fullname="Eve Maler"><organization/></author>
    <author initials="F." surname="Yergeau" fullname="Francois Yergeau"><organization/></author>
    <date day="16" month="August" year="2006"/>
  </front>
  <seriesInfo name="World Wide Web Consortium" value="Recommendation"/>
</reference>

<reference anchor="XMLNamespace" target="http://www.w3.org/TR/REC-xml-names">
  <front>
    <title>Namespaces in XML (Second Edition)</title>
    <author initials="T." surname="Bray" fullname="Tim Bray"><organization/></author>
    <author initials="D." surname="Hollander" fullname="Dave Hollander"><organization/></author>
    <author initials="A." surname="Layman" fullname="Andrew Layman"><organization/></author>
    <author initials="R." surname="Tobin" fullname="Richard Tobin"><organization></organization></author><date day="16" month="August" year="2006"/>
  </front>
  <seriesInfo name="World Wide Web Consortium" value="Recommendation"/>
</reference>

<reference anchor="XMLSchema" target="http://www.w3.org/TR/xmlschema-2/#anyURI">
<front>
<title>XML Schema Part 2: Datatypes</title>
<author initials="P." surname="Biron" fullname="Paul Biron"><organization/></author>
<author initials="A." surname="Malhotra" fullname="Ashok Malhotra"><organization/></author>
<date year="2001" month="May" day="2"/>
</front>
<seriesInfo name="World Wide Web Consortium" value="Recommendation"/>
</reference>

<reference anchor="XPointer" target="http://www.w3.org/TR/xptr-framework/#escaping">
<front>
<title>XPointer Framework</title>
<author initials="P." surname="Grosso" fullname="Paul Grosso"><organization/></author>
<author initials="E." surname="Maler" fullname="Eve Maler"><organization/></author>
<author initials="J." surname="Marsh" fullname="Jonathan Marsh"><organization/></author>
<author initials="N." surname="Walsh" fullname="Norman Walsh"><organization/></author>
<date year="2003" month="March" day="25"/>
</front>
<seriesInfo name="World Wide Web Consortium" value="Recommendation"/>
</reference>

<reference anchor="HTML5" target="http://www.w3.org/TR/2009/WD-html5-20090423/">
<front>
<title>A vocabulary and associated APIs for HTML and XHTML</title>
<author initials="I." surname="Hickson" fullname="Ian Hickson"><organization>Google, Inc.</organization></author>
<author initials="D." surname="Hyatt" fullname="David Hyatt"><organization>Apple, Inc.</organization></author>
<date year="2009"  month="April" day="23"/>
</front>
<seriesInfo name="World Wide Web Consortium" value="Working Draft"/>
</reference>

</references>
<section title="Design Alternatives">
<t>This section shortly summarizes major design alternatives
and the reasons for why they were not chosen.</t>
<section title="New Scheme(s)">
<t>Introducing new schemes (for example, httpi:, ftpi:,...) or a
new metascheme (e.g., i:, leading to URI/IRI prefixes such as
i:http:, i:ftp:,...) was proposed to make IRI-to-URI conversion
scheme dependent or to distinguish between percent-encodings
resulting from IRI-to-URI conversion and percent-encodings from
legacy character encodings.</t>

<t>New schemes are not needed to distinguish URIs from true IRIs (i.e.,
  IRIs that contain non-ASCII characters). The benefit of being able
  to detect the origin of percent-encodings is marginal, as UTF-8
  can be detected with very high reliability. Deploying new schemes is
  extremely hard, so not requiring new schemes for IRIs makes
  deployment of IRIs vastly easier. Making conversion scheme dependent
  is highly inadvisable and would be encouraged by separate schemes for IRIs.
  Using a uniform convention for conversion from IRIs to URIs makes
  IRI implementation orthogonal to the introduction of actual new
  schemes.</t>
</section>
<section title="Character Encodings Other Than UTF-8">
<t>At an early stage, UTF-7 was considered as an alternative to
UTF-8 when IRIs are converted to URIs. UTF-7 would not have needed
percent-encoding and  in most cases would have been shorter than
percent-encoded UTF-8.</t>
<t>Using UTF-8 avoids a double layering and overloading of the use of
   the "+" character. UTF-8 is fully compatible with US-ASCII and has
   therefore been recommended by the IETF, and is being used widely.</t><t>UTF-7 has never been used much and is now clearly being
   discouraged. Requiring implementations to convert from UTF-8
   to UTF-7 and back would be an additional implementation burden.</t>
</section>
<section title="New Encoding Convention">
<t>Instead of using the existing percent-encoding convention
of URIs, which is based on octets, the idea was to create a new
encoding convention; for example, to use "%u" to introduce
UCS code points.</t>
<t>Using the existing octet-based percent-encoding mechanism
does not need an upgrade of the URI syntax and does not
need corresponding server upgrades.</t>
</section>
<section title="Indicating Character Encodings in the URI/IRI">
<t>Some proposals suggested indicating the character encodings used
in an URI or IRI with some new syntactic convention in the URI itself,
similar to the "charset" parameter for e-mails and Web pages.
As an example, the label in square brackets in
"http://www.example.org/ros[iso-8859-1]&amp;#xE9;" indicated that
the following "&amp;#xE9;" had to be interpreted as iso-8859-1.</t>
<t>If UTF-8 is used exclusively, an upgrade to the URI syntax is not needed.
It avoids potentially multiple labels that have to be copied correctly
in all cases, even on the side of a bus or on a napkin, leading to
usability problems (and being prohibitively annoying).
Exclusively using UTF-8 also reduces transcoding errors and confusion.</t>
</section>
</section>
</back>
</rfc>
