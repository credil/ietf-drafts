<?xml version="1.0" encoding="UTF-8"?>


<rfc category="std" ipr="full3978" docName="draft-vakil-sipping-notify-pause-02.txt">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="no" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>


    <front>
        <title abbrev="Pausing Notifications Temporarily">An Extension to Session Initiation Protocol (SIP) Events for Pausing and Resuming Notifications</title>

    <author initials="M." surname="Vakil" fullname="Mohammad Vakil">
      <organization>Microsoft Corporation</organization>
      <address>
	<postal>
	  <street>One Microsoft Way</street>
	  <city>Redmond</city> <region>WA</region> <code>98052</code>
	  <country>USA</country>
 	</postal>
	<email>mvakil@microsoft.com</email>
      </address>
    </author>

      <author initials="S." surname="Parameswar" fullname="Sriram Parameswar">
        <organization>Microsoft Corporation</organization>
        <address>
          <postal>
            <street>One Microsoft Way</street>
            <city>Redmond</city>
            <region>WA</region>
            <code>98052</code>
            <country>USA</country>
          </postal>
          <email>srirampa@microsoft.com</email>
        </address>
      </author>
    <date month="March" year="2008"/>
       <area>Real Time</area> 
    <workgroup>SIPPING WG</workgroup> <keyword>I-D</keyword> <keyword>Internet-
    Draft</keyword> <keyword>SIPPING</keyword> <keyword>pausing notifications</keyword>

    <abstract>
       <t>The Session Initiation Protocol (SIP) events framework enables a subscriber to receive asynchronous notification of various events from other SIP user agents. It defines mechanisms to create, refresh, terminate subscriptions. This framework also defines mechanism to fetch (poll) an event state of a resource without creating persistent subscriptions. There is no mechanism to temporarily pause the notifications, while still maintaining a subscription on the server. This lack of functionality sometime results in a lot of superfluous notification traffic, and put unnecessary load on the server. This draft defines an extension to SIP events that allows the subscriber to pause, un-pause notifications, and be able to perform fetch (poll) subscriptions within an established (created) subscription dialog.</t>
    </abstract>

    </front>

    <middle>

    <section title="Requirements notation">

    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
    document are to be interpreted as described in <xref target="RFC2119"/>.</t>

    </section>

    <section title="Introduction">

    <t>The Session Initiation Protocol (SIP) events framework enables a subscriber to receive asynchronous notification of various events from other SIP user agents. It defines mechanisms to create, refresh, terminate subscriptions. This framework also defines mechanism to fetch (poll) an event state of a resource without creating persistent subscriptions. There is no mechanism to temporarily pause the notifications, while still maintaining a subscription on the server. </t>

    <t>There are many event packages defined, e.g. presence <xref target="RFC3856">RFC3856</xref> , reg event <xref target="RFC3680">RFC3680</xref>, resource list <xref target="RFC4662">RFC4662</xref>, on top of SIP event framework <xref target="RFC3265">RFC3265</xref>. There is no mechanism to temporarily pause the notifications, while still maintaining a subscription on the server. According to RFC 3265 <xref target="RFC3265">RFC3265</xref>, once a subscription dialog is established, notifications are sent whenever there's any change in resource state. There're instances, as described below, where user agents are not required to receive notifications. But at the same time they cannot simply terminate the subscription, because there are huge costs associated with installing the new subscriptions at the notifier.</t>
    <t>This lack of functionality sometime results in a lot of superfluous notification traffic, and put unnecessary load on the server. This draft defines an extension to SIP events that allows the subscriber to pause, un-pause notifications, and be able to perform fetch (poll) subscriptions within an established (created) subscription dialog.</t>

</section>

<section title="Motivation">

  <section title="Overview">

    <t>A SUBSCRIBE request (with Expires !=0 ) for a given event package creates a subscrption with a finite lifetime. In that duration, whenever an event state change occurs for a given resource, notification is sent to the subscriber. This duration depends upon event packages and could range upto hours.</t>

<t>There is a processing cost on the notifier side to generate notifies, incur network traffic, and have user agent (subscriber) receive the NOTIFY, parse the event state, and perform all the update functions with no benefit.</t> 

<t>In the following scenarios, it is not necessary to keep on  receiving on going notifications, when that event state is not beneficial.</t>

<t><list style="symbols">
<t>An endpoint, used by the subscriber for presence event may not be active at that endpoint (e.g. PC is locked), but still logged into the system. This idle endpoint keeps on receiving unnecessary notifications</t>

<t>A wireless handset receiving notifications for events, not paid attention to, while wasting over the air bandwidth. The same wireless endpoint may also consume processing and battery power, which might be needed for other voice applications, to process these unwanted notifications. A wireless handset, may trigger a fetch subscription within an established dialog whenever end user wants to receive an updated event state (mostly in presence buddy list applications)</t>

</list></t>

<t>In the above scenarios, it would be prudent to simply pause the notifications traffic, while still maintaining subscriptions, and when user becomes active, or when the event state is required to be known instantaneously, at that point, it MUST be able to un-pause notification stream or perform a one off fetch subscription to retrieve an updated state within an established dialog.</t>

<section title="Why Not Terminate and Re-create Subscription?">
<t>In big deployments, it's not prudent to simply terminate the subscriptions tempoararily, because creation of subscription take a huge toll on the system. The cost of creating a new subscription on the server is far more than simply pausing the notification traffic temporarily. Typically, the following steps are required to install a new subscription:</t>  

<t><list style="symbols">
<t>New dialog state creation</t>
<t>Execution of authorization policies</t>
<t>Installing composition policies</t>
<t>Creating watcher/presentity based filters</t>
<t>Creation of back end subscriptions to intra and inter domains for distributed resources. That in turn creates extra processing on the back-end servers to install the subscriptions</t>
<t>Each new subscription requires processing of watcher info notifcations, if applicable</t>
<t>To meet high availability requirements, subscription state replication occurs on other nodes</t>
</list></t>


<t>Therefore, it is much less costly to simply turn off notification stream if receipt of the notifications are not required by the subscriber.</t>
</section>

<section title="Fetch During Paused Stream">
<t>It would be a significant performance improvement to be able to perform a fetch subscription within a paused dialog. Because, fetch subscription creates an equal amount of processing on the server as described in the section above. This improvement will be useful for wireless handset to be able to do a quick fetch when event state needs to be shown to end user. 
</t>

</section>

</section>


<section title="Problem Statement">

<t>The SIP events framework (RFC 3265) does not include protocol methods to pause and un-pause notifications, once a subscription is established with a non-zero expiration value. Every, state change triggers a notification towards subscriber, which may not be needed. These notifications cause processing power on the notifier and subscriber side, and the bandwidth in the network. It's not always prudent to terminate the subscription in those cases, as subsequent creation of new subscription requires much more processing on the notifier. There's also no mechanism to do a light weight fetch subscription as and when event state is needed, within a paused subscription.</t>
</section>

<section title="Requirements">
<t>REQ1:   It MUST be possible to pause the notification stream for established SIP dialog of a subscription for any event package. </t>
<t>REQ2:   It MUST be possible to resume the notification stream for an earlier paused notification stream on an established subscription and MUST be able to receive a full state notification to sync up with event state.</t>
<t>REQ3:   It MUST be possible to perform a one off retrieval of updated event state within a paused notification stream.</t>
</section>


<section title="Overview of Operation">
<t>The SIP events framework specifies creation, refresh, and deletion of subscriptions. Once a subscription is created on the server, it keeps on sending notifies on event state changes. In order to pause the subscription on a temporary basis, subscriber issues a SUBSCRIBE request, similar to a refresh subscription, with an event header parameter of "notify=off". At this point, notifier stops sending the notifications, while still keeping the subscription alive. The subscription remains inactive until it expires or subscriber sends a request to resume notifications. In this state, subscriber may perform a light weight fetch subscription to trigger only one notify with an updated state, whenever needed. This can be performed by "notify=once". The resumption of notification is performed by the subscriber sending another refresh subscription, with an event header parameter "notify=on".</t>

<t>In all three cases, expires value is non-zero. Since, these are similar to refresh subscription, they may generate notifies. In the first case of pausing the notifications (notify=off), notifier SHOULD not send a notify. In the resumption case (notify=on) and (notify=once), notifier MUST send a full state subscription. </t>

<figure>
<artwork>
<![CDATA[

Subscriber			Notifier		  Event State
							   Generator
   |				   |				  |
   |SUBSCRIBE (expires!=0 , no notify param)	 		  |
   |------------------------------>|				  |
   |	200 OK			   |---Subscription created	  |
   |<------------------------------|				  |
   |	NOTIFY (first full state notify)			  |
   |<------------------------------|				  |
   |    200 OK			   |				  |
   |------------------------------>|				  |
   |				   |	Event state update	  |
   |				   |<-----------------------------|
   |	NOTIFY (partial or full)   |---Notify sent		  |
   |<------------------------------|				  |
   |    200 OK			   |				  |
   |------------------------------>|				  |
   |				   |				  |
   |				   |				  |
   |				   |				  |
   |SUBSCRIBE (expires!=0 , notify=off)		 		  |
   |------------------------------>|				  |
   |	200 OK			   |---Subscription paused	  |
   |<------------------------------|				  |
   |				   |				  |
   |				   |	Event state update	  |
   |				   |<-----------------------------|
   |				   |---No notify sent (paused)	  |
   |				   |				  |
   |SUBSCRIBE (expires!=0 , notify=once)	 		  |
   |------------------------------>|				  |
   |	200 OK			   |---Subscription paused but one|
   |<------------------------------|	full state notify (fetch  |
   |				   |	requested		  |
   |	NOTIFY (full state notify) |				  |
   |<------------------------------|				  |
   |    200 OK			   |				  |
   |------------------------------>|				  |
   |				   |				  |
   |				   |	Event state update	  |
   |				   |<-----------------------------|
   |				   |---No notify sent (paused)	  |
   |				   |				  |
   |				   |				  |
   |				   |				  |
   |				   |				  |
   |SUBSCRIBE (expires!=0 , notify=on)	 			  |
   |------------------------------>|				  |
   |	200 OK			   |---Subscription unpaused 	  |
   |<------------------------------|				  |
   |				   |				  |
   |	NOTIFY (full state notify) |				  |
   |<------------------------------|				  |
   |    200 OK			   |				  |
   |------------------------------>|				  |
   |				   |				  |
   |				   |	Event state update	  |
   |				   |<-----------------------------|
   |	NOTIFY (partial or full)   |---Notify sent		  |
   |<------------------------------|				  |
   |    200 OK			   |				  |
   |------------------------------>|				  |
   |				   |				  |
]]>			
</artwork>
</figure>

</section>

<section title="Subscriber And Notifier Behaviors">

	<section title="Subscriber Behavior">
		<t>Whenever a subscriber is not interested in receiving on-going notifications for event state changes, it creates a refresh subscription with a non-zero expires value, and adds a new event header parameter "notify=off" to pause notifies on an existing established subscription dialog. This pause notification request in the form of a refresh subscription is sent to the notifier.</t>

<t>At this point, subscriber MUST NOT drop or reject the incoming notifies, if sent from the notifier. A subscriber is just recommending to halt notifies on a temporary basis.</t>

<t>In this halted state, subscriber may send another subscribe request with a non-zero expires value, but with a "notify=once" event header parameter to retrieve an updated event state with only one notification. This would allow subscriber to achieve fetch function within an established dialog. </t>

<t>When a subscriber discovers the need to receive on-going notifications again, it sends another refresh subscription. This time it uses a different value of "notify" event header parameter, with "notify=on". At this point, subscriber expects to receive a full state notification, similar to very first notification, when a subscription is created, continued updates in the event state on an on-going basis until subscription is terminated or another subscription with "notify=off" is sent. </t>

<section title="Initial Subscriptons and option tags">
<t>The subscriber SHOULD NOT use the "notify=off" parameter in the initial subscription. In case the subscriber invokes this functionality with the initial subscription,it MUST be prepared to receive the immediate notification as specified in <xref target="RFC3265">RFC3265</xref>.</t>
<t>It is expected that the subscriber that is sending the initial subscription will place the "notifyoff" option tag in the Supported header. The subscriber SHOULD invoke this feature only if it receives confirmation of support from the notifier. The subscriber MAY invoke this functionality even if it does not receive confirmation, but must then be prepared to receive notifies.</t>
</section>

</section>

<section title="Notifier Behavior">
	<t>When a notifier receives a request to pause the subscription, it treats that request very similar to a refresh subscription request. It does update the expiration of the subscription. But it pays attention to "notify" parameter, and if it's found to be "off". It SHOULD NOT send any notification, not even the immediate notifcation, until either subscription expires or a request to resume notification arrives. 
	It is a feature of this specification that the notifier SHOULD suppresses the notification for the subscription refresh with "notify=off", though this is notification is required by section 3.1.6.2 of <xref target="RFC3265">RFC 3265</xref>. The notifier MUST send notifications in the event that the subscription is terminated for any reason.</t>

<t>Upon receiving a request to receive a one off updated notification (refresh subscription with notify="once"), notifier MUST treat that as a refresh subscription request. It MUST update the expiration time of the subscription and pays attention to "notify" parameter. If it's found to be "once", notifier MUST send a full state notification, and MUST NOT turn on the notification stream, upon every event state changes.</t>

<t>Upon receiving a request to resume notifications (refresh subscription with notify="on"), notifier MUST treat that as a refresh subscription request. It MUST update the expiration time of the subscription and pays attention to "notify" parameter. If it's found to be "on", notifier MUST send a full state notification, and then turns on the notification stream, where by sending notifies for every event state changes.</t>
</section>

<section title="Subscriber Behavior when &quot;notify&quot; Not Supported">
<t>In the case of a notifier not supporting the mechanism identified in this proposed extension, notifier will ignore "notify=" parameter, and would continue to send notifications. That's why, subscriber must be prepared to receive notifications and must keep on acknowleding it with 200 OK.</t>
</section>

</section>

<section title="Syntax">
<section title="The &quot;notify&quot; event parameter">
<t>This section describes the Augmented BNF [RFC 2234] definitions for the new syntax elements. It's based on ruleset present in both SIP Events <xref target="RFC3265">RFC3265</xref> and SIP <xref target="RFC3261">RFC3261</xref>, adding additional alternatives to the alternative sets of "event-param" defined therein.</t>

<t>event-param =/ notify-param </t>
<t>notify-param = "notify" "=" ("on"|"off"|"once")</t>


</section>

<section title="New Option Tag for Notify Pause and Resume functionality">
<t>This specification defines a new option tag "notifyoff" that is be used to signal the state of support for the feature documented here.</t>

<t>UAs that support this feature MUST include the "notifyoff" option tag in a Supported header field. 
The "notifyoff" option tag SHOULD NOT be used in conjuction with the Required header, as the functionality described within this specification is an optimization, and UAs
can continue to work in its absence, albeit with some deleterious effects. </t>
</section>

</section>

<section title="IANA Considerations">
<section title="New Header Parameter">
<t>This mechanism registers a new SIP header field parameter for the event header defined in SIP events <xref target="RFC3265">RFC 3265</xref>, defined by the following information which is to be added to the Header Field Parameters and Parameter Values sub-registry under.</t>

<figure>
<artwork>
<![CDATA[
Header Field 	Parameter Name	Predefined	References
				 Values
------------	--------------	----------	-----------
Event		  notify	"on", "off",	 RFC[xxxx]
				  "once"
]]>			
</artwork>
</figure>

<t>(Note to the RFC Editor: Replace "xxxx" with the RFC number of this specification, when assigned.)</t>
</section>

<section title="New Option Tag">
<t>This section defines a new option tag as per the guidelines of section 27.1 of <xref target="RFC3261">RFC3261</xref></t>

<t>Name: notifyoff</t>

<t>Description: This option tag identifies the Notify Pause and Resume functionality. When present in the Supported header it indicates the user agents support for
this functionality.</t>
</section>
</section>

<section title="Security Considerations">
    <t>The security considerations listed in SIP events <xref target="RFC3265">RFC3265</xref>, which the specified mechanism extends, apply in entirety.</t>

   </section>

    <section title="Acknowledgments">

    <t>I would like to thank everyone who provided feedback on the sipping mailing list for their ideas and input, especially to Paul Kyzivat, Sean Olson, Sriram Parameswar, and Srivatsa Srinivasan.</t>

   </section>

</section>

   </middle>

    <back>
			<references title="Normative References">
				<?rfc include="reference.RFC.2119" ?>
				<?rfc include="reference.RFC.3261" ?>
				<?rfc include="reference.RFC.3265" ?>
			</references>
    	<references title="Informational References">
				<?rfc include="reference.RFC.4662" ?>
				<?rfc include="reference.RFC.3856" ?>
				<?rfc include="reference.RFC.3680" ?>
			</references>
    </back>
</rfc>
