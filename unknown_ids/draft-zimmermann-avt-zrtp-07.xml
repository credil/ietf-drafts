<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE rfc SYSTEM "rfc2629.dtd"><?rfc compact="yes"?><?rfc toc="yes"?><rfc ipr="full3978" docName="draft-zimmermann-avt-zrtp-07" category="info"><front><title abbrev="ZRTP">ZRTP: Media Path Key Agreement for Secure RTP</title><author initials="P." surname="Zimmermann" fullname="Philip Zimmermann"> <organization>Zfone Project</organization>  <address>   <email>prz@mit.edu</email>   </address> </author>  <author initials="A." surname="Johnston" fullname="Alan Johnston" role="editor"><organization>Avaya</organization><address><postal><city>St. Louis</city><region>MO</region><code>63124</code>    </postal>   <email>alan@sipstation.com</email>   </address>  </author><author initials="J." surname="Callas" fullname="Jon Callas"> <organization>PGP Corporation</organization>  <address>   <email>jon@pgp.com</email>   </address> </author>   <date month="June" year="2008"/><abstract><t> This document defines ZRTP, a protocol for media path Diffie-Hellman exchange to agree on a session key and parameters for establishing Secure Real-time Transport Protocol (SRTP) sessions.  The ZRTP protocol is media path keying because it is multiplexed on the same port as RTP and does not require support in the signaling protocol. ZRTP does not assume a Public Key Infrastructure (PKI) or require the complexity of certificates in end devices.  For the media session, ZRTP provides confidentiality, protection against man-in-the-middle (MITM) attacks, and, in cases where a secret is available from the signaling protocol, authentication.  ZRTP can utilize a Session Description Protocol (SDP) attribute to provide discovery and authentication through the signaling channel.  To provide best effort SRTP, ZRTP utilizes normal RTP/AVP profiles. </t></abstract></front><middle><section title="Introduction"><t>ZRTP is a key agreement protocol which performs Diffie-Hellman key exchange during call setup in the media path, and is transported over the same port as the <xref target="RFC3550"> Real-time Transport Protocol (RTP)</xref> media stream which has been established using a signaling protocol such as <xref target="RFC3261">Session Initiation Protocol (SIP)</xref>.   This generates a shared secret which is then used to generate keys and salt for a <xref target="RFC3711">Secure RTP (SRTP)</xref> session.  ZRTP borrows ideas from <xref target="pgpfone">PGPfone</xref>.  A reference implementation of ZRTP is available as <xref target="zfone">Zfone</xref>. </t><t>The ZRTP protocol has some nice cryptographic features lacking in many other approaches to media session encryption. Although it uses a public key algorithm, it does not rely on a public key infrastructure (PKI). In fact, it does not use persistent public keys at all. It uses ephemeral Diffie-Hellman (DH) with hash commitment, and allows the detection of man-in-the-middle (MITM) attacks by displaying a short authentication string for the users to read and compare over the phone. It has Perfect Forward Secrecy, meaning the keys are destroyed at the end of the call, which precludes retroactively compromising the call by future disclosures of key material. But even if the users are too lazy to bother with short authentication strings, we still get reasonable authentication against a MITM attack, based on a form of key continuity. It does this by caching some key material to use in the next call, to be mixed in with the next call's DH shared secret, giving it key continuity properties analogous to SSH. All this is done without reliance on a PKI, key certification, trust models, certificate authorities, or key management complexity that bedevils the email encryption world. It also does not rely on SIP signaling for the key management, and in fact does not rely on any servers at all. It performs its key agreements and key management in a purely peer-to-peer manner over the RTP packet stream. </t><t>If the endpoints have a mechanism for knowing or retrieving the other endpoint's signature key, the short authentication string can be authenticated by exchanging a signature over the short authentication string. </t><t>ZRTP can be used and discovered without being declared or indicated in the signaling path.  This provides a best effort SRTP capability.  Also, this reduces the complexity of implementations and minimizes interdependency between the signaling and media layers.  However, when ZRTP is indicated in the signaling via the zrtp-hash SDP attribute, ZRTP has additional useful properties.  By sending a hash of the ZRTP Hello message in the signaling, ZRTP provides a useful binding between the signaling and media paths, which is explained in <xref target='Binding2Signaling'/>. When this is done through a signaling path that has end-to-end integrity protection, the DH exchange is automatically protected from a MiTM attack, which is explained in <xref target='LeveragingIntegrityProtectedSIP'/>.  </t><t>The next section discusses how ZRTP meets every requirement for media security protocols documented in the IETF.  Following sections provide an overview of the ZRTP protocol, describe the key agreement algorithm and RTP message formats. </t></section><section title="Terminology"><t>In this document, the key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" are to be interpreted as described in RFC 2119 and indicate requirement levels for compliant implementations <xref target="RFC2119"/>. </t></section><section title="Media Security Requirements"><t>This section discuses how ZRTP meets all RTP security requirements discussed in the SIP Working Group's <xref target='I-D.ietf-sip-media-security-requirements'>Media Security Requirements</xref> document without any dependencies on other protocols or extensions. </t><t><list><t>R-FORK-RETARGET is met since ZRTP is a media path key agreement protocol.</t><t></t><t>R-DISTINCT is met since ZRTP uses ZIDs and allows multiple independent ZRTP exchanges to proceed.</t><t></t><t>R-REUSE is met using the Multistream and Preshared modes.</t><t></t><t>R-AVOID-CLIPPING is met since ZRTP is a media path key agreement protocol</t><t></t><t>R-RTP-VALID is met since the ZRTP packet format does not pass the RTP validity check</t><t></t><t>R-ASSOC is met using the a=zrtp-hash SDP attribute in INVITEs and responses.</t><t></t><t>R-NEGOTIATE is met using the Commit message.</t><t></t><t>R-PSTN is met since ZRTP can be implemented in Gateways. </t><t></t><t>R-PFS is met using ZRTP Diffie-Hellman key agreement methods.</t><t></t><t>R-COMPUTE is met using the Hello/Commit ZRTP exchange.  </t><t></t><t>R-CERTS is met using the optional signature field in ZRTP Confirm messages.</t><t></t><t>R-FIPS is met since ZRTP uses algorithms that allow FIPS certification.</t><t></t><t>R-DOS is met since ZRTP does not introduce any new denial of service attacks.</t><t></t><t>R-EXISTING is met since ZRTP can support the use of certificates or keys.</t><t></t><t>R-AGILITY is met since the set of hash, cipher, authentication tag length, key agreement method, SAS type, and signature type can all be extended and negotiated.</t><t></t><t>R-DOWNGRADE is met since ZRTP has protection against downgrade attacks.</t><t></t><t>R-PASS-MEDIA is met since ZRTP prevents a passive adversary with access to the media path from gaining access to keying material used to protect SRTP media packets.</t><t></t><t>R-PASS-SIG is met since ZRTP prevents a passive adversary with access to the signaling path from gaining access to keying material used to protect SRTP media packets.</t><t></t><t>R-SIG-MEDIA is met using the a=zrtp-hash SDP attribute in INVITEs and responses.</t><t></t><t>R-ID-BINDING is met using the a=zrtp-hash SDP attribute.</t><t></t><t>R-ACT-ACT is met using the a=zrtp-hash SDP attribute in INVITEs and responses.</t><t></t><t>R-BEST-SECURE is met since ZRTP utilizes the RTP/AVP profile and hence best effort SRTP in every case.</t><t></t><t>R-OTHER-SIGNALING is met since ZRTP can utilize modes in which there is no dependency on the signaling path.</t><t></t><t>R-RECORDING is met using the ZRTP Disclosure flag.</t><t></t><t>R-TRANSCODER is met if the transcoder operates as a trusted MitM (i.e. a PBX).</t></list></t></section><section title="Overview"><t>This section provides a description of how ZRTP works.  This description is non-normative in nature but is included to build understanding of the protocol. </t><t>ZRTP is negotiated the same way a conventional RTP session is negotiated in an offer/answer exchange using the standard AVP/RTP profile.  The ZRTP protocol begins after two endpoints have utilized a signaling protocol such as SIP and are ready to exchange media.  If <xref target='I-D.ietf-mmusic-ice'>ICE</xref> is being used, ZRTP begins after ICE has completed its connectivity checks. </t><t>ZRTP is multiplexed on the same ports as RTP.  It uses a unique header that makes it clearly differentiable from RTP or STUN. </t><t>In environments in which sending ZRTP packets to non-ZRTP endpoints might cause problems and signaling path discovery is not an option, ZRTP endpoints can include the RTP header extension flag for ZRTP in normal RTP packets sent at the start of a session as a probe to discover if the other endpoint supports ZRTP.  If the flag is received from the other endpoint, ZRTP messages can then be exchanged. </t><t>A ZRTP endpoint initiates the exchange by sending a ZRTP Hello message to the other endpoint.  The purpose of the Hello message is to confirm the endpoint supports the protocol and to see what algorithms the two ZRTP endpoints have in common. </t><t>The Hello message contains the SRTP configuration options, and the ZID.  Each instance of ZRTP has a unique 96-bit random ZRTP ID or ZID that is generated once at installation time. ZIDs are discovered during the Hello message exchange. The received ZID is used to look up retained shared secrets from previous ZRTP sessions with the endpoint. </t><t>A response to a ZRTP Hello message is a ZRTP HelloACK message.  The HelloACK message simply acknowledges receipt of the Hello.  Since RTP commonly uses best effort UDP transport, ZRTP has retransmission timers in case of lost datagrams.  There are two timers, both with exponential backoff mechanisms.  One timer is used for retransmissions of Hello messages and the other is used for retransmissions of all other messages after receipt of a HelloACK. </t><t>If an integrity protected signaling channel is available, a hash of the Hello message can be sent.  This allows rejection of false injected ZRTP Hello messages by an attacker.</t><t>Hello and other ZRTP messages also contain a hash image that is used to link the messages together.  This allows rejection of false injected ZRTP messages during an exchange.</t><section title="Key Agreement Modes"><t>After both endpoints exchange Hello and HelloACK messages, the key agreement exchange can begin with the ZRTP Commit message.  ZRTP supports a number of key agreement modes including both Diffie-Hellman and non-Diffie-Hellman modes as described in the following sections. </t><t>The Commit message may be sent immediately after both endpoints have completed the Hello/HelloAck discovery handshake.  Or it may be deferred until later in the call, after the participants engage in some unencrypted conversation.  The Commit message may be manually activated by a user interface element, such as a GO SECURE button, which becomes enabled after the Hello/HelloAck discovery phase.  This emulates the user experience of a number of secure phones in the PSTN world <xref target="comsec"/>.  However, it is expected that most simple ZRTP user agents will omit such buttons and proceed directly to secure mode by sending a Commit message immediately after the Hello/HelloAck handshake. </t><t>In all key agreement modes, the initiator SHOULD NOT send RTP media after sending the Commit message, and MUST NOT send SRTP media before receiving the Conf2Ack.  The responder SHOULD NOT send RTP media after receiving the Commit message, and MUST NOT send SRTP media before receiving the Confirm2 message. </t><!--<t>In all key agreement modes, the responder MUST NOT send RTP media after sending the DHPart1 message, and MUST NOT send SRTP media before receiving the Confirm2 message.  The initiator MUST NOT send RTP media after sending the DHPart2 message, and MUST NOT send SRTP media before receiving the Conf2Ack.  Either party may stop sending RTP earlier in the protocol; the initiator MAY stop sending RTP media after sending the Commit message, and the responder MAY stop sending RTP media after receiving the Commit message. </t><t>In all key agreement modes, the responder MUST NOT send RTP media after sending the Confirm1 message, and MUST NOT send SRTP media before receiving the Confirm2 message.  The initiator MUST NOT send RTP media after sending the Confirm2 message, and MUST NOT send SRTP media before receiving the Conf2Ack.  Either party may stop sending RTP earlier in the protocol; the initiator MAY stop sending RTP media after sending the Commit message, and the responder MAY stop sending RTP media after receiving the Commit message. </t><t>In all key agreement modes, the initiator MUST NOT send RTP media after sending the Commit message, and MUST NOT send SRTP media before receiving the Conf2Ack.  The responder MUST NOT send RTP media after receiving the Commit message, and MUST NOT send SRTP media before receiving the Confirm2 message. </t><t>In all key agreement modes, the initiator sends no RTP media after sending the Commit message, and begins sending SRTP media only after receiving the Conf2Ack.  The responder sends no RTP media after receiving the Commit message, and begins sending SRTP media only after receiving the Confirm2 message. </t>--><section title="Diffie-Hellman Mode"><t>An example ZRTP call flow is shown in <xref target='CallFlow'/> below.  Note that the order of the Hello/HelloACK exchanges in F1/F2 and F3/F4 may be reversed.  That is, either Alice or Bob might send the first Hello message.  Note that the endpoint which sends the Commit message is considered the initiator of the ZRTP session and drives the key agreement exchange.  The Diffie-Hellman public values are exchanged in the DHPart1 and DHPart2 messages.  SRTP keys and salts are then calculated. </t><figure anchor='CallFlow' title="Establishment of an SRTP session using ZRTP"><artwork><![CDATA[Alice                                                Bob  |                                                   |  |      Alice and Bob establish a media session.     |  |         They initiate ZRTP on media ports         |  |                                                   |  | F1 Hello (version, options, Alice's ZID)          |  |-------------------------------------------------->|  |                                       HelloACK F2 |  |<--------------------------------------------------|  |            Hello (version, options, Bob's ZID) F3 |  |<--------------------------------------------------|  | F4 HelloACK                                       |  |-------------------------------------------------->|  |                                                   |  |             Bob acts as the initiator             |  |                                                   |  |               Commit (Bob's ZID, options, hvi) F5 |  |<--------------------------------------------------|  | F6 DHPart1 (pvr, shared secret hashes)            |  |-------------------------------------------------->|  |            DHPart2 (pvi, shared secret hashes) F7 |  |<--------------------------------------------------|  |                                                   |  |     Alice and Bob generate SRTP session key.      |  |                                                   |  | F8 Confirm1 (HMAC, D,A,V,E flags, sig)            |  |-------------------------------------------------->|  |            Confirm2 (HMAC, D,A,V,E flags, sig) F9 |  |<--------------------------------------------------|  | F10 Conf2ACK                                      |  |-------------------------------------------------->|  |                    SRTP begins                    |  |<=================================================>|  |                                                   |]]></artwork></figure><t>ZRTP authentication uses a Short Authentication String (SAS) which is ideally displayed for the human user.  Alternatively, the SAS can be transported over the signaling channel in the SDP and compared automatically, provided the signaling has end-to-end integrity protection.  Or, the SAS can be authenticated by exchanging an OPTIONAL digital signature (sig) over the short authentication string in the Confirm1 or Confirm2 messages. </t><t>The ZRTP Confirm1 and Confirm2 messages are sent for a number of reasons, not the least of which is they confirm that all the key agreement calculations were successful and thus the encryption will work. They also carry other information such as the Disclosure flag (D), the Allow Clear flag (A), the SAS Verified flag (V), and the PBX Enrollment flag (E).  All flags are encrypted to shield them from a passive observer. </t></section><section title="Multistream Mode"><t>Multistream mode is an alternative key agreement method when two endpoints have an established SRTP media stream between them and hence an active ZRTP Session key. ZRTP can derive multiple SRTP keys from a single DH exchange.  For example, an established secure voice call that adds a video stream could use Multistream mode to quickly initiate the video stream without a second DH exchange. </t><t>When Multistream mode is indicated in the Commit message, a call flow similar to <xref target='CallFlow'/> is used, but no DH calculation is performed by either endpoint and the DHPart1 and DHPart2 messages are omitted.  The Confirm1, Confirm2, and Conf2Ack messages are still sent.  Since the cache is not affected during this mode, multiple Multistream ZRTP exchanges can be performed in parallel between two endpoints. </t><t>When adding additional media streams to an existing call, Multistream mode MUST be used.  Only one DH operation should be performed, just for the first media stream.  The DH exchange must be completed for the first media stream before Multistream mode is used to add any other media streams. </t></section><section title="Preshared Mode"><t>In the Preshared Mode, endpoints can skip the DH calculation if they have a shared secret from a previous ZRTP session.  Preshared mode is indicated in the Commit message and results in the same call flow as Multistream mode.  The principal difference between Multistream mode and Preshared mode is that Preshared mode uses a previously cached shared secret, rs1, instead of an active ZRTP Session key, ZRTPSess, as the initial keying material. </t><t>This mode could be useful for slow processor endpoints so that a DH calculation does not need to be performed every session.  Or, this mode could be used to rapidly re-establish an earlier session that was recently torn down or interrupted without the need to perform another DH calculation.  Since the cache is not affected during this mode, multiple Preshared mode exchanges can be processed at a time between two endpoints. </t><t>A major drawback to Preshared mode is that it lacks Perfect Forward Secrecy (PFS).  For this reason, Preshared mode MUST NOT be used for establishing a second media stream.  Multistream mode is designed for that role, without sacrificing PFS. </t><t>Because of the loss of PFS, Preshared mode should be used sparingly, if used at all.  Preshared mode is only included in this specification to meet the R-REUSE requirement in the <xref target='I-D.ietf-sip-media-security-requirements'>Media Security Requirements</xref> document.  A series of preshared-keyed calls between two ZRTP endpoints should use a DH key exchange periodically to replace the cached key material, to limit the interval of exposure from no PFS. </t></section></section></section><section title="Protocol Description"><t>ZRTP MUST be multiplexed on the same ports as the RTP media packets. </t><t>To support best effort encryption from the <xref target='I-D.ietf-sip-media-security-requirements'>Media Security Requirements</xref>, ZRTP uses normal RTP/AVP profile (AVP) media lines in the initial offer/answer exchange.  The ZRTP SDP attribute flag a=zrtp-hash defined in <xref target='SignalingInteractions'/> SHOULD be used in all offers and answers to indicate support for the ZRTP protocol.  The Secure RTP/AVP (SAVP) profile MAY be used in subsequent offer/answer exchanges after a successful ZRTP exchange has resulted in an SRTP session, or if it is known the other endpoint supports this profile.</t><t><list><t>The use of the RTP/SAVP profile has caused failures in negotiating best effort SRTP due to the limitations on negotiating profiles using SDP.  This is why ZRTP supports the RTP/AVP profile and includes its own discovery mechanisms.</t></list></t><section title="Discovery"><t>During the ZRTP discovery phase, a ZRTP endpoint discovers if the other endpoint supports ZRTP and the supported algorithms and options.  This information is transported in a Hello message. </t><t>ZRTP endpoints SHOULD include the SDP attribute a=zrtp-hash in offers and answers, as defined in <xref target='SignalingInteractions'/>.  ZRTP MAY use an RTP <xref target="RFC3550"/> extension field as a flag to indicate support for the ZRTP protocol in RTP packets as described in <xref target='RTPXHdrFlagZRTP'/>. </t><t>The Hello message includes the ZRTP version, hash type, cipher type, authentication method and tag length, key agreement type, and Short Authentication String (SAS) algorithms that are supported.   The Hello message also includes a hash image as described in <xref target='Hashchains'/>.  In addition, each endpoint sends and discovers ZIDs.  The received ZID is used later in the protocol as an index into a cache of shared secrets that were previously negotiated and retained between the two parties. </t><t>A Hello message can be sent at any time, but is usually sent at the start of an RTP session to determine if the other endpoint supports ZRTP, and also if the SRTP implementations are compatible.  A Hello message is retransmitted using timer T1 and an exponential backoff mechanism detailed in <xref target='Retransmissions'/> until the receipt of a HelloACK message or a Commit message. </t><t>The use of the a=zrtp-hash SDP attribute to authenticate the Hello message is described in <xref target='Binding2Signaling'/>.</t></section><section anchor='CommitContention' title="Commit"><t>After both parties have received Hello messages, a Commit message can be sent to begin the ZRTP key exchange. The endpoint that sends the Commit is known as the initiator, while the receiver of the Commit is known as the responder. </t><t>If both sides send Commit messages initiating a secure session at the same time the following rules are used to break the tie.  If one Commit is for a DH mode while the other is for a non-DH mode, then the non-DH Commit is discarded and the DH Commit proceeds.  If the Commits are either both DH modes or both non-DH modes, then the Commit message with the lowest hvi value is discarded and the other side is the initiator. </t><t>Because the DH exchange affects the state of the retained shared secret cache, only one in-process ZRTP DH exchange may occur at a time between two ZRTP endpoints.  Otherwise, race conditions and cache integrity problems will result.  When multiple media streams are established in parallel between the same pair of ZRTP endpoints (determined by the ZIDs in the Hello Messages), only one can be processed.  Once that exchange completes with Confirm2 and Conf2ACK messages, another ZRTP DH exchange can begin.  This constraint does not apply when Multistream mode key agreement is used since the cached shared secrets are not affected. </t><t>In the event that Commit messages are sent by both ZRTP endpoints at the same time, but are received in different media streams, the same resolution rules apply as if they were received on the same stream.  The media stream in which the Commit will proceed through the ZRTP exchange while the media stream with the discarded Commit must wait for the completion of the other ZRTP exchange. </t><!-- <t>When a call is made in Preshared mode (no DH calculations), and more than one media stream is involved in concurrent key negotiations in Preshared Mode, both streams will produce their own SAS value, but only one of the SAS values will be rendered to the users.  The stream with the largest hvi value will be selected to have its SAS rendered. </t> --></section><section anchor='SharedSecretDetermination' title="Shared Secret Determination"><t>The following sections describe how ZRTP endpoints generate and/or use the set of shared secrets s1, auxsecret, and pbxsecret through the exchange of the DHPart1 and DHPart2 messages. </t><t>Each ZRTP endpoint maintains a long-term cache of shared secrets that it has previously negotiated with the other party.  The ZID of the other party, received in the other party's Hello message, is used as an index into this cache to find the set of shared secrets, if any exist.  This cache entry may contain previously retained shared secrets, rs1 and rs2, which give ZRTP its key continuity features.  If the other party is a PBX, the cache may also contain a trusted MiTM PBX shared secret, called pbxsecret, defined in <xref target='PBXenrollment'/>. </t><t>The DHPart1 and DHPart2 messages contain a list of hashes of these shared secrets to allow the two endpoints to compare the hashes with what they have in their caches to detect whether the two sides share any secrets that can be used in the calculation of the session key.  The use of this shared secret cache is described in <xref target='CacheOperation'/>. </t><t>If no secret of a given type is available, a random value is generated and used for that secret to ensure a mismatch in the hash comparisons in the DHPart1 and DHPart2 messages.  This prevents an eavesdropper from knowing which types of shared secrets are available between the endpoints. </t><t><xref target='ResponderBehavior1'/> and <xref target='InitiatorBehavior1'/> both refer to the auxiliary shared secret auxsecret.  The auxsecret shared secret may be defined by the VoIP user agent out-of-band from the ZRTP protocol.  In some cases it may be provided by the signaling layer as srtps, which is defined in <xref target='derive_srtps'/>. If it's not provided by the signaling layer, the auxsecret shared secret may be manually provisioned in other application-specific ways that are out-of-band, such as computed from a hashed pass phrase by prior agreement between the two parties.  Or it may be a family key used by an institution that the two parties both belong to.  It is a generalized mechanism for providing a shared secret that is agreed to between the two parties out of scope of the ZRTP protocol. It is expected that most typical ZRTP endpoints will rarely use auxsecret. </t><t>For both the initiator and the responder, the shared secrets s1, s2, and s3 will be calculated so that they can all be used later to calculate s0 in <xref target='sharedsecretcalc'/>.  Here is how s1, s2, and s3 are calculated:</t><t>The shared secret s1 will be either the initiator's rs1 or the initiator's rs2, depending on which of them can be found in the responder's cache. If the initiator's rs1 matches the responder's rs1 or rs2, then s1 = the initiator's rs1.  If and only if that match fails, then if the initiator's rs2 matches the responder's rs1 or rs2, then s1 = the initiator's rs2.  If that match also fails, then s1 is set to null. The complexity of the this s1 calculation is to recover from any loss of cache sync from an earlier aborted session, due to the <xref target='Byzantine'>Byzantine Generals' Problem</xref>. </t><t>The shared secret s2 will be set to the value of auxsecret if and only if both parties have matching values for auxsecret, as determined by comparing the hashes of auxsecret sent in the DH messages.  If they don't match, s2 is set to null. </t><t>The shared secret s3 will be set to the value of pbxsecret if and only if both parties have matching values for pbxsecret, as determined by comparing the hashes of pbxsecret sent in the DH messages.  If they don't match, s3 is set to null. </t><t>If s1, s2, or s3 have null values, they are assumed to have a zero length for the purposes of hashing them later during the s0 calculation. </t><t>The comparison of hashes of rs1, rs2, auxsecret, and pbxsecret is described in the next sections. </t><section anchor='ResponderBehavior1' title="Responder Behavior"><t>The responder calculates an HMAC keyed hash using the first retained shared secret, rs1, as the key on the string "Responder" which generates a retained secret ID, rs1IDr, which is truncated to the leftmost 64 bits.  HMACs are calculated in a similar way for additional shared secrets: </t><t><list><t> rs1IDr = HMAC(rs1, "Responder") </t><t> rs2IDr = HMAC(rs2, "Responder") </t><t> auxsecretIDr = HMAC(auxsecret, "Responder") </t><t> pbxsecretIDr = HMAC(pbxsecret, "Responder") </t></list></t><t>The set of keyed hashes (HMACs) of shared secrets are included by the responder in the DHPart1 message. </t><t>The HMACs of the possible shared secrets received in the DHPart2 can be compared against the HMACs of the local set of possible shared secrets.  From these comparisons, s1, s2, and s3 are calculated per the methods described above in <xref target='SharedSecretDetermination'/>.  The expected HMAC values of the shared secrets are calculated (using the string "Initiator" instead of "Responder") as in <xref target='InitiatorBehavior1'/> and compared to the HMACs received in the DHPart2 message.  The secrets corresponding to matching HMACs are kept while the secrets corresponding to the non-matching ones are replaced with a null, which is assumed to have a zero length for the purposes of hashing them later.  The resulting s1, s2, and s3 values are used later to calculate s0 in <xref target='sharedsecretcalc'/>. </t></section><section anchor='InitiatorBehavior1' title="Initiator Behavior"><t>The initiator calculates an HMAC keyed hash using the first retained shared secret, rs1, as the key on the string "Initiator" which generates a retained secret ID, rs1IDi, which is truncated to the leftmost 64 bits.  HMACs are calculated in a similar way for additional shared secrets: </t><t><list><t> rs1IDi = HMAC(rs1, "Initiator") </t><t> rs2IDi = HMAC(rs2, "Initiator") </t><t> auxsecretIDi = HMAC(auxsecret, "Initiator") </t><t> pbxsecretIDi = HMAC(pbxsecret, "Initiator") </t></list></t><t>These HMACs of shared secrets are included by the initiator in the DHPart2 message. </t><t>The initiator then calculates the set of secret IDs that are expected to be received from the responder in the DHPart1 message by substituting the string "Responder" instead of "Initiator" as in <xref target='ResponderBehavior1'/>. </t><t>The HMACs of the possible shared secrets received are compared against the HMACs of the local set of possible shared secrets.  From these comparisons, s1, s2, and s3 are calculated per the methods described above in <xref target='SharedSecretDetermination'/>.  The secrets corresponding to matching HMACs are kept while the secrets corresponding to the non-matching ones are replaced with a null, which is assumed to have a zero length for the purposes of hashing them later.  The resulting s1, s2, and s3 values are used later to calculate s0 in <xref target='sharedsecretcalc'/>. </t><t>For example, consider two ZRTP endpoints who share secrets rs1 and pbxsecret (defined in <xref target='PBXenrollment'/>).  During the comparison, rs1ID and pbxsecretID will match but auxsecretID will not.  As a result, s1 = rs1, s2 will be null, and s3 = pbxsecret. </t></section><section anchor='cache_mismatch' title="Handling a Shared Secret Cache Mismatch"><t>A shared secret cache mismatch is defined to mean that we expected a cache match because rs1 exists in our local cache, but we computed a null value for s1 (per the method described in <xref target='SharedSecretDetermination'/>). </t><t>If one party has a cached shared secret and the other party does not, this indicates one of two possible situations.  Either there is a man-in-the-middle (MiTM) attack, or one of the legitimate parties has lost their cached shared secret by some mishap.  Perhaps they inadvertently deleted their cache, or their cache was lost or disrupted due to restoring their disk from an earlier backup copy.  The party that has the surviving cache entry can easily detect that a cache mismatch has occurred, because they expect their own cached secret to match the other party's cached secret, but it does not match.  It is possible for both parties to detect this condition if both parties have surviving cached secrets that have fallen out of sync, due perhaps to one party restoring from a disk backup. </t><t>If either party discovers a cache mismatch, the user agent who makes this discovery must treat this as a possible security event and MUST alert their own user that there is a heightened risk of a MiTM attack, and that the user should verbally compare the SAS with the other party to ascertain that no MiTM attack has occurred.  If a cache mismatch is detected and it is not possible to compare the SAS, either because the user interface does not support it or because one or both endpoints are unmanned devices, and no other SAS comparison mechanism is available, the session MAY be terminated. </t><t>The session need not be terminated on a cache mismatch event if the mechanism described in <xref target='LeveragingIntegrityProtectedSIP'/> is available, which allows authentication of the DH exchange without human assistance.  Or if any mechanism is available to determine if the SAS matches.  This would require either circumstances that allow human verbal comparisons of the SAS, or by using the OPTIONAL digital signature feature on the SAS hash, as described in <xref target='SignSAS'/>.  Even if the user interface does not permit an SAS compare, the human user MUST be warned, and may elect to proceed with the call at their own risk. </t><t>Here is a non-normative example of a cache-mismatch alert message from a ZRTP user agent (specifically, <xref target="zfone">Zfone</xref>), designed for a desktop PC graphical user interface environment.  It is by no means required that the alert be this detailed:</t><t><list><t>  "We expected the other party to have a shared secret cached from a previous call, but they don't have it.  This may mean your partner simply lost his cache of shared secrets, but it could also mean someone is trying to wiretap you.  To resolve this question you must check the authentication string with your partner.  If it doesn't match, it indicates the presence of a wiretapper." </t></list></t></section></section><section title="Secret Generation"><t>The next step is the generation of a secret for deriving SRTP keying material.  ZRTP uses Diffie-Hellman and two non-Diffie-Hellman modes, described in the following sections.</t><section title="Diffie-Hellman Mode"><t>The purpose of the Diffie-Hellman (either Finite Field Diffie-Hellman or Elliptic Curve Diffie-Hellman) exchange is for the two ZRTP endpoints to generate a new shared secret, s0.  In addition, the endpoints discover if they have any cached or previously stored shared secrets in common, and uses them as part of the calculation of the session keys. </t><section anchor='HashCommit' title="Hash Commitment"><t>From the intersection of the algorithms in the sent and received Hello messages, the initiator chooses a hash, cipher, auth tag, key agreement type, and SAS type to be used. </t><t>A Diffie-Hellman mode is selected by setting the Key Agreement Type to one of the DH or ECDH values in Table 5 in the Commit.  In this mode, the key agreement begins with the initiator choosing a fresh random Diffie-Hellman (DH) secret value (svi) based on the chosen key agreement type value, and computing the public value.  (Note that to speed up processing, this computation can be done in advance.)  For guidance on generating random numbers, see <xref target='RNG'/>. The value for the DH generator g, the DH prime p, and the length of the DH secret value, svi, are defined in <xref target='KeyAgreementType'/>. </t><t><list><t>  pvi = g^svi mod p </t></list></t><t>where g and p are determined by the key agreement type value.  The pvi value is formatted as a big-endian octet string, fixed to the width of the DH prime, and leading zeros MUST NOT be truncated. </t><t>The hash commitment is performed by the initiator of the ZRTP exchange.  The hash value of the initiator, hvi, includes a hash of the entire DHPart2 message as shown in <xref target='DHPart2_Msg'/> (which includes the Diffie-Hellman public value, pvi), and the responder's Hello message: </t><t><list><t>  hvi = hash(initiator's DHPart2 message | responder's Hello message) </t></list></t><t>Note that the Hello message includes the fields shown in <xref target='Hello_Msg'/>. </t><t>The information from the responder's Hello message is included in the hash calculation to prevent a bid-down attack by modification of the responder's Hello message. </t><t>The initiator sends hvi in the Commit message. </t></section><section title="Responder Behavior"><t>Upon receipt of the Commit message, the responder generates its own fresh random DH secret value, svr, and computes the public value. (Note that to speed up processing, this computation can be done in advance.)  For guidance on random number generation, see <xref target='RNG'/>. The value for the DH generator g, the DH prime p, and the length of the DH secret value, svr, are defined in <xref target='KeyAgreementType'/>. </t><t><list><t>  pvr = g^svr mod p </t></list></t><t>The pvr value is formatted as a big-endian octet string, fixed to the width of the DH prime, and leading zeros MUST NOT be truncated. </t><t>Upon receipt of the DHPart2 message, the responder checks that the initiator's public DH value is not equal to 1 or p-1.  An attacker might inject a false DHPart2 packet with a value of 1 or p-1 for g^svi mod p, which would cause a disastrously weak final DH result to be computed.  If pvi is 1 or p-1, the user should be alerted of the attack and the protocol exchange MUST be terminated. Otherwise, the responder computes its own value for the hash commitment using the public DH value (pvi) received in the DHPart2 packet and its Hello packet and compares the result with the hvi received in the Commit packet. If they are different, a MITM attack is taking place and the user is alerted and the protocol exchange terminated. </t><t>The responder then calculates the Diffie-Hellman result: </t><t><list><t>  DHResult = pvi^svr mod p </t></list></t></section><section title="Initiator Behavior"><t>Upon receipt of the DHPart1 message, the initiator checks that the responder's public DH value is not equal to 1 or p-1.  An attacker might inject a false DHPart1 packet with a value of 1 or p-1 for g^svr mod p, which would cause a disastrously weak final DH result to be computed.  If pvr is 1 or p-1, the user should be alerted of the attack and the protocol exchange MUST be terminated. </t><t>The initiator then sends a DHPart2 message containing the initiator's public DH value and the set of calculated shared secret IDs as defined in <xref target='InitiatorBehavior1'/>. </t><t>The initiator calculates the same Diffie-Hellman result using: </t><t><list><t>  DHResult = pvr^svi mod p </t></list></t></section><section anchor='sharedsecretcalc' title="Shared Secret Calculation for DH Mode"><t>A hash of the received and sent ZRTP messages in the current ZRTP exchange in the following order is calculated by both parties: </t><t><list><t>  total_hash = hash(Hello of responder | Commit | DHPart1 | DHPart2) </t></list></t><t>Note that only the ZRTP messages (<xref target='Hello_Msg'/>, <xref target='DHCommit_Msg'/>, <xref target='DHPart1_Msg'/>, and <xref target='DHPart2_Msg'/>), not the entire ZRTP packets, are included in the total_hash. </t><t>For both the initiator and responder, the DHResult is formatted as a big-endian octet string, fixed to the width of the DH prime, and leading zeros MUST NOT be truncated.  For example, for a 3072-bit p, DHResult would be a 384 octet value, with the first octet the most significant. </t><t>The calculation of the final shared secret, s0, is in compliance with the recommendations in sections 5.8.1 and 6.1.2.1 of <xref target="SP800-56A">NIST SP 800-56A</xref>.  This is done by hashing a concatenation of a number of items, including the DHResult, the ZID's of the initiator (ZIDi) and the responder (ZIDr), the total_hash, and the set of non-null shared secrets as described in 5.2. </t><t>In section 5.8.1 of <xref target="SP800-56A">NIST SP 800-56A</xref>, NIST requires certain parameters to be hashed together in a particular order, which NIST refers to as:  Z, AlgorithmID, PartyUInfo, PartyVInfo, SuppPubInfo, and SuppPrivInfo.  In our implementation, our DHResult corresponds to Z, "ZRTP-HMAC-KDF" corresponds to AlgorithmID, our ZIDi and ZIDr correspond to PartyUInfo and PartyVInfo, our total_hash corresponds to SuppPubInfo, and the set of three shared secrets s1, s2, and s3 corresponds to SuppPrivInfo.  NIST also requires a 32-bit big-endian integer counter to be included in the hash each time the hash is computed, which we have set to the fixed value of 1, because we only compute the hash once. </t><t><list><t>  s0 = hash( counter | DHResult | "ZRTP-HMAC-KDF" | ZIDi | ZIDr | total_hash |        len(s1) | s1 | len(s2) | s2 | len(s3) | s3 ) </t></list></t><t>Note that temporary values s1, s2, and s3 were calculated per the methods described above in <xref target='SharedSecretDetermination'/>, and they are erased from memory immediately after they are used to calculate s0. </t><t>The length of the DHResult field was implicitly agreed to by the negotiated DH prime size.  The length of total_hash is implicitly determined by the negotiated hash algorithm.  All of the explicit length fields, len(), in the above hash are 32-bit big-endian integers, giving the length in octets of the field that follows.  Some members of the set of shared secrets (s1, s2, and s3) may have lengths of zero if they are null (not shared), and are each preceded by a 4-octet length field.  For example, if s2 is null, len(s2) is 0x00000000, and s2 itself would be absent from the hash calculation, which means len(s3) would immediately follow len(s2).  While inclusion of ZIDi and ZIDr may be redundant, because they are implicitly included in the total_hash, we explicitly include them here to follow NIST SP800-56A.  The string "ZRTP-HMAC-KDF" (not null-terminated) identifies what purpose the resulting s0 will be used for, which is to serve as the master key for the ZRTP HMAC-based key derivation function defined in <xref target='KeyGen'/>. </t><t>Both parties must now update their retained shared secret rs1 in the cache.  But first they discard their old rs2 and copy their old rs1 to rs2.  Then they compute a new rs1 value from s0 this way: </t><t><list><t>  rs1 = HMAC(s0,"retained secret") </t></list></t><t>The old rs1 was saved to rs2 because of the risk of session interruption after one party has updated his own rs1 but before the other party has enough information to update her own rs1.  If that happens, they may regain cache sync in the next session by using rs2 (per <xref target='SharedSecretDetermination'/>).  This mitigates the well-known <xref target='Byzantine'>Byzantine Generals' Problem</xref>. </t><t>A ZRTP Session Key is generated which then allows the ZRTP Multistream mode to be used to generate SRTP key and salt pairs for additional concurrent media streams between this pair of ZRTP endpoints.  If a ZRTP Session Key has already been generated between this pair of endpoints and is available, no new ZRTP Session Key is calculated. </t><t><list><t>  ZRTPSess = HMAC(s0,"ZRTP Session Key") </t></list></t><t>The ZRTPSess key is kept for the duration of the call signaling session between the two ZRTP endpoints.  That is, if there are two separate calls between the endpoints (in SIP terms, separate SIP dialogs), then a ZRTP Session Key MUST NOT be used across the two call signaling sessions.  ZRTPSess MUST be destroyed no later than the end of the call signaling session. </t></section></section><section title="Multistream Mode"><t> The Multistream key agreement mode can be used to generate SRTP keys and salts for additional media streams established between a pair of endpoints.  Multistream mode cannot be used unless there is an active SRTP session established between the endpoints which means a ZRTP Session key is active.  This ZRTP Session key can be used to generate keys and salts without performing another DH calculation.  In this mode, the retained shared secret cache is not used or updated.  As a result, multiple ZRTP Multistream mode exchanges can be processed in parallel between two endpoints. </t><t>Multistream mode is selected by the initiator setting the Key Agreement Type to "Mult" in the Commit message.  The Cipher Type and Auth Tag Length in Multistream mode MUST be set by the initiator to the same as the values as in the initial DH Mode Commit.  These values in the Multistream commit packet SHOULD be ignored by the responder, and SHOULD be assumed to be the same as the values in the previous DH commit message.  The SAS Type is ignored as there is no SAS authentication in this mode. </t><t>In place of hvi in the Commit, a random nonce of length 4-words (16 octets) is chosen.  Its value MUST be unique for all nonce values chosen for active ZRTP sessions between a pair of endpoints. If a Commit is received with a reused nonce value, the ZRTP exchange MUST be immediately terminated. </t><t>Note: Since the nonce is used to calculate different SRTP key and salt pairs for each media stream, a duplication will result in the same key and salt being generated for the two media streams, which would have disastrous security consequences. </t><t>If a Commit is received selecting Multistream mode, but the responder does not have a ZRTP Session Key available, the exchange MUST be terminated.  Otherwise, the responder proceeds to the next section on Shared Secret Calculation, <xref target='MultSecretCalc'/></t><t>In Multistream mode, both the DHPart1 and DHPart2 messages are not sent.  After receiving the Commit message from the initiator, the responder sends the Confirm1 message after calculating this stream's SRTP keys, as described below. </t><section anchor='MultSecretCalc' title="Shared Secret Calculation for Multistream Mode"><t>A hash of the received and sent ZRTP messages in the current ZRTP exchange for the current media stream is calculated: </t><t><list><t>  total_hash = hash(Hello of responder | Commit ) </t></list></t><t>This refers to the Hello and Commit messages for the current media stream which is using Multistream mode, not the original media stream that included a full DH key agreement.  Note that only the ZRTP messages (<xref target='Hello_Msg'/> and <xref target='MultCommit_Msg'/>), not the entire ZRTP packets, are included in the hash. </t><t>The SRTP keys and salts for the initiator and responder are calculated using the ZRTP Session Key ZRTPSess and the nonce from the Commit message.  The nonce from the Commit message is implicitly included in the total_hash, which hashed the entire Commit message and the other party's Hello message.  For the nth media stream: </t><t><list><t>s0n = HMAC(ZRTPSess, total_hash) </t></list></t><t>Note that the responder's Hello message, included in the total_hash, includes some unique nonce-derived material of its own (the H3 hash image), thereby ensuring that each of the two parties can unilaterally force the resulting s0n shared secret to be unique for each media stream, even if one party by some error fails to produce a unique nonce.  Note also that the ZRTPSess key is derived from material that also includes a different and more inclusive total_hash from the entire packet sequence that performed the original DH exchange for the first media stream in this ZRTP session. </t><t>At this point in Multistream mode, the two endpoints begin key generation as described in <xref target='KeyGen'/> using s0n in place of s0 in the key generation formulas for this media stream. </t></section></section><section title="Preshared Mode"><t>The Preshared key agreement mode can be used to generate SRTP keys and salts without a DH calculation, instead relying on a shared secret from previous DH calculations between the endpoints. </t><t>This key agreement mode is useful to rapidly re-establish a secure session between two parties who have recently started and ended a secure session that has already performed a DH key agreement, without performing another lengthy DH calculation, which may be desirable on slow processors in resource-limited environments. Preshared mode MUST NOT be used for adding additional media streams to an existing call.  Multistream mode MUST be used for this purpose, since it is designed for that role, without sacrificing PFS. </t><t>In the most severe resource-limited environments, Preshared mode may be useful with processors that cannot perform a DH calculation in an ergonomically acceptable time limit.  Shared key material may be manually provisioned between two such endpoints in advance and still allow a limited subset of functionality. Such a "better than nothing" implementation would have to be regarded as non-compliant with the  ZRTP specification, but it could interoperate in Preshared (and if applicable, Multistream) mode with a compliant ZRTP endpoint. </t><t></t><section title="Commitment in Preshared Mode"><t>Preshared mode is selected by setting the Key Agreement Type to Preshared in the Commit message.  This results in the same call flow as Multistream mode.  The principal difference between Multistream mode and Preshared mode is that Preshared mode uses a previously cached shared secret, rs1, instead of an active ZRTP Session key, ZRTPSess, as the initial keying material. </t><t>The Commit message (<xref target='PrshCommit_Msg'/>) is sent by the initiator of the ZRTP exchange.  From the intersection of the algorithms in the sent and received Hello messages, the initiator chooses a hash, cipher, auth tag, key agreement type, and SAS type to be used. </t><t>In place of hvi in the Commit, two smaller fields are inserted by the initiator: </t><t><list><t> - A random nonce of length 4-words (16 octets). </t><t> - A keyID = HMAC(key, "Prsh") truncated to 64 bits. </t></list></t><t>The above HMAC key is the cached shared secret rs1, if one is available or alternatively it could be the trusted MiTM PBX shared secret pbxsecret, defined in <xref target='PBXenrollment'/>.  Or it may be manually provisioned as the auxiliary shared secret auxsecret.  If no such shared key is available in the cache, Preshared mode cannot be used. </t><t>The responder uses the received keyID to search for matching key material in its cache, comparing it with hashes of rs1, rs2, auxsecret, or pbxsecret. </t><t>When it finds the appropriate shared key, it is used to derive s0 and a new ZRTPSess key, as described in the next section on Shared Secret Calculation, <xref target='PrshSecretCalc'/>. </t><t>If the responder determines that it does not have a cached shared secret from a previous DH exchange, it SHOULD respond with its own DH Commit message.  This would reverse the roles and the responder would become the initiator, because the DH Commit must always "trump" the Preshared Commit message as described in <xref target='CommitContention'/>.  The key exchange would then proceeds using DH mode.  However, if a severely resource-limited responder lacks the computing resources to respond in a reasonable time with a DH Commit, it MAY respond with a ZRTP Error message (<xref target='ErrorMsg'/>) indicating that no shared secret is available. </t><t>Because Preshared mode depends on having a reliable shared secret in its cache, it is RECOMMENDED that Preshared mode only be used when the SAS Verified flag has been previously set. </t><t>If both sides send Preshared Commit messages initiating a secure session at the same time, the Commit message with the lowest nonce value is discarded and the other side is the initiator. This breaks the tie, allowing the protocol to proceed from this point with a clear definition of who is the initiator and who is the responder. </t></section><section anchor='PrshSecretCalc' title="Shared Secret Calculation for Preshared Mode"><t>A hash of the received and sent ZRTP messages in the current ZRTP exchange for the current media stream is calculated: </t><t><list><t>  total_hash = hash(Hello of responder | Commit ) </t></list></t><t>Note that only the ZRTP messages (<xref target='Hello_Msg'/> and <xref target='PrshCommit_Msg'/>), not the entire ZRTP packets, are included in the hash. The nonce from the Commit message is implicitly included in the total_hash, which hashed the entire Commit message and the other party's Hello message. </t><t><list><t>s0 = HMAC(rs1, total_hash)   [use whatever keyID matches: rs1, rs2, auxsecret, or pbxsecret] </t><t>ZRTPSess = HMAC(s0,"ZRTP Session Key") </t></list></t><t>Note that the responder's Hello message, included in the total_hash, includes some unique nonce-derived material of its own (the H3 hash image), thereby ensuring that each of the two parties can unilaterally force the resulting s0 shared secret to be unique for each media stream, even if one party by some error fails to produce a unique nonce. </t><t>Note: Since the nonce is used to calculate different SRTP key and salt pairs for each media stream, a duplication will result in the same key and salt being generated for the two media streams, which would have disastrous security consequences. </t><t>At this point in Preshared mode, the two endpoints begin key generation as described in <xref target='KeyGen'/>, now that there is a defined s0 and ZRTPSess key.  The ZRTPSess key allows the later use of Multistream mode for adding additional media streams. </t></section></section></section><section anchor='KeyGen' title="Key Generation"><t>The following calculations derive a set of keys from s0.  For the original media stream that calculated s0 from the DH exchange, s0 means the original s0.  For any additional media streams that were activated in Multistream mode, s0 means s0n, for the n-th media stream. </t><t>Various keys, such as those used by SRTP, must be derived from the shared secret s0.  To do this, ZRTP uses an HMAC-based key derivation function, keyed by s0, instead of simply drawing subkey material directly from s0, as defined in NIST SP800-56A.  The possibly greater noninvertability of HMAC may add an extra measure of isolation for the derived keys. </t><t>The SRTP master key and master salt are derived from s0.  Separate SRTP keys and salts are used in each direction for each media stream.  Unless otherwise specified, ZRTP uses SRTP with no MKI, 32 bit authentication using HMAC-SHA1, AES-CM 128 or 256 bit key length, 112 bit session salt key length, 2^48 key derivation rate, and SRTP prefix length 0. </t><t>The ZRTP initiator encrypts and the ZRTP responder decrypts packets by using srtpkeyi and srtpsalti, while the ZRTP responder encrypts and the ZRTP initiator decrypts packets by using srtpkeyr and srtpsaltr.  These are generated by: </t><t><list><t>    srtpkeyi = HMAC(s0,"Initiator SRTP master key") </t><t>    srtpsalti = HMAC(s0,"Initiator SRTP master salt") </t><t>    srtpkeyr = HMAC(s0,"Responder SRTP master key") </t><t>    srtpsaltr = HMAC(s0,"Responder SRTP master salt") </t></list></t><t>The SRTP key and salt values are truncated (taking the leftmost bits) to the length determined by the chosen SRTP algorithm. </t><t>The HMAC keys are the same length as the output of the underlying hash function, and are thus generated without truncation by: </t><t><list><t>    hmackeyi = HMAC(s0,"Initiator HMAC key") </t><t>    hmackeyr = HMAC(s0,"Responder HMAC key") </t></list></t><t>Note that these HMAC keys are used only by ZRTP and not by SRTP. </t><t>Note: Different HMAC keys are needed for the initiator and the responder to ensure that GoClear messages in each direction are unique and can not be cached by an attacker and reflected back to the endpoint. </t><t>ZRTP keys are generated for the initiator and responder to use to encrypt the Confirm1 and Confirm2 messages.  They are truncated to the same size as the negotiated SRTP key size. </t><t><list><t>    zrtpkeyi = HMAC(s0,"Initiator ZRTP key") </t><t>    zrtpkeyr = HMAC(s0,"Responder ZRTP key") </t></list></t><t>As soon as s0 has been used to calculate all the subkeys that are derived from it, it MUST be erased from memory.  All other key material, especially the SRTP keys and salts, and any material sufficient to derive the SRTP keys and salts, MUST also be erased from memory when they are no longer used, no later than the end of the call.  That includes ZRTPSess.  The only exceptions are the retained shared secrets, or other cached secrets needed for future calls. </t><t>The Short Authentication String (SAS) value is calculated from the HMAC of a fixed string, keyed with the ZRTPSess key derived from the DH key agreement.  This means the same SAS is used for all media streams which are derived from a single DH key agreement in a ZRTP session. </t><t><list><t>  sashash = HMAC(ZRTPSess,"SAS") </t><t>  sasvalue = sashash [truncated to leftmost 32 bits] </t></list></t></section><section title="Confirmation"><t>The Confirm1 and Confirm2 messages contain the cache expiration interval (defined in <xref target='CacheOperation'/>) for the newly generated retained shared secret. The flagoctet is an 8 bit unsigned integer made up of these flags: the PBX Enrollment flag (E) defined in <xref target='RelayingTheSAS'/>, SAS Verified flag (V) defined in <xref target='SASVerifiedFlag'/>, Allow Clear flag (A) defined in <xref target='GoClearTermination'/>, and Disclosure flag (D) defined in <xref target='DisclosureFlag'/>. </t><t><list><t>flagoctet =  (E * 2^3) + (V * 2^2) + (A * 2^1) + (D * 2^0) </t></list></t><t>Part of the Confirm1 and Confirm2 messages are encrypted using full-block Cipher Feedback Mode, and contain a 128-bit random CFB Initialization Vector (IV).  The Confirm1 and Confirm2 messages also contain an HMAC covering the encrypted part of the Confirm1 or Confirm2 message which includes a string of zeros, the signature length, flag octet, cache expiration interval, signature type block (if present) and signature block (if present).  For the responder </t><t><list><t>  hmac = HMAC(hmackeyr, encrypted part of Confirm1) </t></list></t><t>For the initiator: </t><t><list><t>  hmac = HMAC(hmackeyi, encrypted part of Confirm2) </t></list></t><t>The Conf2ACK message sent by the responder completes the exchange. </t></section><section anchor='Termination' title="Termination"><t>A ZRTP session is normally terminated at the end of a call, but it may be terminated early by either the Error message or the GoClear message. </t><section anchor='ErrorTermination' title="Termination via Error message"><t>The Error message (<xref target='ErrorMsg'/>) is used to terminate an in-progress ZRTP exchange due to an error. The Error message contains an integer Error Code for debugging purposes.  The termination of a ZRTP key agreement exchange results in no updates to the cached shared secrets and deletion of all crypto context. </t><t>The ZRTP Session key, ZRTPSess, is only deleted if the ZRTP session in which it was generated and all ZRTP sessions which are using it are terminated. </t></section><section anchor='GoClearTermination' title="Termination via GoClear message"><t>The GoClear message (<xref target='GoClearMsg'/>) is used to switch from SRTP to RTP, usually because the user has chosen to do that by pressing a button.  The GoClear uses an HMAC of the Message Type Block sent in the GoClear Message computed with the hmackey derived from the shared secret.  This HMAC is truncated to the leftmost 64 bits.  When sent by the initiator: </t><t><list><t>clear_hmac = HMAC(hmackeyi, "GoClear ") </t></list></t><t>When sent by the responder: </t><t><list><t>clear_hmac = HMAC(hmackeyr, "GoClear ") </t></list></t><t>A GoClear message which does not receive a ClearACK response must be resent.  If a GoClear message is received with a bad HMAC, it must be ignored, and no ClearACK is sent. </t><t>A ZRTP endpoint MAY choose to accept GoClear messages after the session has switched to SRTP, allowing the session to revert to RTP.  This is indicated in the Confirm1 or Confirm2 messages by setting the Allow Clear flag (A).  If both endpoints set the Allow Clear (A) flag in their Confirm message, GoClear messages MAY be sent. </t><t>A ZRTP endpoint that receives a GoClear authenticates the message by checking the clear_hmac.  If the message authenticates, the endpoint stops sending SRTP packets, and generates a ClearACK in response. It MUST also delete all the crypto key material for all the SRTP media streams, as defined in <xref target='keydestruct1'/>. </t><t>Until confirmation from the user is received (e.g. clicking a button, pressing a DTMF key, etc.), the ZRTP endpoint MUST NOT resume sending RTP packets.   The endpoint then renders to the user an indication that the media session has switched to clear mode, and waits for confirmation from the user. To prevent pinholes from closing or NAT bindings from expiring, the ClearACK message MAY be resent at regular intervals (e.g. every 5 seconds) while waiting for confirmation from the user.  After confirmation of the notification is received from the user, the sending of RTP packets may begin. </t><t>After sending a GoClear message, the ZRTP endpoint stops sending SRTP packets.  When a ClearACK is received, the ZRTP endpoint deletes the crypto context for the SRTP session, as defined in <xref target='keydestruct1'/>, and may then resume sending RTP packets. </t><t>In the event a ClearACK is not received before the retransmissions of GoClear are exhausted, the key material is deleted, as defined in <xref target='keydestruct1'/>. </t><t>After the users have transitioned from SRTP media back to RTP media (clear mode), they may decide later to return to secure mode by manual activation, usually by pressing a GO SECURE button.  In that case, a new secure session is initiated by the party that presses the button, by sending a new Commit packet, leadng to a new session key negotiation.  It is not necessary to send another Hello packet, as the two parties have already done that at the start of the call and thus have already discovered each other's ZRTP capabilities.  It is possible for users to toggle back and forth between clear and secure modes multiple times in the same call, just as they could in the old days of secure PSTN phones. </t><section anchor='keydestruct1' title="Key Destruction for GoClear message"><t>All SRTP session key material MUST be erased by the receiver of the GoClear message upon receiving a properly authenticated GoClear.  The same key destruction MUST be done by the sender of GoClear message, upon receiving the ClearACK. </t><t>In particular, the destroyed key material includes the SRTP session keys and salts, SRTP master keys and salts, and all material sufficient to reconstruct the SRTP keys and salts, including ZRTPSess (s0 should have been destroyed earlier).  All key material that would have been erased at the end of the SIP session MUST be erased.  However, ZRTPSess is destroyed in a manner different from the other key material.  Both parties replace ZRTPSess with a hash of itself, without truncation: </t><t><list><t>ZRTPSess = hash(ZRTPSess) </t></list></t><t>This meets the requirements of Perfect Forward Secrecy, but preserves a new version of ZRTPSess, so that if the user later re-initiates secure mode during the same call, the new key negotiation can (and SHOULD) use a Multistream Commit message, which requires and assumes the existence of ZRTPSess with the same value at both ZRTP endpoints.  Later, at the end of the entire call, ZRTPSess is finally destroyed along with the other key material. </t></section></section></section><section anchor='RNG' title="Random Number Generation"><t>The ZRTP protocol uses random numbers for cryptographic key material, notably for the DH secret exponents and nonces, which must be freshly generated with each session.  Whenever a random number is needed, all of the following criteria must be satisfied: </t><t>It MUST be freshly generated, meaning that it must not have been used in a previous calculation. </t><t>When generating a random number k of L bits in length, k MUST be chosen with equal probability from the range of [1 < k < 2^L]. </t><t>It MUST be derived from a physical entropy source, such as RF noise, acoustic noise, thermal noise, high resolution timings of environmental events, or other unpredictable physical sources of entropy.  For a detailed explanation of cryptographic grade random numbers and guidance for collecting suitable entropy, see <xref target="RFC4086">RFC 4086</xref> and Chapter 10 of <xref target="Ferguson">Practical Cryptography</xref>.  The raw entropy must be distilled and processed through a deterministic random bit generator (DRBG).   Examples of DRBGs may be found in <xref target="SP800-90">NIST SP 800-90</xref>, and in <xref target='Ferguson'/>.  Failure to use true entropy from the physical environment as a basis for generating random cryptographic key material would lead to a disastrous loss of security. </t></section><section anchor='CacheOperation' title="ZID and Cache Operation"><t>Each instance of ZRTP has a unique 96-bit random ZRTP ID or ZID that is generated once at installation time.  It is used to look up retained shared secrets in a local cache.  A single global ZID for a single installation is the simplest way to implement ZIDs.  However, it is specifically not precluded for an implementation to use multiple ZIDs, up to the limit of a separate one per callee.  This then turns it into a long-lived "association ID" that does not apply to any other associations between a different pair of parties.  It is a goal of this protocol to permit both options to interoperate freely. </t><t>Each time a new s0 is calculated, a new retained shared secret rs1 is generated and stored in the cache, indexed by the ZID of the other endpoint.  But first the previous rs1 is copied to rs2 and also stored in the cache. <!--to mitigate the <xref target='Byzantine'>Byzantine Generals' Problem</xref>.-->  For the new retained shared secret, each endpoint chooses a cache expiration value which is an unsigned 32 bit integer of the number of seconds that this secret should be retained in the cache.  The time interval is relative to when the Confirm1 message is sent or received. </t><t>The cache intervals are exchanged in the Confirm1 and Confirm2 messages.  The actual cache interval used by both endpoints is the minimum of the values from the Confirm1 and Confirm2 messages.  A value of 0 seconds means the newly-computed shared secret SHOULD NOT be stored in the cache, and if a cache entry already exists from an earlier call, the stored cache interval should be set to 0.  A value of 0xffffffff means the secret should be cached indefinitely and is the recommended value.  If the ZRTP exchange results in no new shared secret generation (i.e. Multistream or Preshared Modes), the field in the Confirm1 and Confirm2 is set to 0xffffffff and ignored, and the cache is not updated. </t><t>The expiration interval need not be used to force the deletion of a shared secret from the cache when the interval has expired.  It just means the shared secret MAY be deleted from that cache at any point after the interval has expired without causing the other party to note it as an unexpected security event when the next key negotiation occurs between the same two parties.  This means there need not be perfectly synchronized deletion of expired secrets from the two caches, and makes it easy to avoid a race condition that might otherwise be caused by clock skew. </t><section anchor='selfhealing' title="Self-healing Key Continuity Feature"><t>The key continuity features of ZRTP are analogous to those provided by <xref target="RFC4251">SSH (Secure Shell)</xref>, but they differ in one respect.  SSH caches public signature keys that do not change, and uses a private signature key that also never changes and must be forever guarded from disclosure.  ZRTP caches symmetric key material used to compute secret session keys, and these values change with each session.  If someone steals your SSH private signature key, they can impersonate you in all future sessions and mount a successful MiTM attack any time they want.  But if someone steals your ZRTP shared secret cache, they only get one chance to mount a MiTM attack, in the very next session. If they miss that chance, the retained shared secret is refreshed with a new value, and the window of vulnerability heals itself, which means they are locked out of any future opportunities to mount a MiTM attack.  This gives ZRTP a "self-healing" feature if any key material is compromised.  ZRTP operates entirely in the media path, so a MiTM attacker must always be in the media path.  This presents operational difficulties for the attacker in many VoIP usage scenarios, because being in the media path is often harder than being in the signaling path.  This means the attacker may often miss MiTM attack opportunities.  ZRTP's self-healing key continuity features are better than SSH at exploiting the MiTM attacker's missed opportunities.  Thus, ZRTP quickly recovers from any disclosure of cached key material. </t></section></section></section><section title="ZRTP Messages"><t>All ZRTP messages use the message format defined in <xref target='ZRTPpkt'/>. All word lengths referenced in this specification are 32 bits or 4 octets. All integer fields are carried in network byte order, that is, most significant byte (octet) first, commonly known as big-endian. </t><figure anchor='ZRTPpkt' title="ZRTP Packet Format"><artwork>  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0 0 1|Not Used (set to zero) |         Sequence Number       | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                  ZRTP Magic Cookie (0x5a525450)               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                        Source Identifier                      | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                                                               | |           ZRTP Message (length depends on Message Type)       | |                            . . .                              | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                          CRC (1 word)                         | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ZRTP Packet Format</artwork></figure><t>The Sequence Number is a count that is incremented for each ZRTP packet sent.  The count is initialized to a random value.  This is useful in estimating ZRTP packet loss and also detecting when ZRTP packets arrive out of sequence. </t><t>The ZRTP Magic Cookie is a 32 bit string that uniquely identifies a ZRTP packet, and has the value 0x5a525450. </t><t>Source Identifier is the SSRC number of the RTP stream that this ZRTP packet relates to.   For cases of forking or forwarding, RTP and hence ZRTP may arrive at the same port from several different sources - each of these sources will have a different SSRC and may initiate an independent ZRTP protocol session. </t><t>This format is clearly identifiable as non-RTP due to the first two bits being zero which looks like RTP version 0, which is not a valid RTP version number.  It is clearly distinguishable from STUN since the magic cookies are different.  The 12 not used bits are set to zero and MUST be ignored when received. </t><t>The ZRTP Messages are defined in <xref target='Hello_Msg'/> to <xref target='RelayACK_Msg'/> and are of variable length. </t><t>The ZRTP protocol uses a 32 bit CRC checksum in each ZRTP packet as defined in <xref target="RFC3309">RFC 3309</xref> to detect transmission errors.  ZRTP packets are typically transported by UDP, which carries its own built-in 16-bit checksum for integrity, but ZRTP does not rely on it.  This is because of the effect of an undetected transmission error in a ZRTP message.  For example, an undetected error in the DH exchange could appear to be an active man-in-the-middle attack.  The psychological effects of a false announcement of this by ZTRP clients can not be overstated.  The probability of such a false alarm hinges on a mere 16-bit checksum that usually protects UDP packets, so more error detection is needed.  For these reasons, this belt-and-suspenders approach is used to minimize the chance of a transmission error affecting the ZRTP key agreement. </t><t>The CRC is calculated across the entire ZRTP packet shown in <xref target='ZRTPpkt'/>, including the ZRTP Header and the ZRTP Message, but not including the CRC field. If a ZRTP message fails the CRC check, it is silently discarded. </t><section title="ZRTP Message Formats"><t> ZRTP messages are designed to simplify endpoint parsing requirements and to reduce the opportunities for buffer overflow attacks (a good goal of any security extension should be to not introduce new attack vectors). </t><t>ZRTP uses 8 octets (2 words) blocks to encode Message Type.  4 octets (1 word) blocks are used to encode Hash Type, Cipher Type, and Key Agreement Type, and Authentication Tag. The values in the blocks are ASCII strings which are extended with spaces (0x20) to make them the desired length. Currently defined block values are listed in Tables 1-6 below. </t><t>Additional block values may be defined and used. </t><t> ZRTP uses this ASCII encoding to simplify debugging and make it "Wireshark (Ethereal) friendly". </t><section title="Message Type Block"><t>Currently 14 Message Type Blocks are defined - they represent the set of ZRTP message primitives.  ZRTP endpoints MUST support the Hello, HelloACK, Commit, DHPart1, DHPart2, Confirm1, Confirm2, Conf2ACK, SASrelay, RelayACK, Error and ErrorACK block types.  ZRTP endpoints MAY support the GoClear and ClearACK messages.  Additional messages may be defined in extensions to ZRTP. </t><figure><artwork> Message Type Block   |  Meaning  ---------------------------------------------------  "Hello   "           |  Hello Message                      |  defined in Section 6.2 --------------------------------------------------- "HelloACK"           |  HelloACK Message                       |  defined in Section 6.3 ---------------------------------------------------  "Commit  "           |  Commit Message                       |  defined in Section 6.4 --------------------------------------------------- "DHPart1 "           |  DHPart1 Message                      |  defined in Section 6.5 --------------------------------------------------- "DHPart2 "           |  DHPart2 Message                       |  defined in Section 6.6 --------------------------------------------------- "Confirm1"           |  Confirm1 Message                      |  defined in Section 6.7 --------------------------------------------------- "Confirm2"           |  Confirm2 Message                       |  defined in Section 6.7 --------------------------------------------------- "Conf2ACK"           |  Conf2ACK Message                       |  defined in Section 6.8 --------------------------------------------------- "Error   "           |  Error Message                       |  defined in Section 6.9 --------------------------------------------------- "ErrorACK"           |  ErrorACK Message                       |  defined in Section 6.10 --------------------------------------------------- "GoClear "           |  GoClear Message                       |  defined in Section 6.11 --------------------------------------------------- "ClearACK"           |  ClearACK Message                       |  defined in Section 6.12 --------------------------------------------------- "SASrelay"           |  SASrelay Message                       |  defined in Section 6.13 --------------------------------------------------- "RelayACK"           |  RelayACK Message                       |  defined in Section 6.14 --------------------------------------------------- Table 1. Message Block Type Values</artwork></figure></section><section title="Hash Type Block"><t> Only one Hash Type is currently defined, SHA256, and all ZRTP endpoints MUST support this hash.   Additional Hash Types can be registered and used. </t><figure><artwork> Hash Type Block      |  Meaning --------------------------------------------------- "S256"               |  SHA-256 Hash defined in [SHA-256]  --------------------------------------------------- Table 2. Hash Block Type Values</artwork></figure></section><section title="Cipher Type Block"><t>All ZRTP endpoints MUST support AES-128 (AES1) and MAY support AES-256 (AES3). or other Cipher Types.  The choice of the AES key length is coupled to the Key Agreement type, as explained in <xref target="KeyAgreementType"/>. </t><t>The use of AES-128 in SRTP is defined by <xref target="RFC3711"/>. The use of AES-256 in SRTP is defined by <xref target='I-D.ietf-avt-srtp-big-aes'/>. </t><figure><artwork>  Cipher Type Block    |  Meaning ---------------------------------------------------  "AES1"                |  AES-CM with 128 bit keys                       |  as defined in RFC 3711 ---------------------------------------------------  "AES3"                |  AES-CM with 256 bit keys                       |   ---------------------------------------------------  Table 3. Cipher Block Type Values</artwork></figure></section><section title="Auth Tag Block"><t>All ZRTP endpoints MUST support HMAC-SHA1 authentication, 32 bit and 80 bit length tags as defined in <xref target="RFC3711"/>. </t><figure><artwork> Auth Tag Block        |  Meaning --------------------------------------------------- "HS32"                |  HMAC-SHA1 32 bit authentication                        |  tag as defined in RFC 3711 --------------------------------------------------- "HS80"                |  HMAC-SHA1 80 bit authentication                        |  tag as defined in RFC 3711 --------------------------------------------------- Table 4. Auth Tag Values</artwork></figure></section><section anchor='KeyAgreementType' title="Key Agreement Type Block"><t>All ZRTP endpoints MUST support DH3k and Multistream, SHOULD support Preshared, and MAY support EC25, EC38, and EC52. </t><t>For Finite Field Diffie-Hellman, ZRTP endpoints MUST use the DH parameters defined in <xref target="RFC3526">RFC 3526</xref>, as follows.  DH3k uses the 3072-bit MODP group.  The DH generator g is 2.  The random Diffie-Hellman secret exponent SHOULD be twice as long as the AES key length.  If AES-128 is used, the DH secret value SHOULD be 256 bits long.  If AES-256 is used, the secret value SHOULD be 512 bits long. </t><t>If Elliptic Curve DH is used, the ECDH algorithm and key generation is from <xref target="SP800-56A">NIST SP 800-56A</xref>.  The curves used are from <xref target="NSA-Suite-B">NSA Suite B</xref>, which uses the same curves as ECDSA defined by <xref target="FIPS-186-3">FIPS 186-3</xref>, and can also be found in <xref target="RFC4753">RFC 4753</xref>, sections 3.1 through 3.3. The validation procedures are from <xref target="SP800-56A">NIST SP 800-56A</xref> section 5.6.2.6, method 3, ECC Partial Validation.  Both the X and Y coordinates of the point on the curve are sent, in the first and second half of the ECDH public value, respectively. </t><t>The choice of AES key length is coupled to the choice of key agreement type.  If AES-128 is chosen, DH3k SHOULD be used, or EC25 if supported.  If AES-256 is chosen, either EC38 or EC52 SHOULD be used. </t><t>ZRTP also defines two non-DH modes, Multistream and Preshared, in which the SRTP key is derived from a shared secret and some nonce material. </t><t>Table 5 lists the pv length in words and DHPart1 and DHPart2 message length in words for each Key Agreement Type Block.</t><figure><artwork> Key Agreement |  pv   | message | Meaning Type Block    | words |  words  |  --------------------------------------------------- "DH3k"        |   96  |   117   |  DH mode with p=3072 bit prime                |       |         |  as defined in RFC 3526 --------------------------------------------------- "Prsh"        |    -  |     -   |  Preshared Non-DH mode               |       |         |  --------------------------------------------------- "Mult"        |    -  |     -   |  Multistream Non-DH mode               |       |         | --------------------------------------------------- "EC25"        |   16  |    37   |  Elliptic Curve DH, P-256               |       |         |  per RFC 4753, section 3.1 --------------------------------------------------- "EC38"        |   24  |    45   |  Elliptic Curve DH, P-384               |       |         |  per RFC 4753, section 3.2 --------------------------------------------------- "EC52"        |   33  |    54   |  Elliptic Curve DH, P-521               |       |         |  per RFC 4753, section 3.3 --------------------------------------------------- Table 5. Key Agreement Block Type Values</artwork></figure></section><section title="SAS Type Block"><t>All ZRTP endpoints MUST support the base32 and MAY support base256 Short Authentication String scheme, and other SAS rendering schemes.  The ZRTP SAS is described in <xref target='SAS'/>. </t><figure><artwork>  SAS Type Block       |  Meaning --------------------------------------------------- "B32 "                |  Short Authentication String using                       |  base32 encoding defined in Section 8.  --------------------------------------------------- "B256"                |  Short Authentication String using                       |  base256 encoding defined in Section 8.  --------------------------------------------------- Table 6. SAS Block Type Values </artwork></figure><t>The SAS Type determines how the SAS is rendered to the user so that the user may compare it with his partner over the voice channel.  This allows detection of a man-in-the-middle (MITM) attack. </t></section><section title="Signature Type Block"><t>The signature type block is a 4 octet (1 word) block used to represent the signature algorithm.  Suggested signature algorithms and key lengths are a future subject of standardization. </t></section></section><section anchor='HelloMsg' title="Hello message"><t>The Hello message has the format shown in <xref target='Hello_Msg'/>.  The Hello ZRTP message begins with the preamble value 0x505a then a 16 bit length in 32 bit words.  This length includes only the ZRTP message (including the preamble and the length) but not the ZRTP header or CRC. </t><t>Next is the Message Type Block and a 4 character string containing the version (ver) of the ZRTP protocol, currently "0.85" (when this specification reaches RFC status, the protocol version will become "1.00"). Next is the Client Identifier string (cid) which is 4 words long and identifies the vendor and release of the ZRTP software. The 256-bit hash image H3 is defined in <xref target='Hashchains'/>.  The next parameter is the ZID, the 96 bit long unique identifier for the ZRTP endpoint. </t><t>The next four bits contains flag bits. The Passive flag (P) is a Boolean normally set to False.  A ZRTP endpoint which is configured to never initiate secure sessions is regarded as passive, and would set the P bit to True.  The next 8 bits are unused.  They should be set to zero when sent and ignored on receipt. </t><t>Next is a list of supported Hash algorthms, Cipher algorithms, SRTP Auth Tag types, Key Agreement types, and SAS types.  The number of listed algorithms are listed for each type: hc=hash count, cc=cipher count, ac=auth tag count, kc=key agreement count, and sc=sas count.  The values for these algorithms are defined in Tables 2, 3, 4, 5, and 6.  A count of zero means that only the mandatory to implement algorithms are supported.  Mandatory algorithms MAY be included in the list.  The order of the list indicates the preferences of the endpoint.  If a mandatory algorithm is not included in the list, it is added to the end of the list for preference. </t><t>Note: Implementers are encouraged to keep these algorithm lists small - the list does not need to include every cipher and hash supported, just the ones the endpoint would prefer to use for this ZRTP exchange. </t><t>The 64-bit HMAC at the end of the message is computed across the whole message, not including the HMAC, of course.  The HMAC key is the sender's H2 (defined in <xref target='Hashchains'/>), and thus cannot be checked by the receiving party until the sender's H2 value is known to the receiving party later in the protocol. </t><figure anchor='Hello_Msg' title="Hello message format"><artwork>  0                   1                   2                   3   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|             length            | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |            Message Type Block="Hello   " (2 words)            | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                   version="0.85" (1 word)                     | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                                                               | |                Client Identifier (4 words)                    | |                                                               | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                                                               | |                   Hash image H3 (8 words)                     | |                             . . .                             | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                                                               | |                         ZID  (3 words)                        | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|0|0|P| unused (zeros)|  hc   |  cc   |  ac   |  kc   |  sc   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                 hash algorthms (0 to 7 values)                | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |               cipher algorthms (0 to 7 values)                | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                  auth tag types (0 to 7 values)               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |               key agreement types (0 to 7 values)             | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                    SAS types (0 to 7 values)                  | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                         HMAC (2 words)                        | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Hello message format</artwork></figure></section><section title="HelloACK message"><t>The HelloACK message is used to stop retransmissions of a Hello message.  A HelloACK is sent regardless if the version number in the Hello is supported or the algorithm list supported.  The receipt of a HelloACK stops retransmission of the Hello message. The format is shown in the Figure below.  Note that a Commit message can be sent in place of a HelloACK by an Initiator. </t><figure anchor='HelloACK_Msg' title="HelloACK message format"><artwork>  0                   1                   2                   3   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|         length=3 words        | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |              Message Type Block="HelloACK" (2 words)          | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ HelloACK message format</artwork></figure></section><section anchor='CommitMsg' title="Commit message"><t>The Commit message is sent to initiate the key agreement process after both sides have received a Hello message, which means it can only be sent after receiving both a Hello message and a HelloACK message.  The Commit message contains the Initiator's ZID and a list of selected algorithms (hash, cipher, auth tag type, key agreement, sas type), and hvi, which is a hash of the DHPart2 of the Initiator and the Responder's Hello message, as explained in <xref target='HashCommit'/>.  The hash image H2 is defined in <xref target='Hashchains'/>.  The Commit Message formats are shown in <xref target='DHCommit_Msg'/>, <xref target='MultCommit_Msg'/>, and <xref target='PrshCommit_Msg'/>. </t><t>The 64-bit HMAC at the end of the message is computed across the whole message, not including the HMAC, of course.  The HMAC key is the sender's H1 (defined in <xref target='Hashchains'/>), and thus cannot be checked by the receiving party until the sender's H1 value is known to the receiving party later in the protocol. </t><figure anchor='DHCommit_Msg' title="DH Commit message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=29 words        |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="Commit  " (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                   Hash image H2 (8 words)                     |    |                             . . .                             |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                         ZID  (3 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                       hash algorihm                           |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                      cipher algorihm                          |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                       auth tag type                           |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                     key agreement type                        |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                         SAS type                              |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                       hvi (8 words)                           |    |                           . . .                               |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                         HMAC (2 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    DH Commit message format</artwork></figure><figure anchor='MultCommit_Msg' title="Multistream Commit message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=25 words        |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="Commit  " (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                   Hash image H2 (8 words)                     |    |                             . . .                             |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                         ZID  (3 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                       hash algorihm                           |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                      cipher algorihm                          |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                       auth tag type                           |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                  key agreement type = "Mult"                  |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                         SAS type                              |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                       nonce (4 words)                         |    |                           . . .                               |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                         HMAC (2 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    Multistream Commit message format</artwork></figure><figure anchor='PrshCommit_Msg' title="Preshared Commit message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=27 words        |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="Commit  " (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                   Hash image H2 (8 words)                     |    |                             . . .                             |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                         ZID  (3 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                       hash algorihm                           |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                      cipher algorihm                          |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                       auth tag type                           |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                   key agreement type = "Prsh"                 |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                         SAS type                              |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                       nonce (4 words)                         |    |                           . . .                               |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                        keyID (2 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                         HMAC (2 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    Preshared Commit message format</artwork></figure></section><section title="DHPart1 message"><t>The DHPart1 message begins the DH exchange.  The format is shown in <xref target='DHPart1_Msg'/> below.  The DHPart1 message is sent by the Responder if a valid Commit message is received from the Initiator. The length of the pvr value and the length of the DHPart1 message depends on the Key Agreement Type chosen.  This information is contained in Table 5.  Note that for both Multistream and Preshared modes, no DHPart1 or DHPart2 message will be sent. </t><t>The 256-bit hash image H1 is defined in <xref target='Hashchains'/>. </t><t>The next four parameters are HMACs of potential shared secrets used in generating the ZRTP secret. The first two, rs1IDr and rs2IDr, are the HMACs of the responder's two retained shared secrets, truncated to 64 bits.  Next is auxsecretIDr, the HMAC of the responder's auxsecret (defined in <xref target='SharedSecretDetermination'/>), truncated to 64 bits.  The last parameter is the HMAC of the trusted MiTM PBX shared secret pbxsecret, defined in <xref target='PBXenrollment'/>. The Message format for the DHPart1 message is shown in <xref target='DHPart1_Msg'/>. </t><t>The 64-bit HMAC at the end of the message is computed across the whole message, not including the HMAC, of course.  The HMAC key is the sender's H0 (defined in <xref target='Hashchains'/>), and thus cannot be checked by the receiving party until the sender's H0 value is known to the receiving party later in the protocol. </t><figure anchor='DHPart1_Msg' title="DH Part1 message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|   length=depends on KA Type   |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="DHPart1 " (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                   Hash image H1 (8 words)                     |    |                             . . .                             |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                        rs1IDr (2 words)                       |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                        rs2IDr (2 words)                       |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                     auxsecretIDr (2 words)                    |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                     pbxsecretIDr (2 words)                    |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                  pvr (length depends on KA Type)              |    |                               . . .                           |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                         HMAC (2 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    DHPart1 message format</artwork></figure></section><section title="DHPart2 message"><t>The DHPart2 message completes the DH exchange.  A DHPart2 message is sent by the Initiator if a valid DHPart1 message is received from the Responder.  The length of the pvr value and the length of the DHPart2 message depends on the Key Agreement Type chosen.  This information is contained in Table 5.  Note that for both Multistream and Preshared modes, no DHPart1 or DHPart2 message will be sent. </t><t>The 256-bit hash image H1 is defined in <xref target='Hashchains'/>. </t><t>The next four parameters are HMACs of potential shared secrets used in generating the ZRTP secret. The first two, rs1IDi and rs2IDi, are the HMACs of the initiator's two retained shared secrets, truncated to 64 bits.  Next is auxsecretIDi, the HMAC of the initiator's auxsecret (defined in <xref target='SharedSecretDetermination'/>), truncated to 64 bits.  The last parameter is the HMAC of the trusted MiTM PBX shared secret pbxsecret, defined in <xref target='PBXenrollment'/>. The message format for the DHPart2 message is shown in <xref target='DHPart2_Msg'/>. </t><t>The 64-bit HMAC at the end of the message is computed across the whole message, not including the HMAC, of course.  The HMAC key is the sender's H0 (defined in <xref target='Hashchains'/>), and thus cannot be checked by the receiving party until the sender's H0 value is known to the receiving party later in the protocol. </t><figure anchor='DHPart2_Msg' title="DH Part2 message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|   length=depends on KA Type   |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="DHPart2 " (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                   Hash image H1 (8 words)                     |    |                             . . .                             |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                        rs1IDi (2 words)                       |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                        rs2IDi (2 words)                       |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                     auxsecretIDi (2 words)                    |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                     pbxsecretIDi (2 words)                    |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                  pvi (length depends on KA Type)              |    |                               . . .                           |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                         HMAC (2 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    DHPart2 message format</artwork></figure></section><section anchor='ConfirmMsg' title="Confirm1 and Confirm2 messages"><t>The Confirm1 message is sent by the Responder in response to a valid DHPart2 message after the SRTP session key and parameters have been negotiated. The Confirm2 message is sent by the Initiator in response to a Confirm1 message.  The format is shown in <xref target='Confirm_Msg'/> below.  The message contains the Message Type Block "Confirm1" or "Confirm2". Next is the HMAC, a keyed hash over encrypted part of the message (shown enclosed by "===" in <xref target='Confirm_Msg'/>.)  The next 16 octets contain the CFB Initialization Vector.  The rest of the message is encrypted using CFB and protected by the HMAC. </t><t>The first field inside the encrypted region is the hash pre-image H0, which is defined in detail in <xref target='Hashchains'/>. </t><t>The next 16 bits are not used.  They SHOULD be set to zero and MUST be ignored in received Confirm1 or Confirm2 messages. </t><t>The next 8 bits contain the signature length.  If no SAS signature (described in <xref target='SignSAS'/>) is present, all bits are set to zero.  The signature length is in words and includes the signature type block. If the calculated signature octet count is not a multiple of 4, zeros are added to pad it out to a word boundary. If no signature block is present, the overall length of the Confirm1 or Confirm2 Message will be set to 19 words. </t><t>The next 8 bits are used for flags.  Undefined flags are set to zero and ignored.  Four flags are currently defined.  The PBX Enrollment flag (E) is a Boolean bit defined in <xref target='RelayingTheSAS'/>.  The SAS Verified flag (V) is a Boolean bit defined in <xref target='SASVerifiedFlag'/>.  The Allow Clear flag (A) is a Boolean bit defined in <xref target='GoClearTermination'/>.  The Disclosure Flag (D) is a Boolean bit defined in <xref target='DisclosureFlag'/>. The cache expiration interval is defined in <xref target='CacheOperation'/>. </t><t>If the signature length (in words) is non-zero, a signature type block will be present along with a signature block.  Next is the signature block.  The signature block includes the key used to generate the signature. </t><t><xref target='SP800-38A'>CFB</xref> mode is applied with a feedback length of 128-bits, a full cipher block, and the final block is truncated to match the exact length of the encrypted data.  The CFB Initialization Vector is a 128 bit random nonce.  The block cipher algorithm and the key size is the same as what was negotiated for the media encryption.  CFB is used to encrypt the part of the Confirm1 message beginning after the CFB IV to the end of the message (the encrypted region is enclosed by "======" in <xref target='Confirm_Msg'/>). </t><t>The responder uses the zrtpkeyr to encrypt the Confirm1 message.  The initiator uses the zrtpkeyi to encrypt the Confirm2 message. </t><figure anchor='Confirm_Msg' title="Confirm1 and Confirm2 message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|         length=variable       |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |      Message Type Block="Confirm1" or "Confirm2" (2 words)    |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                         HMAC (2 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                CFB Initialization Vector (4 words)            |    |                                                               |    |                                                               |    +===============================================================+    |                                                               |    |                 Hash pre-image H0 (8 words)                   |    |                             . . .                             |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    | Unused (Set to zero, ignored) |  sig length   |0 0 0 0|E|V|A|D|     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              cache expiration interval (1 word)               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |      optional signature type block (1 word if present)        |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |           optional signature block (variable length)          |    |                            . . .                              |    |                                                               |    |                                                               |    +===============================================================+    Confirm1 and Confirm2 message format</artwork></figure></section><section anchor='Conf2ACKMsg' title="Conf2ACK message"><t>The Conf2ACK message is sent by the Responder in response to a valid Confirm2 message.  The message format for the Conf2ACK is shown in the Figure below.  The receipt of a Conf2ACK stops retransmission of the Confirm2 message. </t><figure anchor='Conf2ACK_Msg' title="Conf2ACK message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|         length=3 words        |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="Conf2ACK" (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        Conf2ACK message format</artwork></figure></section><section anchor='ErrorMsg' title="Error message"><t>The Error message is sent to terminate an in-process ZRTP key agreement exchange due to an error.  The format is shown in the Figure below.  The use of the Error message is described in <xref target='ErrorTermination'/>. </t><figure anchor='Error_Msg' title="Error message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=4 words         |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="Error   " (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |               Integer Error Code (1 word)                     |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    Error message format</artwork></figure><t>Defined hexadecimal values for the Error Code are listed in Table 7. </t><figure><artwork>Error Code |  Meaning----------------------------------------------------------- 0x10      | Malformed packet (CRC OK, but wrong structure)----------------------------------------------------------- 0x20      | Critical software error----------------------------------------------------------- 0x30      | Unsupported ZRTP version----------------------------------------------------------- 0x40      | Hello components mismatch----------------------------------------------------------- 0x51      | Hash type not supported----------------------------------------------------------- 0x52      | Cipher type not supported----------------------------------------------------------- 0x53      | Public key exchange not supported----------------------------------------------------------- 0x54      | SRTP auth. tag not supported----------------------------------------------------------- 0x55      | SAS scheme not supported----------------------------------------------------------- 0x56      | No shared secret available, DH mode required----------------------------------------------------------- 0x61      | DH Error: bad pvi or pvr ( == 1, 0, or p-1)----------------------------------------------------------- 0x62      | DH Error: hvi != hashed data----------------------------------------------------------- 0x63      | Received relayed SAS from untrusted MiTM----------------------------------------------------------- 0x70      | Auth. Error: Bad Confirm pkt HMAC----------------------------------------------------------- 0x80      | Nonce reuse----------------------------------------------------------- 0x90      | Equal ZIDs in Hello----------------------------------------------------------- 0x100     | GoClear packet received, but not allowed-----------------------------------------------------------Table 7. ZRTP Error Codes</artwork></figure></section><section anchor='ErrorAckMsg' title="ErrorACK message"><t>The ErrorACK message is sent in response to an Error message.  The format is shown in the Figure below. </t><figure anchor='ErrorAck_Msg' title="ErrorAck message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=3 words         |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="ErrorACK" (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    ErrorACK message format</artwork></figure></section><section anchor='GoClearMsg' title="GoClear message"><t>Support for the GoClear message is OPTIONAL in the protocol, and it is sent to switch from SRTP to RTP.  The format is shown in the Figure below.  The clear_hmac is used to authenticate the GoClear message so that bogus GoClear messages introduced by an attacker can be detected and discarded.   The use of GoClear is described in <xref target='GoClearTermination'/>. </t><figure anchor='GoClear_Msg' title="GoClear message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=5 words         |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="GoClear " (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                       clear_hmac (2 words)                    |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    GoClear message format</artwork></figure></section><section anchor='ClearAckMsg' title="ClearACK message"><t>Support for the ClearACK message is OPTIONAL in the protocol, and it is sent to acknowledge receipt of a GoClear.  A ClearACK is only sent if the clear_hmac from the GoClear message is authenticated.  Otherwise, no response is returned.  The format is shown in the Figure below. </t><figure anchor='ClearAck_Msg' title="ClearAck message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=3 words         |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="ClearACK" (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    ClearACK message format</artwork></figure></section><section anchor='SASRelayMsg' title="SASrelay message"><t>The SASrelay message is sent by a trusted Man in The Middle (MiTM), most often a PBX.  It is not sent as a response to a packet, but is sent as a self-initiated packet by the trusted MiTM.  It can only be sent after the rest of the ZRTP key negotiations have completed, after the Confirm packets and their ACKs.  It can only be sent after the trusted MiTM has finished key negotiations with the other party, because it is the other party's SAS that is being relayed.  It is sent with retry logic until a RelayACK message (<xref target='RelayACKMsg'/>) is received or the retry schedule has been exhausted.  The SASrelay message format is shown in <xref target='SASrelay_Msg'/> below.  The message contains the Message Type Block "SASrelay". Next is the HMAC, a keyed hash over encrypted part of the message (shown enclosed by "===" in <xref target='SASrelay_Msg'/>.)  The next 16 octets contain the CFB Initialization Vector.  The rest of the message is encrypted using CFB and protected by the HMAC. </t><t>The next 16 bits are not used.  They SHOULD be set to zero and MUST be ignored in received SASrelay messages. </t><t>The next 8 bits contain the signature length.  The trusted MiTM MAY compute a digital signature on the SAS hash, as described in <xref target='SignSAS'/>, using a persistant signing key owned by the trusted MiTM.  If no SAS signature is present, all bits are set to zero.  The signature length is in words and includes the signature type block. If the calculated signature octet count is not a multiple of 4, zeros are added to pad it out to a word boundary. If no signature block is present, the overall length of the SASrelay Message will be set to 12 words. </t><t>The next 8 bits are used for flags.  Undefined flags are set to zero and ignored. Three flags are currently defined.  The Disclosure Flag (D) is a Boolean bit defined in <xref target='DisclosureFlag'/>. The Allow Clear flag (A) is a Boolean bit defined in <xref target='GoClearTermination'/>.  The SAS Verified flag (V) is a Boolean bit defined in <xref target='SASVerifiedFlag'/>. These flags are updated values to the same flags provided earlier in the Confirm packet, but they are updated to reflect the new flag information relayed by the PBX from the other party. </t><t>The next 32 bit word contains the rendering scheme for the relayed sasvalue, which will be the same rendering scheme used by the other party on the other side of the trusted MiTM. <xref target='RelayingTheSAS'/> describes how the PBX determines whether the ZRTP client regards the PBX as a trusted MiTM. If the PBX determines that the ZRTP client trusts the PBX, the next 32 bit word contains the binary sasvalue relayed from the other party.  If this SASRelay packet is being sent to a ZRTP client that does not trust this MiTM, the next 32 bit word will be ignored by the recipient and should be set to zero by the PBX. </t><t>If the signature length (in words) is non-zero, a signature type block will be present along with a signature block.  Next is the signature block.  The signature block includes the key used to generate the signature. </t><t><xref target='SP800-38A'>CFB</xref> mode is applied with a feedback length of 128-bits, a full cipher block, and the final block is truncated to match the exact length of the encrypted data.  The CFB Initialization Vector is a 128 bit random nonce.  The block cipher algorithm and the key size is the same as what was negotiated for the media encryption.  CFB is used to encrypt the part of the SASrelay message beginning after the CFB IV to the end of the message (the encrypted region is enclosed by "======" in <xref target='SASrelay_Msg'/>). </t><t>Depending on whether the trusted MiTM had taken the role of the initiator or the responder during the ZRTP key negotiation, the SASrelay message is encrypted with zrtpkeyi or zrtpkeyr. </t><figure anchor='SASrelay_Msg' title="SASrelay message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|         length=variable       |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |             Message Type Block="SASrelay" (2 words)           |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                         HMAC (2 words)                        |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |                CFB Initialization Vector (4 words)            |    |                                                               |    |                                                               |    +===============================================================+    | Unused (Set to zero, ignored) |  sig length   |0 0 0 0|0|V|A|D|     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |         rendering scheme of relayed sasvalue (1 word)         |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |            Trusted MITM relayed sasvalue (1 word)             |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |      optional signature type block (1 word if present)        |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |                                                               |    |           optional signature block (variable length)          |    |                            . . .                              |    |                                                               |    |                                                               |    +===============================================================+    SASrelay message format</artwork></figure></section><section anchor='RelayACKMsg' title="RelayACK message"><t>The RelayACK message is sent in response to a valid SASrelay message.  The message format for the RelayACK is shown in the Figure below.  The receipt of a RelayACK stops retransmission of the SASrelay message. </t><figure anchor='RelayACK_Msg' title="RelayACK message format"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|         length=3 words        |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    |              Message Type Block="RelayACK" (2 words)          |    |                                                               |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    RelayACK message format</artwork></figure></section></section><section anchor='Retransmissions' title="Retransmissions"><t>ZRTP uses two retransmission timers T1 and T2.  T1 is used for retransmission of Hello messages, when the support of ZRTP by the other endpoint may not be known.  T2 is used in retransmissions of all the other ZRTP messages. </t><t>All message retransmissions MUST be identical to the initial message including nonces, public values, etc; otherwise, hashes of the message sequences may not agree. </t><t>Practical experience has shown that RTP packet loss at the start of an RTP session can be extremely high.  Since the entire ZRTP message exchange occurs during this period, the defined retransmission scheme is defined to be aggressive.  Since ZRTP packets with the exception of the DHPart1 and DHPart2 messages are small, this should have minimal effect on overall bandwidth utilization of the media session. </t><t>ZRTP endpoints MUST NOT exceed the bandwidth of the resulting media session as determined by the offer/answer exchange in the signaling layer. </t><t>Hello ZRTP requests are retransmitted at an interval that starts at T1 seconds and doubles after every retransmission, capping at 200ms.   A Hello message is retransmitted 20 times before giving up.  T1 has a recommended initial value of 50 ms. Retransmission of a Hello ends upon receipt of a HelloACK or Commit message. </t><t>Non-Hello ZRTP requests are retransmitted only by the initiator - that is, only Commit, DHPart2, Confirm2, and GoClear are retransmitted if the corresponding message from the responder, DHPart1, Confirm1, Conf2ACK, and ClearACK, are not received.  Non-Hello ZRTP messages are retransmitted at an interval that starts at T2 seconds and doubles after every retransmission, capping at 600ms.  Only the ZRTP initiator performs retransmissions.  Each message is retransmitted 10 times before giving up and resuming a normal RTP session.  T2 has a recommended initial value of 150ms.  Each message has a response message that stops retransmissions, as shown in Table 8.  The high value of T2 means that retransmissions will likely only occur with packet loss. </t><figure><artwork>    Message      Acknowledgement Message    -------      -----------------------    Hello        HelloACK or Commit    Commit       DHPart1 or Confirm1    DHPart2      Confirm1    Confirm1     Confirm2    Confirm2     Conf2ACK    GoClear      ClearACK    Error        ErrorACK    SASrelay     RelayACK   Table 8. Retransmitted ZRTP Messages and Responses </artwork></figure></section><section anchor='SAS' title="Short Authentication String"><t>This section will discuss the implementation of the Short Authentication String, or SAS in ZRTP.   The SAS can be verbally verified by the human users reading the string aloud, or by validating a digital signature exchanged in the Confirm1 or Confirm2 messages. </t><t>The rendering of the SAS value to the user depends on the SAS Type agreed upon in the Commit message.  For the SAS Type of base32, the leftmost 20 bits of the 32-bit sasvalue are rendered as a form of base32 encoding known as <xref target="z-base-32"> z-base-32</xref>. The purpose of z-base-32 is to represent arbitrary sequences of octets in a form that is as convenient as possible for human users to manipulate.  As a result, the choice of characters is slightly different from base32 as defined in RFC 3548.  The leftmost 20 bits of the sasvalue results in four base32 characters which are rendered to both ZRTP endpoints. For the SAS Type of base256, the leftmost 16 bits of the 32-bit sasvalue are rendered using the <xref target="base256">PGP Wordlist</xref>, <xref target="pgpwordlist"/>.  Other SAS Types may be defined to render the SAS value in other ways. </t><t>The SAS SHOULD be rendered to the user for authentication.  In addition, the SAS SHOULD be sent in a subsequent offer/answer exchange (a re-INVITE in SIP) after the completion of ZRTP exchange using the ZRTP SAS SDP attributes defined in <xref target='SignalingInteractions'/>. </t><t>The SAS is not treated as a secret value, but it must be compared to see if it matches at both ends of the communications channel.  The two users read it aloud to their partners to see if it matches.  This allows detection of a man-in-the-middle (MITM) attack. </t><t>There is only one SAS value computed per call.  That is the SAS value for the first media stream established, which computes the ZRTPSess key, using DH mode. The ZRTPSess key is used to compute the SAS, as well as the SRTP session keys for each additional media stream in Multistream mode.  This SAS applies to all media streams for the same call. </t><section anchor='SASVerifiedFlag' title="SAS Verified Flag"><t>The SAS Verified flag (V) is set based on the user indicating that SAS comparison has been successfully performed.  The SAS Verified flag is exchanged securely in the Confirm1 and Confirm2 messages of the next session.  In other words, each party sends the SAS Verified flag from the previous session in the Confirm message of the current session.  It is perfectly reasonable to have a ZRTP endpoint that never sets the SAS Verified flag, because it would require adding complexity to the user interface to allow the user to set it.   The SAS Verified flag is not required to be set, but if it is available to the client software, it allows for the possibility that the client software could render to the user that the SAS verify procedure was carried out in a previous session. </t><t>Regardless of whether there is a user interface element to allow the user to set the SAS Verified flag, it is worth caching a shared secret, because doing so reduces opportunities for an attacker in the next call. </t><t>If at any time the users carry out the SAS comparison procedure, and it actually fails to match, then this means there is a very resourceful man-in-the-middle.  If this is the first call, the MITM was there on the first call, which is impressive enough.  If it happens in a later call, it also means the MITM must also know the cached shared secret, because you could not have carried out any voice traffic at all unless the session key was correctly computed and is also known to the attacker.  This implies the MITM must have been present in all the previous sessions, since the initial establishment of the first shared secret.  This is indeed a resourceful attacker.  It also means that if at any time he ceases his participation as a MITM on one of your calls, the protocol will detect that the cached shared secret is no longer valid -- because it was really two different shared secrets all along, one of them between Alice and the attacker, and the other between the attacker and Bob.  The continuity of the cached shared secrets make it possible for us to detect the MITM when he inserts himself into the ongoing relationship, as well as when he leaves.   Also, if the attacker tries to stay with a long lineage of calls, but fails to execute a DH MITM attack for even one missed call, he is permanently excluded.  He can no longer resynchronize with the chain of cached shared secrets. </t><t>Some sort of user interface element (maybe a checkbox) is needed to allow the user to tell the software the SAS verify was successful, causing the software to set the SAS Verified flag (V), which (together with our cached shared secret) obviates the need to perform the SAS procedure in the next call.  An additional user interface element can be provided to let the user tell the software he detected an actual SAS mismatch, which indicates a MITM attack.  The software can then take appropriate action, clearing the SAS Verified flag, and erase the cached shared secret from this session.  It is up to the implementer to decide if this added user interface complexity is warranted. </t><t>If the SAS matches, it means there is no MITM, which also implies it is now safe to trust a cached shared secret for later calls.  If inattentive users don't bother to check the SAS, it means we don't know whether there is or is not a MITM, so even if we do establish a new cached shared secret, there is a risk that our potential attacker may have a subsequent opportunity to continue inserting himself in the call, until we finally get around to checking the SAS.  If the SAS matches, it means no attacker was present for any previous session since we started propagating cached shared secrets, because this session and all the previous sessions were also authenticated with a continuous lineage of shared secrets. </t></section><section anchor='SignSAS' title="Signing the SAS"><t>The SAS MAY be signed and the signature sent using the Confirm1, Confirm2, or SASrelay messages.  The signature algorithm is also sent in the Confirm1, Confirm2, or SASrelay message, along with the length of the signature.  The key types and signature algorithms are for future study.  The signature is calculated over the entire SAS hash result (sashash) that was truncated down to derive the sasvalue.  The signatures exchanged in the encrypted Confirm1, Confirm2, or SASrelay messages MAY be used to authenticate the ZRTP exchange. </t></section><section anchor='RelayingTheSAS' title="Relaying the SAS through a PBX"><t>ZRTP is designed to use end-to-end encryption.  The two parties' verbal comparison of the short authentication string (SAS) depends on this assumption. But in some PBX environments, such as Asterisk, there are usage scenarios that have the PBX acting as a trusted man-in-the-middle (MiTM), which means there are two back-to-back ZRTP connections with separate session keys and separate SAS's. </t><t>For example, imagine that Bob has a ZRTP-enabled VoIP phone that has been registered with his company's PBX, so that it is regarded as an extension of the PBX.  Alice, whose phone is not associated with the PBX, might dial the PBX from the outside, and a ZRTP connection is negotiated between her phone and the PBX.  She then selects Bob's extension from the company directory in the PBX.  The PBX makes a call to Bob's phone (which might be offsite, many miles away from the PBX through the Internet) and a separate ZRTP connection is negotiated between the PBX and Bob's phone.  The two ZRTP sessions have different session keys and different SAS's, which would render the SAS useless for verbal comparison between Alice and Bob.  They might even mistakenly believe that a wiretapper is present because of the SAS mismatch, causing undue alarm. </t><t>ZRTP has a mechanism for solving this problem by having the PBX relay the Alice/PBX SAS to Bob, sending it through to Bob in a special SASrelay packet as defined in <xref target='SASRelayMsg'/>, which is sent after the PBX/Bob ZRTP negotiation is complete, after the Confirm packets.  Only the PBX, acting as a special trusted MiTM (trusted by the recipient of the SAS relay packet), will relay the SAS.  The SASrelay packet protects the relayed SAS from tampering via an included HMAC, similar to how the Confirm packet is protected.  Bob's ZRTP-enabled phone accepts the relayed SAS for rendering only because Bob's phone had previously been configured to trust the PBX.  This special trusted relationship with the PBX can be established through a special security enrollment procedure.  After that enrollment procedure, the PBX is treated by Bob as a special trusted MiTM.  This results in Alice's SAS being rendered to Bob, so that Alice and Bob may verbally compare them and thus prevent a MiTM attack by any other untrusted MiTM. </t><t>A real bad-guy MiTM cannot exploit this protocol feature to mount a MiTM attack and relay Alice's SAS to Bob, because Bob has not previously carried out a special registration ritual with the bad guy.  The relayed SAS would not be rendered by Bob's phone, because it did not come from a trusted PBX.  The recognition of the special trust relationship is achieved with the prior establishment of a special shared secret between Bob and his PBX, which is called the trusted MiTM key. </t><t>The trusted MiTM key can be stored in a special cache at the time of the initial enrollment (which is carried out only once for Bob's phone), and Bob's phone associates this key with the ZID of the PBX, while the PBX associates it with the ZID of Bob's phone.  After the enrollment has established and stored this trusted MiTM key, it can be detected during subsequent ZRTP call negotiations between the PBX and Bob's phone, because the PBX and the phone MUST pass the hash of the trusted MiTM key in the DH packet. It is then used as part of the key agreement to calculate s0. </t><t>The PBX can determine whether it is trusted by the ZRTP user agent of the caller or callee.  The presence of a shared trusted MiTM key in the key negotiation sequence indicates that the phone has been enrolled with this PBX and therefore trusts it to act as a trusted MiTM.  The PBX SHOULD relay the SAS from the other party in this case. </t><t>The relayed SAS fields contain the SAS rendering type and the binary 32-bit sasvalue.  The receiver absolutely MUST NOT render the relayed SAS if it does not come from a specially trusted ZRTP endpoint.  The security of the ZRTP protocol depends on not rendering a relayed SAS from an untrusted MiTM, because it may be relayed by a MiTM attacker.  See the SASrelay packet definition (<xref target='SASrelay_Msg'/>) for further details. </t><t>To ensure that both Alice and Bob will use to the same SAS rendering scheme after the keys are negotiated, the PBX also sends the SASrelay message to the unenrolled party (which does not regard this PBX as a trusted MiTM), conveying the SAS rendering scheme, but not the SAS value, which it sets to zero.  The unenrolled party will ignore the relayed SAS field, but will use the specified SAS rendering scheme. </t><t>The next section describes the initial enrollment procedure that establishes a special shared secret between the PBX and Bob's phone, a trusted MiTM key, so that the phone will learn to recognize the PBX as a trusted MiTM. </t><section anchor='PBXenrollment' title="PBX Enrollment and the PBX Enrollment Flag"><t>Both the PBX and the endpoint need to know when enrollment is taking place.  One way of doing this is to setup an enrollment extension on the PBX which a newly configured endpoint would call and establish a ZRTP session.  The PBX would then play audio media that offers the user an opportunity to configure his phone to trust this PBX as a trusted MiTM.  The PBX calculates and stores the trusted MiTM shared secret in its cache and associates it with this phone, indexed by the phone's ZID.  The trusted MiTM PBX shared secret is calculated this way: </t><t><list><t>    pbxsecret = HMAC(ZRTPSess,"Trusted MiTM key") </t></list></t><t>The PBX signals the enrollment process by setting the PBX Enrollment flag (E) in the Confirm message.  This flag is used to trigger the ZRTP endpoint's user interface to prompt the user if they want to trust this PBX and calculate and store the pbxsecret in the cache. If the user decides to respond by activating the appropriate user interface element (a menu item, checkbox, or button), his ZRTP user agent calculates pbxsecret using the same formula and saves it in a special cache entry associated with this PBX. </t><t>If the user elects not to enroll, perhaps because he dialed a wrong number or does not yet feel comfortable with this PBX, he can simply hang up and not save the pbxsecret in his cache.  The PBX will have it saved in the PBX cache, but that will do no harm.  The SASrelay scheme does not depend on the PBX trusting the phone.  It only depends on the phone trusting the PBX.  It is the phone (the user) who is at risk if the PBX abuses its MiTM privileges. </t><t>After this enrollment process, the PBX and the ZRTP-enabled phone both share a secret that enables the phone to recognize the PBX as a trusted MiTM in future calls.  This means that when a future call from an outside ZRTP-enabled caller is relayed through the PBX to this phone, the phone will render a relayed SAS from the PBX.  If the SASrelay packet comes from a MiTM which does not know the pbxsecret, the phone treats it as a "bad guy" MiTM, and refuses to render the relayed SAS.  Regardless of which party initiates any future phone calls through the PBX, the enrolled phone or the outside phone, the PBX will relay the SAS to the enrolled phone. </t><t>There are other ways that ZRTP user agents can be configured to trust a PBX.  Perhaps the pbxsecret can be configured into the phone by some automated provisioning process in large IT environments.  This specification does not require that products be configured solely by this enrollment process.  Any process that results in a pbxsecret to be computed and shared between the PBX and the phone will suffice.  This is one such method that has been shown to work. </t></section></section></section><section anchor='SignalingInteractions' title="Signaling Interactions"><t>This section discusses how ZRTP, SIP, and SDP work together. </t><t>Note that ZRTP may be implemented without coupling with the SIP signaling.  For example, ZRTP can be implemented as a "bump in the wire" or as a "bump in the stack" in which RTP sent by the SIP UA is converted to ZRTP.  In these cases, the SIP UA will have no knowledge of ZRTP.  As a result, the signaling path discovery mechanisms introduced in this section should not be definitive - they are a hint.  Despite the absence of an indication of ZRTP support in an offer or answer, a ZRTP endpoint SHOULD still send Hello messages. </t><t>ZRTP endpoints which have control over the signaling path include a ZRTP SDP attributes in their SDP offers and answers.  The ZRTP attribute, a=zrtp-hash is used to indicate support for ZRTP and to convey a hash of the Hello message.  There are a number of potential uses for this attribute.  It is useful when signaling elements would like to know when ZRTP may be utilized by endpoints.  It is also useful if endpoints support multiple methods of SRTP key management.  The ZRTP attribute can be used to ensure that these key management approaches work together instead of against each other.  For example, if only one endpoint supports ZRTP but both support another method to key SRTP, then the other method will be used instead.  When used in parallel, an SRTP secret carried in an a=keymgt <xref target='RFC4567'/>  or a=crypto <xref target='RFC4568'/> attribute can be used as a shared secret for the srtp_secret.  The ZRTP attribute is also used to signal to an intermediary ZRTP device not to act as a ZRTP endpoint, as discussed in <xref target='IntermediaryZRTP'/>. </t><t>The a=zrtp-hash attribute can only be included at a media level since Hello messages sent in different media streams will have unique hashes.</t><t>The ABNF for the ZRTP attribute is as follows: </t><figure><artwork><![CDATA[     zrtp-attribute        = "a=zrtp-hash:" zrtp-hash-value     zrtp-hash-value       = 1*(HEXDIG)]]></artwork></figure><t>Example of the ZRTP attribute in an initial SDP offer or answer used at the session level: </t><figure><artwork><![CDATA[   v=0   o=bob 2890844527 2890844527 IN IP4 client.biloxi.example.com   s=   c=IN IP4 client.biloxi.example.com   t=0 0   m=audio 3456 RTP/AVP 97 33   a=rtpmap:97 iLBC/8000   a=rtpmap:33 no-op/8000   a=zrtp-hash:fe30efd02423cb054e50efd0248742ac7a52c8f91bc2df881ae642c371ba46df]]></artwork></figure><section anchor='Binding2Signaling' title="Binding the media stream to the signaling layer via the Hello Hash"><t>It is desirable to tie the media stream to the signaling channel to prevent a third party from inserting false media packets.  If the signaling layer contains information that ties it to the media stream, false media streams can be rejected. </t><t>To accomplish this, a SHA-256 hash is computed across the entire ZRTP Hello message (as shown in <xref target='Hello_Msg'/>).  This hash image is made available to the signaling layer, where it is transmitted as a hexadecimal value in the SIP channel using the SDP attribute, a=zrtp-hash defined in this specification.  Each media stream (audio or video) will have a separate Hello packet, and thus will require a separate a=zrtp-hash in an SDP attribute.  The recipient of the SIP/SDP message can then use this hash image to detect and reject false Hello packets in the media channel, as well as identify which media stream is associated with this SIP call.  Each Hello packet hashes uniquely, because it contains the H3 field derived from a random nonce, defined in <xref target='Hashchains'/>. </t><t>The Hello Hash as an SDP attribute is an OPTIONAL feature, because some ZRTP endpoints do not have the ability to add SDP attributes to the signaling.  For example, if ZRTP is implemented in a hardware bump-in-the-wire device, it might only have the ability to modify the media packets, not the SIP packets, especially if the SIP packets are integrity protected and thus cannot be modified on the wire.  If the SDP has no hash image of the ZRTP Hello message, the recipient's ZRTP user agent cannot check it, and thus will not be able to reject Hello messages based on this hash. </t><t>After the Hello Hash is used to properly identify the ZRTP Hello message as belonging to this particular SIP call, the rest of the ZRTP message sequence is protected from false packet injection by other protection mechanisms.  For example, the use of the total_hash in the shared secret calculation, and also the hash chaining mechanism defined in <xref target='Hashchains'/>. </t><t>An attacker who controls only the signaling layer, such as an uncooperative VoIP service provider, may be able to deny service by corrupting the hash of the Hello message in the SDP attribute, which would force ZRTP to reject perfectly good Hello messages.  If there is reason to believe this is happening, the ZRTP endpoint MAY allow Hello messages to be accepted that do not match the hash image in the SDP attribute. </t><t>Even in the absence of SIP integrity protection, the inclusion of the a=zrtp-hash SDP attribute, when coupled with the hash chaining mechanism defined in <xref target='Hashchains'/>, meets the R-ASSOC requirement in the <xref target='I-D.ietf-sip-media-security-requirements'>Media Security Requirements</xref>, which requires: </t><t><list><t>"...a mechanism for associating key management messages with both the signaling traffic that initiated the session and with protected media traffic.  Allowing such an association also allows the SDP offerer to avoid performing CPU-consuming operations (e.g., Diffie-Hellman or public key operations) with attackers that have not seen the signaling messages." </t></list></t><t>The a=zrtp-hash SDP attribute becomes especially useful if the SDP is integrity-protected end-to-end by <xref target="RFC4474">SIP Identity (RFC 4474)</xref> or better still, Dan Wing's <xref target='I-D.wing-sip-identity-media'>SIP Identity using Media Path</xref>.  This leads to an ability to stop MiTM attacks independent of ZRTP's SAS mechanism, as explained in <xref target='LeveragingIntegrityProtectedSIP'/> below. </t><section anchor='LeveragingIntegrityProtectedSIP' title="Integrity-protected signaling enables integrity-protected DH exchange"><t>If and only if the signaling path and the SDP is protected by some form of end-to-end integrity protection, such as one of the abovementioned mechanisms, so that it can guarantee delivery of the a=zrtp-hash attribute without any tampering by a third party, and if there is good reason to trust the signaling layer to protect the interests of the end user, it is possible to authenticate the key exchange and prevent a MiTM attack.  This can be done without requiring the users to verbally compare the SAS, by using the hash chaining mechanism defined in <xref target='Hashchains'/> to provide a series of HMAC keys that protect the entire ZRTP key exchange.  Thus, an end-to-end integrity-protected signaling layer automatically enables an integrity-protected Diffie-Hellman exchange in ZRTP, which in turn means immunity from a MiTM attack.  Here's how it works. </t><t>The integrity-protected SIP SDP contains a hash commitment to the entire Hello message.  The Hello message contains H3, which provides a hash commitment for the rest of the hash chain H0-H2 (<xref target='Hashchains'/>).  The Hello message is protected by a 64-bit HMAC, keyed by H2.  The Commit message is protected by a 64-bit HMAC keyed by H1.  The DHPart1 or DHPart2 messages are protected by a 64-bit HMAC keyed by H0.  The HMAC protecting the Confirm messages are computed by a different HMAC key derived from the resulting key agreement.  Each message's HMAC is checked when the HMAC key is received in the next message.  If a bad HMAC is discovered, it MUST be treated as a security exception indicating a MiTM attack, perhaps by logging or alerting the user.  It MUST NOT be treated as a random error.  Random errors are already discovered and quietly rejected by bad CRCs (<xref target='ZRTPpkt'/>). </t><t>The <xref target='I-D.ietf-sip-media-security-requirements'>Media Security Requirements </xref> R-EXISTING requirement can be fully met by leveraging a certificate-backed PKI in the signaling layer to integrity-protect the delivery of the a=zrtp-hash SDP attribute.  This would thereby protect ZRTP against a MiTM attack, without requiring the user to check the SAS, without adding any explicit signatures or signature keys to the ZRTP key exchange, and without any extra public key operations or extra packets. </t><t>Without an end-to-end integrity protection mechanism in the signaling layer to guarantee delivery of the a=zrtp-hash SDP attribute without modification by a third party, these HMACs alone will not prevent a MiTM attack.  In that case, ZRTP's built-in SAS mechanism will still have to be used to authenticate the key exchange.  At the time of this writing, very few deployed VoIP clients offer a fully implemented SIP stack that provides end-to-end integrity protection for the delivery of SDP attributes.  Also, end-to-end signaling integrity becomes more problematic if <xref target='RFC3824'>E.164 numbers</xref> are used in SIP.  Thus, real-world implementations of ZRTP endpoints will continue to depend on SAS authentication for quite some time.  Even after there is widespread availability of SIP user agents that offer integrity protected delivery of SDP attributes, many users will still be faced with the fact that the signaling path may be controlled by institutions that do not have the best interests of the end user in mind.  In those cases, SAS authentication will remain the gold standard for the prudent user. </t><t>Even without SIP integrity protection, the <xref target='I-D.ietf-sip-media-security-requirements'>Media Security Requirements </xref> R-ACT-ACT requirement can be met by ZRTP's SAS mechanism.  Although ZRTP may benefit from an integrity-protected SIP layer, it is fortunate that ZRTP's self-contained MiTM defenses do not actually require an integrity-protected SIP layer. ZRTP can bypass the delays and problems that SIP integrity faces, such as E.164 number usage, and the complexity of building and maintaining a PKI. </t><t>In contrast, <xref target='I-D.ietf-avt-dtls-srtp'>DTLS-SRTP</xref> appears to depend heavily on end-to-end integrity protection in the SIP layer.  Further, DTLS-SRTP must bear the additional cost of a signature calculation of its own, in addition to the signature calculation the SIP layer uses to achieve its integrity protection.  ZRTP needs no signature calculation of its own to leverage the signature calculation carried out in the SIP layer. </t></section></section><section anchor='derive_srtps' title="Deriving the SRTP secret (srtps) from the signaling layer"><t>The shared secret calculations defined in <xref target='SharedSecretDetermination'/> make use of the SRTP secret (srtps), if it is provided by the signaling layer. </t><t>It is desirable for only one SRTP key negotiation protocol to be used, and that protocol should be ZRTP.  But in the event the signaling layer negotiates its own SRTP master key and salt, using the <xref target="RFC4568">SDES</xref> or <xref target='RFC4567'/>, it can be passed from the signaling to the ZRTP layer and mixed into ZRTP's own shared secret calculations, without compromising security by creating a dependency on the signaling for media encryption. </t><t>ZRTP computes srtps from the SRTP master key and salt parameters provided by the signaling layer in this manner: </t><t><list><t>srtps = hash(SRTP master key | SRTP master salt) </t></list></t><t>It is expected that the srtps parameter will be rarely computed or used in typical ZRTP endpoints, because it is likely and desirable that ZRTP will be the sole means of negotiating SRTP keys, needing no help from <xref target="RFC4568">SDES</xref> or <xref target='RFC4567'/>. If srtps is computed, it will be stored in the auxiliary shared secret auxsecret, defined in <xref target='SharedSecretDetermination'/>, and used in <xref target='ResponderBehavior1'/> and <xref target='InitiatorBehavior1'/>. </t></section><!--<section title="Using the signaling path to check the SAS"><t>In some scenarios, it is desirable for a signaling intermediary to be able to validate the SAS on behalf of the user.  This could be due to an endpoint which has a user interface unable to render the SAS.  Or, this could be a protection by an organization against lazy users who never check the SAS.  Using either the ZRTP SAS or ZRTP SASvalue attribute, the SAS check can be performed without requiring the human users to speak the SAS.  Note that this check can only be relied on if the signaling path has end-to-end integrity protection. </t><t>The ZRTP SAS attribute a=zrtp-sas is a Media level SDP attribute that can be used to carry the SAS string and value.  The string is identical to that rendered to the user while contents of the string passed depends on the negotiated SAS Type.  The value is the leftmost 64 bits of the SAS hash result (sashash) encoded as hex.  Since the SAS is not known at the start of a session, the a=zrtp-sas attribute will never be present in the initial offer/answer exchange.  After the ZRTP exchange has completed, the SAS is known and can be exchanged over the signaling using a second offer/answer exchange (a re-INVITE in SIP terms).  Note that the SAS is not treated as a secret and as such does not need confidentiality protection when sent over the signaling path. </t><t>The ABNF for the ZRTP attribute is as follows: </t><figure><artwork><![CDATA[     zrtp-attribute        = "a=zrtp-hash:" zrtp-hash-value     zrtp-hash-value       = 1*(HEXDIG)]]></artwork></figure><t>The ABNF for the ZRTP SAS attribute is as follows: </t><figure><artwork><![CDATA[     zrtp-sas-attribute    = "a=zrtp-sas:" sas-string sas-value     sas-string            = non-ws-string     non-ws-string         = 1*(VCHAR/%x80-FF)                            ;string of visible characters     sas-value             = 1*(HEXDIG)]]></artwork></figure><t>Example of the ZRTP attribute in an initial SDP offer or answer used at the session level: </t><figure><artwork><![CDATA[   v=0   o=bob 2890844527 2890844527 IN IP4 client.biloxi.example.com   s=   c=IN IP4 client.biloxi.example.com   t=0 0   m=audio 3456 RTP/AVP 97 33   a=rtpmap:97 iLBC/8000   a=rtpmap:33 no-op/8000   a=zrtp-hash:fe30efd02423cb054e50efd0248742ac7a52c8f91bc2df881ae642c371ba46df]]></artwork></figure><t>An Example of the ZRTP SAS attribute in a subsequent SDP offer or answer used at the media level:</t><figure><artwork><![CDATA[   v=0   o=bob 2890844527 2890844528 IN IP4 client.biloxi.example.com   s=   c=IN IP4 client.biloxi.example.com   t=0 0   m=audio 3456 RTP/AVP 97 33   a=rtpmap:97 iLBC/8000   a=rtpmap:33 no-op/8000   a=zrtp-sas: opzf 5e017f3a6563876a]]></artwork></figure><t>Another example showing a second media stream being added to the session.  A second DH exchange is performed (instead of using the Preshared mode) resulting in a second ZRTP SAS attribute. </t><figure><artwork><![CDATA[   v=0   o=bob 2890844527 2890844528 IN IP4 client.biloxi.example.com   s=   c=IN IP4 client.biloxi.example.com   t=0 0   m=audio 3456 RTP/AVP 97 33   a=rtpmap:97 iLBC/8000   a=rtpmap:33 no-op/8000   a=zrtp-sas: opzf 5e017f3a6563876a   m=video 51372 RTP/AVP 31 33   a=rtpmap:31 H261/90000   a=rtpmap:33 no-op/8000   a=zrtp-sas: gwif e1027fa9f865221c]]></artwork></figure></section>--></section><section anchor='Hashchains' title="False ZRTP Packet Rejection"><t>An attacker who is not in the media path may attempt to inject false ZRTP protocol packets, possibly to effect a denial of service attack, or to inject his own media stream into the call.  VoIP by its nature invites various forms of denial of service attacks and requires protocol features to reject such attacks.  While bogus SRTP packets may be easily rejected via the SRTP auth tag field, that can only be applied after a key agreement is completed.  During the ZRTP key negotiation phase, other false packet rejection mechanisms are needed.  One such mechanism is the use of the total_hash in the final shared secret calculation, but that can only detect false packets after performing the computationally expensive Diffie-Hellman calculation. </t><t>The VoIP developer community expects to see a lot of denial of service attacks, especially from attackers who are not in the media path.  Such an attacker might inject false ZRTP packets to force a ZRTP endpoint to engage in an endless series of pointless and expensive DH calculations.  To detect and reject false packets cheaply and rapidly as soon as they are received, ZRTP uses a hash chain, which is a series of successive hash images.  Before each session, the following values are computed: </t><t><list><t>H0 = 256-bit random nonce (different for each party) </t><t>H1 = hash (H0) </t><t>H2 = hash (H1) </t><t>H3 = hash (H2) </t></list></t><t>The hash function is defined to be SHA-256.  Each 256-bit hash image is the pre-image of the next, and the sequence of images is sent in reverse order in the ZRTP packet sequence.  The hash image H3 is sent in the Hello packet, H2 is sent in the Commit packet, H1 is sent in the DHPart1 or DHPart2 packets, and H0 is sent in the Confirm1 or Confirm2 packets.  The initial random H0 nonces that each party generates MUST be unpredictable to an attacker and unique within a ZRTP call, which thereby forces the derived hash images H1-H3 to also be unique and unpredictable. </t><t>The recipient checks if the packet has the correct hash pre-image, by hashing it and comparing the result with the hash image for the preceding packet.  Packets which contain an incorrect hash pre-image MUST NOT be used by the recipient, but MAY be processed as security exceptions, perhaps by logging or alerting the user.  As long as these bogus packets are not used, and correct packets are still being received, the protocol SHOULD be allowed to run to completion, thereby rendering ineffective this denial of service attack. </t><t>Because these hash images alone do not protect the rest of the contents of the packet they reside in, this scheme assumes the attacker cannot modify the packet contents from a legitimate party, which is a reasonable assumption for an attacker who is not in the media path.  This covers an important range of denial-of-service attacks.  For dealing with the remaining set of attacks that involve packet modification, other mechanisms are used, such as the total_hash in the final shared secret calculation, and the hash commitment in the Commit packet. </t><t>False Hello packets may be detected and rejected by the mechanism defined in <xref target='Binding2Signaling'/>.  This mechanism requires that each Hello packet be unique, and the inclusion of the H3 hash image meets that requirement. </t><t>If and only if an integrity-protected signaling channel is available, this hash chaining scheme can be used to key HMACs to authenticate the entire ZRTP key exchange, and thereby prevent a MiTM attack, without relying on the users verbally comparing the SAS.  See <xref target='LeveragingIntegrityProtectedSIP'/> for details. </t><t>Some ZRTP user agents allow the user to manually switch to clear mode (via the GoClear packet) in the middle of a secure call, and then later initiate secure mode again.  Many consumer client products will omit this feature, but those that allow it may return to secure mode again in the same media stream.  Although the same chain of hash images will be re-used and thus rendered ineffective the second time, no real harm is done because the new SRTP session keys will be derived in part from a cached shared secret, which was safely protected from the MiTM in the previous DH exchange earlier in the same call. </t><!-- <t>Some ZRTP user agents allow the user to manually switch to clear mode (via the GoClear packet) in the middle of a secure call, and then later initiate secure mode again.  Many consumer client products will omit this feature, but those that allow it will need a fresh new set of hash images to use in a new ZRTP negotiation beginning with a new Commit packet.  To facilitate this, a new H3 hash image is sent in the Confirm packet.  This is derived from a new random nonce iteratively hashed to create H0 through H3 as defined above.  This new H3 hash image will only be used if the Allow Clear (A) flag is enabled in the same Confirm packet, which means the user may elect to go back to clear mode and then later go secure again within this same media stream.  In that case, the new Commit message will contain the H2 preimage of this new H3 hash. </t> --></section><section anchor='IntermediaryZRTP' title="Intermediary ZRTP Devices"><t>This section discusses the operation of a ZRTP endpoint which is actually an intermediary.  For example, consider a device which proxies both signaling and media between endpoints.  There are three possible ways in which such a device could support ZRTP. </t><t>An intermediary device can act transparently to the ZRTP protocol.  To do this, a device MUST pass RTP header extensions and payloads (to allow the ZRTP Flag) and non-RTP protocols multiplexed on the same port as RTP (to allow ZRTP and STUN).  This is the RECOMMENDED behavior for intermediaries as ZRTP and SRTP are best when done end-to-end. </t><t>An intermediary device could implement the ZRTP protocol and act as a ZRTP endpoint on behalf of non-ZRTP endpoints behind the intermediary device.  The intermediary could determine on a call-by-call basis whether the endpoint behind it supports ZRTP based on the presence or absence of the ZRTP SDP attribute flag (a=zrtp-hash).  For non-ZRTP endpoints, the intermediary device could act as the ZRTP endpoint using its own ZID and cache.  This approach MUST only be used when there is some other security method protecting the confidentiality of the media between the intermediary and the inside endpoint, such as IPSec or physical security. </t><t>The third mode, which is NOT RECOMMENDED, is for the intermediary device to attempt to back-to-back the ZRTP protocol.  The only exception to this case is where the intermediary device is a trusted element providing services to one of the endpoints - e.g. a Private Branch Exchange or PBX.  In this mode, the intermediary would attempt to act as a ZRTP endpoint towards both endpoints of the media session.  This approach MUST NOT be used except as described in <xref target='RelayingTheSAS'/> as it will always result in a detected man-in-the-middle attack and will generate alarms on both endpoints and likely result in the immediate termination of the session. </t><t>In cases where centralized media mixing is taking place, the SAS will not match when compared by the humans.  However, this situation is known in the SIP signaling by the presence of the isfocus feature tag <xref target="RFC4579"/>.  As a result, when the isfocus feature tag is present, the DH exchange can be authenticated by the mechanism defined in <xref target='LeveragingIntegrityProtectedSIP'/> or by validating signatures in the Confirm or SASrelay messages.  For example, consider a audio conference call with three participants Alice, Bob, and Carol hosted on a conference bridge in Dallas.  There will be three ZRTP encrypted media streams, one encrypted stream between each participant and Dallas.  Each will have a different SAS.  Each participant will be able to validate their SAS with the conference bridge by using signatures in the Confirm messages.  Or, if the signaling path has end-to-end integrity protection, each DH exchange will have automatic MiTM protection by using the mechanism in <xref target='LeveragingIntegrityProtectedSIP'/>. </t><t>SIP feature tags can also be used to detect if a session is established with an automaton such as an IVR, voicemail system, or speech recognition system.  The display of SAS strings to users should be disabled in these cases. </t><t>It is possible that an intermediary device acting as a ZRTP endpoint might still receive ZRTP Hello and other messages from the inside endpoint.  This could occur if there is another inline ZRTP device which does not include the ZRTP SDP attribute flag.  If this occurs, the intermediary MUST NOT pass these ZRTP messages if it is acting as the ZRTP endpoint. </t></section><section anchor='DisclosureFlag' title="The ZRTP Disclosure flag" ><t>There are no back doors defined in the ZRTP protocol specification. The designers of ZRTP would like to discourage back doors in ZRTP-enabled products. However, despite the lack of back doors in the actual ZRTP protocol, it must be recognized that a ZRTP implementer might still deliberately create a rogue ZRTP-enabled product that implements a back door outside the scope of the ZRTP protocol. For example, they could create a product that discloses the SRTP session key generated using ZRTP out-of-band to a third party. They may even have a legitimate business reason to do this for some customers. </t><t>For example, some environments have a need to monitor or record calls, such as stock brokerage houses who want to discourage insider trading, or special high security environments with special needs to monitor their own phone calls. We've all experienced automated messages telling us that "This call may be monitored for quality assurance". A ZRTP endpoint in such an environment might unilaterally disclose the session key to someone monitoring the call. ZRTP-enabled products that perform such out-of-band disclosures of the session key can undermine public confidence in the ZRTP protocol, unless we do everything we can in the protocol to alert the other user that this is happening. </t><t>If one of the parties is using a product that is designed to disclose their session key, ZRTP requires them to confess this fact to the other party through a protocol message to the other party's ZRTP client, which can properly alert that user, perhaps by rendering it in a graphical user interface. The disclosing party does this by sending a Disclosure flag (D) in Confirm1 and Confirm2 messages as described in <xref target='ConfirmMsg'/>. </t><t>Note that the intention here is to have the Disclosure flag identify products that are designed to disclose their session keys, not to identify which particular calls are compromised on a call-by-call basis. This is an important legal distinction, because most government sanctioned wiretap regulations require a VoIP service provider to not reveal which particular calls are wiretapped. But there is nothing illegal about revealing that a product is designed to be wiretap-friendly. The ZRTP protocol mandates that such a product "out" itself. </t><t>You might be using a ZRTP-enabled product with no back doors, but if your own graphical user interface tells you the call is (mostly) secure, except that the other party is using a product that is designed in such a way that it may have disclosed the session key for monitoring purposes, you might ask him what brand of secure telephone he is using, and make a mental note not to purchase that brand yourself. If we create a protocol environment that requires such back-doored phones to confess their nature, word will spread quickly, and the "invisible hand" of the free market will act. The free market has effectively dealt with this in the past. </t><t>Of course, a ZRTP implementer can lie about his product having a back door, but the ZRTP standard mandates that ZRTP-compliant products MUST adhere to the requirement that a back door be confessed by sending the Disclosure flag to the other party. </t><t>There will be inevitable comparisons to Steve Bellovin's 2003 April fool's joke, when he submitted <xref target="RFC3514">RFC 3514</xref> which defined the "Evil bit" in the IPV4 header, for packets with "evil intent". But we submit that a similar idea can actually have some merit for securing VoIP. Sure, one can always imagine that some implementer will not be fazed by the rules and will lie, but they would have lied anyway even without the Disclosure flag. There are good reasons to believe that it will improve the overall percentage of implementations that at least tell us if they put a back door in their products, and may even get some of them to decide not to put in a back door at all. From a civic hygiene perspective, we are better off with having the Disclosure flag in the protocol. </t><t>If an endpoint stores or logs SRTP keys or information that can be used to reconstruct or recover SRTP keys after they are no longer in use (i.e. the session is active), or otherwise discloses or passes SRTP keys or information that can be used to reconstruct or recover SRTP keys to another application or device, the Disclosure flag D MUST be set in the Confirm1 or Confirm2 message. </t><section title="Guidelines on Proper Implementation of the Disclosure Flag"><t>Some implementers have asked for guidance on implementing the Disclosure Flag. Some people have incorrectly thought that a connection secured with ZRTP cannot be used in a call center, with voluntary voice recording, or even with a voicemail system. Similarly, some potential users of ZRTP have overconsidered the protection that ZRTP can give them. These guidelines clarify both concerns. </t><t>The ZRTP Disclosure Flag only governs the ZRTP/SRTP stream itself. It does not govern the underlying RTP media stream, nor the actual media itself. Consequently, a PBX that uses ZRTP may provide conference calls, call monitoring, call recording, voicemail, or other PBX features and still say that it does not disclose the ZRTP key material. A video system may provide DVR features and still say that it does not disclose the ZRTP key material. The ZRTP Disclosure Flag, when not set, means only that the ZRTP cryptographic key material stays within the bounds of the ZRTP subsystem. </t><t>If an application has a need to disclose the ZRTP cryptographic key material, the easiest way to comply with the protocol is to set the flag to the proper value. The next easiest way is to overestimate disclosure. For example, a call center that commonly records calls might choose to set the disclosure flag even though all recording is an analog recording of a call (and thus outside the ZRTP scope) because it sets an expectation with clients that their calls might be recorded. </t><t>Note also that the ZRTP Disclosure Flag does not require an implementation to preclude hacking or malware. Malware that leaks ZRTP cryptographic key material does not create a liability for the implementor from non-compliance with the ZRTP specification. </t><t>A user of ZRTP should note that ZRTP is not a panacea against unauthorized recording. ZRTP does not and cannot protect against an untrustworthy partner who holds a microphone up to the speaker. It does not protect against someone else being in the room. It does not protect against analog wiretaps in the phone or in the room. It does not mean your partner has not been hacked with spyware. It does not mean that the software has no flaws. It means that the ZRTP subsystem is not knowingly leaking ZRTP cryptographic key material. </t></section></section><section anchor='RTPXHdrFlagZRTP' title="RTP Header Extension Flag for ZRTP"><t>This specification defines a new RTP header extension used only for discovery of support for ZRTP.  No ZRTP data is transported in the extension.  When used, the X bit is set in the RTP header to indicate the presence of the RTP header extension. </t><t>Section 5.3.1 in RFC 3550 defines the format of an RTP Header extension.  The Header extension is appended to the RTP header.  The first 16 bits are an identifier for the header extension, and the following 16 bits are length of the extension header in 32 bit words. The ZRTP flag RTP header extension has the value of 0x505A and a length of 0. The format of the header extension is as shown in the Figure below. </t><figure title="RTP Extension header format for ZRTP Flag"><artwork>     0                   1                   2                   3      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    RTP Extension header format for ZRTP Flag</artwork></figure><t>ZRTP endpoints SHOULD include the ZRTP Flag in RTP packets sent at the start of a session.  For example, and endpoint may decide to include the flag in the first 1 second of RTP packets sent.  The inclusion of the flag MAY be ended if a ZRTP message (such as Hello) is received. </t></section><section title="IANA Considerations"><t>   This specification defines a new <xref target="RFC4566">SDP</xref> attribute in <xref target='SignalingInteractions'/>. </t><figure><artwork><![CDATA[   Contact name:          Philip Zimmermann <prz@mit.edu>   Attribute name:        "zrtp-hash".   Type of attribute:     Media level.   Subject to charset:    Not.   Purpose of attribute:  The 'zrtp-hash' indicates that a UA supports the                          ZRTP protocol and provides a hash of the ZRTP Hello                          message.   Allowed attribute values:  Hex.]]></artwork></figure></section><section title="Security Considerations"><t>This document is all about securely keying SRTP sessions.  As such, security is discussed in every section. </t><t>Most secure phones rely on a Diffie-Hellman exchange to agree on a common session key.  But since DH is susceptible to a man-in-the-middle (MITM) attack, it is common practice to provide a way to authenticate the DH exchange.  In some military systems, this is done by depending on digital signatures backed by a centrally-managed PKI.  A decade of industry experience has shown that deploying centrally managed PKIs can be a painful and often futile experience.  PKIs are just too messy, and require too much activation energy to get them started.  Setting up a PKI requires somebody to run it, which is not practical for an equipment provider.  A service provider like a carrier might venture down this path, but even then you have to deal with cross-carrier authentication, certificate revocation lists, and other complexities.  It is much simpler to avoid PKIs altogether, especially when developing secure commercial products.  It is therefore more common for commercial secure phones in the PSTN world to augment the DH exchange with a Short Authentication String (SAS) combined with a hash commitment at the start of the key exchange, to shorten the length of SAS material that must be read aloud.  No PKI is required for this approach to authenticating the DH exchange.  The AT&T TSD 3600, <xref target="comsec">Eric Blossom's COMSEC secure phones </xref>, <xref target="pgpfone">PGPfone</xref>, and <xref target="cryptophone">CryptoPhone</xref> are all examples of products that took this simpler lightweight approach. </t><t>The main problem with this approach is inattentive users who may not execute the voice authentication procedure, or unattended secure phone calls to answering machines that cannot execute it. </t><t>Additionally, some people worry about voice spoofing.  But it is a mistake to think this is simply an exercise in voice impersonation (perhaps this could be called the "Rich Little" attack). Although there are digital signal processing techniques for changing a person's voice, that does not mean a man-in-the-middle attacker can safely break into a phone conversation and inject his own short authentication string (SAS) at just the right moment. He doesn't know exactly when or in what manner the users will choose to read aloud the SAS, or in what context they will bring it up or say it, or even which of the two speakers will say it, or if indeed they both will say it. In addition, some methods of rendering the SAS involve using a list of words such as the PGP word list, in a manner analogous to how pilots use the NATO phonetic alphabet to convey information. This can make it even more complicated for the attacker, because these words can be worked into the conversation in unpredictable ways. Remember that the attacker places a very high value on not being detected, and if he makes a mistake, he doesn't get to do it over.  Some people have raised the question that even if the attacker lacks voice impersonation capabilities, it may be unsafe for people who don't know each other's voices to depend on the SAS procedure. This is not as much of a problem as it seems, because it isn't necessary that they recognize each other by their voice, it's only necessary that they detect that the voice used for the SAS procedure matches the voice in the rest of the phone conversation. </t><t>A popular and field-proven approach is used by <xref target="RFC4251">SSH (Secure Shell)</xref>, which Peter Gutmann likes to call the "baby duck" security model.  SSH establishes a relationship by exchanging public keys in the initial session, when we assume no attacker is present, and this makes it possible to authenticate all subsequent sessions.  A successful MITM attacker has to have been present in all sessions all the way back to the first one, which is assumed to be difficult for the attacker.  ZRTP's key continuity features are actually better than SSH, for reasons described in <xref target='selfhealing'/>.  All this is accomplished without resorting to a centrally-managed PKI. </t><t>We use an analogous baby duck security model to authenticate the DH exchange in ZRTP.  We don't need to exchange persistent public keys, we can simply cache a shared secret and re-use it to authenticate a long series of DH exchanges for secure phone calls over a long period of time.  If we read aloud just one SAS, and then cache a shared secret for later calls to use for authentication, no new voice authentication rituals need to be executed.  We just have to remember we did one already. </t><t>If one party ever loses this cached shared secret, it is no longer available for authentication of DH exchanges.  This cache mismatch situation is easy to detect by the party that still has a surviving shared secret cache entry.  If it fails to match, either there is a MiTM attack or one side has lost their shared secret cache entry. The user agent that discovers the cache mismatch MUST alert the user that a cache mismatch has been detected, and that he must do a verbal comparison of the SAS to distinguish if the mismatch is because of a MiTM attack or because of the other party losing her cache.  From that point on, the two parties start over with a new cached shared secret.  Then they can go back to omitting the voice authentication on later calls. </t><t>A particularly compelling reason why this approach is attractive is that SAS is easiest to implement when a graphical user interface or some sort of display is available, which raises the question of what to do when a display is less conveniently available.  For example, some devices that implement ZRTP might have a graphical user interface that is only visible through a web browser, such as a PBX or some other nearby device that implements ZRTP as a "bump-in-the-wire".  If we take an approach that greatly reduces the need for a SAS in each and every call, we can operate in products without a graphical user interface with greater ease.  Then the SAS can be compared less frequently through a web browser, or it might even be presented as needed to the local user through a locally generated voice prompt, which the local user hears and verbally repeats and compares with the remote party. </t><t>It's a good idea to force your opponent to have to solve multiple problems in order to mount a successful attack.  Some examples of widely differing problems we might like to present him with are:  Stealing a shared secret from one of the parties, being present on the very first session and every subsequent session to carry out an active MITM attack, and solving the discrete log problem.  We want to force the opponent to solve more than one of these problems to succeed. </t><t>ZRTP can use different kinds of shared secrets.  Each type of shared secret is determined by a different method.  All of the shared secrets are hashed together to form a session key to encrypt the call.  An attacker must defeat all of the methods in order to determine the session key. </t><t>First, there is the shared secret determined entirely by a Diffie-Hellman key agreement.  It changes with every call, based on random numbers.  An attacker may attempt a classic DH MITM attack on this secret, but we can protect against this by displaying and reading aloud a SAS, combined with adding a hash commitment at the beginning of the DH exchange. </t><t>Second, there is an evolving shared secret, or ongoing shared secret that is automatically changed and refreshed and cached with every new session.  We will call this the cached shared secret, or sometimes the retained shared secret.  Each new image of this ongoing secret is a non-invertable function of its previous value and the new secret derived by the new DH agreement.  It's possible that no cached shared secret is available, because there were no previous sessions to inherit this value from, or because one side loses its cache. </t><t>There are other approaches for key agreement for SRTP that compute a shared secret using information in the signaling.  For example, <xref target='RFC4567'/> describes how to carry a <xref target="RFC3830">MIKEY (Multimedia Internet KEYing)</xref> payload in <xref target="RFC4566">SDP</xref>.  Or <xref target="RFC4568">RFC 4568 (SDES) </xref> describes directly carrying SRTP keying and configuration information in SDP.  ZRTP does not rely on the signaling to compute a shared secret, but If a client does produce a shared secret via the signaling, and makes it available to the ZRTP protocol, ZRTP can make use of this shared secret to augment the list of shared secrets that will be hashed together to form a session key.  This way, any security weaknesses that might compromise the shared secret contributed by the signaling will not harm the final resulting session key. </t><t>There may also be a static shared secret that the two parties agree on out-of-band in advance.  A hashed passphrase would suffice. </t><t>The shared secret provided by the signaling (if available), the shared secret computed by DH, and the cached shared secret are all hashed together to compute the session key for a call.  If the cached shared secret is not available, it is omitted from the hash computation.  If the signaling provides no shared secret, it is also omitted from the hash computation. </t><t>No DH MITM attack can succeed if the ongoing shared secret is available to the two parties, but not to the attacker.  This is because the attacker cannot compute a common session key with either party without knowing the cached secret component, even if he correctly executes a classic DH MITM attack.  Mixing in the cached shared secret for the session key calculation allows it to act as an implicit authenticator to protect the DH exchange, without requiring additional explicit HMACs to be computed on the DH parameters.  If the cached shared secret is available, a MITM attack would be instantly detected by the failure to achieve a shared session key, resulting in undecryptable packets.  The protocol can easily detect this.  It would be more accurate to say that the MITM attack is not merely detected, but thwarted. </t><t>When adding the complexity of additional shared secrets beyond the familiar DH key agreement, we must make sure the lack of availability of the cached shared secret cannot prevent a call from going through, and we must also prevent false alarms that claim an attack was detected. </t><t>An small added benefit of using these cached shared secrets to mix in with the session keys is that it augments the entropy of the session key.  Even if limits on the size of the DH exchange produces a session key with less than 256 bits of real work factor, the added entropy from the cached shared secret can bring up all the subsequent session keys to the full 256-bit AES key strength, assuming no attacker was present in the first call. </t><t>We could have authenticated the DH exchange the same way SSH does it, with digital signatures, caching public keys instead of shared secrets.  But this approach with caching shared secrets seemed a bit simpler, requiring less CPU time for low-powered mobile platforms because it avoids an added digital signature step. </t><t>The ZRTP SDP attributes convey information through the signaling that is already available in clear text through the media path.  For example, the ZRTP flag is equivalent to sending a ZRTP Hello message.  The SAS is calculated from a hash of material from ZRTP messages sent over the media path.   As a result, none of the ZRTP SDP attributes require confidentiality from the signaling. </t><t>The ZRTP SAS attributes can use the signaling channel as an out-of-band authentication mechanism.  This authentication is only useful if the signaling channel has end-to-end integrity protection.  Note that the SIP <xref target='RFC4474'>Identity header field</xref> provides middle-to-end integrity protection across SDP message bodies which provides useful protection for ZRTP SAS attributes. </t></section><section title="Acknowledgments"><t>The authors would like to thank Bryce Wilcox-O'Hearn for his contributions to the design of this protocol, and to thank Jon Peterson, Colin Plumb, Hal Finney, Colin Perkins, and Dan Wing for their helpful comments and suggestions. Also thanks to David McGrew, Roni Even, Viktor Krikun, Werner Dittmann, Allen Pulsifer, Klaus Peters, and Abhishek Arya for their feedback and comments. </t><t>The use of hash chains to key HMACs in ZRTP is similar to Adrian Perrig's <xref target='TESLA'>TESLA protocol</xref>. </t></section></middle><back><references title="Normative References"><?rfc include="reference.RFC.2119" ?><?rfc include="reference.RFC.3550" ?><?rfc include="reference.RFC.3711" ?><?rfc include="reference.RFC.3526" ?><?rfc include="reference.RFC.3309" ?><reference anchor='SP800-90'><front><title>Recommendation for Random Number Generation Using Deterministic Random Bit Generators</title><author initials='E.' surname='Barker' fullname='Elaine Barker'></author><author initials='J.' surname='Kelsey' fullname='John Kelsey'></author></front><seriesInfo name= 'NIST Special Publication 800-90' value='(Revised) March 2007'/><format type='HTML' target='http://csrc.nist.gov/publications/nistpubs/800-90/SP800-90revised_March2007.pdf'/></reference><reference anchor='SP800-56A'><front><title>Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography</title><author initials='E.' surname='Barker' fullname='Elaine Barker'></author><author initials='D.' surname='Johnson' fullname='Don Johnson'></author><author initials='M.' surname='Smid' fullname='Miles Smid'></author></front><seriesInfo name= 'NIST Special Publication 800-56A' value='Revision 1, March 2007'/><format type='HTML' target='http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf'/></reference><reference anchor='NSA-Suite-B'><front><title>Fact Sheet NSA Suite B Cryptography</title><author fullname='National Security Agency Information Assurance Directorate'></author></front><seriesInfo name= 'NSA Information Assurance Directorate' value='Fact Sheet NSA Suite B'/><format type='HTML' target='http://www.nsa.gov/ia/industry/crypto_suite_b.cfm'/></reference><?rfc include="reference.RFC.4753" ?><reference anchor='FIPS-186-3'><front><title>Digital Signature Standard (DSS)</title><author fullname='Federal Information Processing Standards'></author></front><seriesInfo name= 'NIST FIPS PUB 186-3' value='Draft, March 2006'/><format type='HTML' target='http://csrc.nist.gov/publications/drafts/fips_186-3/Draft-FIPS-186-3%20_March2006.pdf'/></reference><reference anchor='SP800-38A'><front><title>Recommendation for Block Cipher: Methods and Techniques</title>   <author initials='M.' surname='Dworkin' fullname='Morris Dworkin'></author></front><seriesInfo name= 'NIST Special Publication 800-38A' value='2001 Edition'/><format type='HTML' target='http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf'/></reference><reference anchor='z-base-32'><front><title>Human-oriented base-32 encoding</title>   <author initials='B.' surname='Wilcox' fullname='Bryce Wilcox'></author></front><seriesInfo name= 'http://zooko.com/repos/z-base-32/base32/DESIGN' value=''/><format type='HTML' target=' http://zooko.com/repos/z-base-32/base32/DESIGN'/></reference><reference anchor='pgpwordlist'><front><title>PGP Words</title></front><seriesInfo name='http://en.wikipedia.org/wiki/PGP_Words' value=''/><format type='HTML' target='http://en.wikipedia.org/wiki/PGP_Words'/></reference><?rfc include="reference.RFC.4566" ?></references><references title="Informative References"><?rfc include="reference.I-D.ietf-sip-media-security-requirements" ?><reference anchor='Ferguson'><front><title>Practical Cryptography</title><author initials='N.' surname='Ferguson' fullname='Niels Ferguson'></author><author initials='B.' surname='Schneier' fullname='Bruce Schneier'></author></front><seriesInfo name= 'Wiley Publishing' value='2003'/></reference><?rfc include="reference.RFC.4086" ?><reference anchor='base256'><front><title>Whole-Word Phonetic Distances and the PGPfone Alphabet</title><author initials ='P.' surname='Juola' fullname='Patrick Juola'></author> <author initials ='P.' surname='Zimmermann' fullname='Philip Zimmermann'></author></front><seriesInfo name= 'Proceedings of the International Conference of Spoken Language Processing (ICSLP-96)' value=''/><format type='HTML' target=' http://www.mathcs.duq.edu/~juola/papers.d/icslp96.pdf'/></reference><reference anchor='pgpfone'><front><title>PGPfone</title><author initials='P.' surname='Zimmermann' fullname='Philip Zimmermann'></author></front><seriesInfo name= 'http://philzimmermann.com/docs/pgpfone10b7.pdf' value=''/><format type='HTML' target='http://philzimmermann.com/docs/pgpfone10b7.pdf'/></reference><reference anchor='zfone'><front><title>Zfone</title><author initials='P.' surname='Zimmermann' fullname='Philip Zimmermann'></author></front><seriesInfo name= 'http://www.philzimmermann.com/zfone' value=''/><format type='HTML' target='http://www.philzimmermann.com/zfone'/></reference><reference anchor='Byzantine'><front><title>The Two Generals' Problem</title></front><seriesInfo name="http://en.wikipedia.org/wiki/Two_Generals%27_Problem" value=''/><format type='HTML' target="http://en.wikipedia.org/wiki/Two_Generals%27_Problem"/></reference><reference anchor='TESLA'><front><title>The TESLA Broadcast Authentication Protocol</title>   <author initials='A.' surname='Perrig' fullname='Adrian Perrig'></author>   <author initials='R.' surname='Canetti' fullname='Ran Canetti'></author>   <author initials='J.' surname='Tygar' fullname='J. D. Tygar'></author>   <author initials='D.' surname='Song' fullname='Dawn Song'></author></front><seriesInfo name= 'http://www.ece.cmu.edu/~adrian/projects/tesla-cryptobytes/tesla-cryptobytes.pdf' value=''/><format type='HTML' target='http://www.ece.cmu.edu/~adrian/projects/tesla-cryptobytes/tesla-cryptobytes.pdf'/></reference><reference anchor='comsec'><front><title>The VP1 Protocol for Voice Privacy Devices Version 1.2</title><author initials='E.' surname='Blossom' fullname='Eric A. Blossom'></author></front><seriesInfo name='http://www.comsec.com/vp1-protocol.pdf' value=''/><format type='PDF' target='http://www.comsec.com/vp1-protocol.pdf'/></reference><reference anchor='cryptophone'><front><title>CryptoPhone</title></front><seriesInfo name='http://www.cryptophone.de/' value=''/><format type='HTML' target='http://www.cryptophone.de/'/></reference><!-- <?rfc include="reference.I-D.ietf-avt-srtp-big-aes" ?> --><reference anchor='I-D.ietf-avt-srtp-big-aes'><front><title>The use of AES-192 and AES-256 in Secure RTP</title>   <author initials='D.' surname='McGrew' fullname='David McGrew'></author></front><seriesInfo name= 'http://www1.tools.ietf.org/html/draft-ietf-avt-srtp-big-aes' value=''/><format type='HTML' target='http://www1.tools.ietf.org/html/draft-ietf-avt-srtp-big-aes'/></reference> <?rfc include="reference.RFC.3261" ?> <?rfc include="reference.RFC.4251" ?> <?rfc include="reference.RFC.4568" ?> <?rfc include="reference.RFC.4567" ?> <?rfc include="reference.RFC.3830" ?> <?rfc include="reference.RFC.3514" ?> <?rfc include="reference.RFC.4474" ?> <?rfc include="reference.I-D.ietf-mmusic-ice" ?> <?rfc include="reference.RFC.4579" ?> <?rfc include="reference.I-D.wing-sip-identity-media" ?> <?rfc include="reference.RFC.3824" ?> <?rfc include="reference.I-D.ietf-avt-dtls-srtp" ?></references></back></rfc>