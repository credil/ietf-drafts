 



Network Working Group                                          J. Uberti
Internet-Draft                                                    Google
Intended status: Standards Track                        January 23, 2012
Expires: July 26, 2012                                                  


               Javascript Session Establishment Protocol
                      draft-uberti-rtcweb-jsep-00

Abstract

   This document proposes a mechanism for allowing a Javascript
   application to fully control the signaling plane of a multimedia
   session, and discusses how this would work with existing signaling
   protocols.

   This document is an input document for discussion.  It should be
   discussed in the RTCWEB WG list, rtcweb@ietf.org.

Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on July 26, 2012.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
 


Uberti                   Expires July 26, 2012                  [Page 1]

Internet-Draft                    JSEP                      January 2012


   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


Table of Contents

   1. Introduction  . . . . . . . . . . . . . . . . . . . . . . . . .  4
   2. JSEP Approach . . . . . . . . . . . . . . . . . . . . . . . . .  5
   3. Other Approaches Considered . . . . . . . . . . . . . . . . . .  6
   4. Semantics and Syntax  . . . . . . . . . . . . . . . . . . . . .  7
     4.1. Signaling Model . . . . . . . . . . . . . . . . . . . . . .  7
     4.2. Session Descriptions  . . . . . . . . . . . . . . . . . . .  7
     4.3. Session Description Format  . . . . . . . . . . . . . . . .  8
     4.4. Separation of Signaling and ICE State Machines  . . . . . .  9
     4.5. ICE Candidate Format  . . . . . . . . . . . . . . . . . . .  9
   5. Media Setup Overview  . . . . . . . . . . . . . . . . . . . . .  9
     5.1. Initiating the Session  . . . . . . . . . . . . . . . . . . 10
       5.1.1. Generating An Offer . . . . . . . . . . . . . . . . . . 10
       5.1.2. Applying the Offer  . . . . . . . . . . . . . . . . . . 10
       5.1.3. Initiating ICE  . . . . . . . . . . . . . . . . . . . . 10
       5.1.4. Serializing the Offer and Candidates  . . . . . . . . . 11
     5.2. Receiving the Session . . . . . . . . . . . . . . . . . . . 11
       5.2.1. Receiving the Offer . . . . . . . . . . . . . . . . . . 11
       5.2.2. Initiating ICE  . . . . . . . . . . . . . . . . . . . . 11
       5.2.3. Handling ICE Messages . . . . . . . . . . . . . . . . . 11
       5.2.4. Generating the Answer . . . . . . . . . . . . . . . . . 11
       5.2.5. Applying the Answer . . . . . . . . . . . . . . . . . . 12
       5.2.6. Serializing the Answer  . . . . . . . . . . . . . . . . 12
     5.3. Completing the Session  . . . . . . . . . . . . . . . . . . 12
       5.3.1. Receiving the Answer  . . . . . . . . . . . . . . . . . 12
     5.4. Updates to the Session  . . . . . . . . . . . . . . . . . . 12
   6. Proposed WebRTC API changes . . . . . . . . . . . . . . . . . . 13
     6.1. PeerConnection API  . . . . . . . . . . . . . . . . . . . . 13
     6.2. MediaHints  . . . . . . . . . . . . . . . . . . . . . . . . 14
   7. Example API Flows . . . . . . . . . . . . . . . . . . . . . . . 14
     7.1. Call using ROAP . . . . . . . . . . . . . . . . . . . . . . 14
     7.2. Call using XMPP . . . . . . . . . . . . . . . . . . . . . . 15
     7.3. Adding video to a call, using XMPP  . . . . . . . . . . . . 16
     7.4. Call using SIP  . . . . . . . . . . . . . . . . . . . . . . 17
     7.5. Handling early media (e.g. 1-800-FEDEX), using SIP  . . . . 17
   8. Security Considerations . . . . . . . . . . . . . . . . . . . . 17
   9. IANA Considerations . . . . . . . . . . . . . . . . . . . . . . 17
 


Uberti                   Expires July 26, 2012                  [Page 2]

Internet-Draft                    JSEP                      January 2012


   10. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 17
   11. References . . . . . . . . . . . . . . . . . . . . . . . . . . 17
     11.1. Normative References . . . . . . . . . . . . . . . . . . . 17
     11.2. Informative References . . . . . . . . . . . . . . . . . . 18
   Appendix A. Open Issues  . . . . . . . . . . . . . . . . . . . . . 18
   Appendix B. Change log . . . . . . . . . . . . . . . . . . . . . . 19
   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 19









































 


Uberti                   Expires July 26, 2012                  [Page 3]

Internet-Draft                    JSEP                      January 2012


1. Introduction

   The general thinking behind WebRTC call setup has been to fully
   specify and control the media plane, but to leave the signaling plane
   up to the application as much as possible. The rationale is that
   different applications may prefer to use different protocols, such as
   the existing SIP or Jingle call signaling protocols, or something
   custom to the particular application, perhaps for a novel use case.
   In this approach, the key information that needs to be exchanged is
   the multimedia session description, which specifies the necessary
   transport and media configuration information necessary to establish
   the media plane.

   The original spec for WebRTC attempted to implement this protocol-
   agnostic signaling by providing a mechanism to exchange session
   descriptions in the form of SDP blobs. Upon starting a session, the
   browser would generate a SDP blob, which would be passed to the
   application for transport over its preferred signaling protocol. On
   the remote side, this blob would be passed into the browser from the
   application, and the browser would then generate a blob of its own in
   response. Upon transmission back to the initiator, this blob would be
   plugged into their browser, and the handshake would be complete.

   Experimentation with this mechanism turned up several shortcomings,
   which generally stemmed from there being insufficient context at the
   browser to fully determine the meaning of a SDP blob. For example,
   determining whether a blob is an offer or an answer, or
   differentiating a new offer from a retransmit.

   The ROAP proposal, specified in http://tools.ietf.org/html/draft-
   jennings-rtcweb-signaling-01, attempted to resolve these issues by
   providing additional structure in the messaging - in essence, to
   create a generic signaling protocol that specifies how the browser
   signaling state machine should operate. However, even though the
   protocol is abstracted, the state machine forces a least-common-
   denominator approach on the signaling interactions. For example, in
   Jingle, the call initiator can provide additional ICE candidates even
   after the initial offer has been sent, which allows the offer to be
   sent immediately for quicker call startup. However, in the browser
   state machine, there is no notion of sending an updated offer before
   the initial offer has been responded to, rendering this functionality
   impossible.

   While specific concerns like this could be addressed by modifying the
   generic protocol, others would likely be discovered later. The main
   reason this mechanism is inflexible is because it embeds a signaling
   state machine within the browser. Since the browser generates the
   session descriptions on its own, and fully controls the possible
 


Uberti                   Expires July 26, 2012                  [Page 4]

Internet-Draft                    JSEP                      January 2012


   states and advancement of the signaling state machine, modification
   of the session descriptions or use of alternate state machines
   becomes difficult or impossible.

   The browser environment also has its own challenges that cause
   problems for an embedded signaling state machine. One of these is
   that the user may reload the web page at any time. If this happens,
   and the state machine is being run at a server, the server can simply
   push the current state back down to the page and resume the call
   where it left off. If instead the state machine is run at the browser
   end, and is instantiated within, for example, the PeerConnection
   object, that state machine will be reinitialized when the page is
   reloaded and the JavaScript re-executed. This actually complicates
   the design of any interoperability service, as all cases where an
   offer or answer has already been generated but is now "forgotten"
   must now be handled by trying to move the client state machine
   forward to the same state it had been in previously in order to match
   what has already been delivered to and/or answered by the far side,
   or handled by ensuring that aborts are cleanly handled from every
   state and the negotiation rapidly restarted.


2. JSEP Approach

   To resolve these issues, this document proposes the Javascript
   Session Establishment Protocol (JSEP) that pulls the signaling state
   machine out of the browser and into Javascript. This mechanism
   effectively removes the browser almost completely from the core
   signaling flow; the only interface needed is a way for the
   application to pass in the local and remote session descriptions
   negotiated by whatever signaling mechanism is used, and a way to
   interact with the ICE state machine. 

   JSEP's handling of session descriptions is simple and
   straightforward. Whenever an offer/answer exchange is needed, the
   initiating side creates an offer by calling the createOffer(hints)
   API on PeerConnection. The application can do massaging of that
   offer, if it wants to, and then sends it off to the remote side over
   its preferred signaling mechanism (e.g. WebSockets). Upon receipt of
   that offer, the remote party calls the createAnswer(offer, hints) to
   generate an appropriate answer, and sends that back to the initiator.
   When the offer and answer each have been deemed by the signaling
   protocol to be "live", the application will apply them to the
   PeerConnection via the setLocalDescription(type, desc) and
   setRemoteDescription(type, desc) APIs. This process can be repeated
   for additional offer/answer exchanges.

   Regarding ICE, in this approach we decouple the ICE state machine
 


Uberti                   Expires July 26, 2012                  [Page 5]

Internet-Draft                    JSEP                      January 2012


   from the overall signaling state machine; the ICE state machine must
   remain in the browser, given that only the browser has the necessary
   knowledge of candidates and other transport info. While transport has
   typically been lumped in with session descriptions, performing this
   separation it provides additional flexibility. In protocols that
   decouple session descriptions from transport, such as Jingle, the
   transport information can be sent separately; in protocols that
   don't, such as SIP, the information can be easily aggregated and
   recombined. Sending transport information separately can allow for
   faster ICE and DTLS startup, since the necessary roundtrips can occur
   while waiting for the remote side to accept the session.

   The JSEP approach does come with a minor downside. As the application
   now is responsible for driving the signaling state machine, slightly
   more application code is necessary to perform call setup; the
   application must call the right APIs at the right times, and convert
   the session desciptions and ICE information into the defined messages
   of its chosen signaling protocol, instead of simply forwarding the
   messages emitted from the browser. 

   One way to mitigate this is to provide a Javascript library that
   hides this complexity from the developer, which would implement the
   state machine and serialization of the desired signaling protocol.
   For example, this library could convert easily adapt the JSEP API
   into the exact ROAP API, thereby implementing the ROAP signaling
   protocol. Such a library could of course also implement other popular
   signaling protocols, including SIP or Jingle. In this fashion we can
   enable greater control for the experienced developer without forcing
   any additional complexity on the novice developer.

3. Other Approaches Considered

   Another approach that was considered for JSEP was to move the
   mechanism for generating offers and answers out of the browser as
   well. This approach would add a getCapabilities API which would
   provide the application with the information it needed in order to
   generate session descriptions. This increases the amount of work that
   the application needs to do; it needs to know how to generate session
   descriptions from capabilities, and especially how to generate the
   correct answer from an arbitrary offer and available capabilities.
   While this could certainly be addressed by using a library like the
   one mentioned above, some experimentation also indicates that coming
   up with a sufficiently complete getCapabilities API is a nontrivial
   undertaking. Nevertheless, if we wanted to go down this road, JSEP
   makes it significantly easier; if a getCapabilities API is added in
   the future, the application can generate session descriptions
   accordingly and pass those to the
   setLocalDescription/setRemoteDescription APIs added by JSEP. (Even
 


Uberti                   Expires July 26, 2012                  [Page 6]

Internet-Draft                    JSEP                      January 2012


   with JSEP, an application could still perform its own browser
   fingerprinting and generate approximate session descriptions as a
   result.)

   Note also that while JSEP transfers more control to Javascript, it is
   not intended to be an example of a "low-level" API. The general
   argument against a low-level API is that there are too many necessary
   API points, and they can be called in any order, leading to something
   that is hard to specify and test. In the approach proposed here,
   control is performed via session descriptions; this requires only a
   few APIs to handle these descriptions, and they are evaluated in a
   specific fashion, which reduces the number of possible states and
   interactions.

4. Semantics and Syntax

4.1. Signaling Model

   JSEP does not specify a particular signaling model or state machine,
   other than the generic need to exchange RFC 3264-esque offers and
   answers in order for both sides of the session to know how to conduct
   the session. JSEP provides mechanisms to create offers and answers,
   as well as to apply them to a PeerConnection. However, the actual
   mechanism by which these offers and answers are communicated to the
   remote side, including addressing, retransmission, forking, and glare
   handling, is left entirely up to the application.

4.2. Session Descriptions

   In order to establish the media plane, PeerConnection needs specific
   parameters to indicate what to transmit to the remote side, as well
   as how to handle the media that is received. These parameters are
   determined by the exchange of session descriptions in offers and
   answers, and there are certain details to this process that must be
   handled in the JSEP APIs.

   Whether a session description was sent or received affects the
   meaning of that description. For example, the list of codecs sent to
   a remote party indicates what the local side is willing to decode,
   and what the remote party should send. Not all parameters follow this
   rule; the SRTP parameters sent to a remote party indicate what the
   local side will use to encrypt, and thereby how the remote party
   should expect to receive. 

   In addition, various RFCs put different conditions on the format of
   offers versus answers. For example, a offer may propose multiple SRTP
   configurations, but an answer may only contain a single SRTP
   configuration.
 


Uberti                   Expires July 26, 2012                  [Page 7]

Internet-Draft                    JSEP                      January 2012


   Lastly, while the exact media parameters are only known only after a
   offer and an answer have been exchanged, it is possible for the
   offerer to receive media after they have sent an offer and before
   they have received an answer. To properly process incoming media in
   this case, the offerer's media handler must be aware of the details
   of the offerer before the answer arrives.

   Therefore, in order to handle session descriptions properly,
   PeerConnection needs:

      1. To know if a session description pertains to the local or
      remote side.

      2. To know If a session description is an offer or an answer.

      3. To allow the offer to be specified independently of the answer.

   JSEP addresses this by adding both a setLocalDescription and a
   setRemoteDescription method, and both these methods take as a first
   parameter either the value SDP_OFFER, or SDP_ANSWER. This satisfies
   the requirements listed above for both the offererer, who first calls
   setLocalDescription(SDP_OFFER, sdp) and then later
   setRemoteDescription(SDP_ANSWER, sdp), as well as for the answerer,
   who first calls setRemoteDescription(SDP_OFFER, sdp) and then later
   setLocalDescription(SDP_ANSWER, sdp). 

   While it could be possible to implicitly determine the value of the
   offer/answer argument inside of PeerConnection, requiring it to be
   specified explicitly seems substantially more robust, allowing
   invalid combinations (i.e. an answer before an offer) to generate an
   appropriate error.

4.3. Session Description Format

   In the current WebRTC specification, session descriptions are
   formatted as SDP messages. While this format is not optimal for
   manipulation from Javascript, it is widely accepted, and frequently
   updated with new features. Any alternate encoding of session
   descriptions would have to keep pace with the changes to SDP, at
   least until the time that this new encoding eclipsed SDP in
   popularity. As a result, JSEP continues to use SDP as the format for
   its session descriptions.

   Note that this decision does not prevent us from using an alternate
   encoding in the future; if we were able to agree on a JSON format for
   session descriptions, surely it would be easy to add a switch to
   PeerConnection to tell it to generate/expect JSON.

 


Uberti                   Expires July 26, 2012                  [Page 8]

Internet-Draft                    JSEP                      January 2012


4.4. Separation of Signaling and ICE State Machines

   Previously, PeerConnection operated two state machines, referred to
   in the spec as an "ICE Agent", which handles the establishment of
   peer-to-peer connectivity, and an "SDP Agent", which handles the
   state of the offer-answer signaling. The states of these state
   machines were exposed through the iceState and sdpState attributes on
   PeerConnection, with an additional readyState attribute that
   reflected the high-level state of the PeerConnection.

   JSEP does away with the SDP Agent within the browser; this
   functionality is now controlled directly by the application, which
   uses the setLocalDescription and setRemoteDescription APIs to tell
   PeerConnection what SDP has been negotiated. The ICE Agent remains in
   the browser, as it still needs to perform gathering of candidates,
   connectivity checking, and related ICE functionality.

   The net effect of this is that sdpState goes away, and
   processSignalingMessage becomes processIceMessage, which now
   specifically handles incoming ICE candidates. To allow the
   application to control exactly when it wants to start ICE negotiation
   (e.g. either on receipt of the call, or only after accepting the
   call), a connect method has been added.

4.5. ICE Candidate Format

   As with session descriptions, we choose to use SDP's representation
   of ICE candidates in this API, specifically processIceMessage. For
   example:

      a=candidate:1 1 UDP 1694498815 66.77.88.99 10000 typ host

   While a JSON encoding could have been used, it is probably simplest
   to stay consistent and use the SDP representation, given the ease
   with which this string can be parsed.

   Currently, a=candidate lines are the only thing that are exchanged.
   In the future, it might be useful to include other transport-related
   information, such as the DTLS certificate fingerprint, or whether
   transport muxing has been enabled.

5. Media Setup Overview

   The example here shows a typical call setup using the JSEP model. We
   assume the following architecture in this example, where UA is
   synonymous with "browser", and JS is synonymous with "web
   application":

 


Uberti                   Expires July 26, 2012                  [Page 9]

Internet-Draft                    JSEP                      January 2012


   OffererUA <-> OffererJS <->WebServer <-> AnswererJS <-> AnswererUA

5.1. Initiating the Session

   The initiator creates a PeerConnection, installs its IceCallback, and
   adds the desired MediaStreams (presumably obtained via getUserMedia).
   The PeerConnection is in the NEW state.

   OffererJS->OffererUA: var pc = new PeerConnection(config, iceCb);
   OffererJS->OffererUA: pc.addStream(stream);

5.1.1. Generating An Offer

   The initiator then creates a session description to offer to the
   callee. This description includes the codecs and other necessary
   session parameters, as well as information about each of the streams
   that has been added (e.g. SSRC, CNAME, etc.) The created description
   includes all parameters that the offerer's UA supports; if the
   initiator wants to influence the created offer, they can pass in a
   MediaHints object to createOffer that allows for customization (e.g.
   if the initiator wants to receive but not send video). The initiator
   can also directly manipulate the created session description as well,
   perhaps if it wants to change the priority of the offerered codecs.

   OffererJS->OffererUA: var offer = pc.createOffer(null);

5.1.2. Applying the Offer

   The initiator then instructs the PeerConnection to use this offer as
   the local description for this session, i.e. what codecs it will use
   for received media, what SRTP keys it will use for sending media (if
   using SDES), etc. In order that the UA handle the description
   properly, the initiator marks it as an offer when calling
   setLocalDescription; this indicates to the UA that multiple
   capabilities have been offered, but this set may be pared back later,
   when the answer arrives.

   OffererJS->OffererUA: pc.setLocalDescription(SDP_OFFER, offer);

5.1.3. Initiating ICE

   The initiator can now start the ICE process of candidate generation
   and connectivity checking. This results in callbacks to the
   application's IceCallback.

   OffererJS->OffererUA: pc.connect();
   OffererUA->OffererJS: iceCallback(candidates);

 


Uberti                   Expires July 26, 2012                 [Page 10]

Internet-Draft                    JSEP                      January 2012


5.1.4. Serializing the Offer and Candidates

   At this point, the offerer is ready to send its offer to the callee
   using its preferred signaling protocol. Depending on the protocol, it
   can either send the initial session description first, and then
   "trickle" the ICE candidates as they are given to the application, or
   it can wait for all the ICE candidates to be collected, and then send
   the offer and list of candidates all at once.

5.2. Receiving the Session

   Through the chosen signaling protocol, the recipient is notified of
   an incoming session request. It creates a PeerConnection, and
   installs its own IceCallback.

   AnswererJS->AnswererUA: var pc = new PeerConnection(config, iceCb);

5.2.1. Receiving the Offer

   The recipient converts the received offer from its signaling protocol
   into SDP format, and supplies it to its PeerConnection, again marking
   it as an offer. As a remote description, the offer indicates what
   codecs the remote side wants to use for receiving, as well as what
   SRTP keys it will use for sending. The setting of the remote
   description causes callbacks to be issued, informing the application
   of what kinds of streams are present in the offer.

   AnswererJS->AnswererUA: pc.setRemoteDescription(SDP_OFFER, offer);
   AnswererUA->AnswererJS: onAddStream(stream);

5.2.2. Initiating ICE

   The recipient then starts its own ICE state machine, to allow
   connectivity to be established as quickly as possible.

   AnswererJS->AnswererUA: pc.connect();
   AnswererUA->AnswererJS: iceCallback(candidates);

5.2.3. Handling ICE Messages

   If ICE candidates from the remote site were included in the offer,
   the ICE Agent will automatically start trying to use them. Otherwise,
   if ICE candidates are sent separately, they are passed into the
   PeerConnection when they arrive.

   AnswererJS->AnswererUA: pc.processIceMessage(candidates);

5.2.4. Generating the Answer
 


Uberti                   Expires July 26, 2012                 [Page 11]

Internet-Draft                    JSEP                      January 2012


   Once the recipient has decided to accept the session, it generates an
   answer session description. This process performs the appropriate
   intersection of codecs and other parameters to generate the correct
   answer. As with the offer, MediaHints can be provided to influence
   the answer that is generated, and/or the application can post-process
   the answer manually.

   AnswererJS->AnswererUA: pc.createAnswer(offer, null);

5.2.5. Applying the Answer

   The recipient then instructs the PeerConnection to use the answer as
   its local description for this session, i.e. what codecs it will use
   to receive media, etc. It also marks the description as an answer,
   which tells the UA that these parameters are final. This causes the
   PeerConnection to move to the ACTIVE state, and transmission of media
   by the answerer to start.

   AnswererJS->AnswererUA: pc.setLocalDescription(SDP_ANSWER, answer);
   AnswererUA->OffererUA:  <media>

5.2.6. Serializing the Answer

   As with the offer, the answer (with or without candidates) is now
   converted to the desired signaling format and sent to the initiator.

5.3. Completing the Session

5.3.1. Receiving the Answer

   The initiator converts the answer from the signaling protocol and
   applies it as the remote description, marking it as an answer. This
   causes the PeerConnection to move to the ACTIVE state, and
   transmission of media by the offerer to start.

   OffererJS->OffererUA:  pc.setRemoteDescription(SDP_ANSWER, answer);
   OffererUA->AnswererUA: <media>

5.4. Updates to the Session

   Updates to the session are handled with a new offer/answer exchange.
   However, since media will already be flowing at this point, the new
   session descriptions should not be passed into PeerConnection until
   the changes have been accepted by the remote side, to prevent sending
   media that the remote side is not prepared to handle.

   Note also that in an update scenario, the roles may be reversed, i.e.
   the update offerer can be different than the original offerer.
 


Uberti                   Expires July 26, 2012                 [Page 12]

Internet-Draft                    JSEP                      January 2012


6. Proposed WebRTC API changes

6.1. PeerConnection API

   The text below indicates the recommended changes to the
   PeerConnection API to implement the JSEP functionality. Methods
   marked with a [+] are new/proposed; methods marked with a [-] have
   been removed in this proposal.

   [Constructor (in DOMString configuration, in IceCallback iceCb)]
   interface PeerConnection {
       // creates a blob of SDP to be provided as an offer.    
   [+] DOMString createOffer (MediaHints hints);
       // creates a blob of SDP to be provided as an answer.
   [+] DOMString createAnswer (DOMString offer, MediaHints hints);
       // sets the local session description (except ICE info)
   [+] void setLocalDescription (Action action, DOMString sdp);
       // sets the remote session description (except ICE info)
   [+] void setRemoteDescription (Action action, DOMString sdp);
       // returns the current local session description
   [+] readonly DOMString localDescription;
       // returns the current remote session description
   [+] readonly DOMString remoteDescription;
   [-] void processSignalingMessage (DOMString message);
       const unsigned short NEW = 0;     // initial state
       const unsigned short ACTIVE = 1;  // local+remote desc set, live
       const unsigned short CLOSED = 2;  // ended state
       readonly attribute unsigned short readyState;
       // starts ICE connection/handshaking
   [+] void connect();
       // processes received ICE information
   [+] void processIceMessage (DOMString message);
       const unsigned short ICE_GATHERING = 0x100;
       const unsigned short ICE_WAITING = 0x200;
       const unsigned short ICE_CHECKING = 0x300;
       const unsigned short ICE_CONNECTED = 0x400;
       const unsigned short ICE_COMPLETED = 0x500;
       const unsigned short ICE_FAILED = 0x600;
       const unsigned short ICE_CLOSED = 00x700;
       readonly attribute unsigned short iceState;
   [-] const unsigned short SDP_IDLE = 0x1000;
   [-] const unsigned short SDP_WAITING = 0x2000;
   [-] const unsigned short SDP_GLARE = 0x3000;
   [-] readonly attribute unsigned short sdpState;
       void addStream (MediaStream stream, MediaStreamHints hints);
       void removeStream (MediaStream stream);
       readonly attribute MediaStream[]  localStreams;
       readonly attribute MediaStream[]  remoteStreams;
 


Uberti                   Expires July 26, 2012                 [Page 13]

Internet-Draft                    JSEP                      January 2012


       void close ();
       [ rest of interface omitted ]
   };

6.2. MediaHints

   MediaHints is an object that can be passed into createOffer or
   createAnswer to affect the type of offer/answer that is generated. 

   The following properties can be set on MediaHints:

      has_audio: boolean // whether we want to receive audio // defaults
      to true if we have audio streams, else false

      has_video: boolean // whether we want to receive video // defaults
      to true if we have video streams, else false

   As an example, MediaHints could be used to create a session that
   transmits only audio, but is able to receive video from the remote
   side, by forcing the inclusion of a m=video line even when no video
   sources are provided.

7. Example API Flows

   Below are several sample flows for the new PeerConnection and library
   APIs, demonstrating when the various APIs are called in different
   situations and with various transport protocols.

7.1. Call using ROAP

   // Call is initiated toward Answerer
   OffererJS->OffererUA:   pc = new PeerConnection();
   OffererJS->OffererUA:   pc.addStream(localStream, null);
   OffererJS->OffererUA:   offer = pc.createOffer(null);
   OffererJS->OffererUA:   peer.setLocalDescription(SDP_OFFER, offer);

   OffererJS->OffererUA:   pc.connect();
   OffererUA->OffererJS:   iceCallback(cand); these are added to |offer|
   OffererJS->AnswererJS:  {"type":"OFFER", "sdp":"<offer>"}

   // OFFER arrives at Answerer
   AnswererJS->AnswererUA: pc = new PeerConnection();
   AnswererJS->AnswererUA: pc.setRemoteDescription(SDP_OFFER, msg.sdp);
   AnswererUA->AnswererJS: onaddstream(remoteStream);
   AnswererJS->AnswererUA: pc.processIceMessage(GetCandidates(msg.sdp));
   AnswererJS->AnswererUA: pc.connect();
   AnswererUA->OffererUA:  iceCallback(cand);

 


Uberti                   Expires July 26, 2012                 [Page 14]

Internet-Draft                    JSEP                      January 2012


   // Answerer accepts call
   AnswererJS->AnswererUA: peer.addStream(localStream, null);
   AnswererJS->AnswererUA: answer = peer.createAnswer(msg.offer, null);
   AnswererJS: candidates are added to |answer|
   AnswererJS->AnswererUA: peer.setLocalDescription(SDP_ANSWER, answer);
   AnswererJS->OffererJS:  {"type":"ANSWER","sdp":"<answer>"}

   // ANSWER arrives at Offerer
   OffererJS->OffererUA:   peer.setRemoteDescription(ANSWER, answer); 
   OffererUA->OffererJS:   onaddstream(remoteStream);
   OffererJS->OffererUA:   pc.processIceMessage(GetCandidates(msg.sdp));

   // ICE Completes (at Answerer)
   AnswererUA->AnswererJS: onopen();
   AnswererUA->OffererUA:  Media

   // ICE Completes (at Offerer)
   OffererUA->OffererJS:   onopen();
   OffererJS->AnswererJS:  {"type":"OK" }
   OffererUA->AnswererUA:  Media

7.2. Call using XMPP

   // Call is initiated toward Answerer
   OffererJS->OffererUA:   pc = new PeerConnection();
   OffererJS->OffererUA:   pc.addStream(localStream, null);
   OffererJS->OffererUA:   offer = pc.createOffer(null);
   OffererJS->OffererUA:   peer.setLocalDescription(SDP_OFFER, offer);
   OffererJS:              xmpp = createSessionInitiate(offer);
   OffererJS->AnswererJS:  <jingle action="session-initiate"/>

   OffererJS->OffererUA:   pc.connect();
   OffererUA->OffererJS:   iceCallback(cand);
   OffererJS:              createTransportInfo(cand);
   OffererJS->AnswererJS:  <jingle action="transport-info"/>

   // session-initiate arrives at Answerer
   AnswererJS->AnswererUA: pc = new PeerConnection();
   AnswererJS:             offer = parseSessionInitiate(xmpp);
   AnswererJS->AnswererUA: pc.setRemoteDescription(SDP_OFFER, offer);
   AnswererUA->AnswererJS: onaddstream(remoteStream);

   // transport-infos arrive at Answerer
   AnswererJS->AnswererUA: candidates = parseTransportInfo(xmpp);
   AnswererJS->AnswererUA: pc.processIceMessage(candidates);
   AnswererJS->AnswererUA: pc.connect();
   AnswererUA->AnswererJS: iceCallback(cand)
   AnswererJS:             createTransportInfo(cand);
 


Uberti                   Expires July 26, 2012                 [Page 15]

Internet-Draft                    JSEP                      January 2012


   AnswererJS->OffererJS:  <jingle action="transport-info"/>

   // transport-infos arrive at Offerer
   OffererJS->OffererUA:  candidates = parseTransportInfo(xmpp);
   OffererJS->OffererUA:  pc.processIceMessage(candidates);

   // Answerer accepts call
   AnswererJS->AnswererUA: peer.addStream(localStream, null);
   AnswererJS->AnswererUA: answer = peer.createAnswer(offer, null);
   AnswererJS:             xmpp = createSessionAccept(answer);
   AnswererJS->AnswererUA: peer.setLocalDescription(SDP_ANSWER, answer);
   AnswererJS->OffererJS:  <jingle action="session-accept"/>

   // session-accept arrives at Offerer
   OffererJS:              answer = parseSessionAccept(xmpp);
   OffererJS->OffererUA:   peer.setRemoteDescription(ANSWER, answer); 
   OffererUA->OffererJS:   onaddstream(remoteStream);
   OffererJS->OffererUA:   pc.processIceMessage(GetCandidates(msg.sdp));

   // ICE Completes (at Answerer)
   AnswererUA->AnswererJS: onopen();
   AnswererUA->OffererUA:  Media

   // ICE Completes (at Offerer)
   OffererUA->OffererJS:   onopen();
   OffererUA->AnswererUA:  Media

7.3. Adding video to a call, using XMPP

   Note that the offerer may be different than the original offerer. In
   addition, unlike the othe local description is not set until the 

   // Offerer adds video stream
   OffererJS->OffererUA:   pc.addStream(videoStream)
   OffererJS->OffererUA:   offer = pc.createOffer(null);
   OffererJS:              xmpp = createContentAdd(offer);
   OffererJS->AnswererJS:  <jingle action="content-add"/>

   // content-add arrives at Answerer
   AnswererJS:             offer = parseContentAdd(xmpp);
   AnswererJS->AnswererUA: pc.setRemoteDescription(SDP_OFFER, offer);
   AnswererJS->AnswererUA: answer = pc.createAnswer(offer, null);
   AnswererJS->AnswererUA: pc.setLocalDescription(SDP_ANSWER, answer);
   AnswererJS:             xmpp = createContentAccept(answer);
   AnswererJS->OffererJS:  <jingle action="content-accept"/>

   // content-accept arrives at Offerer
   OffererJS:              answer = parseContentAccept(xmpp);
 


Uberti                   Expires July 26, 2012                 [Page 16]

Internet-Draft                    JSEP                      January 2012


   OffererJS->OffererUA:   pc.setLocalDescription(SDP_OFFER, offer);
   OffererJS->OffererUA:   pc.setRemoteDescription(SDP_ANSWER, answer);

7.4. Call using SIP

   TODO

7.5. Handling early media (e.g. 1-800-FEDEX), using SIP

   TODO

   // normal setup

   // 180 is received var sdp = parseResponse(sip);
   pc.setRemoteDescription(ANSWER, sdp);

   // 200 is received var sdp = parseResponse(sip);
   pc.setRemoteDescription(ANSWER, sdp);   

8. Security Considerations

   TODO

9. IANA Considerations

   This document requires no actions from IANA.

10. Acknowledgements

   Harald Alvestrand, Cullen Jennings, Dan Burnett, Neil Stratford, and
   Eric Rescorla all provided valuable feedback on this proposal.
   Matthew Kaufman provided the observation that keeping state out of
   the browser allows a call to continue even if the page is reloaded.

11. References

11.1. Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
   Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC3264]  Rosenberg, J. and H. Schulzrinne, "An Offer/Answer Model
   with Session Description Protocol (SDP)", RFC 3264, June 2002.

   [RFC4566]  Handley, M., Jacobson, V., and C. Perkins, "SDP: Session
   Description Protocol", RFC 4566, July 2006.


 


Uberti                   Expires July 26, 2012                 [Page 17]

Internet-Draft                    JSEP                      January 2012


11.2. Informative References

   [RFC4568]  Andreasen, F., Baugher, M., and D. Wing, "Session
   Description Protocol (SDP) Security Descriptions for Media Streams",
   RFC 4568, July 2006.

   [RFC5245]  Rosenberg, J., "Interactive Connectivity Establishment
   (ICE): A Protocol for Network Address Translator (NAT) Traversal for
   Offer/Answer Protocols", RFC 5245, April 2010.

   [webrtc-api] Bergkvist, Burnett, Jennings, Narayanan, "WebRTC 1.0:
   Real-time Communication Between Browsers", October 2011.

   Available at http://dev.w3.org/2011/webrtc/editor/webrtc.html

Appendix A. Open Issues

   - More examples needed: SIP, Early media, Forking, Glare.

   - Determine proper signaling of errors (e.g. out of resources error
   in setLocalDescription). Leaning toward something like a PCException,
   a la https://developer.mozilla.org/en/IndexedDB/IDBDatabaseException

   - When does the endpoint start sending? Currently, when
   setLocalDescription + setRemoteDescription have been called, the PC
   transitions into the ACTIVE state, and starts sending. It might be
   useful to make this more explicit, i.e. have a method that controls
   whether media is sent or not. Need to think about how we would
   implement call hold; it would work either by toggling this method, or
   applying a description with a=recvonly/inactive; an example would be
   useful here.

   - What are the exact semantics of connect()? Does it gather
   candidates and start connectivity checks? If so, how do we limit the
   connection to using TURN candidates before the call is accepted? If
   not, what method do we need to add?

   - How does connect() know how many components to gather candidates
   for? On the caller side, connect() knows from the local description.
   But on the callee side, connect() occurs after the remote
   description, and the local description is not yet set. So the number
   of components is not yet known. Solutions include allowing the local
   desc to be set without activating the call, or having a separate
   mechanism for indicating the # of components (though this is probably
   hard to get right).

   - iceCallback needs some way of indicating doneness, for SIP and
   other protocols that need all candidates together. iceCallback needs
 


Uberti                   Expires July 26, 2012                 [Page 18]

Internet-Draft                    JSEP                      January 2012


   to associate each candidate with a particular m= line;
   processIceMessage will need the equivalent.

   - Need callback to indicate that the transport is down, e.g.
   ICE_DISCONNECTED or ondisconnected().

Appendix B. Change log

   00: Initial version; includes some improvements from W3C mailing list
   feedback.

Author's Address

   Justin Uberti





































Uberti                   Expires July 26, 2012                 [Page 19]
