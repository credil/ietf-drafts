<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc authorship="yes"?>
<?rfc tocappendix="yes"?>
<rfc category="std" docName="draft-ietf-roll-rpl-05" ipr="trust200902">
  <front>
    <title abbrev="draft-ietf-roll-rpl-05">RPL: IPv6 Routing Protocol for Low
    power and Lossy Networks</title>

    <author fullname="Tim Winter" initials="T" role="editor" surname="Winter">
      <organization></organization>

      <address>
        <email>wintert@acm.org</email>
      </address>
    </author>

    <author fullname="Pascal Thubert" initials="P" role="editor"
            surname="Thubert">
      <organization abbrev="Cisco Systems">Cisco Systems</organization>

      <address>
        <postal>
          <street>Village d'Entreprises Green Side</street>

          <street>400, Avenue de Roumanille</street>

          <street>Batiment T3</street>

          <city>Biot - Sophia Antipolis</city>

          <code>06410</code>

          <country>FRANCE</country>
        </postal>

        <phone>+33 497 23 26 34</phone>

        <email>pthubert@cisco.com</email>
      </address>
    </author>

    <author fullname="ROLL Design Team" initials="" surname="ROLL Design Team">
      <organization>IETF ROLL WG</organization>

      <address>
        <email>rpl-authors@external.cisco.com</email>
      </address>
    </author>

    <date day="7" month="December" year="2009" />

    <area>Routing Area</area>

    <workgroup>Networking Working Group</workgroup>

    <keyword>Draft</keyword>

    <abstract>
      <t>Low power and Lossy Networks (LLNs) are a class of network in which
      both the routers and their interconnect are constrained: LLN routers
      typically operate with constraints on (any subset of) processing power,
      memory and energy (battery), and their interconnects are characterized
      by (any subset of) high loss rates, low data rates and instability. LLNs
      are comprised of anything from a few dozen and up to thousands of LLN
      routers, and support point-to-point traffic (between devices inside the
      LLN), point-to-multipoint traffic (from a central control point to a
      subset of devices inside the LLN) and multipoint-to-point traffic (from
      devices inside the LLN towards a central control point). This document
      specifies the IPv6 Routing Protocol for LLNs (RPL), which provides a
      mechanism whereby multipoint-to-point traffic from devices inside the
      LLN towards a central control point, as well as point-to-multipoint
      traffic from the central control point to the devices inside the LLN, is
      supported. Support for point-to-point traffic is also available.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Low power and Lossy Networks (LLNs) are made largely of constrained
      nodes (with limited processing power, memory, and sometimes energy when
      they are battery operated). These routers are interconnected by lossy
      links, typically supporting only low data rates, that are usually
      unstable with relatively low packet delivery rates. Another
      characteristic of such networks is that the traffic patterns are not
      simply unicast, but in many cases point-to-multipoint or
      multipoint-to-point. Furthermore such networks may potentially comprise
      up to thousands of nodes. These characteristics offer unique challenges
      to a routing solution: the IETF ROLL Working Group has defined
      application-specific routing requirements for a Low power and Lossy
      Network (LLN) routing protocol, specified in <xref
      target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
      target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
      target="RFC5673"></xref>, and <xref target="RFC5548"></xref>. This
      document specifies the IPv6 Routing Protocol for Low power and Lossy
      Networks (RPL).</t>

      <section title="Design Principles">
        <t>RPL was designed with the objective to meet the requirements
        spelled out in <xref
        target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
        target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
        target="RFC5673"></xref>, and <xref target="RFC5548"></xref>. Because
        those requirements are heterogeneous and sometimes incompatible in
        nature, the approach is first taken to design a protocol capable of
        supporting a core set of functionalities corresponding to the
        intersection of the requirements. As the RPL design evolves optional
        features may be added to address some application specific
        requirements. This is a key protocol design decision providing a
        granular approach in order to restrict the core of the protocol to a
        minimal set of functionalities, and to allow each implementation of
        the protocol to be optimized differently. All "MUST" application
        requirements that cannot be satisfied by RPL will be specifically
        listed in the Appendix A, accompanied by a justification.</t>

        <t>A network may run multiple instances of RPL concurrently. Each such
        instance may serve different and potentially antagonistic constraints
        or performance criteria. This document defines how a single instance
        operates.</t>

        <t>RPL is a generic protocol that is to be deployed by instantiating
        the generic operation described in this document with a specific
        objective function (OF) (which ties together metrics, constraints, and
        an optimization objective) to realize a desired objective in a given
        environment.</t>

        <t>A set of companion documents to this specification will provide
        further guidance in the form of applicability statements specifying a
        set of operating points appropriate to the Building Automation, Home
        Automation, Industrial, and Urban application scenarios.</t>
      </section>

      <section title="Expectations of Link Layer Type">
        <t>As RPL is a routing protocol, it of course does not rely on any
        particular features of a specific link layer technology. RPL should be
        able to operate over a variety of different link layers, including but
        not limited to low power wireless or PLC (Power Line Communication)
        technologies.</t>

        <t>Implementers may find <xref target="RFC3819">RFC 3819</xref> a
        useful reference when designing a link layer interface between RPL and
        a particular link layer technology.</t>
      </section>
    </section>

    <section anchor="Terminology" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>

      <t>This document requires readers to be familiar with the terminology
      described in `Terminology in Low power And Lossy Networks' <xref
      target="I-D.ietf-roll-terminology"></xref>.</t>

      <t><list hangIndent="6" style="hanging">
          <t hangText="DAG:">Directed Acyclic Graph. A directed graph having
          the property that all edges are oriented in such a way that no
          cycles exist. All edges are contained in paths oriented toward and
          terminating at one or more root nodes.</t>

          <t hangText="DAG Instance:">A DAG Instance is a set of possibly
          multiple Destination Oriented DAGs. A network may have more than one
          DAG Instance, and a RPL router can participate to multiple DAG
          instances. Each DAG Instance operates independently of other DAG
          Instances. This document describes operation within a single DAG
          instance.</t>

          <t hangText="InstanceID:">Unique identifier of a DAG Instance.</t>

          <t hangText="Destination Oriented DAG (DODAG):">A DAG rooted at a
          single destination, which is a node with no outgoing edges. The
          tuple (InstanceID, DAGID) uniquely identifies a Destination Oriented
          DAG (DODAG). In the RPL context, a router can can belong to at most
          one DODAG per DAG Instance.</t>

          <t hangText="DAGID:">The identifier of a DODAG root. The DAGID must
          be unique within the scope of a DAG Instance in the LLN.</t>

          <t hangText="DODAG Iteration:">A specific sequence number iteration
          of a DODAG.</t>

          <t hangText="DAGSequenceNumber:">A sequential counter that is
          incremented by the root to form a new Iteration of a DODAG. A DODAG
          Iteration is identified uniquely by the (InstanceID, DAGID,
          DAGSequenceNumber) tuple.</t>

          <t hangText="DAG parent:">A parent of a node within a DAG is one of
          the immediate successors of the node on a path towards the DAG
          root.</t>

          <t hangText="DAG sibling:">A sibling of a node within a DAG is
          defined in this specification to be any neighboring node which is
          located at the same rank within a DAG. Note that siblings defined in
          this manner do not necessarily share a common parent.</t>

          <t hangText="DAG root:">A DAG root is a node within the DAG that has
          no outgoing edges. Because the graph is acyclic, by definition all
          DAGs must have at least one DAG root and all paths terminate at a
          DAG root.</t>

          <t hangText="Sub-DAG">The sub-DAG of a node is the set of other
          nodes in the DAG that might use a path towards the DAG root that
          contains the node. Nodes in the sub-DAG of a node have a greater
          rank (although not all nodes of greater rank are in the
          sub-DAG).</t>

          <t hangText="Up:">Up refers to the direction from leaf nodes towards
          DODAG roots, following the orientation of the edges within the
          DODAG.</t>

          <t hangText="Down:">Down refers to the direction from DODAG roots
          towards leaf nodes, going against the orientation of the edges
          within the DODAG.</t>

          <t hangText="OCP:">Objective Code Point. The Objective Code Point is
          used to indicate which Objective Function is in use in a DODAG. The
          Objective Code Point is further described in <xref
          target="I-D.ietf-roll-routing-metrics"></xref>.</t>

          <t hangText="OF:">Objective Function. The Objective Function (OF)
          defines which routing metrics, optimization objectives, and related
          functions are in use in a DODAG. The Objective Function is further
          described in <xref
          target="I-D.ietf-roll-routing-metrics"></xref>.</t>

          <t hangText="Goal:">The Goal is a host or set of hosts that satisfy
          a particular application objective / OF. Whether or not a DODAG can
          provide connectivity to a goal is a property of the DODAG. For
          example, a goal might be a host serving as a data collection point,
          or a gateway providing connectivity to an external
          infrastructure.</t>

          <t hangText="Grounded:">A DAG is grounded when the root can reach
          the Goal of the objective function.</t>

          <t hangText="Floating:">A DAG is floating if is not Grounded. A
          floating DAG is not expected to reach the Goal defined for the
          OF.</t>
        </list></t>

      <t>As they form networks, LLN devices often mix the roles of `host' and
      `router' when compared to traditional IP networks. In this document,
      `host' refers to an LLN device that can generate but does not forward
      RPL traffic, `router' refers to an LLN device that can forward as well
      as generate RPL traffic, and `node' refers to any RPL device, either a
      host or a router.</t>
    </section>

    <section anchor="ProtocolModel" title="Protocol Model">
      <t>The aim of this section is to describe RPL in the spirit of <xref
      target="RFC4101"></xref>. Protocol details can be found in further
      sections.</t>

      <section title="Instances, DODAGs, and DODAG Iterations">
        <t>Each DAG instance constructs a routing topology optimized for a
        certain Objective Function (OF). A DAG instance may provide routes to
        certain destination prefixes. A single DAG instance contains one or
        more Destination Oriented DAG (DODAG) roots. These roots may operate
        independently, or may coordinate over a non-LLN backchannel.</t>

        <t>Each root has a unique identifier, the DAGID, such that nodes can
        identify the DODAG root.</t>

        <t>A DAG instance may comprise:</t>

        <t><list style="symbols">
            <t>a single DODAG with a single root <list>
                <t>For example, a DODAG optimized to minimize latency rooted
                at a single centralized lighting controller in a home
                automation application.</t>
              </list></t>

            <t>multiple uncoordinated DODAGs with independent roots (differing
            DAGIDs) <list>
                <t>For example, multiple data collection points in an urban
                data collection application that do not have an always-on
                backbone suitable to coordinate to form a single DODAG, and
                further use the formation of multiple DODAGs as a means to
                dynamically and autonomously partition the network.</t>
              </list></t>

            <t>a single DODAG with a single virtual root coordinating LLN
            sinks (with the same DAGID) over some non-LLN backbone<list>
                <t>For example, multiple border routers operating with a
                reliable backbone, e.g. in support of a 6LowPAN application,
                that are capable to act as logically equivalent sinks to the
                same DODAG.</t>
              </list></t>

            <t>a combination of one of the above as suited to some application
            scenario.</t>
          </list></t>

        <t>Traffic is bound to a specific DODAG Instance by a marking in the
        flow label of the IPv6 header. Traffic originating in support of a
        particular application may be tagged to follow an appropriate DAG
        instance, for example to follow paths optimized for low latency or low
        energy. The provisioning or automated discovery of a mapping between
        an InstanceID and a type or service of application traffic is beyond
        the scope of this specification.</t>

        <t>An example of a DAG Instance comprising a number of DODAGs is
        depicted in <xref target="figInstance"></xref>. A DODAG Iteration is
        depicted in <xref target="figDODAGIteration"></xref>.</t>

        <figure anchor="figInstance" title="DAG Instance">
          <artwork><![CDATA[
 
  +----------------------------------------------------------------+
  |                                                                |
  | +--------------+                                               |
  | |              |                                               |
  | |     (R1)     |            (R2)                   (Rn)        |
  | |     /  \     |            /| \                  / |  \       |
  | |    /    \    |           / |  \                /  |   \      |
  | |  (A)    (B)  |         (C) |  (D)     ...    (F) (G)  (H)    |
  | |  /|\     |\  |         /   |   |\             |   |    |     |
  | | : : :    : : |        :   (E)  : :            :   :    :     |
  | |              |            / \                                |
  | +--------------+           :   :                               |
  |      DODAG                                                     |
  |                                                                | 
  +----------------------------------------------------------------+
                             DAG Instance                           
]]></artwork>
        </figure>

        <figure anchor="figDODAGIteration" title="DODAG Iteration">
          <artwork><![CDATA[
                                                                     
         +----------------+                +----------------+        
         |                |                |                |        
         |      (R1)      |                |      (R1)      |        
         |      /  \      |                |      /         |        
         |     /    \     |                |     /          |        
         |   (A)    (B)   |         \      |   (A)          |        
         |   /|\     |\   |    ------\     |   /|\          |        
         |  : : (C)  : :  |           \    |  : : (C)       |        
         |                |           /    |        \       |        
         |                |    ------/     |         \      |        
         |                |         /      |         (B)    |        
         |                |                |          |\    |        
         |                |                |          : :   |        
         |                |                |                |        
         +----------------+                +----------------+        
             Sequence N                       Sequence N+1           
                                                                     
]]></artwork>
        </figure>
      </section>

      <section title="Traffic Flows">
        <section title="Multipoint-to-Point Traffic">
          <t>Multipoint-to-Point (MP2P) is a dominant traffic flow in many LLN
          applications (<xref
          target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
          target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
          target="RFC5673"></xref>, <xref target="RFC5548"></xref>). The
          destinations of MP2P flows are designated nodes that have some
          application significance, such as providing connectivity to the
          larger Internet or core private IP network. RPL supports MP2P
          traffic by allowing MP2P destinations to be reached via DODAG
          roots.</t>
        </section>

        <section title="Point-to-Multipoint Traffic">
          <t>Point-to-multipoint (P2MP) is a traffic pattern required by
          several LLN applications (<xref
          target="I-D.ietf-roll-building-routing-reqs"></xref>, <xref
          target="I-D.ietf-roll-home-routing-reqs"></xref>, <xref
          target="RFC5673"></xref>, <xref target="RFC5548"></xref>). RPL
          supports P2MP traffic by using a destination advertisement mechanism
          that provisions routes toward destination prefixes and away from
          roots. Destination advertisements can update routing tables as the
          underlying DODAG topology changes.</t>
        </section>

        <section title="Point-to-Point Traffic">
          <t>RPL DODAGs provide a basic structure for point-to-point (P2P)
          traffic. For a RPL network to support P2P traffic, a root must be
          able to route packets to a destination. Nodes within the network may
          also have routing tables to destinations. A packet flows towards a
          root until it reaches an ancestor that has a known route to the
          destination.</t>

          <t>RPL also supports the case where a P2P destination is a `one-hop'
          neighbor.</t>

          <t>RPL neither specifies nor precludes additional mechanisms for
          computing and installing more optimal routes to support arbitrary
          P2P traffic.</t>
        </section>
      </section>

      <section title="DODAG Construction">
        <t>RPL provisions routes up towards DODAG roots, forming a DODAG
        optimized according to the Objective Function (OF) in use. RPL nodes
        construct and maintain these DODAGs through exchange of DAG
        Information Object (DIO) messages. Undirected links between siblings
        are also identified during this process, which are used to provide
        additional diversity.</t>

        <section title="DAG Information Object (DIO)">
          <t>A DIO identifies the DAG Instance, the DAGID, the values used to
          compute the DAG Instance's objective function, and the present DODAG
          Sequence Number. It can also include additional routing and
          configuration information. The DIO includes a measure derived from
          the position of the node within the DODAG, the rank, which is used
          for nodes to determine their positions relative to each other and to
          inform loop avoidance/detection procedures. RPL exchanges DIO
          messages to establish and maintain routes.</t>

          <t>RPL adapts the rate at which nodes send DIO messages. When a
          DODAG is detected to be inconsistent or needs repair, RPL sends DIO
          messages more frequently. As the DODAG stabilizes, the DIO message
          rate tapers off, reducing the maintenance cost of a steady and
          well-working DODAG.</t>

          <t>This document defines an ICMPv6 Message Type RPL Control Message,
          which is capable of carrying a DIO.</t>
        </section>

        <section title="DAG Repair">
          <t>RPL supports global repair over the DODAG. A DODAG Root may
          increment the DODAG Sequence Number to institute a global repair,
          revising the DODAG and allowing nodes to choose an arbitrary new
          position within the new DODAG iteration.</t>

          <t>RPL may support mechanisms for local repair within the DODAG
          iteration. The DIO message will specify the necessary parameters as
          configured from the DODAG root. Local repair options include the
          allowing a node, upon detecting a loss of connectivity to a DODAG it
          is a member of, to:</t>

          <t><list style="symbols">
              <t>Poison its sub-DAG by advertising an effective rank of
              INFINITY, OR detach and form a floating DODAG in order to
              preserve inner connectivity within its sub-DAG.</t>

              <t>Move down the DODAG iteration in a limited manner, no further
              than a bound configured via the DIO so as not to count all the
              way to infinity. Such a move may be undertaken after waiting an
              appropriate poisoning interval, and should allow the node to
              restore connectivity to the DODAG Iteration if possible.</t>
            </list></t>
        </section>

        <section title="Grounded and Floating DODAGs">
          <t>DODAGs can be grounded or floating. A grounded DODAG offers
          connectivity to to a goal. A floating DODAG offers no such
          connectivity, and provides routes only to nodes within the DODAG.
          Floating DODAGs may be used, for example, to preserve inner
          connectivity during repair.</t>
        </section>

        <section title="Administrative Preference">
          <t>An implementation/deployment may specify that some DODAG roots
          should be used over others through an administrative preference.
          Administrative preference offers a way to control traffic and
          engineer DODAG formation in order to better support application
          requirements or needs.</t>
        </section>

        <section title="Objective Function (OF)">
          <t>The Objective Function (OF) implements the optimization
          objectives of route selection within the DAG Instance. The OF is
          identified by an Objective Code Point (OCP) within the DIO, and its
          specification also indicates the metrics and constraints in use. The
          OF also specifies the procedure used to compute rank within a DODAG
          iteration. Further details may be found in <xref
          target="I-D.ietf-roll-routing-metrics"></xref> and related companion
          specifications.</t>

          <t>By using defined OFs that are understood by all nodes in a
          particular implementation, and by referencing them in the DIO
          message, RPL nodes may work to build optimized LLN routes using a
          variety of application and implementation specific metrics and
          goals.</t>

          <t>In the case where a node is unable to encounter a suitable DAG
          Instance using a known Objective Function, it may be configured to
          join DAG Instance using and unknown Objective Function but only
          acting as a leaf node.</t>
        </section>

        <section title="Distributed Algorithm Operation">
          <t>A high level overview of the distributed algorithm which
          constructs the DODAG is as follows:</t>

          <t><list style="symbols">
              <t>Some nodes are configured to be DODAG roots, with associated
              DODAG configuration.</t>

              <t>Nodes advertise their presence, affiliation with a DODAG,
              routing cost, and related metrics by sending link-local
              multicast DIO messages.</t>

              <t>Nodes may adjust the rate at which DIO messages are sent in
              response to stability or detection of routing
              inconsistencies.</t>

              <t>Nodes listen for DIOs and use their information to join a new
              DODAG, or to maintain an existing DODAG, as according to the
              specified Objective Function and rank-based loop avoidance
              rules.</t>

              <t>The nodes provision routing table entries for the
              destinations specified by the DIO towards their parents in the
              DODAG iteration. Nodes may provision a parent as a default
              gateway.</t>

              <t>Nodes may identify siblings within the DODAG iteration to
              increase path diversity.</t>

              <t>Using both DIOs and possibly information in data packets, RPL
              nodes detect possible routing loops. When a RPL node detects a
              possible routing loop, it may adapt its DIO transmission rate to
              apply a local repair to the topology. This process and its
              limitations is discussed in greater detail in 3.4.</t>
            </list></t>
        </section>
      </section>

      <section title="Destination Advertisement">
        <t>As RPL constructs and maintains DODAGs with DIO messages to
        establish upward routes, it may use Destination Advertisement Object
        (DAO) messages to establish downward routes along the DODAG. DAO
        messages and support for downward routes are an optional feature for
        applications that require P2MP or P2P traffic. DIO messages advertise
        whether the destination advertisement mechanism is enabled.</t>

        <section title="Destination Advertisement Object (DAO)">
          <t>A Destination Advertisement Object (DAO) conveys destination
          information upwards along the DODAG so that a DODAG root (an other
          intermediate nodes) can provision downward routes. A DAO message
          includes prefix information to identify destinations, a capability
          to record routes in support of source routing, and information to
          determine the freshness of a particular advertisement.</t>

          <t>Nodes that are capable of maintaining routing state may aggregate
          routes from DAO messages that they receive before transmitting a DAO
          message. Nodes that are not capable to maintain routing state may
          attach a next-hop address to the Reverse Route Stack contained
          within the DAO message. The Reverse Route Stack is subsequently used
          to generate piecewise source routes over regions of the LLN that are
          incapable of storing downward routing state.</t>

          <t>A special case of the DAO message, termed a no-DAO, is used to
          clear downward routing state that has been provisioned through DAO
          operation.</t>

          <t>This document defines an ICMPv6 Message Type RPL Control Message,
          which is capable to carry the DAO.</t>

          <section title="`One-Hop' Neighbors">
            <t>In addition to sending DAOs toward DODAG roots, RPL nodes may
            occasionally emit a link-local multicast DAO message advertising
            available destination prefixes. This mechanism allow provisioning
            a trivial `one-hop' route to local neighbors.</t>
          </section>
        </section>
      </section>
    </section>

    <section anchor="ConstrainedLLNs"
             title="Routing Metrics and Constraints Used By RPL">
      <t>Routing metrics are used by routing protocols to compute the shortest
      paths. Interior Gateway Protocols (IGPs) such as IS-IS (<xref
      target="RFC5120"></xref>) and OSPF (<xref target="RFC4915"></xref>) use
      static link metrics. Such link metrics can simply reflect the bandwidth
      or can also be computed according to a polynomial function of several
      metrics defining different link characteristics; in all cases they are
      static metrics. Some routing protocols support more than one metric: in
      the vast majority of the cases, one metric is used per (sub)topology.
      Less often, a second metric may be used as a tie-breaker in the presence
      of Equal Cost Multiple Paths (ECMP). The optimization of multiple
      metrics is known as an NP complete problem and is sometimes supported by
      some centralized path computation engine.</t>

      <t>In contrast, LLNs do require the support of both static and dynamic
      metrics. Furthermore, both link and node metrics are required. In the
      case of RPL, it is virtually impossible to define one metric, or even a
      composite, that will satisfy all use cases.</t>

      <t>In addition, RPL supports constrained-based routing where constraints
      may be applied to link and nodes. If a link or a node does not satisfy a
      required constraint, it is `pruned' from the candidate list thus leading
      to a constrained shortest path.</t>

      <t>The set of supported link/node constraints and metrics is specified
      in <xref target="I-D.ietf-roll-routing-metrics"></xref>.</t>

      <t>The role of the Objective Function is to advertise routing metrics
      and constraints in addition to the objectives used to compute the
      (constrained) shortest path.</t>

      <t><list hangIndent="11" style="hanging">
          <t hangText="Example 1:">Shortest path: path offering the shortest
          end-to-end delay</t>

          <t hangText="Example 2:">Constrained shortest path: the path that
          does not traverse any battery-operated node and that optimizes the
          path reliability</t>
        </list></t>
    </section>

    <section title="Rank">
      <section title="Loop Avoidance">
        <t>RPL guarantees neither loop free path selection nor strong global
        convergence. In order to reduce control overhead, however, such as the
        cost of the count-to-infinity problem, RPL avoids creating loops when
        undergoing topology changes. Furthermore, RPL includes rank-based
        mechanisms for detecting loops when they do occur. RPL uses this loop
        detection to ensure that packets make forward progress within the
        DODAG iteration and trigger repairs when necessary.</t>

        <section title="Greediness and Rank-based Instabilities">
          <t>Once a node has joined a DODAG, RPL disallows certain behaviors,
          including greediness, in order to prevent resulting instabilities in
          the DODAG.</t>

          <t>If a node is allowed to be greedy and attempts to move deeper in
          the DODAG, beyond its most preferred parent, in order to increase
          the size of the parent set, then an instability can result. This is
          illustrated in <xref target="Greedy"></xref>.</t>

          <t>Suppose a node is willing to receive and process a DIO messages
          from a node in its own sub-DAG, and in general a node deeper than
          it. In such cases a chance exists to create a feedback loop, wherein
          two or more nodes continue to try and move in the DODAG in order to
          optimize against each other. In some cases this will result in an
          instability. It is for this reason that RPL limits the cases where a
          node may process DIO messages from deeper nodes to some forms of
          local repair. This approach creates an `event horizon', whereby a
          node cannot be influenced beyond some limit into an instability by
          the action of nodes that may be in its own sub-DAG.</t>

          <t>A further example of the consequences of greedy operation, and
          instability related to processing DIO messages from nodes of greater
          rank, may be found in <xref target="ExGreedyExample"></xref></t>
        </section>

        <section title="DODAG Loops">
          <t>A DODAG loop may occur when a node detaches from the DODAG and
          reattaches to a device in its prior sub-DAG. This may happen in
          particular when DIO messages are missed. Strict use of the DAG
          sequence number can eliminate this type of loop, but this type of
          loop may possibly be encountered when using some local repair
          mechanisms.</t>
        </section>

        <section title="DAO Loops">
          <t>A DAO loop may occur when the parent has a route installed upon
          receiving and processing a DAO message from a child, but the child
          has subsequently cleaned up the state. This loop happens when a
          no-DAO was missed until a heartbeat cleans up all states. RPL
          includes loop detection mechanisms that may mitigate the impact of
          DAO loops and trigger their repair.</t>

          <t>In the case where stateless DAO operation is used, i.e. source
          routing specifies the down routes, then DAO Loops should not occur
          on the stateless portions of the path.</t>
        </section>

        <section title="Sibling Loops">
          <t>Sibling loops could occur if a group of siblings kept choosing
          amongst themselves as successors such that a packet does not make
          forward progress. This specification limits the number of times that
          sibling forwarding may be used at a given rank to prevent sibling
          loops.</t>
        </section>
      </section>

      <section anchor="DAGRank" title="Rank Properties">
        <t>The rank of a node is a scalar representation of the location of
        that node within a DODAG iteration. The rank is used to avoid and
        detect loops, and as such must demonstrate certain properties. The
        exact calculation of the rank is left to the Objective Function, and
        may depend on parents, link metrics, and the node configuration and
        policies.</t>

        <t>The rank is not a cost metric, although its value can be derived
        from and influenced by metrics. The rank has properties of its own
        that are not necessarily that of all metrics: <list hangIndent="8"
            style="hanging">
            <t hangText="Type:">Rank is an abstract scalar. Some metrics are
            boolean (e.g. grounded), others are statistical and better
            expressed as a tuple like an expected value and a variance. Some
            OCPs use not one but a set of metrics bound by a piece of
            logic.</t>

            <t hangText="Function:">Rank is the expression of a relative
            position within a DODAG iteration with regard to neighbors and,
            not necessarily a good indication or a proper expression of a
            distance or a cost to the root.</t>

            <t hangText="Stability:">The stability of the rank determines that
            of the routing topology. Some dampening or filtering might be
            applied to keep the topology stable and the rank does not
            necessarily change as fast as some physical metrics would. A new
            iteration is a good opportunity to reconcile the discrepancies
            that might form over time between the metrics and the ranks.</t>

            <t hangText="Granularity:">Rank is coarse grained. A fine
            granularity would prevent the selection of siblings.</t>

            <t hangText="Properties:">Rank is strictly monotonic and can be
            used to validate a progression from or towards the root. A metric
            like bandwidth or jitter does not necessarily exhibit such
            property.</t>

            <t hangText="Abstract:">Rank does not have a physical unit, but
            rather a range of increment per hop that varies from 1 (best) to
            16 (worst), where the assignment of each value is to be determined
            by the implementation.</t>
          </list></t>

        <t>The rank value feeds back into the DAG parent selection according
        to the RPL loop-avoidance strategy. Once a parent has been added, and
        a rank value for the node within the DODAG has been advertised, the
        nodes further options with regard to DAG parent selection and movement
        within the DODAG are restricted in favor of loop avoidance.</t>

        <t>The computation of the DAG rank MUST be done in such a way so as to
        maintain the following properties for any nodes M and N that are
        neighbors in the LLN:</t>

        <t><list hangIndent="8" style="hanging">
            <t hangText="DAGRank(M) is less than DAGRank(N):">In this case, M
            is probably located in a more preferred position than N in the
            DODAG with respect to the metrics and optimizations defined by the
            objective code point. In any fashion, Node M may safely be a DAG
            parent for Node N without risk of creating a loop. Further, for a
            node N, all parents in the DAG parent set must be of rank less
            than self's DAGRank(N). In other words, the rank presented by a
            node N MUST be greater (deeper) than that presented by any of its
            parents.</t>

            <t hangText="DAGRank(M) equals DAGRank(N):">In this case M and N
            are located positions of relatively the same optimality within the
            DODAG. In some cases, Node M may be used as a successor by Node N,
            but with related chance of creating a loop that must be detected
            and broken by some other means.</t>

            <t hangText="DAGRank(M) is greater than DAGRank(N):">In this case,
            then node M is located in a less preferred position than N in the
            DODAG with respect to the metrics and optimizations defined by the
            objective code point. Further, Node (M) may in fact be in Node
            (N)'s sub-DAG. There is a higher risk to Node (N) selecting Node
            (M) as a DAG parent, as such a selection may create a loop.</t>
          </list></t>

        <t>As an example, the DAG rank could be computed in such a way so as
        to closely track ETX when the objective function is to minimize ETX,
        or latency when the objective function is to minimize latency, or in a
        more complicated way as appropriate to the objective code point being
        used within the DODAG.</t>
      </section>
    </section>

    <section anchor="SpecCore" title="RPL Protocol Specification">
      <section anchor="RPLMessages" title="RPL Messages">
        <section anchor="RPLControlMessage" title="ICMPv6 RPL Control Message">
          <t>This document defines the RPL Control Message, a new ICMPv6
          message. The RPL Control Message has the following general format,
          in accordance with <xref target="RFC4443"></xref>:</t>

          <t><figure anchor="ICMPFormat" title="RPL Control Message">
              <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Code      |          Checksum             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                         Message Body                          +
    |                                                               |
]]></artwork>
            </figure></t>

          <t>The RPL Control message is an ICMPv6 information message with a
          requested Type of 155.</t>

          <t>The Code will be used to identify RPL Control Messages as
          follows:</t>

          <t><list style="symbols">
              <t>0x01: DAG Information Solicitation (<xref
              target="DAGInformationSolicitation"></xref>)</t>

              <t>0x02: DAG Information Object (<xref
              target="DAGInformationObject"></xref>)</t>

              <t>0x04: Destination Advertisement Object (<xref
              target="DestinationAdvertisementObject"></xref>)</t>
            </list></t>
        </section>

        <section anchor="DAGInformationSolicitation"
                 title="DAG Information Solicitation (DIS)">
          <t>The DAG Information Solicitation (DIS) message may be used to
          solicit a DAG Information Object from a RPL node. Its use is
          analogous to that of a Router Solicitation; a node may use DIS to
          probe its neighborhood for nearby DAGs. The DAG Information
          Solicitation carries no additional message body.</t>
        </section>

        <section anchor="DAGInformationObject"
                 title="DAG Information Object (DIO)">
          <t>The DAG Information Object carries a number of metrics and other
          information that allows a node to discover a DAG Instance, select
          its DAG parents, and identify its siblings while employing loop
          avoidance strategies.</t>

          <section anchor="DIOBase" title="DIO Base">
            <t>The DIO Base is a container option, which is always present,
            and might contain a number of suboptions. The base option regroups
            the minimum information set that is mandatory in all cases.</t>

            <t><figure anchor="DIObase" title="DIO Base">
                <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |G|D|A|0|0| Prf |   Sequence    |  InstanceID   |    DAGRank    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                            DAGID                              |
    +                                                               +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   sub-option(s)...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
              </figure></t>

            <t><list hangIndent="6" style="hanging">
                <t hangText="Control Field:">The DAG Control Field is
                currently allocated as follows: <list hangIndent="6"
                    style="hanging">
                    <t hangText="Grounded (G):">The Grounded (G) flag is set
                    when the DODAG root is a Goal for the OF.</t>

                    <t hangText="Destination Advertisement Trigger (D):">The
                    Destination Advertisement Trigger (D) flag is set when the
                    DODAG root or another node in the successor chain decides
                    to trigger the sending of destination advertisements in
                    order to update routing state for the down direction along
                    the DODAG, as further detailed in <xref
                    target="DestinationAdvertisement"></xref>. Note that the
                    use and semantics of this flag are still under
                    investigation.</t>

                    <t hangText="Destination Advertisement Supported (A):">The
                    Destination Supported (A) bit is set when the DODAG root
                    is capable to support the collection of destination
                    advertisement related routing state and enables the
                    operation of the destination advertisement mechanism
                    within the DODAG.</t>

                    <t hangText="DAGPreference (Prf):">3-bit unsigned integer
                    set by the DODAG root to its preference and unchanged at
                    propagation. DAGPreference ranges from 0x00 (least
                    preferred) to 0x07 (most preferred). The default is 0
                    (least preferred). The DAG preference provides an
                    administrative mechanism to engineer the self-organization
                    of the LLN, for example indicating the most preferred LBR.
                    If a node has the option to join a more preferred DODAG
                    while still meeting other optimization objectives, then
                    the node will generally seek to join the more preferred
                    DODAG as determined by the OF.</t>
                  </list></t>

                <t>Unassigned bits of the Control Field are considered as
                reserved. They MUST be set to zero on transmission and MUST be
                ignored on receipt.</t>

                <t hangText="Sequence Number:">8-bit unsigned integer set by
                the DODAG root, incremented according to a policy provisioned
                at the DODAG root, and propagated with no change down the
                DODAG. Each increment SHOULD have a value of 1 and may cause a
                wrap back to zero.</t>

                <t hangText="InstanceID:">8-bit field indicating the topology
                instance associated with the DODAG, as provisioned at the
                DODAG root.</t>

                <t hangText="DAGRank:">8-bit unsigned integer indicating the
                DAG rank of the node sending the DIO message. The DAGRank of
                the DODAG root is ROOT_RANK. DAGRank is further described in
                <xref target="DAGDiscovery"></xref>.</t>

                <t hangText="DAGID:">128-bit unsigned integer which uniquely
                identify a DODAG. This value is set by the DODAG root. The
                global IPv6 address of the DODAG root can be used. the DAGID
                MUST be unique per DAG Instance within the scope of the
                LLN.</t>
              </list></t>

            <t>The following values MUST NOT change during the propagation of
            DIO messages down the DAG:<?rfc subcompact="yes"?><list>
                <t>Grounded (G)</t>

                <t>Destination Advertisement Supported (A)</t>

                <t>DAGPreference (Prf)</t>

                <t>Sequence</t>

                <t>InstanceID</t>

                <t>DAGID</t>
              </list><?rfc subcompact="no"?>All other fields of the DIO
            message may be updated at each hop of the propagation.</t>

            <section title="DIO Suboptions">
              <t>In addition to the minimum options presented in the base
              option, several suboptions are defined for the DIO message:</t>

              <section title="Format">
                <t><figure anchor="DIOsub"
                    title="DIO Suboption Generic Format">
                    <artwork><![CDATA[
     0                   1                   2      
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
    |  Subopt. Type |         Subopt Length         | Subopt Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
]]></artwork>
                  </figure></t>

                <t><list hangIndent="6" style="hanging">
                    <t hangText="Suboption Type:">8-bit identifier of the type
                    of suboption. When processing a DIO message containing a
                    suboption for which the Suboption Type value is not
                    recognized by the receiver, the receiver MUST silently
                    ignore the unrecognized option, continue to process the
                    following suboption, correctly handling any remaining
                    options in the message.</t>

                    <t hangText="Suboption Length:">16-bit unsigned integer,
                    representing the length in octets of the suboption, not
                    including the suboption Type and Length fields.</t>

                    <t hangText="Suboption Data:">A variable length field that
                    contains data specific to the option.</t>
                  </list></t>

                <t>The following subsections specify the DIO message
                suboptions which are currently defined for use in the DAG
                Information Object.</t>

                <t>Implementations MUST silently ignore any DIO message
                suboptions options that they do not understand.</t>

                <t>DIO message suboptions may have alignment requirements.
                Following the convention in IPv6, these options are aligned in
                a packet such that multi-octet values within the Option Data
                field of each option fall on natural boundaries (i.e., fields
                of width n octets are placed at an integer multiple of n
                octets from the start of the header, for n = 1, 2, 4, or
                8).</t>
              </section>

              <section title="Pad1">
                <t>The Pad1 suboption does not have any alignment
                requirements. Its format is as follows:</t>

                <t><figure anchor="DIOsubPad1" title="Pad 1">
                    <artwork><![CDATA[
     0
     0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+
    |   Type = 0    |
    +-+-+-+-+-+-+-+-+
]]></artwork>
                  </figure></t>

                <t>NOTE! the format of the Pad1 option is a special case - it
                has neither Option Length nor Option Data fields.</t>

                <t>The Pad1 option is used to insert one or two octets of
                padding in the DIO message to enable suboptions alignment. If
                more than two octets of padding is required, the PadN option,
                described next, should be used rather than multiple Pad1
                options.</t>
              </section>

              <section title="PadN">
                <t>The PadN option does not have any alignment requirements.
                Its format is as follows:</t>

                <t><figure anchor="DIOsubPadN" title="Pad N">
                    <artwork><![CDATA[
     0                   1                   2      
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
    |   Type = 1    |         Subopt Length         | Subopt Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
]]></artwork>
                  </figure></t>

                <t>The PadN option is used to insert three or more octets of
                padding in the DIO message to enable suboptions alignment. For
                N (N &gt; 2) octets of padding, the Option Length field
                contains the value N-3, and the Option Data consists of N-3
                zero-valued octets. PadN Option data MUST be ignored by the
                receiver.</t>
              </section>

              <section title="DAG Metric Container">
                <t>The DAG Metric Container suboption may be aligned as
                necessary to support its contents. Its format is as
                follows:</t>

                <t><figure anchor="DIOsubLLNMetric"
                    title="DAG Metric Container">
                    <artwork><![CDATA[
     0                   1                   2      
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
    |   Type = 2    |       Container Length        | DAG Metric Data
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
]]></artwork>
                  </figure></t>

                <t>The DAG Metric Container is used to report aggregated path
                metrics along the DODAG. The DAG Metric Container may contain
                a number of discrete node, link, and aggregate path metrics as
                chosen by the implementer. The Container Length field contains
                the length in octets of the DAG Metric Data. The order,
                content, and coding of the DAG Metric Container data is as
                specified in <xref
                target="I-D.ietf-roll-routing-metrics"></xref>.</t>

                <t>The DAG Metric Container MUST include the value for the DAG
                Objective Code Point.</t>

                <t>The processing and propagation of the DAG Metric Container
                is governed by implementation specific policy functions.</t>
              </section>

              <section title="Destination Prefix">
                <t>The Destination Prefix suboption does not have any
                alignment requirements. Its format is as follows:</t>

                <t><figure anchor="DIOsubDestinationPrefix"
                    title="DAG Destination Prefix">
                    <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 3    |            Length             |Resvd|Prf|Resvd|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        Prefix Lifetime                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Prefix Length |                                               |
    +-+-+-+-+-+-+-+-+                                               |
    |             Destination Prefix (Variable Length)              |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
                  </figure></t>

                <t>The Destination Prefix suboption is used when the DODAG
                root, or another node located upwards along the DODAG on the
                path to the DODAG root, needs to indicate that it offers
                connectivity to destination prefixes other than the default.
                This may be useful in cases where more than one LBR is
                operating within the LLN and offering connectivity to
                different administrative domains, e.g. a home network and a
                utility network. In such cases, upon observing the Destination
                Prefixes offered by a particular DODAG, a node MAY decide to
                join multiple DODAGs in support of a particular
                application.</t>

                <t>The Length is coded as the length of the suboption in
                octets, excluding the Type and Length fields.</t>

                <t>Prf is the Route Preference as in <xref
                target="RFC4191"></xref>. The reserved fields MUST be set to
                zero on transmission and MUST be ignored on receipt.</t>

                <t>The Prefix Lifetime is a 32-bit unsigned integer
                representing the length of time in seconds (relative to the
                time the packet is sent) that the Destination Prefix is valid
                for route determination. The lifetime is initially set by the
                node that owns the prefix and denotes the valid lifetime for
                that prefix (similar to AdvValidLifetime <xref
                target="RFC4861"></xref>). The value might be reduced by the
                originator and/or en-route nodes that will not provide
                connectivity for the whole valid lifetime. A value of all one
                bits (0xFFFFFFFF) represents infinity. A value of all zero
                bits (0x00000000) indicates a loss of reachability.</t>

                <t>The Prefix Length is an 8-bit unsigned integer that
                indicates the number of leading bits in the destination
                prefix.</t>

                <t>The Destination Prefix contains Prefix Length significant
                bits of the destination prefix. The remaining bits of the
                Destination Prefix, as required to complete the trailing
                octet, are set to 0.</t>

                <t>In the event that a DIO message may need to specify
                connectivity to more than one destination, the Destination
                Prefix suboption may be repeated.</t>
              </section>

              <section title="DAG Configuration">
                <t>The DAG Configuration suboption does not have any alignment
                requirements. Its format is as follows:</t>

                <t><figure anchor="DIOsubDAGConfig" title="DAG Configuration">
                    <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type = 4    |            Length             | DIOIntDoubl.  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  DIOIntMin.   |   DIORedun.   |  MaxRankInc   |                
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                
]]></artwork>
                  </figure></t>

                <t>The DAG Configuration suboption is used to distribute
                configuration information for DAG Operation through the DODAG.
                The information communicated in this suboption is generally
                static and unchanging within the DODAG, therefore it is not
                necessary to include in every DIO. This suboption MAY be
                included occasionally by the DODAG Root, and MUST be included
                in response to a unicast request, e.g. a DAG Information
                Solicitation (DIS) message.</t>

                <t>The Length is coded as 5.</t>

                <t>DIOIntervalDoublings is an 8-bit unsigned integer,
                configured on the DODAG root and used to configure the trickle
                timer governing when DIO message should be sent within the
                DODAG. DIOIntervalDoublings is the number of times that the
                DIOIntervalMin is allowed to be doubled during the trickle
                timer operation.</t>

                <t>DIOIntervalMin is an 8-bit unsigned integer, configured on
                the DODAG root and used to configure the trickle timer
                governing when DIO message should be sent within the DODAG.
                The minimum configured interval for the DIO trickle timer in
                units of ms is 2^DIOIntervalMin. For example, a DIOIntervalMin
                value of 16ms is expressed as 4.</t>

                <t>DIORedundancyConstant is an 8-bit unsigned integer used to
                configure suppression of DIO transmissions.
                DIORedundancyConstant is the minimum number of relevant
                incoming DIOs required to suppress a DIO transmission. If the
                value is 0xFF then the suppression mechanism is disabled.</t>

                <t>MaxRankInc, 8-bit unsigned integer, is the
                DAGMaxRankIncrease. This is the allowable increase in rank in
                support of local repair. If DAGMaxRankIncrease is 0 then this
                mechanism is disabled.</t>
              </section>
            </section>
          </section>
        </section>

        <section anchor="DestinationAdvertisementObject"
                 title="Destination Advertisement Object (DAO)">
          <t>The Destination Advertisement Object (DAO) is used to propagate
          destination information upwards along the DODAG. The RPL use of the
          DAO allows the nodes in the DODAG to provision routing state for
          nodes contained in the sub-DAG in support of traffic flowing down
          along the DODAG.</t>

          <t><figure anchor="DAObject"
              title="The Destination Advertisement Object (DAO)">
              <artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |         DAO Sequence          |  InstanceID   |   DAO Rank    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          DAO Lifetime                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           Route Tag                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | Prefix Length |    RRCount    |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
    |                   Prefix (Variable Length)                    |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Reverse Route Stack (Variable Length)             |
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
            </figure></t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="DAO Sequence:">Incremented by the node that owns
              the prefix for each new DAO message for that prefix.</t>

              <t hangText="InstanceID:">8-bit field indicating the topology
              instance associated with the DODAG, as learned from the DIO.</t>

              <t hangText="DAO Rank:">Set by the node that owns the prefix and
              first issues the DAO message to its rank.</t>

              <t hangText="DAO Lifetime:">32-bit unsigned integer. The length
              of time in seconds (relative to the time the packet is sent)
              that the prefix is valid for route determination. A value of all
              one bits (0xFFFFFFFF) represents infinity. A value of all zero
              bits (0x00000000) indicates a loss of reachability.</t>

              <t hangText="Route Tag:">32-bit unsigned integer. The Route Tag
              may be used to give a priority to prefixes that should be
              stored. This may be useful in cases where intermediate nodes are
              capable of storing a limited amount of routing state. The
              further specification of this field and its use is under
              investigation.</t>

              <t hangText="Prefix Length:">8-bit unsigned integer. Number of
              valid leading bits in the IPv6 Prefix.</t>

              <t hangText="RRCount:">8-bit unsigned integer. This counter is
              used to count the number of entries in the Reverse Route Stack.
              A value of `0' indicates that no Reverse Route Stack is
              present.</t>

              <t hangText="Prefix:">Variable-length field containing an IPv6
              address or a prefix of an IPv6 address. The Prefix Length field
              contains the number of valid leading bits in the prefix. The
              bits in the prefix after the prefix length (if any) are reserved
              and MUST be set to zero on transmission and MUST be ignored on
              receipt.</t>

              <t hangText="Reverse Route Stack:">Variable-length field
              containing a sequence of RRCount (possibly compressed) IPv6
              addresses. A node that adds on to the Reverse Route Stack will
              append to the list and increment the RRCount.</t>
            </list></t>
        </section>
      </section>

      <section anchor="ProtocolElements" title="Protocol Elements">
        <section title="Topological Elements">
          <t>RPL uses four identifiers to track and control the routing
          topology</t>

          <t><list style="symbols">
              <t>The first is an InstanceID. An InstanceID defines what OF a
              DAG uses and may also indicate what destinations are offered. A
              network may have multiple InstanceIDs, each of which defines an
              independent DAG optimized for a different OF and/or application.
              The DAG defined by an InstanceID is called a DAG Instance.</t>

              <t>The second is a DAGID. The scope of a DAGID is a DAG
              Instance. A combination of InstanceID and DAGID defines a DODAG.
              A DAG Instance may have multiple DODAGs.</t>

              <t>The third value is a DAG Sequence Number. The scope of a DAG
              Sequence Number is a DODAG. A DODAG is sometimes reconstructed
              from the root, by incrementing the DAGSequenceNumber. A
              combination of InstanceID, DAGID, and DAG Sequence Number
              defines a DODAG Iteration.</t>

              <t>The fourth value is rank. The scope of rank is a DODAG
              Iteration. Rank establishes a partial order over a DODAG
              Iteration, defining individual node positions.</t>
            </list></t>
        </section>

        <section title="Neighbors, Parents, and Siblings">
          <t><list style="numbers">
              <t>A node that is not a DODAG root MAY maintain multiple DAG
              parents for a single DAG Instance.</t>

              <t>The set of DAG parents MUST be a conceptual subset of the set
              of candidate neighbors. (This does not dictate implementation,
              e.g., to use a certain data structure).</t>

              <t>If Neighbor Unreachability Detection (NUD), or an equivalent
              mechanism, determines that a neighbor is no longer reachable,
              then a RPL node MUST NOT consider this node in the neighbor set
              when calculating and advertising routes until the node
              determines it is reachable again.</t>

              <t>Routes via that unreachable neighbor MUST be eliminated from
              the routing table, and the node SHOULD poison using no-DAO all
              DAO routes that it has advertised via DAO and that it can reach
              only via that neighbor.</t>
            </list></t>

          <t>A node's neighbor set is an unconstrained subset of the nodes
          that it can reach with a link-local multicast.</t>

          <t>The OF guides in the selection and maintains a number of
          neighbors to interact with, which neighbors being qualified as
          statistically stable and presenting adequate properties as per the
          the OF logic, for instance following mechanisms discussed in <xref
          target="I-D.ietf-roll-routing-metrics"></xref>. Those neighbors are
          referred to as candidate neighbors.</t>

          <t>Candidate neighbors may take the role of Parent or Siblings, in
          part as determined by rank.</t>

          <t>For the purpose of inheriting metrics and computing rank, the OF
          might select one preferred parent. In that case, the rank of this
          node is computed as the rank of the preferred parent plus a rank
          increment as determined by the OF.</t>
        </section>

        <section title="DODAG Information">
          <t>For each DODAG that a node is, or may become, a member of, the
          implementation should conceptually keep track of the following
          information for each DODAG. The data structures described in this
          section are intended to illustrate a possible implementation to aid
          in the description of the protocol, but are not intended to be
          normative.</t>

          <t><list style="symbols">
              <t>InstanceID</t>

              <t>DAGID</t>

              <t>DAGSequenceNumber</t>

              <t>DAG Metric Container, including DAGObjectiveCodePoint</t>

              <t>A set of Destination Prefixes offered upwards along the
              DODAG</t>

              <t>A set of DAG parents</t>

              <t>A set of DAG siblings</t>

              <t>A timer to govern the sending of DIO messages</t>
            </list></t>

          <t>When the DAG parent set is depleted on a node that is not a root,
          (i.e. the last parent is removed), then the DAG information should
          not be suppressed until after the expiration of an
          implementation-specific local timer in order to observe that the
          DAGSequenceNumber has incremented should any new parents appear for
          the DODAG.</t>

          <section title="DAG Parents/Siblings Structure">
            <t>When the DODAG is self-rooted, the set of DAG parents is
            empty.</t>

            <t>For each node in a DAG parent/sibling set, the implementation
            should conceptually keep track of:</t>

            <t><list style="symbols">
                <t>a reference to the neighboring device which is the DAG
                parent/sibling</t>

                <t>a record of most recent information taken from the DAG
                Information Object last processed in the case where the
                neighboring device is a DAG parent</t>
              </list></t>

            <t>DAG parents may be ordered, according to the OF. When ordering
            DAG parents, in consultation with the OF, the most preferred DAG
            parent may be identified. All current DAG parents must have a rank
            less than self. All current DAG siblings must have a rank equal to
            self.</t>

            <t>When nodes are added to or removed from the DAG parent/sibling
            sets the most preferred DAG parent may have changed. The role of
            all the nodes in the list should be reevaluated. In particular,
            any nodes having a rank greater than self after such a change must
            be evicted from the set.</t>
          </section>
        </section>
      </section>

      <section anchor="DAGDiscovery" title="DAG Discovery and Maintenance">
        <t>DAG discovery allows a node to join a DODAG rooted at a DODAG root
        by discovering neighbors that are members of the DODAG, and
        identifying a set of parents. DAG discovery also identifies siblings,
        which may be used later to provide additional path diversity towards
        the DODAG root.</t>

        <t>DODAG discovery may avoid loops by constraining how and when nodes
        can increase their rank, and by statistically poisoning the nodes that
        present the highest risk.</t>

        <t>DAG discovery enables nodes to implement different policies for
        selecting their DAG parents in the DODAG by using implementation
        specific policy functions. DAG discovery specifies a set of rules to
        be followed by all implementations to enable interoperation.</t>

        <section anchor="DAGDiscoveryRules" title="DAG Discovery Rules">
          <t>The following rules define the RPL DAG Discovery procedures:</t>

          <section anchor="DAGDiscoveryRulesSeq" title="DODAG Iteration">
            <t><list style="numbers">
                <t>An InstanceID SHOULD be administratively provisioned on a
                DODAG root that is significant RPL objective. The InstanceID
                MUST be unique to that purpose across the scope of the
                LLN.</t>

                <t>A DAGID MUST be unique within the scope of the InstanceID.
                It MAY be derived from the IPv6 address of the DODAG root.</t>

                <t>A node MAY belong to multiple DAG instances. The related
                details of operation are outside the scope of this
                specification.</t>

                <t>DODAG roots MAY increment the DAGSequenceNumber that they
                advertise.</t>

                <t>When a DODAG root increments its DAGSequenceNumber, it MUST
                follow the conventions of Serial Number Arithmetic as
                described in <xref target="RFC1982"></xref>.</t>

                <t>The tuple (InstanceID, DAGID, DAGSequenceNumber) uniquely
                defines a DODAG Iteration. All of a node's parents within a
                DODAG MUST belong to the same DODAG iteration, as conveyed by
                the last heard DIO from each parent.</t>

                <t>A node MUST NOT propagate DIOs for a DODAG Iteration unless
                it is the DODAG root of the DODAG iteration or has selected
                DODAG parents in that DODAG iteration.</t>

                <t>A node acting as a leaf SHOULD NOT propagate DIOs for a
                DODAG Iteration.</t>

                <t>A node MUST belong at most to one DODAG Iteration per
                InstanceID.</t>

                <t>Within a given DODAG, a node that is a not a root MUST NOT
                advertise a DAGSequenceNumber higher than the highest
                DAGSequenceNumber it has heard.</t>
              </list></t>

            <t>Within a particular implementation, a DODAG root may increment
            the DAGSequenceNumber periodically, at a rate that depends on the
            deployment. In other implementations loop detection may be
            considered sufficient to solve the routing issues, and the DODAG
            root may increment the DAGSequenceNumber only upon administrative
            intervention. Another possibility is that nodes within the LLN
            have some means to signal the DODAG root in order to request an
            on-demand increment when routing issues are detected.</t>

            <t>As the DAGSequenceNumber is incremented, a new DODAG Iteration
            spreads outward from the DODAG root. Thus a parent that advertises
            the new DAGSequenceNumber can not possibly belong to the sub-DAG
            of a node that still advertises an older DAGSequenceNumber. A node
            may safely add such a parent, without risk of forming a loop,
            without regard to its relative rank in the prior DODAG Iteration.
            This is equivalent to jumping to a different DODAG.</t>

            <t>As a node transitions to new DODAG Iterations as a consequence
            of following these rules, the node will be unable to advertise the
            previous DODAG Iteration (prior DAGSequenceNumber) once it has
            committed to advertising the new DODAG Iteration.</t>

            <t>During a transition to a new DODAG Iteration, a node may decide
            to forward packets via 'future parents' that belong to the same
            DODAG (same InstanceID and DAGID), but are observed to advertise a
            more recent (incremented) DAGSequenceNumber.</t>
          </section>

          <section anchor="DAGDiscoveryRulesRoot" title="DODAG Roots">
            <t><list style="numbers">
                <t>A DODAG root that does not have connectivity to a network
                outside of the LLN MUST NOT set the Grounded bit.</t>

                <t>A DODAG root MUST advertise a rank of ROOT_RANK.</t>

                <t>A node that does not have any DODAG parent MAY become the
                DODAG root of a floating DODAG. It MAY also set its
                DAGPreference such that it is less preferred. This behavior
                may be a desired alternate to poisoning.</t>
              </list></t>

            <t>An LLN node that is a Goal for the Objective Function is the
            root of its own grounded DODAG, at rank ROOT_RANK.</t>

            <t>In a deployment that uses a backbone link to federate a number
            of LLN roots, it is possible to run RPL over the backbone and use
            one router as a backbone root. The backbone root is the virtual
            root of the DODAG and exposes a rank of BASE_RANK over the
            backbone. All the LLN roots that are parented to that backbone
            root, including the backbone root if it also serves as LLN root,
            expose a rank of ROOT_RANK over the LLN and are part of the same
            DODAG, coordinated with the virtual root over the backbone.</t>
          </section>

          <section anchor="DAGDiscoveryRulesMove"
                   title="Rank and Movement within a DODAG Iteration">
            <t><list style="numbers">
                <t>A node MUST NOT advertise a rank less than or equal to any
                member of its parent set within the DODAG Iteration.</t>

                <t>A node MAY advertise a rank lower than its prior
                advertisement within the DODAG Iteration. (This corresponds to
                a node moving up within the DODAG Iteration).</t>

                <t>Let L be the lowest rank within a DODAG iteration that a
                given node has advertised. Within a DODAG Iteration, that node
                MUST NOT advertise an effective rank deeper than L +
                DAGMaxRankIncrease. INFINITE_RANK is an exception to this
                rule: a node MAY advertise an INFINITE_RANK at any time. (This
                corresponds to a limited rank increase for the purpose of
                local repair within the DODAG Iteration.)</t>

                <t>A node MAY, at any time, choose to join a different DODAG
                within a DAG Instance. Such a join has no rank restrictions,
                unless that different DODAG is a DODAG Iteration that the node
                has been a prior member of, in which case the rule of the
                previous bullet (3) must be observed. Until a node transmits a
                DIO indicating its new DODAG membership, it MUST forward
                packets along the previous DODAG.</t>

                <t>A node MAY, at any time after hearing the next
                DAGSequenceNumber Iteration advertised from suitable parents,
                choose to migrate up to the next DODAG Iteration within the
                DODAG.</t>
              </list></t>

            <t>Conceptually, an implementation is maintaining a parent set
            within the DODAG Iteration. Movement entails changes to the parent
            set. Moving up does not present the risk to create a loop but
            moving down might, so that operation is subject to additional
            constraints.</t>

            <t>When a node migrates into the next DODAG Iteration, the parent
            and sibling sets need to be rebuilt for the new iteration. An
            implementation could defer to migrate until for some reasonable
            time to see if some other neighbors with potentially better
            metrics but higher rank announce themselves. Similarly, when a
            node jumps into a new DODAG it needs to construct new
            parent/sibling sets for the new DODAG.</t>

            <t>When a node moves to improve its position, it must conceptually
            abandon all parents and siblings with a rank larger than itself.
            As a consequence of the movement it may also add new siblings.
            Such a movement may occur at any time to decrease the rank, as per
            the calculation indicated by the OF. Maintenance of the parent and
            sibling sets occurs as the rank of candidate neighbors is observed
            as reported in their DIOs.</t>

            <t>If a node needs to move down a DODAG that it is attached to,
            causing the DAG rank to increase, then it MAY poison its routes
            and delay before moving as described in <xref
            target="DAGDiscoveryRulesPoison"></xref>.</t>

            <!-- TBD turn this into an implementation note?
                <t>If a node has selected a new set of DAG parents but has not
                jumped yet (because it is waiting for DAG Hop timer to
                elapse), the node is UNSTABLE and MUST NOT send DIOs for that
                DAG.</t>
                -->
          </section>

          <section anchor="DAGDiscoveryRulesPoison"
                   title="Poisoning a Broken Path">
            <t><list style="numbers">
                <t>A node MAY poison, in order to avoid being used as an
                ancestor by the nodes in its sub-DAG, by advertising an
                effective rank of INFINITE_RANK and resetting the associated
                DIO trickle timer to cause the INFINITE_RANK to be announced
                promptly.</t>

                <t>The node MAY advertise an effective rank of INFINITE_RANK
                for an arbitrary number of DIO timer events before announcing
                a new rank.</t>

                <t>As per <xref target="DAGDiscoveryRulesMove"></xref>, the
                node MUST advertise INFINITE_RANK within the DODAG iteration
                if its revised rank would exceed the maximum DAG rank
                increase.</t>
              </list></t>

            <t>An implementation may choose to employ this poisoning mechanism
            when a node that loses all of its current parents, i.e. the set of
            DAG parents becomes depleted, and it can not jump onto an
            alternate DODAG An alternate mechanism is to form a floating
            DODAG.</t>

            <t>The motivation for delaying announcement of the revised route
            through multiple DIO events is to (i) increase tolerance to DIO
            loss, (ii) allow time for the poisoning action to propagate, and
            (iii) to develop an accurate assessment of its new rank. Such
            gains are obtained at the expense of potentially increasing the
            delay before lower portions of the network are able to
            re-establish up routes. Path redundancy in the DAG reduces the
            significance of either effect, since children with alternate
            parents should be able to utilize those alternates and retain rank
            while the detached parent re-establishes its rank.</t>

            <t>Although an implementation may advertise INFINITE_RANK for the
            purposes of poisoning, it is not expected to be equivalent to
            setting the rank to INFINITE_RANK, and an implementation would
            likely retain its rank value prior to the poisoning in some form,
            for purpose of maintaining its effective position within (L +
            DAGMaxRankIncrease).</t>
          </section>

          <section anchor="DAGDiscoveryRulesdetach" title="Detaching">
            <t><list style="numbers">
                <t>A node that does not have a solution to stay connected to a
                DODAG within a given iteration MAY detach from its current
                DODAG iteration. A node that detaches becomes root of its own
                floating DODAG and SHOULD immediately advertise its new
                situation in a DIO as an alternate to poisoning.</t>
              </list></t>
          </section>

          <section anchor="DAGDiscoveryRulesfollow" title="Following a Parent">
            <t><list style="numbers">
                <t>If a node receives a DIO from one of its parents indicating
                that the parent has left the DODAG, it SHOULD stay in its
                current DODAG through an alternate DAG parent if that is
                possible. It MAY follow that parent.</t>
              </list></t>

            <t>A DAG parent may have moved, migrated forward into the next
            DODAG Iteration, or jumped to a different DODAG. A node should
            give some preference to remaining in the current DODAG if
            possible, but ought to follow the parent if there are no other
            options.</t>
          </section>
        </section>

        <section title="DIO Message Communication">
          <t>When an DIO message is received from a source device named SRC,
          the receiving node must first determine whether or not the DIO
          message should be accepted for further processing, and subsequently
          present the DIO message for further processing if eligible.</t>

          <t>
            <list style="numbers">
              <t>If the DIO message is malformed, then the DIO message is not
              eligible for further processing and is silently discarded. A RPL
              implementation MAY log the reception of a malformed DIO
              message.</t>

              <t>If SRC is a member of the candidate neighbor set, then the
              DIO is eligible for further processing.</t>
            </list>
          </t>

          <section title="DIO Message Processing">
            <t>
              <list>
                <t>If the node has sent an DIO message within the risk window
                as described in <xref target="DAGCollision" /> then a
                collision has occurred; do not process the DIO message any
                further.</t>

                <t>Process the DIO message as per the rules in <xref
                target="DAGDiscovery" /></t>
              </list>
            </t>
          </section>

          <t>As DIO messages are received from candidate neighbors, the
          neighbors may be promoted to DAG parents by following the rules of
          DAG discovery as described in <xref target="DAGDiscovery" />. When a
          node places a neighbor into the DAG Parent set, the node becomes
          attached to the DODAG through the new parent node.</t>

          <t>In the DAG discovery implementation, the most preferred parent
          should be used to restrict which other nodes may become DAG parents.
          Some nodes in the DAG parent set may be of a rank less than or equal
          to the most preferred DAG parent. (This case may occur, for example,
          if an energy constrained device is at a lesser rank but should be
          avoided as per an optimization objective, resulting in a more
          preferred parent at a greater rank).</t>
        </section>

        <section title="DIO Transmission">
          <t>Each node maintains a timer that governs when to multicast DIO
          messages. This timer is a trickle timer, as detailed in <xref
          target="TrickleImplementation"></xref>. The DIO Configuration Option
          includes the configuration of a DAG Instance's trickle timer.</t>

          <t><list style="symbols">
              <t>When a node detects or causes an inconsistency, it MUST reset
              the interval of the trickle timer to a minimum value.</t>

              <t>When a node migrates to a new DODAG Iteration it MUST reset
              the trickle timer to its minimum value</t>

              <t>When a node detects an inconsistency when forwarding a
              packet, as detailed in <xref target="loopdetect"></xref>, the
              node MUST reset the trickle timer to its minimum value.</t>

              <t>When a node receives a multicast DIS message, it MUST reset
              the trickle timer to the minimum value.</t>

              <t>When a node receives a unicast DIS message, it MUST unicast a
              DIO message in response, and include the DAG Configuration
              Object. In this case the node SHOULD NOT reset the trickle
              timer.</t>

              <t>If a node is not a member of a DODAG, it MUST suppress
              transmitting DIO messages.</t>

              <t>When a node is initialized, it MAY be configured to remain
              silent and not multicast any DIO messages until it has
              encountered and joined a DODAG (perhaps initially probing for a
              nearby DODAG with an DIS message). Alternately, it may choose to
              root its own floating DODAG and begin multicasting DIO messages
              using a default trickle configuration. The second case may be
              advantageous if it is desired for independent nodes to begin
              aggregating into scattered floating DODAGs in the absence of a
              grounded node, for example in support of LLN installation and
              commissioning.</t>
            </list></t>

          <!--
          <t>Note that if multiple DAG roots are participating in the same
          DAG, i.e. offering DIO messages with the same DAGID, then they must
          coordinate with each other to ensure that their DIO messages are
          consistent when they emit DIO messages. In particular the Sequence
          number must be identical from each DAG root, regardless of which of
          the multiple DAG roots issues the DIO message, and changes to the
          Sequence number should be issued at the same time. The specific
          mechanism of this coordination, e.g. along a non-LLN network between
          DAG roots, is beyond the scope of this specification.</t>
          -->
        </section>

        <section anchor="TrickleImplementation"
                 title="Trickle Timer for DIO Transmission">
          <t>RPL treats the construction of a DODAG as a consistency problem,
          and uses a trickle timer <xref target="Levis08"></xref> to control
          the rate of control broadcasts.</t>

          <t>For each DODAG that a node is part of, the node must maintain a
          single trickle timer. The required state contains the following
          conceptual items:</t>

          <t><list hangIndent="6" style="hanging">
              <t hangText="I:">The current length of the communication
              interval</t>

              <t hangText="T:">A timer with a duration set to a random value
              in the range [I/2, I]</t>

              <t hangText="C:">Redundancy Counter</t>

              <t hangText="I_min:">The smallest communication interval in
              milliseconds. This value is learned from the DIO message as
              (2^DIOIntervalMin)ms. The default value is
              DEFAULT_DIO_INTERVAL_MIN.</t>

              <t hangText="I_doublings:">The number of times I_min should be
              doubled before maintaining a constant rate, i.e. I_max = I_min *
              2^I_doublings. This value is learned from the DIO message as
              DIOIntervalDoublings. The default value is
              DEFAULT_DIO_INTERVAL_DOUBLINGS.</t>
            </list></t>

          <section title="Resetting the Trickle Timer">
            <t>The trickle timer for a DODAG is reset by:</t>

            <t><list style="numbers">
                <t>Setting I_min and I_doublings to the values learned from
                the DIO message.</t>

                <t>Setting C to zero.</t>

                <t>Setting I to I_min.</t>

                <t>Setting T to a random value as described above.</t>

                <t>Restarting the trickle timer to expire after a duration
                T</t>
              </list></t>

            <t>When a node learns about a DODAG through a DIO message and
            makes the decision to join it, it initializes the state of the
            trickle timer by resetting the trickle timer and listening. Each
            time it hears a redundant DIO message for this DODAG, it MAY
            increment C. The exact determination of redundant is left to an
            implementation; it could include DIOs that advertise the same
            rank.</t>

            <t>When the timer fires at time T, the node compares C to the
            redundancy constant, DIORedundancyConstant. If C is less than that
            value, or if the DIORedundancyConstant value is 0xFF, the node
            generates a new DIO message and multicasts it. When the
            communication interval I expires, the node doubles the interval I
            so long as it has previously doubled it fewer than I_doubling
            times, resets C, and chooses a new T value.</t>
          </section>

          <!-- TBD redundant -->

          <section anchor="TrickleInconsistencies"
                   title="Determination of Inconsistency">
            <t>The trickle timer is reset whenever an inconsistency is
            detected within the DODAG, for example:</t>

            <t><list style="symbols">
                <t>The node joins a new DODAG</t>

                <t>The node moves within a DODAG</t>

                <t>The node receives a modified DIO message from a DAG
                parent</t>

                <t>A DAG parent forwards a packet intended to move up,
                indicating an inconsistency and possible loop.</t>

                <t>A metric communicated in the DIO message is determined to
                be inconsistent, as according to a implementation specific
                path metric selection engine.</t>

                <t>The rank of a DAG parent has changed.</t>
              </list></t>
          </section>
        </section>
      </section>

      <section title="DAG Selection">
        <t>The DAG selection is implementation and algorithm dependent. Nodes
        SHOULD prefer to join DODAGs for InstanceIDs advertising OCPs and
        destinations compatible with their implementation specific objectives.
        In order to limit erratic movements, and all metrics being equal,
        nodes SHOULD keep their previous selection. Also, nodes SHOULD provide
        a means to filter out a parent whose availability is detected as
        fluctuating, at least when more stable choices are available.</t>

        <t>When connection to a fixed network is not possible or preferable
        for security or other reasons, scattered DODAGs MAY aggregate as much
        as possible into larger DODAGs in order to allow connectivity within
        the LLN.</t>

        <t>A node SHOULD verify that bidirectional connectivity and adequate
        link quality is available with a candidate neighbor before it
        considers that candidate as a DAG parent.</t>
      </section>

      <section title="Operation as a Leaf Node">
        <t>In some cases it a RPL node may attach to a DODAG for DAG Instance
        as a leaf node only; the node in this case is not to extend
        connectivity to the DODAG to other nodes under any circumstances. Such
        a case may occur, for example, when a node is attaching to a DODAG
        that is using an unknown Objective Function. When operating as a leaf
        node, a node:</t>

        <t><list style="numbers">
            <t>MAY receive and process DIOs for that DODAG</t>

            <t>SHOULD NOT transmit DIOs for that DODAG</t>

            <t>MUST NOT transmit DIOs containing the DAG Metric Container for
            that DODAG</t>

            <t>MAY transmit unicast DAOs to the chosen parents for that
            DODAG</t>

            <t>MAY transmit multicast DAOs to the `1 hop' neighborhood.</t>
          </list></t>
      </section>

      <section title="Administrative rank">
        <t>When the DODAG is formed under a common administration, or when a
        node performs a certain role within a community, it might be
        beneficial to associate a range of acceptable rank with that node. For
        instance, a node that has limited battery should be a leaf unless
        there is no other choice, and may then augment the rank computation
        specified by the OF in order to expose an exaggerated rank.</t>
      </section>

      <section anchor="DAGCollision" title="Collision">
        <t>A race condition occurs if 2 nodes send DIO messages at the same
        time and then attempt to join each other. This might happen, for
        example, between nodes which act as DAG root of their own DODAGs. In
        order to detect the situation, LLN Nodes time stamp the sending of DIO
        message. Any DIO message received within a short link-layer-dependent
        period introduces a risk. It left to the implementation to define the
        duration of the risk window.</t>

        <t>There is risk of a collision when a node receives and processes a
        DIO within the risk window. For example, it may occur that two nodes
        are associated with different DODAGs and near-simultaneously send DIO
        messages, which are received and processed by both, and possibly
        result in both nodes simultaneously deciding to attach to each other.
        As a remedy, in the face of a potential collision, as determined by
        receiving a DIO within the risk window, the DIO message is not
        processed. It is expected that subsequent DIOs would not cross.</t>
      </section>

      <section anchor="DestinationAdvertisement"
               title="Establishing Routing State Down the DODAG">
        <t>The destination advertisement mechanism supports the dissemination
        of routing state required to support traffic flows down along the
        DODAG, from the DODAG root toward nodes.</t>

        <t>As a result of destination advertisement operation:</t>

        <t><list style="symbols">
            <t>Destination advertisement establishes down routes along the
            DODAG. Such paths consist of:</t>

            <?rfc subcompact="yes"?>

            <list style="symbols">
              <t>Hop-By-Hop routing state within islands of `stateful'
              nodes.</t>

              <t>Source Routing `bridges' across nodes that do not retain
              state.</t>
            </list>

            <?rfc subcompact="no"?>
          </list></t>

        <t>Destinations disseminated with the destination advertisement
        mechanism may be prefixes, individual hosts, or multicast listeners.
        The mechanism supports nodes of varying capabilities as follows:</t>

        <t><list style="symbols">
            <t>When nodes are capable of storing routing state, they may
            inspect destination advertisements and learn hop-by-hop routing
            state toward destinations by populating their routing tables with
            the routes learned from nodes in their sub-DAG. In this process
            they may also learn necessary piecewise source routes to traverse
            regions of the LLN that do not maintain routing state. They may
            perform route aggregation on known destinations before emitting
            Destination Advertisements.</t>

            <t>When nodes are incapable of storing routing state, they may
            forward destination advertisements, recording the reverse route as
            the go in order to support the construction of piecewise source
            routes.</t>
          </list></t>

        <t>Nodes that are capable of storing routing state, and finally the
        DODAG roots, are able to learn which destinations are contained in the
        sub-DAG below the node, and via which next-hop neighbors. The
        dissemination and installation of this routing state into nodes allows
        for Hop-By-Hop routing from the DODAG root down the DODAG. The
        mechanism is further enhance by supporting the construction of source
        routes across stateless `gaps' in the DODAG, where nodes are incapable
        of storing additional routing state. An adaptation of this mechanism
        allows for the implementation of loose-source routing.</t>

        <t>A special case, the reception of a destination advertisement
        addressed to a link-local multicast address, allows for a node to
        learn destinations directly available from its one-hop neighbors.</t>

        <t>A design choice behind advertising routes via destination
        advertisements is not to synchronize the parent and children databases
        along the DODAG, but instead to update them regularly to recover from
        the loss of packets. The rationale for that choice is time variations
        in connectivity across unreliable links. If the topology can be
        expected to change frequently, synchronization might be an excessive
        goal in terms of exchanges and protocol complexity. The approach used
        here results in a simple protocol with no real peering. The
        destination advertisement mechanism hence provides for periodic
        updates of the routing state, similarly to other protocols such as RIP
        <xref target="RFC2453"></xref>.</t>

        <section title="Destination Advertisement Operation">
          <section title="Overview">
            <t>According to implementation specific policy, a subset or all of
            the feasible parents in the DODAG may be selected to receive
            prefix information from the destination advertisement mechanism.
            This subset of DAG parents shall be designated the set of DA
            parents.</t>

            <t>As DAO messages for particular destinations move up the DODAG,
            a sequence counter is used to guarantee their freshness. The
            sequence counter is incremented by the source of the DAO message
            (the node that owns the prefix, or learned the prefix via some
            other means), each time it issues a DAO message for its prefix.
            Nodes that receive the DAO message and, if scope allows, will be
            forwarding a DAO message for the unmodified destination up the
            DODAG, will leave the sequence number unchanged. Intermediate
            nodes will check the sequence counter before processing a DAO
            message, and if the DAO is unchanged (the sequence counter has not
            changed), then the DAO message will be discarded without
            additional processing. Further, if the DAO message appears to be
            out of synch (the sequence counter is 2 or more behind the present
            value) then the DAO state is considered to be stale and may be
            purged, and the DAO message is discarded. The rank is also added
            for tracking purposes; nodes that are storing routing state may
            use it to determine which possible next-hops for the destination
            are more optimal.</t>

            <t>If destination advertisements are activated in the DIO message
            as indicated by the `D' bit, the node sends unicast destination
            advertisements to one of its DA parents, that is selected as most
            favored for incoming down traffic. The node only accepts unicast
            destination advertisements from any nodes but those contained in
            the DA parent subset.</t>

            <t>Receiving a DIO message with the `D' destination advertisement
            bit set from a DAG parent stimulates the sending of a delayed
            destination advertisement back, with the collection of all known
            prefixes (that is the prefixes learned via destination
            advertisements for nodes lower in the DODAG, and any connected
            prefixes). If the Destination Advertisement Supported (A) bit is
            set in the DIO message for the DODAG, then a destination
            advertisement is also sent to a DAG parent once it has been added
            to the DA parent set after a movement, or when the list of
            advertised prefixes has changed.</t>

            <t>A node that modifies its DAG Parent set may set the `D' bit in
            subsequent DIO propagation in order to trigger destination
            advertisements to be updated to its DAG Parents and other
            ancestors on the DODAG. Additional recommendations and guidelines
            regarding the use of this mechanism are still under consideration
            and will be elaborated in a future revision of this
            specification.</t>

            <t>Destination advertisements may advertise positive (prefix is
            present) or negative (removed) DAO messages, termed as no-DAOs. A
            no-DAO is stimulated by the disappearance of a prefix below. This
            is discovered by timing out after a request (a DIO message) or by
            receiving a no-DAO. A no-DAO is a conveyed as a DAO message with a
            DAO Lifetime of ZERO_LIFETIME.</t>

            <t>A node that is capable of recording the state information
            conveyed in a unicast DAO message will do so upon receiving and
            processing the DAO message, thus provisioning routing state
            concerning destinations located downwards along the DODAG. If a
            node capable of recording state information receives a DAO message
            containing a Reverse Route Stack, then the node knows that the DAO
            message has traversed one or more nodes that did not retain any
            routing state as it traversed the path from the DAO source to the
            node. The node may then extract the Reverse Route Stack and retain
            the included state in order to specify Source Routing instructions
            along the return path towards the destination. The node MUST set
            the RRCount back to zero and clear the Reverse Route Stack prior
            to passing the DAO message information on.</t>

            <t>A node that is unable to record the state information conveyed
            in the DAO message will append the next-hop address to the Reverse
            Route Stack, increment the RRCount, and then pass the destination
            advertisement on without recording any additional state. In this
            way the Reverse Route Stack will contain a vector of next hops
            that must be traversed along the reverse path that the DAO message
            has traveled. The vector will be ordered such that the node
            closest to the destination will appear first in the list. In such
            cases, if it is useful to the implementation to try and provision
            redundant paths, the node may choose to convey the destination
            advertisement to one or more DAG parents in order of preference as
            guided by an implementation specific policy.</t>

            <t>In certain cases (called hybrid cases), some nodes along the
            path a destination advertisement follows up the DODAG may store
            state and some may not. The destination advertisement mechanism
            allows for the provisioning of routing state such that when a
            packet is traversing down the DODAG, some nodes may be able to
            directly forward to the next hop, and other nodes may be able to
            specify a piecewise source route in order to bridge spans of
            stateless nodes within the path on the way to the desired
            destination.</t>

            <t>In the case where no node is able to store any routing state as
            destination advertisements pass by, and the DAG root ends up with
            DAO messages that contain a completely specified route back to the
            originating node in the form of the inverted Reverse Route Stack.
            A DAG root should not request (Destination Advertisement Trigger)
            nor indicate support (Destination Advertisement Supported) for
            destination advertisements if it is not able to store the Reverse
            Route Stack information in this case.</t>

            <t>The destination advertisement mechanism requires stateful nodes
            to maintain lists of known prefixes. A prefix entry contains the
            following abstract information:</t>

            <t><list style="symbols">
                <t>A reference to the ND entry that was created for the
                advertising neighbor.</t>

                <t>The IPv6 address and interface for the advertising
                neighbor.</t>

                <t>The logical equivalent of the full destination
                advertisement information (including the prefixes, depth, and
                Reverse Route Stack, if any).</t>

                <t>A 'reported' Boolean to keep track whether this prefix was
                reported already, and to which of the DA parents.</t>

                <t>A counter of retries to count how many DIO messages were
                sent on the interface to the advertising neighbor without
                reachability confirmation for the prefix.</t>
              </list></t>

            <t>Note that nodes may receive multiple information from different
            neighbors for a specific destination, as different paths through
            the DODAG may be propagating information up the DODAG for the same
            destination. A node that is recording routing state will keep
            track of the information from each neighbor independently, and
            when it comes time to propagate the DAO message for a particular
            prefix to the DA parents, then the DAO information will be
            selected from among the advertising neighbors who offer the least
            depth to the destination.</t>

            <t>When a node loses connectivity to a child that is used as next
            hop for a route learned from a DAO, the node should cleanup all
            routes and DAO states that are related to that child. If the lost
            child was the only adjacency leading to the DAO prefix, the node
            should poison the route by sending no-DAOs to the parents to which
            it has advertised the DAO prefixes.</t>

            <t>The destination advertisement mechanism stores the prefix
            entries in one of 3 abstract lists; the Connected, the Reachable
            and the Unreachable lists.</t>

            <t>The Connected list corresponds to the prefixes owned and
            managed by the local node.</t>

            <t>The Reachable list contains prefixes for which the node keeps
            receiving DAO messages, and for those prefixes which have not yet
            timed out.</t>

            <t>The Unreachable list keeps track of prefixes which are no
            longer valid and in the process of being deleted, in order to send
            DAO messages with zero lifetime (also called no-DAO) to the DA
            parents.</t>

            <section anchor="DATimers"
                     title="Destination Advertisement Timers">
              <t>The destination advertisement mechanism requires 2 timers;
              the DelayDAO timer and the RemoveTimer.</t>

              <t><list style="symbols">
                  <t>The DelayDAO timer is armed upon a stimulation to send a
                  destination advertisement (such as a DIO message from a DA
                  parent). When the timer is armed, all entries in the
                  Reachable list as well as all entries for Connected list are
                  set to not be reported yet for that particular DA
                  parent.</t>

                  <t>For a root, the DIO timer has a duration of
                  DEF_DAO_LATENCY. For a node in a DODAG iteration, the
                  DelayDAO timer has a duration that is randomized between
                  (DEF_DAO_LATENCY divided by the Rank of the node) and
                  (DEF_DAO_LATENCY divided by the Rank of the parent). The
                  intention is that nodes located deeper in the DODAG
                  iteration should have a shorter DelayDAO timer, allowing DAO
                  messages a chance to be reported from deeper in the DODAG
                  and potentially aggregated along sub-DAGs before propagating
                  further up.</t>

                  <t>The RemoveTimer is used to clean up entries for which DAO
                  messages are no longer being received from the sub-DAG.</t>

                  <list style="symbols">
                    <t>When a DIO message is sent that is requesting
                    destination advertisements, a flag is set for all DAO
                    entries in the routing table.</t>

                    <t>If the flag has already been set for a DAO entry, the
                    retry count is incremented.</t>

                    <t>If a DAO message is received to confirm the entry, the
                    entry is refreshed and the flag and count may be
                    cleared.</t>

                    <t>If at least one entry has reached a threshold value and
                    the RemoveTimer is not running, the entry is considered to
                    be probably gone and the RemoveTimer is started.</t>

                    <t>When the RemoveTimer elapse, DAO messages with lifetime
                    0, i.e. no-DAOs, are sent to explicitly inform DA parents
                    that the entries which have reached the threshold are no
                    longer available, and the related routing states may be
                    propagated and cleaned up.</t>
                  </list>

                  <t>The RemoveTimer has a duration of min
                  (MAX_DESTROY_INTERVAL, TBD(DIO Trickle Timer Interval)).</t>
                </list></t>
            </section>
          </section>

          <section title="Multicast Destination Advertisement Messages">
            <t>It is also possible for a node to multicast a DAO message to
            the link-local scope all-nodes multicast address FF02::1. This
            message will be received by all node listening in range of the
            emitting node. The objective is to enable direct P2P
            communication, between destinations directly supported by
            neighboring nodes, without needing the RPL routing structure to
            relay the packets.</t>

            <t>A multicast DAO message MUST be used only to advertise
            information about self, i.e. prefixes in the Connected list or
            addresses owned by this node. This would typically be a multicast
            group that this node is listening to or a global address owned by
            this node, though it can be used to advertise any prefix owned by
            this node as well. A multicast DAO message is not used for routing
            and does not presume any DODAG relationship between the emitter
            and the receiver; it MUST NOT be used to relay information learned
            (e.g. information in the Reachable list) from another node;
            information obtained from a multicast DAO MAY be installed in the
            routing table and MAY be propagated by a router in unicast
            DAOs.</t>

            <t>A node receiving a multicast DAO message addressed to FF02::1
            MAY install prefixes contained in the DAO message in the routing
            table for local use. Such a node MUST NOT perform any other
            processing on the DAO message (i.e. such a node does not presume
            it is a DA parent).</t>
          </section>

          <section title="Unicast Destination Advertisement Messages from Child to Parent">
            <t>When sending a destination advertisement to a DA parent, a node
            includes the DAOs for prefix entries not already reported (since
            the last DA Trigger from an DIO message) in the Reachable and
            Connected lists, as well as no-DAOs for all the entries in the
            Unreachable list. Depending on its policy and ability to retain
            routing state, the receiving node SHOULD keep a record of the
            reported DAO message. If the DAO message offers the best route to
            the prefix as determined by policy and other prefix records, the
            node SHOULD install a route to the prefix reported in the DAO
            message via the link local address of the reporting neighbor and
            it SHOULD further propagate the information in a DAO message.</t>

            <t>The DIO message from the DODAG root is used to synchronize the
            whole DODAG iteration, including the periodic reporting of
            destination advertisements back up the DODAG. Its period is
            expected to vary, depending on the configuration of the DIO
            trickle timer.</t>

            <t>When a node receives a DIO message over an LLN interface from a
            DA parent, the DelayDAO is armed to force a full update.</t>

            <t>When the node broadcasts a DIO message on an LLN interface, for
            all entries on that interface:</t>

            <t><list style="symbols">
                <t>If the entry is CONFIRMED, it goes PENDING with the retry
                count set to 0.</t>

                <t>If the entry is PENDING, the retry count is incremented. If
                it reaches a maximum threshold, the entry goes ELAPSED If at
                least one entry is ELAPSED at the end of the process: if the
                RemoveTimer is not running then it is armed with a jitter.</t>
              </list></t>

            <t>Since the DelayDAO timer has a duration that decreases with the
            depth, it is expected to receive all DAO messages from all
            children before the timer elapses and the full update is sent to
            the DA parents.</t>

            <t>Once the RemoveTimer is elapsed, the prefix entry is scheduled
            to be removed and moved to the Unreachable list if there are any
            DA parents that need to be informed of the change in status for
            the prefix, otherwise the prefix entry is cleaned up right away.
            The prefix entry is removed from the Unreachable list when no more
            DA parents need to be informed. This condition may be satisfied
            when a no-DAO is sent to all current DA parents indicating the
            loss of the prefix, and noting that in some cases parents may have
            been removed from the set of DA parents.</t>
          </section>

          <section title="Other Events">
            <t>Finally, the destination advertisement mechanism responds to a
            series of events, such as:</t>

            <t><list style="symbols">
                <t>Destination advertisement operation stopped: All entries in
                the abstract lists are freed. All the routes learned from DAO
                messages are removed.</t>

                <t>Interface going down: for all entries in the Reachable list
                on that interface, the associated route is removed, and the
                entry is scheduled to be removed.</t>

                <t>Loss of routing adjacency: When the routing adjacency for a
                neighbor is lost, as per the procedures described in <xref
                target="MaintenanceRoutingAdjacency"></xref>, and if the
                associated entries are in the Reachable list, the associated
                routes are removed, and the entries are scheduled to be
                destroyed.</t>

                <t>Changes to DA parent set: all entries in the Reachable list
                are set to not 'reported' and DelayDAO is armed.</t>
              </list></t>
          </section>

          <section title="Aggregation of Prefixes by a Node">
            <t>There may be number of cases where a aggregation may be shared
            within a group of nodes. In such a case, it is possible to use
            aggregation techniques with destination advertisements and improve
            scalability.</t>

            <t>Other cases might occur for which additional support is
            required:</t>

            <t><list style="numbers">
                <t>The aggregating node is attached within the sub-DAG of the
                nodes it is aggregating for.</t>

                <t>A node that is to be aggregated for is located somewhere
                else within the DODAG iteration, not in the sub-DAG of the
                aggregating node.</t>

                <t>A node that is to be aggregated for is located somewhere
                else in the LLN.</t>
              </list></t>

            <t>Consider a node M that is performing an aggregation, and a node
            N that is to be a member of the aggregation group. A node Z
            situated above the node M in the DODAG, but not above node N, will
            see the advertisements for the aggregation owned by M but not that
            of the individual prefix for N. Such a node Z will route all the
            packets for node N towards node M, but node M will have no route
            to the node N and will fail to forward.</t>

            <t>Additional protocols may be applied beyond the scope of this
            specification to dynamically elect/provision an aggregating node
            and groups of nodes eligible to be aggregated in order to provide
            route summarization for a sub-DAG.</t>
          </section>
        </section>
      </section>

      <section anchor="loopdetect" title="Loop Detection">
        <t>RPL loop avoidance mechanisms are kept simple and designed to
        minimize churn and states. Loops may form for a number of reasons,
        from control packet loss to sibling forwarding. RPL includes a
        reactive loop detection technique that protects from meltdown and
        triggers repair of broken paths.</t>

        <t>RPL loop detection uses information that is placed into the packet
        in the IPv6 flow label. The IPv6 flow label is defined in <xref
        target="RFC2460" /> and its operation is further specified in <xref
        target="RFC3697" />. For the purpose of RPL operations, the flow label
        is constructed as follows: <t>
            <figure anchor="flowlabel" title="RPL Flow Label">
              <artwork><![CDATA[
     0                   1                   2       
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |O|S|R|F|  SenderRank   |  InstanceID   |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
]]></artwork>
            </figure>
          </t></t>

        <t><list hangIndent="6" style="hanging">
            <t hangText="Down 'O' bit:">1-bit flag indicating whether the
            packet is expected to progress up or down. A router sets the 'O'
            bit when the packet is expect to progress down (using DAO routes),
            and resets it when forwarding towards the root of the DODAG
            iteration. A host MUST set the bit to 0.</t>

            <t hangText="Sibling 'S' bit:">1-bit flag indicating whether the
            packet has been forwarded via a sibling at the present rank, and
            denotes a risk of a sibling loop. A host sets the bit to 0.</t>

            <t hangText="Rank-Error 'R' bit:">1-bit flag indicating whether a
            rank error was detected. A rank error is detected when there is a
            mismatch in the relative ranks and the direction as indicated in
            the 'O' bit. A host MUST set the bit to 0.</t>

            <t hangText="Forwarding-Error 'F' bit:">1-bit flag indicating that
            this node can not forward the packet further towards the
            destination. The 'F' bit might be set by sibling that can not
            forward to a parent a packet with the Sibling 'S' bit set, or by a
            child node that does not have a route to destination for a packet
            with the down 'O' bit set. A host MUST set the bit to 0.</t>

            <t hangText="SenderRank:">8-bit field set to zero by the source
            and to its rank by a router that forwards inside the RPL
            network.</t>

            <t hangText="InstanceID:">8-bit field indicating the DODAG
            instance along which the packet is sent.</t>
          </list></t>

        <section title="Source Node Operation">
          <t>A packet that is sourced at a node connected to a RPL network or
          destined to a node connected to a RPL network MUST be issued with
          the flow label zeroed out, but for the InstanceID field.</t>

          <t>If the source is aware of the InstanceID that is preferred for
          the flow, then it MUST set the InstanceID field in the flow label
          accordingly, otherwise it MUST set it to the
          RPL_DEFAULT_INSTANCE.</t>

          <t>If a compression mechanism such as 6LoWPAN is applied to the
          packet, the flow label MUST NOT be compressed even if it is set to
          all zeroes.</t>
        </section>

        <section title="Router Operation">
          <section title="Conformance to RFC 3697">
            <t><xref target="RFC3697"></xref> mandates that the Flow Label
            value set by the source MUST be delivered unchanged to the
            destination node(s).</t>

            <t>In order to restore the flow label to its original value, an
            RPL router that delivers a packet to a destination connected to a
            RPL network or that routes a packet outside the RPL network MUST
            zero out all the fields but the InstanceID field that must be
            delivered without a change.</t>
          </section>

          <section title="Instance Forwarding">
            <t>Instance IDs are used to avoid loops between DODAGs from
            different origins. DODAGs that constructed for antagonistic
            constraints might contain paths that, if mixed together, would
            yield loops. Those loops are avoided by forwarding a packet along
            the DODAG that is associated to a given instance.</t>

            <t>The InstanceID is placed by the source in the flow label. This
            InstanceID MUST match the DODAG instance onto which the packet is
            placed by any node, be it a host or router.</t>

            <t>When a router receives a packet that is flagged with a given
            InstanceID and the node can forward the packet along the DODAG
            associated to that instance, then the router MUST do so and leave
            the InstanceID flag unchanged.</t>

            <t>If any node can not forward a packet along the DODAG associated
            to the InstanceID in the flow label, then the node SHOULD discard
            the packet.</t>
          </section>

          <section title="DAG Inconsistency Loop Detection">
            <t>The DODAG is inconsistent if the direction of a packet does not
            match the rank relationship. A receiver detects an inconsistency
            if it receives a packet with either: <list>
                <t>the 'O' bit set (to down) from a node of a higher rank.</t>

                <t>the 'O' bit reset (for up) from a node of a lesser
                rank.</t>

                <t>the 'S' bit set (to sibling) from a node of a different
                rank.</t>
              </list></t>

            <t>When the DODAG root increments the DAG Sequence Number a
            temporary rank discontinuity may form between the next iteration
            and the prior iteration, in particular if nodes are adjusting
            their rank in the next iteration and deferring their migration
            into the next iteration. A router that is still a member of the
            prior iteration may choose to forward a packet to a (future)
            parent that is in the next iteration. In some cases this could
            cause the parent to detect an inconsistency because the
            rank-ordering in the prior iteration is not necessarily the same
            as in the next iteration and the packet may be judged to not be
            making forward progress. If the sending router is aware that the
            chosen successor has already joined the next iteration, then the
            sending router MUST update the SenderRank to INFINITE_RANK as it
            forwards the packets across the discontinuity into the next DODAG
            iteration in order to avoid a false detection of rank
            inconsistency.</t>

            <!--
            <t>The propagation of a new sequence creates local
            inconsistencies. In particular, it is possible for a router to
            forward a packet to a future parent (same instance, same DAGID,
            higher sequence) without a loop, regardless of the rank of that
            parent. In that case, the sending router MUST present itself as a
            host on the future DODAG iteration and use a rank of INFINITE_RANK
            as it forwards the packets via a future parent to avoid a false
            positive.</t>
            -->

            <t>One inconsistency along the path is not considered as a
            critical error and the packet may continue. But a second detection
            along the path of a same packet should not occur and the packet is
            dropped.</t>

            <t>This process is controlled by the Rank-Error bit in the Flow
            Label. When an inconsistency, is detected on a packet, if the
            Rank-Error bit was not set then the Rank-Error bit is set. If it
            was set the packet is discarded and the trickle timer is
            reset.</t>
          </section>

          <section title="Sibling Loop Avoidance">
            <t>When a packet is forwarded along siblings, it cannot be checked
            for forward progress and may loop between siblings. Experimental
            evidence has shown that one sibling hop can be very useful but is
            generally sufficient to avoid loops. Based on that evidence, this
            specification enforces the simple rule that a packet may not make
            2 sibling hops in a row.</t>

            <t>When a host issues a packet or when a router forwards a packet
            to a non-sibling, the Sibling bit in the packet must be reset.
            When a router forwards to a sibling: if the Sibling bit was not
            set then the Sibling bit is set. If the Sibling bit was set then
            then the router SHOULD return the packet to the sibling that that
            passed it with the Forwarding-Error 'F' bit set.</t>
          </section>

          <section title="DAO Inconsistency Loop Detection and Recovery">
            <t>A DAO inconsistency happens when router that has an down DAO
            route via a child that is a remnant from an obsolete state that is
            not matched in the child. With DAO inconsistency loop recovery, a
            packet can be used to recursively explore and cleanup the obsolete
            DAO states along a sub-DAG.</t>

            <t>In a general manner, a packet that goes down should never go up
            again. So rather than routing up a packet with the down bit set,
            the router MUST discard the packet. If DAO inconsistency loop
            recovery is applied, then the router SHOULD send the packet to the
            parent that passed it with the Forwarding-Error 'F' bit set.</t>
          </section>

          <section title="Forward Path Recovery">
            <t>Upon receiving a packet with a Forwarding-Error bit set, the
            node MUST remove the routing states that caused forwarding to that
            neighbor, clear the Forwarding-Error bit and attempt to send the
            packet again. The packet may its way to an alternate neighbor. If
            that alternate neighbor still has an inconsistent DAO state via
            this node, the process will recurse, this node will set the
            Forwarding-Error 'F' bit and the routing state in the alternate
            neighbor will be cleaned up as well.</t>
          </section>
        </section>
      </section>

      <section title="Multicast Operation">
        <t>This section describes further the multicast routing operations
        over an IPv6 RPL network, and specifically how unicast DAOs can be
        used to relay group registrations up. Wherever the following text
        mentions MLD, one can read MLDv2 or v3.</t>

        <t>As is traditional, a listener uses a protocol such as MLD with a
        router to register to a multicast group.</t>

        <t>Along the path between the router and the DODAG root, MLD requests
        are mapped and transported as DAO messages within the RPL protocol;
        each hop coalesces the multiple requests for a same group as a single
        DAO message to the parent(s), in a fashion similar to proxy IGMP, but
        recursively between child router and parent up to the root.</t>

        <t>A router might select to pass a listener registration DAO message
        to its preferred parent only, in which case multicast packets coming
        back might be lost for all of its sub-DAG if the transmission fails
        over that link. Alternatively the router might select to copy
        additional parents as it would do for DAO messages advertising unicast
        destinations, in which case there might be duplicates that the router
        will need to prune.</t>

        <t>As a result, multicast routing states are installed in each router
        on the way from the listeners to the root, enabling the root to copy a
        multicast packet to all its children routers that had issued a DAO
        message including a DAO for that multicast group, as well as all the
        attached nodes that registered over MLD.</t>

        <t>For unicast traffic, it is expected that the grounded root of an
        DODAG terminates RPL and MAY redistribute the RPL routes over the
        external infrastructure using whatever routing protocol is used there.
        For multicast traffic, the root MAY proxy MLD for all the nodes
        attached to the RPL routers (this would be needed if the multicast
        source is located in the external infrastructure). For such a source,
        the packet will be replicated as it flows down the DODAG based on the
        multicast routing table entries installed from the DAO message.</t>

        <t>For a source inside the DODAG, the packet is passed to the
        preferred parents, and if that fails then to the alternates in the
        DODAG. The packet is also copied to all the registered children,
        except for the one that passed the packet. Finally, if there is a
        listener in the external infrastructure then the DODAG root has to
        further propagate the packet into the external infrastructure.</t>

        <t>As a result, the DODAG Root acts as an automatic proxy Rendezvous
        Point for the RPL network, and as source towards the Internet for all
        multicast flows started in the RPL LLN. So regardless of whether the
        root is actually attached to the Internet, and regardless of whether
        the DODAG is grounded or floating, the root can serve inner multicast
        streams at all times.</t>
      </section>

      <section anchor="MaintenanceRoutingAdjacency"
               title="Maintenance of Routing Adjacency">
        <t>The selection of successors, along the default paths up along the
        DODAG, or along the paths learned from destination advertisements down
        along the DODAG, leads to the formation of routing adjacencies that
        require maintenance.</t>

        <t>In IGPs such as OSPF <xref target="RFC4915"></xref> or IS-IS <xref
        target="RFC5120"></xref>, the maintenance of a routing adjacency
        involves the use of Keepalive mechanisms (Hellos) or other protocols
        such as BFD (<xref target="I-D.ietf-bfd-base"></xref>) and MANET
        Neighborhood Discovery Protocol (NHDP <xref
        target="I-D.ietf-manet-nhdp"></xref>). Unfortunately, such an approach
        is not desirable in constrained environments such as LLN and would
        lead to excessive control traffic in light of the data traffic with a
        negative impact on both link loads and nodes resources. Overhead to
        maintain the routing adjacency should be minimized. Furthermore, it is
        not always possible to rely on the link or transport layer to provide
        information of the associated link state. The network layer needs to
        fall back on its own mechanism.</t>

        <t>Thus RPL makes use of a different approach consisting of probing
        the neighbor using a Neighbor Solicitation message (see <xref
        target="RFC4861"></xref>). The reception of a Neighbor Advertisement
        (NA) message with the "Solicited Flag" set is used to verify the
        validity of the routing adjacency. Such mechanism MAY be used prior to
        sending a data packet. This allows for detecting whether or not the
        routing adjacency is still valid, and should it not be the case,
        select another feasible successor to forward the packet.</t>
      </section>
    </section>

    <section anchor="PacketForwarding"
             title="Suggestions for Packet Forwarding">
      <t>When forwarding a packet to a destination, precedence is given to
      selection of a next-hop successor as follows:</t>

      <t><list style="numbers">
          <t>In the scope of this specification, it is preferred to select a
          successor from a DODAG iteration that matches the InstanceID marked
          in the IPv6 header of the packet being forwarded.</t>

          <t>If a local administrative preference favors a route that has been
          learned from a different routing protocol than RPL, then use that
          successor.</t>

          <t>If there is an entry in the routing table matching the
          destination that has been learned from a multicast destination
          advertisement (e.g. the destination is a one-hop neighbor), then use
          that successor.</t>

          <t>If there is an entry in the routing table matching the
          destination that has been learned from a unicast destination
          advertisement (e.g. the destination is located down the sub-DAG),
          then use that successor.</t>

          <t>If there is a DODAG iteration offering a route to a prefix
          matching the destination, then select one of those DODAG parents as
          a successor.</t>

          <t>If there is a DAG parent offering a default route then select
          that DAG parent as a successor.</t>

          <t>If there is a DODAG iteration offering a route to a prefix
          matching the destination, but all DAG parents have been tried and
          are temporarily unavailable (as determined by the forwarding
          procedure), then select a DAG sibling as a successor.</t>

          <t>Finally, if no DAG siblings are available, the packet is dropped.
          ICMP Destination Unreachable may be invoked. An inconsistency is
          detected.</t>
        </list></t>

      <t>TTL MUST be decremented when forwarding. If the packet is being
      forwarded via a sibling, then the TTL MAY be decremented more
      aggressively (by more than one) to limit the impact of possible
      loops.</t>

      <t>Note that the chosen successor MUST NOT be the neighbor that was the
      predecessor of the packet (split horizon), except in the case where it
      is intended for the packet to change from an up to an down flow, such as
      switching from DIO routes to DAO routes as the destination is
      neared.</t>
    </section>

    <section title="Guidelines for Objective Functions">
      <t>An Objective Function (OF) allows for the selection of a DODAG to
      join, and a number of peers in that DAG as parents. The OF is used to
      compute an ordered list of parents. The OF is also responsible to
      compute the rank of the device within the DODAG iteration.</t>

      <t>The Objective Function is indicated in the DIO message using an
      Objective Code Point (OCP), as specified in <xref
      target="I-D.ietf-roll-routing-metrics" />, and indicates the method that
      must be used to compute the DODAG (e.g. "minimize the path cost using
      the ETX metric and avoid `Blue' links"). The Objective Code Points are
      specified in <xref target="I-D.ietf-roll-routing-metrics" /> and related
      companion specifications.</t>

      <t>Most Objective Functions are expected to follow the same abstract
      behavior:</t>

      <list style="symbols">
        <t>The parent selection is triggered each time an event indicates that
        a potential next hop information is updated. This might happen upon
        the reception of a DIO message, a timer elapse, or a trigger
        indicating that the state of a candidate neighbor has changed.</t>

        <t>An OF scans all the interfaces on the device. Although there may
        typically be only one interface in most application scenarios, there
        might be multiple of them and an interface might be configured to be
        usable or not for RPL operation. An interface can also be configured
        with a preference or dynamically learned to be better than another by
        some heuristics that might be link-layer dependent and are out of
        scope. Finally an interface might or not match a required criterion
        for an Objective Function, for instance a degree of security. As a
        result some interfaces might be completely excluded from the
        computation, while others might be more or less preferred.</t>

        <t>An OF scans all the candidate neighbors on the possible interfaces
        to check whether they can act as a router for a DODAG. There might be
        multiple of them and a candidate neighbor might need to pass some
        validation tests before it can be used. In particular, some link
        layers require experience on the activity with a router to enable the
        router as a next hop.</t>

        <t>An OF computes self's rank by adding the step of rank to that
        candidate to the rank of that candidate. The step of rank is computed
        by estimating the link as follows:</t>

        <list style="symbols">
          <t>The step of rank might vary from 1 to 16.</t>

          <list style="symbols">
            <t>1 indicates a unusually good link, for instance a link between
            powered devices in a mostly battery operated environment.</t>

            <t>4 indicates a `normal'/typical link, as qualified by the
            implementation.</t>

            <t>16 indicates a link that can hardly be used to forward any
            packet, for instance a radio link with quality indicator or
            expected transmission count that is close to the acceptable
            threshold.</t>
          </list>

          <t>Candidate neighbors that would cause self's rank to increase are
          ignored</t>
        </list>

        <t>Candidate neighbors that advertise an OF incompatible with the set
        of OF specified by the policy functions are ignored.</t>

        <t>As it scans all the candidate neighbors, the OF keeps the current
        best parent and compares its capabilities with the current candidate
        neighbor. The OF defines a number of tests that are critical to reach
        the objective. A test between the routers determines an order
        relation.</t>

        <list style="symbols">
          <t>If the routers are roughly equal for that relation then the next
          test is attempted between the routers,</t>

          <t>Else the best of the 2 becomes the current best parent and the
          scan continues with the next candidate neighbor</t>

          <t>Some OFs may include a test to compare the ranks that would
          result if the node joined either router</t>
        </list>

        <t>When the scan is complete, the preferred parent is elected and
        self's rank is computed as the preferred parent rank plus the step in
        rank with that parent.</t>

        <t>Other rounds of scans might be necessary to elect alternate parents
        and siblings. In the next rounds:</t>

        <list style="symbols">
          <t>Candidate neighbors that are not in the same DODAG are
          ignored</t>

          <t>Candidate neighbors that are of greater rank than self are
          ignored</t>

          <t>Candidate neighbors of an equal rank to self (siblings) are
          ignored</t>

          <t>Candidate neighbors of a lesser rank than self (non-siblings) are
          preferred</t>
        </list>
      </list>
    </section>

    <section title="RPL Constants and Variables">
      <t>Following is a summary of RPL constants and variables. Some default
      values are to be determined in companion applicability statements.</t>

      <t><list hangIndent="6" style="hanging">
          <t hangText="ZERO_LIFETIME">This is the special value of a lifetime
          that indicates immediate death and removal. ZERO_LIFETIME has a
          value of 0.</t>

          <t hangText="BASE_RANK">This is the rank for a virtual root that
          might be used to coordinate multiple roots. BASE_RANK has a value of
          0.</t>

          <t hangText="ROOT_RANK">This is the rank for a DAG root. ROOT_RANK
          has a value of 1.</t>

          <t hangText="INFINITE_RANK">This is the constant maximum for the
          rank. INFINITE_RANK has a value of 0xFF.</t>

          <t hangText="RPL_DEFAULT_INSTANCE">This is the InstanceID that is
          used by this protocol by a node without any overriding policy.
          RPL_DEFAULT_INSTANCE has a value of 0.</t>

          <t hangText="DEFAULT_DIO_INTERVAL_MIN">To be determined</t>

          <t hangText="DEFAULT_DIO_INTERVAL_DOUBLINGS">To be determined</t>

          <t hangText="DEFAULT_DIO_REDUNDANCY_CONSTANT">To be determined</t>

          <t hangText="DEF_DAO_LATENCY">To be determined</t>

          <t hangText="MAX_DESTROY_INTERVAL">To be determined</t>

          <t hangText="DIO Timer">One instance per DODAG that a node is a
          member of. Expiry triggers DIO message transmission. Trickle timer
          with variable interval in [0,
          DIOIntervalMin..2^DIOIntervalDoublings]. See <xref
          target="TrickleImplementation"></xref></t>

          <t hangText="DAG Sequence Number Increment Timer">Up to one instance
          per DODAG that the node is acting as DAG root of. May not be
          supported in all implementations. Expiry triggers revision of
          DAGSequenceNumber, causing a new series of updated DIO message to be
          sent. Interval should be chosen appropriate to propagation time of
          DODAG and as appropriate to application requirements (e.g. response
          time vs. overhead).</t>

          <t hangText="DelayDAO Timer">Up to one instance per DA parent (the
          subset of DAG parents chosen to receive destination advertisements)
          per DODAG. Expiry triggers sending of DAO message to the DA parent.
          The interval is to be proportional to DEF_DAO_LATENCY/(node rank),
          such that nodes of greater rank (further down along the DODAG)
          expire first, coordinating the sending of DAO messages to allow for
          a chance of aggregation. See <xref target="DATimers"></xref></t>

          <t hangText="RemoveTimer">Up to one instance per DA entry per
          neighbor (i.e. those neighbors that have given DAO messages to this
          node as a DAG parent) Expiry triggers a change in state for the DA
          entry, setting up to do unreachable (No-DAO) advertisements or
          immediately deallocating the DA entry if there are no DA parents.
          The interval is min(MAX_DESTROY_INTERVAL, TBD(DIO Trickle Timer
          Interval)). See <xref target="DATimers"></xref></t>
        </list></t>
    </section>

    <section anchor="Manageability" title="Manageability Considerations">
      <t>The aim of this section is to give consideration to the manageability
      of RPL, and how RPL will be operated in LLN beyond the use of a MIB
      module. The scope of this section is to consider the following aspects
      of manageability: fault management, configuration, accounting and
      performance.</t>

      <section title="Control of Function and Policy">
        <section title="Initialization Mode">
          <t>When a node is first powered up, it may either choose to stay
          silent and not send any multicast DIO message until it has joined a
          DODAG, or to immediately root a transient DODAG and start sending
          multicast DIO messages. A RPL implementation SHOULD allow
          configuring whether the node should stay silent or should start
          advertising DIO messages.</t>

          <t>Furthermore, the implementation SHOULD to allow configuring
          whether or not the node should start sending an DIS message as an
          initial probe for nearby DODAGs, or should simply wait until it
          received DIO messages from other nodes that are part of existing
          DODAGs.</t>
        </section>

        <section title="DIO Base option">
          <t>RPL specifies a number of protocol parameters.</t>

          <t>A RPL implementation SHOULD allow configuring the following
          routing protocol parameters, which are further described in <xref
          target="DIOBase"></xref>:</t>

          <?rfc subcompact="yes"?>

          <t><list hangIndent="6" style="hanging">
              <t hangText="DAGPreference"></t>

              <t hangText="InstanceID"></t>

              <t hangText="DAGObjectiveCodePoint"></t>

              <t hangText="DAGID"></t>

              <t hangText="Destination Prefixes"></t>

              <t hangText="DIOIntervalDoublings"></t>

              <t hangText="DIOIntervalMin"></t>

              <t hangText="DIORedundancyConstant"></t>

              <t></t>

              <t hangText="DAG Root behavior:">In some cases, a node may not
              want to permanently act as a DAG root if it cannot join a
              grounded DODAG. For example a battery-operated node may not want
              to act as a DAG root for a long period of time. Thus a RPL
              implementation MAY support the ability to configure whether or
              not a node could act as a DAG root for a configured period of
              time.</t>

              <t></t>

              <t hangText="DAG Table Entry Suppression">A RPL implementation
              SHOULD provide the ability to configure a timer after the
              expiration of which the DAG table that contains all the records
              about a DAG is suppressed, to be invoked if the DAG parent set
              becomes empty.</t>
            </list></t>

          <?rfc subcompact="no"?>
        </section>

        <section title="Trickle Timers">
          <t>A RPL implementation makes use of trickle timer to govern the
          sending of DIO message. Such an algorithm is determined a by a set
          of configurable parameters that are then advertised by the DAG root
          along the DODAG in DIO messages.</t>

          <t>For each DODAG, a RPL implementation MUST allow for the
          monitoring of the following parameters, further described in <xref
          target="TrickleImplementation"></xref>:</t>

          <?rfc subcompact="yes"?>
          <t><list hangIndent="6" style="hanging">
              <t hangText="I"></t>

              <t hangText="T"></t>

              <t hangText="C"></t>

              <t hangText="I_min"></t>

              <t hangText="I_doublings"></t>
            </list></t>
          <?rfc subcompact="no"?>

          <t>A RPL implementation SHOULD provide a command (for example via
          API, CLI, or SNMP MIB) whereby any procedure that detects an
          inconsistency may cause the trickle timer to reset.</t>
        </section>

        <section title="DAG Sequence Number Increment">
          <t>A RPL implementation may allow by configuration at the DAG root
          to refresh the DODAG states by updating the DAGSequenceNumber. A RPL
          implementation SHOULD allow configuring whether or not periodic or
          event triggered mechanism are used by the DAG root to control
          DAGSequenceNumber change.</t>
        </section>

        <section title="Destination Advertisement Timers">
          <t>The following set of parameters of the DAO messages SHOULD be
          configurable:</t>

          <t><list style="symbols">
              <t>The DelayDAO timer</t>

              <t>The Remove timer</t>
            </list></t>
        </section>

        <section title="Policy Control">
          <t>DAG discovery enables nodes to implement different policies for
          selecting their DAG parents.</t>

          <t>A RPL implementation SHOULD allow configuring the set of
          acceptable or preferred Objective Functions (OF) referenced by their
          Objective Codepoints (OCPs) for a node to join a DODAG, and what
          action should be taken if none of a node's candidate neighbors
          advertise one of the configured allowable Objective Functions.</t>

          <t>A node in an LLN may learn routing information from different
          routing protocols including RPL. It is in this case desirable to
          control via administrative preference which route should be favored.
          An implementation SHOULD allow for specifying an administrative
          preference for the routing protocol from which the route was
          learned.</t>

          <t>A RPL implementation SHOULD allow for the configuration of the
          "Route Tag" field of the DAO messages according to a set of rules
          defined by policy.</t>
        </section>

        <section title="Data Structures">
          <t>Some RPL implementation may limit the size of the candidate
          neighbor list in order to bound the memory usage, in which case some
          otherwise viable candidate neighbors may not be considered and
          simply dropped from the candidate neighbor list.</t>

          <t>A RPL implementation MAY provide an indicator on the size of the
          candidate neighbor list.</t>
        </section>
      </section>

      <section title="Information and Data Models">
        <t>The information and data models necessary for the operation of RPL
        will be defined in a separate document specifying the RPL SNMP
        MIB.</t>
      </section>

      <section title="Liveness Detection and Monitoring">
        <t>The aim of this section is to describe the various RPL mechanisms
        specified to monitor the protocol.</t>

        <t>As specified in <xref target="ProtocolElements"></xref>, an
        implementation is expected to maintain a set of data structures in
        support of DAG discovery:</t>

        <t><list style="symbols">
            <t>The candidate neighbors data structure</t>

            <t>For each DODAG:</t>

            <list style="symbols">
              <t>A set of DAG parents</t>
            </list>
          </list></t>

        <section title="Candidate Neighbor Data Structure">
          <t>A node in the candidate neighbor list is a node discovered by the
          some means and qualified to potentially become of neighbor or a
          sibling (with high enough local confidence). A RPL implementation
          SHOULD provide a way monitor the candidate neighbors list with some
          metric reflecting local confidence (the degree of stability of the
          neighbors) measured by some metrics.</t>

          <t>A RPL implementation MAY provide a counter reporting the number
          of times a candidate neighbor has been ignored, should the number of
          candidate neighbors exceeds the maximum authorized value.</t>
        </section>

        <section title="Directed Acyclic Graph (DAG) Table">
          <t>For each DAG, a RPL implementation is expected to keep track of
          the following DODAG table values:</t>

          <t><list style="symbols">
              <t>DAGID</t>

              <t>DAGObjectiveCodePoint</t>

              <t>A set of Destination Prefixes offered upwards along the
              DODAG</t>

              <t>A set of DAG Parents</t>

              <t>timer to govern the sending of DIO messages for the DODAG</t>

              <t>DAGSequenceNumber</t>
            </list></t>

          <t>The set of DAG parents structure is itself a table with the
          following entries:</t>

          <t><list style="symbols">
              <t>A reference to the neighboring device which is the DAG
              parent</t>

              <t>A record of most recent information taken from the DAG
              Information Object last processed from the DAG Parent</t>

              <t>A flag reporting if the Parent is a DA Parent as described in
              <xref target="DestinationAdvertisement"></xref></t>
            </list></t>
        </section>

        <section title="Routing Table">
          <t>For each route provisioned by RPL operation, a RPL implementation
          MUST keep track of the following:</t>

          <t><list style="symbols">
              <t>Destination Prefix</t>

              <t>Destination Prefix Length</t>

              <t>Lifetime Timer</t>

              <t>Next Hop</t>

              <t>Next Hop Interface</t>

              <t>Flag indicating that the route was provisioned from one
              of:<list>
                  <t>Unicast DAO message</t>

                  <t>DIO message</t>

                  <t>Multicast DAO message</t>
                </list></t>
            </list></t>
        </section>

        <section title="Other RPL Monitoring Parameters">
          <t>A RPL implementation SHOULD provide a counter reporting the
          number of a times the node has detected an inconsistency with
          respect to a DAG parent, e.g. if the DAGID has changed.</t>

          <t>A RPL implementation MAY log the reception of a malformed DIO
          message along with the neighbor identification if avialable.</t>
        </section>

        <section title="RPL Trickle Timers">
          <t>A RPL implementation operating on a DAG root MUST allow for the
          configuration of the following trickle parameters:</t>

          <t><list style="symbols">
              <t>The DIOIntervalMin expressed in ms</t>

              <t>The DIOIntervalDoublings</t>

              <t>The DIORedundancyConstant</t>
            </list></t>

          <t>A RPL implementation MAY provide a counter reporting the number
          of times an inconsistency (and thus the trickle timer has been
          reset).</t>
        </section>
      </section>

      <section title="Verifying Correct Operation">
        <t>This section has to be completed in further revision of this
        document to list potential Operations and Management (OAM) tools that
        could be used for verifying the correct operation of RPL.</t>
      </section>

      <section title="Requirements on Other Protocols and Functional Components">
        <t>RPL does not have any impact on the operation of existing
        protocols.</t>
      </section>

      <section title="Impact on Network Operation">
        <t>To be completed.</t>
      </section>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Security Considerations for RPL are to be developed in accordance
      with recommendations laid out in, for example, <xref
      target="I-D.tsao-roll-security-framework"></xref>.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <section title="RPL Control Message">
        <t>The RPL Control Message is an ICMP information message type that is
        to be used carry DAG Information Objects, DAG Information
        Solicitations, and Destination Advertisement Objects in support of RPL
        operation.</t>

        <t>IANA has defined a ICMPv6 Type Number Registry. The suggested type
        value for the RPL Control Message is 155, to be confirmed by IANA.</t>
      </section>

      <section title="New Registry for RPL Control Codes">
        <t>IANA is requested to create a registry, RPL Control Codes, for the
        Code field of the ICMPv6 RPL Control Message.</t>

        <t>New codes may be allocated only by an IETF Consensus action. Each
        code should be tracked with the following qualities:</t>

        <t><list style="symbols">
            <t>Code</t>

            <t>Description</t>

            <t>Defining RFC</t>
          </list></t>

        <t>Three codes are currently defined:</t>

        <texttable title="RPL Control Codes">
          <ttcol align="center">Code</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0x01</c>

          <c>DAG Information Solicitation</c>

          <c>This document</c>

          <c>0x02</c>

          <c>DAG Information Object</c>

          <c>This document</c>

          <c>0x04</c>

          <c>Destination Advertisement Object</c>

          <c>This document</c>
        </texttable>
      </section>

      <section title="New Registry for the Control Field of the DIO Base">
        <t>IANA is requested to create a registry for the Control field of the
        DIO Base.</t>

        <t>New bit numbers may be allocated only by an IETF Consensus action.
        Each bit should be tracked with the following qualities:</t>

        <t><list style="symbols">
            <t>Bit number (counting from bit 0 as the most significant
            bit)</t>

            <t>Capability description</t>

            <t>Defining RFC</t>
          </list></t>

        <t>Four groups are currently defined:</t>

        <texttable title="DIO Base Flags">
          <ttcol align="center">Bit</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0</c>

          <c>Grounded DODAG</c>

          <c>This document</c>

          <c>1</c>

          <c>Destination Advertisement Trigger</c>

          <c>This document</c>

          <c>2</c>

          <c>Destination Advertisement Supported</c>

          <c>This document</c>

          <c>5,6,7</c>

          <c>DAG Preference</c>

          <c>This document</c>
        </texttable>
      </section>

      <section title="DAG Information Object (DIO) Suboption">
        <t>IANA is requested to create a registry for the DIO Base
        Suboptions</t>

        <texttable title="DAG Information Option (DIO) Base Suboptions">
          <ttcol align="center">Value</ttcol>

          <ttcol align="left">Meaning</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>0</c>

          <c>Pad1 - DIO Padding</c>

          <c>This document</c>

          <c>1</c>

          <c>PadN - DIO suboption padding</c>

          <c>This document</c>

          <c>2</c>

          <c>DAG Metric Container</c>

          <c>This Document</c>

          <c>3</c>

          <c>Destination Prefix</c>

          <c>This Document</c>

          <c>4</c>

          <c>DAG Timer Configuration</c>

          <c>This Document</c>
        </texttable>
      </section>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The authors would like to acknowledge the review, feedback, and
      comments from Emmanuel Baccelli, Dominique Barthel, Yusuf Bashir,
      Mathilde Durvy, Manhar Goindi, Mukul Goyal, Anders Jagd, Quentin Lampin,
      Jerry Martocci, Alexandru Petrescu, and Don Sturek.</t>

      <t>The authors would like to acknowledge the guidance and input provided
      by the ROLL Chairs, David Culler and JP Vasseur.</t>

      <t>The authors would like to acknowledge prior contributions of Robert
      Assimiti, Mischa Dohler, Julien Abeille, Ryuji Wakikawa, Teco Boot,
      Patrick Wetterwald, Bryan Mclaughlin, Carlos J. Bernardos, Thomas
      Watteyne, Zach Shelby, Caroline Bontoux, Marco Molteni, Billy Moon, and
      Arsalan Tavakoli, which have provided useful design considerations to
      RPL.</t>
    </section>

    <section title="Contributors">
      <t>RPL is the result of the contribution of the following members of the
      ROLL Design Team, including the editors, and additional contributors as
      listed below:</t>

      <figure>
        <artwork><![CDATA[
JP Vasseur
Cisco Systems, Inc
11, Rue Camille Desmoulins
Issy Les Moulineaux,   92782
France

Email: jpv@cisco.com
 

Jonathan W. Hui
Arch Rock Corporation
501 2nd St. Ste. 410
San Francisco, CA  94107
USA

Email: jhui@archrock.com


Thomas Heide Clausen
LIX, Ecole Polytechnique, France

Phone: +33 6 6058 9349
EMail: T.Clausen@computer.org
URI:   http://www.ThomasClausen.org/


Philip Levis
Stanford University
358 Gates Hall, Stanford University
Stanford, CA  94305-9030
USA

Email: pal@cs.stanford.edu


Richard Kelsey
Ember Corporation
Boston, MA
USA

Phone: +1 617 951 1225
Email: kelsey@ember.com


Stephen Dawson-Haggerty
UC Berkeley
Soda Hall, UC Berkeley
Berkeley, CA  94720
USA

Email: stevedh@cs.berkeley.edu


Kris Pister
Dust Networks
30695 Huntwood Ave.
Hayward,   94544
USA

Email: kpister@dustnetworks.com


Anders Brandt
Zensys, Inc.
Emdrupvej 26
Copenhagen, DK-2100
Denmark

Email: abr@zen-sys.com
    ]]></artwork>
      </figure>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>

      <?rfc include="reference.RFC.2460"?>
    </references>

    <references title="Informative References">
      <?rfc include='reference.I-D.draft-ietf-roll-building-routing-reqs-08.xml'?>

      <?rfc include='reference.I-D.draft-ietf-roll-home-routing-reqs-09.xml'?>

      <?rfc include='reference.RFC.3697'?>

      <?rfc include='reference.RFC.5673'?>

      <?rfc include="reference.RFC.5548"?>

      <?rfc include='reference.I-D.ietf-roll-terminology.xml'?>

      <?rfc include='reference.I-D.ietf-roll-routing-metrics.xml'?>

      <?rfc include='reference.I-D.tsao-roll-security-framework.xml'?>

      <?rfc include="reference.RFC.2453"?>

      <?rfc include="reference.RFC.3819"?>

      <?rfc include="reference.RFC.4101"?>

      <?rfc include="reference.RFC.4191"?>

      <?rfc include="reference.RFC.4443"?>

      <?rfc include="reference.RFC.4861"?>

      <?rfc include="reference.RFC.4915"?>

      <?rfc include="reference.RFC.5120"?>

      <?rfc include="reference.RFC.1982"?>

      <?rfc include="reference.I-D.draft-ietf-bfd-base-09.xml"?>

      <?rfc include="reference.I-D.draft-ietf-manet-nhdp-11.xml"?>

      <reference anchor="Levis08"
                 target="http://portal.acm.org/citation.cfm?id=1364804">
        <front>
          <title abbrev="Levis08">The Emergence of a Networking Primitive in
          Wireless Sensor Networks</title>

          <author fullname="Philip Levis" initials="P." surname="Levis">
            <organization></organization>
          </author>

          <author fullname="Eric Brewer" initials="E." surname="Brewer">
            <organization></organization>
          </author>

          <author fullname="David Culler" initials="D." surname="Culler">
            <organization></organization>
          </author>

          <author fullname="David Gay" initials="D." surname="Gay">
            <organization></organization>
          </author>

          <author fullname="Samuel Madden" initials="S." surname="Madden">
            <organization></organization>
          </author>

          <author fullname="Neil Patel" initials="N." surname="Patel">
            <organization></organization>
          </author>

          <author fullname="Joe Polastre" initials="J." surname="Polastre">
            <organization></organization>
          </author>

          <author fullname="Scott Shenker" initials="S." surname="Shenker">
            <organization></organization>
          </author>

          <author fullname="Robert Szewczyk" initials="R." surname="Szewczyk">
            <organization></organization>
          </author>

          <author fullname="Alec Woo" initials="A." surname="Woo">
            <organization></organization>
          </author>

          <date month="July" year="2008" />
        </front>

        <seriesInfo name="Communications of the ACM," value="v.51 n.7" />

        <format target="http://portal.acm.org/citation.cfm?id=1364804"
                type="HTML" />
      </reference>
    </references>

    <section anchor="Requirements" title="Requirements">
      <section title="Protocol Properties Overview">
        <t>RPL demonstrates the following properties, consistent with the
        requirements specified by the application-specific requirements
        documents.</t>

        <section title="IPv6 Architecture">
          <t>RPL is strictly compliant with layered IPv6 architecture.</t>

          <t>Further, RPL is designed with consideration to the practical
          support and implementation of IPv6 architecture on devices which may
          operate under severe resource constraints, including but not limited
          to memory, processing power, energy, and communication. The RPL
          design does not presume high quality reliable links, and operates
          over lossy links (usually low bandwidth with low packet delivery
          success rate).</t>
        </section>

        <section title="Typical LLN Traffic Patterns">
          <t>Multipoint-to-Point (MP2P) and Point-to-multipoint (P2MP) traffic
          flows from nodes within the LLN from and to egress points are very
          common in LLNs. Low power and lossy network Border Router (LBR)
          nodes may typically be at the root of such flows, although such
          flows are not exclusively rooted at LBRs as determined on an
          application-specific basis. In particular, several applications such
          as building or home automation do require P2P (Point-to-Point)
          communication.</t>

          <t>As required by the aforementioned routing requirements documents,
          RPL supports the installation of multiple paths. The use of multiple
          paths include sending duplicated traffic along diverse paths, as
          well as to support advanced features such as Class of Service (CoS)
          based routing, or simple load balancing among a set of paths (which
          could be useful for the LLN to spread traffic load and avoid fast
          energy depletion on some, e.g. battery powered, nodes).
          Conceptually, multiple instances of RPL can be used to send traffic
          along different topology instances, the construction of which is
          governed by different Objective Functions (OF). Details of RPL
          operation in support of multiple instances are beyond the scope of
          the present specification.</t>
        </section>

        <section title="Constraint Based Routing">
          <t>The RPL design supports constraint based routing, based on a set
          of routing metrics and constraints. The routing metrics and
          constraints for links and nodes with capabilities supported by RPL
          are specified in a companion document to this specification, <xref
          target="I-D.ietf-roll-routing-metrics"></xref>. RPL signals the
          metrics, constraints, and related Objective Functions (OFs) in use
          in a particular implementation by means of an Objective Code Point
          (OCP). Both the routing metrics, constraints, and the OF help
          determine the construction of the Directed Acyclic Graphs (DAG)
          using a distributed path computation algorithm.</t>
        </section>
      </section>

      <section title="Deferred Requirements">
        <t>NOTE: RPL is still a work in progress. At this time there remain
        several unsatisfied application requirements, but these are to be
        addressed as RPL is further specified.</t>
      </section>
    </section>

    <section anchor="Examples" title="Examples">
      <t>Consider the example LLN physical topology in <xref
      target="LLNExample"></xref>. In this example the links depicted are all
      usable L2 links. Suppose that all links are equally usable, and that the
      implementation specific policy function is simply to minimize hops. This
      LLN physical topology then yields the DAG depicted in <xref
      target="DAGExample"></xref>, where the links depicted are the edges
      toward DAG parents. This topology includes one DAG, rooted by an LBR
      node (LBR) at rank 1. The LBR node will issue DIO messages, as governed
      by a trickle timer. Nodes (11), (12), (13), have selected (LBR) as their
      only parent, attached to the DAG at rank 2, and periodically multicast
      DIOs. Node (22) has selected (11) and (12) in its DAG parent set, and
      advertises itself at rank 3. Node (22) thus has a set of DAG parents
      {(11), (12)} and siblings {((21), (23)}.</t>

      <figure anchor="LLNExample" title="Example LLN Topology">
        <artwork><![CDATA[
                                                                     
                                  (LBR)                              
                                  / | \                              
                             .---`  |  `----.                        
                            /       |        \                       
                         (11)------(12)------(13)                    
                          | \       | \       | \                    
                          |  `----. |  `----. |  `----.              
                          |        \|        \|        \             
                         (21)------(22)------(23)      (24)          
                          |        /|        /|         |            
                          |  .----` |  .----` |         |            
                          | /       | /       |         |            
                         (31)------(32)------(33)------(34)          
                          |        /| \       | \       | \          
                          |  .----` |  `----. |  `----. |  `----.    
                          | /       |        \|        \|        \   
                .--------(41)      (42)      (43)------(44)------(45)
               /         /         /| \       | \                    
         .----`    .----`    .----` |  `----. |  `----.              
        /         /         /       |        \|        \             
     (51)------(52)------(53)------(54)------(55)------(56)          
                                                                     
]]></artwork>

        <postamble>Note that the links depicted represent the usable L2
        connectivity available in the LLN. For example, Node (31) can
        communicate directly with its neighbors, Nodes (21), (22), (32), and
        (41). Node (31) cannot communicate directly with any other nodes, e.g.
        (33), (23), (42). In this example these links offer bidirectional
        communication, and `bad' links are not depicted.</postamble>
      </figure>

      <figure anchor="DAGExample" title="Example DAG">
        <artwork><![CDATA[
                                                                     
                                  (LBR)                              
                                  / | \                              
                             .---`  |  `----.                        
                            /       |        \                       
                         (11)      (12)      (13)                    
                          | \       | \       | \                    
                          |  `----. |  `----. |  `----.              
                          |        \|        \|        \             
                         (21)      (22)      (23)      (24)          
                          |        /|        /|         |            
                          |  .----` |  .----` |         |            
                          | /       | /       |         |            
                         (31)      (32)      (33)      (34)          
                          |        /| \       | \       | \          
                          |  .----` |  `----. |  `----. |  `----.    
                          | /       |        \|        \|        \   
                .--------(41)      (42)      (43)      (44)      (45)
               /         /         /| \       | \                    
         .----`    .----`    .----` |  `----. |  `----.              
        /         /         /       |        \|        \             
     (51)      (52)      (53)      (54)      (55)      (56)          
                                                                     
]]></artwork>

        <postamble>Note that the links depicted represent directed links in
        the DAG overlaid on top of the physical topology depicted in <xref
        target="LLNExample"></xref>. As such, the depicted edges represent the
        relationship between nodes and their DAG parents, wherein all depicted
        edges are directed and oriented `up' on the page toward the DAG root
        (LBR). The DAG may provide default routes within the LLN, and serves
        as the foundation on which RPL builds further routing structure, e.g.
        through the destination advertisement mechanism.</postamble>
      </figure>

      <section anchor="DestinationAdvertisementExample"
               title="Destination Advertisement">
        <t>Consider the example DAG depicted in <xref
        target="DAGExample"></xref>. Suppose that Nodes (22) and (32) are
        unable to record routing state. Suppose that Node (42) is able to
        perform prefix aggregation on behalf of Nodes (53), (54), and
        (55).</t>

        <t><list style="symbols">
            <t>Node (53) would send a DAO message to Node (42), indicating the
            availability of destination (53).</t>

            <t>Node (54) and Node (55) would similarly send DAO messages to
            Node (42) indicating their own destinations.</t>

            <t>Node (42) would collect and store the routing state for
            destinations (53), (54), and (55).</t>

            <t>In this example, Node (42) may then be capable of representing
            destinations (42), (53), (54), and (55) in the aggregation
            (42').</t>

            <t>Node (42) sends a DAO message advertising destination (42') to
            Node 32.</t>

            <t>Node (32) does not want to maintain any routing state, so it
            adds onto to the Reverse Route Stack in the DAO message and passes
            it on to Node (22) as (42'):[(42)]. It may send a separate DAO
            message to indicate destination (32).</t>

            <t>Node (22) does not want to maintain any routing state, so it
            adds on to the Reverse Route Stack in the DAO message and passes
            it on to Node (12) as (42'):[(42), (32)]. It also relays the DAO
            message containing destination (32) to Node 12 as (32):[(32)], and
            finally may send a DAO message for itself indicating destination
            (22).</t>

            <t>Node (12) is capable to maintain routing state again, and
            receives the DAO messages from Node (22). Node (12) then
            learns:</t>

            <?rfc subcompact="yes"?>

            <list style="symbols">
              <t>Destination (22) is available via Node (22)</t>

              <t>Destination (32) is available via Node (22) and the piecewise
              source route to (32)</t>

              <t>Destination (42') is available via Node (22) and the
              piecewise source route to (32), (42').</t>
            </list>

            <?rfc subcompact="no"?>

            <t>Node (12) sends DAO messages to (LBR), allowing (LBR) to learn
            routes to the destinations (12), (22), (32), and (42'). (42),
            (53), (54), and (55) are available via the aggregation (42'). It
            is not necessary for Node (12) to propagate the piecewise source
            routes to (LBR).</t>
          </list></t>
      </section>

      <section anchor="ExDAGParentSelection"
               title="Example: DAG Parent Selection">
        <t>For example, suppose that a node (N) is not attached to any DAG,
        and that it is in range of nodes (A), (B), (C), (D), and (E). Let all
        nodes be configured to use an OCP which defines a policy such that ETX
        is to be minimized and paths with the attribute `Blue' should be
        avoided. Let the rank computation indicated by the OCP simply reflect
        the ETX aggregated along the path. Let the links between node (N) and
        its neighbors (A-E) all have an ETX of 1 (which is learned by node (N)
        through some implementation specific method). Let node (N) be
        configured to send RPL DIS messages to probe for nearby DAGs.</t>

        <t><list style="symbols">
            <t>Node (N) transmits a RPL DIS message.</t>

            <t>Node (B) responds. Node (N) investigates the DIO message, and
            learns that Node (B) is a member of DAGID 1 at rank 4, and not
            `Blue'. Node (N) takes note of this, but is not yet confident.</t>

            <t>Similarly, Node (N) hears from Node (A) at rank 9, Node (C) at
            rank 5, and Node (E) at rank 4.</t>

            <t>Node (D) responds. Node (D) has a DIO message that indicates
            that it is a member of DAGID 1 at rank 2, but it carries the
            attribute `Blue'. Node (N)'s policy function rejects Node (D), and
            no further consideration is given.</t>

            <t>This process continues until Node (N), based on implementation
            specific policy, builds enough confidence to trigger a decision to
            join DAGID 1. Let Node (N) determine its most preferred parent to
            be Node (E).</t>

            <t>Node (N) adds Node (E) (rank 4) to its set of DAG parents for
            DAGID 1. Following the mechanisms specified by the OCP, and given
            that the ETX is 1 for the link between (N) and (E), Node (N) is
            now at rank 5 in DAGID 1.</t>

            <t>Node (N) adds Node (B) (rank 4) to its set of DAG parents for
            DAGID 1.</t>

            <t>Node (N) is a sibling of Node (C), both are at rank 5.</t>

            <t>Node (N) may now forward traffic intended for the default
            destination upwards along DAGID 1 via nodes (B) and (E). In some
            cases, e.g. if nodes (B) and (E) are tried and fail, node (N) may
            also choose to forward traffic to its sibling node (C), without
            making upwards progress but with the intention that node (C) or a
            following successor can make upwards progress. Should Node (C) not
            have a viable parent, it should never send the packet back to Node
            (N) (to avoid a 2-node loop).</t>
          </list></t>
      </section>

      <section anchor="ExDAGMaintenance" title="Example: DAG Maintenance">
        <figure anchor="DAGMaintenance" title="DAG Maintenance">
          <artwork><![CDATA[
                                                                     
       :                      :                      :               
       :                      :                      :               
      (A)                    (A)                    (A)              
       |\                     |                      |               
       | `-----.              |                      |               
       |        \             |                      |               
      (B)       (C)          (B)       (C)          (B)              
                 |                      |             \              
                 |                      |              `-----.       
                 |                      |                     \      
                (D)                    (D)                    (C)    
                                                               |     
                                                               |     
                                                               |     
                                                              (D)    
                                                                     
           -1-                    -2-                    -3-         
                                                                     
]]></artwork>
        </figure>

        <t>Consider the example depicted in <xref
        target="DAGMaintenance"></xref>-1. In this example, Node (A) is
        attached to a DAG at some rank d. Node (A) is a DAG parent of Nodes
        (B) and (C). Node (C) is a DAG parent of Node (D). There is also an
        undirected sibling link between Nodes (B) and (C).</t>

        <t>In this example, Node (C) may safely forward to Node (A) without
        creating a loop. Node (C) may not safely forward to Node (D),
        contained within it's own sub-DAG, without creating a loop. Node (C)
        may forward to Node (B) in some cases, e.g. the link (C)-&gt;(A) is
        temporarily unavailable, but with some chance of creating a loop (e.g.
        if multiple nodes in a set of siblings start forwarding `sideways' in
        a cycle) and requiring the intervention of additional mechanisms to
        detect and break the loop.</t>

        <t>Consider the case where Node (C) hears a DIO message from a Node
        (Z) at a lesser rank and superior position in the DAG than node (A).
        Node (C) may safely undergo the process to evict node (A) from its DAG
        parent set and attach directly to Node (Z) without creating a loop,
        because its rank will decrease.</t>

        <t>Now consider the case where the link (C)-&gt;(A) becomes nonviable,
        and node (C) must move to a deeper rank within the DAG:</t>

        <t><list style="symbols">
            <t>Node (C) must first detach from the DAG by removing Node (A)
            from its DAG parent set, leaving an empty DAG parent set. Node (C)
            may become the root of its own floating, less preferred, DAG.</t>

            <t>Node (D), hearing a modified DIO message from Node (C), follows
            Node (C) into the floating DAG. This is depicted in <xref
            target="DAGMaintenance"></xref>-2. In general, any node with no
            other options in the sub-DAG of Node (C) will follow Node (C) into
            the floating DAG, maintaining the structure of the sub-DAG.</t>

            <t>Node (C) hears a DIO message with an incremented
            DAGSequenceNumber from Node (B) and determines it is able to
            rejoin the grounded DAG by reattaching at a deeper rank to Node
            (B). Node (C) adds Node (B) to its DAG parent set. Node (C) has
            now safely moved deeper within the grounded DAG without creating
            any loops.</t>

            <t>Node (D), and any other sub-DAG of Node (C), will hear the
            modified DIO message sourced from Node (C) and follow Node (C) in
            a coordinated manner to reattach to the grounded DAG. The final
            DAG is depicted in <xref target="DAGMaintenance"></xref>-3</t>
          </list></t>
      </section>

      <section anchor="ExGreedyExample"
               title="Example: Greedy Parent Selection and Instability">
        <figure anchor="Greedy" title="Greedy DAG Parent Selection">
          <artwork><![CDATA[
                                                                     
      (A)                    (A)                    (A)              
       |\                     |\                     |\              
       | `-----.              | `-----.              | `-----.       
       |        \             |        \             |        \      
      (B)       (C)          (B)        \            |        (C)    
                               \        |            |        /      
                                `-----. |            | .-----`       
                                       \|            |/              
                                       (C)          (B)              
                                                                     
           -1-                    -2-                    -3-         
                                                                     
]]></artwork>
        </figure>

        <t>Consider the example depicted in <xref target="Greedy"></xref>. A
        DAG is depicted in 3 different configurations. A usable link between
        (B) and (C) exists in all 3 configurations. In <xref
        target="Greedy"></xref>-1, Node (A) is a DAG parent for Nodes (B) and
        (C), and (B)--(C) is a sibling link. In <xref
        target="Greedy"></xref>-2, Node (A) is a DAG parent for Nodes (B) and
        (C), and Node (B) is also a DAG parent for Node (C). In <xref
        target="Greedy"></xref>-3, Node (A) is a DAG parent for Nodes (B) and
        (C), and Node (C) is also a DAG parent for Node (B).</t>

        <t>If a RPL node is too greedy, in that it attempts to optimize for an
        additional number of parents beyond its preferred parent, then an
        instability can result. Consider the DAG illustrated in <xref
        target="Greedy"></xref>-1. In this example, Nodes (B) and (C) may most
        prefer Node (A) as a DAG parent, but are operating under the greedy
        condition that will try to optimize for 2 parents.</t>

        <t>When the preferred parent selection causes a node to have only one
        parent and no siblings, the node may decide to insert itself at a
        slightly higher rank in order to have at least one sibling and thus an
        alternate forwarding solution. This does not deprive other nodes of a
        forwarding solution and this is considered acceptable greediness.</t>

        <t><list style="symbols">
            <t>Let <xref target="Greedy"></xref>-1 be the initial
            condition.</t>

            <t>Suppose Node (C) first is able to leave the DAG and rejoin at a
            lower rank, taking both Nodes (A) and (B) as DAG parents as
            depicted in <xref target="Greedy"></xref>-2. Now Node (C) is
            deeper than both Nodes (A) and (B), and Node (C) is satisfied to
            have 2 DAG parents.</t>

            <t>Suppose Node (B), in its greediness, is willing to receive and
            process a DIO message from Node (C) (against the rules of RPL),
            and then Node (B) leaves the DAG and rejoins at a lower rank,
            taking both Nodes (A) and (C) as DAG parents. Now Node (B) is
            deeper than both Nodes (A) and (C) and is satisfied with 2 DAG
            parents.</t>

            <t>Then Node (C), because it is also greedy, will leave and rejoin
            deeper, to again get 2 parents and have a lower rank then both of
            them.</t>

            <t>Next Node (B) will again leave and rejoin deeper, to again get
            2 parents</t>

            <t>And again Node (C) leaves and rejoins deeper...</t>

            <t>The process will repeat, and the DAG will oscillate between
            <xref target="Greedy"></xref>-2 and <xref
            target="Greedy"></xref>-3 until the nodes count to infinity and
            restart the cycle again.</t>

            <t>This cycle can be averted through mechanisms in RPL: <list>
                <t>Nodes (B) and (C) stay at a rank sufficient to attach to
                their most preferred parent (A) and don't go for any deeper
                (worse) alternate parents (Nodes are not greedy)</t>

                <t>Nodes (B) and (C) do not process DIO messages from nodes
                deeper than themselves (because such nodes are possibly in
                their own sub-DAGs)</t>
              </list></t>
          </list></t>
      </section>
    </section>

    <section anchor="TODO" title="Outstanding Issues">
      <t>This section enumerates some outstanding issues that are to be
      addressed in future revisions of the RPL specification.</t>

      <section title="Additional Support for P2P Routing">
        <t>In some situations the baseline mechanism to support arbitrary P2P
        traffic, by flowing upwards along the DAG until a common ancestor is
        reached and then flowing down, may not be suitable for all application
        scenarios. A related scenario may occur when the down paths setup
        along the DAG by the destination advertisement mechanism are not be
        the most desirable downward paths for the specific application
        scenario (in part because the DAG links may not be symmetric). It may
        be desired to support within RPL the discovery and installation of
        more direct routes `across' the DAG. Such mechanisms need to be
        investigated.</t>
      </section>

      <section title="Loop Detection">
        <t>It is under investigation to complement the loop avoidance
        strategies provided by RPL with a loop detection mechanism that may be
        employed when traffic is forwarded.</t>
      </section>

      <section title="Destination Advertisement / DAO Fan-out">
        <t>When DAO messages are relayed to more than one DAG parent, in some
        cases a situation may be created where a large number of DAO messages
        conveying information about the same destination flow upwards along
        the DAG. It is desirable to bound/limit the multiplication/fan-out of
        DAO messages in this manner. Some aspects of the Destination
        Advertisement mechanism remain under investigation, such as behavior
        in the face of links that may not be symmetric.</t>

        <t>In general, the utility of providing redundancy along downwards
        routes by sending DAO messages to more than one parent is under
        investigation.</t>

        <t>The use of suitable triggers, such as the `D' bit, to trigger DA
        operation within an affected sub-DAG, is under investigation. Further,
        the ability to limit scope of the affected depth within the sub-DAG is
        under investigation (e.g. if a stateful node can proxy for all nodes
        `behind' it, then there may be no need to propagate the triggered `D'
        bit further).</t>
      </section>

      <section title="Source Routing">
        <t>In support of nodes that maintain minimal routing state, and to
        make use of the collection of piecewise source routes from the
        destination advertisement mechanism, there needs to be some
        investigation of a mechanism to specify, attach, and follow source
        routes for packets traversing the LLN.</t>
      </section>

      <section title="Address / Header Compression">
        <t>In order to minimize overhead within the LLN it is desirable to
        perform some sort of address and/or header compression, perhaps via
        labels, addresses aggregation, or some other means. This is still
        under investigation.</t>
      </section>
    </section>
  </back>
</rfc>
