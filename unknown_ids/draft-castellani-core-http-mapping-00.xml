<?xml version="1.0" encoding="us-ascii"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2046 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2046.xml">
  <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
  <!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
  <!ENTITY RFC4732 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4732.xml">
  <!ENTITY RFC5988 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5988.xml">
  <!ENTITY RFC6202 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6202.xml">  
  <!ENTITY I-D.ietf-core-coap SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-core-coap-06.xml">
  <!ENTITY I-D.ietf-core-observe SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-core-observe-02.xml">
  <!ENTITY I-D.rahman-core-groupcomm SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-rahman-core-groupcomm-05.xml">
  <!ENTITY I-D.eggert-core-congestion-control SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-eggert-core-congestion-control-01.xml">
  <!ENTITY I-D.bormann-core-simple-server-discovery SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-bormann-core-simple-server-discovery-00.xml">
  <!ENTITY I-D.vanderstok-core-bc SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-vanderstok-core-bc-03.xml">
  <!ENTITY I-D.ietf-httpbis-p1-messaging SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p1-messaging-14.xml">
  <!ENTITY I-D.thomson-hybi-http-timeout SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-thomson-hybi-http-timeout-00.xml">
  <!ENTITY I-D.shelby-core-resource-directory SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-shelby-core-resource-directory-00.xml">
  <!ENTITY I-D.hartke-core-coap-http SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-hartke-core-coap-http-00.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc strict="no"?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc ipr="trust200902"
     docName="draft-castellani-core-http-mapping-00" category='info'>
<front>

  <title abbrev="HTTP-CoAP mapping">
     Best practices for HTTP-CoAP mapping implementation
  </title>

  <author initials="A.P." surname="Castellani" fullname="Angelo P. Castellani">
    <organization>University of Padova</organization>
    <address>
	    <postal>
        <street>Via Gradenigo 6/B</street>
        <code>35131</code> 
        <city>Padova</city> 
        <country>Italy</country>
   	  </postal>
	    <email>angelo@castellani.net</email>
    </address>
  </author>
  
  <author initials="S." surname="Loreto" fullname="Salvatore Loreto">
    <organization>Ericsson</organization>
    <address>
    	<postal>
        <street>Hirsalantie 11</street>
        <code>02420</code> 
     	  <city>Jorvas</city> 
    	  <country>Finland</country>
     	</postal>
    	<email>salvatore.loreto@ericsson.com</email>
    </address>
  </author>

  <author initials="A." surname="Rahman" fullname="Akbar Rahman">
    <organization>InterDigital Communications, LLC</organization>
    <address>
        <email>Akbar.Rahman@InterDigital.com</email>
    </address>
  </author>

  <author initials="T." surname="Fossati" fullname="Thomas Fossati">
    <organization>KoanLogic</organization>
    <address>
        <postal>
          <street>Via di Sabbiuno 11/5</street>
          <city>Bologna</city>
          <code>40136</code>
          <country>Italy</country>
        </postal>
        <phone>+39 051 644 82 68</phone>
        <email>tho@koanlogic.com</email>
    </address>
  </author>

  <author initials="E." surname="Dijk" fullname="Esko Dijk">
    <organization>Philips Research</organization>
    <address>
        <email>esko.dijk@philips.com</email>
    </address>
  </author>


  <date year="2011" />
  <area>APP</area>
  <workgroup>CoRE Working Group</workgroup>
  <keyword>CoAP</keyword>
  <keyword>HTTP-CoAP mapping</keyword>
  <abstract>
    <t>This draft aims at being a base reference documentation for HTTP-CoAP proxy implementors.
    It details deployment options, discusses possible approaches for URI mapping,
    and provides useful considerations related to protocol translation.</t>
  </abstract>
</front>
<middle>

<section title="Introduction">

  <t>RESTful protocols, such as HTTP <xref target="RFC2616"/> and CoAP <xref target="I-D.ietf-core-coap"/>,
  can interoperate through an intermediary proxy which performs cross-protocol mapping.</t>

  <t>A reference about the mapping process is provided in Section 8 of <xref target="I-D.ietf-core-coap"/>.
  However, depending on the involved application, deployment scenario, or network topology,
  such mapping could be realized using a wide range of intermediaries.</t>

  <t>Moreover, the process of implementing such a proxy could be complex,
  and details regarding its internal procedures and design choices
  deserve further discussion, which is provided in this document.</t>

  <t>This draft is organized as follows:
  <list style="symbols">
    <t><xref target="terminology"/> describes terminology to identify different mapping approaches
    and the related proxy deployments;</t>
    <t><xref target="URI"/> discusses impact of the mapping on URI and describes notable options;</t>
    <t><xref target="hc"/> and <xref target="ch"/> respectively analyze the mapping from HTTP to CoAP and viceversa;</t>
    <t><xref target="sec"/> discusses possible security impact related to the mapping.</t>
  </list></t>

  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>

<section title="Terminology" anchor="terminology">
    <t>A device providing cross-protocol HTTP-CoAP mapping is called an HTTP-CoAP cross-protocol proxy (HC proxy).</t>

    <t>Regular HTTP proxies are usually same-protocol proxies, because they can map from HTTP to HTTP.
    CoAP same-protocol proxies are intermediaries for CoAP to CoAP exchanges.
    However the discussion about these entities is out-of-scope of this document.</t>

    <t>At least two different kinds of HC proxies exist:
        <list style="symbols">
            <t>One-way cross-protocol proxy (1-way proxy):
            This proxy translates from a client of a protocol to a server of another protocol but not vice-versa.</t>

            <t>Two-way (or bidirectional) cross-protocol proxy (2-way proxy):
            This proxy translates from a client of both protocols to a server supporting one protocol.</t>
        </list>
    </t>

    <t>1-way and 2-way HC proxies are realized using the following general types of proxies:
        <list style="hanging">
            <t hangText="Forward proxy (F):">
            Is a proxy known by the client (either CoAP or HTTP) used to access a specific cross-protocol server (respectively HTTP or CoAP).
            Main feature: server(s) do not require to be known in advance by the proxy (ZSC: Zero Server Configuration).</t>

            <t hangText="Reverse proxy (R):">
            Is a proxy known by the client to be the server, however for a subset of resources it works as a proxy, by knowing the real server(s) serving each resource.
            When a cross-protocol resource is accessed by a client, the request will be silently forwarded by the reverse proxy to the real server (running a different protocol).
            If a response is received by the reverse proxy, it will be mapped, if possible, to the original protocol and sent back to the client.
            Main feature: client(s) do not require to be known in advance by the proxy (ZCC: Zero Client Configuration).</t>

            <t hangText="Transparent (or Intercepting) proxy (I):">
            This proxy can intercept any origin protocol request (HTTP or CoAP) and map it to the destination protocol,
            without any kind of knowledge about the client or server involved in the exchange.
            Main feature: client(s) and server(s) do not require to be known in advance by the proxy (ZCC and ZSC).</t>
        </list>
    </t>

    <t>The proxy can be placed in the network at three different logical locations:
        <list style="hanging">
            <t hangText="Server-side proxy (SS):">
            A proxy placed on the same network domain of the server;</t>
            <t hangText="Client-side proxy (CS):">
            A proxy placed on the same network domain of the client;</t>
            <t hangText="External proxy (E):">
            A proxy placed in a network domain external to both endpoints,
            it is in the network domain neither of the client nor of the server.</t>
        </list>
    </t>

</section>

<section anchor="URI" title="Cross-protocol resource identification using URIs">
    <t>A Uniform Resource Identifier (URI) provides a simple and extensible means for identifying a resource.
    It enables uniform identification of resources via a separately defined extensible set of naming schemes <xref target="RFC3986"/>.</t>

    <t>URIs are formed of at least three components: scheme, authority and path.
    The scheme is the first part of the URI,
    and it often corresponds to the protocol used to access the resource.
    However, as noted in Section 1.2.2 of <xref target="RFC3986"/>
    the scheme does not imply that a particular protocol is used to access the resource.</t>

    <t>Clients supporting a protocol that uses URIs to identify target resources (e.g. HTTP web browsers),
    may support the resolution of a limited set of schemes (i.e. "http:", "https:").
    When such clients want to interoperate with resources available in another protocol
    (cross-protocol resources, e.g. CoAP), the existence of a URI identifying the requested
    resource in a scheme natively supported by the client,
    is useful for interoperability with clients handling only the supported schemes.</t>

    <t>Both CoAP and HTTP expose resources through a REST interface,
    so the same resource can be made available in both protocols by simply applying protocol translation.
    To this end the protocol by which the resource is actually served is not relevant at all for a client.</t>

    <t>In general two different methods can be used to access cross-protocol resources,
	    i.e. resources offered by a server using a protocol (e.g. HTTP) different from the one
	    supported by the client (e.g. CoAP),
        <list style="hanging">
            <t hangText='Protocol-aware access:'>
                The client accesses the cross-protocol resource using the URI with the native scheme
                using a cross-protocol proxy (e.g. uses coap: scheme URI embedded in the HTTP proxy request);
                both CoAP and HTTP support this access method.
                HTTP defines that proxy or servers MUST accept even an absolute-URI as request-target,
                see Section 4.1.2 of <xref target="I-D.ietf-httpbis-p1-messaging"/>.
                CoAP provides Proxy-URI option having absolute-URI as value,
                see Section 5.10.3 of <xref target="I-D.ietf-core-coap"/>.</t>
            <t hangText='Protocol-agnostic access:'>
                The client accesses the cross-protocol resource
                as if it were available in the protocol supported by the client
                (e.g. uses "http:" scheme to access a CoAP resource),
                the actual protocol translation is provided by a cross-protocol proxy.
                In order to use this method a URI identifying an equivalent resource MUST exist.</t>
        </list>
    </t>

    <t>No URI mapping is required when using protocol-aware access,
    the following section is focused on URI mapping techniques for protocol-agnostic access.</t>

    <section anchor="URI-mapping" title="URI mapping">

      <t>When accessing cross-protocol resources in a protocol-agnostic way,
      clients MUST use an URI with a scheme supported by the client
      and serving to them an equivalent resource.</t>

      <t>Because determination of equivalence or difference of URIs
      (e.g. whether or not they identify the same resource) is based on string comparison,
      URI domains using "coap:" and "http:" scheme are fully distinct:
      resources identified by the same authority and path tuple change when switching the scheme.</t>
      
      <t>Example: Assume that the following resource exists - "coap://node.coap.something.net/foo".
      The resource identified by "http://node.coap.something.net/foo" may not exist
      or be not-equivalent to the one identified by the "coap:" scheme.</t>
      
      <t>If a cross-protocol URI exists providing an equivalent representation of the native protocol resource,
      it can be available at a completely different URI (in terms of authority and path).
      The mapping of an URI between HTTP and CoAP is said HC URI mapping.</t>
      
      <t>Example: The HC URI mapping to HTTP of the CoAP resource identified
      by "coap://node.coap.something.net/foo" is "http://node.something.net/foobar".</t>

      <t>The HC URI mapping of a resource could be complex in general,
      and a proper mechanism to statically or dynamically (discover) map the resource HC URI mapping MAY be required.</t>

      <t>Two methods are proposed in the following subsections,
      that could in general reduce the complexity related to URI mapping.</t>

      <section title="Homogeneous mapping">

        <t>The URI mapping between CoAP and HTTP is called homogeneous
        when the resource can be identified either using "http:", or "coap:" scheme
        without changing neither the authority or path.</t>

        <t>Example: The CoAP resource "//node.coap.something.net/foo"
        can be accessed using CoAP at the URI "coap://node.coap.something.net/foo",
        and using HTTP at the URI "http://node.coap.something.net/foo".
        When the resource is accessed using HTTP, the mapping from HTTP to CoAP is performed by an HC proxy</t>

        <t>When homogeneous HC URI mapping is available
        HC-Intercepting (HC-I) proxies are easily implementable.</t>

      </section>
        
      <section title="Embedded mapping">

        <t>The mapping is said to be embedded,
        if the HC URI mapping of the resource embeds inside it the authority and path part of the native URI.</t>
      
        <t>Example: The CoAP resource "coap://node.coap.something.net/foo"
        can be accessed at "http://hc-proxy.something.net/coap/node.coap.something.net/foo"
        or at "http://node.coap.something.net.hc-proxy.something.net/foo".</t>

        <t>It is usually selected to minimize mapping complexity in an HC reverse proxy.</t>

      </section>
      
  </section>
    
</section>

<section title="HTTP-CoAP implementation" anchor="hc">

    <section anchor="hc-placement" title="Placement and deployment">
	    <t>In typical scenarios the HC proxy is expected to be server-side (SS), in particular
		    deployed at the edge of the constrained network.</t>

     	<t>The arguments supporting SS placement are the following:
        <list style="hanging">
	        <t hangText="TCP/UDP:">Translation between HTTP and CoAP requires also a TCP to UDP mapping;
            UDP performance over the unconstrained Internet may not be adequate.
            In order to minimize the number of required retransmissions and overall reliability,
            TCP/UDP conversion SHOULD be performed at a SS placed proxy.</t>
      
            <t hangText="Caching:">Efficient caching requires that all the CoAP traffic is intercepted by the same proxy,
            thus an SS placement, collecting all the traffic, is strategical for this need.</t>

            <t hangText="Multicast:">To support using local-multicast functionalities available in the constrained network,
            the HC proxy MAY require a network interface directly attached to the constrained network.</t>
        </list></t>

        <figure title="Server-side HC proxy deployment scenario" anchor="fig-http-coap-deployment"><artwork>
    <![CDATA[
                            +------+                                                                              
                            |      |                                                                                                                 
                            | DNS  |                                                                              
                            |      |                                                                              
                            +------+                             
                                                --------------------                                                                
                                               //                  \\                   
                                              /    /---\       /---\ \                  
                                             /     CoAP        CoAP   \                 
                                            ||     \---/       \---/  ||                               
                                      +---------+                     ||               
                                      |         |                /---\||               
                                      |HTTP/CoAP|                CoAP ||               
                                      |         |                \---/||               
    +------+                          +---------+                     ||               
    |HTTP  |                                ||   /---\                ||                
    |Client|                                ||   CoAP                 ||                
    +------+                                 \   \---/                /                                 
                                              \           /---\      /                   
                                               \          CoAP      /                    
                                                \\        \---/   //                      
                                                 ------------------               
    ]]>
        </artwork></figure>

        <t>Other important aspects involved in the selection of which type of proxy deployment,
        whose choice impacts its placement too, are the following:
        <list style="hanging">

            <t hangText="Client/Proxy/Network configuration overhead:">
            Forward proxies require either static configuration or discovery support in every client.
            Reverse proxies require either static configuration, server discovery or embedded URI mapping in the proxy.
            Intercepting proxies typically require single router configuration for a whole network.</t>

            <t hangText="Scalability/Availability:">
            Both aspects are typically addressed using redundancy.
            CS deployments, due to the limited catchment area and administrative-wide domain of operation,
            have looser requirements on this.
            SS deployments, in dense/popular/critical environments, have stricter requirements and MAY need to be replicated.
            Stateful proxies (e.g. reverse) may be complex to replicate.</t>
      
        </list></t>
        
        <t>Discussion about security impacts of different deployments is covered in <xref target="sec"/>.</t>

        <t><xref target="tab-hc-deployments"/> shows some interesting HC proxy deployment scenarios,
        and notes the advantages related to each scenario.</t>

        <texttable title="Interesting HC proxy deployments" anchor="tab-hc-deployments">
            <ttcol align='left'> Feature </ttcol>
            <ttcol align='right'> F CS </ttcol>
            <ttcol align='right'> R SS </ttcol>
            <ttcol align='right'> I SS </ttcol>

            <c> TCP/UDP </c>
            <c> - </c>
            <c> + </c>
            <c> + </c>

            <c> Multicast </c>
            <c> - </c>
            <c> + </c>
            <c> + </c>

            <c> Caching </c>
            <c> - </c>
            <c> + </c>
            <c> + </c>

            <c> Scalability/Availability </c>
            <c> + </c>
            <c> +/- </c>
            <c> + </c>

            <c> Configuration </c>
            <c> - </c>
            <c> - </c>
            <c> + </c>
        </texttable>
        
        <t>Guidelines proposed in the previous paragraphs have been used to fill out the above table.
        In the first three rows, it can be seen that SS deployment is preferred versus CS.
        Scalability/Availability issues can be generally handled, but some complexity may be involved in reverse
        proxies scenarios. Configuration overhead could be simplified when intercepting proxies deployments
        are feasible.</t>
        
        <t>When support for legacy HTTP clients is required,
        it may be preferrable using configuration/discovery free deployments.
        Discovery procedures for client or proxy auto-configuration are still under active-discussion:
        see <xref target="I-D.vanderstok-core-bc"/>, <xref target="I-D.bormann-core-simple-server-discovery"/>
        or <xref target="I-D.shelby-core-resource-directory"/>.
        Static configuration of multiple forward proxies is typically not feasible in existing HTTP clients.</t>
        
    </section>
    
    <section title="Basic mapping">
        <t>The mapping of HTTP requests to CoAP and of the response back to HTTP
        is defined in Section 8.2 of <xref target="I-D.ietf-core-coap"/>.</t>

        <t>The mapping of a CoAP response code to HTTP is not straightforward,
        this mapping MUST be operated accordingly to Table 4 of <xref target="I-D.ietf-core-coap"/>.</t>
        
        <t>No upper bound is defined for a CoAP server to provide the response,
        thus for long delays the HTTP client or any other proxy in between MAY timeout,
        further considerations are available in Section 7.1.4 of <xref target="I-D.ietf-httpbis-p1-messaging"/>.</t>

        <t>The HC proxy MUST define an internal timeout for each CoAP request pending,
        because the CoAP server MAY silently die before completing the request.</t>
        
        <t>Even if the DNS protocol may not be used inside the constrained network,
        maintaining valid DNS entries describing the hosts available on such network
        helps offering the CoAP resources to HTTP clients.</t>
        
        <t>An example of the usefulness of such entries is described in <xref target="hc-v4v6"/>.</t>
        
        <t>HTTP connection pipe-lining is transparent to the CoAP network,
        the HC proxy will sequentially serve the requests by issuing different CoAP requests.</t>
        
        <section title="Caching and congestion control" anchor="hc-caching"> <!-- discuss cache-control -->
            <t>The HC proxy SHOULD limit the number of requests to CoAP servers
            by responding, where applicable, with a cached representation of the resource.</t>

            <t>In the case of a multicast request,
            because of the inherent unreliable nature of the NON messages involved,
            and dynamic membership of multicast groups,
            immediately responding only with previously cached responses and
            without issuing a new request to the multicast group,
            could lead to duplicate partial representations of the multicast resource.</t>
            
            <t>Duplicate idempotent pending requests to the same resource SHOULD in general be avoided,
            by duplexing the response to the relevant hosts without duplicating the request.
            <!--
            The same consideration apply if multiple active HTTP subscriptions involve the same observe relationship.
            -->
            </t>
            
            <t>If the HTTP client times out and drops the HTTP session to the proxy (closing the TCP connection),
            the HC proxy SHOULD wait for the response and cache it if possible.
            Further idempotent requests to the same resource can use the result present in cache,
            or if a response has still to come requests will wait on the open CoAP session.</t>

            <t>Traffic related to resources experiencing a recurrently high access rate
            MAY be reduced by establishing with that resources an observe session <xref target="I-D.ietf-core-observe"/>,
            that will keep updated the cached representation of the target resource.</t>
            
            <t>Depending upon the particular deployment MAY exist server or resources highly impacted by congestion,
            i.e. multicast resources (see <xref target="hc-multicast"/>), popular servers.
            Careful considerations are required about the caching policies for those resources,
            also considering possible security implications related to those specific targets.</t>
            
            <t>To this end when traffic reduction obtained by the caching mechanism is not adequate,
            the HC proxy could apply stricter policing by limiting the amount of aggregate traffic to the constrained network.
            More specifically the HC proxy SHOULD pose a strict upper limit to the number of concurrent CoAP request pending
            directed to the same constrained network, further request MAY either be queued or dropped.
            In order to successfully apply this congestion control, the HC proxy SHOULD be SS placed.</t>
            
            <t>Further discussion on congestion control can be found in <xref target="I-D.eggert-core-congestion-control"/>.</t>
       </section>
       
        <section title="Use case: HTTP/IPv4-CoAP/IPv6 proxy" anchor="hc-v4v6">
            <t>This section covers the expected common use case of when an HTTP/IPv4 client
		    desires to get access to a CoAP/IPv6 resource.</t>
            
            <t>Whereas HTTP/IPv4 is today the most widely adopted communication in the Internet,
            a pervasive deployment of constrained nodes exploiting the IPv6 address space is expected.</t>
            
            <t>Enabling direct interoperability of such technologies is valuable.
            An HC proxy supporting IPv4/IPv6 mapping is said to be a v4/v6 proxy.</t>
        
            <t>An HC v4/v6 proxy SHOULD always try to resolve the URI authority,
            and SHOULD prefer using the IPv6 resolution if available.
            The authority section of the URI is thus used internally by the HC proxy
            and SHOULD not be mapped to CoAP.</t>
        
            <t><xref target="fig-simple-http-coap"/> shows an HTTP client on IPv4 (C)
            accessing a CoAP server on IPv6 (S) through an HC proxy on IPv4/IPv6 (P).
            "node.coap.something.net" has an A record containing the IPv4 address of the HC proxy,
            and an AAAA record containing the IPv6 of the CoAP server.</t>

            <figure title="HTTP/IPv4 to CoAP/IPv6 mapping" anchor="fig-simple-http-coap"><artwork>
<![CDATA[
C     P     S
|     |     |
|     |     |  Source: IPv4 of C
|     |     |  Destination: IPv4 of P
+---->|     |  GET /foo HTTP/1.1
|     |     |  Host: node.coap.something.net
|     |     |  ..other HTTP headers ..
|     |     |
|     |     |  Source: IPv6 of P
|     |     |  Destination: IPv6 of S
|     +---->|  CON GET
|     |     |  URI-Path: foo
|     |     |
|     |     |  Source: IPv6 of S
|     |     |  Destination: IPv6 of P
|     |<----+  ACK
|     |     |
|     |     |  ... Time passes ...
|     |     |
|     |     |  Source: IPv6 of S
|     |     |  Destination: IPv6 of P
|     |<----+  CON 2.00
|     |     |  "bar"
|     |     |
|     |     |  Source: IPv6 of P
|     |     |  Destination: IPv6 of S
|     +---->|  ACK
|     |     |
|     |     |  Source: IPv4 of P
|     |     |  Destination: IPv4 of C
|<----+     |  HTTP/1.1 200 OK
|     |     |  .. other HTTP headers ..
|     |     |
|     |     |  bar
|     |     |
]]>
            </artwork></figure>

            <t>The proposed example shows the HC proxy operating also the mapping between IPv4
            to IPv6 using the authority information available in any HTTP 1.1 request.
            Thus IPv6 connectivity is not required at the HTTP client
            when accessing a CoAP server over IPv6 only, which is a typical expected use case.</t>

            <t>When P is an intercepting HC proxy, the CoAP request SHOULD have the IPv6 address of C as source
            (IPv4 can always be mapped into IPv6).</t>
            
            <t>The described solution takes into account only the HTTP/IPv4 clients accessing CoAP/IPv6 servers;
            this solution does not provide a full fledged mapping from HTTP to CoAP.</t>
            
            <t>In order to obtain a working deployment for HTTP/IPv6 clients,
            a different HC proxy access method may be required,
            or Internet AAAA records should not point to the node anymore
            (the HC proxy should use a different DNS database pointing to the node).</t>

            <t>When an HC intercepting proxy deployment is used
            this solution is fully working even with HTTP/IPv6 clients.</t>
            
        </section>

    </section>
    
    <section title="Multiple message exchanges mapping">
      <t>This section discusses the mapping of some advanced CoAP features (e.g. multicast, observe) to HTTP 
      which involves the need to asynchronously deliver multiple responses within the same HTTP request.</t>

      <section title="Relevant features of existing standards">

        <t>Various features provided by existing standards are useful to efficiently represent sessions involving multiple messages.</t>

      	<section title="Multipart messages">

          <t>In particular the "multipart/*" media type, defined in Section 5.1 of <xref target="RFC2046"/>,
          is a suitable solution to deliver multiple CoAP responses within a single HTTP payload.
          Each part of a multipart entity SHOULD be represented using "message/http" media type
          containing the full mapping of a single CoAP response as previously described.</t>

        </section>

        <section title="Immediate message delivery">

          <t>An HC proxy may prefer to transfer each CoAP response immediately after its reception.
          This is possible thanks to the HTTP Transfer-Encoding "chunked",
          that enables transferring single responses without any further delay.</t>

          <t>A detailed discussion on the use of chunked Transfer-Encoding to stream data
          over HTTP can be found in <xref target="RFC6202"/>.
          Large delays between chunks can lead the HTTP session to timeout,
          more details on this issue can be found in <xref target="I-D.thomson-hybi-http-timeout"/>.</t>

          <t>The HC proxy MAY reduce internal buffering by providing responses to HTTP client without any delay;
          each CoAP response can be immediately streamed using HTTP chunked Transfer-Encoding.
          This chunked encoding was not shown in order to simplify <xref target="fig-multicast-http-coap"/>,
          where the proxy returns all responses in one payload after a timeout expires.
          An example showing immediate delivery of CoAP responses using chunks is provided in
          <xref target="hc-subscription"/>,
          while describing its application to an observe session.</t>

    	  </section>

        <section title="Detailing source information">
          <t>Under some circumstance responses may come from different sources (i.e. responses to a multicast request);
          in this case details about the actual source of each CoAP response SHOULD be provided to the client.
          Source information can be represented using HTTP Web Linking as defined in <xref target="RFC5988"/>,
          by adding the actual source URI into each response using Link option with "via" relation type.</t>
        </section>

      </section> <!-- standard features section -->


      <section title="Multicast mapping" anchor="hc-multicast">

        <t>In order to establish a multicast communication such a feature should be offered either
        by the network (i.e. IP multicast, link-layer multicast, etc.) or by a gateway (i.e. the HC proxy).
        Rationale on the methods available to obtain such a feature is out-of-scope of this document, and
        extensive discussion of group communication techniques is available in
       	<xref target="I-D.rahman-core-groupcomm"/>.</t>

        <t>Additional considerations related to handling multicast requests mapping are detailed in the
       	following sections.</t>

        <section title="URI identification and mapping">

        <t>In order to successfully handle a multicast request, the HC proxy MUST successfully perform the
		       	following tasks on the URI:
          <list style="hanging">
            <t hangText="Identification:">The HC proxy MUST understand whether the requested URI identifies a group of nodes.</t>
            <t hangText="Mapping:">The HC proxy MUST know how to distribute the multicast request to involved servers;
            this process is specific of the group communication technology used.</t>
          </list></t>

          <t>When using IPv6 multicast paired with DNS,
          the mapping to IPv6 multicast is simply done using DNS resolution.
          If the group management is performed at the proxy,
          the URI or part of it (i.e. the authority) can be mapped using some static or
          dynamic table available at the HC proxy.
          In Section 3.5 of <xref target="I-D.rahman-core-groupcomm"/> discusses a method to build
          and maintain a local table of multicast authorities.</t>

        </section>
  
        <section title="Request handling">

          <t>When the HC proxy receives a request to a URI
          that has been successfully identified and mapped to a group of nodes,
          it SHOULD start a multicast proxying operation, if supported by the proxy.</t>

          <t>Multicast request handling consists of the following steps:
          <list style="hanging">

            <t hangText="Multicast TX:">The HC proxy sends out the request on the CoAP side
            by using the methods offered by the specific group communication technology used in the constrained network;</t>

            <t hangText="Collecting RXs:">The HC proxy collects every response related to the request;</t>

            <t hangText="Timeout:">The HC proxy will pay special attention in multicast timing,
            detailed discussion about timing depends upon the particular group communication technology used;</t>

            <t hangText="Distributing RXs to the client:">The HC proxy can distribute the responses in two different ways:
            batch delivering them at the end of the process or on timeout,
            or immediately delivering them as they are available.
            Batch requires more caching and introduces delays but may lead to lower TCP overhead and simpler processing.
            Immediate is the converse.
            A trade-off solution of partial batch delivery may also be feasible and efficient in some circumstances.</t>

          </list></t>         

        </section>

        <section title="Example">

          <t><xref target="fig-multicast-http-coap"/> shows an HTTP client (C) requesting the resource "/foo"
        	to a group of CoAP servers (S1/S2/S3) through an HC proxy (P) which uses IP multicast to send the 
        	corresponding CoAP request.</t>

        	<figure title="Unicast HTTP to multicast CoAP mapping" anchor="fig-multicast-http-coap"><artwork>
<![CDATA[
C     P     S1    S2    S3
|     |     |     |     |
+---->|     |     |     |  GET /foo HTTP/1.1
|     |     |     |     |  Host: group-of-nodes.coap.something.net
|     |     |     |     |  .. other HTTP headers ..
|     |     |     |     |
|     +---->|---->|---->|  NON GET
|     |     |     |     |  URI-Path: foo
|     |     |     |     |
|     |<----------+     |  NON 2.00
|     |     |     |     |  "S2"
|     |     |     |     |
|     | X---------------+  NON 2.00
|     |     |     |     |  "S3"
|     |     |     |     |
|     |<----+     |     |  NON 2.00
|     |     |     |     |  "S1"
|     |     |     |     |
|     |     |     |     |  ... Timeout ...
|     |     |     |     |
|<----+     |     |     |  HTTP/1.1 200 OK
|     |     |     |     |  Content-Type: multipart/mixed; boundary="response"
|     |     |     |     |  .. other HTTP headers ..
|     |     |     |     |
|     |     |     |     |  --response
|     |     |     |     |  Content-Type: message/http
|     |     |     |     |
|     |     |     |     |  HTTP/1.1 200 OK
|     |     |     |     |  Link: <http://node2.coap.something.net/foo>; rel=via
|     |     |     |     |
|     |     |     |     |  S2
|     |     |     |     |
|     |     |     |     |  --response
|     |     |     |     |  Content-Type: message/http
|     |     |     |     |
|     |     |     |     |  HTTP/1.1 200 OK
|     |     |     |     |  Link: <http://node1.coap.something.net/foo>; rel=via
|     |     |     |     |
|     |     |     |     |  S1
|     |     |     |     |
|     |     |     |     |  --response--
|     |     |     |     |
]]>
          </artwork></figure>

          <t>The example proposed in the above diagram does not make any assumption
          on which underlying group communication technology is available in the constrained network.
          Some detailed discussion is provided about it along the following lines.</t>

          <t>C makes a GET request to group-of-nodes.coap.something.net.
          This domain name MAY either resolve to the address of P,
          or to the IPv6 multicast address of the nodes (if IP multicast is supported and P is an intercepting proxy),
          or the proxy P is specifically known by the client that sends this request to it.</t>

          <t>To successfully start multicast proxying operation,
          the HC proxy MUST know that the destination URI involves a group of CoAP servers,
          e.g. the authority group-of-nodes.coap.something.net is known to identify a group of nodes
          either by using an internal lookup table, using DNS paired with IPv6 multicast, or by using some
          other special technique.</t>

          <t>A specific implementation option is proposed to further explain the proposed example.
          Assume that DNS is configured such that all subdomain queries to coap.something.net,
          such as group-of-nodes.coap.something.net, resolve to the address of P.
          P performs the HC URI mapping by removing the "coap" subdomain from the authority and by switching
          the scheme from "http" to "coap"
          (result: "coap://group-of-node.something.net/foo");
          "group-of-nodes.something.net" is resolved to an IPv6 multicast address to which S1, S2 and S3 belong.
          The proxy handles this request as multicast and sends the request "GET /foo" to the multicast group .</t>	
				</section>
					
      </section> <!-- multicast section -->


      <section title="Subscription mapping" anchor="hc-subscription">
          <t>TBD</t>
      </section> <!-- subscription section -->

    </section>
   
</section>

<section title="CoAP-HTTP implementation" anchor="ch">

  <t>Discussion about CoAP-HTTP mapping implementation considerations
  is available in Section 3 of <xref target="I-D.hartke-core-coap-http"/>.</t>

<!--
    TODO Introduction and typical use-cases
    
    <section title="Placement">
        <t>Specific discussion about CoAP-HTTP proxy placement</t>
    </section>
    
    <section title="Basic mapping">
        <t>discussion about basic proxy implementation</t>
    </section>
-->
    
</section>

<section title="Security Considerations" anchor="sec">

    <t>The security concerns raised in Section 15.7 of <xref target="RFC2616" /> also apply to the HC proxy scenario. 
    In fact, the HC proxy is a trusted (not rarely a transparently trusted) component in the network path.
    Also, a reverse proxy deployed at the boundary of constrained network is an easy single point of failure
    for reducing availability.
    As such, a special care should be taken in designing, developing and operating it.
    In most cases it could have fewer constraints than the constrained devices.</t>

    <t>The following sub paragraphs categorize and argue about a set of specific security issues related to the translation,
    caching and forwarding functionality exposed by an HC proxy module.</t>


    <section title="Traffic overflow">
    
        <t>Due to the generally constrained nature of a CoAP network,
        particular attention SHOULD be posed in the implementation of traffic reduction
        mechanisms (see <xref target="hc-caching"/>),
        because inefficient implementations can be targeted by unconstrained Internet attackers.
        Bandwidth or complexity involved in such attacks is very low.</t>  

        <t>An amplification attack to the constrained network MAY be triggered by a multicast request
        generated by a single HTTP request mapped to a CoAP multicast resource,
        as considered in Section XX of <xref target="I-D.ietf-core-coap"/>.</t> 

        <t>The impact of this amplification technique is higher than an amplification attack
       	carried out by a malicious constrained device
        (i.e. ICMPv6 flooding, like Packet Too Big, or Parameter Problem on a multicast
       	destination <xref target="RFC4732" />),
        since it does not require direct access to the constrained network.</t>
        
        <t>The feasibility of this attack, disruptive in terms of CoAP server availability, can be limited by
        access controlling the exposed HTTP multicast resource, so that only known/authorized users access such URIs.</t>

    </section>

    <section anchor="sec_mapping" title="Cross-protocol security policy mapping">

        <t>At the moment of this writing, CoAP and HTTP are missing any cross-protocol security policy mapping.</t>

        <t>The HC proxy SHOULD flexibly support security policies between the two protocols,
        possibly as part of the HC URI mapping function,
        in order to statically map HTTP and CoAP security policies at the proxy.</t> 

        <t>Example: This can be provided using mod_rewrite-like syntax:
        <figure><artwork>
        <![CDATA[
Sec_Context_DTLS_1 {
    # define credentials, supported ciphersuite, etc.
}

# Map 'https://my/mote-5/path_and_query' to 
# 'coap://mote-5/path_and_query' using the 
# security policy defined in 'Sec_Context_DTLS_1'
MapRule ^https://my/mote-([0-9])/(.*$)  \
            coap://mote-$1/$2           \
            ${Sec_Context_DTLS_1}

# Apply homogeneous mapping of URLs in the http schema, 
# with no security policy.
MapRule ^http://.*$      \
            coap://$1    \
            NoSec
        ]]>
        </artwork></figure> 
        </t>

    </section>

    <section title="Handling secured exchanges">

        <t>It is possible that the request from the client to the HC proxy is sent over a secured connection.
        However, there may or may not exist a secure connection mapping to the other protocol.
        For example, a secure distribution method for multicast traffic is complex and MAY not be
       	implemented (see <xref target="I-D.rahman-core-groupcomm"/>).</t>

        <t>An HC proxy SHOULD reject secured request if there is not a corresponding secure mapping.
        The HC proxy MAY still decide to process an incoming secured request, even in the absence of a secure mapping.</t>

        <t>Example: Assume that CoAP nodes are isolated behind a secure firewall
        (e.g. as the SS HC proxy deployment shown in <xref target="fig-http-coap-deployment"/>),
        and the HC proxy cannot perform any secure CoAP mapping.
        In this scenario, the HC proxy may be configured to translate anyway the incoming HTTPS request
        using CoAP NoSec mode, as the internal CoAP network is believed to be secure.</t>

        <t>The HC URI mapping MUST NOT map to HTTP (see <xref target="URI-mapping"/>)
        a CoAP resource intended to be accessed only using HTTPS.</t>

        <t>A secured connection that is terminated at the HC proxy, i.e. the proxy decrypts secured data locally,
        raises an ambiguity about the cacheability of the requested resource.
        The HC proxy SHOULD NOT cache any secured content to avoid any leak of secured information.
        However in some specific scenario, a security/efficiency trade-off could motivate caching secured information;
        in that case the caching behavior MAY be tuned to some extent on a per-resource basis (see <xref target="sec_mapping" />).</t>

    </section>

    <section title="Spoofing and Cache Poisoning">

      <!-- TODO add references -->

      <t>In web security jargon, the "cache poisoning" verb accounts for attacks
      where an evil user causes the proxy server to associate incorrect content to a cached resource,
      which work through especially crafted HTTP requests or request/response combos.</t>

      <t>When working in CoAP NoSec mode, the use of UDP makes cache poisoning on the constrained network easy and effective,
      simple address spoofing by a malicious host is sufficient to perform the attack.
      The implicit broadcast nature of typical link-layer communication technologies used in constrained networks
      lead this attack to be easily performed by any host, even without the requirement of being a router in the network.
      The ultimate outcome depends on both the order of arrival of packets (legitimate and rogue);
      attackers targeting this weakness may have less requirements on timing,
      thus leading the attack to succeed with high probability.</t>

      <t>In case the threat of a rogue mote acting in the constrained network can't be winded up by
      appropriate procedural means,
      the only way to avoid such attacks is for any CoAP server to work
      at least in MultiKey mode with a 1:1 key with the HC proxy.
      SharedKey mode would just mitigate the attack,
      since a guessable MIDs and Tokens generation function at the HC proxy side
      would make it feasible for the evil mote to implement a "try until succeed" strategy. 
      Also, (authenticated) encryption at a lower layer (MAC/PHY) could be defeated
      by a slightly more powerful attacker, a compromised router mote.</t>.

    </section>

    <section title="Subscription">
        <!-- TODO ask Klaus about observe + intermediaries and loops (Sec 7. of draft-ietf-core-observe-02). -->

        <t>As noted in Section 7 of <xref target="I-D.ietf-core-observe" />,
        when using the observe pattern, an attacker could easily impose resource exhaustion on a naive server
        who's indiscriminately accepting observer relationships establishment from clients.
        The converse of this problem is also present, a malicious client may also target the HC proxy itself,
        by trying to exhaust the HTTP connection limit of the proxy by opening multiple subscriptions to some CoAP resource.</t>  

        <t>Effective strategies to reduce success of such a DoS on the HTTP side
        (by forcing prior identification of the HTTP client via usual web authentication mechanisms),
        must always be weighted against an acceptable level of usability of the exposed CoAP resources.</t>

    </section>

</section>

<section title="Acknowledgements">

  <t>Thanks to
  Klaus Hartke,
  Zach Shelby,
  Carsten Bormann,
  Michele Rossi,
  Nicola Bui,
  Michele Zorzi,
  Peter Saint-Andre,
  Cullen Jennings,
  Kepeng Li,
  Brian Frank,
  Peter Van Der Stok,
  Kerry Lynn,
  Linyi Tian,
  Dorothy Gellert
  for helpful comments and discussions that have shaped the document.</t>

</section>

</middle>

<back>

    <references title="Normative References">
        &RFC2046;
        &RFC2119;
        &RFC2616;
        &RFC3986;
        &RFC5988;
        &I-D.ietf-core-coap;
        &I-D.ietf-core-observe;
        &I-D.rahman-core-groupcomm;
        &I-D.ietf-httpbis-p1-messaging;
        &I-D.thomson-hybi-http-timeout;
    </references>

    <references title="Informative References">
        &RFC4732;
        &RFC6202;
        &I-D.vanderstok-core-bc;
        &I-D.bormann-core-simple-server-discovery;
        &I-D.eggert-core-congestion-control;
        &I-D.shelby-core-resource-directory;
        &I-D.hartke-core-coap-http;
    </references>

</back>

</rfc>

<!-- Change log 


-->
<!-- LocalWords: xref CDATA exploders BUA -->


