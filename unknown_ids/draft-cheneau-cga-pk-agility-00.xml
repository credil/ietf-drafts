<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'[
		       <!ENTITY RFC3972 SYSTEM
		       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3972.xml">
		       <!ENTITY RFC3279 SYSTEM
		       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3279.xml">
		       <!ENTITY RFC5280 SYSTEM
		       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
		       <!ENTITY RFC3971 SYSTEM
		       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3971.xml">
		       <!ENTITY RFC4581 SYSTEM
		       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4581.xml">
		       <!ENTITY RFC4861 SYSTEM
		       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4861.xml">
		       <!ENTITY RFC4866 SYSTEM
		       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4866.xml">
		       <!ENTITY RFC4982 SYSTEM
		       "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4982.xml">

]>
<?rfc toc="yes"?>
<rfc ipr='trust200811' docName='draft-cheneau-cga-pk-agility-00'>
	<front>
		<title abbrev="Signature Algorithm Agility for CGAs">
			Support for Multiple Signature Algorithms in Cryptographically Generated 
				Addresses (CGAs)
		</title>
		<author initials="T.C" surname="Cheneau" fullname="Tony Cheneau">
			<organization abbrev="TMSP">
				Institut TELECOM, TELECOM SudParis, CNRS SAMOVAR UMR 5157 
			</organization>
			<address>
				<postal>
					<street>9 rue Charles Fourier </street>
					<city>Evry</city>
					<code>91011</code>
					<country>France</country>
				</postal>
				<email>tony.cheneau@it-sudparis.eu</email>
			</address>
		</author>
		<author initials="M.M" surname="Maknavicius" fullname="Maryline Laurent-Maknavicius">
			<organization abbrev="TMSP">
				Institut TELECOM, TELECOM SudParis, CNRS SAMOVAR UMR 5157 
			</organization>
			<address>
				<postal>
					<street>9 rue Charles Fourier </street>
					<city>Evry</city>
					<code>91011</code>
					<country>France</country>
				</postal>
				<email>maryline.maknavicius@it-sudparis.eu</email>
			</address>
		</author>
		<author initials="S.S" surname="Sean" fullname="Sean Shen">
			<organization abbrev="Huawei">Huawei</organization>
			<address>
				<email>sshen@huawei.com</email>
			</address>
		</author>
		<author initials="M.C.V"  surname="Vanderveen" fullname="Michaela Vanderveen">
			<organization abbrev="Qualcomm">
				Qualcomm
			</organization>
			<address>
				<email>mvandervn@gmail.com</email>
			</address>
		</author>
		<date month="February" year="2009"/>
		<area>Internet</area>
		<workgroup>CGA &amp; Send maintenance</workgroup>
		<keyword>CGA</keyword>
		<keyword>extension</keyword>
		<keyword>ECDSA</keyword>
		<abstract>                                     
			<t> <!-- This memo describes an extension field of the "CGA Parameters" field of the 
				Neighbor Discovery Protocol (NDP) CGA option. --> 
				This document defines an extension field for the CGA Parameter data structure specified in RFC 3972.  This extension field carries a Public Key that is used in Cryptographically Generated Address (CGA) generation. This extension enables protocols using CGAs, such as SEND, to use multiple Public Key signing algorithms and/or multiple Public Keys.</t> 
			<!-- MCV: Tony's request for title now in the abstract: 
			"The title should reflect theses two aspects:
				 - more than one public key
				 - more than one public key type" -->
			
		</abstract>

	</front>
<middle>
	<section anchor="introduction" title="Introduction">
		<t>   	Cryptographically Generated Addresses (CGA) <xref target="RFC3972"/> have been
			designed primarily for securing Neighbor Discovery <xref target="RFC3971"/>.
		                A digital signature algorithm is used to 
			provide authentication and integrity protection when CGA is used.  
			CGAs <xref target="RFC3972"/> were defined to only use RSA as the associated signature algorithm. 
			Only one RSA public key is associated with a CGA and this public key  is carried in 
			the Public Key field of the CGA Parameter data structure. 
	</t>
		<t>	The secure neighbor discovery  usage scenarios have recently been extended 
			to include environments with mobile or nomadic nodes. These nodes can often be
			limited in power and memory capabilities, and thus may only be able to support
			lightweight public key cryptography; that is, RSA-based public keys and algorithm 
			support may not be feasible. </t>
		<t>        Therefore, support for signature 	algorithm agility in CGA is desired. However, 
			since the CGA specification <xref target="RFC3972"/> states that SEND "SHOULD" 
			use an RSA public/private key pair,  backward compatibility is preserved herein.   
		</t>
		<t>	A logical place for extending the CGA Parameter data structure to include other
			types of public keys is its "extension fields". Some guidance on the format of 
			these extensions is provided in <xref target="RFC4581"/>.
			One type of CGA Parameter data structure extension is defined in 
			<xref target="sec-PK_ext"/> and this type of extension is able to carry public keys,
			in addition to the RSA public key defined in the Public Key field of CGA Parameters data structure.  
		</t>

			<t>
				These extensions allows new functionnalities on CGA based protocols, such as the Signature Algorithm Agility in SEND <xref target="cheneau-send-sig-agility"/>.
			</t>
	</section>

	<section anchor="sec-PK_ext" title="Public Key extension">
		<t>This section describes an extension field that conforms to the guidelines of <xref target="RFC4581" />.</t>
		<t>This extension allows a CGA Parameters data structure to carry  public keys in addition to the key in the Public Key field. 
			This approach paves the way for one CGA to possibly be associated with multiple public keys.</t>
		<t>This extension allows a node to select a Public Key value that is different from the one in the Public Key field of the CGA Parameters data 
			structure option. This Public Key is placed in an extension embedded in the Extension field of the CGA Parameters data structure,
			described in <xref target="RFC3972" />.</t>
		<section title="Public Key extension format">
<!--		<figure anchor="fig-PK_ext" title="Public Key extension format">
			<artwork align="left"><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Extension Type        |      Extension Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                       Public Key                              ~
   |                                                               |
   +                               +-+-+-+- - - - - - - - -+-+-+-+-+
   |                               |          Padding              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
	</figure>
-->
		<figure anchor="fig-PK_ext" title="Public Key extension format">
			<artwork align="left"><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Extension Type        |      Extension Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                       Public Key                              ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
	</figure>
	                                                                                                                        
			<t>
				<list style="hanging">
					<t hangText="Extension Type"> <vspace blankLines="1"/>TBA. (16-bit unsigned integer. See <xref target="sec-iana"/>.)</t>
<!--					<t hangText="Extension Length"><vspace blankLines="1"/> 16-bit unsigned integer. The length of the option 
						(including the Extension Type, Extension Length, Public Key and Padding fields) in units of 8 octets. The value 0 is invalid.</t> -->
					<t hangText="Extension Length"><vspace blankLines="1"/> The length of the Public Key field to follow, in octets.
						16-bit unsigned integer. </t>
					<t hangText="Public Key"><vspace blankLines="1"/> 
					
			This is a variable-length field containing the public key of the
			sender.  The public key MUST be formatted as a DER-encoded
			<xref target="ITU.X690.2002"/> ASN.1 structure of the type SubjectPublicKeyInfo,
			defined in the Internet X.509 certificate profile <xref target="RFC5280"/>.  
			<!-- SubjectPublicKeyInfo ::= SEQUENCE { algorithm AlgorithmIdentifier,
				subjectPublicKey BIT STRING } -->
			When RSA is used, the algorithm identifier MUST be rsaEncryption, which is
			1.2.840.113549.1.1.1, and the RSA public key MUST be formatted by
			using the RSAPublicKey type as specified in Section 2.3.1 of  <xref target="RFC3279"/>.  
			The RSA key length SHOULD be at least 384 bits.
						<vspace blankLines="1"/>		
			When ECC is used, the algorithm identifier MUST be of type id-ecPublicKey (OID 1.2.840.10045.2.1), as defined in  
			<xref target="ID-pkix-ecc"/>. <!-- currently in the RFC Ed queue -->ECC public key encoding is specified in this reference.
			<!-- MM:  id-ecPublicKey OBJECT IDENTIFIER ::= {
			       iso(1) member-body(2) us(840) ansi-X9-62(10045) keyType(2) 1 }", so OID is 1.2.840.10045.2.1
		       	      You need to describe more precisely the Public Key content for ECC. -->
			      Note that the ECC key lengths are determined by the ECParameters field named namedCurves (curves implying key length).
			      <!-- M.M: I'd suppress the (curves implying key length) | TC: I think it's useful to keep it for now, maybe in later versions-->
			      <!--			      [MCV: There has to be a way to signal what curve
			      the key is taken from. We know how to do that for
			      certificates. But this is not our case. 
			      TC: it is defined in the draft-ietf-pkix-ecc-subpubkeyinfo-11 (and most probably in other standards, this is the field namedCurves. 
						Since curves are of fixed length: one name = one length.] -->
					<!--	<t>Draft XXX specify ASN.1 rules for ECC keys encoding. For example, 
						namedCurve secp256r1 of OID 1.2.840.10045.3.1.7 refers to 
						P-256 ECC curve as defined in [FIPS186-3].</t> -->
						<vspace blankLines="1"/>
			
			<!-- The length of this Public Key field is determined by the DER encoding. -->
			
					</t>
 <!--					<t hangText="Padding"><vspace blankLines="1"/>A variable length field. The size of the Padding 
					field is determined by size contained in the Extension Length field minus the size of the Public Key field.</t>  -->
<!--					<t>New Public Key types MUST be defined in new documents that update 
						the companion draft [draft-cheneau-pki-agility?].</t>	 -->
		</list>
		</t>
		</section>
		</section>

		<section title="CGA Generation Process" anchor="sec-cga-gen"> 
			<!-- To me, this is redundant with the next paragraph
		<t> The CGA Generation Process remains the same as in  <xref target="RFC3972" />.
		More specifically,  a CGA can be generated using two public keys: one public key (e.g., RSA) stored in the "Public Key" field of the
		CGA Parameters data structure, and another public key (e.g., ECC) stored in the Public Key Extension field. Note that
		the hash values are computed over the entire CGA Parameters data structure, including all extension fields.
	</t> -->
<!--		<t> Unfortunately, 	
				<xref target="RFC3971"/> states that the Public Key field of the CGA structure option MUST be RSA. 
				We feel that  this specification needs to be updated to leave the signing algorithm to be decided on a local policy basis. 
				To achieve this goal, the proposal herein is partially (depending on local policy) backward compatible, but any 
				existing implementations can still perform 
				Neighbor Discovery, with nodes that do not support RSA [TC: I don't quite understand the end of the sentence. 
				Does it mean "non-RSA nodes can still perform SEND among them" ?]. In a nutshell, the "MUST" relating to the
				 RSA signature is demoted 
				to a "SHOULD" or a "MAY".
		</t>  -->
		<t> When a node supports two or more types of signing algorithms, and is able to generate two or more corresponding public keys, 
				then it can derive a single CGA using all these keys. The  derivation is done exactly as in <xref target="RFC3972"/>; one key is
				placed in the CGA Parameters data structure "Public Key" field  while the rest of the keys are  placed in separate extension fields . This is illustrated in <xref target="multi-cga"/>.
		</t>
		<t>It should be noted that the type of the public key (RSA, ECC, etc.) is already encoded into the 
			"Public Key" field itself, and thus there is no need to identify the public key type separately. This is due to the fact that the "Public Key" field, according to
			<xref target="RFC3972"/> is a DER-encoded ASN.1 structure of the type "SubjectPublicKeyInfo", and therefore
			includes a subfield called "AlgorithmIdentifier". 
		</t>
			
			<!-- Insert ASCII art with a picture of both KUs going into a hash function, out comes one CGA -->
			<!-- TC: pretty different picture here, I think it better illustrate the problem -->

			<figure anchor="multi-cga" title="CGA parameter structure with multiple keys">
		<artwork align="left"><![CDATA[
  List of keys             CGA parameter Data structure

                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                       |                             |
                       +         Modifier            |
                       |                             |
                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                       |                             |
                       +      Subnet Prefix          +
                       |                             |
                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                       |Col Count|                   |
+-+-+-+-+-+-+-+-+      +-+-+-+-+-+
|               |      |        Public Key           |
~  Public Key 1 ~ ->   ~                             ~
|               |      |     (variable length)       |
+-+-+-+-+-+-+-+-+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+-+-+-+-+-+-+-+-+      |         Extension           |
|               |      ~       Public Key 2          ~
~  Public Key 2 ~ ->   |     (variable length)       |
|               |      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+-+-+-+-+-+-+-+-+      |                             |
                       ~           ...               ~
                       |                             |
+-+-+-+-+-+-+-+-+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               |      |         Extension           |
~  Public Key N ~ ->   ~       Public Key N          ~
|               |      |     (variable length)       |
+-+-+-+-+-+-+-+-+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                       |      Extension Fields       |
                       ~                             ~ 
                       | (optional, variable length) |
                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

		       ]]></artwork>
			</figure>
			                                    
			<!-- M.M: shouldn't the "as per" transformed in "as in" ? -->
		<t> The resulting CGA Parameters data structure is inserted into a CGA option as per <xref target="RFC3971"/>. 
				When sending a NDP packet, the node includes this CGA option and also one signature option of choice,
				computed with a private key whose corresponding Public Key is present in the CGA Parameters data structure.
				This signature option can be the RSA signature option as per <xref target="RFC3971"/>,
			or another signature option, e.g. the ECC signature option as per <xref target="ID-csi-ecc"/>,
			or any other signature defined. The signature option contains the hash of the key used to sign
				the message. 
		</t>

		<t>Note that an implementation should choose the number of simultaneous Public Key Extensions fields used so as the
			total length of the extension fields does not exceed a threshold that requires fragmentation support at the
			SEND or other upper-layer protocol layer.
			</t>

		<!-- TC agrees with the CAPSLOCKED text -->
		<t>Support for RSA Public Keys and signature algorithm is only RECOMMENDED for backward compatibility. 
			This specification does not mandate support for any particular public key signature algorithm. 
			Therefore, nodes can be configured to choose/support only a single additional signature algorithm 
			besides RSA. However, a node is also free to not support RSA and still claim 
			compatibility with this specification. 
		</t>
		<t> Since <xref target="RFC3972"/>  mandates the use of RSA  keys in the Public Key field, a node compatible with
			<xref target="RFC3972"/> only will  extract the RSA public key from the Public Key field and ignore the extension fields.
			Therefore, in order to achieve backward compatibility, if a node uses a CGA associated with multiple public keys (through 
			the use of the Public Key extension), the following procedures are in place: if one of the public keys is of RSA type, 
			then that key SHOULD be placed in the Public Key field of the CGA Parameter data structure, while the other
			key(s) SHOULD  be placed in the Extension field(s).  
			<!-- Comment to be deleted once Michaela agrees: TC agrees with mail of Sean, this text is not 100% useful, so I propose its removal 
			If no keys are of RSA type, then these keys CAN be placed 
			without any constrains.	-->
			<!-- M.M thinks the current text is alright, we shouldn't change it -->
			<!-- M.M there should be a section "CGA parsing process" explaining how a receiver interpret a received CGA, for the -01 version -->
		</t>

<!--
		<t>A node not supporting one or both algorithms should still be able to re-derive the CGA value. Naturally, a node
				can verify the validity of the CGA only if it supports the signing algorithm that was used by the sender to generate
				the specific NDP signature option.
		</t>
-->         <!--  This is like SeND processing rule, not proper in CGA definition  -->

			<!-- I am not sure about the need for a universal signature option. I think the Type field is long enough 
			that we just add signatures based on type; this should work and is easy to implement.
			Also, the Supported PKI extension: this is only to allow negotiations-->
	</section>
	<section title="Security Consideration" anchor="sec-consideration"> 
		<t> The document specifies a CGA extension field format. No additional vulnerabilities 
			appear besides those  described in section 7 of  <xref target="RFC3972"/></t>.  
		<t> However , it should be noted that the resulting security level of a multiple-key CGA is only that of the weakest key. 
			Therefore, the requirement remains that every key in use should have a security level matching or exceeding
			that of a 384-bit RSA key.</t>
	                <!-- To remains compatible with the statement of the
			document <xref target="RFC3971"/>, this document state
			that each key should have a strength at least
			equivalent to a 384-bit RSA key. MCV>> What statement??  Even if that rfc said 384, times have 
			changed and that too may need updating -->
		<t>	Whenever protocols negotiate signature algorithms, downgrade attacks are considered. 
			This document only provides the ability for CGA options to carry multiple public keys;
			negotiations of signature algorithms or public keys are out of the scope of this document.
		</t>
	</section>

	<section title="IANA Considerations" anchor="sec-iana">
		
		<t> This document defines one new CGA Extension Type <xref target="RFC4581"/> option, which must
			be assigned by IANA: <list>
				<t>Name: Public Key Extension Type; </t>
				<t> Value: TBA. </t>
				<t> Description: see <xref target="sec-PK_ext"/>.
				</t>
			</list>
		</t>
	</section>
	
</middle>

<back>
		<references title="Normative References">
			&RFC5280;
			&RFC3972;
			&RFC3971;
			&RFC4982;
			&RFC4861;
		</references>
		<references title="Informative References">
			&RFC4581; 
			&RFC3279;
			&RFC4866;

			<reference anchor="ITU.X690.2002">
				<front>
					<title>Information Technology - ASN.1 encoding rules:
						Specification of Basic Encoding Rules (BER),
						Canonical Encoding Rules (CER) and Distinguished
						Encoding Rules (DER)</title>
					<author>
						<organization abbrev="ITU">
							International Telecommunication Union
						</organization>
					</author>
					<date month="July" year="2002"/>

				</front>
					<seriesInfo name="ITU-T Recommandation" value="X.690"/>
			
			</reference>
			<reference anchor='ID-csi-ecc'>
				<front>
					<title>ECC Support for SEND/CGA</title>
					
					<author initials='S' surname='Shen' fullname='Sean Shen'>
						<organization />
					</author>
					<author initials='M' surname='Vanderveen' fullname='Michaela Vanderveen'>
						<organization />
					</author>
					
					<date month='October' day='11' year='2008' />
					
					<abstract><t>This draft proposes an upgrade to the SEND/CGA protocols to incorporate support for
						elliptic curve cryptography.</t></abstract>
					
				</front>
				
				<seriesInfo name='Internet-Draft' value='draft-shen-csi-ecc-01' />
				<format type='TXT'
					target='http://www.ietf.org/internet-drafts/draft-shen-csi-ecc-01.txt' />
			</reference>
			
			<reference anchor='ID-pkix-ecc'>
				<front>
					<title>Elliptic Curve Cryptography Subject Public Key Information		
					</title>
					
					<author initials='S' surname='Turner' fullname='S. Turner'>
						<organization />
					</author>
					<author initials='et.' surname='al' fullname='et. al.'>
						<organization />
					</author>
					
					<date month='December' day='11' year='2008' />
					
					<abstract><t>This document specifies the syntax and semantics for the Subject
						Public Key Information field in certificates that support Elliptic
						Curve Cryptography.  This document updates Sections 2.3.5 and 5, and
						the ASN.1 module of Algorithms and Identifiers for the Internet X.509......</t></abstract>
					
				</front>
				
				<seriesInfo name='Internet-Draft' value='draft-ietf-pkix-ecc-subpubkeyinfo-11' />
				<format type='TXT'
					target='http://www.ietf.org/internet-drafts/draft-ietf-pkix-ecc-subpubkeyinfo-11.txt' />
			</reference>
			<reference anchor='cheneau-send-sig-agility'>
				<front>
					<title>
						Signature Algorithm Agility in the Secure Neighbor Discovery (SEND) Protocol
					</title>
					<author initials='T' surname='Cheneau' fullname='Tony Cheneau'>
						<organization />
					</author>
					<author initials='M' surname='Laurent-Maknavicius' fullname='Maryline Laurent-Maknavicius'>
						<organization />
					</author>
					<author initials='S' surname='Shen' fullname='Sean Shen'>
						<organization />
					</author>
					<author initials='M' surname='Vanderveen' fullname='Michaela Vanderveen'>
						<organization />
					</author>
					
					<date month='Feb'  year='2009' />
					
					<abstract><t>This draft describes a mechanism to enable the Secure Neighbor Discovery (SEND) protocol to select
				between different signature algorithms to use with Cryptographically Generated Addresses (CGA). 
				It also provides optional support for interoperability between nodes that do not share any 
				common signature algorithms.</t></abstract>

				</front>
				<seriesInfo name='Internet-Draft' value='draft-cheneau-send-sig-agility-00' />
				<format type='TXT'
					target='http://www.ietf.org/internet-drafts/draft-cheneau-send-sig-agility-00.txt' />
			</reference>

		</references>
</back> 

</rfc>	
