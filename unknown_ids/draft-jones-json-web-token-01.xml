<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY OASIS.saml-core-2.0-os PUBLIC "" "http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml">
<!ENTITY W3C.CR-xml11-20021015 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-xml11-20021015.xml">
<!ENTITY RFC1738 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1738.xml">
<!ENTITY RFC2045 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY RFC2104 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC3275 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3275.xml">
<!ENTITY RFC3339 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
<!ENTITY RFC3447 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY RFC3629 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml">
<!ENTITY RFC3986 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4122 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4122.xml">
<!ENTITY RFC4627 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC4648 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC5226 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC5280 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
]>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-jones-json-web-token-01"
     ipr="trust200902">
  <front>
    <title>JSON Web Token (JWT) - Claims and Signing</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones"> <!-- role="editor" -->
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
      <organization>Google</organization>
      <address>
	<email>balfanz@google.com</email>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>independent</organization>
      <address>
	<email>ve7jtb@ve7jtb.com</email>
      </address>
    </author>

    <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland">
      <organization>Microsoft</organization>
      <address>
	<email>yarong@microsoft.com</email>
      </address>
    </author>

    <author fullname="John Panzer" initials="J." surname="Panzer">
      <organization>Google</organization>
      <address>
	<email>jpanzer@google.com</email>
      </address>
    </author>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>Nomura Research Institute</organization>
      <address>
	<email>n-sakimura@nri.co.jp</email>
      </address>
    </author>

    <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
      <organization>Facebook</organization>
      <address>
	<email>paul.tarjan@facebook.com</email>
      </address>
    </author>

    <date day="04" month="January" year="2011" />

    <area>Applications</area>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>Assertion</keyword>
    <keyword>Claim</keyword>
    <keyword>Simple Web Token</keyword>
    <keyword>Security Token</keyword>
    <keyword>SWT</keyword>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>

    <abstract>
      <t>
	JSON Web Token (JWT) is a means of representing signed content
	using JSON data structures, including claims to be transferred
	between two parties.  The claims in a JWT are encoded as a
	JSON object that is digitally signed and optionally encrypted.
	Encryption for JWTs is described in a separate companion
	specification.
      </t>
      <t>
        The suggested pronunciation of JWT is the same as the English
        word "jot".
      </t>
    </abstract>

    <note title="Requirements Language">
      <t>
	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
	NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
	"OPTIONAL" in this document are to be interpreted as described
	in <xref target="RFC2119">RFC 2119</xref>.
      </t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	JSON Web Token (JWT) is a compact token format intended for
	space constrained environments such as HTTP Authorization
	headers and URI query parameters. JWTs encode claims to be
	transmitted as a JSON object (as defined in <xref
	target="RFC4627">RFC 4627</xref>) that is base64url encoded
	and digitally signed.  The JWT signature mechanisms are
	independent of the type of content being signed, allowing
	arbitrary content to be signed.  Encryption for JWTs is
	described in a separate companion specification.
      </t>
      <t>
        The suggested pronunciation of JWT is the same as the English
        word "jot".
      </t>
    </section>

    <section title="Terminology">
      <t>
	<list style="hanging">

          <t hangText="JSON Web Token (JWT)">
	    A data structure containing three JWT Token Segments: the
	    JWT Header Segment, the JWT Payload Segment, and the JWT
	    Crypto Segment.  The JWT Payload Segment typically
	    represents a set of claims convened by the JWT as a JSON
	    object, but in the general case, may represent arbitrary
	    signed content.
	  </t>
          <t hangText="JWT Compact Serialization">
	    A data structure representing a JWT as a string consisting
	    of three JWT Token Segments: the JWT Header Segment, the
	    JWT Payload Segment, and the JWT Crypto Segment, in that
	    order, with the segments being separated by period ('.')
	    characters.
	  </t>
          <t hangText="JWT JSON Serialization">
	    A data structure representing a JWT as a JSON object with
	    members for each of three kinds of JWT Token Segments: a
	    "header" member whose value is a non-empty array of JWT
	    Header Segments, a "payload" member whose value is the JWT
	    Payload Segment, and a "signature" member whose value is a
	    non-empty array of JWT Crypto Segments, where the
	    cardinality of both arrays is the same.
	  </t>
          <t hangText="JWT Token Segment">
	    One of the three parts that make up a JSON Web Token
	    (JWT).  JWT Token Segments are always base64url encoded
	    values.
	  </t>
          <t hangText="JWT Header Segment">
	    A JWT Token Segment containing a base64url encoded JSON
	    object that describes the signature applied to the JWT
	    Header Segment and the JWT Payload Segment.
	  </t>
          <t hangText="JWT Payload Segment">
	    A JWT Token Segment containing base64url encoded
	    content.  This may be a JWT Claims Object.
	  </t>
          <t hangText="JWT Crypto Segment">
	    A JWT Token Segment containing base64url encoded
	    cryptographic signature material that secures the JWT
	    Header Segment's and the JWT Payload Segment's contents.
	  </t>
          <t hangText="Decoded JWT Header Segment">
	    A JWT Header Segment that has been base64url decoded
	    back into a JSON object.
	  </t>
          <t hangText="Decoded JWT Payload Segment">
	    A JWT Payload Segment that has been base64url decoded.  If
	    the corresponding JWT Payload Segment is a JWT Claims
	    Object, this will be a Decoded JWT Claims Object.
	  </t>
          <t hangText="Decoded JWT Crypto Segment">
	    A JWT Crypto Segment that has been base64url decoded back
	    into cryptographic material.
	  </t>
          <t hangText="JWT Claims Object">
	    A base64url encoded JSON object that represents the claims
	    contained in the JWT.
	  </t>
          <t hangText="Decoded JWT Claims Object">
	    A JSON object that represents the claims contained in the JWT.
	  </t>
	  <t hangText="JWT Signing Input">
	    The concatenation of the JWT Header Segment, a period
	    ('.') character, and the JWT Payload Segment.
	  </t>
	  <t hangText="Digital Signature">
	    For the purposes of this specification, we use this term
	    to encompass both Hash-based Message Authentication Codes
	    (HMACs), which can provide authenticity but not
	    non-repudiation, and digital signatures using public key
	    algorithms, which can provide both.  Readers should be
	    aware of this distinction, despite the decision to use a
	    single term for both concepts to improve readability of
	    the specification.
	  </t>
          <t hangText="Base64url Encoding">
	    For the purposes of this specification, this term always
	    refers to the he URL- and filename-safe Base64 encoding
	    described in <xref target="RFC4648">RFC 4648</xref>,
	    Section 5, with the '=' padding characters omitted, as
	    permitted by Section 3.2; see <xref
	    target="base64urllogic"></xref> for more details.
	  </t>
	  <t hangText="Header Parameter Names">
	    The names of the members within the JSON object
	    represented in a JWT Header Segment.
	  </t>
	  <t hangText="Header Parameter Values">
	    The values of the members within the JSON object
	    represented in a JWT Header Segment.
	  </t>
	  <t hangText="Claim Names">
	    The names of the members of the JSON object represented
	    in a JWT Claims Object.
	  </t>
	  <t hangText="Claim Values">
	    The values of the members of the JSON object represented
	    in a JWT Claims Object.
	  </t>
        </list>
      </t>
    </section>

    <section title="JSON Web Token (JWT) Overview">

      <t>
	JWTs represent content that is base64url encoded and digitally
	signed, and optionally encrypted, using JSON data structures;
	this content is typically a set of claims represented as a
	JSON object.
      </t>
      <t>
        When the JWT payload is a set of claims, the claims are
        represented as name/value pairs that are members of a JSON
        object.  The JSON object is base64url encoded to produce the
        JWT Claims Object, which is used as the JWT Payload
        Segment. An accompanying base64url encoded JSON header - the
        JWT Header Segment - describes the signature method used.
      </t>
      <t>
	The names within the header object MUST be unique.  The
	names within the header object are referred to as Header
	Parameter Names.  The corresponding values are referred to as
	Header Parameter Values.  Likewise, if the payload
	represents a JWT Claims Object, the names within the claims
	object MUST be unique.  The names within the claims object are
	referred to as Claim Names.  The corresponding values are
	referred to as Claim Values.
      </t>
      <t>
	JWTs contain a signature that ensures the integrity of the
	content of the JWT Header Segment and the JWT Payload
	Segment.  This signature value is carried in the JWT Crypto
	Segment.  The JSON Header object MUST contain an "alg"
	parameter, the value of which is a string that unambiguously
	identifies the algorithm used to sign the JWT Header Segment
	and the JWT Payload Segment to produce the JWT Crypto Segment.
      </t>

      <section title="Example JWT" anchor="ExampleJWT">

	<t>
	  The following is an example of a JSON object that can be
	  encoded to produce a JWT Claims Object:
	</t>

	<artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

	<t>
	  Base64url encoding the UTF-8 representation of the JSON
	  object yields this JWT Claims Object, which is used as the
	  JWT Payload Segment:
	</t>

	<artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

	<t>
	  The following example JSON header object declares that the
	  encoded object is a JSON Web Token (JWT) and the JWT Header
	  Segment and the JWT Payload Segment are signed using the HMAC
	  SHA-256 algorithm:
	</t>

	<artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork>

	<t>
	  Base64url encoding the UTF-8 representation of the JSON
	  header object yields this JWT Header Segment value:
	</t>

	<artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork>

	<t>
	  Signing the UTF-8 representation of the JWT Signing Input
	  (the concatenation of the JWT Header Segment, a period ('.')
	  character, and the JWT Payload Segment) with the HMAC
	  SHA-256 algorithm and base64url encoding the result, as per
	  <xref target="SigningWithHMACSHA256"></xref>, yields this
	  JWT Crypto Segment value:
	</t>

	<artwork><![CDATA[dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork>

	<t>
	  Concatenating these segments in the order
	  Header.Payload.Signature with period characters between the
	  segments yields this complete JWT using the JWT Compact
	  Serialization (with line breaks for display purposes only):
	</t>

	<artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork>

	<t>
	  This computation is illustrated in more detail in <xref
	  target="HMACSHA256Example"></xref>.
	</t>

      </section>
    </section>

    <section title="JWT Claims">

      <t>
	If the JWT contains a set of claims represented as a JSON
	object, then the members of the JSON object represented by the
	Decoded JWT Claims Object decoded from the JWT Payload Segment
	contain the claims. Note however, that the set of claims a JWT
	must contain to be considered valid is context-dependent and
	is outside the scope of this specification.  When used in a
	security-related context, implementations MUST understand and
	support all of the claims present; otherwise, the JWT MUST be
	rejected for processing.
      </t>

      <t>
        There are three classes of JWT Claim Names: Reserved Claim
        Names, Public Claim Names, and Private Claim Names.
      </t>

      <section title="Reserved Claim Names" anchor="ReservedClaimName">
	<t>
	  The following claim names are reserved. None of the claims
	  defined in the table below are intended to be mandatory, but
	  rather, provide a starting point for a set of useful,
	  interoperable claims.  All the names are short because a
	  core goal of JWTs is for the tokens themselves to be short.
	</t>

	<texttable title="Reserved Claim Definitions" anchor="ClaimTable">

	  <ttcol align="left">Claim Name</ttcol>
	  <ttcol align="left">JSON Value Type</ttcol>
	  <ttcol align="left">Claim Syntax</ttcol>
	  <ttcol align="left">Claim Semantics</ttcol>

	  <c>exp</c>
	  <c>integer</c>
	  <c>IntDate</c>
	  <c>
	    The "exp" (expiration time) claim identifies the
	    expiration time on or after which the token MUST NOT be
	    accepted for processing.  The processing of the "exp"
	    claim requires that the current date/time MUST be before
	    the expiration date/time listed in the "exp"
	    claim. Implementers MAY provide for some small leeway,
	    usually no more than a few minutes, to account for clock
	    skew.  This claim is OPTIONAL.
	  </c>

	  <c>iss</c>
	  <c>string</c>
	  <c>StringAndURI</c>
	  <c>
	    The "iss" (issuer) claim identifies the principal that
	    issued the JWT.  The processing of this claim is generally
	    application specific.  This claim is OPTIONAL.
	  </c>

	  <c>aud</c>
	  <c>string</c>
	  <c>StringAndURI</c>
	  <c>
	    The "aud" (audience) claim identifies the audience that
	    the JWT is intended for.  The principal intended to
	    process the JWT MUST be identified by the value of the
	    audience claim. If the principal processing the claim does
	    not identify itself with the identifier in the "aud" claim
	    value then the JWT MUST be rejected.  The interpretation
	    of the contents of the audience value is generally
	    application specific.  This claim is OPTIONAL.
	  </c>

	  <c>typ</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The "typ" (type) claim is used to declare a type for the
	    contents of this JWT.  This claim is OPTIONAL.
	  </c>

	</texttable>

	<t>
	  Additional reserved claim names MAY be defined via the IANA
	  JSON Web Token Claims registry, as per <xref target="IANA"
	  />.  The syntax values used above and in <xref
	  target="HeaderParameterTable" /> are defined as follows:
	</t>

	<texttable anchor="SyntaxDefinitions">
	  <ttcol align="left">Syntax Name</ttcol>
	  <ttcol align="left">Syntax Definition</ttcol>

	  <c>IntDate</c>
	  <c>
	    The number of seconds from 1970-01-01T0:0:0Z as measured
	    in UTC until the desired date/time. See <xref
	    target="RFC3339">RFC 3339</xref> for details regarding
	    date/times in general and UTC in particular.
	  </c>

	  <c>String</c>
	  <c>
	    Any string value MAY be used.
	  </c>

	  <c>StringAndURI</c>
	  <c>
	    Any string value MAY be used but a value containing a ":"
	    character MUST be a URI as defined in <xref
	    target="RFC3986">RFC 3986</xref>.
	  </c>

	  <c>URI</c>
	  <c>
	    A URI as defined in <xref target="RFC3986">RFC 3986</xref>.
	  </c>

	  <c>URL</c>
	  <c>
	    A URL as defined in <xref target="RFC1738">RFC 1738</xref>.
	  </c>
	</texttable>

      </section>

      <section title="Public Claim Names" anchor="PublicClaimName">

        <t>
	  Claim names can be defined at will by those using
	  JWTs. However, in order to prevent collisions, any new claim
	  name SHOULD either be defined in the IANA JSON Web Token
	  Claims registry or be defined as a URI that contains a
	  collision resistant namespace. Examples of collision
	  resistant namespaces include:

          <list style="symbols">
            <t>
	      Domain Names,
	    </t>
            <t>
	      Object Identifiers (OIDs) as defined in the ITU-T X 660
	      and X 670 Recommendation series or
	    </t>
            <t>
	      Universally Unique IDentifier (UUID) as defined in <xref
	      target="RFC4122">RFC 4122</xref>.
	    </t>
          </list>

          In each case, the definer of the name or value MUST take
          reasonable precautions to make sure they are in control of
          the part of the namespace they use to define the claim
          name.</t>
      </section>

      <section title="Private Claim Names" anchor="PrivateClaimName">

         <t>
	   A producer and consumer of a JWT may agree to any claim
	   name that is not a Reserved Name <xref
	   target="ReservedClaimName"></xref> or a Public Name <xref
	   target="PublicClaimName"></xref>. Unlike Public Names,
	   these private names are subject to collision and should be
	   used with caution.
	 </t>

      </section>
    </section>

    <section title="JWT Header">

      <t>
	The members of the JSON object represented by the Decoded JWT
	Header Segment describe the signature applied to the JWT
	Header Segment and the JWT Payload Segment and optionally
	additional properties of the JWT.  Implementations MUST
	understand the entire contents of the header; otherwise, the
	JWT MUST be rejected for processing.
      </t>

      <section title="Reserved Header Parameter Names" anchor="ReservedHeaderParameterName">
	<t>
	  The following header parameter names are reserved.  All
	  the names are short because a core goal of JWTs is for the
	  tokens themselves to be short.
	</t>

	<texttable title="Reserved Header Parameter Definitions" anchor="HeaderParameterTable">

	  <ttcol align="left">Header Parameter Name</ttcol>
	  <ttcol align="left">JSON Value Type</ttcol>
	  <ttcol align="left">Header Parameter Syntax</ttcol>
	  <ttcol align="left">Header Parameter Semantics</ttcol>

	  <c>alg</c>
	  <c>string</c>
	  <c>StringAndURI</c>
	  <c>
	    The "alg" (algorithm) header parameter identifies the
	    cryptographic algorithm used to secure the JWT.  A list of
	    reserved alg values is in <xref target="AlgTable"></xref>.
	    The processing of the "alg" (algorithm) header
	    parameter, if present, requires that the value of the
	    "alg" header parameter MUST be one that is both
	    supported and for which there exists a key for use with
	    that algorithm associated with the issuer of the JWT.
	    This header parameter is REQUIRED.
	  </c>

	  <c>typ</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The "typ" (type) header parameter is used to declare
	    that this data structure is a JWT.  If a "typ" parameter
	    is present, it is RECOMMENDED that its value be "JWT".
	    This header parameter is OPTIONAL.
	  </c>

	  <c>jku</c>
	  <c>string</c>
	  <c>URL</c>
	  <c>
	    The "jku" (JSON Key URL) header parameter is a URL that
	    points to JSON-encoded public key certificates that can be
	    used to validate the signature.  The specification for
	    this encoding is TBD.  This header parameter is OPTIONAL.
	  </c>

	  <c>kid</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The "kid" (key ID) header parameter is a hint indicating
	    which specific key owned by the signer should be used to
	    validate the signature.  This allows signers to explicitly
	    signal a change of key to recipients. Omitting this
	    parameter is equivalent to setting it to an empty string.
	    The interpretation of the contents of the "kid" parameter
	    is unspecified.  This header parameter is OPTIONAL.
	  </c>

	  <c>x5u</c>
	  <c>string</c>
	  <c>URL</c>
	  <c>
	    The "x5u" (X.509 URL) header parameter is a URL that
	    points to an X.509 public key certificate that can be used
	    to validate the signature.  This certificate MUST conform
	    to <xref target="RFC5280">RFC 5280</xref>.  This header
	    parameter is OPTIONAL.
	  </c>

	  <c>x5t</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The "x5t" (x.509 certificate thumbprint) header parameter
	    provides a base64url encoded SHA-256 thumbprint
	    (a.k.a. digest) of the DER encoding of an X.509
	    certificate that can be used to match a certificate.  This
	    header parameter is OPTIONAL.
	  </c>

	</texttable>

	<t>
	  Additional reserved header parameter names MAY be defined
	  via the IANA JSON Web Token Header Parameters registry, as
	  per <xref target="IANA" />.  The syntax values used above
	  and in <xref target="ClaimTable" /> are defined in <xref
	  target="SyntaxDefinitions" />.
	</t>

      </section>

      <section title="Public Header Parameter Names" anchor="PublicHeaderParameterName">

        <t>
	  Additional header parameter names can be defined by those
	  using JWTs. However, in order to prevent collisions, any new
	  header parameter name or algorithm value SHOULD either be
	  defined in the IANA JSON Web Token Header Parameters
	  registry or be defined as a URI that contains a collision
	  resistant namespace.  In each case, the definer of the name
	  or value MUST take reasonable precautions to make sure they
	  are in control of the part of the namespace they use to
	  define the header parameter name.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWTs.  Nonetheless,
	  some extensions needed for some use cases may require them,
	  such as an extension to enable the inclusion of multiple
	  signatures.
	</t>
      </section>

      <section title="Private Header Parameter Names" anchor="PrivateHeaderParameterName">

	<t>
	  A producer and consumer of a JWT may agree to any header
	  parameter name that is not a Reserved Name <xref
	  target="ReservedHeaderParameterName"></xref> or a Public
	  Name <xref
	  target="PublicHeaderParameterName"></xref>. Unlike Public
	  Names, these private names are subject to collision and
	  should be used with caution.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWTs.
	</t>

      </section>
    </section>

    <section title="Rules for Creating and Validating a JWT">
      <t>
	To create a JWT one MUST follow these steps:

        <list style="numbers">

	  <t>
	    Create the payload content to be encoded as the Decoded
	    JWT Payload Segment.  If the payload represents a JWT
	    Claims Object, then these steps for creating the Decoded
	    JWT Payload Segment also apply:

	    <list style="symbols">
	      <t>
		Create a JSON object containing the desired claims.
		Note that white space is explicitly allowed in the
		representation and no canonicalization is performed
		before encoding.
	      </t>
	      <t>
		Translate this JSON object's Unicode code points into
		UTF-8, as defined in <xref target="RFC3629">RFC
		3629</xref>.  This is the Decoded JWT Payload Segment.
	      </t>
	    </list>
	  </t>
          <t>
	    Base64url encode the Decoded JWT Payload Segment. This
	    encoding becomes the JWT Payload Segment.
	  </t>
	  <t>
	    Create a JSON object containing a set of desired header
	    parameters.  Note that white space is explicitly allowed
	    in the representation and no canonicalization is performed
	    before encoding.
	  </t>
          <t>
	    Translate this JSON object's Unicode code points into
	    UTF-8, as defined in <xref target="RFC3629">RFC
	    3629</xref>.
	  </t>
          <t>
	    Base64url encode the UTF-8 representation of this JSON
	    object as defined in this specification (without
	    padding). This encoding becomes a JWT Header Segment.
	  </t>
          <t>
	    Construct a JWT Crypto Segment as defined for the
	    particular algorithm being used.  The JWT Signing Input is
	    always the concatenation of a JWT Header Segment, a period
	    ('.') character, and the JWT Payload Segment.  The "alg"
	    header parameter MUST be present in the JSON Header
	    Segment, with the algorithm value accurately representing
	    the algorithm used to construct the JWT Crypto Segment.
	  </t>
          <t>
	    If the JWT Compact Serialization is being used, then:

	    <list style="symbols">
	      <t>
		Concatenate the JWT Header Segment, the JWT Payload
		Segment and then the JWT Crypto Segment in that order,
		separating each by period characters, to create the
		JWT.
	      </t>
	    </list>

	    Else if the JWT JSON Serialization is being used, then:

	    <list style="symbols">
	      <t>
		Create a JSON object with these three members: a
		"header" member whose value is an array of JWT Header
		Segments, a "payload" member whose value is the JWT
		Payload Segment, and a "signature" member whose value
		is an array of JWT Crypto Segments.
	      </t>
	      <t>
		If more than one signature is present, then repeat
		steps 3 through 6 for each header and crypto segment
		to produce additional values for the header and
		signature arrays.
	      </t>
	      <t>
		The header and signature arrays must have the same
		number of values, with each header value and
		corresponding signature value being located at the
		same array index.
	      </t>
	    </list>
	  </t>
        </list>
      </t>
      <t>
	When validating a JWT the following steps MUST be taken. If
	any of the listed steps fails then the token MUST be rejected
	for processing.
      </t>
      <t>
	<list style="numbers">
	  <t>
	    If the JWT Compact Serialization is being used, then:

	    <list style="symbols">
	      <t>
		The JWT MUST contain two period characters.
	      </t>
	      <t>
		The JWT MUST be split on the two period characters
		resulting in three non-empty segments.  The first
		segment is the JWT Header Segment; the second is the
		JWT Payload Segment; the third is the JWT Crypto
		Segment.
	      </t>
	    </list>

 	    Else if the JWT JSON Serialization is being used, then:

	    <list style="symbols">
	      <t>
		The JSON MUST contain the three members "header",
		"payload", and "signature" and MAY contain others,
		which MUST be ignored.  The payload member MUST be a
		string and the header and signature members MUST be
		non-empty arrays of strings with equal cardinality.
	      </t>
	      <t>
		Use a "header" member array value as the JWT Header
		Segment; use the "payload" member value as the JWT
		Payload Segment; use a "signature" member array value
		with the same index as the "header" member array value
		used as the JWT Crypto Segment.
	      </t>
	    </list>
	  </t>
          <t>
	    The JWT Payload Segment MUST be successfully base64url
	    decoded following the restriction given in this spec that
	    no padding characters have been used.
	  </t>
          <t>
	    If the payload represents a JWT Claims Object, then these
	    steps for validating the Decoded JWT Payload Segment also
	    apply:

	    <list style="symbols">
	      <t>
		The Decoded JWT Payload Segment, which is the Decoded
		JWT Claims Object, MUST be completely valid JSON
		syntax conforming to <xref target="RFC4627">RFC
		4627</xref>.
	      </t>
	      <t>
		When used in a security-related context, the Decoded
		JWT Claims Object MUST be validated to only include
		claims whose syntax and semantics are both understood
		and supported.
	      </t>
	    </list>
	  </t>
          <t>
	    The JWT Header Segment MUST be successfully base64url
	    decoded following the restriction given in this spec that
	    no padding characters have been used.
	  </t>
          <t>
	    The Decoded JWT Header Segment MUST be completely valid
	    JSON syntax conforming to <xref target="RFC4627">RFC
	    4627</xref>.
	  </t>
          <t>
	    The JWT Crypto Segment MUST be successfully base64url
	    decoded following the restriction given in this spec that
	    no padding characters have been used.
	  </t>
          <t>
	    The JWT Header Segment MUST be validated to only include
	    parameters and values whose syntax and semantics are both
	    understood and supported.
	  </t>
          <t>
	    The JWT Crypto Segment MUST be successfully validated
	    against the JWT Header Segment and JWT Payload Segment
	    in the manner defined for the algorithm being used, which
	    MUST be accurately represented by the value of the "alg"
	    header parameter, which MUST be present.
	  </t>
	  <t>
	    If the JWT JSON Serialization is being used, then repeat
	    steps 4 to 8 for each element of the header and signature
	    arrays.
	  </t>
        </list>
      </t>

      <t>
	Processing a JWT inevitably requires comparing known strings
	to values in the token. For example, in checking what the
	algorithm is, the Unicode string encoding "alg" will be
	checked against the member names in the Decoded JWT Header
	Segment to see if there is a matching header parameter
	name. A similar process occurs when determining if the value
	of the "alg" header parameter represents a supported
	algorithm. Comparing Unicode strings, however, has significant
	security implications, as per <xref target="Security"></xref>.
      </t>
      <t>
	Comparisons between JSON strings and other Unicode strings
	MUST be performed as specified below:
      </t>

      <t>
	<list style="numbers">

          <t>
	    Remove any JSON applied escaping to produce an array of
	    Unicode code points.
	  </t>
          <t>
	    <xref target="USA15">Unicode Normalization</xref> MUST NOT
	    be applied at any point to either the JSON string or to
	    the string it is to be compared against.
	  </t>
          <t>
	    Comparisons between the two strings MUST be performed as a
	    Unicode code point to code point equality comparison.
	  </t>

        </list>
      </t>

    </section>

    <section title="Base64url encoding as used by JWTs" anchor="base64urllogic">

      <t>
	JWTs make use of the base64url encoding as defined in <xref
	target="RFC4648">RFC 4648</xref>. As allowed by Section 3.2 of
	the RFC, this specification mandates that base64url encoding
	when used with JWTs MUST NOT use padding. The reason for this
	restriction is that the padding character ('=') is not URL
	safe.
      </t>
      <t>
	For notes on implementing base64url encoding without padding,
	see <xref target="base64urlnotes"></xref>.
      </t>
    </section>

    <section title="Signing JWTs with Cryptographic Algorithms" anchor="Signing">

      <t>
	JWTs use specific cryptographic algorithms to sign the contents
	of the JWT Header Segment and the JWT Payload Segment.  The
	use of the following algorithms for producing JWTs is defined in
	this section.  The table below is the list of "alg" header
	parameter values reserved by this specification, each of which
	is explained in more detail in the following sections:
      </t>

      <texttable title="JSON Web Token Reserved Algorithm Values" anchor="AlgTable">

	<ttcol align="left">Alg Parameter Value</ttcol>
	<ttcol align="left">Algorithm</ttcol>

	<c>HS256</c>
	<c>HMAC using SHA-256 hash algorithm</c>

	<c>HS384</c>
	<c>HMAC using SHA-384 hash algorithm</c>

	<c>HS512</c>
	<c>HMAC using SHA-512 hash algorithm</c>

	<c>RS256</c>
	<c>RSA using SHA-256 hash algorithm</c>

	<c>RS384</c>
	<c>RSA using SHA-384 hash algorithm</c>

	<c>RS512</c>
	<c>RSA using SHA-512 hash algorithm</c>

	<c>ES256</c>
	<c>ECDSA using P-256 curve and SHA-256 hash algorithm</c>

	<c>ES384</c>
	<c>ECDSA using P-384 curve and SHA-384 hash algorithm</c>

	<c>ES512</c>
	<c>ECDSA using P-521 curve and SHA-512 hash algorithm</c>

      </texttable>

      <t>
	Of these algorithms, only HMAC SHA-256 and RSA SHA-256 MUST be
	implemented by conforming implementations.  It is RECOMMENDED
	that implementations also support the ECDSA P-256 SHA-256
	algorithm.  Support for other algorithms is OPTIONAL.
      </t>

      <t>
	The portion of a JWT that is signed is the same for all
	algorithms: the concatenation of the JWT Header Segment, a
	period ('.') character, and the JWT Payload Segment.  This
	character sequence is referred to as the JWT Signing Input.
	Note that in the JWT Compact Serialization, this corresponds
	to the portion of the JWT representation preceding the second
	period character.  The UTF-8 representation of the JWT Signing
	Input is passed to the respective signing algorithms.
      </t>

      <section title="Signing a JWT with HMAC SHA-256" anchor="SigningWithHMACSHA256">

	<t>
	  Hash based Message Authentication Codes (HMACs) enable one to
	  use a secret plus a cryptographic hash function to generate a
	  Message Authentication Code (MAC). This can be used to
	  demonstrate that the MAC matches the hashed content, in this
	  case the JWT Signing Input, which therefore demonstrates that
	  whoever generated the MAC was in possession of the secret.
	</t>
	<t>
	  The algorithm for implementing and validating HMACs is
	  provided in <xref target="RFC2104">RFC 2104</xref>. Although
	  any HMAC can be used with JWTs, this section defines the use
	  of the SHA-256 cryptographic hash function as defined in <xref
	  target="FIPS.180-3">FIPS 180-3</xref>. The reserved "alg"
	  header parameter value "HS256" is used in the JWT Header
	  Segment to indicate that the JWT Crypto Segment contains a
	  base64url encoded HMAC SHA-256 HMAC value.
	</t>
	<t>
	  The HMAC SHA-256 MAC is generated as follows:

	  <list style="numbers">
	    <t>
	      Apply the HMAC SHA-256 algorithm to the UTF-8
	      representation of the JWT Signing Input using the shared
	      key to produce an HMAC.
	    </t>
	    <t>
	      Base64url encode the HMAC as defined in this document.
	    </t>
	  </list>

	  The output is placed in the JWT Crypto Segment for that JWT.
	</t>

	<t>
	  The HMAC SHA-256 MAC on a JWT is validated as follows:

	  <list style="numbers">

	    <t>
	      Apply the HMAC SHA-256 algorithm to the UTF-8
	      representation of the JWT Signing Input of the JWT using
	      the shared key.
	    </t>
	    <t>
	      Base64url encode the previously generated HMAC as defined
	      in this document.
	    </t>
	    <t>
	      If the JWT Crypto Segment and the previously calculated
	      value exactly match, then one has confirmation that the
	      key was used to generate the HMAC on the JWT and that the
	      contents of the JWT have not be tampered with.
	    </t>
	    <t>
	      If the validation fails, the token MUST be rejected.
	    </t>

	  </list>
	</t>

	<t>
	  Signing with the HMAC SHA-384 and HMAC SHA-512 algorithms is
	  performed identically to the procedure for HMAC SHA-256 - just
	  with correspondingly longer key and result values.
	</t>

      </section>

      <section title="Signing a JWT with RSA SHA-256" anchor="DefiningRSA">

	<t>
	  This section defines the use of the RSASSA-PKCS1-v1_5
	  signature algorithm as defined in <xref target="RFC3447">RFC
	  3447</xref>, Section 8.2 (commonly known as PKCS#1), using
	  SHA-256 as the hash function.  Note that the use of the
	  RSASSA-PKCS1-v1_5 algorithm is described in <xref
	  target="FIPS.186-3">FIPS 186-3</xref>, Section 5.5, as is the
	  SHA-256 cryptographic hash function, which is defined in <xref
	  target="FIPS.180-3">FIPS 180-3</xref>.  The reserved "alg"
	  header parameter value "RS256" is used in the JWT Header
	  Segment to indicate that the JWT Crypto Segment contains an
	  RSA SHA-256 signature.
	</t>
	<t>
	  A 2048-bit or longer key length MUST be used with this
	  algorithm.
	</t>
	<t>
	  The RSA SHA-256 signature is generated as follows:

	  <list style="numbers">

	    <t>
	      Let K be the signer's RSA private key and let M be the
	      UTF-8 representation of the JWT Signing Input.
	    </t>
	    <t>
	      Compute the octet string S = RSASSA-PKCS1-V1_5-SIGN (K,
	      M) using SHA-256 as the hash function.
	    </t>
	    <t>
	      Base64url encode the octet string S, as defined in this
	      document.
	    </t>

	  </list>

	  The output is placed in the JWT Crypto Segment for that JWT.
	</t>

	<t>
	  The RSA SHA-256 signature on a JWT is validated as follows:

	  <list style="numbers">

	    <t>
	      Take the JWT Crypto Segment and base64url decode it into
	      an octet string S. If decoding fails, then the token MUST
	      be rejected.
	    </t>
	    <t>
	      Let M be the UTF-8 representation of the JWT Signing
	      Input and let (n, e) be the public key corresponding to
	      the private key used by the signer.
	    </t>
	    <t>
	      Validate the signature with RSASSA-PKCS1-V1_5-VERIFY ((n,
	      e), M, S) using SHA-256 as the hash function.
	    </t>
	    <t>
	      If the validation fails, the token MUST be rejected.
	    </t>

	  </list>
	</t>

	<t>
	  Signing with the RSA SHA-384 and RSA SHA-512 algorithms is
	  performed identically to the procedure for RSA SHA-256 - just
	  with correspondingly longer key and result values.
	</t>

      </section>

      <section title="Signing a JWT with ECDSA P-256 SHA-256" anchor="DefiningECDSA">
	<t>
	  The Elliptic Curve Digital Signature Algorithm (ECDSA) is
	  defined by <xref target="FIPS.186-3">FIPS 186-3</xref>. ECDSA
	  provides for the use of Elliptic Curve cryptography, which is
	  able to provide equivalent security to RSA cryptography but
	  using shorter key lengths and with greater processing
	  speed. This means that ECDSA signatures will be substantially
	  smaller in terms of length than equivalently strong RSA
	  Digital Signatures.
	</t>
	<t>
	  This specification defines the use of ECDSA with the P-256
	  curve and the SHA-256 cryptographic hash function. The P-256
	  curve is also defined in FIPS 186-3. The reserved "alg"
	  header parameter value "ES256" is used in the JWT Header
	  Segment to indicate that the JWT Crypto Segment contains an
	  ECDSA P-256 SHA-256 signature.
	</t>
	<t>
	  A JWT is signed with an ECDSA P-256 SHA-256 signature as
	  follows:

	  <list style="numbers">
	    <t>
	      Generate a digital signature of the UTF-8 representation
	      of the JWT Signing Input using ECDSA P-256 SHA-256 with
	      the desired private key. The output will be the EC point
	      (R, S), where R and S are unsigned integers.
	    </t>
	    <t>
	      Turn R and S into byte arrays in big endian order. Each
	      array will be 32 bytes long.
	    </t>
	    <t>
	      Concatenate the two byte arrays in the order R and then S.
	    </t>
	    <t>
	      Base64url encode the 64 byte array as defined in this
	      specification.
	    </t>
	  </list>

	  The output becomes the JWT Crypto Segment for the JWT.
	</t>

	<t>
	  The following procedure is used to validate the ECDSA
	  signature of a JWT:

	  <list style="numbers">
	    <t>
	      Take the JWT Crypto Segment and base64url decode it into a
	      byte array. If decoding fails, the token MUST be rejected.
	    </t>
	    <t>
	      The output of the base64url decoding MUST be a 64 byte
	      array.
	    </t>
	    <t>
	      Split the 64 byte array into two 32 byte arrays. The first
	      array will be R and the second S. Remember that the byte
	      arrays are in big endian byte order; please check the
	      ECDSA validator in use to see what byte order it requires.
	    </t>
	    <t>
	      Submit the UTF-8 representation of the JWT Signing
	      Input, R, S and the public key (x, y) to the ECDSA P-256
	      SHA-256 validator.
	    </t>
	    <t>
	      If the validation fails, the token MUST be rejected.
	    </t>
	  </list>

	  The ECDSA validator will then determine if the digital
	  signature is valid, given the inputs.  Note that ECDSA digital
	  signature contains a value referred to as K, which is a random
	  number generated for each digital signature instance. This
	  means that two ECDSA digital signatures using exactly the same
	  input parameters will output different signatures because
	  their K values will be different. The consequence of this is
	  that one must validate an ECDSA signature by submitting the
	  previously specified inputs to an ECDSA validator.
	</t>
	<t>
	  Signing with the ECDSA P-384 SHA-384 and ECDSA P-521 SHA-512
	  algorithms is performed identically to the procedure for ECDSA
	  P-256 SHA-256 - just with correspondingly longer key and
	  result values.
	</t>

      </section>

      <section title="Additional Algorithms" anchor="MoreAlgs">

	<t>
	  Additional algorithms MAY be used to protect JWTs with
	  corresponding "alg" header parameter values being defined to
	  refer to them. Like claim names, new "alg" header parameter
	  values SHOULD either be defined in the IANA JSON Web Token
	  Algorithms registry or be a URI that contains a collision
	  resistant namespace.  In particular, the use of algorithm
	  identifiers defined in <xref target="RFC3275">XML DSIG</xref>
	  and related specifications is permitted.
	</t>

      </section>
    </section>

    <section title="JWT Serialization Formats" anchor="Serializations">
      <t>
	JSON Web Tokens (JWTs) support two serialization formats: the
	JWT Compact Serialization, which is more space efficient and
	intended for uses where the token is passed as a simple
	string-valued parameter, and the JWT JSON Serialization, which
	is more general, being able to contain multiple signatures
	over the same content.  The two serialization formats are
	intended for use in different contexts.
      </t>
      <section title="JWT Compact Serialization" anchor="CompactSerialization">
	<t>
	  The JWT Compact Serialization represents a JWT as a string
	  consisting of three JWT Token Segments: the JWT Header
	  Segment, the JWT Payload Segment, and the JWT Crypto
	  Segment, in that order, with the segments being separated by
	  period ('.')  characters.  It is intended for uses where the
	  token is passed as a simple string-valued parameter,
	  including in URLs.
	</t>
	<t>
	  The Compact Serialization contains only one signature to
	  keep this format simple.  The example JWT in <xref
	  target="ExampleJWT" /> uses the Compact Serialization.
	</t>
      </section>
      <section title="JWT JSON Serialization" anchor="JSONSerialization">
	<t>
	  The JWT JSON Serialization represents a JWT as a JSON object
	  with members for each of three kinds of JWT Token Segments:
	  a "header" member whose value is a non-empty array of JWT
	  Header Segments, a "payload" member whose value is the JWT
	  Payload Segment, and a "signature" member whose value is a
	  non-empty array of JWT Crypto Segments, where the
	  cardinality of both arrays is the same.
	</t>
	<t>
	  Unlike the Compact Serialization, JWTs using the JSON
	  Serialization MAY contain multiple signatures.  Each
	  signature is represented as a JWT Crypto Segment in the
	  "signature" member array.  For each signature, there is a
	  corresponding "header" member array element that specifies
	  the signature algorithm for that signature, and potentially
	  other information as well.  Therefore, the syntax is:
	</t>
	<artwork><![CDATA[{"header":["<header 1 contents>",...,"<header N contents>"],
 "payload":"<payload contents>",
 "signature":["<signature 1 contents>",...,"<signature N contents>"]
}
]]></artwork>
	<t>
	  The i'th signature is computed on the concatenation of
	  &lt;header i contents&gt;.&lt;payload contents&gt;.
	</t>
	<t>
	  <xref target="JSONSerializationExample" /> contains an
	  example JWT using the JSON Serialization.
	</t>
      </section>
    </section>

    <section title="IANA Considerations" anchor="IANA">
      <t>
	This specification calls for:

        <list style="symbols">

          <t>
	    A new IANA registry entitled "JSON Web Token Claims" for
	    reserved claim names is defined in <xref
	    target="ReservedClaimName"></xref>. Inclusion in the
	    registry is RFC Required in the <xref target="RFC5226">RFC
	    5226</xref> sense for reserved JWT claim names that are
	    intended to be interoperable between implementations.  The
	    registry will just record the reserved claim name and a
	    pointer to the RFC that defines it. This specification
	    defines inclusion of the claim names defined in <xref
	    target="ClaimTable"></xref>.
	  </t>
          <t>
	    A new IANA registry entitled "JSON Web Token Header
	    Parameters" for reserved header parameter names is defined
	    in <xref target="ReservedHeaderParameterName"></xref>.
	    Inclusion in the registry is RFC Required in the <xref
	    target="RFC5226">RFC 5226</xref> sense for reserved JWT
	    header parameter names that are intended to be
	    interoperable between implementations.  The registry will
	    just record the reserved header parameter name and a
	    pointer to the RFC that defines it. This specification
	    defines inclusion of the header parameter names defined in
	    <xref target="HeaderParameterTable"></xref>.
	  </t>
          <t>
	    A new IANA registry entitled "JSON Web Token Algorithms"
	    for reserved values used with the "alg" header parameter
	    values is defined in <xref target="MoreAlgs"></xref>. Inclusion
	    in the registry is RFC Required in the <xref
	    target="RFC5226">RFC 5226</xref> sense. The registry will
	    just record the "alg" value and a pointer to the RFC that
	    defines it.  This specification defines inclusion of the
	    algorithm values defined in <xref
	    target="AlgTable"></xref>.
	  </t>
        </list>
      </t>
    </section>

    <section title="Security Considerations" anchor="Security">
      <t>
	TBD: Lots of work to do here. We need to remember to look into
	any issues relating to security and JSON parsing. One wonders
	just how secure most JSON parsing libraries are. Were they
	ever hardened for security scenarios? If not, what kind of
	holes does that open up? Also, we need to walk through the
	JSON standard and see what kind of issues we have especially
	around comparison of names.  For instance, comparisons of
	claim names and other parameters must occur after they are
	unescaped. Need to also put in text about: Importance of
	keeping secrets secret. Rotating keys. Strengths and
	weaknesses of the different algorithms.
      </t>
      <t>
	TBD: Need to put in text about why strict JSON validation is
	necessary.  Basically, that if malformed JSON is received then
	the intent of the sender is impossible to reliably
	discern. While in non-security contexts it's o.k. to be
	generous in what one accepts, in security contexts this can
	lead to serious security holes. For example, malformed JSON
	might indicate that someone has managed to find a security
	hole in the issuer's code and is leveraging it to get the
	issuer to issue "bad" tokens whose content the attacker can
	control.
      </t>

      <section title="Unicode Comparison Security Issues">

        <t>
	  Claim names in JWTs are Unicode strings.  For security
	  reasons, the representations of these names must be compared
	  verbatim after performing any escape processing (as per
	  <xref target="RFC4627">RFC 4627</xref>, Section 2.5).
	</t>
        <t>
	  This means, for instance, that these JSON strings must
	  compare as being equal ("JWT", "\u004aWT"), whereas these
	  must all compare as being not equal to the first set or to
	  each other ("jwt", "Jwt", "JW\u0074").
	</t>
	<t>
	  JSON strings MAY contain characters outside the Unicode
	  Basic Multilingual Plane.  For instance, the G clef
	  character (U+1D11E) may be represented in a JSON string as
	  "\uD834\uDD1E".  Ideally, JWT implementations SHOULD ensure
	  that characters outside the Basic Multilingual Plane are
	  preserved and compared correctly; alternatively, if this is
	  not possible due to these characters exercising limitations
	  present in the underlying JSON implementation, then input
	  containing them MUST be rejected.
	</t>

      </section>
    </section>

    <section title="Open Issues and Things To Be Done (TBD)" anchor="TBD">

      <t>
	The following items remain to be done in this draft (and related drafts):
      </t>

      <list style="symbols">

	<t>
	  The specification will be a lot clearer if the signature
	  portions are cleanly separated from the claims token format
	  and serialization portions.  Having tried it this way and
	  being dissatisfied with the sometimes unwieldy readability
	  of the result, I plan to perform the separation in the next
	  draft.
	</t>
	<t>
	  Consider whether there is a better term than "Digital
	  Signature" for the concept that includes both HMACs and
	  digital signatures using public keys.
	</t>
	<t>
	  Consider whether we really want to allow private claim names
	  and header parameters that are not registered with IANA and
	  are not in collision-resistant namespaces.  Eventually this
	  could result in interop nightmares where you need to have
	  different code to talk to different endpoints that "knows"
	  about each endpoints' private parameters.
	</t>
	<t>
	  Clarify the optional ability to provide type information
	  JWTs and/or their segments.  Specifically, clarify the
	  intended use of the "typ" Header Parameter and the "typ"
	  claim, whether they convey syntax or semantics, and indeed,
	  whether this is the right approach.  Also clarify the
	  relationship between these type values and <xref
	  target="RFC2045">MIME</xref> types.
	</t>
	<t>
	  Clarify the semantics of the "kid" (key ID) header
	  parameter.  Open issues include:  What happens if a kid
	  header is received with an unrecognized value? Is that an
	  error? Should it be treated as if it's empty? What happens
	  if the header has a recognized value but the value doesn't
	  match the key associated with that value, but it does match
	  another key that is associated with the issuer? Is that an
	  error?
	</t>
	<t>
	  The "x5t" parameter is currently specified as "a base64url
	  encoded SHA-256 thumbprint of the DER encoding of an X.509
	  certificate".  SHA-1 was traditionally used for certificate
	  digests but collisions are possible to create and can be
	  used for denial of service attacks within multi-tenant
	  services.  We need to understand the compatibility issues of
	  using SHA-256 thumbprints instead.  We also likely want to
	  specify the digest algorithm explicitly.
	</t>
	<t>
	  Several people have objected to the requirement for
	  implementing RSA SHA-256, some because they will only be
	  using HMACs and symmetric keys, and others because they only
	  want to use ECDSA when using asymmetric keys, either for
	  security or key length reasons, or both.  I believe
	  therefore, that we should consider changing the MUST for RSA
	  SHA-256 to RECOMMENDED.
	</t>
	<t>
	  Since RFC 3447 Section 8 explicitly calls for people NOT to
	  adopt RSASSA-PKCS1 for new applications and instead requests
	  that people transition to RSASSA-PSS, we probably need some
	  Security Considerations text explaining why RSASSA-PKCS1 is
	  being used (it's what's commonly implemented) and what the
	  potential consequences are.
	</t>
	<t>
	  Generalize the normative text on signing algorithms so that
	  the descriptions apply equally to the use of various key
	  lengths - not just HMAC SHA-256, RSA SHA-256, and ECDSA
	  P-256 SHA-256.
	</t>
	<t>
	  Add a table cross-referencing the algorithm name strings
	  used in standard software packages and specifications.
	</t>
	<t>
	  Add Security Considerations text on timing attacks.
	</t>
	<t>
	  Finish the Security Considerations section.
	</t>
	<t>
	  Sort out what to do with the IANA registries if this is
	  first standardized as an OpenID specification.
	</t>
        <t>
	  Write the related specification for encoding public keys
	  using JSON, as per the agreement documented at
	  http://self-issued.info/?p=390.  This will be used by the
	  "jku" (JSON Key URL) header parameter.
	</t>
	<t>
	  Write the companion encryption specification, per the
	  agreements documented at http://self-issued.info/?p=378.
	</t>

      </list>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &RFC1738;

      &RFC2045;

      &RFC2104;

      &rfc2119;

      &RFC3339;

      &RFC3447;

      &RFC3629;

      &RFC3986;

      &RFC4627;

      &RFC4648;

      &RFC5226;

      &RFC5280;

      <reference anchor="FIPS.180-3">
        <front>
          <title>Secure Hash Standard (SHS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="October" year="2008" />
        </front>
        <format target="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf" type="PDF" />
        <seriesInfo name="FIPS" value="PUB 180-3" />
      </reference>

      <reference anchor="FIPS.186-3">
        <front>
          <title>Digital Signature Standard (DSS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="June" year="2009" />
        </front>
        <format target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf" type="PDF" />
        <seriesInfo name="FIPS" value="PUB 186-3" />
      </reference>

      <reference anchor="USA15">
        <front>
          <title>Unicode Normalization Forms</title>

          <author fullname="Mark Davis" initials="M." surname="Davis">
            <address>
              <email>markdavis@google.com</email>
            </address>
          </author>

          <author fullname="Ken Whistler" initials="K." surname="Whistler">
            <address>
              <email>ken@unicode.org</email>
            </address>
          </author>

          <author fullname="Martin D&uuml;rst" initials="M."
                  surname="D&uuml;rst"></author>

          <date day="03" month="09" year="2009" />
        </front>

        <seriesInfo name="Unicode Standard Annex" value="15" />
      </reference>
    </references>

    <references title="Informative References">
      &OASIS.saml-core-2.0-os;

      &W3C.CR-xml11-20021015;

      &RFC3275;

      &RFC4122;

      <reference anchor="SWT">
        <front>
          <title>Simple Web Token (SWT)</title>

          <author fullname="Dick Hardt" initials="D." surname="Hardt"></author>

          <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland"></author>

          <date month="November" year="2009" />
        </front>
        <format target="http://oauth-wrap-wg.googlegroups.com/web/SWT-v0.9.5.1.pdf?gda=Sn4MsEMAAABFB7PFAFiVedPtjcqT8uuIImHXUksNUKMXLyrSumAs_dF2tzlQ33RhT1wW8BFYO1QytiJ-HdGYYcPi_09pl8N7FWLveOaWjzbYnpnkpmxcWg" type="PDF" />
        <seriesInfo name="Version" value="0.9.5.1" />
      </reference>

      <reference anchor="MagicSignatures">
        <front>
          <title>Magic Signatures</title>

          <author fullname="John Panzer (editor)" initials="J." surname="Panzer (editor)"></author>

          <author fullname="Ben Laurie" initials="B." surname="Laurie"></author>

          <author fullname="Dirk Balfanz" initials="D." surname="Balfanz"></author>

          <date month="August" year="2010" />
        </front>
        <format target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-experimental-00.html" type="HTML" />
      </reference>

      <reference anchor="JSS">
        <front>
          <title>JSON Simple Sign</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization>Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/jss/1.0/" type="HTML" />
      </reference>

      <reference anchor="CanvasApp">
        <front>
          <title>Canvas Applications</title>

          <author fullname="Facebook" surname="Facebook"></author>

          <date year="2010" />
        </front>
        <format target="http://developers.facebook.com/docs/authentication/canvas" type="HTML" />
      </reference>

    </references>

    <section title="JWT Examples" anchor="JWTExamples">

      <section title="JWT using HMAC SHA-256" anchor="HMACSHA256Example">
	<section title="Encoding">
	  <t>
	    The Decoded JWT Payload Segment used in this example is:
	  </t>

	  <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

	  <t>
	    Note that white space is explicitly allowed in Decoded JWT
	    Claims Objects and no canonicalization is performed before
	    encoding. The following byte array contains the UTF-8
	    characters for the Decoded JWT Payload Segment:
	  </t>
	  <t>

[123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10, 32, 34, 101, 120, 112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56, 48, 44, 13, 10, 32, 34, 104, 116, 116, 112, 58, 47, 47, 101, 120, 97, 109, 112, 108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111, 111, 116, 34, 58, 116, 114, 117, 101, 125]

	  </t>
	  <t>
	    Base64url encoding the above yields the JWT Payload Segment value:
	  </t>

          <artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

	  <t>
	    The following example JSON header object declares that
	    the data structure is a JSON Web Token (JWT) and the JWT
	    Signing Input is signed using the HMAC SHA-256 algorithm:
	  </t>

	  <artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the Decoded JWT Header Segment:
	  </t>
	  <t>

[123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34, 44, 13, 10, 32, 34, 97, 108, 103, 34, 58, 34, 72, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    JWT Header Segment value:
	  </t>

	  <artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork>

	  <t>
	    Concatenating the JWT Header Segment, a period character,
	    and the JWT Payload Segment yields this JWT Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

	  <t>
	    The UTF-8 representation of the JWT Signing Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 48, 101, 88, 65, 105, 79, 105, 74, 75, 86, 49, 81, 105, 76, 65, 48, 75, 73, 67, 74, 104, 98, 71, 99, 105, 79, 105, 74, 73, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    HMACs are generated using keys. This example used the key
	    represented by the following byte array:
	  </t>
	  <t>

[3, 35, 53, 75, 43, 15, 165, 188, 131, 126, 6, 101, 119, 123, 166, 143, 90, 179, 40, 230, 240, 84, 201, 40, 169, 15, 132, 178, 210, 80, 46, 191, 211, 251, 90, 146, 210, 6, 71, 239, 150, 138, 180, 195, 119, 98, 61, 34, 61, 46, 33, 114, 5, 46, 79, 8, 192, 205, 154, 245, 103, 208, 128, 163]

	  </t>
	  <t>
	    Running the HMAC SHA-256 algorithm on the UTF-8
	    representation of the JWT Signing Input with this key
	    yields the following byte array:
	  </t>
	  <t>

[116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173, 187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83, 132, 141, 121]

	  </t>
	  <t>
	    Base64url encoding the above HMAC output yields the JWT Crypto
	    Segment value:
	  </t>

	  <artwork><![CDATA[dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork>

	  <t>
	    Combining these segments in the order
	    Header.Payload.Signature with period characters between
	    the segments yields this complete JWT using the JWT
	    Compact Serialization (with line breaks for display
	    purposes only):
	  </t>

	  <artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWT first requires removing the base64url
	    encoding from the JWT Header Segment, the JWT Payload
	    Segment, and the JWT Crypto Segment. We base64url decode
	    the segments per <xref target="base64urllogic"></xref> and
	    turn them into the corresponding byte arrays.  We
	    translate the header segment byte array containing UTF-8
	    encoded characters into the Decoded JWT Header Segment
	    string.  Likewise, if the payload represents a JWT Claims
	    Object, we translate the payload segment byte array
	    containing UTF-8 encoded characters into a Decoded JWT
	    Claims Object string.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Next we validate the decoded results.  Since the "alg"
	    parameter in the header is "HS256", we validate the HMAC
	    SHA-256 signature contained in the JWT Crypto Segment.  If
	    any of the validation steps fail, the token MUST be
	    rejected.
	  </t>
	  <t>
	    First, we validate that the decoded JWT Header Segment
	    string is legal JSON.
	  </t>
	  <t>
	    If the payload represents a JWT Claims Object, we also
	    validate that the decoded JWT Payload Segment string is
	    legal JSON.
	  </t>
          <t>
	    To validate the signature, we repeat the previous process
	    of using the correct key and the UTF-8 representation of
	    the JWT Signing Input as input to a SHA-256 HMAC function
	    and then taking the output and determining if it matches
	    the Decoded JWT Crypto Segment.  If it matches exactly,
	    the token has been validated.
	  </t>
	</section>
      </section>

      <section title="JWT using RSA SHA-256" anchor="RSASHA256Example">

	<section title="Encoding">
	  <t>
	    The Decoded JWT Payload Segment used in this example is the
	    same as in the previous example:
	  </t>

	  <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

	  <t>
	    Since the JWT Payload Segment will therefore be the same,
	    its computation is not repeated here.  However, the
	    Decoded JWT Header Segment is different in two ways:
	    First, because a different algorithm is being used, the
	    "alg" value is different.  Second, for illustration
	    purposes only, the optional "typ" parameter is not used.
	    (This difference is not related to the signature algorithm
	    employed.)  The Decoded JWT Header Segment used is:
	  </t>

	  <artwork><![CDATA[{"alg":"RS256"}]]></artwork>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the Decoded JWT Header Segment:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    JWT Header Segment value:
	  </t>

	  <artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9]]></artwork>

	  <t>
	    Concatenating the JWT Header Segment, a period character,
	    and the JWT Payload Segment yields this JWT Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

	  <t>
	    The UTF-8 representation of the JWT Signing Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    The RSA key consists of a public part (n, e), and a
	    private exponent d.  The values of the RSA key used in
	    this example, presented as the byte arrays representing
	    big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>n</c>
	    <c>

[161, 248, 22, 10, 226, 227, 201, 180, 101, 206, 141, 45, 101, 98, 99, 54, 43, 146, 125, 190, 41, 225, 240, 36, 119, 252, 22, 37, 204, 144, 161, 54, 227, 139, 217, 52, 151, 197, 182, 234, 99, 221, 119, 17, 230, 124, 116, 41, 249, 86, 176, 251, 138, 143, 8, 154, 220, 75, 105, 137, 60, 193, 51, 63, 83, 237, 208, 25, 184, 119, 132, 37, 47, 236, 145, 79, 228, 133, 119, 105, 89, 75, 234, 66, 128, 211, 44, 15, 85, 191, 98, 148, 79, 19, 3, 150, 188, 110, 155, 223, 110, 189, 210, 189, 163, 103, 142, 236, 160, 198, 104, 247, 1, 179, 141, 191, 251, 56, 200, 52, 44, 226, 254, 109, 39, 250, 222, 74, 90, 72, 116, 151, 157, 212, 185, 207, 154, 222, 196, 199, 91, 5, 133, 44, 44, 15, 94, 248, 165, 193, 117, 3, 146, 249, 68, 232, 237, 100, 193, 16, 198, 182, 71, 96, 154, 164, 120, 58, 235, 156, 108, 154, 215, 85, 49, 48, 80, 99, 139, 131, 102, 92, 111, 111, 122, 130, 163, 150, 112, 42, 31, 100, 27, 130, 211, 235, 242, 57, 34, 25, 73, 31, 182, 134, 135, 44, 87, 22, 245, 10, 248, 53, 141, 154, 139, 157, 23, 195, 64, 114, 143, 127, 135, 216, 154, 24, 216, 252, 171, 103, 173, 132, 89, 12, 46, 207, 117, 147, 57, 54, 60, 7, 3, 77, 111, 96, 111, 158, 33, 224, 84, 86, 202, 229, 233, 161]

	    </c>

	    <c>e</c>
	    <c>

[1, 0, 1]

	    </c>

	    <c>d</c>
	    <c>

[18, 174, 113, 164, 105, 205, 10, 43, 195, 126, 82, 108, 69, 0, 87, 31, 29, 97, 117, 29, 100, 233, 73, 112, 123, 98, 89, 15, 157, 11, 165, 124, 150, 60, 64, 30, 63, 207, 47, 44, 211, 189, 236, 136, 229, 3, 191, 198, 67, 155, 11, 40, 200, 47, 125, 55, 151, 103, 31, 82, 19, 238, 216, 193, 90, 37, 216, 213, 206, 160, 2, 94, 227, 171, 46, 139, 127, 121, 33, 111, 198, 59, 234, 86, 39, 83, 180, 6, 68, 198, 161, 81, 39, 217, 178, 149, 69, 64, 160, 187, 225, 163, 5, 86, 152, 45, 78, 159, 222, 95, 100, 37, 241, 77, 75, 113, 52, 65, 181, 93, 199, 59, 155, 74, 237, 204, 146, 172, 227, 146, 126, 55, 245, 125, 12, 253, 94, 117, 129, 250, 81, 44, 143, 73, 97, 169, 235, 11, 128, 248, 168, 7, 70, 114, 138, 85, 255, 70, 71, 31, 52, 37, 6, 59, 157, 83, 100, 47, 94, 222, 30, 132, 214, 19, 8, 26, 250, 92, 34, 208, 81, 40, 91, 214, 59, 148, 59, 86, 93, 137, 138, 5, 104, 84, 19, 229, 60, 60, 108, 101, 37, 255, 31, 227, 78, 61, 220, 112, 240, 213, 100, 80, 253, 164, 139, 161, 46, 16, 78, 157, 235, 159, 184, 24, 129, 225, 196, 189, 242, 93, 146, 71, 244, 80, 200, 101, 146, 121, 104, 231, 115, 52, 244, 65, 79, 117, 167, 80, 225, 57, 84, 110, 58, 138, 115, 157]

	    </c>
	  </texttable>

	  <t>
	    The RSA private key (n, d) is then passed to the RSA
	    signing function, which also takes the hash type, SHA-256,
	    and the UTF-8 representation of the JWT Signing Input as
	    inputs.  The result of the signature is a byte array S,
	    which represents a big endian integer.  In this example, S
	    is:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>S</c>
	    <c>

[112, 46, 33, 137, 67, 232, 143, 209, 30, 181, 216, 45, 191, 120, 69, 243, 65, 6, 174, 27, 129, 255, 247, 115, 17, 22, 173, 209, 113, 125, 131, 101, 109, 66, 10, 253, 60, 150, 238, 221, 115, 162, 102, 62, 81, 102, 104, 123, 0, 11, 135, 34, 110, 1, 135, 237, 16, 115, 249, 69, 229, 130, 173, 252, 239, 22, 216, 90, 121, 142, 232, 198, 109, 219, 61, 184, 151, 91, 23, 208, 148, 2, 190, 237, 213, 217, 217, 112, 7, 16, 141, 178, 129, 96, 213, 248, 4, 12, 167, 68, 87, 98, 184, 31, 190, 127, 249, 217, 46, 10, 231, 111, 36, 242, 91, 51, 187, 230, 244, 74, 230, 30, 177, 4, 10, 203, 32, 4, 77, 62, 249, 18, 142, 212, 1, 48, 121, 91, 212, 189, 59, 65, 238, 202, 208, 102, 171, 101, 25, 129, 253, 228, 141, 247, 127, 55, 45, 195, 139, 159, 175, 221, 59, 239, 177, 139, 93, 163, 204, 60, 46, 176, 47, 158, 58, 65, 214, 18, 202, 173, 21, 145, 18, 115, 160, 95, 35, 185, 232, 56, 250, 175, 132, 157, 105, 132, 41, 239, 90, 30, 136, 121, 130, 54, 195, 212, 14, 96, 69, 34, 165, 68, 200, 242, 122, 122, 45, 184, 6, 99, 209, 108, 247, 202, 234, 86, 222, 64, 92, 178, 33, 90, 69, 178, 194, 85, 102, 181, 90, 193, 167, 72, 160, 112, 223, 200, 163, 42, 70, 149, 67, 208, 25, 238, 251, 71]

	    </c>
	  </texttable>

	  <t>
	    Base64url encoding the signature produces this value for
	    the JWT Crypto Segment:
	  </t>

	  <artwork><![CDATA[cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw]]></artwork>

	  <t>
	    Combining these segments in the order
	    Header.Payload.Signature with period characters between
	    the segments yields this complete JWT using the JWT
	    Compact Serialization (with line breaks for display
	    purposes only):
	  </t>

	  <artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw]]></artwork>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWT from this example requires processing the
	    JWT Header Segment and JWT Payload Segment exactly as
	    done in the first example.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Since the "alg" parameter in the header is "RS256", we
	    validate the RSA SHA-256 signature contained in the JWT
	    Crypto Segment.  If any of the validation steps fail, the
	    token MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the decoded JWT Header Segment
	    string is legal JSON.
	  </t>
	  <t>
	    If the payload represents a JWT Claims Object, we also
	    validate that the decoded JWT Payload Segment string is
	    legal JSON.
	  </t>
	  <t>
	    Validating the JWT Crypto Segment is a little different
	    from the previous example. First, we base64url decode the
	    JWT Crypto Segment to produce a signature S to check.  We
	    then pass (n, e), S and the UTF-8 representation of the
	    JWT Signing Input to an RSA signature verifier that has
	    been configured to use the SHA-256 hash function.
	  </t>

	</section>
      </section>

      <section title="JWT using ECDSA P-256 SHA-256" anchor="ECDSASHA256Example">
	<section title="Encoding">
	  <t>
	    The Decoded JWT Payload Segment used in this example is the
	    same as in the previous examples:
	  </t>

	  <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

	  <t>
	    Since the JWT Payload Segment will therefore be the same,
	    its computation is not repeated here.  However, the
	    Decoded JWT Header Segment is differs from the previous
	    example because a different algorithm is being used.  The
	    Decoded JWT Header Segment used is:
	  </t>

	  <artwork><![CDATA[{"alg":"ES256"}]]></artwork>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the Decoded JWT Header Segment:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    JWT Header Segment value:
	  </t>

	  <artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9]]></artwork>

	  <t>
	    Concatenating the JWT Header Segment, a period character,
	    and the JWT Payload Segment yields this JWT Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork>

	  <t>
	    The UTF-8 representation of the JWT Signing Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    The ECDSA key consists of a public part, the EC point (x,
	    y), and a private part d.  The values of the ECDSA key
	    used in this example, presented as the byte arrays
	    representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>x</c>
	    <c>

[127, 205, 206, 39, 112, 246, 196, 93, 65, 131, 203, 238, 111, 219, 75, 123, 88, 7, 51, 53, 123, 233, 239, 19, 186, 207, 110, 60, 123, 209, 84, 69]

	    </c>

	    <c>y</c>
	    <c>

[199, 241, 68, 205, 27, 189, 155, 126, 135, 44, 223, 237, 185, 238, 185, 244, 179, 105, 93, 110, 169, 11, 36, 173, 138, 70, 35, 40, 133, 136, 229, 173]

	    </c>

	    <c>d</c>
	    <c>

[142, 155, 16, 158, 113, 144, 152, 191, 152, 4, 135, 223, 31, 93, 119, 233, 203, 41, 96, 110, 190, 210, 38, 59, 95, 87, 194, 19, 223, 132, 244, 178]

	    </c>
	  </texttable>

	  <t>
	    The ECDSA private part d is then passed to an ECDSA
	    signing function, which also takes the curve type, P-256,
	    the hash type, SHA-256, and the UTF-8 representation of
	    the JWT Signing Input as inputs.  The result of the
	    signature is the EC point (R, S), where R and S are
	    unsigned integers.  In this example, the R and S values,
	    given as byte arrays representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>R</c>
	    <c>

[14, 209, 33, 83, 121, 99, 108, 72, 60, 47, 127, 21, 88, 7, 212, 2, 163, 178, 40, 3, 58, 249, 124, 126, 23, 129, 154, 195, 22, 158, 166, 101]

	    </c>

	    <c>S</c>
	    <c>

[197, 10, 7, 211, 140, 60, 112, 229, 216, 241, 45, 175, 8, 74, 84, 128, 166, 101, 144, 197, 242, 147, 80, 154, 143, 63, 127, 138, 131, 163, 84, 213]

	    </c>
	  </texttable>

	  <t>
	    Concatenating the S array to the end of the R array and
	    base64url encoding the result produces this value for the
	    JWT Crypto Segment:
	  </t>

	  <artwork><![CDATA[DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSApmWQxfKTUJqPP3-Kg6NU1Q]]></artwork>


	  <t>
	    Combining these segments in the order
	    Header.Payload.Signature with period characters between
	    the segments yields this complete JWT using the JWT
	    Compact Serialization (with line breaks for display
	    purposes only):
	  </t>

	  <artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSApmWQxfKTUJqPP3-Kg6NU1Q]]></artwork>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWT from this example requires processing the
	    JWT Header Segment and JWT Payload Segment exactly as
	    done in the first example.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Since the "alg" parameter in the header is "ES256", we
	    validate the ECDSA P-256 SHA-256 signature contained in
	    the JWT Crypto Segment.  If any of the validation steps
	    fail, the token MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the decoded JWT Header Segment
	    string is legal JSON.
	  </t>
	  <t>
	    If the payload represents a JWT Claims Object, we also
	    validate that the decoded JWT Payload Segment string is
	    legal JSON.
	  </t>
	  <t>
	    Validating the JWT Crypto Segment is a little different
	    from the first example. First, we base64url decode the JWT
	    Crypto Segment as in the previous examples but we then
	    need to split the 64 member byte array that must result
	    into two 32 byte arrays, the first R and the second S. We
	    then pass (x, y), (R, S) and the UTF-8 representation of
	    the JWT Signing Input to an ECDSA signature verifier that
	    has been configured to use the P-256 curve with the
	    SHA-256 hash function.
	  </t>
	  <t>
	    As explained in <xref target="DefiningECDSA"></xref>, the
	    use of the k value in ECDSA means that we cannot validate
	    the correctness of the signature in the same way we
	    validated the correctness of the HMAC. Instead,
	    implementations MUST use an ECDSA validator to validate
	    the signature.
	  </t>

	</section>
      </section>

      <section title="JWT using JSON Serialization" anchor="JSONSerializationExample">
	<t>
	  Previous example JWTs shown have used the JWT Compact
	  Serialization.  This section contains an example JWT using
	  the JWT JSON Serialization.  This example demonstrates the
	  capability for conveying multiple signatures for the same
	  JWT.
	</t>
	<section title="Encoding">
	  <t>
	    The Decoded JWT Payload Segment used in this example is the
	    same as in the previous examples:
	  </t>

	  <artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork>

	  <t>
	    Two signatures are used in this JWT: an RSA SHA-256
	    signature, for which the header and signature values are
	    the same as in <xref target="RSASHA256Example" />, and an
	    ECDSA P-256 SHA-256 signature, for which the header and
	    signature values are the same as in <xref
	    target="ECDSASHA256Example" />.  The two Decoded JWT
	    Header Segments used are:
	  </t>

	  <artwork><![CDATA[{"alg":"RS256"}]]></artwork>

	  <t>
	    and:
	  </t>

	  <artwork><![CDATA[{"alg":"ES256"}]]></artwork>

	  <t>
	    Since the computations for all JWT Token Segments used in
	    this example were already presented in previous examples,
	    they are not repeated here.
	  </t>
	  <t>
	    A JSON Serialization of this JWT is as follows:
	  </t>

	  <artwork><![CDATA[{"header":[
  "eyJhbGciOiJSUzI1NiJ9",
  "eyJhbGciOiJFUzI1NiJ9"],
 "payload":"eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ",
 "signature":[
  "cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw",
  "DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSApmWQxfKTUJqPP3-Kg6NU1Q"]
}]]></artwork>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWT first requires removing the base64url
	    encoding from the array of JWT Header Segments, the JWT
	    Payload Segment, and the array of JWT Crypto Segments. We
	    base64url decode the segments per <xref
	    target="base64urllogic"></xref> and turn them into the
	    corresponding byte arrays.  We translate the header
	    segment byte arrays containing UTF-8 encoded characters
	    into Decoded JWT Header Segment strings.  Likewise, if the
	    payload represents a JWT Claims Object, we translate the
	    payload segment byte array into a Decoded JWT Claims
	    Object string.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    If any of the validation steps fail, the token MUST be
	    rejected.
	  </t>
	  <t>
	    First, we validate that the header and signature arrays
	    contain the same number of elements.
	  </t>
	  <t>
	    Next, we validate that the Decoded JWT Header Segment
	    strings are all legal JSON.
	  </t>
	  <t>
	    If the payload represents a JWT Claims Object, we also
	    validate that the decoded JWT Payload Segment string is
	    legal JSON.
	  </t>
	  <t>
	    Finally, for each Decoded JWT Header Segment, we validate
	    the corresponding signature using the algorithm specified
	    in the "alg" parameter, which must be present.
	  </t>

	</section>
      </section>

    </section>

    <section title="Notes on implementing base64url encoding without padding" anchor="base64urlnotes">

      <t>
	This appendix describes how to implement base64url encoding
	and decoding functions without padding based upon standard
	base64 encoding and decoding functions that do use padding.
      </t>
      <t>
	To be concrete, example C# code implementing these functions
	is shown below.  Similar code could be used in other
	languages.
      </t>

      <artwork><![CDATA[static string base64urlencode(byte [] arg)
{
  string s = Convert.ToBase64String(arg); // Standard base64 encoder
  s = s.Split('=')[0]; // Remove any trailing '='s
  s = s.Replace('+', '-'); // 62nd char of encoding
  s = s.Replace('/', '_'); // 63rd char of encoding
  return s;
}

static byte [] base64urldecode(string arg)
{
  string s = arg;
  s = s.Replace('-', '+'); // 62nd char of encoding
  s = s.Replace('_', '/'); // 63rd char of encoding
  switch (s.Length % 4) // Pad with trailing '='s
  {
    case 0: break; // No pad chars in this case
    case 2: s += "=="; break; // Two pad chars
    case 3: s += "="; break; // One pad char
    default: throw new System.Exception(
      "Illegal base64url string!");
  }
  return Convert.FromBase64String(s); // Standard base64 decoder
}]]></artwork>

      <t>
	As per the example code above, the number of '=' padding
	characters that needs to be added to the end of a base64url
	encoded string without padding to turn it into one with
	padding is a deterministic function of the length of the
	encoded string.  Specifically,

	if the length mod 4 is 0, no padding is added;
	if the length mod 4 is 2, two '=' padding characters are added;
	if the length mod 4 is 3, one '=' padding character is added;
	if the length mod 4 is 1, the input is malformed.
      </t>
      <t>
	An example correspondence between unencoded and encoded values
	follows.  The byte sequence below encodes into the string
	below, which when decoded, reproduces the byte sequence.
      </t>

      <artwork>3 236 255 224 193</artwork>

      <artwork>A-z_4ME</artwork>
    </section>

    <section title="Relationship of JWTs to SAML Tokens">
      <t>
	<xref target="OASIS.saml-core-2.0-os">SAML 2.0</xref> provides
	a standard for creating tokens with much greater expressivity
	and more security options than supported by JWTs. However, the
	cost of this flexibility and expressiveness is both size and
	complexity. In addition, SAML's use of <xref
	target="W3C.CR-xml11-20021015">XML</xref> and <xref
	target="RFC3275">XML DSIG</xref> only contributes to the size
	of SAML tokens.
      </t>
      <t>
	JWTs are intended to provide a simple token format that is
	small enough to fit into HTTP headers and query arguments in
	URIs. It does this by supporting a much simpler token model
	than SAML and using the <xref target="RFC4627">JSON</xref>
	object encoding syntax. It also supports securing tokens using
	Hash-based Message Authentication Codes (HMACs) and digital
	signatures using a smaller (and less flexible) format than XML
	DSIG.
      </t>
      <t>
	Therefore, while JWTs can do some of the things SAML tokens
	do, JWTs are not intended as a full replacement for SAML
	tokens, but rather as a compromise token format to be used
	when space is at a premium.
      </t>
    </section>

    <section title="Relationship of JWTs to Simple Web Tokens (SWTs)">

      <t>
	Both JWTs and Simple Web Tokens <xref target="SWT">SWT</xref>,
	at their core, enable sets of claims to be communicated
	between applications.  For SWTs, both the claim names and
	claim values are strings.  For JWTs, while claim names are
	strings, claim values can be any JSON type.  Both token types
	offer cryptographic protection of their content: SWTs with
	HMAC SHA-256 and JWTs with a choice of algorithms, including
	HMAC SHA-256, RSA SHA-256, and ECDSA P-256 SHA-256.  The
	signed content of a SWT must be a set of claims, whereas the
	payload of a JWT, in general, can be any base64url encoded
	content.
      </t>

    </section>

    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>
	The authors acknowledge that the design of JWTs was
	intentionally influenced by the design and simplicity of <xref
	target="SWT">Simple Web Tokens</xref>.  Solutions for signing
	JSON tokens were also previously explored by <xref
	target="MagicSignatures">Magic Signatures</xref>, <xref
	target="JSS">JSON Simple Sign</xref>, and <xref
	target="CanvasApp">Canvas Applications</xref>, all of which
	influenced this draft.
      </t>

    </section>

    <section title='Document History'>
      <t>
        -01
        <list style='symbols'>
          <t>
            Draft incorporating consensus decisions reached at IIW.
          </t>
        </list>
      </t>
      <t>
        -00
        <list style='symbols'>
          <t>
            Public draft published before November 2010 IIW based upon
            the JSON token convergence proposal incorporating input
            from several implementers of related specifications.
          </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
