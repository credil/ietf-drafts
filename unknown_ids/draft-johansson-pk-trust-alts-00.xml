<?xml version="1.0" encoding="US-ASCII"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc category="info" docName="draft-johansson-pk-trust-alts-00"
     ipr="trust200902">
  <front>
    <title abbrev="PK Trust Alternatives">Simple Public Key Trust
    Alternatives</title>

    <author fullname="Leif Johansson" surname="Johansson">
      <organization abbrev="SUNET">SUNET</organization>

      <address>
        <email>leifj@sunet.se</email>

        <uri>http://www.sunet.se</uri>
      </address>
    </author>

    <date day="6" month="July" year="2009" />

    <abstract>
      <t>This document describes often used patterns for establishing
      technical trust for public key-based security architectures other than
      traditional PKIX-based public key infrastructure. The intent is that
      this document be useful as a reference for protocol specification
      authors who use technology like PKIX, PGP or S/MIME as part of their
      protocols.</t>
    </abstract>
  </front>

  <middle>
    <section title="Terminology">
      <t>The keywords "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT"
      and "MAY" that appear in this document are to be interpreted as
      described in <xref target="RFC2119"></xref></t>
    </section>

    <section title="Introduction and motiviation">
      <t>Several protocols introduced by the IETF aswell as by by other SDOs
      employ public key-based technology in various ways - notably in order to
      protect messages or channels, eg using security technology like S/MIME,
      PGP or TLS. Notable examples include SIP, XMPP aswell as calendaring and
      scheduling protocols and several WebSSO technologies including SAML and
      OpenID.</t>

      <t>A common problem facing these protocols is how to establish technical
      trust between protocol endpoints in the absence of a canonical
      internet-wide PKI.</t>

      <t>This document only deals with technical trust, i.e artifacts and
      entities used to establish secure channels between protocol endpoints.
      Arguably there are larger issues involved in the general concept of
      "trust" but this falls outside the scope of this document.</t>

      <t>Furthermore this document does not attempt to describe new design for
      technical trust but rather focuses on what can be achieved using common
      existing protocols, implementations and toolchains.</t>

      <t>Quite often the problem of establishing technical trust for
      public-key technologies is presented as a simple market problem. The
      theory is that since public Certificate Authorities (CAs) exist and are
      readily available, their products are a simple answer to the question of
      how to establish technical trust between (say) TLS endpoints.</t>

      <t>Economy does play a role in trust. Most commercial CAs sell several
      products where the price of the certificate is related to the cost of
      identity vetting that is performed so clearly there is a relationship
      between the amount of work that is spent on vetting and due diligence
      and the value of the trust represented by the technical trust bearer (eg
      X.509 certificate) that is produced.</t>

      <t>Quite often it is desirable to establish technical trust between a
      small group of entities, excluding all others with a high degree of
      certainty. This is also known as a "ring of trust". For instance a
      private CA could be used to represent trust in a set of properties
      shared by all entities issued keys from the CA - for instance that all
      key holders represent the same type of organization or that they all
      represent the same class of service. The value of the CA is in the
      vetting and due diligence done to insure that the set of of certificates
      issued from the CA is isomorphic to a proper subset of entities having
      the given property.</t>

      <t>Rather than being a simple question of "how much" vetting/due
      diligence was done before signing a certificate we see that trust often
      depends on specific contextual validation ("does this endpoint have
      property X?") for which no market exists in general since the size of
      these rings of trust are often small compared to the number of customers
      of most commercial CAs.</t>

      <t>One problem with the single PKI model is that entities often need to
      participate in transactions within multiple contexts joining multiple
      rings of trust. The various ways in which multiple contexts can be
      represented using PKIX (eg naming constraints or 'bridge' CAs) are
      either not widely implemented or suffer from interoperability problems
      making them somewhat impractical.</t>

      <t>This is not to say that traditional PKIX technology does not have a
      role to play still. Some of the strategies described in this protocol
      can be seen as extensions building on top of traditional PKI which
      remain an important tool.</t>
    </section>

    <section title="PKIX">
      <t>TODO: Overview of bridge/cross PKI.</t>
    </section>

    <section title="Simple Public Key Trust Alternatives">
      <section title="The role of X.509 certificates">
        <t>An X.509 certificate can carry lots of semantics using its names
        and extensions. It is also possible to treat an X.509 certificate as a
        simple public key container, disregarding any other element in the
        certificate. Validation for such "raw key" certificates MUST be
        limited to comparing the public key or key fingerprint with a copy of
        the public key received from a trusted source. Used this way an X.509
        certificate can be used with most existing PKIX implementations by
        altering the way certificate validation is performed.</t>

        <t>While it may seem easier (and cleaner) to handle raw keys directly
        this is seldom supported in existing implementations.</t>
      </section>

      <section title="Manually Shared Public Keys">
        <t>Arguably the simplest form of trust is derived from manually
        sharing keys. This can easily implemented using any X.509 certificates
        (which do not necessarily have to be self-signed) serving as public
        key bearers. In order to support this model it MUST be possible to
        validate endpoints using key values or key fingerprints. Exactly how
        the keys are established and updated is out of scope for this simple
        model.</t>

        <t>An example is RADIUS over TCP. Traditionally RADIUS uses a
        shared-secret model where RADIUS clients and servers are each given
        (out of band) a secret which must be shared among parties who need to
        communicate with each other. RADIUS uses UDP. Recent work has extended
        RADIUS to use TCP (<xref target="I-D.ietf-radext-radsec"></xref>) and
        TLS for securing communication between RADIUS endpoints. </t>

        <t>Distributing self-signed X.509 certificates and validating peers
        using their raw keys or key fingerprints is in this context
        semantically equivalent to managing traditional RADIUS shared
        secrets.</t>

        <t>This begs the question of why a PKI isn't a better alternative than
        self-signed X.509 certificates used as raw key bearers. From a
        theoretical perspective a PKI might be preferable to manually sharing
        keys but practical deployment experience shows that it is very
        uncommon for RADIUS servers only to be part of a single business
        relationship which would lead to the requirement to deploy bridge or
        cross CA between the PKIX PKIs representing the various relationships
        a RADIUS server may be part of.</t>

        <t>Deploying bridge CAs constitutes overhead which may be difficult to
        justify when the scale of the business relationships (number of
        relationships and number of members in each ring of trust) is small.
        By comparison manually sharing (possibly self-signed) certificate is
        good enough for many situations.</t>
      </section>

      <section title="Leap-of-faith Shared Public Keys">
        <t>Certain protocols such as Secure Shell (<xref
        target="RFC4251"></xref> and <xref target="RFC4253"></xref>) and BTNS
        (<xref target="RFC5386"></xref>) allow security associations to be
        established by the so called leap-of-faith model where an initial
        association is established with little or no prior trust. Subsequent
        associations to the same endpoint is by contrast required to be
        authenticated using keys or other artifacts exchanged during the first
        association.</t>

        <t>For instance Secure Shell associates endpoints (Secure Shell
        servers) with key fingerprints. When an SSH client opens a connection
        to the server fingerprints MUST match or the user is notified and
        forced to take action to manually authenticate the (possibly valid)
        new key.</t>

        <t>The Secure Shell leap-of-faith authentication can be generalized to
        a pattern for public key sharing: Protocols implementing this pattern
        MUST provide mechanisms for endpoints to publish their keys or key
        fingerprints or include them in protocol messages. </t>

        <t>The first time a trust relationship is needed the keys or
        fingerprints are associated with a representation of the endpont (eg
        URL or hostname). If the endpoint subsequently publishes a different
        (set of) keys or fingerprints the trust relationship MUST be
        invalidated and a manual process MUST resolve if this was a valid key
        roll-over or an attack.</t>
      </section>

      <section title="Authenticated Bag-of-Keys">
        <t>A variation of manually shared public keys, the bag-of-keys
        approach is similar to a traditional X.509 Certificate Authority but
        with a few important operational differences.</t>

        <t>The bag-of-keys is a data structure (eg XML, DNS resource records,
        ASN.1, etc) containing encoded representation of keys (either raw
        keys, X.509 certificates or in some cases fingerprints of keys). The
        data structure MUST be authenticated for instance using one or more
        digital signatures and it is from this authentication that trust in
        the contained keys is derived. </t>

        <t>Trust in the authentication (eg the signing keys) can be
        established using manually sharing the corresponding public keys (cf
        above) or by any other means, including the mechanisms described in
        this document. Below we'll see how DNSSEC fits into this picture.</t>

        <t>By including a time-to-live parameter for the embedded keys or
        fingerprints in the data structure itself the consumer of the keys can
        easily determine for how long it is safe to cache the keys in the data
        structure.</t>

        <t>There are several operationally significant differences between a
        authenticated bag-of-keys and a traditional CA:<list style="symbols">
            <t>The data structure can describe its own validity to consumers
            which eliminates the need for revocation infrastructure (eg CRLs
            or OCSP) - the bag-of-keys is both a CA and a CRL of sorts.
            Regular updates of the bag-of-keys replaces the need for validity
            checks.</t>

            <t>Most signature representation (eg XML-DSig or CMS) allows for
            multiple separate signatures on a single object. Using this
            mechanism to authenticate the bag-of-keys data structure it is
            possible to represent multiple trust relationships on single
            bag-of-keys.</t>

            <t>It is possible to assign multiple keys (with different
            life-times for instance) to a given entity in the bag-of-keys
            allowing for a simple roll-over mechanism.</t>

            <t>Keys contained in the bag-of-keys can be used to configure the
            validation-engine at a time separate from when these keys are used
            - i.e validation is done at configure-time rather than at
            run-time. This may seem like a relatively minor point but
            deployment experience from web federated identity shows this to be
            an important simplification.</t>
          </list></t>
      </section>
    </section>

    <section title="Examples">
      <section title="SAML Metadata">
        <t>The Security Assertion Markup Language (SAML) is a set of protocols
        and protocol bindings used to communicate information about
        authentication and authorization between peers. Communication is in
        the form of XML-based messages. Security is either derived from
        security at the message-transport layer (eg TLS) or XML digital
        signatures of the XML messages. In both cases SAML employs various
        means of establishing technical trust between peers.</t>

        <t>Information about SAML entities (protocol endpoints and bindings)
        is sometimes described using SAML metadata which is used by protocol
        endpoints and supporting infrastructure. An important part of SAML
        metadata is to describe the entity-to-key mapping which can be done
        either by giving the name of a key (eg the name of a certificate) or
        by embedding the key itself.</t>

        <t>Embedding keys in metadata (which is then signed using XML-DSig) is
        an example of the bag-of-keys pattern described above.</t>
      </section>

      <section title="DNSSEC Trust Bridge">
        <t>DNSSEC <xref target="RFC4033"></xref>, <xref
        target="RFC4034"></xref>, <xref target="RFC4035"></xref> is a
        mechanism for securing data in the domain name system (DNS). By
        introducing new (or reusing existing) resource records it is possible
        to use DNSSEC to provide a measure of authentication for any data than
        can be represented stored and queried from the DNS.</t>

        <t>For instance <xref target="RFC4255"></xref> describes a way to
        store Secure Shell <xref target="RFC4251">(</xref> and <xref
        target="RFC4253"></xref>) fingerprints in DNS and a semantics for the
        trust derived from such fingerprints when stored in Secure DNS. Other
        examples include <xref target="RFC4398"></xref> (certificates in the
        DNS) and <xref target="RFC4025"></xref> (IPSec keying material).</t>

        <t>We can think of these cases as examples of the authenticated
        bag-of-keys pattern where DNSSEC authenticates the keys (or
        fingerprints of keys) represented as DNS resource records.</t>
      </section>
    </section>

    <section title="Security Considerations">
      <t>Revocation is an important part of key management. Experience shows
      that it is sometimes quite difficult to achieve large-scale deployment
      of revocation infrastructure. The authentication bag-of-keys pattern
      does not include revocation but instead relies on the consumer regularly
      refreshing the data structure. Should the consumer fail to do that there
      is an increased risk of key compromise.</t>

      <t>Leap-of-faith key sharing is vulnerable to user fatigue - presenting
      a user with questions about security associations when the user only
      wants to "get to his/her stuff" clearly hasn't worked so far. </t>

      <t>Implementors of leap-of-faith patterns should strongly consider not
      allowing users to make decisions about security associations at all or
      at least not to present such decisions as problems to be overcome before
      the user can access resources.</t>
    </section>

    <section title="IANA Considerations">
      <t>None</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119.xml"?>
    </references>

    <references title="Informational References">
      <?rfc include='reference.RFC.4033.xml'?>

      <?rfc include='reference.RFC.4034.xml'?>

      <?rfc include='reference.RFC.4035.xml'?>

      <?rfc include='reference.RFC.4398.xml'?>

      <?rfc include='reference.RFC.4255.xml'?>

      <?rfc include='reference.RFC.4251.xml'?>

      <?rfc include='reference.RFC.4253.xml'?>

      <?rfc include='reference.RFC.4025.xml'?>

      <?rfc include='reference.I-D.ietf-radext-radsec.xml'?>

      <?rfc include='reference.RFC.5386.xml'?>
    </references>
  </back>
</rfc>
