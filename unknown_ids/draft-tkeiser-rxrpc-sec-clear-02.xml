<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC4120 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml">
<!ENTITY RFC4301 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml">
<!ENTITY RFC4302 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4302.xml">
<!ENTITY RFC4303 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4303.xml">
<!ENTITY RFC4506 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4506.xml">
<!ENTITY RFC4960 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4960.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY I-D.narten-iana-considerations-rfc2434bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.narten-iana-considerations-rfc2434bis.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="bcp" docName="draft-tkeiser-rxrpc-sec-clear-02" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="Cleartext Peer Identity Assertion">Rx Security Object Providing Cleartext Peer Identity Assertions</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Thomas Keiser" initials="T.E."
            surname="Keiser">
      <organization abbrev="Sine Nomine">Sine Nomine Associates</organization>

      <address>
        <postal>
          <street>43596 Blacksmith Square</street>

          <!-- Reorder these if your country does things differently -->

          <city>Ashburn</city>

          <region>VA</region>

          <code>20147</code>

          <country>USA</country>
        </postal>

        <phone>+1 703 723 6673</phone>

        <email>tkeiser@sinenomine.net</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <date year="2010" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>

    <workgroup>N/A</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>rx</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>
         RxRPC was originally designed as the remote procedure call layer for
         AFS-3.  Today there are a number of anonymous RxRPC applications which 
         require identity assertions in order to ensure that the desired peer 
         receives and processes a procedure call.  This memo defines a replacement 
         for the rxnull security class which provides a means for mutually agreeing
         upon who is communicating, without incurring cryptographic overhead.
         It should be noted that, much like rxnull, this security object is not
         suitable for use in a distributed environment due to its inability to
         provide integrity protection.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
         RxRPC <xref target="draft-zeldovich-rx-spec"/> is a remote procedure call (RPC) protocol
         that evolved from earlier prototypes developed as part of the Andrew 
         Project at Carnegie Mellon University <xref target="VICE1"/>
         <xref target="CMU-ITC-85-003"/>
         <xref target="CMU-ITC-84-011"/> 
         <xref target="CMU-ITC-85-038"/>.
         Its primary, although notably not its only, usage is by the AFS-3 
         distributed file system
         <xref target="AFS1"/> <xref target="AFS2"/>.
         Rx provides remote procedure call services over top of multiplexed 
         stateful virtual circuits called "connections".  Individual call sessions
         within the multiplexed circuits are called "channels".  Flow control, delivery
         guarantees, and security are provided at the connection level.  Stream ordering
         is performed at the channel level.  Security in Rx is handled at the connection
         level.  Thus, all calls within a given multiplexed connection must be associated
         with the same security object, which in all current use cases means the same
         security context.  Security mechanisms in Rx are pluggable --
         the Rx packet header contains a single octet field which defines the security
         mechanism to be used.  Rx packet payload encoding is under the control of the
         mutually agreed upon Rx security mechanism.
      </t>

      <section title="Existing Security Mechanisms">
        <t>
          At present, there are two Rx security mechanisms in wide deployment: rxnull,
          and rxkad.  Additionally, there was a security mechanism called rxvab,
          which was used by early VICE prototypes, never widely deployed, and considered
          to be entirely deprecated.
        </t>

        <section title="rxnull">
          <t>
            As the name implies, rxnull provides 
            no-op security services for anonymous services.  Rxnull does not modify the
            packet payload in any manner.  Absolutely no cryptography is used with
            rxnull; header fields are asserted to be correct.  
          </t>
        </section>

        <section title="rxkad">
          <t>
            Rxkad was originally developed as a kerberos 4-based security
            mechanism implementing three security profiles: header integrity protection, payload
            integrity protection, and payload encryption.  With the advent of Kerberos 5
            <xref target="RFC4120"/>, the rxkad
            mechanism was extended to support DES Kerberos 5 tickets.  Rxkad utilizes a spare
            16-bit Rx header field to store a 16-bit cryptographic checksum of a bit-string called
            the packet pseudoheader.  The pseudoheader contains most Rx header fields, as well as
            certain other ancillary pieces of data <xref target="AFS-RX"/>.
          </t>
        </section>
      </section>

      <section anchor="sec:mh" title="Multi-homed Host Support">
        <t>
          During the 1990s Transarc extended the Rx protocol to support multihomed hosts.
          The Transarc design involved redefining the most significant bit of the packet
          header connection identifier field.  Under the new design, the connection ID field
          was split as follows:
        </t>

        <figure align="center">
          <preamble>Rx Header Epoch and Connection ID Fields</preamble>
          <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|G|                               E                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             C                             | H |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          ]]></artwork>
        </figure>

        <t>
          <list style="hanging" hangIndent="4">
            <t hangText="G bit: 1 bit">
              <vspace blankLines="1"/>
              When asserted, the (G)lobal bit indicates that the C field is globally unique.  When not
              asserted, the tuple (IPv4 address, UDP port, E, C) is used to identify an Rx connection.
              However, when multi-homed hosts are involved in a connection, the Global bit causes the
              C field to become globally unique, and thus IP address and port number matching is not
              performed as part of the virtual circuit identification process.
            </t>
            <t hangText="E bits: 31 bits (unsigned integer)">
              <vspace blankLines="1"/>
              The (E)poch field is used to detect peer Rx state resets.  Whenever an Rx protocol stack
              is initialized, an effort should be made to assigned it a different value.  Typically, this
              is done by assigning the current Unix epoch time.
            </t>
            <t hangText="C bits: 30 bits (unsigned integer)">
              <vspace blankLines="1"/>
              The (C)onnection bits are part of the virtual circuit identifier.  As discussed above,
              the G bit controls what other date is used as part of the virtual circuit identifier.
            </t>
            <t hangText="H bits: 2 bits (unsigned integer)">
              <vspace blankLines="1"/>
              The c(H)annel bits are used to multiplex four RPC call channels over a single Rx
              connection.  Each packet is thus associated with a specific channel.
            </t>
          </list>
        </t>
      </section>

      <section title="Motivations">
        <t>
           IPv4 address renumbering is a frequent occurence in many environments.  Due
           to the stateless nature of the Rx packet multiplexor, it is possible for race
           conditions to occur whereby an RPC call payload is delivered to the wrong peer.
           With the existing Rx security classes, the receiving peer will
           automatically create a new Rx connection, optionally go through a challenge/response
           phase, and then proceed to process the call arguments.  Obviously, mis-delivery of an 
           RPC call can result in incorrect behavior.  For example, in the case of AFS-3,
           mis-delivery can lead to data corruption, loss of cache coherence, and other 
           problematic situations.
        </t>
      </section>

      <section title="Goals">
        <t>
           Many high-performance applications based upon Rx RPC cannot tolerate 
           cryptographic overhead.  In order to ensure correctness in the face of
           transport-layer address renumbering, some form of context needs to be 
           established between client and server to permit upper-layer applications 
           to reject processing of remote procedure calls that were misdirected.
           This memo aims to replace rxnull with a minimally-intrusive security object
           that provides a stateful means of detecting address renumbering events
           without introducing cryptographic overhead.
        </t>

        <t>
           Obviously, similar race conditions can occur with the rxkad security object.
           Solving that problem is considered outside the scope of this memo.
        </t>
      </section>

    </section>

    <section title="Conventions">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>
    </section>

    <section title="Overview of Rx RPC">
      <t>
        Rx RPC is a remote procedure call mechanism built on top of UDP.  In order to establish
        a stateful call context on top of a stateless datagram protocol, Rx relies upon
        a number of client-asserted header fields to establish a flow-controlled 
        communications channel between peers.  To eliminate the need for context-establishment 
        round-trips, Rx relies upon client assertions to establish a stateful context.
      </t>

      <section title="Packet Mux">
        <t>
          Rx connection objects are identified by a tuple of packet header fields.  The most
          important control field is the most-significant bit of the epoch header field.  When
          this bit is asserted, the connection object is operating in multi-homing mode, as
          specified in <xref target="draft-zeldovich-rx-spec"/>.
          In the normal Rx operating mode (with the multi-homing bit set to zero), Rx 
          connections are identified by the following tuple: (host, port, epoch, cid), where
          these elemenets are defined as:

          <list style="hanging">
            <t hangText="host:">IPv4 address of peer</t>
            <t hangText="port:">UDP port of peer</t>
            <t hangText="epoch:">Rx header epoch field</t>
            <t hangText="cid:">Rx header cid field (channel ID bits masked to zero)</t>
          </list>

          However, when the multi-homing bit is asserted, the connection identifier tuple becomes:
          (epoch, cid).  Thus, multi-homed Rx connection objects have a shared (epoch, cid) namespace,
          independent of peer address.
        </t>
      </section>

    </section>

    <section title="Presenting Problems">
      <t>
        The design of this Rx security class is motivated by server and client renumbering
        incidents at large AFS-3 deployments.  When a file server is renumbered, there is a several
        hour window until the next VL_GetAddrsU RPC is performed to refresh the file server UUID
        to IPv4 address mappings in the client.  Due to the TTL-based invalidation of stale cached
        mappings, there is a substantial time interval during which RPCs can be delivered to the
        wrong file server, potentially leading to incorrect behavior.
      </t>

      <t>
        Similarly, client renumbering can lead to incorrect behavior due to a loss of cache
        coherence.  The AFS-3 callback mechanism relies upon correct knowledge of client UUID to
        IPv4 address mappings in order to deliver cache invalidation messages to clients.  When
        these mappings become stale due to intervening address renumbering events, advertisement of
        incorrect addresses, NATs, etc. these "call back" remote procedure calls may be delivered to
        the wrong client node.  In some circumstances this can lead to false state of success on the
        file server because an unintended client received, processed, and sent a response of success 
        to the file server.  Due to the success return code, the file server will no longer attempt 
        to deliver the invalidation, and the client to which the call back was supposed to be delivered 
        will continue to operate on stale cached data because it never received the cache invalidation 
        message.
      </t>

      <section title="Node Renumbering">
        <t>
          When servers are renumbered, one potential outcome is that two or more
          machines running the same service will swap addresses.  In this case, there
          is a possibility for the wrong machine to correctly interpret, and attempt to
          execute, a procedure call.
        </t>

        <t>
          In some cases, execution of an RPC by the wrong endpoint will still result in correct 
          behavior.  However, this is not generally true, where execution by an unintended 
          target could result in undefined, or even dangerous, behavior.  For example, in 
          AFS-3, the existence of shadow clones could result in a situation where an RW shadow 
          clone is updated instead of the canonical RW site registered in the VLDB.
        </t>
      </section>

      <section title="Epoch ID Multi-Homing Bit">
        <t>
          When the multi-homing bit is asserted, (connection,epoch) tuples become
          globally unique.  This mode of operation permits clients to contact the
          server on multiple addresses, thus allowing client operating systems to route
          datagrams as desired.  Current implementations of Rx bind the connection to
          the first peer address on which a datagram was received.  Since all reply
          datagrams are sent to the bound peer, connection hijacking becomes impossible.
          Unfortunately, this comes at the expense of handling client renumbering
          events: when the bound peer address becomes unreachable, or is reassigned, 
          the Rx connection enters a simplex state and consequently all call channels
          block until the connection times out.
        </t>
      </section>

      <section title="Processing of Non-Idempotent Calls">
        <t>
          Another problematic symptom of Rx connections entering a simplex state involves
          non-idempotent RPCs.  The core problem is that by the time the lack of a reply
          channel is observed, the non-idempotent procedure call has already been executed.
          Rx RPCs are not generally transactional, and thus there is typically no means of
          rolling back the state-changing behavior.  Obviously, this problem is not
          unique to multihomed hosts, but it is another indication of how Rx is lacking
          compared to alternative multi-home aware protocols, such as SCTP <xref target="RFC4960"/>.
        </t>
      </section>
    </section>

    <section title="Rx Clear Security Class">
      <t>
        In order to overcome the dangers inherent in assuming stability of transport
        addresses, the Rx Clear security class embeds a security header in all data packets.
        This security header contains application-specific endpoint identifier assertions 
        for both the source and destination.
      </t>

      <t>
        When a datagram is received by the wrong peer, 
        an Rx abort packet will be dispatched notifying the peer of the need to re-bind 
        transport addresses for this connection object.  When such an abort packet is received
        by a client connection, the error will be immediately propagated back to the caller so
        that application-specific logic may be invoked to refresh transport-layer address mappings
        for the intended destination endpoint.  In the server case, this memo standardizes new
        multi-homing Rx connection peer binding semantics which allow for graceful handling of
        client renumbering events.
      </t>

      <section anchor="sec:constants" title="Constants">
        <t>
           The Rx Clear security class makes use of several newly defined constants, which are
           defined below:
        </t>

        <t>
          <list style="hanging" hangIndent="4">
            <t hangText="RX_SEC_ID_CLEAR:">
              <vspace blankLines="1"/>
              An Rx security index will be allocated by the Grand Central Registrar.  As with
              all Rx security indices, this 8 bit integer will uniquely identify the security
              class bound to a given Rx datagram.
            </t>
            <t hangText="RXCL_HDR_VERS_1:">
              <vspace blankLines="1"/>
              Rx Clear security header version 1 will be allocated by the Grand Central
              Registrar.  This version number will correspond to the XDR <xref target="RFC4506"/> 
              encoded data structure called rxClear_Header, as specified in <xref target="sec:header"/>.
            </t>
            <t hangText="RXCL_ERR_UNKNOWN_VERS:">
              <vspace blankLines="1"/>
              An Rx error code will be allocated which communicates that this version of
              the Rx Clear security header is unsupported by the peer.  This error code will
              be sent as the user payload of an Rx abort packet.
            </t>
            <t hangText="RXCL_ERR_UNKNOWN_ID_TYPE:">
              <vspace blankLines="1"/>
              An Rx error code will be allocated which communicates that this endpoint
              identifier type is not supported by the peer.  This error code will be sent
              as the user payload of an Rx abort packet.
            </t>
            <t hangText="RXCL_ERR_WRONG_PEER:">
              <vspace blankLines="1"/>
              An Rx error code will be allocated which communicates mis-delivery of an
              Rx Clear-protected datagram to the wrong peer.  This error code will be sent 
              as the user payload of an Rx abort packet.
            </t>
<!-- I'm not sure we need this one; commenting out for now
(It was originally intended to be an abort return to the original caller in a case
 where call reply args were mis-delivered due to stale peer binding, and the server
 received an RXCL_ERR_WRONG_PEER abort from that client)
            <t hangText="RXCL_ERR_MH_PEER_MISMATCH:">
              <vspace blankLines="1"/>
              An Rx error code will be allocated which communicates mis-delivery of an
              Rx Clear-protected datagram to the wrong-peer on a connection with the epoch multi-homing
              bit enabled.  This error code will be sent as the user payload of an
              Rx abort packet.
            </t>
-->
            <t hangText="RXCL_ERR_XCID_UNSUPP:">
              <vspace blankLines="1"/>
              An Rx error code will be allocated which communicates to the peer that this
              node is incapable of supporting the extended connection id field.  This error
              code will be sent as the user payload of an Rx abort packet upon receipt of
              an RxClear header containing a non-zero clh_xcid field by a node which cannot
              support extended connection identifiers.
            </t>
            <t hangText="RXCL_EI_TYPE_NULL:">
              <vspace blankLines="1"/>
              An endpoint identifier type which provides fallback to rxnull-like semantics.
              In other words, the contents of the source and destination endpoint identifiers
              have no meaning (and SHOULD thus be zero octets in length).  In this mode of
              operation, detection of address renumbering is impossible.
            </t>
          </list>
        </t>
      </section>

      <section anchor="sec:header" title="Security Header">
        <t>
          In order to communicate expectations to the peer, all data packets travelling over
          an RxClear-protected connection will include an XDR-encoded security header which carries
          identity assertions.  The RxClear mechanism uses a header rather than a challenge-
          response mechanism because the additional round-trips required by the Rx challenge-
          response mechanism were deemed too costly for the typical unauthenticated Rx call 
          workload.
        </t>

        <t>
          The proposed security header is an XDR-encoded structure defined as follows:
        </t>

<!-- XXX will XDR correctly compact the first three fields? -->
        <figure align="center" anchor="rxclear_authenticator">
          <artwork><![CDATA[
struct rxClear_Header {
    u_char clh_version;          /* authenticator version number */
    u_char clh_id_type;          /* how to interpret opaque peer
                                    identifier payloads */
    u_char clh_data_off;         /* data payload offset */
    u_char clh_spares1;          /* MUST be set to zero */
    afs_uint32 clh_data_len;     /* data payload length */
    afs_uint32 clh_trl_off;      /* security trailer offset */
    afs_uint32 clh_flags;        /* miscellaneous control flags */
    afs_uint32 clh_spares2;      /* MUST be set to zero */
    afs_uint32 clh_spares3;      /* MUST be set to zero */
    opaque clh_src_id;           /* assertion of client identity */
    opaque clh_dst_id;           /* assertion of server identity */
};
          ]]></artwork>
          <postamble>Rx Clear Security Header</postamble>
        </figure>

        <t>
          This security header will be an XDR-encoded data structure, which will occupy the first octets of the 
          data offset in an Rx packet -- it will start at the offset directly following the Rx packet header.
          The normal packet data will begin at the data offset specified in the clh_data_off field of the security
          header.  
        </t>

        <t>
          <list style="hanging" hangIndent="4">
            <t hangText="clh_version: 8-bits (unsigned integer)">
              <vspace blankLines="1"/>
              This contains the version of the Rx Clear 
              security object header.  If this version is unknown by the peer, then the 
              connection must be aborted.
            </t>
            <t hangText="clh_id_type: 8-bits (unsigned integer)">
              <vspace blankLines="1"/>
              An 8-bit unsigned integer which identifies the encoding of the XDR opaque
              fields src_id and dst_id.  Values within this 8-bit namespace are allocated 
              by the AFS Assigned Numbers Registrar.
            </t>
            <t hangText="clh_data_off: 8-bits (unsigned integer)">
              <vspace blankLines="1"/>
              This field specifies the beginning of the data 
              payload, in units of octets from the beginning of the Rx packet payload.  
              This field is used by receivers to determine where to begin reading the 
              encapsulated data payload.
            </t>
            <t hangText="clh_trl_off: 32-bits (unsigned integer)">
              <vspace blankLines="1"/>
              This value specifies the offset in octets of 
              the clear security class packet trailer.  A value of zero indicates the 
              absence of a security trailer.
            </t>
            <t hangText="clh_flags: 32-bits (unsigned integer)">
              <vspace blankLines="1"/>
              This is a bitfield whose bits are used as protocol control flags.
              All flag bits whose semantics are not yet standardized MUST be sent as
              zeroes.
            </t>
            <t hangText="clh_src_id: XDR opaque">
              <vspace blankLines="1"/>
              This field contains an application-specific source endpoint identifier.  For example, in the
              case of AFS-3, this will likely be an XDR-encoded node UUID.
            </t>
            <t hangText="clh_dst_id: XDR opaque">
              <vspace blankLines="1"/>
              This field contains an application-specific destination endpoint identifier.  For example, in the
              case of AFS-3, this will likely be a XDR-encoded node UUID.
            </t>
            <t hangText="clh_spares1: 8-bits (unsigned integer)">
              <vspace blankLines="1"/>
              This field is reserved for future use, and MUST
              be set to zero.  Future memos MAY define a standardized use for this field,
              and thus implementors MUST NOT make private use of this field.
            </t>
            <t hangText="clh_spares2: 32-bits (unsigned integer)">
              <vspace blankLines="1"/>
              This field is reserved for future use, and MUST
              be set to zero.  Future memos MAY define a standardized use for this field,
              and thus implementors MUST NOT make private use of this field.
            </t>
            <t hangText="clh_spares3: 32-bits (unsigned integer)">
              <vspace blankLines="1"/>
              This field is reserved for future use, and MUST
              be set to zero.  Future memos MAY define a standardized use for this field,
              and thus implementors MUST NOT make private use of this field.
            </t>
          </list>
        </t>
      </section>

      <section title="Data Packet Validation">
        <t>
          Upon receipt of a data packet with the security index set to RX_SEC_ID_CLEAR, the node will XDR decode the
          security header, and subsequently validate the security header.  Following XDR decode, the node shall
          first verify that the clh_version field contains a supported version number.  In the event that the node
          does not support this RxClear version, the node will send an Rx abort packet to the peer with error code
          RXCL_ERR_UNKNOWN_VERS.
        </t>

        <t>
          The second step in validation involves the extended connection identifier field, clh_xcid.  If this node
          does not support extended cid, and the clh_xcid field is non-zero, then an abort packet with user payload
          RXCL_ERR_XCID_UNSUPP should be sent to the peer, and the connection should transition to an error state.
        </t>

        <t>
          Next, the application-specific endpoint identifier type specified in clh_id_type field is validated to ensure
          that the application layer can handle this identifier type.  If this endpoint identifier type is not 
          supported by the application layer, then the node will send an Rx abort packet with user payload of 
          RXCL_ERR_UNKNOWN_ID_TYPE, and the connection should transition to an error state.
        </t>

        <t>
          The application layer will then be asked to validate the clh_dst_id field.  If there is a mismatch, an
          abort packet will be sent to the peer with user payload RXCL_ERR_WRONG_PEER, and the Rx connection will then 
          transition into an error state.
        </t>
      </section>

      <section title="Abort Packet Handling">
        <t>
          Processing of received Rx Abort packets must be updated to handle the new RXCL_ERR_ error codes.  If such an error
          code is received on a connection with security index other than RX_SEC_ID_CLEAR, then behavior is undefined.
        </t>

        <section title="RXCL_ERR_UNKNOWN_VERS">
          <t>
            This error code indicates that the peer is unable to support the version of the RxClear security header sent in
            a packet.  The connection is transitioned into an error state.
          </t>
        </section>

        <section title="RXCL_ERR_UNKNOWN_ID_TYPE">
          <t>
            This error code indicates that the peer is unable to support this application-specific endpoint identifier type.
            The connection is transitioned into an error state.
          </t>
        </section>

        <section title="RXCL_ERR_WRONG_PEER">
          <t>
            This error code indicates that the packet was delivered to the wrong peer.  Behavior in this situation depends on
            several factors.  First, for connections where the epoch multi-homing bit is zero, the connection must be 
            transitioned to an error state.  For multi-homed connections, behavior further depends upon whether this is a
            client connection, or a server connection.  For client connections, the easiest course of action is to set the
            connection to an error state, and allow the client to re-resolve the application-specific endpoint-identifier to
            transport identifier mapping, allocate a new Rx connection, and re-try the call.

            In the case of a multi-homed server connection, the implementation SHOULD make a best-effort try to deliver the 
            call reply data to the correct destination, as this may be a non-idempotent procedure call.  This memo outlines 
            in detail new peer binding semantics for multi-homed Rx connections in another section.  Hence, whenever it is
            possible, the server will not transition a server connection into an error state upon receipt of this message.
            Instead, it SHOULD invalidate the peer currently bound to the connection so that future replies go to a different,
            hopefully correct, transport address.
          </t>
        </section>

        <section title="RXCL_ERR_XCID_UNUSPP">
          <t>
            This error code indicates that the peer is unable to support the extended connection identifier field in the
            RxClear security header.  The connection is transitioned to error state, and the implementation SHOULD mark the
            peer as being incapable of supporting extended connection identifiers so that connections allocated to this peer
            in the future contain a clh_xcid field with value zero.
          </t>
        </section>
      </section>
    </section>

    <section title="Multi-Home Behavior">
      <t>
        Rx supports multi-homed clients through the assertion of the most-significant bit in the Rx header epoch field.
        When this bit is asserted, a server will accept datagrams into a connection regardless of the source host address
        and port.  However, reply packets are always sent to the first peer address which contacted the server on any given
        (epoch, cid) tuple.  This behavior prevents connection hijacking, at the expense of robust multi-homing support.
      </t>

      <t>
        In order to properly support multi-homing this memo specifies relaxation of the peer binding policies.
        Most importantly, upon receipt of an RXCL_ERR_WRONG_PEER abort packet, an Rx server should
        not transition a server-mode connection to an error state.  Rather, it SHOULD mark the peer currently bound to the Rx
        connection as being incorrect so that responses may be sent to a different peer, as determined upon receipt of the next 
        ping packet.  Although this does open up room for connection hijacking, it does so only for anonymous connections, which
        are otherwise exposed to denial of service attacks.
      </t>

      <t>
        To address the issue of lack of response, new Rx server implementations SHOULD permit re-binding of the peer
        on server-mode connections.  To this end, servers should track liveness of peer addresses on a server connection
        in order to remove a dead peer from a connection.  If an Rx ping comes from an address other than the currently bound
        peer transport address, the Rx implementation MAY try to re-send unacknowledged packets to this other address.  If 
        these re-transmits are correctly aknowledged, the connection may be re-bound to the new peer.
      </t>

<!-- 
     XXX do we need/want to provide some text on rules/heuristics to be employed to attempt to limit session hijacking?
     e.g. do we want to limit this behavior to certain packet types that actually demonstrate that the peer has knowledge
     of enough state to "prove" (in a probabilistic sense) that it is the peer, and not some random hijacker? 

     All of which leads into the bigger question: given that Rx is susceptible to plenty of other DoS holes (e.g. spoofed aborts),
     does hijacking of an unauthenticated call really matter all that much?
-->
    </section>

    <?rfc needLines="8" ?>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        I would like to thank all of the participants at the 2009 Edinburgh AFS hackathon for their input into
        the design of this security mechanism.  Specifically, I would like to thank Jeffrey Altman for suggesting that it
        would be architecturally cleaner to place peer identity assertions into a security header, rather than modifying 
        AFS-3 RPCs to explicitly include application-layer identity assertions as IN parameters.  Special thanks to Randall
        Atkinson for providing useful feedback with regard to the introduction and security considerations sections.
      </t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>

    <section anchor="AFS_registrar" title="AFS Assigned Numbers Registrar Considerations">
      <t>
         This memo includes several assigned numbers requests which must
         be considered by the AFS Assigned Numbers Registrar.
      </t>

      <section title="Definition of new registries">
        <t>
           This memo requests that the AFS Assigned
           Numbers Registrar allocate new registries for three fields in the Rx Clear security 
           header, as described in <xref target="sec:header" />:
        </t>

        <t>
          <list style="symbols">
            <t>clh_version</t>
            <t>clh_id_type</t>
            <t>clh_flags</t>
          </list>
        </t>

        <t>
           Allocations for the following registries are to be processed by the AFS Assigned
           Numbers Regisrar pursuant to the policies dictated in sections 2.3.2 and 2.3.3 of 
           <xref target="AFS3-STDS-CHARTER"/>.  
        </t>

        <section title="clh_version">
          <t>
              The Rx Clear security class includes a version number in its packet header.  This
              memo requests that the AFS Assigned Numbers Registrar allocate a new registry for
              tracking assigned values for this protocol field.  The unsigned 8-bit namespace
              for this registry shall be divided into three regions as follows:
          </t>

          <figure align="center">
            <artwork><![CDATA[
Range      Policy
-----      ------
0-239      standards
240-254    private use
255        reserved
]]></artwork>
          </figure>

          <t>
             Standards-track allocation requests for this registry MUST contain the following pieces of information:
          </t>

          <t>
            <list style="symbols">
              <t>A reference to an RFC section documenting the XDR definition of the header</t>
            </list>
          </t>

          <t>
             In addition, a standards-track allocation request MAY contain the following optional elements:
          </t>

          <t>
            <list style="symbols">
              <t>A reference to an RFC section documenting security considerations for this header type</t>
              <t>A requested version number</t>
            </list>
          </t>
        </section>

        <section title="clh_id_type">
          <t>
             The Rx Clear security class provides a means of sending opaque application data,
             which is intended to provide a means of transmitting application-specific 
             transport-independent endpoint identifiers.  The 8-bit unsigned namespace for this
             registry shall be divided into three policy regions as follows:
          </t>

          <figure align="center">
            <artwork><![CDATA[
Range      Policy
-----      ------
0-239      standards
240-254    private use
255        reserved
]]></artwork>
          </figure>

          <t>
             Standards-track allocation requests for this registry MUST contain the following pieces of information:
          </t>

          <t>
            <list style="symbols">
              <t>A reference to an RFC section documenting the means of encoding the payload, such as an XDR type definition</t>
              <t>A reference to an RFC section documenting the semantics for this encoding type</t>
            </list>
          </t>

          <t>
             In addition, a standards-track allocation request MAY contain the following optional elements:
          </t>

          <t>
            <list style="symbols">
              <t>A reference to an RFC section documenting security considerations for this encoding type</t>
              <t>A requested type identification number</t>
            </list>
          </t>
        </section>

        <section title="clh_flags">
          <t>
             The Rx Clear security class header contains a 32-bit flags bit vector.  Bits
             within this vector shall be allocated by the AFS Assigned Numbers Registrar.
             This 32-value namespace shall be subdivided into two policy regions as follows:
          </t>

          <figure align="center">
            <artwork><![CDATA[
Range            Policy
-----            ------
2^0 to 2^27      standards
2^28 to 2^31     private use
]]></artwork>
          </figure>

          <t>
             Standards-track allocation requests for this registry MUST contain the following pieces of information:
          </t>

          <t>
            <list style="symbols">
              <t>A reference to an RFC section documenting the semantics for this flag</t>
            </list>
          </t>

          <t>
             In addition, a standards-track allocation request MAY contain the following optional elements:
          </t>

          <t>
            <list style="symbols">
              <t>A reference to an RFC section documenting security considerations for this flag</t>
              <t>A requested bit position</t>
            </list>
          </t>
        </section>
      </section>

      <section title="Allocation of new values">
        <t>
           This memo also makes several allocation requests to the AFS Assigned Numbers Registrar.
        </t>

        <section title="RxClear security index">
          <t>
             A new Rx protocol security index must be allocated.  It is anticipated that given
             the small size of the security index namepsace, the allocation will
             only be satisfied after rough consensus is established on the 
             afs3-standardization@openafs.org mailing list.
          </t>
        </section>

        <section title="Rx error codes">
          <t>
             The Rx Clear security class allocates several new Rx error codes for use
             in Rx abort packet payloads.  Given that there are multiple Rx implementations,
             it is assumed that the AFS Assigned Numbers Registrar will be responsible for 
             allocating new error table values.  Specifically, the following new Rx error
             codes need to be allocated:
          </t>

          <t>
            <list style="symbols">
              <t>RXCL_ERR_UNKNOWN_VERS</t>
              <t>RXCL_ERR_UNKNOWN_ID_TYPE</t>
              <t>RXCL_ERR_WRONG_PEER</t>
              <t>RXCL_ERR_XCID_UNSUPP</t>
            </list>
          </t>

          <t>
             Please see <xref target="sec:constants"/> for further details regarding these constants.
          </t>
        </section>

        <section title="Rx Clear Security Header Version">
          <t>
             This memo requests allocation of version 1 within this new namespace
             for the protocol header described in <xref target="sec:header"/>.
          </t>
        </section>

        <section title="Endpoint Identifier Type">
          <t>
             One endpoint type identifier is requested at this time: RXCL_EI_TYPE_NULL.
             The null endpoint identifier type shall have encoding and semantics as
             defined in <xref target="sec:constants"/>
          </t>
        </section>
      </section>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
         This protocol explicitly provides neither the means for encrypting nor integrity
         checking the contents of Rx headers or payloads.  Its use, except 
         in physically secured and isolated high-performance computing environments where
         cryptographic overhead is deemed to be unacceptable, is NOT RECOMMENDED.  Where
         use on the internet is necessary, other means of protecting the Rx protocol
         from attack, such as IPsec <xref target="RFC4301"/> <xref target="RFC4302"/>
         <xref target="RFC4303"/> are RECOMMENDED.  It should be noted that, due to its
         use of UDP as a transport, Rx is not a candidate for encapsulation within TLS
         <xref target="RFC5246"/>.
      </t>

      <t>
         Rx without packet header integrity, at a minimum, is open to a call injection
         attack.  The following section outlines describes this known attack vector,
         and how the introduction of the Rx Clear security class changes the susceptibility of
         Rx to this attack.
      </t>

      <section title="call injection">
        <t>
          With rxnull, simplex injection attacks have always been possible.  For connections
          with the G bit (as described in <xref target="sec:mh"/>) asserted, this means
          that the attacker must correctly spoof the epoch and connection ID.  For injection
          of data packets into a channel, one further piece of information must be available:
          the range of packet sequence numbers currently within the valid receive window.
          Much of this information is obtainable by probing the victim with Rx protocol
          debugging packets.
        </t>

        <t>
           The Rx Clear security class changes the nature of this attack.  If an attacker,
           in addition to the information above,
           also posesses the correct endpoint identifiers for the two peers, it may hijack
           the Rx connection.  The key difference here is that the attack is full-duplex;
           all replies will now flow to the attacker instead of the original recipient.
        </t>

        <t>
           Given that both rxnull and Rx Clear are unauthenticated security objects, this is
           unlikely to result in anything more severe than a denial of service.  Furthermore,
           given the new Rx Clear abort codes, the peer will detect this situation one round trip
           after transmission of its next call, rather than ending up in a state where the
           two peers disagree on call channel window position, which is complex to detect and resolve.
        </t>
      </section>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC2119;

      <reference anchor="AFS3-STDS-CHARTER" target="http://michigan-openafs-lists.central.org/archives/afs3-standardization/2008-September/000244.html">
        <front>
          <title>Options for AFS Standardisation</title>

          <author initials="S." surname="Wilkinson" fullname="Simon Wilkinson">
            <organization>University of Edinburgh School of Informations</organization>
          </author>

          <date year="2008" month="September" day="22"/>
        </front>
      </reference>
    </references>

    <references title="Informative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml"?-->
      &RFC4120;
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml"?-->
      &RFC4301;
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4302.xml"?-->
      &RFC4302;
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4303.xml"?-->
      &RFC4303;
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4506.xml"?-->
      &RFC4506;
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4960.xml"?-->
      &RFC4960;
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml"?-->
      &RFC5246;

      <reference anchor="CMU-ITC-85-003" target="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-003.pdf">
        <front>
          <title>A Large-Parameter Remote Procedure Call Mechanism in Unix</title>

          <author initials="M." surname="Satyanarayanan" fullname="M. Satyanarayanan">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>

          <date year="1985"/>
        </front>
        <seriesInfo name="CMU ITC Tech. Rep." value="CMU-ITC-85-003" />
      </reference>

      <reference anchor="CMU-ITC-84-011" target="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-011.pdf">
        <front>
          <title>RPC User Manual</title>

          <author initials="M." surname="Satyanarayanan" fullname="M. Satyanarayanan">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>

          <date year="1985" month="January" day="10"/>
        </front>
        <seriesInfo name="CMU ITC Tech. Rep." value="CMU-ITC-84-011" />
      </reference>

      <reference anchor="CMU-ITC-85-038" target="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-038.pdf">
        <front>
          <title>RPC2 User Manual</title>

          <author initials="M." surname="Satyanarayanan" fullname="M. Satyanarayanan">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>

          <date year="1985"/>
        </front>
        <seriesInfo name="CMU ITC Tech. Rep." value="CMU-ITC-85-038" />
      </reference>

      <reference anchor="draft-zeldovich-rx-spec" target="http://openafs.sinenomine.net/~mmeffie/rfc/draft-zeldovich-rx-spec-00.txt">
        <front>
          <title>Rx protocol (work in progress)</title>

          <author initials="N." surname="Zeldovich" fullname="Nickolai Zeldovich">
            <organization abbrev="MIT">Massachusetts Institute of Technology</organization>
          </author>
          <author initials="M." surname="Meffie" fullname="Michael Meffie">
            <organization abbrev="Sine Nomine">Sine Nomine Associates</organization>
          </author>

          <date year="2009" month="November" day="17" />
        </front>
      </reference>

      <reference anchor="VICE1" target="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-039.pdf">
        <front>
          <title>The ITC Distributed File System: Principles and Design</title>

          <author initials="M." surname="Satyanarayanan" fullname="M. Satyanarayanan">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>
          <author initials="J.H." surname="Howard" fullname="John H. Howard">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>
          <author initials="D.A." surname="Nichols" fullname="David A. Nichols">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>
          <author initials="R.N." surname="Sidebotham" fullname="Robert N. Sidebotham">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>
          <author initials="A.Z." surname="Spector" fullname="Alfred Z. Spector">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>
          <author initials="M.J." surname="West" fullname="Michael J. West">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>

          <date year="1985" month="December"/>
        </front>
        <seriesInfo name="Proc. 10th ACM Symp. Operating Sys. Princ." value="Vol. 19, No. 5" />
        <seriesInfo name="CMU ITC Tech. Rep." value="CMU-ITC-85-039" />
      </reference>

      <reference anchor="AFS1" target="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-062.pdf">
        <front>
          <title>An Overview of the Andrew File System"</title>

          <author initials="J.H." surname="Howard" fullname="John H. Howard">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>

          <date year="1988" month="February" />
        </front>
        <seriesInfo name="Proc. 1988 USENIX Winter Tech. Conf." value="pp. 23-26" />
        <seriesInfo name="CMU ITC Tech. Rep." value="CMU-ITC-88-062" />
      </reference>

      <reference anchor="AFS2" target="http://reports-archive.adm.cs.cmu.edu/anon/itc/CMU-ITC-068.pdf">
        <front>
          <title>Scale and Performance in a Distributed File System</title>

          <author initials="J.H." surname="Howard" fullname="John H. Howard">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="M.L." surname="Kazar" fullname="Michael L. Kazar">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="S.G." surname="Menees" fullname="Sherri G. Menees">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="D.A." surname="Nichols" fullname="David A. Nichols">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="M." surname="Satyanarayanan" fullname="M. Satyanarayanan">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="R.N." surname="Sidebotham" fullname="Robert N. Sidebotham">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="M.J." surname="West" fullname="Michael J. West">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>

          <date year="1988" month="February" />
        </front>
        <seriesInfo name="ACM Trans. Comp. Sys." value="Vol. 6, No. 1, pp. 51-81" />
        <seriesInfo name="CMU ITC Tech. Rep." value="CMU-ITC-87-068" />
      </reference>

      <reference anchor="AFS-RX">
        <front>
          <title>AFS-3 Programmer's Reference: Specification for the Rx Remote Procedure Call Facility</title>

          <author initials="E.R." surname="Zayas" fullname="Edward R. Zayas">
            <organization abbrev="Transarc">Transarc Corporation</organization>
          </author>

          <date year="1991" month="August" day="28" />
        </front>
        <seriesInfo name="Transarc Corp. Tech. Rep." value="FS-00-D164" />
      </reference>

    </references>

<!--
    <section anchor="app-additional" title="Additional Stuff">
      <t>This becomes an Appendix.</t>
    </section>
-->

    <!-- Change Log

v00 2009-09-24  TEK   Initial version
v01 2010-01-29  TEK   make kolya draft informative
v02 2010-03-09  TEK   incorporate changes suggested by Randall Atkinson

     -->
  </back>
</rfc>
