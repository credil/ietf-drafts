


Network Working Group                                   J. Schoenwaelder
Internet-Draft                                  Jacobs University Bremen
Intended status: Informational                             June 15, 2007
Expires: December 17, 2007


                 Lessons Learned from the SMIng Project
                   draft-schoenw-sming-lessons-00.txt

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on December 17, 2007.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   A data modeling language for network management protocols called
   SMIng was developed within the Network Management Research Group of
   the Internet Research Task Force over a period of several years.
   This memo documents some of the lessons learned during the project
   for consideration by designers of future data modeling languages for
   network management protocols.





Schoenwaelder           Expires December 17, 2007               [Page 1]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  SMIng Goals and History  . . . . . . . . . . . . . . . . . . .  3
   3.  Lessons Learned  . . . . . . . . . . . . . . . . . . . . . . .  4
     3.1.  Readers, Writers, Tool Developers  . . . . . . . . . . . .  4
     3.2.  Data vs. Command vs. Object vs. Document . . . . . . . . .  5
     3.3.  Naming Independence  . . . . . . . . . . . . . . . . . . .  5
     3.4.  Errors and Exceptions  . . . . . . . . . . . . . . . . . .  6
     3.5.  Configuration Storage Models . . . . . . . . . . . . . . .  6
     3.6.  Selection of Language Features . . . . . . . . . . . . . .  7
     3.7.  Syntax versus Semantics  . . . . . . . . . . . . . . . . .  7
     3.8.  Reuse of Definitions . . . . . . . . . . . . . . . . . . .  7
     3.9.  Versioning and Meta Information  . . . . . . . . . . . . .  8
     3.10. Extensibility  . . . . . . . . . . . . . . . . . . . . . .  8
     3.11. Language Independence  . . . . . . . . . . . . . . . . . .  8
     3.12. Compliance and Conformance . . . . . . . . . . . . . . . .  9
   4.  Conclusions  . . . . . . . . . . . . . . . . . . . . . . . . .  9
   5.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . .  9
   6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 10
   7.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 10
   8.  Informative References . . . . . . . . . . . . . . . . . . . . 10
   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 10
   Intellectual Property and Copyright Statements . . . . . . . . . . 12



























Schoenwaelder           Expires December 17, 2007               [Page 2]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


1.  Introduction

   The Network Management Research Group (NMRG) of the Internet Research
   Task Force (IRTF) has developed a new data modeling language for
   network management protocols called SMIng [RFC3780].  Work on SMIng
   started in the late 1999 and concluded with the publication of the
   core language [RFC3780] and an extension which provides the mappings
   to the Simple Network Management Protocol (SNMP) [RFC3781] in 2004.

   This memo documents some of the lessons learned during the project
   for consideration by engineers of future data modeling languages for
   network management protocols.  Our focus is on technical design
   aspects that have turned out to be more difficult than expected as
   well as aspects that required significant discussions in order to
   understand trade-offs.


2.  SMIng Goals and History

   SMIng started in 1999 as a research project to address some drawbacks
   of SMIv2, the current data modeling language for management
   information bases.  Primarily, its partial dependence on ASN.1 and a
   number of exception rules turned out to be problematic.  In 2000, the
   work was handed over to the IRTF Network Management Research Group
   where it was significantly detailed.  Since the work of the RAP
   Working Group on COPS-PR and SPPI emerged in 1999/2000, SMIng was
   split into two parts: a core data definition language (defined in
   this document) and protocol mappings to allow the application of core
   definitions through (potentially) multiple management protocols.  The
   replacement of SMIv2 and SPPI by a single merged data definition
   language was also a primary goal of the IETF SMING Working Group that
   was chartered at the end of 2000.  The SMING Working Group could not
   reach agreement, resulting in the Working Group being closed down in
   April 2003.  The NMRG then published the SMIng specifications in
   [RFC3780] and [RFC3781] in order to document the results achieved in
   the NMRG.

   In short, the published version of SMIng aimed at being a data
   modeling language that can be adapted for different management
   protocols and thus be closer to an information modeling language.
   For a more detailed discussion of the terms data modeling language
   and information modeling languages, we refer the reader to RFC 3444
   [RFC3444].

   The problem which drove the development of SMIng, namely duplicated
   data modeling efforts and often also duplicated instrumentation code,
   has not been solved and it even may have become more pressing.  A
   data modeling language capable to drive tools that can automate the



Schoenwaelder           Expires December 17, 2007               [Page 3]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


   implementation of command line interfaces, monitoring interfaces, and
   configuration interfaces from a single specification surely would
   have significant value.

   During the SMIng project, people have looked at various issues that
   have to be dealt with in this context.  The purpose of this memo is
   to document these issues and some of the alternatives that have been
   explored to tackle them so that future language designers can learn
   from the SMIng experiment.


3.  Lessons Learned

   This section summarizes the lessons learned from the SMIng project.
   Designers of future data modeling languages for network management
   protocols are encouraged to study these lessons to avoid potential
   pitfalls.

3.1.  Readers, Writers, Tool Developers

   Network management data modeling languages are used by engineers to
   develop and specify data models for (sub-components of) managed
   systems.  The data models are later read by implementers with the
   goal to create interoperable implementations as well as network
   operators while managing networks and services.  A data modeling
   language is therefore used by both, data model writers and data model
   readers.  In most cases, the number of readers of a data model is
   much larger than the number of writers.  Hence, when taking design
   decisions, it may be necessary to consider to what extend the design
   choice simplifies the task of data model readers and the task of data
   model writers.  All other things being equal, preference should be
   given to solutions that simplify the task of the human reader.

   The third group to be considered in the data modeling language design
   process are tool developers.  In general, language features should be
   simple and straight forward to implement in order to achieve wide
   spread tool support.  However, when considering alternatives, it is
   important to realize that in most cases the number of data model
   writers is much larger than the number of tool developers.

   As a consequence, preference should be give to solutions that
   simplify the task of readers.  Reduction of the efforts required by
   writers is of secondary importance and the reduction of the efforts
   required by tool developers is of least important preference.  While
   this perhaps seems obvious, it is at times difficult to take
   according design decisions if the group working on a new data
   modeling language is dominated by say tool developers or data model
   writers.



Schoenwaelder           Expires December 17, 2007               [Page 4]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


3.2.  Data vs. Command vs. Object vs. Document

   There are different approaches to model network management interfaces
   and to design supporting protocols:

   o  The data-oriented approach models all management aspects through
      data objects that can be read, written, created, and destroyed.
      The SNMP technology is an extreme example of this approach where
      even create and destroy operations are handled as side effects of
      write operations.  While the data-oriented approach is
      conceptually simple, it is usually difficult to use for modeling
      complex operations, for example due to atomicity issues.
   o  The command-oriented approach does not model state objects but
      instead treats the state maintained by a managed element as a
      black box and provides specific commands to cause state changes or
      to retrieve/write some selected state information.  The command-
      oriented approach is widely used by command line interfaces.
   o  The object-oriented approach can be seen as a combination of the
      data-oriented and the command-oriented approach where commands are
      bound to data objects and the black-box state is limited to the
      internal state of objects.  The object-oriented approach is being
      used for example by the Common Information Model.
   o  The document-oriented approach represents the state of a device
      and its configuration as a structured document.  As a consequence,
      primitive operations are the retrieval of (parts of) a document
      and the application of changes to move from one document version
      to the next.  Since a configuration is treated as a complete
      document, it becomes more natural to support course grained atomic
      operations.  The document-oriented approach is used by NETCONF for
      dealing with configurations.

   Note that the choice of the approach has impact on the features
   required by a data modeling language.  Trying to be protocol neutral
   may imply to support multiple of these approaches, which clearly
   increases the complexity of the language design.  A data modeling
   language aiming at supporting a document-oriented view for
   configuration, a data-oriented view for monitoring, and a command-
   oriented view for ad-hoc operations on a device must be able to link
   say a command to the data objects that may be triggered to achieve
   the behaviour defined for that command.  This quickly becomes
   difficult and it might be better to avoid mixing different approaches
   for the same functionality.

3.3.  Naming Independence

   One of the goals of the SMIng project was to provide a data
   definition language where the data definitions are not tied to a
   specific management protocol.  Since protocols typically use



Schoenwaelder           Expires December 17, 2007               [Page 5]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


   different approaches to name instances, it is required to support
   multiple instance naming systems.  While this may sound easy to do,
   it turns out that trying to achieve naming independence has many
   implications:

   o  There is in general a need to model relationships.  A common
      approach is to refer to other definitions using names as pointers.
      Being naming system independent, such a pointer needs to be
      abstracted and the protocol mappings then need to explain how the
      pointer works for a given protocol.  This becomes quickly
      difficult since management protocols tend to introduce different
      specific constraints.
   o  Many relationships between data model components are typically
      explained in description clauses.  Being protocol neutral,
      description clauses have to be worded carefully so that they make
      sense with the various protocol mappings.  This significantly
      increases the efforts to write data models and to review them.
   o  When thinking about relationships, it is crucial to think about
      fate sharing of data objects, namely does the removal of an object
      imply the removal of other objects?  Being naming system
      independent causes some additional challenges here since some fate
      sharing properties may be implicit in the naming system used in
      once protocol mapping while they must be explicit in other
      protocol mappings.

3.4.  Errors and Exceptions

   Well written data definitions include clear definitions how
   implementations should react in various error situations or during
   run-time exceptions.  It is often a mistake if a data model writer
   assumes that implementers will choose a particular error code in a
   given error situation.  For interoperability reasons, it is far
   better to spell out the precise behaviour in error situations and
   run-time exceptions.  Unfortunately, it becomes quite difficult to be
   precise about errors and exceptions in a protocol and naming system
   neutral data modeling framework such as SMIng since all error and
   exception reporting mechanisms of the underlying protocols need to be
   abstracted since otherwise description clauses become protocol
   specific.  Furthermore, due to the varying features of the underlying
   protocols, some errors and exceptions may only exist in some of the
   mappings and must therefore be dealt with when the generic data model
   is mapped to a concrete protocol.

3.5.  Configuration Storage Models

   Management protocols use different mechanisms to deal with
   persistence of configuration state.  The SNMP protocol uses
   StorageType [RFC2579] columns in conceptual tables to indicate which



Schoenwaelder           Expires December 17, 2007               [Page 6]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


   rows are persistent.  The COPS-PR [RFC3084]protocol binds provisioned
   information to the existence of the COPS-PR session which provisioned
   policy information.  The NETCONF protocol [RFC4741] has a concept of
   different data stores (running, startup, candidate) that imply
   whether configuration state is persistent or not.

   Given these fundamentally different approaches, it is difficult to
   write protocol neutral configuration data models that work equally
   well with the various management protocols.  While it is possible to
   introduce say StorageType columns in protocol mappings, it is
   sometimes awkward to define the semantics of data objects if the
   persistence model is left to the protocol mappings.

3.6.  Selection of Language Features

   A data modeling language should be based on a small orthogonal set of
   language features.  In addition, the language should be minimalistic.
   During the design of the language, it is useful to repeatedly ask the
   question why certain features are needed or whether there are any
   language rules without a strong justification.  The general principle
   stated by Antoine de Saint-Exupery holds:

      Perfection [in design] is achieved, not when there is nothing more
      to add, but when there is nothing left to take away.

   Language features should be selected by considering what tools can do
   with the information formalized by a language feature.  In the
   general case, language features should raise automation and improve
   clarity.  Features without a clear justification that they actually
   reduce implementation efforts or significantly improve the clarity of
   a data model specification should not be accepted.

3.7.  Syntax versus Semantics

   During the design of a data modeling language, it is most important
   to focus on a clear semantic of all language constructs.  Syntactical
   issues are of secondary importance.  While this may sound obvious, it
   is important especially in open concensus driven processes to keep
   contributors reminded that semantics of language constructs come
   first while the syntactic aspects are of secondary importance.

3.8.  Reuse of Definitions

   A good data modeling language should allow data model writers to
   produce reusable definitions.  However, not all definitions are
   equally easy to reuse.  Experience has shown that data types derived
   from a small set of base types are usually very easy to reuse;
   structured data types are often getting slightly more complex to



Schoenwaelder           Expires December 17, 2007               [Page 7]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


   reuse.  Reusing collections of structured data types with non-trivial
   interrelationships are often difficult to reuse.  The low hanging
   fruits are therefor the simple type definitions.

   Sub-typing is frequently used to add specific semantics to a more
   generic type and to constrain the set of possible values.  While
   constraining values is often a good thing, it should be noted that
   too strict constraints can turn out to be painful in the future.
   There are many examples where data types proved too constrained to
   represent protocols that followed a natural evolution.

3.9.  Versioning and Meta Information

   Changes to data models are inevitable.  Even the most careful design
   and review process will not be able to predict how technologies
   evolve in the future.  It is therefore crucial that the data modeling
   language supports a suitable versioning model and that it established
   clear rules which changes are possible without having to change a
   version number or (module) name.  Supporting complex collections of
   meta data (e.g., a granular revision log) as part of the data
   modeling language may be less of an issue since such information can
   often be maintained in revision control systems and automatically
   places into comments where needed.

3.10.  Extensibility

   It has proven to be useful to support language extensibility features
   that avoid backward compatibility problems with existing parsers when
   new language features are introduced.  If a data modeling language
   supports language extensions, it should be possible to gradually
   introduction of new language features.

   Supporting language extensions essentially requires to be very
   consistent with the syntactic structure so that implementations can
   skip over new language constructs.  In addition, it is necessary to
   precisely identify language extensions so that implementations
   supporting extensions know where to apply the appropriate additional
   processing.

3.11.  Language Independence

   Once way to define a new data modeling language is to start from an
   existing language and to extend it and/or subset it as needed.
   However, there are some dangers associated with this approach.  Since
   languages that are used are not static, it is important to deal with
   conflicts that can arise if the base language is revised such that
   the extensions or subsets do not work anymore.  This issue becomes
   particularly important if different organizations have change control



Schoenwaelder           Expires December 17, 2007               [Page 8]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


   since this makes coordination relatively complex.  Things get even
   worse if the data modeling extension constitutes not a significant
   usage of the core language.

   The alternative is to provide a complete and self-contained
   definition for the data modeling language.  This protects against
   change control issues and also makes it simpler for implementors or
   data model writers to find all language rules in one place.

   As a general rule, there is hardly a reason to import language
   definitions.  If you like to import something from a source that is
   likely to change, do not import.  If, however, the source is assumed
   to be stable, then you can just import by value and explain the
   relationship to the original source.

3.12.  Compliance and Conformance

   Any successful data modeling language will at some point have to deal
   with compliance and conformance definitions.  However, getting
   language features to express compliance and conformance statements
   right is non-trivial.  Very fine grained mechanisms to define
   implementation requirements for different usage scenarios can lead to
   very detailed but also very complex compliance and conformance
   definitions that are difficult to understand and review.

   It is therefore important to make a good tradeoff between the
   required expressiveness and the pragmatic usage of compliance and
   conformance definitions.  The general considerations for language
   features discussed Section 3.6 particularly apply here.  One approach
   is to first gain experience with the usage of a new data modeling
   language and to support compliance and conformance definitions
   through language extensions.


4.  Conclusions

   This memo documents some of the insights gained in the SMIng project
   in order to guide future data modeling language designers by making
   them aware of some of the problems encountered in the SMIng project
   and some of the design guidelines that have been developed through
   the project.


5.  IANA Considerations

   This document has no IANA actions.





Schoenwaelder           Expires December 17, 2007               [Page 9]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


6.  Security Considerations

   This document discusses lessons learned during the design of a
   network management data modeling language and they have no impact on
   the security of the Internet.


7.  Acknowledgements

   Many people contributed directly or indirectly to this documented
   through their participation in the SMIng project.  Frank Strauss
   provided valuable feedback on earlier versions of this document.


8.  Informative References

   [RFC2579]  McCloghrie, K., Perkins, D., and J. Schoenwaelder,
              "Textual Conventions for SMIv2", RFC 2579, April 1999.

   [RFC3084]  Chan, K., Seligson, J., Durham, D., Gai, S., McCloghrie,
              K., Herzog, S., Reichmeyer, F., Yavatkar, R., and A.
              Smith, "COPS Usage for Policy Provisioning (COPS-PR)",
              RFC 3084, March 2001.

   [RFC3780]  Strauss, F. and J. Schoenwaelder, "SMIng - Next Generation
              Structure of Management Information", RFC 3780, May 2004.

   [RFC3781]  Strauss, F. and J. Schoenwaelder, "Next Generation
              Structure of Management Information (SMIng) Mappings to
              the Simple Network Management Protocol (SNMP)", RFC 3781,
              May 2004.

   [RFC3444]  Pras, A. and J. Schoenwaelder, "On the Difference between
              Information Models and Data Models", RFC 3444,
              January 2003.

   [RFC4741]  Enns, R., "NETCONF Configuration Protocol", RFC 4741,
              December 2006.













Schoenwaelder           Expires December 17, 2007              [Page 10]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


Author's Address

   Juergen Schoenwaelder
   Jacobs University Bremen
   Campus Ring 1
   28725 Bremen
   Germany

   Phone: +49 421 200-3587
   Email: j.schoenwaelder@jacobs-university.de









































Schoenwaelder           Expires December 17, 2007              [Page 11]

Internet-Draft   Lessons Learned from the SMIng Project        June 2007


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Acknowledgment

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).





Schoenwaelder           Expires December 17, 2007              [Page 12]

