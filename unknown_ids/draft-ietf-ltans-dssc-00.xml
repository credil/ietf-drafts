<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY ETSI-TS102176-1-2005 PUBLIC '' 
      'http://ltans.edelweb.fr/references/reference.ETSI-TS102176.1.2005.xml'>
    <!ENTITY ETSI-TS102176-2-2005 PUBLIC '' 
      'http://ltans.edelweb.fr/references/reference.ETSI-TS102176.2.2005.xml'>
    <!ENTITY rfc3275 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3275.xml'>
    <!ENTITY I-D-ietf-ltans-ers PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ltans-ers.xml'>
    <!ENTITY DSS PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml2/reference.FIPS.186-1.1998.xml'> 
    <!ENTITY PKCS1 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2437.xml'>
     <!ENTITY rfc3852 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3852.xml'>
     <!ENTITY I-D-ietf-ltans-ltap PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-ltans-ltap-04.xml'>
]>

<rfc category="std" ipr="full3978" docName="draft-ietf-ltans-dssc-00.txt">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

    <front>
        <title abbrev="DSSC">Data Structure for Security Suitabilities of Cryptographic Algorithms (DSSC)</title>
        
        <author fullname="Thomas Kunz" initials="T." surname="Kunz">
		  <organization>Fraunhofer Institute for Secure Information Technology</organization>
		  <address>
			<postal>
			  <street>Rheinstrasse 75</street>
			  <city>Darmstadt</city>
			  <code>D-64295</code>
			  <country>Germany</country>
			</postal>
			<email>thomas.kunz@sit.fraunhofer.de</email>
		  </address>
		</author>
        <author fullname="Susanne Okunick" initials="S." surname="Okunick">
		  <organization>Fraunhofer Institute for Secure Information Technology</organization>
		  <address>
			<postal>
			  <street>Rheinstrasse 75</street>
			  <city>Darmstadt</city>
			  <code>D-64295</code>
			  <country>Germany</country>
			</postal>
			<email>susanne.okunick@sit.fraunhofer.de</email>
		  </address>
		</author>
        <author fullname="Ulrich Pordesch" initials="U." surname="Pordesch">
		  <organization>Fraunhofer Gesellschaft</organization>
		  <address>
			<postal>
			  <street>Rheinstrasse 75</street>
			  <city>Darmstadt</city>
			  <code>D-64295</code>
			  <country>Germany</country>
			</postal>
			<email>ulrich.pordesch@zv.fraunhofer.de</email>
		  </address>
		</author>
        <date day="22" month="June" year="2007" />
		<area>Security Area</area>

		<workgroup>Long-term Archive And Notary Services (LTANS)</workgroup>

		<keyword>long term archive</keyword>
		<keyword>security</keyword>
		<keyword>policy</keyword>
		<keyword>hash algorithm</keyword>
		<keyword>public key algorithm</keyword>
		
        <abstract>
        	<t>
        	In many application areas it must be possible to prove the existence
        	and integrity of digital signed data. This proof depends on the
        	security suitability of the used cryptographic algorithms. 
        	Because algorithms can become weak over the years, it is necessary
        	to periodically evaluate these security suitabilities. When signing
        	or verifying data, these evaluations must be considered.
        	This document specifies a data structure for security suitabilities
        	of cryptographic algorithms which may be automatically interpreted.
        	</t>
        </abstract>
        
        <note title="Conventions used in this document">
		<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
	   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
	   document are to be interpreted as described in <xref target="RFC2119" />.</t>
	  </note>
    </front>

    <middle>
       <section title="Introduction">
       	       <section title="Motivation">
	       <t>
	       Digital signatures are means to provide data integrity and authentication.
	       They are based on cryptographic algorithms, which must have certain security
	       properties. For example, hash algorithms have to be resistant to collisions and in
	       the case of public key algorithms it must not be possible to compute the private key of a 
	       given public key. If algorithms did not have the required properties, 
	       signatures could be forged.
	       </t>
	       <t>
	       Only some algorithms satisfy the security requirements and 
	       are suitable for usage in signatures. Besides, because of the increasing performance 
	       of computers and progresses in cryptography, algorithms or their parameters 
	       become insecure over the years. E.g. the hash algorithm MD5 is impractical by now.
	       A digital signature using such "weak" algorithms may lose its probative value.
	       Every kind of digital signed data like signed documents, time stamps,
	       certificates, and revocation lists is affected, in particular in the case of long-term archiving.
	       Over long periods of time, it is realistic to assume that the algorithms 
	       used in signatures become insecure.
	       </t>
	       <t>
	       For this reason, it is important to periodically reevaluate algorithms regarding
	       their security properties and to consider these evaluations when creating, verifying 
	       or renewing signatures. Such evaluations will give a prognosis how long an algorithm
	       will be presumably secure and help to detect, whether insecure algorithms are used in a signature or whether
	       signatures have been timely renewed.	       
	       The evaluation of security suitabilites of algorithms cannot be done by the user itself. They
	       are made by expert committees after long scientific discussion and published by specific 
	       evaluation institutions. In Germany the Federal Network Agency annually publishes a current 
	       evaluation of cryptografic algorithms <xref target='BNetzAg.2007' />. Examples for European and
	       international evaluations are <xref target='NIST.800-57-Part1.2006' /> and 
	       <xref target='ETSI-TS102176-1-2005' />. 
	       </t>
	       <t>
	       These publications evaluate algorithms in a textual form and are not interpretable by 
	       computer programs. Therefore it is necessary to define an 
	       automatically interpretable data structure holding the
	       algorithm evaluations.
	       In this way evaluation institutions are able use the standardized form for publication. 
	       Such policies can be interpreted by e.g. signing and verification tools.
	       In the following, such evaluations are called 
	       security suitability policy.
	       This document specifies a data structure for security suitability policies.
	       </t>
       	       </section>
       	       <section title="Use Cases">
       	       <t>
       	       In the following we present some use cases for security suitability policies.
       	       <list style="hanging">
       	            <t hangText="Long-term archiving:">
       	            The most important use case for security suitability policies is long-term archiving
       	            of signed data. Algorithms or their parameters will become insecure over very 
       	            long periods of time.        	            
       	            Policies are used to determine whether signatures
       	            have to be renewed. That means, the policies must provide information, which algorithms
       	            are currently suitable and which are not.
       	            Additionally the policies assist in verifying archived documents
       	            since it has to be checked whether all signatures were timely renewed by time stamping, 
       	            i.e. before algorithms became insecure.
       	            </t>
       	            
       	            <t hangText="Signing and verifying:">
       	            When signing documents or certificates it has to be assured that the algorithms
       	            which will be used for signing are suitable. Accordingly when verifying 
       	            e.g CMS (<xref target='RFC3852' />) or XML signatures 
       	            (<xref target="RFC3275" />, <xref target='ETSI-TS101903' />), not only the
       	            validity of the certificates may be checked, but also the validity of the used
       	            algorithms.
       	            </t>
       	            
       	            <t hangText="Services:">
       	            Services may provide information about cryptographic algorithms.
       	            E.g. such services can use these policies to provide the date when an algorithm
       	            became insecure or probably will become insecure or to provide all algorithms 
       	            which are presently valid.
       	            Such services could be used by verification tools or long-term archiving systems
       	            so that they do not need to deal with the algorithm security by themselves.
       	            <vspace blankLines='0' />
       	            Long-term archive services supporting LTAP (<xref target='I-D.ietf-ltans-ltap' />)
       	            for providing evidence records (<xref target='I-D.ietf-ltans-ers' />) may use
       	            the policies for signature renewal. Additionally the policies may be integrated
       	            in the ERS as further validation data.
       	            </t>
       	            
       	            <t hangText="Reencryption:">
       	            Security suitability policies can also be used to decide if encrypted documents
       	            must be reencrypted because the encryption algorithm is no longer secure.
       	            </t>
       	       </list>
       	       </t>
       	       </section>
       </section>
       
       <section title="Terminology">
       		<t>
       		<list style="hanging">
       		<t hangText="Algorithm:">
       		In the context of this document, a cryptographic algorithm, i.e. a public key or hash algorithm. For 
       		public key algorithms this is the algorithm with its corresponding parameters.
       		</t>
       		<t hangText="Operator:">
       		Instance which uses and interprets a policy, e.g. a signature component.
       		</t>
       		<t hangText="Policy:">
       		In this document, an abbreviation for security suitability policy.
       		</t>
       		<t hangText="Publisher:">
       		Instance that analyzes and evaluates algorithms and publishes them in the form of policies.
       		</t>
       		<t hangText="Security suitability policy:">
       		The evaluation of cryptographic algorithms according to their security in a 
       		specific application area, e.g. signing or verifying data.		
       		The evaluation is published in an electronic format.
       		</t>
       		<t hangText="Suitable algorithm:">
       		An algorithm which is evaluated in a policy, i.e. is rated to be valid. 
       		</t>
       		</list>
       		</t>
       </section>
       
       <section title="Requirements and Assumptions">
       	<t>
       	This section first describes general requirements for a data structure containing 
       	the securitiy suitabilities of algorithms. Afterwards model assumptions are specified 
       	concerning both the design and the usage of the data structure.
       	</t>
       	<t>
       	An evaluation of the security suitability of algorithms results in a policy. 
	It contains a list of the evaluated algorithms. An evaluated algorithm is described 
	by its identifier, security constraints and predicted validity period. 
	By these constraints the requirements for algorithm properties must be defined, 
	e.g. a public key algorithm is evaluated on the basis of its parameter.
	</t>
	       	<section title="Requirements">
	       	<t>
	       	<list style="hanging">
	       	<t hangText="Automatic interpretation:">
	       	The data structure of the policy must allow an automatic interpretation in order to 
	       	consider the security suitabilities of algorithms when signing, verifying or
	       	renewing signatures.
	       	</t>
	       	<t hangText="Flexibility:">
		The data structure must be flexible enough to support new algorithms. 
		In a future policy publication an algorithm could be included, 
		that is currently unknown. It must be possible to add new algorithms with 
		the corresponding security constraints in the data structure.
		Besides, the data structure must be independent of the intended purpose, 
		e.g. signing, verification, signature renewal.
		</t>
	       	<t hangText="Considering different policies:">
		Policies may be published by different institutions, e.g. on national or EU level, 
		whereas one policy needs not to be in agreement with the other one. 
		Furthermore organizations may undertake own evaluations for internal purposes. 
		For this reason a policy must be attributable to its publisher. 
		</t>
	       	<t hangText="Integrity and authenticity:">
		The integrity and authenticity of a published security suitability policy should be assured. 
		The publisher must be able to sign the policy so that operators may prove 
		the identity and trustworthiness of a policy. 
		</t>
	       	<t hangText="Considering old algorithm suitabilities:">
		Policies may be periodically published, e.g. annually. For some applications it may be 
		desirable to interpret older policies. To automatically verify an old signature, 
		the security suitability of the used algorithms at the signing time must be determinable. 
		Therefore that policy is relevant which has been valid at signing time. 
		The date of publishing must be part of the policy.
		</t>
		</list>
		</t>
		</section>
		<section title="Assumptions">
	    	<t>
		Only the latest policy is significant to decide whether an algorithm is currently suitable. 
		Is an algorithm listed in the current security suitability policy it is valid now, otherwise not.
		</t>
	       	<t>
		To decide whether an algorithm was suitable at a date in the past, 
		you have to find a policy published between this date and today.
		This method also contains the following case: If an algorithm has not been existent at 
		a date in the past and evaluated in a later policy for the first time, 
		it will be assumed that the algorithm has then already been suitable. 
		Generally an algorithm is used in practice before it is evaluated.
		</t>
		<t>
		An algorithm is suitable only if it meets all requirements made in the relevant policy.
		</t>
	       	<t>
		Algorithms listed in the policy are suitable at least until the next policy is published.
		</t>
	       	<t>
		An algorithm once removed from a policy, is invalid and must not appear in a future policy.
		There must not be any gaps in the validity periods.
	       </t>
	       </section>
       </section>
       
       <section title="Data Structures">
       		<t>
       		This section describes the syntax of a security suitability policy. The syntax is
       		defined as an XML schema. The schema uses the following namespace:
       		<list style="empty">
       			<t>http://www.sit.fraunhofer.de/ssp</t>
       		</list>
       		Within this document, the prefix "ssp" is used for this namespace. The schema starts
       		with the following schema definition:
       		<figure>
       		<artwork>
       		<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
           xmlns:ssp="http://www.sit.fraunhofer.de/ssp" 
           xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
           targetNamespace="http://www.sit.fraunhofer.de/ssp" 
           elementFormDefault="qualified" 
           attributeFormDefault="unqualified">
<xs:import namespace="http://www.w3.org/XML/1998/namespace" 
           schemaLocation="http://www.w3.org/2001/xml.xsd"/>
<xs:import namespace="http://www.w3.org/2000/09/xmldsig#" 
           schemaLocation="xmldsig-core-schema.xsd"/>
]]>
       		</artwork>
       		</figure>
       		</t>
       		
       		<section title="SecuritySuitabilityPolicy">
       			<t>
       			The SecuritySuitabilityPolicy element is the root element
       			of a policy. It has an optional id attribute which must be
       			used as a reference when signing the policy (<xref target="Signature"/>).
       			The element is defined by the following schema:
       			<figure>
       			<artwork>
       			<![CDATA[
<xs:element name="SecuritySuitabilityPolicy" 
            type="ssp:SecuritySuitabilityPolicyType"/>
<xs:complexType name="SecuritySuitabilityPolicyType">
  <xs:sequence>
    <xs:element ref="ssp:PolicyName"/>
    <xs:element ref="ssp:Publisher"/>
    <xs:element name="PolicyIssueDate" type="xs:dateTime"/>
    <xs:element name="NextUpdate" type="xs:dateTime" minOccurs="0"/>
    <xs:element ref="ssp:SecuritySuitability" maxOccurs="unbounded"/>
    <xs:element ref="ds:Signature" minOccurs="0"/>
  </xs:sequence>
  <xs:attribute name="version" type="xs:string" default="1"/>
  <xs:attribute name="id" type="xs:ID"/>
</xs:complexType>
]]>
       			</artwork>
       			</figure>
       			</t>
       		</section>
       		<section title="PolicyName">
       			<t>
       			The PolicyName element contains the name of the policy.
      			It consists of the actual name and an optional URI. 			
       			<figure>
       			<artwork>
       			<![CDATA[
<xs:element name="PolicyName" type="ssp:PolicyNameType"/>
<xs:complexType name="PolicyNameType">
  <xs:sequence>
    <xs:element ref="ssp:Name"/>
    <xs:element ref="ssp:URI" minOccurs="0"/>
  </xs:sequence>
</xs:complexType>

<xs:element name="Name" type="xs:string"/>
<xs:element name="URI" type="xs:anyURI"/>
]]>
       			</artwork>
       			</figure>
       			</t>
       		</section>
       		<section title="Publisher">
       			<t>
       			The Publisher element contains information about the
       			publisher of the policy. It is composed of the name,
       			an optional address, and an optional URI.
       			<figure>
       			<artwork>
       			<![CDATA[
<xs:element name="Publisher" type="ssp:PublisherType"/>
<xs:complexType name="PublisherType">
  <xs:sequence>
    <xs:element ref="ssp:Name"/>
    <xs:element ref="ssp:Address" minOccurs="0"/>
    <xs:element ref="ssp:URI" minOccurs="0"/>
  </xs:sequence>
</xs:complexType>
]]>
       			</artwork>
       			</figure>
       			</t>
       		</section>
       		<section title="Address">
       		<t>
       		The Address element consists of the street, the locality,
       		the optional state or province, the postal code, and the country.
       		<figure>
       		<artwork>
       		<![CDATA[
<xs:element name="Address" type="ssp:AddressType"/>
<xs:complexType name="AddressType">
  <xs:sequence>
    <xs:element name="Street" type="xs:string"/>
    <xs:element name="Locality" type="xs:string"/>
    <xs:element name="StateOrProvince" type="xs:string" minOccurs="0"/>
    <xs:element name="PostalCode" type="xs:string"/>
    <xs:element name="Country" type="xs:string"/>
  </xs:sequence>
</xs:complexType>
]]>
       		</artwork>
       		</figure>
       		</t>
       		</section>
       		<section title="PolicyIssueDate">
       		<t>
       		The PolicyIssueDate element indicates the point of time when the policy was issued.
       		</t>
       		</section>
       		<section title="NextUpdate">
       		<t>
       		The optional NextUpdate element may be used to indicate when the next policy will be issued.
       		</t>
       		</section>
       		<section title="SuitableAlgorithm">
       		<t>
       		A security suitability policy must contain at least one SuitableAlgorithm element.
       		A SuitableAlgorithm element describes the evaluation of one suitable cryptographic algorithm.
       		An algorithm can be identified by a name, object identifiers, and URIs. 
       		Additionally specific parameter constraints, e.g. a required modulus length, can be specified.
       		The suitability of the algorithm is expressed by a validity period.
       		An algorithm is suitable according to the respective policy if it complies with the
       		security suitability defined by the respective SuitableAlgorithm element.
       		The SuitableAlgorithm element is defined by the following schema:
       		<figure>
       		<artwork>
       		<![CDATA[
<xs:element name="SuitableAlgorithm" type="ssp:SuitableAlgorithmType"/>
<xs:complexType name="SuitableAlgorithmType">
  <xs:sequence>
    <xs:element ref="ssp:AlgorithmIdentifier"/>
    <xs:element name="ParameterConstraints" minOccurs="0">
      <xs:complexType>
        <xs:sequence>
          <xs:any namespace="##any"/>
        </xs:sequence>
        <xs:attribute name="uri" type="xs:anyURI"/>
      </xs:complexType>
    </xs:element>
    <xs:element ref="ssp:Validity"/>
    <xs:element ref="ssp:Information" minOccurs="0"/>
  </xs:sequence>
</xs:complexType>
]]>
       		</artwork>
       		</figure>
       		</t>
       		</section>
       		<section title="AlgorithmIdentifier">
       		<t>
       		The AlgorithmIdentifier element is used to identify a cryptographic algorithm.
       		It consists of the algorithm name and optionally one or more object identifers and URIs.
       		The element is defined as follows:
       		<figure>
       		<artwork>
       		<![CDATA[
<xs:element name="AlgorithmIdentifier" 
            type="ssp:AlgorithmIdentifierType"/>
<xs:complexType name="AlgorithmIdentifierType">
  <xs:sequence>
    <xs:element ref="ssp:Name"/>
    <xs:element name="ObjectIdentifier" type="xs:string" 
                minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="ssp:URI" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
</xs:complexType>
]]>
       		</artwork>
       		</figure>
       		</t>
       		</section>
       		<section title="ParameterConstraints">
       		<t>
       		By the ParameterConstraints element, constraints on algorithm specific parameters
       		can be expressed. E.g. the suitability of the RSA algorithm depends on the "modulus" 
       		parameter (RSA with modulus = 1024 may have another suitability period as
       		RSA with modulus = 2048). Since the parameters depend on the actual algorithm, it is impossible
       		to specify one data structure covering all algorithms. Instead, an "any" element is used
       		in the schema to express that an arbitrary XML structure can be inserted.
       		The following two sections define XML schemas for RSA and DSA parameters. Parameter constraints
       		needed for other algorithms may be specified in separate XML schemas.
       		Note that not all algorithm suitabilities depend on parameter constraints, e.g. current
       		hash algorithms like SHA-1 or RIPE-MD 160 do not have any parameters.
       		</t>
       		
       			<section title="RSAConstraints">
       			<t>
       			The RSAConstraints element must be used as parameter constraint in all RSA
       			security suitabilities. It contains the bit length of the RSA modulus <xref target="RFC2437" />.
       			The element is defined by the following schema:
       			<figure>
       			<artwork>
       			<![CDATA[
<xs:element name="RSAConstraints" type="ssp:RSAConstraintsType"/>
<xs:complexType name="RSAConstraintsType">
  <xs:sequence>
    <xs:element name="modulus">
      <xs:complexType>
        <xs:attribute name="length" type="xs:integer" use="required"/>
      </xs:complexType>
    </xs:element>
  </xs:sequence>
</xs:complexType>
]]>
       			</artwork>
       			</figure>       			
       			</t>
       			</section>
       			<section title="DSAConstraints">
       			<t>
       			The DSAConstraints element must be used as parameter constraint in all DSA
       			security suitabilities. It is composed of the bit lengths of the two public 
       			DSA parameters "p" (prime modulus) and "q" (prime divisor of p-1), both
       			meeting the requirements defined in <xref target="FIPS.186-1.1998"/>.
       			The element is defined by the following schema:
       			<figure>
       			<artwork>
       			<![CDATA[
<xs:element name="DSAConstraints" type="ssp:DSAConstraintsType"/>
<xs:complexType name="DSAConstraintsType">
  <xs:sequence>
    <xs:element name="p">
      <xs:complexType>
        <xs:attribute name="length" type="xs:integer" use="required"/>
      </xs:complexType>
    </xs:element>
    <xs:element name="q">
      <xs:complexType>
        <xs:attribute name="length" type="xs:integer" use="required"/>
      </xs:complexType>
    </xs:element>
  </xs:sequence>
</xs:complexType>
]]>
       			</artwork>
       			</figure>       			
       			</t>
       			</section>
       		</section>
       		<section title="Validity">
       		<t>
       		The Validity element is used to define the period of the (estimated) suitability
       		of the algorithm. It is  composed of a start date and an end date.
       		The element is defined by the following schema:
       		<figure>
       		<artwork>
       		<![CDATA[
<xs:element name="Validity" type="ssp:ValidityType"/>
<xs:complexType name="ValidityType">
  <xs:sequence>
    <xs:element name="Start" type="xs:date"/>
    <xs:element name="End" type="xs:date"/>
  </xs:sequence>
</xs:complexType>
]]>
       		</artwork>
       		</figure>
       		</t>
       		</section>
       		<section title="Information">
       		<t>
       		The Information element may be used to give additional textual information
       		about the algorithm or the evaluation, e.g. references on algorithm specifications.
       		The element is defined as follows:
       		<figure>
       		<artwork>
       		<![CDATA[
<xs:element name="Information" type="ssp:InformationType"/>
<xs:complexType name="InformationType">
  <xs:sequence>
    <xs:element name="Text" maxOccurs="unbounded">
      <xs:complexType>
        <xs:simpleContent>
          <xs:extension base="xs:string">
            <xs:attribute name="lang"/>
          </xs:extension>
        </xs:simpleContent>
      </xs:complexType>
    </xs:element>
  </xs:sequence>
</xs:complexType>
]]>
       		</artwork>
       		</figure>
       		</t>
       		</section>
       		<section title="Signature" anchor="Signature">
       		<t>
       		The optional Signature element may be used to guarantee the integrity and authenticity
       		of the policy. It is an XML signature specified in <xref target="RFC3275" />.
       		The signature must relate to the SecuritySuitabilityPolicy element. If the Signature element
       		is set, the SecuritySuitabilityPolicy element must have the optional id attribute. This attribute
       		must be used to reference the SecuritySuitabilityPolicy element within the Signature element.
       		Since it is an enveloped signature, the signature must use the transformation algorithm identified
       		by the following URI:
       		<list style="empty">
       			<t>http://www.w3.org/2000/09/xmldsig#enveloped-signature</t>
       		</list>
       		</t>
       		</section>
       
       </section>
       
       <section title="Proceeding">
       <t>
       This section shows which information must be gathered in the different use cases
       and how to proceed to get this information.
       
       <list style="numbers">
		   <t>
	           Is an algorithm currently valid?
		   <vspace blankLines='0' />
	           Procedure: Take the current policy and check whether 
	           this algorithm is listed in it.
		   If it is, the algorithm is currently suitable.
		   <vspace blankLines='0' />
		   Input: algorithm
		   <vspace blankLines='0' />
		   Response: true or false
	           </t>
	           <t>
	           Did an algorithm have been valid at a particular date in the past?
		   <vspace blankLines='0' />
		   Procedure: Find the latest policy published after this particular date
		   containing this algorithm. If such a policy exists, the
		   algorithm has been suitable at the specified date.
		   <vspace blankLines='0' />
		   Input: algorithm and date
		   <vspace blankLines='0' />
		   Response: true or false
	           </t>
	           <t>
	           Until which date in the future an algorithm is predicted to be valid?
		   <vspace blankLines='0' />
		   Procedure: Take the current policy and get the predicted validity end date of 
		   this algorithm, if the algorithm exists in the policy.
		   <vspace blankLines='0' />
		   Input: algorithm
		   <vspace blankLines='0' />
		   Response: date or error, if the algorithm does not exist
	           </t>
	           <t>
	           At which date became an algorithm invalid?
		   <vspace blankLines='0' />
		   Procedure: First it has to be assured, that the given algorithm has been valid at any time 
		   in the past.
		   Find the last policy containing this algorithm and generate the minimum 
		   of the predicted validity end date and the publication date of the following
		   policy.
		   <vspace blankLines='0' />
		   Input: algorithm
		   <vspace blankLines='0' />
		   Response: date or error, if date has never been valid or is valid now
	           </t>
	           <t>
	           Which algorithms are currently valid?
		   <vspace blankLines='0' />
		   Procedure: All algorithms included in the current policy are valid.
		   <vspace blankLines='0' />
		   Response: list of algorithms
	           </t>
	           <t>
	           Which algorithms have been valid at a particular date in the past?
		   <vspace blankLines='0' />
	           Procedure: All algorithms in a policy published at this date have been valid.
		   Additionally any algorithm newly added in one following policy
		   has been valid.
		   <vspace blankLines='0' />
		   Input: date
		   <vspace blankLines='0' />
		   Response: list of algorithms
	           </t>
  	</list>
       </t>
       </section>

        <section title="Security Considerations">
        <t>The used policies for security suitabilities have great impact on the quality
        of signatures and verification results. If evaluations of algorithms are wrong,
        signatures with a low probative force could be created and verification results
        could be incorrect. The following security considerations have been identified:
        <list style="numbers">
        <t>
        An institution publishing a policy must take care via organizational measures 
        that unauthorized manipulation of security suitabilities is impossible before a policy is 
        signed and published.
        </t>
        <t>
        A client should only accept signed policies issued by a trusted institution.
        It must not be possible to unnoticeably manipulate or replace security suitabilities once
        accepted by the client.
        </t>
        <t>
        A threat arises when a client downloads a policy too late 
        although the policy has already been published. In this case, the client would work
        with obsolete security suitabilities. To minimize this risk, the client should
        periodically check if new policies are published. This check could be done automatically
        by signature and verification components.
        </t>
        <t>
        When signing a policy, only algorithms should be used which are suitable according this policy.
        </t>
        </list>
        </t>
        </section>
    </middle>

    <back>
        <references title="Normative References">&rfc2119;&rfc3275;&rfc3852;&I-D-ietf-ltans-ltap;
        	<reference anchor="ETSI-TS101903">
			<front>
  				<title>XML Advanced Electronic Signatures (XAdES)</title> 
  				<author>
  				<organization>European Telecommunication Standards Institute (ETSI)</organization> 
  				</author>
  				<date month="Feb" year="2002" /> 
  			</front>
  			<seriesInfo name="ETSI" value="TS 101 903" /> 
  		</reference>
        </references>
        <references title="Informative References">&ETSI-TS102176-1-2005;&I-D-ietf-ltans-ers;&DSS;&PKCS1;
		<reference anchor="NIST.800-57-Part1.2006">
			<front>
  				<title>Recommendation for Key Management – Part 1: General (Revised)</title> 
  				<author>
  				<organization>National Institute of Standards and Technology</organization> 
  				</author>
  				<date month="May" year="2006" /> 
  			</front>
  			<seriesInfo name="NIST" value="800-57 Part1" /> 
  		</reference>
  		<reference anchor="BNetzAg.2007" target="http://www.bundesnetzagentur.de/media/archive/9655.pdf">
			<front>
  				<title>Bekanntmachung zur elektronischen Signatur nach dem Signaturgesetz
  				und der Signaturverordnung (Übersicht über geeignete Algorithmen)</title> 
  				<author>
  				<organization>Federal Network Agency for Electricity, Gas, Telecommunications, Post and Railway</organization> 
  				</author>
  				<date month="April" year="2007" /> 
  			</front>
  		</reference>
  	</references>
  	
  	<section title="Verification of Evidence Records using DSSC">
  		<t>
  		This section describes the verification of an Evidence Record according to 
  		the Evidence Record Syntax <xref target="I-D.ietf-ltans-ers" /> 
  		by using the presented data structure. Because Evidence Records contain hashtrees
  		secured with time stamps and both the security of hashtrees and time stamp signatures 
  		depend on the used algorithms this is a suitable example to demonstrate a verification.
  		Precondition of the procedure is that at least one policy
  		is present.
  		</t>
  		<t>
  		An Evidence Record contains a sequence of archiveTimeStampChains which
  		consist of ArchiveTimeStamps.
  		For each archiveTimeStamp the hash algorithm used for the hash tree
  		(digestAlgorithm) and the public key algorithm and hash algorithm in the 
  		time stamp signature have to be examined. 
  		The definitive date is the time information in the time stamp (date of issue).
  		Starting with the first ArchiveTimestamp it has to be assured that
  		<list style="numbers">
	           <t>
	           The time stamp uses public key and hash algorithms 
	           which have been suitable at the date of issue.
	           </t>
	           <t>
	           The hashtree was build with an hash algorithm that has been suitable 
	           as well.
	           </t>
	           <t>
	           Algorithms for time stamp and hashtree in the preceding ArchiveTimestamp 
	           must have been suitable at date of considered ArchiveTimestamp.
	           </t>
	           <t>
	           Algorithms in the last ArchiveTimstamp have to be suitable now.
	           </t>
	        </list>
	        If the check of one of these item fails, this will lead to a failure of the
	        verification.
  		</t>
  	</section>
  	
  	<section title="XML schema">
  	<t>
  	<figure>
       	<artwork>
       	<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
           xmlns:ssp="http://www.sit.fraunhofer.de/ssp" 
           xmlns:ds="http://www.w3.org/2000/09/xmldsig#" 
           targetNamespace="http://www.sit.fraunhofer.de/ssp" 
           elementFormDefault="qualified" 
           attributeFormDefault="unqualified">
<xs:import namespace="http://www.w3.org/XML/1998/namespace" 
           schemaLocation="http://www.w3.org/2001/xml.xsd"/>
<xs:import namespace="http://www.w3.org/2000/09/xmldsig#" 
           schemaLocation="xmldsig-core-schema.xsd"/>
           
<xs:element name="SecuritySuitabilityPolicy" 
            type="ssp:SecuritySuitabilityPolicyType"/>
            
<xs:complexType name="SecuritySuitabilityPolicyType">
  <xs:sequence>
    <xs:element ref="ssp:PolicyName"/>
    <xs:element ref="ssp:Publisher"/>
    <xs:element name="PolicyIssueDate" type="xs:dateTime"/>
    <xs:element name="NextUpdate" type="xs:dateTime" minOccurs="0"/>
    <xs:element ref="ssp:SuitableAlgorithm" maxOccurs="unbounded"/>
    <xs:element ref="ds:Signature" minOccurs="0"/>
  </xs:sequence>
  <xs:attribute name="version" type="xs:string" default="1"/>
  <xs:attribute name="id" type="xs:ID"/>
</xs:complexType>

<xs:element name="PolicyName" type="ssp:PolicyNameType"/>

<xs:complexType name="PolicyNameType">
  <xs:sequence>
    <xs:element ref="ssp:Name"/>
    <xs:element ref="ssp:URI" minOccurs="0"/>
  </xs:sequence>
</xs:complexType>

<xs:element name="Publisher" type="ssp:PublisherType"/>

<xs:complexType name="PublisherType">
  <xs:sequence>
    <xs:element ref="ssp:Name"/>
    <xs:element ref="ssp:Address" minOccurs="0"/>
    <xs:element ref="ssp:URI" minOccurs="0"/>
  </xs:sequence>
</xs:complexType>

<xs:element name="Name" type="xs:string"/>

<xs:element name="URI" type="xs:anyURI"/>

<xs:element name="Address" type="ssp:AddressType"/>

<xs:complexType name="AddressType">
  <xs:sequence>
    <xs:element name="Street" type="xs:string"/>
    <xs:element name="Locality" type="xs:string"/>
    <xs:element name="StateOrProvince" type="xs:string" minOccurs="0"/>
    <xs:element name="PostalCode" type="xs:string"/>
    <xs:element name="Country" type="xs:string"/>
  </xs:sequence>
</xs:complexType>

<xs:element name="SuitableAlgorithm" type="ssp:SuitableAlgorithmType"/>

<xs:complexType name="SuitableAlgorithmType">
  <xs:sequence>
    <xs:element ref="ssp:AlgorithmIdentifier"/>
    <xs:element name="ParameterConstraints" minOccurs="0">
      <xs:complexType>
        <xs:sequence>
          <xs:any namespace="##any"/>
        </xs:sequence>
        <xs:attribute name="uri" type="xs:anyURI"/>
      </xs:complexType>
    </xs:element>
    <xs:element ref="ssp:Validity"/>
    <xs:element ref="ssp:Information" minOccurs="0"/>
  </xs:sequence>
</xs:complexType>

<xs:element name="AlgorithmIdentifier" 
            type="ssp:AlgorithmIdentifierType"/>

<xs:complexType name="AlgorithmIdentifierType">
  <xs:sequence>
    <xs:element ref="ssp:Name"/>
    <xs:element name="ObjectIdentifier" type="xs:string" 
                minOccurs="0" maxOccurs="unbounded"/>
    <xs:element ref="ssp:URI" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
</xs:complexType>

<xs:element name="Validity" type="ssp:ValidityType"/>

<xs:complexType name="ValidityType">
  <xs:sequence>
    <xs:element name="Start" type="xs:date"/>
    <xs:element name="End" type="xs:date"/>
  </xs:sequence>
</xs:complexType>

<xs:element name="Information" type="ssp:InformationType"/>

<xs:complexType name="InformationType">
  <xs:sequence>
    <xs:element name="Text" maxOccurs="unbounded">
      <xs:complexType>
        <xs:simpleContent>
          <xs:extension base="xs:string">
            <xs:attribute name="lang"/>
          </xs:extension>
        </xs:simpleContent>
      </xs:complexType>
    </xs:element>
  </xs:sequence>
</xs:complexType>

<xs:element name="RSAConstraints" type="ssp:RSAConstraintsType"/>

<xs:complexType name="RSAConstraintsType">
  <xs:sequence>
    <xs:element name="modulus">
      <xs:complexType>
        <xs:attribute name="length" type="xs:integer" use="required"/>
      </xs:complexType>
    </xs:element>
  </xs:sequence>
</xs:complexType>

<xs:element name="DSAConstraints" type="ssp:DSAConstraintsType"/>

<xs:complexType name="DSAConstraintsType">
  <xs:sequence>
    <xs:element name="p">
      <xs:complexType>
        <xs:attribute name="length" type="xs:integer" use="required"/>
      </xs:complexType>
    </xs:element>
    <xs:element name="q">
      <xs:complexType>
        <xs:attribute name="length" type="xs:integer" use="required"/>
      </xs:complexType>
    </xs:element>
  </xs:sequence>
</xs:complexType>
</xs:schema>

]]>
       	</artwork>
       	</figure>
  	</t>
  	</section>
    </back>

</rfc>
