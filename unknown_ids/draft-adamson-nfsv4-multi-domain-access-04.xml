<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY rfc1034 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml'>
<!ENTITY rfc1831 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1831.xml'>
<!ENTITY rfc2203 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2203.xml'>
<!ENTITY rfc2307 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2307.xml'>
<!ENTITY rfc2743 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2743.xml'>
<!ENTITY rfc3530 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3530.xml'>
<!ENTITY rfc4120 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml'>
<!ENTITY rfc4511 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4511.xml'>
<!ENTITY rfc5280 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml'>
<!ENTITY nfsv41  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-nfsv4-minorversion1.xml'>
<!ENTITY fedfsreqts  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-nfsv4-federated-fs-reqts.xml'>
<!ENTITY rpcsecgss3  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.williams-rpcsecgssv3.xml'>
<!ENTITY gssnamexts  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-kitten-gssapi-naming-exts.xml'>
<!ENTITY rfc2307bis  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-howard-rfc2307bis-02.xml'>
<!ENTITY krb5generalpac  PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-sorce-krbwg-general-pac-01.xml'>
]>

<?rfc toc="yes" ?>
<?rfc tocindent="no" ?>
<?rfc symrefs="yes" ?>

<rfc category="std" ipr="trust200902" docName="draft-adamson-nfsv4-multi-domain-access-04">

    <front>
	<title>NFSv4 Multi-Domain Access</title>

	<author initials='W.A.' surname="Adamson" fullname='William A. (Andy) Adamson'>
	    <organization>NetApp</organization>
	    <address>
		<email>andros@netapp.com </email>
	    </address>
	</author>

	<author initials='K.W.' surname="Coffman" fullname='Kevin Coffman'>
	    <organization>CITI, University of Michigan</organization>
	    <address>
		<email>kwc@umich.edu </email>
	    </address>
	</author>

	<author initials='N.' surname="Williams" fullname='Nicolas Williams'>
	    <organization>Oracle</organization>
	    <address>
		<email>nicolas.williams@oracle.com</email>
	    </address>
	</author>
	<date/>
	<area>Internet </area>
	<workgroup>NFSv4 Working Group</workgroup>

	<abstract>
	    <t>The Network File System, version 4 (NFSv4) uses a
		representation of identity that allows the use of users
		and groups from multiple, distinct administrative
		domains, and NFSv4 allows the use of security mechanisms
		that authenticate principals from multiple, distinct
		administrative domains.  This document describes methods
		by which NFSv4 clients and servers can handle
		principals, users, groups from multiple administrative
		domains.</t>
	</abstract>
    </front>

    <middle>

	<section title="Requirements notation">
	    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
		"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
		and "OPTIONAL" in this document are to be interpreted as
		described in <xref target="RFC2119"/>.</t>
	</section>


	<section title="Introduction">

	    <t>The <xref target="RFC3530">NFS Version 4</xref> protocol
		enables the construction of a distributed file system
		which can join NFSv4.0 or <xref
		    target="I-D.ietf-nfsv4-minorversion1">NFSv4.1</xref>
		servers from multiple administrative domains, each
		potentially using separate
		name resolution services and separate security services,
		into a common multi-domain name space.</t>

	    <t>NFSv4 deals with two kinds of identities: authentication
		identities (referred to here as "principals") and
		authorization identities ("users" and "groups" of
		users).  NFSv4 supports multiple authentication methods,
		each authenticating an "initiator principal" (typically
		representing a user) to an "acceptor principals" (always
		corresponding to the server).  NFSv4 does not prescribe
		how to represent authorization identities on file
		systems.  All file access decisions constitute
		"authorization" and are made by servers using
		information about client principals (such as username,
		group memberships, and so on) and file metadata related
		to authorization, such as a file's access control list
		(ACL).</t>

	    <t>Authentication in NFSv4 occurs at the the <xref
		    target="RFC2203">RPCSEC_GSS</xref> layer where
		GSS-API mechanisms <xref target="RFC2743"></xref>
		are used to authenticate users on NFSv4 clients to NFSv4
		servers, and to provide security services such as
		confidentiality and integrity protection for the
		protocol's messages.  The NFSv4 protocol specifies no
		particular representation for authentication identities
		as these are entirely GSS-API mechanism-specific.</t>

	    <t>Authorization for file object access is done at the NFSv4
		protocol layer (i.e., above the RPCSEC_GSS layer), on
		the server side, based on an authenticated client
		principal's authorization context and the authorization
		meta-data of the file system objects that the client
		wishes to access.  File authorization meta-data is set
		and retrieved in the NFSv4 <xref
		    target="RFC1831">RPC</xref> layer, specifically via
		the object's owner, owner_group and acl, dacl and sacl
		attributes (the last three being ACLs).  ACLs are lists
		of ACL entries (ACEs).  Each ACE has a "who" field
		identifying a subject to whom some permission is granted
		or denied.  The owner and owner_group attributes and the
		who ACE field, all reference users and groups.  On the
		wire, the protocol represents users and groups as
		strings of characters with this form: name@domain, where
		&lt;name&gt; is a user or group name, and &lt;domain&gt;
		is a the name of an administrative domain, more
		specifically a <xref target="RFC1034">DNS</xref>
		domainname.</t>

	    <t>NFSv4 server implementations usually do not, and really
		ought not, store authorization identities on disk in the
		same form as is used on the wire.  The reason is that
		users' and groups' names change all too often, while
		searching for and updating file authorization meta-data
		after a user/group name change is not trivial,
		particularly in a global namespace spanning multiple
		administrative domains.</t>

	    <t>NFSv4 servers therefore must perform two kinds of
		mappings: </t>

		<t>
		    <list style="numbers">

		     <t>Between the authentication identity and
		        the authorization context (a principal's user ID, group
	    	        memberships, etcetera)</t>

		     <t>Between the on-the-wire authorization identity
		        representation and the on-disk authorization identity
		        representation.</t>

                    </list>
                </t>

	     <t>Many aspects of these mappings are
		entirely implementation-specific, but some require name
		resolution services, and in order to interoperate
		servers must use such services in compatible ways.  Many
		implementations are limited to being able to represent
		users and groups from a single domain.</t>

	    <t>In this document we address both of those kind of
		mappings, describing possible implementation strategies,
		and specifying a name service for interoperation in a
		global namespace <xref
		    target="I-D.ietf-nfsv4-federated-fs-reqts"></xref>.</t>

	</section>  <!--Introduction --> 

	<section title="Background">

	    <t>NFSv4 uses a syntax of the form "name@domain" to
		represent, on the wire, the NFSv4 ACL name for users and
		groups.  This design provides a level of indirection
		that allows a client and server with different internal
		representations of authorization identity to
		interoperate even when referring to authorization
		identities from different administrative domains.</t>

	    <t>Multi-domain capable sites need to meet certain
		requirements in order to ensure that clients and servers
		can map name@domain to internal representations
		reliably:</t>

	    <t>
		<list style="symbols">

		    <t>The name portion of name@domain MUST be unique within
		       the specified DNS domain.</t>

		    <t>Every local representation of a user and of a
			group MUST have a canonical name@domain, and it
			must be possible to return the canonical
			name@domain for any identity stored on disk, at
			least when required infrastructure servers (such
			as name services) are online.</t>

		</list>
	    </t>

	    <figure>

		<preamble>
		    As described in <xref
			target="I-D.ietf-nfsv4-minorversion1"></xref>
		    section 2.2.1.1 "RPC Security Flavors":
		</preamble>

		<artwork>
        NFSv4.1 clients and servers MUST implement RPCSEC_GSS.  (This
        requirement to implement is not a requirement to use.)  Other
        flavors, such as AUTH_NONE, and AUTH_SYS, MAY be implemented
        as well.
		</artwork>
	    </figure>

	    <t>The AUTH_NONE security flavor can be useful to the
		multi-domain NFSv4 or federated name space to grant
		universal access to public data without any credentials.</t>

	    <t>The AUTH_SYS security flavor uses a host-based
		authentication model where the [weakly-authenticated]
		client asserts the user's authorization identities using
		small integers as user and group identity
		representations.  Because of the small integer
		authorization ID representation, AUTH_SYS can only be
		used in a name space where all clients and servers share
		a uidNumber and gidNumber translation service.  A shared
		translation service is required because uidNumbers and
		gidNumbers are passed in the RPC credential; there is no
		negotiation of namespace in AUTH_SYS.  Collisions can
		occur if multiple translation services are used.  These
		and other issues are addressed in <xref
		    target="I-D.williams-rpcsecgssv3"/> which describes
		a new version of RPCSEC_GSS that includes a modernized
		replacement for AUTH_SYS.</t>

	</section> <!--Background --> 

	<section title="Terminology">

	    <t>
		<list style="hanging">

		    <t>Identity: a way to refer to a user or group.</t>

		    <t>Principal: an entity that is authenticated by
			RPCSEC_GSS (usually, but not always, a user;
			rarely, if ever, a group; sometimes a host).</t>

		    <t>Authorization context: the set of user and group
			IDs, privileges, labels, and other items
			relevant to authorization, corresponding to a
			subject (user or principal).</t>

		    <t>Domain-local ID: Most installations assign
			numeric, local identifiers to users and groups,
			using a namespace local to their domain.  We
			call this a domain-local ID.</t>

		    <t>Local representation of identity: an item such as
			a POSIX user IDentifier (UID) or group ID (GID),
			or a Windows Security IDentifier (SID), or other
			such representation of a user or a group
			of users. These can be local to a single host.</t>

		    <t>Global representation of identity: a tuple
			consisting of a domain identifier (possibly the
			domain's name itself) and a domain-local
			user/group ID.  We do not propose a standard
			global representation of identity, but the
			concept is useful. [NEEDSWORK: we refer to 
			the global representation form in the
			RPCSEC_GSS PAC]</t>

		    <t>Group: a security entity representing zero, one or
		       more users and, possibly, other groups.  Can appear
		       as the subject of an ACE.</t>

		    <t>Domain: a set of users, groups and computers
		       administered by a single entity, and identified by
		       a DNS domain name.</t>

		    <t>POSIX IDs: small non-negative integer (typically
			0..2^31 or 0..2^32) identifiers.  The namespace
			of user IDs (UIDs) is distinct from the
			namespace of group IDs (GIDs).</t>

		    <t>Windows SIDs: an identifier of security entities,
			including users and groups.  The form of a SID
			is: S-1-&lt;authority&gt;-&lt;RID_0&gt;-&lt;RID_1&gt;
			-&lt;RID_n&gt;
			By convention some authority numbers denote
			security entities, identified by RID_n, local to
			a domain identified by RIDs 0..n-1.  Domain RIDs
			are usually generated randomly within a "forest"
			of domains.</t>

		    <t>Name resolution: mapping from {domain, name} to
			{domain, ID}, and vice-versa via lookups. Can be
			applied to local or remote domains.</t>

		    <t>ID mapping: {remote domain, remote domain-local ID}
		       to {local representation of ID} mappings.</t>

		</list>
	    </t>
	</section>  <!--Terminology --> 

	<section anchor="ONDISK" title="Local Representations of Global Identity">

	    <t>Multi-domain support starts at the fileserver where local
		ID forms need to be able to represent global identities
		from both local and remote domains.  Local
		representation of global identity also applies to
		clients, particularly clients with local filesystems.
		There's a range of local solutions to this multi-domain
		ID representation problem. In this section we describe
		several approaches to representing a
		&lt;name&gt;@&lt;local or remote domain&gt; on disk.
		None of these approaches are REQUIRED; all are
		INFORMATIVE.  However, conventions relating to the use
		of name services are NORMATIVE.</t>

	    <section title="Storing Name@Domainname">

		<t>One simple approach to the multiple domain problem is to
		   store the name@domain on disk.</t>
		
		<t>This approach imposes a severe constraint on the
		    administrators of these domains: user and group
		    names must never be reused, as there is also no
		    realistic way to keep the name@domain on disk
		    representation up to date with user, group or domain
		    renames and removals.  Consider a remote domain's
		    NFSv4 servers where real-time employee join/leave
		    data may be (typically is!) considered privileged,
		    and remote servers may not be sufficiently
		    privileged to access it [NEEDSWORK].</t>

	    </section>

	    <section anchor="ID@DOMAIN" title="Storing Remote-ID@Domainname">

		<t>Most installations assign numeric, local identifiers
		    to users and groups, using a namespace local to
		    their domain.  We call this a domain-local ID.  We
		    can then construct a global identity form consisting
		    of a domain name and a domain-local user/group ID.</t>

		<t>The user or group renaming issue can be addressed by
		    using a global identity form where domain-local IDs
		    are required.  I.e., use name resolution to lookup
		    name@domain to find the ID local to the specified domain,
		    and join the ID with the specified domain name.
		    This function still has
		    a renaming problem with respect to DNS domain
		    renames, but that is a more realistically manageable
		    problem than the user/group renaming problem.</t>

		<section anchor="STORE" title="Storing Remote-ID@Domain-ID">

		    <t>The DNS domain renaming issue in the previous
			section can be addressed by assigning and
			publishing a unique ID to each DNS domain.
			I.e., use name resolution to lookup name@domain
			to find some ID local to the domain, lookup the
			domain ID and store &lt;remote-ID,domain-ID&gt;.
			The Windows Security Identifier (SID) is an
			example of this form.</t>

		</section>
	    </section>

	    <section anchor="ID-MAPPING" title="ID Mapping">

		<t>Many file systems exported by NFS only store
		    32-bit user and group IDs which limit their
		    ability to utilize the on disk representation
		    described in <xref target="ID@DOMAIN"></xref>.
		    Such systems may need to use an additional
		    service to map between
		    &lt;remote user ID, local user IDs&gt; and
		    &lt;remote group IDs, local group IDs&gt;.
		    We call this an "ID mapping service".</t>

		<t>The use of an ID mapping service is not strictly
		    necessary if the system operates on IDs large
		    enough and in a known format such that
		    &lt;user/group ID, domain ID&gt; can be parsed and
		    encoded into a native ID.
		    However, a large class of operating systems,
		    those which are Unix or Unix-like operating
		    systems, such as Solaris and Linux, use 32-bit
		    UIDs and GIDs in many interfaces and therefore need
		    mapping for backwards compatibility reasons.</t>

		<t>One example of such a service is to keep a local
		    or distributed database for dynamically
		    assigning a local 32 bit ID to every
		    &lt;ID&gt;@&lt;domain-ID&gt;, or one could do
		    that only for remote domains, reserving only a
		    small part of the local 32-bit ID namespace for
		    remote domains' users/groups.</t>

		<t>The remote ID and remote domain are then used as
		    inputs to a name resolution service which
		    contacts the remote domain name service to
		    resolve the remote name.</t>

	    </section>

		<section title="Use of Name Services">

		    <t>File systems often use a distributed
			directory service for resolving domain local 32
			bit IDs to users and groups.  The <xref
			target="NIS">Network Information
			Service</xref> and the <xref
			target="RFC4511">Lightweight Directory
			Access Protocol</xref> are the two broadly
			deployed distributed directory service protocols
			used for this purpose.  LDAP is used instead of NIS in
			environments where scalabilty, security and/or
			extensibility are desired.
			<xref target="GSSAUTH"></xref> expands
			the LDAP protocol to include mappings between
			principals and local user and group IDs.</t>

		    <t>Support for LDAP <xref target="RFC4511"/> with
			the RFC2307 schema <xref target="RFC2307"/> is
			REQUIRED.</t>
		    
		    <section anchor="USING-LDAP" title="Using LDAP with RFC2307 Schema">

			<t>Name resolution consists of searches with
			    scope 'sub', a base DN corresponding to a
			    domain (more on this below) and a filter of
			    either of these forms, with matching on
			    objectClass being optional:</t>

			<t>
			    <list style='symbols'>

				<t>(objectClass=posixAccount)(uid="&lt;username&gt;)</t>

				<t>(objectClass=posixGroup)(cn="&lt;groupname&gt;)</t>

				<t>(objectClass=posixAccount)(uidNumber="&lt;UID&gt;)</t>

				<t>(objectClass=posixGroup)(gidNumber="&lt;GID&gt;)</t>

			    </list>
			</t>

			<t>The base DN SHOULD be formatted from a
			    domain's DNS domainname as follows.  First
			    format the domainname as a string, then
			    strip the trailing dot ('.'), if any, then
			    replace all dots ('.') with ",DC=", then
			    prepend "DC=" to the resulting string.  For
			    example, foo.bar.example becomes
			    "DC=foo,DC=bar,DC=example".  This convention
			    is REQUIRED to be implemented.  Domains with
			    base DNs that do not match this convention
			    MAY be used, but their domainname-to-base-DN
			    mappings must be published where NFSv4
			    clients and servers may find them; we
			    provide no conventions for publishing such
			    mappings.  We RECOMMEND that LDAP referrals be
			    used to publish such mappings (e.g., the client
			    does an LDAP search using "DC=foo,DC=example" as
			    the base DN and gets a referral that includes
			    the correct non-standard base DN for
			    "foo.example").</t>

			<t>Client and server implementations MUST support the
			    use of LDAP referrals to find LDAP servers
			    authoritative for any given base DN.</t>

			<t>For example, to resolve a user named
			    joe@foo.bar.example to a remote ID a system
			    would do an LDAP search with
			    DC=foo,DC=bar,DC=example as the base DN,
			    scope='sub' and with a filter of
			    (objectClass=posixAccount)(uid="&lt;username&gt;)
			    looking for the uidNumber attribute.</t>

		    </section>

		    <section title="Using Active Directory LDAP">

			<t>[NEEDSWORK: Add text describing searches by which to
			    resolve name@domain to SIDs and vice
			    versa.]</t>

		    </section>

		    <section title="Mapping Domain Names to Domain IDs">

			<t>[NEEDSWORK: Add text on mapping domainnames to domain
			    IDs. Note that Windows SID does this.]</t>

			<t> We need to have a common way to map Domain Names
			    to Domain IDs to enable mult-domain numeric IDs
			    as described in <xref target="STORE"></xref>.
			    Currently we have two suggestions:
			<list style="numbers">
			    <t> Just use SIDs, first asking MSFT to allocate a
			        suitable authority for non-Windows domain
			        SIDs.</t>
			    <t> - Store 96-bit numeric IDs which means we:
			    <list style="symbols">
			    	<t> cast those to domain SIDs later </t>
				<t> define a non-SID large ID format. This is
				a fine fallback should MSFT be unwilling to
				assign authority numbers for this purpose</t>
			    </list></t>
			</list></t>

		    </section>

	    </section>

	</section>

	<section anchor="CROSSAUTH" title="Resolving Cross-Domain Authorization Information">
	     <t>In order to authorize client principal access to files,
	        the NFS server must map the RPCSEC_GSS client principal name
	        or the underlying GSS-API security context to
		authorization information including a local ID,
		a set of local group IDs and other local user privileges
		meaningful to the file system being exported.</t>

	     <t>In the cross-domain case where a client principal is seeking
	        access to files on a server in a different NFSv4 domain,
	        the NFS server needs to obtain, in a secure manner,
	        the authorization information from an authoritative source:
	        e.g. a directory service in the client principals NFS domain.
	        </t>

	     <t>There are several methods the cross-domain authoritative
	        authorization information can be obtained:
	     <list style="numbers">
		    <t>A mechanism specific GSS-API authorization payload
		       containing credential authorization data such as
		       a "privilege attribute certificate" or PAC.</t>
		    <t>An NFS server local domain directory query when there is
		       a security agreement between the two cross-domain
		       directory services plus regular update data feeds so
		       that the NFS server local domain directory service is
		       authoritative for the client prinicpal domain.</t>
		    <t>A direct query from the NFS server to the client
		       principal authoritative directory service. </t>
		</list></t>

	     <t>The authorization data information SHOULD be obtained via
		the GSS-API name attribute interface
		<xref target="I-D.ietf-kitten-gssapi-naming-exts"/>
		either via a single attribute for the credential authorization
		data or via discrete GSS-API name attributes
		corresponding to the authorization data elements described in
		<xref target="V4ACCESS"></xref>.
		Details for those attributes are TBD.</t>
	     <t>Note that the retrieval of attribute values used by the GSS-API
	        name attribute interface implementation could utilize any
	        of the above mentioned methods of obtaining the authorization
	        information.</t>
	     <t>If the named attribute interface is not available, or the
		attributes are not available, other means of determining
    		a principal's authorization data SHOULD be used, such
		as those described in <xref target="AUTHCRED"></xref>
		and <xref target="DirServ"></xref>.</t>


	    <section anchor="V4ACCESS" title="Credential Authorization Data">

	         <t>Here we list in more detail the authorization information
	            that an NFSv4 server needs in order to make a file access
	            decision.  The credential authorization data contains the
	            user and group IDs corresponding to the client principal,
	            in global representation of identity form.  Note that
	            the server may need to map the global IDs to local IDs as
	            described in <xref target="ID-MAPPING"></xref>.</t>

		 <t>The ability to map IDs to the name@domain form is
		    required for the NFSv4 server to be able to respond to file
	            authorization meta-data (ACL) set and retrieve requests.</t>

	        <t>Credential authorization data consists of:</t>

	        <t>
		    <list style="symbols">

		        <t>UserID: This field contains the principal's
			   global ID and/or local ID mapping thereof, and
			   the name@domain form thereof.</t>

		        <t>PrimaryGroupID: This field contains the global ID
			   and/or local ID mapping thereof for the principal's
			   primary group, and the name@domain form thereof.</t>

		        <t>Groups: This field contains an array of group IDs
			   for the groups that the user is a member of, in
			   global ID form and/or local ID mappings thereof,
		    	   as well as in name@domain forms.</t>

		        <t>Optional field(s) for privileges and
			   authorizations granted to the principal, if
			   any.</t>

		        <t>Optional field(s) for other privilege information
		           such as the multi-level security
			   label range/set of the principal.</t>

		        <t>Optional implementation-specific items relevant to
		    	   authorization.</t>

		    </list>
	        </t>

	    </section> <!-- Credential Authorization Data  -->
	    <section anchor="AUTHCRED" title="Using Credential Authorization Data">

		 <t>Authorization context information can sometimes be
		    obtained from the credentials authenticating a
		    principal; the GSS-API represents such information
		    as attributes of the initiator prinicpal name.
		    For example: Kerberos 5 <xref target='RFC4120'/> has
		    a method for conveying "authorization data", both
		    client-asserted as well as KDC-authenticated
		    authorization data, and one KDC implementation uses
		    this feature to convey a "privilege attribute
		    certificate" (PAC) listing the principal's user and
		    group "security identifiers" (SIDs).  Another example
		    is the Kerberos General PAC
		    <xref target="I-D.sorce-krbwg-general-pac"/>
		    which lists the principal's user and group "universal user
		    identifiers" (UUIDs) as well as their string representations
		    and DNS domains.  PKIX <xref target='RFC5280'/>
		    certificates allow for extensions that could be used
		    similarly.</t>

		<section title="Using a PAC">

		     <t>The Windows operating system uses an authorization
		        context called a <xref target="PAC">"PAC"</xref>,
		        which contains a user Security
		        IDentifier (SID) and a list of group SIDs.  Some
		        Kerberos Key Distribution Centers (KDCs),
		        notably Windows KDCs, issue Kerberos Tickets
		        with PACs as Kerberos authorization data.</t>

		     <t>Some KDCs (will) issue Kerberos Tickets with the 
		        <xref target="I-D.sorce-krbwg-general-pac"> General PAC
		        </xref> as authorization data.
	                The General PAC authorization data MUST be
			authenticated in the sense that its contents must come
			from an authenticated, trusted source, such as a
			directory server or the issuer of the client principal's
			credential.</t>

		     <t>When a client principal is authenticated using such a
		        ticket, the server SHOULD extract the PAC from
		        the client's ticket and map, if need be, the
		        SIDs or UUIDs in the PAC to local ID representations.
		        </t>

		     <t>The authorization context information in a PAC
		        can be considered a single, authenticated,
		        discrete GSS-API name attribute, in which case
		        the server must parse it into its individual
		        elements.</t>

		</section> <!-- Using a PAC -->


	    </section> <!-- Using Authenticated Credential Extensions -->

	    <section anchor="DirServ" title="Using Directory Services">

		<t>If suitable and sufficient authenticated GSS-API name
		    attributes for the client principal are not
		    available, then the server may try to map the client
		    principal name to a local notion of user account,
		    and then lookup that user account's authorization
		    context information through authenticated name service
		    lookups.</t>

	    <section anchor="PRINC_TO_USER" title="Mapping Principal Names to Username">

		<t>One simple method for Kerberos principal-to-username
		    mapping is to first apply an algorithmic or
		    table-based Kerberos client principal realm name to
		    domain name mapping, then a client principal name to
		    username mapping.  Finally, the server can look up
		    the user's authorization context using the user's
		    domain's name services.</t>

		<t>A trivial Kerberos realm-name-to-domainname mapping
		    consists of using the realm name as the domainname.
		    [NEEDSWORK: Add notes about internationalization.]
		    Servers SHOULD implement this mapping as an option,
		    possibly as a default option.</t>

		<t>A trivial Kerberos principal name to username
		    mapping for 1-component principal names
		    is to use the principal name, unmodified, as the username.
		    Servers SHOULD implement this mapping as an option, possibly
		    as a default option.</t>
		</section> <!-- Mapping Principal Names to Usernames -->

		<section title="Using a Name Service to Map Principal Names to User Accounts">

		    <t>Name services such as the Solaris gsscred
			database where the local identity is looked
			up in a database keyed by the GSS exported
			name token, or LDAP with the extension
			described in <xref target="GSSAUTH"></xref>,
			can be used to map principal names to user
			accounts.</t>

		    </section> <!-- Using a Name Service to Map Principal Names to User Accounts -->

		</section> <!-- Using Directory Services -->
	</section> <!-- Resolving Cross-Domain Authorization Information  -->

	<section title="Multi Domain User Group Membership Determination">

 	     <t>User group membership is easy to determine for users in
		a system's local domain: the operating system will
		already know how to do that. For users in remote 
		domains, the authentication service may
		provide group membership information. If not, we need
		methods for group memebership determination.
		</t>

	     <t> [ NEEDSWORK:
		<list style="numbers">
	           <t>provide a[n obviously limited] mode of operation
		      that depends only on RFC2307 and therefore does not
		      support group nesting; </t>
	           <t>provide a more full-fledged mode of operation that
 	    	      depends RFC2307bis; </t>
	           <t>provide a more full-fledged mode of operation that
		      depends AD's schema.] </t>
	         </list></t>

	     <t>User group membership in remote domain's groups, and/or
		for remote users, may be determined using LDAP with
		the RFC2307 schema.  The RFC2307 schema does not define
		the values of the 'memberUid' attribute, but
		in practice it seems that those are expected to be the
		names of users as found in the 'uid' attribute of
		'posixAccount' entries.  There is work in progress to
		update RFC2307 <xref target="I-D.howard-rfc2307bis"></xref>
		to allow the use of DNs in the member attribute. Group
		nesting is also enabled. 
		</t>

		<!--  from rfc2307bis 5.2: Group members may either be
		       login names (values of memberUID) or distinguished
		       named (values of member)

		Such use of memberUid
		should be backwards-compatible, since implementations
		that don't know about that use of memberUid should end
		up ignoring values which are not plain usernames.
		-->

	     <t>Assuming the ability to store DNs in the member
		attribute, then, group membership determination can be
		done as follows.  Given a user ID whose DN has been
		determined:
		    <list style="numbers">

                       <t>Search the user's domain for groups that the user is
                          a member of in the user's home domain.  Since we
                          cannot assume a domain is authoritative for another
                          domains group membership, filter out
                          groups that are not local to the user's home domain.
                          </t>
                       <t>Search the server's domain for groups that the user
                          is a member of in the server's home domain.
                          </t>
                       <t>Search the server's domain for groups that the
                          user's group memberships determined in steps 1 and
                          2 are members of.
                         </t>
                       <t>Continue searching for nested group memberships
                          given the list of groups from steps 2 and 3 while
                          being careful to detect or prevent loops.
                          </t>
                    </list> </t>

                    <t>However, the above procedure has the same user/group
                       name renaming issue.  By skipping step 2 we can get
                       down to just a group renaming issue.  To fully address
                       the rename issue we need either a new attribute or
                       value type for memberUid, storing user/group IDs in
                       some global ID representation.  </t>

                    <t>[NEEDSWORK: Add text defining such a new
                    	attribute/value type.]</t>
		</section>

	<section anchor="LDAP" title="LDAP and Multi-Domain NFSv4">
	    <t>Each of the three methods of retrieving cross-domain
	       authorization information described in section
	       <xref target="CROSSAUTH"></xref> can require a directory service
	       query. Cross-domain querys are not only inefficient, but also
	       implies knowledge of multiple systems where two different
	       domains rely on completely different infrastructures for user
	       information.
	    </t>

	    <t> [NEEDSWORK: Describe why LDAP is REQUIRED] </t>

		<section title="LDAP Service Discovery" >
		    <t> [NEEDSWORK: this is just an idea place holder.] </t>

		    <t> Two potential methods:
		    <list style="numbers">
		        <t> Use local methods (configuration, DNS SRV RR
		            lookups, ...) to discover local domain's servers,
		            then depend on LDAP referrals for discovering all
		            other domains servers.</t>
		        <t> Use DNS SRV RRs much the way AD does </t>

		    </list> </t>

		    <t> NICO: I would prefer that we have one REQUIRED to
		        implement service discovery mechanism as follows:
			<list style='symbols'>
		        <t> specify local DS discovery using DNS SRV RR
			    lookups much like AD does (i.e., have a label to
			    indicate the purpose of the LDAP service, not
			    just _ldap).  Make this general enough that clients
			    could discover DSes of remote domains on
			    their own. </t> 
			<t> use LDAP referrals (and DNS resolution of the
			    host parts of the referrals) to discover DSes of
			    other domains. </t>

			</list></t>
		    <t> The main benefit of this mechanism is that we can
		        leave the work of finding topologically-close caches
		        and/or authoritative servers to the clients' local
		        DSes, thus avoiding the need to deal directly with
			topology in our spec.
		    </t>

		</section> <!-- LDAP Service Discovery -->


	    <section anchor="GSSAUTH" title="LDAP Attribute for Principal Name to Local ID Translation" >

		<t>The gSSPrincipal objectclass allows for the use of the
		   gSSAuthName attribute described in the following section.
		   </t>

		<figure> 
		    <artwork>
                     objectclass ( 1.3.6.1.4.1.250.10.7
                     NAME 'gSSPrincipal'
                     DESC 'GSS Principal Name'
                     SUP  posixAccount
                     MAY ( gSSAuthName ) )
		    </artwork>
		</figure> 

		<t>The gSSAuthName attribute provides a
		    method for the translations between a posixAccount
		    and (multiple) GSS-API security principals, used
		    as described in <xref target="PRINC_TO_USER"></xref>.</t>

		<figure>

		    <preamble>
			The gSSAuthName attribute stores a user's
			GSS-API principal name in exported name token
			form (see <xref target="RFC2743"/>).
		    </preamble>

		    <artwork>
                     attributetype ( 1.3.6.1.4.1.250.10.6
                     NAME ( 'gSSAuthName')
                     DESC 'GSS-API exported principal name
                     exported token'
                     EQUALITY bitStringMatch
                     SYNTAX 1.3.6.1.4.1.1466.115.121.1.6)
		    </artwork>
		</figure>

	    </section>

	    <section title="Name Resolution and LDAP Caching">

	        <t>As noted in <xref target="ID@DOMAIN"></xref>, most local
		    representations require a name service to perform ID to
		    name translations.  Implementations are REQUIRED to
		    support the use of LDAP as a name service, relying on
		    LDAP referrals for federated namespace construction.</t>

	        <t>Note that in a topographically widely separated set of
		    domains the need to do name service lookups in various
		    domains' name services may prove brittle, resulting in
		    non-deterministic server behavior (e.g., sometimes a
		    user can access share, sometimes they cannot; sometimes
		    they appear to be members of some group, sometimes they
		    do not).  To avoid this, site administrators may wish to
		    maintain local caches of remote domains' name
		    services such that LDAP searches for users/groups in
		    remote domains can be satisfied locally for some set of
		    key attributes (such as naming and ID attributes), with
		    referrals used in all other cases.</t>

	        <t>Domains in a federated namespace may provide each other
		    with LDAP LDIF delta feeds by which to maintain cached
		    LDAP contents up to date.The LDAP DN hierarchy described in
	            <xref target="USING-LDAP"></xref> has the advantage of
	            aiding delta feeds from remote domains where each
	    	    domain's information is in its own DN subtree.</t>

	    </section> <!-- Name Resolution and LDAP Caching Proxies -->

	</section> <!-- LDAP and Multi-Domain NFSv4 -->

	<section title="Security Considerations">

	    <t>Caching of remote domains' LDAP search results persents some
	       security considerations.  For example, some attributes'
	       values may not be visible unless a user's credentials
	       are used.  Some attributes' values may not be intended
	       to be visible to users, but to hosts.  Caching servers
	       MUST be capable of issuing referrals as needed for
	       attributes whose values they may not read.  Some domain
	       federations will want to have their domains trust each
	       others' caching servers.</t>

	    <t>More considerations to come</t>

	</section> <!-- Security Considerations -->

    </middle>

    <back>

	<references title="Normative References">
	    &rfc2119;
	    &rfc1034;
	    &rfc3530;&rfc1831;&rfc2203;
	    &rfc2743;&rfc4120;
	    &rfc4511;&rfc2307;
	    &rfc2307bis;
	    &krb5generalpac;
	    &fedfsreqts;
	    &gssnamexts;
	    &nfsv41;
	    <reference anchor="PAC">
		<front>
		    <title>Utilizing the Windows 2000 Authorization Data in Kerberos Tickets for Access Control to Resources </title>
		    <author initials="J. " surname="Brezak" fullname="J.Brezak">
			<organization>Microsoft Corporation</organization>
		    </author>
		    <date month="October" year="2002" />
		</front>
	    </reference>
	</references>

	<references title="Informative References">
	    &rpcsecgss3;
	    &rfc5280;

	    <reference anchor="NIS">
		<front>
		    <title>System and Network Administration</title>
		    <author>
			<organization>Sun Microsystems</organization>
		    </author>
		    <date month="March" year="1990" />
		</front>
	    </reference>

	</references>

    </back>
</rfc>
