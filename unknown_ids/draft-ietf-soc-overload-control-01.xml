<?xml version='1.0' ?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' [ 
  <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
  <!ENTITY rfc3261 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml'>
  <!ENTITY rfc3263 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3263.xml'>
  <!ENTITY rfc4412 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4412.xml'>
  <!ENTITY rfc5390 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5390.xml'>
  <!ENTITY rfc5031 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5031.xml'>
  <!ENTITY i-d.ietf-soc-load-control-event-package PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-soc-load-control-event-package.xml'>
  <!ENTITY i-d.ietf-soc-overload-design PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-soc-overload-design.xml'>]>
<rfc ipr='trust200902' category='std' docName="DOCNAME">

<?rfc toc='yes'?>
<?rfc compact='yes'?>
<?rfc sortrefs='yes'?>
<?rfc symrefs="yes"?>

<front>
  <title abbrev='Overload Control'>Session Initiation Protocol (SIP)
  Overload Control</title>
  <author initials="V.K." surname="Gurbani" fullname="Vijay K. Gurbani" role="editor">
    <organization>Bell Laboratories, Alcatel-Lucent</organization>
    <address>
      <postal>
	<street>1960 Lucent Lane, Rm 9C-533</street>
	<city>Naperville</city> <region>IL</region>
	<code>60563</code>
	<country>USA</country>
      </postal> 
      <email>vkg@bell-labs.com</email>
    </address>
  </author>

  <author initials='V.H.' surname='Hilt' fullname='Volker Hilt'>
    <organization>Bell Labs/Alcatel-Lucent</organization>
    <address>
      <postal>
	<street>791 Holmdel-Keyport Rd</street>
	<city>Holmdel</city> <region>NJ</region>
	<code>07733</code>
	<country>USA</country>
      </postal> 
      <email>volkerh@bell-labs.com</email>
    </address>
  </author>

  <author initials='H.S.' surname='Schulzrinne' fullname='Henning Schulzrinne'>
    <organization abbrev='Columbia University'>Columbia University/Department
    of Computer Science</organization>
    <address>
      <postal>
	<street>450 Computer Science Building</street>
	<city>New York</city> <region>NY</region>
        <code>10027</code>
	<country>USA</country>
      </postal>
      <phone>+1 212 939 7004</phone>
      <email>hgs@cs.columbia.edu</email>
      <uri>http://www.cs.columbia.edu</uri>
    </address>
  </author>

  <date year='2011' />
  <area>RAI</area>
  <workgroup>SOC Working Group</workgroup>
  <keyword>SIP</keyword>
  <keyword>Overload Control</keyword>
  <abstract>
    <t>Overload occurs in Session Initiation Protocol (SIP) networks when
    SIP servers have insufficient resources to handle all SIP messages
    they receive. Even though the SIP protocol provides a limited
    overload control mechanism through its 503 (Service Unavailable)
    response code, SIP servers are still vulnerable to overload. This
    document defines an overload control mechanism for SIP.</t>
  </abstract>
</front>

<middle>

  <section title="Introduction">

    <t>As with any network element, a Session Initiation Protocol
    (SIP) <xref target="RFC3261" /> server can suffer from overload
    when the number of SIP messages it receives exceeds the number of
    messages it can process. Overload can pose a serious problem for a
    network of SIP servers. During periods of overload, the throughput
    of a network of SIP servers can be significantly degraded. In
    fact, overload may lead to a situation in which the throughput
    drops down to a small fraction of the original processing
    capacity. This is often called congestion collapse.</t>

    <t>Overload is said to occur if a SIP server does not have
    sufficient resources to process all incoming SIP messages. These
    resources may include CPU processing capacity, memory,
    network bandwidth, input/output, or disk resources.</t>

    <t>For overload control, we only consider failure cases where SIP
    servers are unable to process all SIP requests due to resource
    constraints. There are other cases where a SIP server can
    successfully process incoming requests but has to reject them due
    to failure conditions unrelated to the SIP server being overloaded. 
    For example, a PSTN gateway that runs out of trunks but 
    still has plenty of capacity to process SIP messages should 
    reject incoming INVITEs using a 488 (Not
    Acceptable Here) response <xref target="RFC4412" />. Similarly, a
    SIP registrar that has lost connectivity to its registration
    database but is still capable of processing SIP requests should
    reject REGISTER requests with a 500 (Server Error) response <xref
    target="RFC3261" />. Overload control does not apply to these
    cases and SIP provides appropriate response codes for them.</t>   

    <t>The SIP protocol provides a limited mechanism for overload
    control through its 503 (Service Unavailable) response
    code. However, this mechanism cannot prevent overload of a SIP
    server and it cannot prevent congestion collapse. In fact, the use
    of the 503 (Service Unavailable) response code may cause traffic
    to oscillate and to shift between SIP servers and thereby worsen
    an overload condition. A detailed discussion of the SIP overload
    problem, the problems with the 503 (Service Unavailable) response
    code and the requirements for a SIP overload control mechanism can
    be found in <xref target="RFC5390" />.</t>

  </section>

  <section title="Terminology">

    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
    "OPTIONAL" in this document are to be interpreted as described in
    <xref target="RFC2119">RFC 2119</xref>.</t>

    <t>The normative statements in this specification as they apply
    to SIP clients and SIP servers assume that both the SIP clients and
    SIP servers support this specification.  If, for instance, only a
    SIP client supports this specification and not the SIP server, 
    then follows that the normative statements in this specification
    pertinent to the behavior of a SIP server do not apply to the
    server that does not support this specification.</t>

  </section>

  <section title="Overview of operations" anchor="sec:overview">
   <t>We now explain the overview of how the overload control
   mechanism operates by introducing the overload control parameters.
   <xref target="sec:header"/> provides more details and
   normative behavior on the parameters listed below.</t>

   <t>Because overload control is best performed hop-by-hop, the 
   Via parameter is attractive since it allows two adjacent SIP 
   entities to indicate support for, and exchange information associated 
   with overload control.  Additional advantages of this choice are
   discussed in <xref target="sec:dc:sm:response"/>.  An alternative
   mechanism using SIP event packages was also considered, and the
   characteristics of that choice are further outlined in <xref target=
   "sec:dc:sm:event"/>.</t>

   <t>This document defines four new parameters for the SIP Via header 
   for overload control.  These parameters provide a SIP mechanism for 
   conveying overload control information between adjacent SIP  
   entities.)  These parameters are:</t>
   
    <t><list style="numbers">
     <t>oc: This parameter serves a dual purpose; when inserted by a
     SIP client in a request going downstream, the parameter indicates
     that the SIP client supports overload control.  When the downstream
     SIP server sends a response, the downstream SIP server will add a
     value to the parameter that indicates a loss rate (in percentage)
     by which the requests arriving at the downstream SIP server should
     be reduced.</t>
    <t>oc-algo: This parameter serves a dual purpose: when inserted by a
    SIP client in a request going downstream, the parameter contains a
    comma-separated list of the class of overload control algorithm 
    supported by the SIP client.  When the downstream SIP server sends a
    response, the downstream SIP server will pick one overload control
    algorithm from the list and will pare the list down to include
    the one chosen algorithm.  In this manner, the upstream SIP client and
    the downstream SIP server can negotiate the specific class of algorithm 
    that is utilized for overload control.</t>
    <t>oc-validity: Inserted by the SIP server sending a response
    upstream.  This parameter contains a value that indicates the time 
    (in millisecond resolution) that the load reduction specified by the 
    "oc" parameter should be in effect.</t>
    <t>oc-seq: Inserted by the SIP server sending a response upstream.
    This parameter contains a value that indicates the sequence number 
    associated with the "oc" parameter defined above.</t>
    </list></t>

    <t>Consider a SIP client, P1, which is sending requests to another
    downstream SIP server, P2.  The following snippets of SIP messages
    demonstrate how the overload control parameters work.</t>

    <figure><artwork><![CDATA[
       INVITE sips:user@example.com SIP/2.0
       Via: SIP/2.0/TLS p1.example.net;
         branch=z9hG4bK2d4790.1;received=192.0.2.111;oc;
         oc-algo="loss,rate"
       ...

       SIP/2.0 100 Trying
       Via: SIP/2.0/TLS p1.example.net;
         branch=z9hG4bK2d4790.1;received=192.0.2.111;
         oc=20;oc-algo="loss";oc-validity=500;
         oc-seq=1282321615.781
       ...       
    ]]></artwork></figure>

    <t>In the messages above, the first line is sent by P1 to P2.
    This line is a SIP request; because P1 supports overload control,
    it inserts the "oc" parameter in the topmost Via header that it 
    created.</t>

    <t>The second line --- a SIP response --- shows the topmost Via 
    header amended by P2 according to this specification and sent to
    P1.  Because P2 also supports overload control, it sends back further 
    overload control parameters towards P1 requesting that P1 reduce the 
    incoming traffic by 20% for 500ms.  P2 updates the "oc" parameter to
    add a value and inserts the remaining two parameters, "oc-validity"
    and "oc-seq".</t>

  </section> <!-- sec:overview -->

  <section title="Via Header Parameters for Overload Control"
           anchor="sec:header"> 

      <section title="The oc paramater" anchor="oc-param">

       <t>This parameter is inserted by the SIP client and updated by the 
       SIP server.</t>

       <t>A SIP client MUST add
       an "oc" parameter to the topmost Via header it inserts into the
       SIP request. This provides an indication to downstream neighbors
       that this server supports overload control.  When inserted into
       a request by a SIP client to indicate support for overload 
       control, there MUST NOT be a value associated with the 
       parameter.</t>

       <t>The downstream server MUST add a value to the "oc" parameter
       in the response going upstream; this value indicates a loss rate
       (in percentage) by which the requests arriving at the downstream
       server should be reduced.</t>

       <t>When adding a value to the "oc" parameter, the downstream
       server MUST restrain that value to a number between 0 and 100.  
       This value describes the percentage by which the traffic 
       (SIP requests) destined to the SIP server should be
       reduced. The default value for this parameter is 0.</t>

       <t>When a SIP client receives a response with the value in
       the "oc" parameter filled in, it SHOULD reduce, in terms of
       a percentage, the number of requests going downstream to the
       SIP server from which it received the response (see 
       <xref target="sec:respond-overload"/> for pertinent discussion 
       on traffic reduction).</t>
       
      </section> <!-- oc-param -->

      <section title="The oc-algo parameter" anchor="oc-algo">
     
       <t>This parameter is inserted by the SIP client and updated by the 
       SIP server.</t>

       <t>A SIP client MAY add an
       "oc-algo" parameter to the topmost Via header it inserts into the
       SIP request.  This parameter contains a comma-separated list of
       a class of overload control algorithms.  Currently, three 
       classes of overload control algorithms are known: loss-based,
       rate-based, and window-based.  This document supports overload
       control through a loss-based mechanism, therefore the single
       mandatory to implement class of overload control algorithm
       is loss-based.  All implementations
       that support overload control MUST implement a loss-based
       overload control mechanism.</t>

       <t>If a SIP client only supports the loss-based overload control
       mechanism, then the "oc-algo" parameter can be omitted.  When a
       SIP server receives a request without an "oc-algo" parameter,
       it MUST NOT add the parameter in the response going upstream
       as the absence of the parameter in the request implied that the
       upstream SIP client only supported a loss-based overload control
       mechanism.</t>

       <t>If a SIP client supports multiple class of overload control
       algorithms, then it will insert a comma-separated list in the
       "oc-algo" parameter value.  Each element in the comma-separated
       list corresponds to the class of overload control algorithms
       supported by the SIP client.  Currently, three 
       classes of overload control algorithms are known: loss-based,
       rate-based, and window-based.  When a downstream SIP server 
       receives a request with a choice of overload control algorithms
       specified in the "oc-algo" parameter value, it MUST choose one
       algorithm from the list and MUST pare the list down to include
       the one chosen algorithm.  The pared down list consisting of the
       chosen algorithm MUST be returned to the upstream SIP client in the
       response.</t>

       <t>It is RECOMMENDED that once an upstream SIP client and a downstream
       SIP server have converged to a mutually agreeable class of overload control
       algorithm, the agreed upon class stays in effect for a non-trivial
       duration of time.  That is, the adjacent peers MUST NOT renegotiate
       the overload control algorithm class per transaction, or per request-
       response message exchange.  A rapid renegotiation of the overload
       control algorithm will not benefit the client or the server as such
       flapping does not allow the chosen algorithm to measure and fine tune
       its behavior over a period of time. </t>

       <t>Exigent realities of deployments of
       SIP clients and servers necessitate that the overload control
       algorithm be renegotiated upon a system reboot or a software upgrade,
       however, frequent renegotiations of the overload control algorithm
       MUST be avoided.  Renegotiation, when desired, is simply accomplished 
       by the SIP client sending a fresh "oc-algo" parameter in a request going
       downstream.  The downstream server, as before, MUST choose one
       algorithm from the list and MUST pare the list down to include
       the one chosen algorithm.  The pared down list consisting of the
       chosen algorithm MUST be returned to the upstream SIP client in the
       response and stays in effect until the next renegotiation.</t> 

      </section> <!-- oc-algo -->
      
      <section title="The oc-validity parameter" anchor="oc-validity">

       <t>This parameter is inserted by the SIP server.</t>

       <t>This parameter contains a value that indicates an interval of time 
       (measured in milliseconds) that the load reduction specified
       value of the "oc" parameter should be in effect.  The default
       value of the "oc_validity" parameter is 500 (millisecond).</t>

       <t>The "oc_validity" parameter can only be present in a Via 
       header in conjunction with an "oc" parameter.</t>

      </section> <!-- oc-validity -->

      <section title="The oc-seq parameter" anchor="oc-seq">

       <t>This parameter is inserted by the SIP server.</t>

       <t>This parameter contains a value that indicates the sequence
       number associated with the "oc" parameter.  Some implementations
       may be capable of updating the overload control information before
       the validity period specified by the "oc-validity" parameter
       expires.  Such implementations MUST have an increasing value in
       the "oc-seq" parameter for each response sent to the upstream
       SIP client.  This is to allow the upstream SIP client to properly
       collate out-of-order responses.</t>

      </section> <!-- oc-seq -->

<!--
      <t><list>
        <t>OPEN ISSUE: To throttle upstream neighbors in a fair way,
        it is important that a SIP server can estimate the load each 
        upstream neighbor receives for this server before it is
        throttled. This enables the server to throttle each upstream
        neighbor in the same way and thus provides each request the
        same chance of succeeding. In rate- and window-based overload
        control systems, a SIP server does not know how many messages
        each upstream neighbor had received for the server before
        throttling took place. A solution to this problem is to allow
        servers to report the unthrottled load for a downstream neighbor
        in the 'oc_accept' parameter.</t>
      </list></t>
-->

    </section> <!-- sec:header -->

    <section title="Creating and updating the overload control parameters" 
             anchor="oc-create">

      <t>A SIP server can provide overload control feedback to its
      upstream neighbors by providing a value for the "oc" parameter 
      to the topmost Via header field of a SIP response.  The topmost 
      Via header is determined after the SIP server has removed its 
      own Via header; i.e., it is the Via header that was generated 
      by the upstream neighbor.</t>

      <t>Since the topmost Via header of a response will be removed by
      an upstream neighbor after processing it, overload control
      feedback contained in the "oc" parameter will not travel beyond
      the upstream SIP client. A Via header parameter therefore provides
      hop-by-hop semantics for overload control feedback (see <xref
      target="I-D.ietf-soc-overload-design" />) even if the 
      next hop neighbor does not support this specification.</t>

      <t>The "oc: parameter can be used in all response types,
      including provisional, success and failure responses (please see
      <xref target="sec:100"/> for special consideration on
      transporting overload control parameters in a 100-Trying response). A SIP
      server MAY update the "oc" parameter in all responses it
      is sending. A SIP server MUST update the "oc" parameter to responses
      when the transmission of overload control feedback is required
      by the overload control algorithm to limit the traffic received
      by the server. I.e., a SIP server MUST update the "oc" parameter
      when the overload control algorithm sets the value of an "oc" 
      parameter to a value different than the default value.</t>

      <t>A SIP server that has updated the "oc" parameter to Via header
      SHOULD also add a "oc_validity" parameter to the same Via
      header. The "oc_validity" parameter defines the time in
      milliseconds during which the content (i.e., the overload
      control feedback) of the "oc" parameter is valid. The default
      value of the "oc_validity" parameter is 500 (millisecond). A SIP 
      server SHOULD use a shorter "oc_validity" time if its overload 
      status varies quickly and MAY use a longer "oc_validity" time 
      if this status is more stable. If the "oc_validity" parameter is 
      not present, its default value is used. The "oc_validity" parameter 
      MUST NOT be used in a Via header that did not originally contain 
      an "oc" parameter when received.  Furthermore, when a SIP server
      receives a request with the topmost Via header containing only 
      an "oc-validity" parameter without the accompanying "oc" parameter. it
      MUST ignore the "oc-validity" parameter.</t>

      <t>When a SIP server retransmits a response, it SHOULD
      use the "oc" parameter value and "oc-validity" parameter 
      value consistent with the overload state at the time the
      retransmitted response is sent.  This implies that the
      values in the "oc" and "oc-validity" parameters may be
      different then the ones used in previous retransmissions
      of the response.  Due to the fact that responses sent over
      UDP may be subject to delays in the network and arrive
      out of order, the "oc-seq" parameter aids in detecting a
      stale "oc" parameter value.</t>

      <t>Implementations that are capable of updating the "oc"
      and "oc-validity" parameter values for retransmissions MUST
      insert the "oc-seq" parameter.  The value of this parameter
      MUST be a set of numbers drawn from an increasing sequence.</t>

      <t>Implementations that are not capable of updating the "oc"
      and "oc-validity" parameter values for retransmissions --- or
      implementations that do not want to do so because they will
      have to regenerate the message to be retransmitted --- MUST 
      still insert a "oc-seq" parameter in the first response
      associated with a transaction; however, they do not have to 
      update the value in subsequent retransmissions.</t>

      <!-- Ed. note: The discussion that lead to the above is 
           captured in 
           http://www.ietf.org/mail-archive/web/sip-overload/
                                                 current/msg00250.html
      -->

      <t>The "oc_validity" and "oc-seq" Via header
      parameters are only defined in SIP responses and MUST NOT be 
      used in SIP requests. These parameters are only useful to the 
      upstream neighbor of a SIP server (i.e., the entity that is 
      sending requests to the SIP server) since this is the entity 
      that can offload traffic by redirecting/rejecting new requests. 
      If requests are forwarded in both directions between two SIP
      servers (i.e., the roles of upstream/downstream neighbors
      change), there are also responses flowing in both
      directions. Thus, both SIP servers can exchange overload
      information.</t>

<!--
Not sure the paragraph below adds anything useful to the
discussion.  I will comment it out right now and see if
someone notices its disappearance. vkg Nov-19-2010.

      <t>While adding "oc" and "oc_validity" parameters to
      requests may increase the frequency with which overload
      information is exchanged in these scenarios, this increase will
      rarely provide benefits and does not justify the added overhead 
      and complexity needed.</t>
-->

      <t>Since overload control protects a SIP server from overload, 
      it is RECOMMENDED that a SIP server use the mechanisms described
      in this specification.  However, if a SIP server wanted to limit its 
      overload control capability for privacy reasons, it MAY decide to 
      perform overload control only for requests that are received 
      on a secure transport channel, such as TLS.  This enables a SIP
      server to protect overload control information and ensure that
      it is only visible to trusted parties.  </t>

    </section>

    <section title="Determining the 'oc' Parameter Value"
             anchor="oc-determine">

      <t>The value of the "oc" parameter is determined by an overload
      control algorithm (see <xref
      target="I-D.ietf-soc-overload-design" />). This 
      specification does not mandate the use of a specific overload
      control algorithm. However, the output of an overload control
      algorithm MUST be compliant to the semantics of this Via header
      parameter.</t> 

      <t>The "oc" parameter value specifies the percentage by which
      the load forwarded to this SIP server should be
      reduced. Possible values range from 0 (the traffic forwarded is 
      reduced by 0%, i.e., all traffic is forwarded) to 100 (the 
      traffic forwarded is reduced by 100%, i.e., no traffic
      forwarded). The default value of this parameter is 0.</t>

<!--
      <t><list>
        <t>OPEN ISSUE 1: The "oc" parameter value specified in this document
        is defined to contain a loss rate. However, other types of
        overload control feedback exist, for example, a target rate for
        rate-based overload control or message confirmations and 
        window-size for window-based overload control. </t>
        <t></t>
	<t>While it would in theory be possible to allow multiple
        types of overload control feedback to co-exist (e.g., by using
        different parameters for the different feedback types) it is
        very problematic for interoperability purposes and would
        require SIP servers to implement multiple overload control
        mechanisms.</t> 
      </list></t>
 -->
    </section>

    <section title="Processing the Overload Control Parameters" 
             anchor="oc-process">

      <t>A SIP client compliant to this specification SHOULD remove
      "oc", "oc_validity" and "oc-seq" parameters from all Via headers of a
      response received, except for the topmost Via header. This
      prevents overload control parameters that were accidentally or
      maliciously inserted into Via headers by a downstream SIP server
      from traveling upstream.</t>

      <t>A SIP client maintains the "oc" parameter values received
      along with the address and port number of the SIP servers from 
      which they were received for the duration specified in the 
      "oc_validity" parameter or the default duration. Each time a 
      SIP client receives a response with an "oc" parameter from a 
      downstream SIP server, it overwrites the "oc" value it has 
      currently stored for this server with the new value received. 
      The SIP client restarts the validity period of an "oc" parameter 
      each time a response with an "oc" parameter is received from 
      this server. A stored "oc" parameter value MUST be discarded once 
      it has reached the end of its validity.</t>

    </section>

    <section title="Using the Overload Control Parameter Values" 
             anchor="oc-use">

      <t>A SIP client compliant to this specification MUST honor 
      overload control values it receives from downstream neighbors. The 
      SIP client MUST NOT forward more requests to a SIP server than
      allowed by the current "oc" parameter value from a particular
      downstream server.</t>

      <t>When forwarding a SIP request, a SIP client uses the SIP
      procedures of <xref target="RFC3263"/> to determine the next 
      hop SIP server.  The procedures of <xref target="RFC3263"/> take 
      as input a SIP URI, extract the
      domain portion of that URI for use as a lookup key, and query
      the Domain Name Service (DNS) to obtain an ordered set of one
      or more IP addresses with a port number and transport corresponding
      to each IP address in this set (the "Expected Output").</t>
    
      <t>After selecting a specific SIP server from the Expected Output,
      the SIP client MUST determine if it already has overload control
      parameter values for the server chosen from the Expected Output.
      If the SIP client has a non-expired "oc" parameter value for
      the server chosen from the Expected Output, and this chosen server
      is operating in overload control mode.  Thus, the SIP client MUST
      determine if it can or cannot forward the current request to the
      SIP server depending on the nature of the request and the
      prevailing overload conditions.</t>

      <t>The particular algorithm used to determine whether or not to
      forward a particular SIP request is a matter of local policy,
      and may take into account a variety of prioritization factors.  
      However, this local policy SHOULD generate the same number and 
      rate of SIP requests as the default algorithm (to be determined), 
      which treats all requests as equal.</t>
 
      <t>In the absence of a different local policy, the SIP client
      SHOULD use the following default algorithm to determine
      if it can forward the request downstream (TODO: Need to devise an
      algorithm.  The original simple algorithm based on random number
      generation does not suffice for all cases.) </t>
<!--
      <t>The SIP client SHOULD use the following algorithm to determine
      if it can forward the request. The SIP client draws a random
      number between 1 and 100 for the current request. If the random
      number is less than or equal to the 'oc' parameter value, the
      request is not forwarded. Otherwise, the request is
      forwarded (note that this algorithm does not prioritize the
      requests it is dropping --- c.f. OPEN ISSUE 3 in <xref target=
      "msg-priority"/>.) Any other algorithms that 
      approximate the random number algorithm may be used as well.</t>
-->
<!--
      <t><list>
        <t>OPEN ISSUE: the specific mechanisms to throttle traffic
        depend on the type of feedback conveyed in the 'oc' parameter
        value. It needs to be defined depending on whether a
        loss-based, rate-based or window-based feedback is used.</t>
      </list></t>

      <t>The treatment of SIP requests that cannot be forwarded to the
      selected SIP Server is a matter of local policy. A SIP client
      MAY try to find an alternative target or it MAY reject the
      request (see <xref target="sec:5xx" />).</t>
-->
    </section>

    <section title="Forwarding the overload control parameters"
             anchor="sec:forward">

      <t>A SIP client MAY forward the content of an "oc" parameter it
      has received from a downstream neighbor on to its upstream
      neighbor. However, forwarding the content of the "oc" parameter
      is generally NOT RECOMMENDED and should only be performed if
      permitted by the configuration of SIP servers. For example, a
      SIP server that only relays messages between exactly two SIP
      servers may forward an "oc" parameter. The "oc" parameter is
      forwarded by copying it from the Via in which it was received
      into the next Via header (i.e., the Via header that will be on
      top after processing the response). If an "oc_validity"
      parameter is present, MUST be copied along with the "oc"
      parameter.</t>

    </section> <!-- sec:forward -->

    <section title="Self-Limiting" anchor="sec:self-limiting">

      <t>In some cases, a SIP client may not receive a response from a
      downstream server after sending a request. <xref
      target="RFC3261">RFC3261</xref> defines that when a timeout 
      error is received from the transaction layer, it MUST be treated
      as if a 408 (Request Timeout) status code has been received. If
      a fatal transport error is reported by the transport layer, it
      MUST be treated as a 503 (Service Unavailable) status code.</t>

      <t>In the event of repeated timeouts or fatal transport errors,
      the SIP client MUST stop sending requests to this server. The 
      SIP client SHOULD occasionally forward a single request to probe 
      if the downstream server is alive. Once a SIP client has successfully 
      transmitted a request to the downstream server, the SIP client 
      can resume normal traffic rates. It should, of course, honor 
      any "oc" parameters it may receive subsequent to resuming normal 
      traffic rates.</t>

      <t><list>
       <t>OPEN ISSUE: If a downstream neighbor does not respond to
       a request at all, the upstream SIP client will stop sending
       requests to the downstream neighbor.  The upstream SIP client
       will periodically forward a single request to probe the 
       health of its downstream neighbor.  It has been suggested ---
       see 
       http://www.ietf.org/mail-archive/web/sip-overload/current/msg00229.html
       --- that we have a notification mechanism in place for the
       downstream neighbor to signal to the upstream SIP client that it
       is ready to receive requests.  This notification scheme has
       advantages, but comes with obvious disadvantages as well.  Need
       some more discussion around this.</t>
      </list></t>

<!--
      <t><list>
        <t>OPEN ISSUE: waiting for a timeout to occur seems a long time
        before starting to throttle back. It could make sense to
        throttle back earlier if no response is received for requests
        transmitted.</t> 
      </list></t>
-->

    </section>

  <section title="Responding to an Overload Indication"
           anchor="sec:respond-overload"> 

    <t>A SIP client can receive overload control feedback indicating
    that it needs to reduce the traffic it sends to its downstream
    server. The client can accomplish this task by sending some of
    the requests that would have gone to the overloaded element to a 
    different destination. It needs to ensure, however, that this
    destination is not in overload and capable of processing the
    extra load. An client can also buffer requests in the hope that
    the overload condition will resolve quickly and the requests
    still can be forwarded in time. In many cases, however, it will
    need to reject these requests.</t>

    <section title="Message prioritization at the hop before the
     overloaded server" anchor="msg-priority"> 

      <t>During an overload condition, a SIP client needs to
      prioritize requests and select those requests that need to be rejected
      or redirected. While this selection is largely a matter of local
      policy, certain heuristics can be suggested.  One, during overload
      control, the SIP client should preserve existing dialogs as much
      as possible.  This suggests that mid-dialog requests MAY be
      given preferential treatment.  Similarly, requests that result in
      releasing resources (such as a BYE) MAY also be given 
      preferential treatment.</t>

      <t>A SIP client SHOULD honor the local policy for prioritizing
      SIP requests such as policies based on the content of the
      Resource-Priority header (RPH, <xref target="RFC4412">RFC4412</xref>).
      Specific (namespace.value) RPH contents may indicate high priority
      requests that should be preserved as much as possible during
      overload.  The RPH contents can also indicate a low-priority
      request that is eligible to be dropped during times of overload.
      Other indicators, such as the SOS URN <xref target="RFC5031"/>
      indicating an emergency request, may also be used for 
      prioritization.</t>

      <t>Local policy could also include giving precedence to mid-
      dialog SIP requests (re-INVITEs, UPDATEs, BYEs etc.) in times
      of overload.  A local policy can be expected to combine both
      the SIP request type and the prioritization markings, and SHOULD
      be honored when overload conditions prevail.</t>

      <t>A SIP client SHOULD honor user-level load control filters
      installed by signaling neighbors 
      <xref target="I-D.ietf-soc-load-control-event-package"/> by sending
      the SIP messages that matched the filter downstream.</t>
<!--
      <t>A SIP server SHOULD honor a request containing the 
      Resource-Priority header field <xref target="RFC4412">RFC4412</xref>.
      Resource-Priority header field enables a proxy to identify 
      high-priority requests, such as emergency service requests, and 
      preserve them as much as possible during times of overload.</t>

      <t><list>
       <t>OPEN ISSUE 3: The process by which the upstream server 
       selects messages to be rejected to reduce load needs to be
       discussed further.  Clearly, SIP messages that contain the
       Resource-Priority header should not be rejected.  Also, mid-
       dialog requests (re-INVITEs, UPDATEs, BYEs etc.) should be
       honored, if possible.  This can be left as a policy decision
       with guidelines provided --- example, if a request has both
       the To tag and From tag, do not drop it since it is a mid-
       dialog request; do not drop requests with the Resource-Priority 
       header, etc.  Some discussion on this is captured in
       http://www.ietf.org/mail-archive/web/sip-overload/current/msg00272.html.
       </t>
       <t></t>
       <t>This issue also has a bearing on the default algorithm to be
        outlined in Section <xref target="oc-use"/>.</t>
      </list></t>
-->
    </section>

    <section title="Rejecting requests at an overloaded server" 
     anchor="sec:5xx">

      <t>If the upstream SIP client to the overloaded server does
      not support overload control, it will continue to direct
      requests to the overloaded server.  Thus, the overloaded
      server must bear the cost of rejecting some session requests as 
      well as the cost of processing other requests to completion.  It 
      would be fair to devote the same amount of processing at the 
      overloaded server to the combination of rejection and processing 
      as the overloaded server would devote to processing requests 
      from an upstream SIP client that supported overload control.
      This is to ensure that SIP servers that do not support this
      specification don't receive an unfair advantage over those that
      do. </t>

      <t>A SIP server that is under overload and has started to
      throttle incoming traffic MUST reject this request with a
      "503 (Service Unavailable)" response without Retry-After header 
      to reject a fraction of requests from upstream neighbors that do
      not support overload control.</t>
    </section>

  </section>

  <section title="100-Trying provisional response and overload control 
           parameters" anchor="sec:100">
   <t>The overload control information sent from a SIP server to a client
   is transported in the responses.  While implementations can insert overload
   control information in any response, special attention should be accorded
   to overload control information transported in a 100-Trying response.</t>

   <t>Traditionally, the 100-Trying response has been used in SIP to quench
   retransmissions.  In some implementations, the 100-Trying message may 
   not be generated by the transaction user (TU) nor consumed by the TU.  
   In these implementations, the 100-Trying response is generated at the 
   transaction layer and sent to the upstream SIP client.  At the receiving 
   SIP client, the 100-Trying is consumed at the transaction layer by 
   inhibiting the retransmission of the corresponding request.  Consequently, 
   implementations that insert overload control information in the 100-Trying 
   cannot assume that the upstream SIP client passed the overload control 
   information in the 100-Trying to their corresponding TU.  For this reason, 
   implementations that insert overload control information in the 100-Trying 
   MUST re-insert the same (or updated) overload control information in the 
   first non-100 response being sent to the upstream SIP client.</t>

   <!-- c.f. http://www.ietf.org/mail-archive/web/sip-overload/
        current/msg00452.html -->

  </section> <!-- sec:100 -->

  <section title="Relationship with other IETF SIP load control efforts"
           anchor="sec:relationship">

   <t>The overload control mechanism described in this document is reactive
   in nature and apart from message prioritization directives listed in
   <xref target="msg-priority"/> the mechanisms described in this draft
   will not discriminate requests based on user identity, filtering action 
   and arrival time.  SIP networks that require pro-active overload control
   mechanisms can upload user-level load control filters as described in 
   <xref target="I-D.ietf-soc-load-control-event-package"/>.</t>

  </section> <!-- sec:relationship -->

  <section title="Syntax" anchor="sec:syntax">

<!--
    <t><list>
      <t>OPEN ISSUE: the syntax of the 'oc' Via header parameter
      depends on the overload control method (i.e., loss-based,
      rate-based or window-based) in use. The following syntax
      definition defines a rate-based 'oc' header. This syntax needs
      to be adjusted if rate-based or window-based overload control is
      used.</t> 
    </list></t>
-->

    <t>This specification extends the existing definition of the Via 
    header field parameters of <xref target="RFC3261"/> as follows:</t>

    <figure>
    <artwork><![CDATA[
    via-params        =  via-ttl / via-maddr
                      / via-received / via-branch
                      / oc / oc-validity
                      / oc-seq / oc-algo / via-extension
    ]]></artwork>
    </figure>

    <t><list>
        <t>oc          = "oc" [EQUAL 0-100]</t>
        <t>oc-validity = "oc_validity" [EQUAL delta-ms]</t>
        <t>oc-seq      =  (1*12DIGIT "." 1*5DIGIT) </t>
        <t>oc-algo     = DQUOTE algo-list *(COMMA algo-list) DQUOTE </t>
        <t>algo-list   = "loss" / *(other-algo) </t>
        <t>other-algo  = %x41-5A / %x61-7A / %x30-39</t>
    </list></t>

  </section>

  <section title="Design Considerations" anchor="sec:dc">

    <t>This section discusses specific design considerations for the
    mechanism described in this document. General design
    considerations for SIP overload control can be found in
    <xref target="I-D.ietf-soc-overload-design" />.</t> 

    <section title="SIP Mechanism" anchor="sec:dc:sm">

      <t>A SIP mechanism is needed to convey overload feedback from
      the receiving to the sending SIP entity. A number of different
      alternatives exist to implement such a mechanism.</t> 

      <section title="SIP Response Header" anchor="sec:dc:sm:response">

        <t>Overload control information can be transmitted using a new
        Via header field parameter for overload control. A SIP server
        can add this header parameter to the responses it is sending
        upstream to provide overload control feedback to its upstream
        neighbors. This approach has the following
        characteristics:</t> 
      
        <t><list style='symbols'>
          <t>A Via header parameter is light-weight and creates very 
          little overhead. It does not require the transmission of
          additional messages for overload control and does not
          increase traffic or processing burdens in an overload
          situation. </t> 
  	  <t>Overload control status can frequently be reported to
          upstream neighbors since it is a part of a SIP
          response. This enables the use of this mechanism in
          scenarios where the overload status needs to be adjusted
          frequently. It also enables the use of overload control
          mechanisms that use regular feedback such as window-based
          overload control.</t> 
   	  <t>With a Via header parameter, overload control status is
	  inherent in SIP signaling and is automatically conveyed to
	  all relevant upstream neighbors, i.e., neighbors that are
	  currently contributing traffic. There is no need for a SIP
	  server to specifically track and manage the set of current
	  upstream or downstream neighbors with which it should
	  exchange overload feedback.</t> 
 	  <t>Overload status is not conveyed to inactive senders. This
          avoids the transmission of overload feedback to inactive 
          senders, which do not contribute traffic. If an inactive
          sender starts to transmit while the receiver is in overload
          it will receive overload feedback in the first response and
          can adjust the amount of traffic forwarded accordingly. </t>
	  <t>A SIP server can limit the distribution of overload
	  control information by only inserting it into responses to
	  known upstream neighbors. A SIP server can use transport
	  level authentication (e.g., via TLS) with its upstream
	  neighbors.</t> 
       </list></t>

      </section>

      <section title="SIP Event Package"  anchor="sec:dc:sm:event">

        <t>Overload control information can also be conveyed from a
        receiver to a sender using a new event package. Such an event
        package enables a sending entity to subscribe to the overload 
        status of its downstream neighbors and receive notifications
        of overload control status changes in NOTIFY requests. This 
        approach has the following characteristics:</t>
      
        <t><list style='symbols'>
          <t>Overload control information is conveyed decoupled from
          SIP signaling. It enables an overload control manager, which
          is a separate entity, to monitor the load on other servers
          and provide overload control feedback to all SIP servers
          that have set up subscriptions with the controller.</t> 
          <t>With an event package, a receiver can send updates to
          senders that are currently inactive. Inactive senders will 
          receive a notification about the overload and can refrain
          from sending traffic to this neighbor until the overload
          condition is resolved. The receiver can also notify all
          potential senders once they are permitted to send traffic 
          again. However, these notifications do generate additional
          traffic, which adds to the overall load.</t>  
  	  <t>A SIP entity needs to set up and maintain overload
          control subscriptions with all upstream and downstream
          neighbors. A new subscription needs to be set up
          before/while a request is transmitted to a new downstream
          neighbor. Servers can be configured to subscribe at boot
          time. However, this would require additional protection to
          avoid the avalanche restart problem for overload
          control. Subscriptions need to be terminated when they are
          not needed any more, which can be done, for example, using a
          timeout mechanism.</t>  
          <t>A receiver needs to send NOTIFY messages to all
	  subscribed upstream neighbors in a timely manner when the
	  control algorithm requires a change in the control variable
	  (e.g., when a SIP server is in an overload condition). This
	  includes active as well as inactive neighbors. These NOTIFYs
	  add to the amount of traffic that needs to be processed. To
	  ensure that these requests will not be dropped due to
	  overload, a priority mechanism needs to be implemented in
	  all servers these request will pass through.</t>
  	  <t>As overload feedback is sent to all senders in separate
	  messages, this mechanism is not suitable when frequent
	  overload control feedback is needed.</t>
	  <t>A SIP server can limit the set of senders that can
          receive overload control information by authenticating
          subscriptions to this event package.</t>
          <t>This approach requires each proxy to implement user agent 
          functionality (UAS and UAC) to manage the subscriptions.</t>
       </list></t>
      </section>


    </section>

    <section title="Backwards Compatibility">

      <t>An new overload control mechanism needs to be backwards
      compatible so that it can be gradually introduced into a network 
      and functions properly if only a fraction of the servers support 
      it.</t>

      <t>Hop-by-hop overload control (see
      <xref target="I-D.ietf-soc-overload-design" />) has the
      advantage that it does not require that all SIP entities in a 
      network support it. It can be used effectively between two
      adjacent SIP servers if both servers support overload control
      and does not depend on the support from any other server or user
      agent. The more SIP servers in a network support hop-by-hop
      overload control, the better protected the network is against
      occurrences of overload.</t>  

      <t>A SIP server may have multiple upstream neighbors from which
      only some may support overload control. If a server would simply 
      use this overload control mechanism, only those that support it
      would reduce traffic. Others would keep sending at the full rate
      and benefit from the throttling by the servers that support
      overload control. In other words, upstream neighbors that do not
      support overload control would be better off than those that
      do.</t> 

      <t>A SIP server should therefore use 5xx responses towards
      upstream neighbors that do not support overload control. The
      server should reject the same amount of requests with 5xx
      responses that would be otherwise be rejected/redirected by the 
      upstream neighbor if it would support overload control. If the
      load condition on the server does not permit the creation of 5xx  
      responses, the server should drop all requests from servers that
      do not support overload control.</t> 

    </section>

  </section>

  <section anchor="sec:security" title="Security Considerations">
 
    <t>Overload control mechanisms can be used by an attacker to
    conduct a denial-of-service attack on a SIP entity if the attacker
    can pretend that the SIP entity is overloaded. When such a forged
    overload indication is received by an upstream SIP client, it will
    stop sending traffic to the victim. Thus, the victim is 
    subject to a denial-of-service attack.</t> 

    <t>An attacker can create forged overload feedback by inserting
    itself into the communication between the victim and its 
    upstream neighbors. The attacker would need to add overload
    feedback indicating a high load to the responses passed from the
    victim to its upstream neighbor. Proxies can prevent this attack by
    communicating via TLS. Since overload feedback has no meaning
    beyond the next hop, there is no need to secure the communication 
    over multiple hops.</t>

    <t>Another way to conduct an attack is to send a message
    containing a high overload feedback value through a proxy that does not
    support this extension. If this feedback is added to the second Via
    headers (or all Via headers), it will reach the next upstream
    proxy. If the attacker can make the recipient believe that the
    overload status was created by its direct downstream neighbor (and
    not by the attacker further downstream) the recipient stops
    sending traffic to the victim. A precondition for this attack is
    that the victim proxy does not support this extension since it
    would not pass through overload control feedback otherwise.</t>

    <t>A malicious SIP entity could gain an advantage by pretending to
    support this specification but never reducing the amount of
    traffic it forwards to the downstream neighbor. If its downstream
    neighbor receives traffic from multiple sources which correctly
    implement overload control, the malicious SIP entity would benefit
    since all other sources to its downstream neighbor would reduce
    load. </t>

    <t><list>
      <t>The solution to this problem depends on the
      overload control method. For rate-based and window-based
      overload control, it is very easy for a downstream entity to
      monitor if the upstream neighbor throttles traffic forwarded as
      directed. For percentage throttling this is not always obvious
      since the load forwarded depends on the load received by the
      upstream neighbor.</t>  
    </list></t>

  </section>

  <section anchor="sec:iana" title="IANA Considerations">
  
    <t>[TBD.]</t> 

  </section>

</middle>

<back>
 <references title='Normative References'>

   &rfc2119;

   &rfc3261;

   &rfc3263;

   &rfc4412;

 </references>

 <references title='Informative References'>

   &rfc5390;

   &rfc5031;

   &i-d.ietf-soc-overload-design;

   &i-d.ietf-soc-load-control-event-package;

 </references>

 <section title="Acknowledgements">

   <t>Many thanks to Keith Drage, Janet Gunn, Rich Terpstra, Daryl Malas, 
   R. Parthasarathi, Jonathan Rosenberg, Charles Shen, Rahul Srivastava, 
   Padma Valluri, Shaun Bharrat, and Paul Kyzivat for their contributions 
   to this specification.</t>

 </section> 

 <section title="RFC5390 requirements" anchor="rfc5390-reqs">

  <t><xref target="table-rfc5390"/> provides a summary how this
  specification fulfills the requirements of <xref target="RFC5390"/>.
  A more detailed view on how each requirements is fulfilled is
  provided after the table.</t>

  <texttable anchor="table-rfc5390">
   <ttcol align="left">Requirement</ttcol>
   <ttcol align="left">Meets requirement</ttcol>

   <c>REQ 1</c> <c>Yes</c>
   <c>REQ 2</c> <c>Yes</c>
   <c>REQ 3</c> <c>Partially</c>
   <c>REQ 4</c> <c>Partially</c>
   <c>REQ 5</c> <c>Partially</c>
   <c>REQ 6</c> <c>Not applicable</c>
   <c>REQ 7</c> <c>Yes</c>
   <c>REQ 8</c> <c>Partially</c>
   <c>REQ 9</c> <c>Yes</c>
   <c>REQ 10</c> <c>Yes</c>
   <c>REQ 11</c> <c>Yes</c>
   <c>REQ 12</c> <c>Yes</c>
   <c>REQ 13</c> <c>Yes</c>
   <c>REQ 14</c> <c>Yes</c>
   <c>REQ 15</c> <c>Yes</c>
   <c>REQ 16</c> <c>Yes</c>
   <c>REQ 17</c> <c>Partially</c>
   <c>REQ 18</c> <c>Yes</c>
   <c>REQ 19</c> <c>Yes</c>
   <c>REQ 20</c> <c>Yes</c>
   <c>REQ 21</c> <c>Yes</c>
   <c>REQ 22</c> <c>Yes</c>
   <c>REQ 23</c> <c>Yes</c>


   <postamble>Summary of meeting requirements in RFC5390</postamble>
  </texttable>

  <t>REQ 1: The overload mechanism shall strive to maintain the overall
  useful throughput (taking into consideration the quality-of-
  service needs of the using applications) of a SIP server at
  reasonable levels, even when the incoming load on the network is
  far in excess of its capacity.  The overall throughput under load
  is the ultimate measure of the value of an overload control mechanism.</t>
  <t>Meeting REQ 1: Yes, the overload control mechanism allows an
  overloaded SIP server to maintain a reasonable level of throughput as
  it enters into congestion mode by requesting the upstream clients to
  reduce traffic destined downstream.</t>

  <t>REQ 2: When a single network element fails, goes into overload, or
  suffers from reduced processing capacity, the mechanism should
  strive to limit the impact of this on other elements in the
  network.  This helps to prevent a small-scale failure from becoming a 
  widespread outage.</t>
  <t>Meeting REQ 2: Yes.  When a SIP server enters overload mode, it
  will request the upstream clients to throttle the traffic destined to it.
  As a consequence of this, the overloaded SIP server will itself generate
  proportionally less downstream traffic, thereby limiting the impact on
  other elements in the network.</t>

  <t>REQ 3: The mechanism should seek to minimize the amount of
  configuration required in order to work.  For example, it is
  better to avoid needing to configure a server with its SIP message
  throughput, as these kinds of quantities are hard to determine.</t>
  <t>Meeting REQ 3: Partially.  On the server side, the overload 
  condition is determined monitoring S (c.f., Section 4 of 
  <xref target="I-D.ietf-soc-overload-design"/>) and reporting a load
  feedback F as a value to the "oc" parameter.  On the client side,
  a throttle T is applied to requests going downstream based on F.
  This specification does not prescribe any value for S, nor a 
  particular value for F.  The "oc-algo" parameter allows for automatic
  convergence to a particular class of overload control algorithm.
  There are suggested default values for the "oc-validity" parameter.</t>

  <t>REQ 4: The mechanism must be capable of dealing with elements that
  do not support it, so that a network can consist of a mix of
  elements that do and don't support it.  In other words, the
  mechanism should not work only in environments where all elements
  support it.  It is reasonable to assume that it works better in
  such environments, of course.  Ideally, there should be
  incremental improvements in overall network throughput as
  increasing numbers of elements in the network support the mechanism.</t>
  <t>Meeting REQ 4: Partially.  The mechanism is designed to reduce congestion
  when a pair of communicating entities support it.  If a downstream
  overloaded SIP server does not respond to a request in time, a SIP
  client conformant to this specification will attempt to reduce traffic
  destined towards the non-responsive server as outlined in 
  <xref target="sec:self-limiting"/>.</t>

  <t>REQ 5: The mechanism should not assume that it will only be
  deployed in environments with completely trusted elements.  It
  should seek to operate as effectively as possible in environments
  where other elements are malicious; this includes preventing
  malicious elements from obtaining more than a fair share of service.</t>
  <t>Meeting REQ 5: Partially.  Since overload control information is
  shared between a pair of communicating entities, a confidential and
  authenticated channel can be used for this communication.  However,
  if such a channel is not available, then the security ramifications 
  outlined in <xref target="sec:security"/> apply.</t>

  <t>REQ 6: When overload is signaled by means of a specific message,
  the message must clearly indicate that it is being sent because of
  overload, as opposed to other, non overload-based failure
  conditions.  This requirement is meant to avoid some of the
  problems that have arisen from the reuse of the 503 response code
  for multiple purposes.  Of course, overload is also signaled by
  lack of response to requests.  This requirement applies only to
  explicit overload signals.</t>
  <t>Meeting REQ 6: Not applicable.  Overload control information is
  signaled as part of the Via header and not in a new header.</t>

  <t>REQ 7: The mechanism shall provide a way for an element to
  throttle the amount of traffic it receives from an upstream
  element.  This throttling shall be graded so that it is not all-
  or-nothing as with the current 503 mechanism.  This recognizes the
  fact that "overload" is not a binary state and that there are
  degrees of overload.</t>
  <t>Meeting REQ 7: Yes, please see <xref target="oc-use"/> and
  <xref target="sec:respond-overload"/>.</t>  

  <t>REQ 8: The mechanism shall ensure that, when a request was not
  processed successfully due to overload (or failure) of a
  downstream element, the request will not be retried on another
  element that is also overloaded or whose status is unknown.  This
  requirement derives from REQ 1.</t>
  <t>Meeting REQ 8: Partially.  A SIP client that has overload information
  from multiple downstream servers will not retry the request
  on another element.  However, if a SIP client does not know the
  overload status of a downstream server, it may send the request to
  that server.</t>

  <t>REQ 9: That a request has been rejected from an overloaded element
  shall not unduly restrict the ability of that request to be
  submitted to and processed by an element that is not overloaded.
  This requirement derives from REQ 1.</t>
  <t>Meeting REQ 9: Yes, a SIP client conformant to this specification
  will send the request to a different element.</t>

  <t>REQ 10: The mechanism should support servers that receive requests
  from a large number of different upstream elements, where the set
  of upstream elements is not enumerable.</t>
  <t>Meeting REQ 10: Yes, there are no constraints on the number of
  upstream clients.</t>

  <t>REQ 11: The mechanism should support servers that receive requests
  from a finite set of upstream elements, where the set of upstream
  elements is enumerable.</t>
  <t>Meeting REQ 11: Yes, there are no constraints on the number of
  upstream clients.</t>

  <t>REQ 12: The mechanism should work between servers in different domains.</t>
  <t>Meeting REQ 12: Yes, there are no inherent limitations on using
  overload control between domains.</t>

  <t>REQ 13: The mechanism must not dictate a specific algorithm for
  prioritizing the processing of work within a proxy during times of
  overload.  It must permit a proxy to prioritize requests based on
  any local policy, so that certain ones (such as a call for
  emergency services or a call with a specific value of the
  Resource-Priority header field <xref target="RFC4412"/>) are given 
  preferential treatment, such as not being dropped, being given 
  additional retransmission, or being processed ahead of others.</t>
  <t>Meeting REQ 13: Yes, please see <xref target="sec:respond-overload"/>.
  </t>

  <t>REQ 14: REQ 14: The mechanism should provide unambiguous directions to
  clients on when they should retry a request and when they should
  not.  This especially applies to TCP connection establishment and
  SIP registrations, in order to mitigate against avalanche restart.</t>
  <t>Meeting REQ 14: Yes, <xref target="sec:self-limiting"/>
  provides normative behavior on when to retry a request after repeated
  timeouts and fatal transport errors resulting from communications with
  a non-responsive downstream SIP server.</t>

  <t>REQ 15: In cases where a network element fails, is so overloaded
  that it cannot process messages, or cannot communicate due to a
  network failure or network partition, it will not be able to
  provide explicit indications of the nature of the failure or its
  levels of congestion.  The mechanism must properly function in
  these cases.</t>
  <t>Meeting REQ 15: Yes, <xref target="sec:self-limiting"/>
  provides normative behavior on when to retry a request after repeated
  timeouts and fatal transport errors resulting from communications with
  a non-responsive downstream SIP server.</t>

  <t>REQ 16: The mechanism should attempt to minimize the overhead of
  the overload control messaging.</t>
  <t>Meeting REQ 16: Yes, overload control messages are sent in the
  topmost Via header, which is always processed by the SIP elements.</t>

  <t>REQ 17: The overload mechanism must not provide an avenue for
  malicious attack, including DoS and DDoS attacks.</t>
  <t>Meeting REQ 17: Partially.  Since overload control information is
  shared between a pair of communicating entities, a confidential and
  authenticated channel can be used for this communication.  However,
  if such a channel is not available, then the security ramifications 
  outlined in <xref target="sec:security"/> apply.</t>

  <t>REQ 18: The overload mechanism should be unambiguous about whether
  a load indication applies to a specific IP address, host, or URI,
  so that an upstream element can determine the load of the entity
  to which a request is to be sent.</t>
  <t>Meeting REQ 18: Yes, please see discussion in <xref target="oc-use"/>.</t>

  <t>REQ 19: The specification for the overload mechanism should give
  guidance on which message types might be desirable to process over
  others during times of overload, based on SIP-specific
  considerations.  For example, it may be more beneficial to process
  a SUBSCRIBE refresh with Expires of zero than a SUBSCRIBE refresh
  with a non-zero expiration (since the former reduces the overall
  amount of load on the element), or to process re-INVITEs over new INVITEs.</t>
  <t>Meeting REQ 19: Yes, please see <xref target="sec:respond-overload"/>.</t>

  <t>REQ 20: In a mixed environment of elements that do and do not
  implement the overload mechanism, no disproportionate benefit
  shall accrue to the users or operators of the elements that do not
  implement the mechanism.</t>
  <t>Meeting REQ 20: Yes, an element that does not implement overload
  control does not receive any measure of extra benefit.</t>

  <t>REQ 21: The overload mechanism should ensure that the system
  remains stable.  When the offered load drops from above the
  overall capacity of the network to below the overall capacity, the
  throughput should stabilize and become equal to the offered load.</t>
  <t>Meeting REQ 21: Yes, the overload control mechanism described in
  this draft ensures the stability of the system.</t>

  <t>REQ 22: It must be possible to disable the reporting of load
  information towards upstream targets based on the identity of
  those targets.  This allows a domain administrator who considers
  the load of their elements to be sensitive information, to
  restrict access to that information.  Of course, in such cases,
  there is no expectation that the overload mechanism itself will
  help prevent overload from that upstream target.</t>
  <t>Meeting REQ 22: Yes, an operator of a SIP server can configure
  the SIP server to only report overload control information for
  requests received over a confidential channel, for example.  However,
  note that this requirement is in conflict with REQ 3, as it
  introduces a modicum of extra configuration.</t>

  <t>REQ 23: It must be possible for the overload mechanism to work in
  cases where there is a load balancer in front of a farm of proxies.</t>
  <t>Meeting REQ 23: Yes; depending on the type of load balancer, this
  requirement is automatically met.  More information on a load balancer
  in the context of SIP overload is in Section 6 of 
  <xref target="I-D.ietf-soc-overload-design"/>.</t>

 </section> <!-- rfc5390-reqs -->

</back>

</rfc>
