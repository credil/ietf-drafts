<?xml version="1.0" encoding="UTF-8"?>
<!-- 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2104 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml'>
    <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY rfc2195 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2195.xml'>
    <!ENTITY rfc2202 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2202.xml'>
    <!ENTITY rfc2898 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2898.xml'>
    <!ENTITY rfc3174 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3174.xml'>
    <!ENTITY rfc3454 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3454.xml'>
    <!ENTITY rfc3629 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml'>
    <!ENTITY rfc4013 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4013.xml'>
    <!ENTITY rfc4086 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml'>
    <!ENTITY rfc4422 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4422.xml'>
    <!ENTITY rfc4510 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4510.xml'>
    <!ENTITY rfc4616 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4616.xml'>
    <!ENTITY rfc4648 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml'>
    <!ENTITY rfc4949 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml'>
    <!ENTITY rfc5056 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5056.xml'>
    <!ENTITY rfc5234 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml'>
    <!ENTITY rfc5246 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml'>
    <!ENTITY rfc2831bis PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-sasl-rfc2831bis-12.xml'>
    <!ENTITY digesthistoric PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-sasl-digest-to-historic-00.xml'>
    <!ENTITY cramhistoric PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-sasl-crammd5-to-historic-00.xml'>
    <!-- References only for SCRAM as a GSS-API mechanism -->
    <!ENTITY rfc2743 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2743.xml'>
    <!ENTITY rfc3962 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3962.xml'>
    <!ENTITY rfc4121 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4121.xml'>
    <!ENTITY rfc4401 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4401.xml'>
    <!ENTITY rfc4402 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4402.xml'>
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc tocindent="no" ?>
<?rfc autobreaks="no" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="no"?>

<rfc ipr="trust200811" category="std" docName="draft-newman-auth-scram-11.txt">
    <front>
	<title abbrev="SCRAM">Salted Challenge Response (SCRAM) SASL Mechanism</title>
	<author initials='A.' surname="Menon-Sen" fullname="Abhijit Menon-Sen">
	    <organization>Oryx Mail Systems GmbH</organization>
	    <address>
		<email>ams@oryx.com</email>
	    </address>
	</author>
	<author initials='A.' surname="Melnikov" fullname="Alexey Melnikov">
	    <organization>Isode Ltd</organization>
	    <address>
		<email>Alexey.Melnikov@isode.com</email>
	    </address>
	</author>
	<author initials='C.' surname="Newman" fullname='Chris Newman'>
	    <organization>Sun Microsystems</organization>
	    <address>
		<postal>
		    <street>1050 Lakes Drive</street>
		    <city>West Covina</city> <region>CA</region>
		    <code>91790</code> <country>USA</country>
		</postal>
		<email>chris.newman@sun.com</email>
	    </address>
        </author>
	<author initials='N.' surname="Williams" fullname='Nicolas
	    Williams'>
	    <organization>Sun Microsystems</organization>
	    <address>
		<postal>
		    <street>5300 Riata Trace Ct</street>
		    <city>Austin</city> <region>TX</region>
		    <code>78727</code> <country>USA</country>
		</postal>
		<email>Nicolas.Williams@sun.com</email>
	    </address>
        </author>
        <date month="March" year="2009"/>
	<area>Security</area>
	<workgroup>NETWORK WORKING GROUP</workgroup>
	<keyword>Internet-Draft</keyword>
	<abstract>
	    <t>The secure authentication mechanism most widely deployed
		and used by Internet application protocols is the
		transmission of clear-text passwords over a channel
		protected by Transport Layer Security (TLS).  There are
		some significant security concerns with that mechanism,
		which could be addressed by the use of a challenge
		response authentication mechanism protected by TLS.
		Unfortunately, the challenge response mechanisms
		presently on the standards track all fail to meet
		requirements necessary for widespread deployment, and
		have had success only in limited use.</t>

	    <t>This specification describes a family of authentication
		mechanisms called the Salted Challenge Response
		Authentication Mechanism (SCRAM), which addresses the
		security concerns and meets the deployability
		requirements. When used in combination with TLS or an
		equivalent security layer, a mechanism from this family
		could improve the status-quo for application protocol
		authentication and provide a suitable choice for a
		mandatory-to-implement mechanism for future application
		protocol standards.</t>
	</abstract>
    </front>

    <middle>

	<section anchor="conv" title="Conventions Used in This Document">

	    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
		"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",
		"MAY", and "OPTIONAL" in this document are to be
		interpreted as described in <xref
		    target='RFC2119'/>.</t>

	    <t>Formal syntax is defined by <xref target='RFC5234'/>
		including the core rules defined in Appendix B of <xref
		    target='RFC5234'/>.</t>

	    <t>Example lines prefaced by "C:" are sent by the client and
		ones prefaced by "S:" by the server. If a single "C:" or
		"S:" label applies to multiple lines, then the line
		breaks between those lines are for editorial clarity
		only, and are not part of the actual protocol
		exchange.</t>

	    <section title="Terminology">

		<t>This document uses several terms defined in <xref
			target='RFC4949'/> ("Internet Security
		    Glossary") including the following: authentication,
		    authentication exchange, authentication information,
		    brute force, challenge-response, cryptographic hash
		    function, dictionary attack, eavesdropping, hash
		    result, keyed hash, man-in-the-middle, nonce,
		    one-way encryption function, password, replay attack
		    and salt. Readers not familiar with these terms
		    should use that glossary as a reference.</t>

		<t>Some clarifications and additional definitions
		    follow:

		    <list style='symbols'>

			<t>Authentication information: Information used
			    to verify an identity claimed by a SCRAM
			    client. The authentication information for a
			    SCRAM identity consists of salt, iteration
			    count, the "StoredKey" and "ServerKey" (as
			    defined in the algorithm overview) for each
			    supported cryptographic hash function.</t>

			<t>Authentication database: The database used to
			    look up the authentication information
			    associated with a particular identity. For
			    application protocols, LDAPv3 (see <xref
				target='RFC4510'/>) is frequently used
			    as the authentication database. For
			    network-level protocols such as PPP or
			    802.11x, the use of RADIUS is more
			    common.</t>

			<t>Base64: An encoding mechanism defined in
			    <xref target='RFC4648'/> which converts an
			    octet string input to a textual output
			    string which can be easily displayed to a
			    human. The use of base64 in SCRAM is
			    restricted to the canonical form with no
			    whitespace.</t>

			<t>Octet: An 8-bit byte.</t>

			<t>Octet string: A sequence of 8-bit bytes.</t>

			<t>Salt: A random octet string that is combined
			    with a password before applying a one-way
			    encryption function. This value is used to
			    protect passwords that are stored in an
			    authentication database.</t>

		    </list>
		</t>

	    </section>

	    <section title="Notation">
		<t>The pseudocode description of the algorithm uses the
		    following notations:

		    <list style='symbols'>

			<t>":=": The variable on the left hand side
			    represents the octet string resulting from
			    the expression on the right hand side.</t>

			<t>"+": Octet string concatenation.</t>

			<t>"[ ]": A portion of an expression enclosed in
			    "[" and "]" may not be included in the
			    result under some circumstances. See the
			    associated text for a description of those
			    circumstances.</t>

			<t>HMAC(key, str): Apply the HMAC keyed hash
			    algorithm (defined in <xref
				target='RFC2104'/>) using the octet
			    string represented by "key" as the key and
			    the octet string "str" as the input string.
			    The size of the result is the hash result
			    size for the hash function in use.  For
			    example, it is 20 octets for SHA-1 (see
			    <xref target='RFC3174'/>).</t>

			<t>H(str): Apply the cryptographic hash function
			    to the octet string "str", producing an
			    octet string as a result. The size of the
			    result depends on the hash result size for
			    the hash function in use.</t>

			<t>XOR: Apply the exclusive-or operation to
			    combine the octet string on the left of this
			    operator with the octet string on the right
			    of this operator. The length of the output
			    and each of the two inputs will be the same
			    for this use.</t>

			<t>Hi(str, salt):</t>

		    </list>

		</t>

			<figure>
			    <artwork>
				<![CDATA[
   U0   := HMAC(str, salt + INT(1))
   U1   := HMAC(str, U0)
   U2   := HMAC(str, U1)
   ...
   Ui-1 := HMAC(str, Ui-2)
   Ui   := HMAC(str, Ui-1)

   Hi := U0 XOR U1 XOR U2 XOR ... XOR Ui
				]]>
			    </artwork>
			</figure>

		<t>

		    <list style='empty'>

			<t>where "i" is the iteration count, "+" is the
			    string concatenation operator and INT(g) is
			    a four-octet encoding of the integer g, most
			    significant octet first.</t>

		    </list>

		    <list style='symbols'>

			<t>This is, essentially, PBKDF2 <xref
				target='RFC2898'/> with HMAC() as the
			    PRF and with dkLen == output length of
			    HMAC() == output length of H().</t>

		    </list>

		</t>

	    </section>

	</section>

	<section title="Introduction">

	    <t>This specification describes a family of authentication
		mechanisms called the Salted Challenge Response
		Authentication Mechanism (SCRAM) which addresses the
		requirements necessary to deploy a challenge-response
		mechanism more widely than past attempts. When used in
		combination with Transport Layer Security (TLS, see
		<xref target='RFC5246'/>) or an equivalent security
		layer, a mechanism from this family could improve the
		status-quo for application protocol authentication and
		provide a suitable choice for a mandatory-to-implement
		mechanism for future application protocol standards.</t>

	    <t>For simplicity, this family of mechanism does not
		presently include negotiation of a security layer. It is
		intended to be used with an external security layer such
		as that provided by TLS or SSH, with optional channel
		binding <xref target="RFC5056"/> to the external
		security layer.</t>

	    <t>SCRAM is specified herein as a pure Simple Authentication
		and Security Layer (SASL) <xref target='RFC4422'/>
		mechanism, but it conforms to the new bridge between
		SASL and the Generic Security Services Application
		Programming Interface (GSS-API) called "GS2"
		[ref-needed].  This means that SCRAM is actually both, a
		GSS-API and SASL mechanism.</t>

	    <t>SCRAM provides the following protocol features:

		<list style='symbols'>

		    <t>The authentication information stored in the
			authentication database is not sufficient by
			itself to impersonate the client. The
			information is salted to prevent a pre-stored
			dictionary attack if the database is stolen.</t>

		    <t>The server does not gain the ability to
			impersonate the client to other servers (with an
			exception for server-authorized proxies).</t>

		    <t>The mechanism permits the use of a
			server-authorized proxy without requiring that
			proxy to have super-user rights with the
			back-end server.</t>

		    <t>A standard attribute is defined to enable storage
			of the authentication information in LDAPv3 (see
			<xref target='RFC4510'/>).</t>

		    <t>Mutual authentication is supported, but only the
			client is named (i.e., the server has no
			name).</t>

		</list>

	    </t>

	    <t>For an in-depth discussion of why other challenge
		response mechanisms are not considered sufficient, see
		appendix A. For more information about the motivations
		behind the design of this mechanism, see appendix B.</t>

	    <t>Comments regarding this draft may be sent either to the
		ietf-sasl@imc.org mailing list or to the authors.</t>

	</section>

	<section title="SCRAM Algorithm Overview">

	    <t>Note that this section omits some details, such as client
		and server nonces.  See <xref target='protocol'/> for
		more details.</t>

	    <t>To begin with, the client is in possession of a username
		and password.  It sends the username to the server,
		which retrieves the corresponding authentication
		information, i.e. a salt, StoredKey, ServerKey and the
		iteration count i. (Note that a server implementation
		may chose to use the same iteration count for all
		account.)  The server sends the salt and the iteration
		count to the client, which then computes the following
		values and sends a ClientProof to the server:</t>

	    <figure>
		<artwork>
		    <![CDATA[
   SaltedPassword  := Hi(password, salt)
   ClientKey       := H(SaltedPassword)
   StoredKey       := H(ClientKey)
   AuthMessage     := client-first-message + "," +
                      server-first-message + "," +
                      client-final-message-without-proof
   ClientSignature := HMAC(StoredKey, AuthMessage)
   ClientProof     := ClientKey XOR ClientSignature
   ServerKey       := HMAC(SaltedPassword, salt)
   ServerSignature := HMAC(ServerKey, AuthMessage)
		    ]]>
		</artwork>
	    </figure>

	    <t>The server authenticates the client by computing the
		ClientSignature, exclusive-ORing that with the
		ClientProof to recover the ClientKey and verifying the
		correctness of the ClientKey by applying the hash
		function and comparing the result to the StoredKey. If
		the ClientKey is correct, this proves that the client
		has access to the user's password.</t>

	    <t>Similarly, the client authenticates the server by
		computing the ServerSignature and comparing it to the
		value sent by the server.  If the two are equal, it
		proves that the server had access to the user's
		ServerKey.</t>

	    <t>The AuthMessage is computed by concatenating messages
		from the authentication exchange. The format of these
		messages is defined in <xref target='syntax'/>.</t>

	</section>

	<section anchor='mechname' title="SCRAM Mechanism Names">

	    <t>A SCRAM mechanism name is a string "SCRAM-HMAC-" followed
		by the uppercased name of the underlying hashed function
		taken from the IANA "Hash Function Textual Names"
		registry (see http://www.iana.org), optionally followed
		by the suffix "-PLUS" (see below)..</t>

	    <t>For interoperability, all SCRAM clients and servers MUST
		implement the SCRAM-HMAC-SHA-1 authentication mechanism,
		i.e. an authentication mechanism from the SCRAM family
		that uses the SHA-1 hash function as defined in <xref
		    target='RFC3174'/>.</t>

	    <t>The "-PLUS" suffix is used only when the server supports
		channel binding to the external channel.  In this case
		the server will advertise both, SCRAM-HMAC-SHA-1 and
		SCRAM-HMAC-SHA-1-PLUS, otherwise the server will
		advertise only SCRAM-HMAC-SHA-1.  The "-PLUS" exists to
		allow negotiation of the use of channel binding.  See
		<xref target="channel-binding"/>.</t>

	</section>

	<section anchor='protocol' title="SCRAM Authentication Exchange">

	    <t>SCRAM is a text protocol where the client and server
		exchange messages containing one or more attribute-value
		pairs separated by commas. Each attribute has a
		one-letter name. The messages and their attributes are
		described in <xref target='attrs'/>, and defined in
		<xref target='syntax'/>.</t>

	    <t>This is a simple example of a SCRAM-HMAC-SHA-1
		authentication exchange:</t>

	    <figure>
		<artwork>
		    <![CDATA[
   C: n,n=Chris Newman,r=ClientNonce
   S: r=ClientNonceServerNonce,s=PxR/wv+epq,i=128
   C: r=ClientNonceServerNonce,p=WxPv/siO5l+qxN4
   S: v=WxPv/siO5l+qxN4
		    ]]>
		</artwork>
	    </figure>

	    <t>With channel-binding data sent by the client this might look like
		this:</t>

	    <figure>
		<artwork>
		    <![CDATA[
   C: p,n=Chris Newman,r=ClientNonce
   S: r=ClientNonceServerNonce,s=PxR/wv+epq,i=128
   C: c=0123456789ABCDEF,r=ClientNonceServerNonce,p=WxPv/siO5l+qxN4
   S: v=WxPv/siO5l+qxN4
		    ]]>
		</artwork>
		<postamble>&lt;&lt;Note that the channel-bind data
		    above, as well as all hashes are
		    fake&gt;&gt;</postamble>
	    </figure>

	    <t>First, the client sends a message containing:

		<list style='symbols'>

		    <t>a GS2 header consisting of a flag indicating
			whether channel binding is
			supported-but-not-used, not supported, or used,
			and the SASL authzid (optional);</t>

		    <t>SCRAM username and client nonce attributes.</t>

		</list>

	    </t>

	    <t>Note that the client's first message will always start
		with "n", "y" or "p", otherwise the message is invalid
		and authentication MUST fail.  This is important, as it
		allows for GS2 extensibility (e.g., to add support for
		security layers).</t>
		
	    <t>In response, the server sends the user's iteration count
		i, the user's salt, and appends its own nonce to the
		client-specified one.  The client then responds with the
		same nonce and a ClientProof computed using the selected
		hash function as explained earlier.  In this step the
		client can also include an optional authorization
		identity.  The server verifies the nonce and the proof,
		verifies that the authorization identity (if supplied by
		the client in the second message) is authorized to act
		as the authentication identity, and, finally, it
		responds with a ServerSignature, concluding the
		authentication exchange. The client then authenticates
		the server by computing the ServerSignature and
		comparing it to the value sent by the server.  If the
		two are different, the client MUST consider the
		authentication exchange to be unsuccessful and it might
		have to drop the connection.</t>

	    <section anchor='attrs' title="SCRAM Attributes">

		<t>This section describes the permissible attributes,
		    their use, and the format of their values. All
		    attribute names are single US-ASCII letters and are
		    case-sensitive.</t>

		<t>

		    <list style='symbols'>

			<t>a: This is an optional attribute, and is part
			    of the GS2 [ref-needed] bridge between the
			    GSS-API and SASL.  This attribute specifies
			    an authorization identity. A client may
			    include it in its second message to the
			    server if it wants to authenticate as one
			    user, but subsequently act as a different
			    user.  This is typically used by an
			    administrator to perform some management
			    task on behalf of another user, or by a
			    proxy in some situations.

			    <list style='empty'>

				<t>Upon the receipt of this value the
				    server verifies its correctness
				    according to the used SASL protocol
				    profile. Failed verification results
				    in failed authentication
				    exchange.</t>

				<t>If this attribute is omitted (as it
				    normally would be), or specified
				    with an empty value, the
				    authorization identity is assumed to
				    be derived from the username
				    specified with the (required) "n"
				    attribute.</t>

				<t>The server always authenticates the
				    user specified by the "n" attribute.
				    If the "a" attribute specifies a
				    different user, the server
				    associates that identity with the
				    connection after successful
				    authentication and authorization
				    checks.</t>

				<t>The syntax of this field is the same
				    as that of the "n" field with
				    respect to quoting of '=' and
				    ','.</t>

			    </list>

			</t>


			<t>n: This attribute specifies the name of the
			    user whose password is used for
			    authentication. A client must include it in
			    its first message to the server. If the "a"
			    attribute is not specified (which would
			    normally be the case), this username is also
			    the identity which will be associated with
			    the connection subsequent to authentication
			    and authorization.

			    <list style='empty'>

				<t>Before sending the username to the
				    server, the client MUST prepare the
				    username using the "SASLPrep"
				    profile <xref target='RFC4013'/> of
				    the "stringprep" algorithm <xref
					target='RFC3454'/>. If the
				    preparation of the username fails or
				    results in an empty string, the
				    client SHOULD abort the
				    authentication exchange (*).</t>

				<t>(*) An interactive client can request
				    a repeated entry of the username
				    value.</t>

				<t>Upon receipt of the username by the
				    server, the server SHOULD prepare it
				    using the "SASLPrep" profile <xref
					target='RFC4013'/> of the
				    "stringprep" algorithm <xref
					target='RFC3454'/>.  If the
				    preparation of the username fails or
				    results in an empty string, the
				    server SHOULD abort the
				    authentication exchange.</t>

				<t>The characters ',' or '=' in
				    usernames are sent as '=2C' and
				    '=3D' respectively. If the server
				    receives a username which contains
				    '=' not followed by either '2C' or
				    '3D', then the server MUST fail the
				    authentication.</t>

			    </list>

			</t>

			<t>m: This attribute is reserved for future
			    extensibility.  In this version of SCRAM,
			    its presence in a client or a server message
			    MUST cause authentication failure when the
			    attribute is parsed by the other end.</t>

			<t>r: This attribute specifies a sequence of
			    random printable characters excluding ','
			    which forms the nonce used as input to the
			    hash function.  No quoting is applied to
			    this string (&lt;&lt;unless the binding of
			    SCRAM to a particular protocol states
			    otherwise&gt;&gt;). As described earlier,
			    the client supplies an initial value in its
			    first message, and the server augments that
			    value with its own nonce in its first
			    response. It is important that this be value
			    different for each authentication. The
			    client MUST verify that the initial part of
			    the nonce used in subsequent messages is the
			    same as the nonce it initially specified.
			    The server MUST verify that the nonce sent
			    by the client in the second message is the
			    same as the one sent by the server in its
			    first message.</t>

			<t>c: This REQUIRED attribute specifies
			    base64-encoded of a header and the channel-binding
			    data.  It is sent by the client in its second
			    authentication message.  The header consist
			    of: 

			    <list style='symbols'>

				<t>the GS2 header from the client's
				    first message (recall: a channel
				    binding flag and an optional
				    authzid);</t>

				<t>followed by the external channel's
				    channel binding type prefix (see
				    <xref target='RFC5056'/>, if and
				    only if the client is using channel
				    binding;</t>

				<t>followed by the external channel's
				    channel binding data, if and only if
				    the client is using channel
				    binding.</t>

			    </list>

			</t>
			    
			<t>s: This attribute specifies the
			    base64-encoded salt used by the server for
			    this user. It is sent by the server in its
			    first message to the client.</t>

			<t>i: This attribute specifies an iteration
			    count for the selected hash function and
			    user, and must be sent by the server along
			    with the user's salt.

			    <list style='empty'>

				<t>For SCRAM-HMAC-SHA-1 SASL mechanism
				    servers SHOULD announce a hash
				    iteration-count of at least 128.</t>

			    </list>

			</t>

			<t>p: This attribute specifies a base64-encoded
			    ClientProof. The client computes this value
			    as described in the overview and sends it to
			    the server.</t>

			<t>v: This attribute specifies a base64-encoded
			    ServerSignature. It is sent by the server in
			    its final message, and is used by the client
			    to verify that the server has access to the
			    user's authentication information.  This
			    value is computed as explained in the
			    overview.</t>

		    </list>

		</t>

	    </section>

	</section>

	<section anchor='channel-binding' title="Channel Binding">

	    <t>SCRAM supports channel binding to external secure
		channels, such as TLS.  Clients and servers may or may
		not support channel binding, therefore the use of
		channel binding is negotiable.  SCRAM does not provide
		security layers, however, therefore it is imperative
		that SCRAM provide integrity protection for the
		negotiation of channel binding.</t>

	    <t>Use of channel binding is negotiated as follows:

		<list style='symbols'>

		    <t>The server advertises support for channel binding
			by advertising both,
			SCRAM-HMAC-&lt;hash-function&gt; and
			SCRAM-HMAC-&lt;hash-function&gt;-PLUS.</t>

		    <t>If the client negotiates mechanisms then client
			MUST select
			SCRAM-HMAC-&lt;hash-function&gt;-PLUS if offered
			by the server.  Otherwise, if the client does
			not negotiate mechanisms then it MUST select
			only SCRAM-HMAC-&lt;hash-function&gt; (not
			suffixed with "-PLUS").</t>

		    <t>If the client and server both support channel
			binding, or if the client wishes to use channel
			binding but the client does not negotiate
			mechanisms, the client MUST set the GS2 channel
			binding flag to "p" and MUST include channel
			binding data for the external channel in the
			computation of the "c=" attribute (see <xref
			    target='attrs'/>).</t>

		    <t>If the client supports channel binding but the
			server does not then the client MUST set the GS2
			channel binding flag to "y" and MUST NOT include
			channel binding data for the external channel in
			the computation of the "c=" attribute (see <xref
			    target='attrs'/>).</t>

		    <t>If the client does not support channel binding
			then the client MUST set the GS2 channel binding
			flag to "n" and MUST NOT include channel binding
			data for the external channel in the computation
			of the "c=" attribute (see <xref
			    target='attrs'/>).</t>

		    <t>If the server receives a client first message
			with the GS2 channel binding flag set to "y" and
			the server supports channel binding the server
			MUST fail authentication.  This is because if
			the client sets the GS2 channel binding flag set
			to "y" then the client must have believed that
			the server did not support channel binding -- if
			the server did in fact support channel binding
			then this is an indication that there has been a
			downgrade attack (e.g., an attacker changed the
			server's mechanism list to exclude the -PLUS
			suffixed SCRAM mechanism name(s)).</t>

		</list>

	    </t>

	    <t>The server MUST always validate the client's "c=" field.
		The server does this by constructing the value of the
		"c=" attribute and then checking that it matches the
		client's c= attribute value.</t>

	    <section title="Channel Binding to TLS Channels">

		<t>If an external TLS channel is to be bound into the
		    SCRAM authentication, and if the channel was
		    established using a server certificate to
		    authenticate the server, then the SCRAM client and
		    server MUST use the 'tls-server-end-point' channel
		    binding type.  See the IANA Channel Binding Types
		    registry.</t>

		<t>If an external TLS channel is to be bound into the
		    SCRAM authentication, and if the channel was
		    established without the use of any server
		    certificate to authenticate the server, then the
		    SCRAM client and server MUST use the 'tls-unique'
		    channel binding type.</t>

	    </section>

	</section>

	<section anchor='syntax' title="Formal Syntax">

	    <t>The following syntax specification uses the Augmented
		Backus-Naur Form (ABNF) notation as specified in <xref
		    target='RFC5234'/>.  "UTF8-2", "UTF8-3" and "UTF8-4"
		non-terminal are defined in <xref
		    target='RFC3629'/>.</t>

			<figure>
			    <!-- <artwork type='abnf'> is supposed to
				work, but doesn't. -->
			    <artwork type='abnf'>
				<![CDATA[
   ALPHA = <as defined in RFC 5234 appendix B.1>
   DIGIT = <as defined in RFC 5234 appendix B.1>
   UTF8-2 = <as defined in RFC 3629 (STD 63)>
   UTF8-3 = <as defined in RFC 3629 (STD 63)>
   UTF8-4 = <as defined in RFC 3629 (STD 63)>

   generic-message = attr-val *("," attr-val)
                     ;; Generic syntax of any server challenge
                     ;; or client response

   attr-val        = ALPHA "=" value

   value           = *value-char

   value-safe-char = %x01-2B / %x2D-3C / %x3E-7F /
                     UTF8-2 / UTF8-3 / UTF8-4
                     ;; UTF8-char except NUL, "=", and ",".

   value-char      = value-safe-char / "="

   base64-char     = ALPHA / DIGIT / "/" / "+"

   base64-4        = 4base64-char

   base64-3        = 3base64-char "="

   base64-2        = 2base64-char "=="

   base64          = *base64-4 [base64-3 / base64-2]

   posit-number = %x31-39 *DIGIT
                     ;; A positive number

   saslname        = 1*(value-safe-char / "=2C" / "=3D")
                     ;; Conforms to <value>

   authzid         = "a=" saslname
                     ;; Protocol specific.

   gs2-cbind-flag  = "n" / "y" / "p"
                     ;; "n" -> client doesn't support channel binding
                     ;; "y" -> client does support channel binding
                     ;;        but thinks the server does not.
                     ;; "p" -> client requires channel binding
   gs2-header      = gs2-cbind-flag [ authzid ] ","
                     ;; GS2 header for SCRAM
                     ;; (the actual GS2 header includes an optional
                     ;; flag to indicate that the GSS mechanism is not
                     ;; "standard" but since SCRAM is "standard" we
                     ;; don't include that flag).

   username        = "n=" saslname
                     ;; Usernames are prepared using SASLPrep.

   reserved-mext  = "m=" 1*(value-char)
                     ;; Reserved for signalling mandatory extensions.
                     ;; The exact syntax will be defined in
                     ;; the future.

   ;;cbind-type    = value
   ;;cbind-input   = gs2-header [ value ":" cbind-data ]
   channel-binding = "c=" base64
                     ;; base64 encoding of cbind-input

   proof           = "p=" base64

   nonce           = "r=" c-nonce [s-nonce]
                     ;; Second part provided by server.

   c-nonce         = value

   s-nonce         = value

   salt            = "s=" base64

   verifier        = "v=" base64
                     ;; base-64 encoded ServerSignature.

   iteration-count = "i=" posit-number
                     ;; A positive number

   client-first-message =
                     gs2-header [reserved-mext ","]
                     username "," nonce ["," extensions]

   server-first-message =
                     [reserved-mext ","] nonce "," salt ","
                     iteration-count ["," extensions]

   client-final-message-without-proof =
                     [channel-binding ","] nonce [","
                     extensions]

   client-final-message =
                     client-final-message-without-proof "," proof

   gss-server-error = "e=" value
   server-final-message = gss-server-error /
                     verifier ["," extensions]
                     ;; The error message is only for the GSS-API
                     ;; form of SCRAM, and it is OPTIONAL to
                     ;; implement it.

   extensions = attr-val *("," attr-val)
                     ;; All extensions are optional,
                     ;; i.e. unrecognized attributes
                     ;; not defined in this document
                     ;; MUST be ignored.
]]>
			</artwork>
			</figure>

	</section>

	<section title="SCRAM as a GSS-API Mechanism">

	    <t>This section and its sub-sections and all normative
		references of it not referenced elsewhere in this
		document are INFORMATIONAL for SASL implementors, but
		they are NORMATIVE for GSS-API implementors.</t>

	    <t>SCRAM is actually also GSS-API mechanism.  The messages
		are the same, but a) the GS2 header on the client's
		first message and channel binding data is excluded when
		SCRAM is used as a GSS-API mechanism, and b) the RFC2743
		section 3.1 initial context token header is prefixed to
		the client's first authentication message (context
		token).</t>

	    <t>The GSS-API mechanism OID for SCRAM is &lt;TBD&gt; (see
		<xref target='iana'/>).</t>

	    <section title="GSS-API Principal Name Types for SCRAM">

		<t>SCRAM does not name acceptors.  Therefore only
		    GSS_C_NO_NAME and names of type GSS_C_NT_ANONYMOUS
		    shall be allowed as the target name input of
		    GSS_Init_sec_context() when using a SCRAM
		    mechanism.</t>

		<t>SCRAM supports only a single name type for
		    initiators: GSS_C_NT_USER_NAME.  GSS_C_NT_USER_NAME
		    is the default name type for SCRAM.</t>

		<t>There is no name canonicalization procedure for
		    SCRAM beyond applying SASLprep as described in <xref
			target='attrs'/>.</t>

		<t>The query, display and exported name syntax for SCRAM
		    principal names is the same: there is no syntax -- SCRAM
		    principal names are free-form.  (The exported name
		    token does, of course, conform to <xref
			target="RFC2743"/> section 3.2, but the "NAME"
		    part of the token is just a SCRAM user name.)</t>

	    </section>

	    <section title="GSS-API Per-Message Tokens for SCRAM">

		<t>The per-message tokens for SCRAM as a GSS-API
		    mechanism SHALL BE the same as those for the
		    Kerberos V GSS-API mechanism <xref
			target="RFC4121"/>, using the Kerberos V
		    "aes128-cts-hmac-sha1-96" enctype <xref
			target="RFC3962"/>.</t>

		<t>The 128-bit session key SHALL be derived by using the
		    least significant (right-most) 128 bits of
		    HMAC(StoredKey, "GSS-API session key" || ClientKey
		    || AuthMessage).</t>

		<t>SCRAM does support PROT_READY, and is PROT_READY on
		    the initiator side first upon receipt of the
		    server's reply to the initial security context
		    token.</t>

	    </section>

	    <section title="GSS_Pseudo_random() for SCRAM">

		<t>The GSS_Pseudo_random() <xref target="RFC4401"/> for
		    SCRAM SHALL be the same as for the Kerberos V
		    GSS-API mechanism <xref target="RFC4402"/>.  There
		    is no acceptor-asserted sub-session key for SCRAM,
		    thus GSS_C_PRF_KEY_FULL and GSS_C_PRF_KEY_PARTIAL
		    are equivalent for SCRAM's GSS_Pseudo_random().</t>

	    </section>

	</section>

	<section title="Security Considerations">

	    <t>If the authentication exchange is performed without a
		strong security layer, then a passive eavesdropper can
		gain sufficient information to mount an offline
		dictionary or brute-force attack which can be used to
		recover the user's password. The amount of time
		necessary for this attack depends on the cryptographic
		hash function selected, the strength of the password and
		the iteration count supplied by the server. An external
		security layer with strong encryption will prevent this
		attack.</t>

	    <t>If the external security layer used to protect the SCRAM
		exchange uses an anonymous key exchange, then the SCRAM
		channel binding mechanism can be used to detect a
		man-in-the-middle attack on the security layer and cause
		the authentication to fail as a result.  However, the
		man-in-the-middle attacker will have gained sufficient
		information to mount an offline dictionary or
		brute-force attack.  For this reason, SCRAM includes the
		ability to increase the iteration count over time.</t>

	    <t>If the authentication information is stolen from the
		authentication database, then an offline dictionary or
		brute-force attack can be used to recover the user's
		password. The use of salt mitigates this attack somewhat
		by requiring a separate attack on each password.
		Authentication mechanisms which protect against this
		attack are available (e.g., the EKE class of
		mechanisms), but the patent situation is presently
		unclear.</t>

	    <t>If an attacker obtains the authentication information
		from the authentication repository and either eavesdrops
		on one authentication exchange or impersonates a server,
		the attacker gains the ability to impersonate that user
		to all servers providing SCRAM access using the same
		hash function, password, iteration count and salt.  For
		this reason, it is important to use randomly-generated
		salt values.</t>

	    <t>SCRAM does not negotiate a hash function to use.  Hash
		function negotiation is left to the SASL mechanism
		negotiation.  It is important that clients be able to
		sort a locally available list of mechanisms by
		preference so that the client may pick the most
		preferred of a server's advertised mechanism list.  This
		preference order is not specified here as it is a local
		matter.  The preference order should include objective
		and subjective notions of mechanism cryptographic
		strength (e.g., SCRAM with a successor to SHA-1 may be
		preferred over SCRAM with SHA-1).</t>

	    <t>Note that to protect the SASL mechanism negotiation
		applications normally must list the server mechs twice:
		once before and once after authentication, the latter
		using security layers.  Since SCRAM does not provide
		security layers the only ways to protect the mechanism
		negotiation are: a) use channel binding to an external
		channel, or b) use an external channel that
		authenticates a user-provided server name.</t>

	    <t>A hostile server can perform a computational
		denial-of-service attack on clients by sending a big
		iteration count value.</t>

	</section>

	<section anchor='iana' title="IANA Considerations">

	    <t>IANA is requested to add the following entries to the
		SASL Mechanism registry established by <xref
		    target='RFC4422'/>:</t>

	    <figure>
		<artwork>
		    <![CDATA[
To: iana@iana.org
Subject: Registration of a new SASL mechanism SCRAM-HMAC-SHA-1

SASL mechanism name (or prefix for the family): SCRAM-HMAC-SHA-1
Security considerations: Section 7 of [RFCXXXX]
Published specification (optional, recommended): [RFCXXXX]
Person & email address to contact for further information:
 IETF SASL WG <ietf-sasl@imc.org>
Intended usage: COMMON
Owner/Change controller: IESG <iesg@ietf.org>
Note: 

To: iana@iana.org
Subject: Registration of a new SASL mechanism SCRAM-HMAC-SHA-1-PLUS

SASL mechanism name (or prefix for the family): SCRAM-HMAC-SHA-1-PLUS
Security considerations: Section 7 of [RFCXXXX]
Published specification (optional, recommended): [RFCXXXX]
Person & email address to contact for further information:
 IETF SASL WG <ietf-sasl@imc.org>
Intended usage: COMMON
Owner/Change controller: IESG <iesg@ietf.org>
Note: 
		    ]]>
		</artwork>
	    </figure>

	    <t>Note that even though this document defines a family of
		SCRAM-HMAC mechanisms, it doesn't register a family of
		SCRAM-HMAC mechanisms in the SASL Mechanisms registry.
		IANA is requested to prevent future registrations of
		SASL mechanisms starting with SCRAM-HMAC- without
		consulting the SASL mailing list
		&lt;ietf-sasl@imc.org&gt; first.</t>

	    <t>Note to future SCRAM-HMAC mechanism designers: each new
		SCRAM-HMAC SASL mechanism MUST be explicitly registered
		with IANA and MUST comply with SCRAM-HMAC mechanism
		naming convention defined in <xref target='mechname'/>
		of this document.</t>

	    <t>We hereby request that IANA assign a GSS-API mechanism
		OID for SCRAM.</t>

	</section>

	<section title="Acknowledgements">

	    <t>The authors would like to thank Dave Cridland for his
		contributions to this document.</t>

	</section>

	<appendix title="Other Authentication Mechanisms">

	    <t>The DIGEST-MD5 <xref
		    target='I-D.ietf-sasl-digest-to-historic'/>
		mechanism has proved to be too complex to implement and
		test, and thus has poor interoperability. The security
		layer is often not implemented, and almost never used;
		everyone uses TLS instead.  For a more complete list of
		problems with DIGEST-MD5 which lead to the creation of
		SCRAM see <xref
		    target='I-D.ietf-sasl-digest-to-historic'/>.</t>

	    <t>The CRAM-MD5 SASL mechanism, while widely deployed has
		also some problems, in particular it is missing some
		modern SASL features such as support for
		internationalized usernames and passwords, support for
		passing of authorization identity, support for channel
		bindings. It also doesn't support server authentication.
		For a more complete list of problems with CRAM-MD5 see
		<xref target='I-D.ietf-sasl-crammd5-to-historic'/>.</t>

	    <t>The PLAIN <xref target='RFC4616'/> SASL mechanism allows
		a malicious server or eavesdropper to impersonate the
		authenticating user to any other server for which the
		user has the same password. It also sends the password
		in the clear over the network, unless TLS is used.
		Server authentication is not supported.</t>

	</appendix>

	<appendix title="Design Motivations">

	    <t>The DIGEST-MD5 <xref
		    target='I-D.ietf-sasl-digest-to-historic'/>
		mechanism has proved to be too complex to implement and
		test, and thus has poor interoperability. The security
		layer is often not implemented, and almost never used;
		everyone uses TLS instead.  For a more complete list of
		problems with DIGEST-MD5 which lead to the creation of
		SCRAM see <xref
		    target='I-D.ietf-sasl-digest-to-historic'/>.</t>

	    <t>The CRAM-MD5 SASL mechanism, while widely deployed has
		also some problems, in particular it is missing some
		modern SASL features such as support for
		internationalized usernames and passwords, support for
		passing of authorization identity, support for channel
		bindings. It also doesn't support server authentication.
		For a more complete list of problems with CRAM-MD5 see
		<xref target='I-D.ietf-sasl-crammd5-to-historic'/>.</t>

	    <t>The PLAIN <xref target='RFC4616'/> SASL mechanism allows
		a malicious server or eavesdropper to impersonate the
		authenticating user to any other server for which the
		user has the same password. It also sends the password
		in the clear over the network, unless TLS is used.
		Server authentication is not supported.</t>

	</appendix>

	<appendix title="SCRAM Examples and Internet-Draft Change History">

	    <t>&lt;&lt;To be written.&gt;&gt;</t>

	    <t>(RFC Editor: Please delete everything after this
		point)</t>

	    <t>Open Issues

		<list style='symbols'>

		    <t>The appendices need to be written.</t>

		    <t>Should the server send a base64-encoded
			ServerSignature for the value of the "v"
			attribute, or should it compute a ServerProof
			the way the client computes a ClientProof?</t>

		</list>

	    </t>

	    <t>Changes since -10

		<list style='symbols'>

		    <t>Converted the source for this I-D to XML.</t>

		    <t>Added text to make SCRAM compliant with the new
			GS2 design.</t>

		    <t>Added text on channel binding negotiation.</t>

		    <t>Added text on channel binding, including a
			reference to RFC5056.</t>

		    <t>Added text on SCRAM as a GSS-API mechanism.  This
			noted as not relevant to SASL-only implementors
			-- the normative references for SCRAM as a
			GSS-API mechanism are segregated as well.</t>

		</list>

	    </t>

	    <t>Changes since -07

		<list style='symbols'>

		    <t>Updated References.</t>

		    <t>Clarified purpose of the m= attribute.</t>

		    <t>Fixed a problem with authentication/authorization
			identity's ABNF not allowing for some
			characters.</t>

		    <t>Updated ABNF for nonce to show client-generated
			and server-generated parts.</t>

		    <t>Only register SCRAM-HMAC-SHA-1 with IANA and
			require explicit registrations of all other
			SCRAM-HMAC- mechanisms.</t>

		</list>

	    </t>

	    <t>Changes since -06

		<list style='symbols'>

		    <t>Removed hash negotiation from SCRAM and turned it
			into a family of SASL mechanisms.</t>

		    <t>Start using "Hash Function Textual Names" IANA
			registry for SCRAM mechanism naming.</t>

		    <t>Fixed definition of Hi(str, salt) to be
			consistent with [RFC2898].</t>

		    <t>Clarified extensibility of SCRAM: added m=
			attribute (for future mandatory extensions) and
			specified that all unrecognized attributes must
			be ignored.</t>

		</list>

	    </t>

	    <t>Changes since -05

		<list style='symbols'>

		    <t>Changed the mandatory to implement hash algorithm
			to SHA-1 (as per WG consensus).</t>

		    <t>Added text about use of SASLPrep for username
			canonicalization/validation.</t>

		    <t>Clarified that authorization identity is
			canonicalized/verified according to SASL
			protocol profile.</t>

		    <t>Clarified that iteration count is per-user.</t>

		    <t>Clarified how clients select the authentication
			function.</t>

		    <t>Added IANA registration for the new
			mechanism.</t>

		    <t>Added missing normative references (UTF-8,
			SASLPrep).</t>

		    <t>Various editorial changes based on comments from
			Hallvard B Furuseth, Nico William and Simon
			Josefsson.</t>

		</list>

	    </t>

	    <t>Changes since -04

		<list style='symbols'>

		    <t>Update Base64 and Security Glossary
			references.</t>

		    <t>Add Formal Syntax section.</t>

		    <t>Don't bother with "v=".</t>

		    <t>Make MD5 mandatory to implement. Suggest
			i=128.</t>

		</list>

	    </t>

	    <t>Changes since -03

		<list style='symbols'>

		    <t>Seven years have passed, in which it became clear
			that DIGEST-MD5 suffered from unacceptably bad
			interoperability, so SCRAM-MD5 is now back from
			the dead.</t>

		    <t>Be hash agnostic, so MD5 can be replaced more
			easily.</t>

		    <t>General simplification.</t>

		</list>

	    </t>

	</appendix>

    </middle>

    <back>
	<references title="Normative References">
	    &rfc2104;
	    &rfc2119;
	    &rfc3174;
	    &rfc3454;
	    &rfc3629;
	    &rfc4013;
	    &rfc4422;
	    &rfc4648;
	    &rfc5056;
	    &rfc5234;
	</references>

	<references title="Normative References for GSS-API implementors">
	    &rfc2743;
	    &rfc3962;
	    &rfc4121;
	    &rfc4401;
	    &rfc4402;
	</references>

	<references title="Informative References">
	    &rfc2195;
	    &rfc2202;
	    &rfc2898;
	    &rfc4086;
	    &rfc4510;
	    &rfc4616;
	    &rfc4949;
	    &rfc5246;
	    &rfc2831bis;
	    &digesthistoric;
	    &cramhistoric;
	</references>
    </back>

</rfc>
