<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<rfc category='std' ipr='trust200902' docName='draft-ietf-oauth-v2-08'>
  <?rfc strict='yes' ?>
  <?rfc toc='yes' ?>
  <?rfc tocdepth='3' ?>
  <?rfc symrefs='yes' ?>
  <?rfc sortrefs='yes' ?>
  <?rfc compact='yes' ?>
  <?rfc subcompact='no' ?>

  <front>

    <title abbrev='OAuth 2.0'>The OAuth 2.0 Protocol</title>

    <author fullname='Eran Hammer-Lahav' surname='Hammer-Lahav' initials='E' role='editor'>
      <organization>Yahoo!</organization>
      <address>
        <email>eran@hueniverse.com</email>
        <uri>http://hueniverse.com</uri>
      </address>
    </author>
    <author fullname='David Recordon' surname='Recordon' initials='D'>
      <organization>Facebook</organization>
      <address>
        <email>davidrecordon@facebook.com</email>
        <uri>http://www.davidrecordon.com/</uri>
      </address>
    </author>
    <author fullname='Dick Hardt' surname='Hardt' initials='D'>
      <organization>Microsoft</organization>
      <address>
        <email>dick.hardt@gmail.com</email>
        <uri>http://dickhardt.org/</uri>
      </address>
    </author>

    <date year='2010' />

    <abstract>
      <t>
        This specification describes the OAuth 2.0 protocol.
      </t>
    </abstract>
  </front>

  <middle>

    <section title='Introduction'>
      <t>
        With the increasing use of distributed web services and cloud computing, third-party
        applications require access to server-hosted resources. These resources are usually
        protected and require authentication using the resource owner's credentials (typically a
        username and password). In the traditional client-server authentication model, a client
        accessing a protected resource on a server presents the resource owner's credentials in
        order to authenticate and gain access.
      </t>
      <t>
        OAuth introduces a third role to the traditional client-server authentication model: the
        resource owner. In OAuth, the client (which is usually not the resource owner, but is
        acting on its behalf) requests access to resources controlled by the resource owner and
        hosted by the resource server.
      </t>
      <t>
        In addition to removing the need for resource owners to share their credentials, resource
        owners should also have the ability to restrict access to a limited subset of the resources
        they control, to limit access duration, or to limit access to the methods supported by
        these resources.
      </t>
      <t>
        Instead of using the resource owner's credentials to access protected resources, clients
        obtain an access token (which denotes a specific scope, duration, and other attributes).
        Tokens are issued to third-party client by an authorization server with the approval of
        the resource owner. The client uses the access token to access the protected resources.
      </t>
      <t>
        For example, a web user (resource owner) can grant a printing service (client) access to
        her protected photos stored at a photo sharing service (resource server), without sharing
        her username and password with the printing service. Instead, she authenticates directly
        with the photo sharing service (authorization server) which issues the printing service
        delegation-specific credentials (token).
      </t>
      <t>
        This specification defines the use of OAuth over <xref target='RFC2616'>HTTP</xref>
        (or HTTP over TLS as defined by <xref target='RFC2818' />). Other specifications may
        extend it for use with other transport protocols.
      </t>

      <section title='Notational Conventions'>
        <t>
          The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD
          NOT', 'RECOMMENDED', 'MAY', and 'OPTIONAL' in this document are to be interpreted as
          described in <xref target='RFC2119' />.
        </t>
        <t>
          This document uses the Augmented Backus-Naur Form (ABNF) notation of
          <xref target='I-D.ietf-httpbis-p1-messaging' />. Additionally, the realm and auth-param
          rules are included from <xref target='RFC2617' />.
        </t>
        <t>
          Unless otherwise noted, all the protocol parameter names and values are case sensitive.
        </t>
      </section>

      <section title='Terminology'>
        <t>
          <list style='hanging' hangIndent='6'>
            <t hangText='protected resource'>
              <vspace />
              An access-restricted resource which can be obtained using an OAuth-authenticated
              request.
            </t>
            <t hangText='resource server'>
              <vspace />
              A server capable of accepting and responding to protected resource requests.
            </t>
            <t hangText='client'>
              <vspace />
              An application obtaining authorization and making protected resource requests.
            </t>
            <t hangText='resource owner'>
              <vspace />
              An entity capable of granting access to a protected resource.

              <list style='hanging' hangIndent='6'>
                <t hangText='end-user'>
                  <vspace />
                  A human resource owner.
                </t>
              </list>
            </t>
            <t hangText='token'>
              <vspace />
              A string representing an access authorization issued to the client. The string is
              usually opaque to the client and can self-contain the authorization information in a
              verifiable manner (i.e. signed), or denotes an identifier used to retrieve the
              information. Tokens represent a specific scope, duration, and other authorization
              attributes granted by the resource owner and enforced by the resource server and
              authorization servers.

              <list style='hanging' hangIndent='6'>
                <t hangText='access token'>
                  <vspace />
                  A token used by the client to make authenticated requests on behalf of the resource
                  owner.
                </t>
                <t hangText='refresh token'>
                  <vspace />
                  A token used by the client to obtain a new access token (in addition or as a
                  replacement for an expired access token), without having to involve the resource
                  owner.
                </t>
                <t hangText='authorization code'>
                  A short-lived token representing the access grant provided by the end-user. The
                  authorization code is used to obtain an access token and a refresh token.
                </t>
              </list>
            </t>
            <t hangText='authorization server'>
              <vspace />
              A server capable of issuing tokens after successfully authenticating the resource
              owner and obtaining authorization. The authorization server may be the same server as
              the resource server, or a separate entity.
            </t>
            <t hangText='end-user authorization endpoint'>
              <vspace />
              The authorization server's HTTP endpoint capable of authenticating the end-user and
              obtaining authorization. The end-user authorization endpoint is described in
              <xref target='user_authorization' />.
            </t>
            <t hangText='token endpoint'>
              <vspace />
              The authorization server's HTTP endpoint capable of issuing tokens and refreshing
              expired tokens. The token endpoint is described in <xref target='obtaining_token' />.
            </t>
            <t hangText='client identifier'>
              <vspace />
              An unique identifier issued to the client to identify itself to the authorization
              server. Client identifiers may have a matching secret. The client identifier is
              described in <xref target='client_authentication' />.
            </t>
          </list>
        </t>
      </section>

      <section title='Overview'>
        <t>
          OAuth provides a method for clients to access a protected resource on behalf of a resource
          owner. Before a client can access a protected resource, it must first obtain
          authorization from the resource owner, then exchange that access grant for an access
          token (representing the grant's scope, duration, and other attributes). The client
          accesses the protected resource by presenting the access token to the resource server.
        </t>
        <figure title='Abstract Protocol Flow' anchor='Figure 1'>
          <artwork>
            <![CDATA[
  +--------+                                  +---------------+
  |        |--(A)-- Authorization Request --->|   Resource    |
  |        |                                  |     Owner     |
  |        |<-(B)------ Access Grant ---------|               |
  |        |                                  +---------------+
  |        |
  |        |         Client Credentials &     +---------------+
  |        |--(C)------ Access Grant -------->| Authorization |
  | Client |                                  |     Server    |
  |        |<-(D)------ Access Token ---------|               |
  |        |      (w/ Optional Refresh Token) +---------------+
  |        |
  |        |                                  +---------------+
  |        |--(E)------ Access Token -------->|    Resource   |
  |        |                                  |     Server    |
  |        |<-(F)---- Protected Resource -----|               |
  +--------+                                  +---------------+

]]>
          </artwork>
        </figure>
        <t>
          The abstract flow illustrated in <xref target='Figure 1' /> includes the following
          steps:

          <list style='format (%C)'>
            <t>
              The client requests authorization from the resource owner. The client should not
              interact directly with the resource owner (since that would exposing the resource
              owner's credentials to the client), but instead requests authorization via an
              authorization server or other entities. For example, the client directs the resource
              owner to the authorization server which in turn issues it an access grant. When
              cannot be avoided, the client interacts directly with the end-user, asking for the
              end-user's username and password.
            </t>
            <t>
              The client is issued an access grant which represents the authorization provided by
              the resource owner. The access grant can be expressed as:

              <list style='symbols'>
                <t>
                  Authorization code - an access grant obtained via an authorization server. The
                  process used to obtain an authorization code is described in
                  <xref target='user_authorization' />.
                </t>
                <t>
                  Assertion - an access grant obtained from entities using a different trust
                  framework. Assertions enable the client to utilize existing trust relationships
                  to obtain an access token. They provide a bridge between OAuth and other trust
                  frameworks. The access grant represented by an assertion depends on the assertion
                  type, its content, and how it was issued, which are beyond the scope of this
                  specification.
                </t>
                <t>
                  Basic end-user credentials - obtained when interacting directly with an end-user.
                  Resource owner credentials should only be used when there is a high degree of
                  trust between the resource owner the client (e.g. its computer operating system
                  or a highly privileged application). However, unlike the HTTP Basic
                  authentication scheme defined in <xref target='RFC2617' />, the end-user's
                  credentials are used in a single request and are exchanged for an access token
                  and refresh token which eliminates the client need to store them for future use.
                </t>
              </list>
            </t>
            <t>
              The client requests an access token by authenticating with the authorization server,
              and presenting the access grant. The token request is described in
              <xref target='obtaining_token' />.
            </t>
            <t>
              The authorization server validated the client credentials and the access grant, and
              issues an access token with an optional refresh token. Access token usually have a
              shorter lifetime than the access grant. Refresh tokens usually have a lifetime equal
              to the duration of the access grant. When an access token expires, the refresh token
              is used to obtain a new access token without having to request another access grant
              from the resource owner (in which case, the refresh token acts as an access grant).
            </t>
            <t>
              The client makes a protect resource request to the resource server, and presents the
              access token in order to gain access. Accessing a protected resource is described in
              <xref target='access_resource' />.
            </t>
            <t>
              The resource server validates the access token, and if valid, serves the request.
            </t>
          </list>
        </t>
        <t>
          When the client is acting on behalf of itself (the client is also the resource owner),
          the client skips steps (A) and (B), and does not include an access grant in step (C).
          When the client uses the user-agent profile (described in <xref target='user_agent' />),
          the authorization request (A) results in an access token (D), skipping steps (B) and (C).
        </t>
        <t>
          The sizes of tokens and other values received from the authorization server, are left
          undefined by this specification. Clients should avoid making assumptions about value
          sizes. Servers should document the expected size of any value they issue.
        </t>
      </section>

      <section title='Client Profiles'>
        <t>
          OAuth supports a wide range of client types by providing a rich and extensible framework
          for establishing authorization and exchaning it for an access token. The methods detailed
          in this specification were designed to accomodate four client types: web servers,
          user-agents, native applications, and autonomous clients. Additional authorization flows
          and client profiles may be defined by other specifications to cover additional scenarios
          and client types.
        </t>

        <section title='Web Server'>
          <t>
            The web server profile is suitable for clients capable of interacting with the end-user's
            user-agent (typically a web browser) and capable of receiving incoming requests from the
            authorization server (capable of acting as an HTTP server).
          </t>
          <figure title='Web Server Flow' anchor='Figure 2'>
            <artwork>
              <![CDATA[
  +----------+          Client Identifier      +---------------+
  |         -+----(A)--- & Redirect URI ------>|               |
  | End-user |                                 | Authorization |
  |    at    |<---(B)-- User authenticates --->|     Server    |
  | Browser  |                                 |               |
  |         -+----(C)-- Authorization Code ---<|               |
  +-|----|---+                                 +---------------+
    |    |                                         ^      v
   (A)  (C)                                        |      |
    |    |                                         |      |
    ^    v                                         |      |
  +---------+                                      |      |
  |         |>---(D)-- Client Credentials, --------'      |
  |   Web   |          Authorization Code,                |
  |  Client |            & Redirect URI                   |
  |         |                                             |
  |         |<---(E)----- Access Token -------------------'
  +---------+       (w/ Optional Refresh Token)
]]>
            </artwork>
          </figure>
          <t>
            The web server flow illustrated in <xref target='Figure 2' /> includes the following
            steps:

            <list style='format (%C)'>
              <t>
                The web client initiates the flow by redirecting the end-user's user-agent to the
                end-user authorization endpoint as described in <xref target='user_authorization' />
                using client type <spanx style='verb'>web_server</spanx>. The client includes its
                client identifier, requested scope, local state, and a redirect URI to which the
                authorization server will send the end-user back once access is granted (or
                denied).
              </t>
              <t>
                The authorization server authenticates the end-user (via the user-agent) and
                establishes whether the end-user grants or denies the client's access request.
              </t>
              <t>
                Assuming the end-user granted access, the authorization server redirects the
                user-agent back to the client to the redirection URI provided earlier. The
                authorization includes an authorization code for the client to use to obtain an
                access token.
              </t>
              <t>
                The client requests an access token from the authorization server by authenticating
                and including the authorization code received in the previous step as described in
                <xref target='obtaining_token' />.
              </t>
              <t>
                The authorization server validates the client credentials and the authorization
                code and responds back with the access token.
              </t>
            </list>
          </t>
        </section>

        <section title='User-Agent' anchor='user_agent'>
          <t>
            The user-agent profile is suitable for client applications residing in a user-agent,
            typically implemented in a browser using a scripting language such as JavaScript. These
            clients cannot keep client secrets confidential and the authentication of the client is
            based on the user-agent's same-origin policy.
          </t>
          <t>
            Unlike other profiles in which the client makes a separate end-user authorization request
            and an access token requests, the client receives the access token as a result of the
            end-user authorization request in the form of an HTTP redirection. The client requests
            the authorization server to redirect the user-agent to another web server or local
            resource accessible to the user-agent which is capable of extracting the access token
            from the response and passing it to the client.
          </t>
          <t>
            This user-agent profile does not utilize the client secret since the client executables
            reside on the end-user's computer or device which makes the client secret accessible
            and exploitable. Because the access token is encoded into the redirection URI, it may
            be exposed to the end-user and other applications residing on the computer or device.
          </t>
          <figure title='User-Agent Flow' anchor='Figure 3'>
            <artwork>
              <![CDATA[
         +----------+          Client Identifier     +----------------+
         |          |>---(A)-- & Redirection URI --->|                |
         |          |                                |                |
  End <--+  -  -  - +----(B)-- User authenticates -->|  Authorization |
  User   |          |                                |     Server     |
         |          |<---(C)--- Redirect URI -------<|                |
         |  Client  |         with Access Token      |                |
         |    in    |    (w/ Optional Authorization  +----------------+
         |  Browser |         Code) in Fragment
         |          |                                +----------------+
         |          |>---(D)--- Redirect URI ------->|                |
         |          |         without Fragment       |   Web Server   |
         |          |                                |   with Client  |
         |    (F)   |<---(E)--- Web Page with ------<|    Resource    |
         |  Access  |              Script            |                |
         |   Token  |                                +----------------+
         +----------+                                
]]>
            </artwork>
          </figure>
          <t>
            The user-agent flow illustrated in <xref target='Figure 3' /> includes the following
            steps:

            <list style='format (%C)'>
              <t>
                The client sends the user-agent to the end-user authorization endpoint as described
                in <xref target='user_authorization' /> using client type
                <spanx style='verb'>user-agent</spanx>. The client includes its client identifier,
                requested scope, local state, and a redirect URI to which the authorization server
                will send the end-user back once authorization is granted (or denied).
              </t>
              <t>
                The authorization server authenticates the end-user (via the user-agent) and
                establishes whether the end-user grants or denies the client's access request.
              </t>
              <t>
                If the end-user granted access, the authorization server redirects the
                user-agent to the redirection URI provided earlier. The redirection URI includes
                the access token (and an optional authorization code) in the URI fragment.
              </t>
              <t>
                The user-agent follows the redirection instructions by making a request to the web
                server which does not include the fragment. The user-agent retains the fragment
                information locally.
              </t>
              <t>
                The web server returns a web page  (typically an HTML page with an embedded script)
                capable of accessing the full redirection URI including the fragment retained by the
                user-agent, and extracting the access token (and other parameters) contained in the
                fragment.
              </t>
              <t>
                The user-agent executes the script provided by the web server which extracts the
                access token and passes it to the client. If an authorization code was issued, the
                client can pass it to a web server component to obtain another access token for
                additional server-based protected resources interaction.
              </t>
            </list>
          </t>
        </section>

        <section title='Native Application'>
          <t>
            Native application are clients running as native code on the end-user's computer or
            device (i.e. executing outside a user-agent or as a desktop program). These clients are
            often capable of interacting with (or embedding) the end-user's user-agent but are
            incapable of receiving callback requests from the server (incapable of acting as an HTTP
            server).
          </t>
          <t>
            Native application clients can be implemented in different ways based on their
            requirements and desired end-user experience. Native application clients can:

            <list style='symbols'>
              <t>
                Utilize the end-user authorization endpoint as described in
                <xref target='user_authorization' /> by launching an external user-agent. The client
                can capture the response by providing a redirection URI with a custom URI scheme
                (registered with the operating system to invoke the client application), or by
                providing a redirection URI pointing to a server-hosted resource under the client's
                control which puts the response in the user-agent window title (from which the client
                can obtain the response by polling the user-agnet window, looking for a window title
                change).
              </t>
              <t>
                Utilize the end-user authorization endpoint as described in
                <xref target='user_authorization' /> by using an embedded user-agent. The client
                obtains the response by directly communicating with the embedded user-agent.
              </t>
              <t>
                Prompt end-users for their basic credentials (username and password) and use them
                directly to obtain an access token. This is generally discouraged as it hands the
                end-user's password directly to the 3rd party and is limited to basic credentials.
              </t>
            </list>
          </t>
          <t>
            When choosing between launching an external browser and an embedded user-agent,
            developers should consider the following:

            <list style='symbols'>
              <t>
                External user-agents may improve completion rate as the end-user may already be
                logged-in and not have to re-authenticate.
              </t>
              <t>
                Embedded user-agents often offer a better end-user flow, as they remove the need to
                switch context and open new windows.
              </t>
              <t>
                Embedded user-agents are less secure because users are authenticating in unidentified
                window without access to the protections offered by many user-agents.
              </t>
            </list>
          </t>
        </section>

        <section title='Autonomous'>
          <t>
            Autonomous clients act on their own behalf (the client is also the resource owner),
            or utilize existing trust relationship or framework to establish authorization without
            directly involving the resource owner.
          </t>
          <t>
            Autonomous clients can be implemented in different ways based on their
            requirements and the existing trust framework they rely upon. Autonomous clients can:

            <list style='symbols'>
              <t>
                Obtain an access token by authenticating with the authorization server using their
                client credentials. The scope of the access token is limited to the protected
                resources under the control of the client.
              </t>
              <t>
                Use an existing access grant expressed as an assertion using an assertion format
                supported by the authorization server. Using assertions requires the client to
                obtain a assertion (such as a <xref target='OASIS.saml-core-2.0-os'>SAML</xref>
                assertion) from an assertion issuer or to self-issue an assertion. The assertion
                format, the process by which the assertion is obtained, and the method of
                validating the assertion are defined by the assertion issuer and the authorization
                server, and are beyond the scope of this specification.
              </t>
            </list>
          </t>
        </section>

      </section>

    </section>

    <section title='Client Credentials' anchor='client_authentication'>
      <t>
        When interacting with the authorization server, the client identifies itself using a set of
        client credentials. The client credentials include a client identifier and MAY include a
        secret or other means for the authorization server to authenticate the client.
      </t>
      <t>
        The means through which the client obtains its credentials are beyond the scope of this
        specification, but usually involve registration with the authorization server.
        [[ OAuth Discovery provides one way of obtaining basic client credentials ]]
      </t>
      <t>
        Due to the nature of some clients, authorization servers SHOULD NOT make assumptions
        about the confidentiality of client credentials without establishing trust with the
        client operator. Authorization servers SHOULD NOT issue client secrets to clients
        incapable of keeping their secrets confidential.
      </t>
      <t>
        This specification provides one mean of authenticating the client using a set of basic
        client credentials. The authorization server MAY authenticate the client using any desired
        authentication scheme.
      </t>

      <section title='Basic Client Credentials'>
        <t>
          The basic client credentials include a client identifier and an OPTIONAL matching shared
          symmetric secret. The client identifier and secret are included in the request using the
          HTTP Basic authentication scheme as defined in <xref target='RFC2617' /> by including the
          client identifier as the username and secret as the password.
        </t>
        <figure>
          <preamble>
            For example (line breaks are for display purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded

  type=web_server&code=i1WsRn1uB1&
  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
          </artwork>
        </figure>
        <t>
          Alternatively, the client MAY include the credentials using the following request
          parameters:

          <list style='hanging' hangIndent='6'>
            <t hangText='client_id'>
              <vspace />
              REQUIRED. The client identifier.
            </t>
            <t hangText='client_secret'>
              REQUIRED if the client identifier has a matching secret.
            </t>
          </list>
        </t>
        <figure>
          <preamble>
            For example (line breaks are for display purposes only):
          </preamble>
          <artwork>
            <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  type=web_server&client_id=s6BhdRkqt3&
  client_secret=gX1fBat3bV&code=i1WsRn1uB1&
  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
          </artwork>
        </figure>
        <t>
          The client MAY include the client credentials using other HTTP authentication schemes
          which support authenticating using a username and password. The client MUST NOT include
          the client credentials using more than one mechanism. If more than one mechanism is used,
          regardless whether the credentials are identical or valid, the server MUST reply with an
          HTTP 400 status code (Bad Request) and include the
          <spanx style='verb'>multiple_credentials</spanx> error code.
        </t>
        <t>
          The authorization server MUST accept the client credentials using both the request
          parameters, and the HTTP Basic authentication scheme. The authorization server MAY
          support additional authentication schemes.
        </t>
      </section>

    </section>

    <section title='Obtaining End-User Authorization' anchor='user_authorization'>
      <t>
        When the client interacts with an end-user, the end-user MUST first grant the client
        authorization to access its protected resources. Once obtained, the end-user access
        grant is expressed as an authorization code which the client uses to obtain an access
        token. To obtain an end-user authorization, the client sends the end-user to the
        end-user authorization endpoint.
      </t>
      <t>
        At the end-user authorization endpoint, the end-user first authenticates with the
        authorization server, and then grants or denies the access request. The way in which the
        authorization server authenticates the end-user (e.g. username and password login, OpenID,
        session cookies) and in which the authorization server obtains the end-user's
        authorization, including whether it uses a secure channel such as TLS, is beyond the scope
        of this specification. However, the authorization server MUST first verify the identity of
        the end-user.
      </t>
      <t>
        The location of the end-user authorization endpoint can be found in the service
        documentation, or can be obtained by using [[ OAuth Discovery ]]. The end-user
        authorization endpoint URI MAY include a query component as defined by
        <xref target='RFC3986' /> section 3, which must be retained when adding additional
        query parameters.
      </t>
      <t>
        Since requests to the end-user authorization endpoint result in user authentication and
        the transmission of sensitive information, the authorization server SHOULD require the
        use of a transport-layer mechanism such as TLS when sending requests to the end-user
        authorization endpoint.
      </t>
      <t>
        In order to direct the end-user's user-agent to the authorization server, the client
        constructs the request URI by adding the following parameters to the end-user
        authorization endpoint URI query component using the
        <spanx style='verb'>application/x-www-form-urlencoded</spanx> format as defined by
        <xref target='W3C.REC-html401-19991224' />:

        <list style='hanging' hangIndent='6'>
          <t hangText='type'>
            <vspace />
            REQUIRED. The client type (user-agent or web server). Determines how the
            authorization server delivers the authorization response back to the client. The
            parameter value MUST be set to <spanx style='verb'>web_server</spanx> or
            <spanx style='verb'>user_agent</spanx>.
          </t>
          <t hangText='client_id'>
            <vspace />
            REQUIRED. The client identifier as described in
            <xref target='client_authentication' />.
          </t>
          <t hangText='redirect_uri'>
            <vspace />
            REQUIRED, unless a redirection URI has been established between the client and
            authorization server via other means. An absolute URI to which the authorization
            server will redirect the user-agent to when the end-user authorization step is
            completed. The authorization server SHOULD require the client to pre-register
            their redirection URI. Authorization servers MAY restrict the redirection URI to
            not include a query component as defined by <xref target='RFC3986' /> section 3.
          </t>
          <t hangText='state'>
            <vspace />
            OPTIONAL. An opaque value used by the client to maintain state between the request
            and callback. The authorization server includes this value when redirecting the
            user-agent back to the client.
          </t>
          <t hangText='scope'>
            <vspace />
            OPTIONAL. The scope of the access request expressed as a list of space-delimited
            strings. The value of the <spanx style='verb'>scope</spanx> parameter is defined
            by the authorization server. If the value contains multiple space-delimited
            strings, their order does not matter, and each string adds an additional access
            range to the requested scope.
          </t>
        </list>
      </t>
      <t>
        The client directs the end-user to the constructed URI using an HTTP redirection
        response, or by other means available to it via the end-user's user-agent. The
        request MUST use the HTTP <spanx style='verb'>GET</spanx> method.
      </t>
      <figure>
        <preamble>
          For example, the client directs the end-user's user-agent to make the
          following HTTPS request (line breaks are for display purposes only):
        </preamble>
        <artwork>
          <![CDATA[
  GET /authorize?type=web_server&client_id=s6BhdRkqt3&redirect_uri=
      https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
  Host: server.example.com
]]>
        </artwork>
      </figure>
      <t>
        If the client has previously registered a redirection URI with the authorization server,
        the authorization server MUST verify that the redirection URI received matches the
        registered URI associated with the client identifier. [[ provide guidance on how to
        perform matching ]]
      </t>
      <t>
        The authorization server authenticates the end-user and obtains an authorization
        decision (by asking the end-user or by establishing approval via other means). When a
        decision has been established, the authorization server directs the end-user's
        user-agent to the provided client redirection URI using an HTTP redirection response,
        or by other means available to it via the end-user's user-agent.
      </t>

      <section title='Authorization Server Response'>
        <t>
          If the end-user grants the access request, the authorization server issues an access
          token, an authorization code, or both, and delivers them to the client by adding the
          following parameters to the redirection URI:

          <list style='hanging' hangIndent='6'>
            <t hangText='code'>
              <vspace />
              REQUIRED if the client type is <spanx style='verb'>web_server</spanx>, otherwise
              OPTIONAL. The authorization code generated by the authorization server. The
              authorization code SHOULD expire shortly after it is issued and allowed for a
              single use. The authorization code is bound to the client identifier and
              redirection URI.
            </t>
            <t hangText='access_token'>
              <vspace />
              REQUIRED if the client type is <spanx style='verb'>user_agent</spanx>, otherwise
              MUST NOT be included. The access token.
            </t>
            <t hangText='expires_in'>
              <vspace />
              OPTIONAL. The duration in seconds of the access token lifetime if an access token
              is included.
            </t>
            <t hangText='state'>
              <vspace />
              REQUIRED if the <spanx style='verb'>state</spanx> parameter was present in the
              client authorization request. Set to the exact value received from the client.
            </t>
          </list>
        </t>
        <t>
          If the end-user denies the access request, the authorization server informs the
          client by adding the following parameters to the redirection URI:

          <list style='hanging' hangIndent='6'>
            <t hangText='error'>
              <vspace />
              REQUIRED. The parameter value MUST be set to
              <spanx style='verb'>user_denied</spanx>.
            </t>
            <t hangText='state'>
              <vspace />
              REQUIRED if the <spanx style='verb'>state</spanx> parameter was present in the
              client authorization request. Set to the exact value received from the client.
            </t>
          </list>
        </t>
        <t>
          The method in which the authorization server adds the parameter to the redirection
          URI is determined by the client type provided by the client in the authorization
          request using the <spanx style='verb'>type</spanx> parameter.
        </t>
        <t>
          If the client type is <spanx style='verb'>web_server</spanx>, the authorization
          server adds the parameters to the redirection URI query component using the
          <spanx style='verb'>application/x-www-form-urlencoded</spanx> format as defined by
          <xref target='W3C.REC-html401-19991224' />.
        </t>
        <figure>
          <preamble>
            For example, the authorization server redirects the end-user's user-agent by
            sending the following HTTP response:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 302 Found
  Location: https://client.example.com/cb?code=i1WsRn1uB1
]]>
          </artwork>
        </figure>
        <t>
          If the client type is <spanx style='verb'>user_agent</spanx>, the authorization
          server adds the parameters to the redirection URI fragment component using the
          <spanx style='verb'>application/x-www-form-urlencoded</spanx> format as defined by
          <xref target='W3C.REC-html401-19991224' />. [[ replace form-encoded
          with JSON? ]]
        </t>
        <figure>
          <preamble>
            For example, the authorization server redirects the end-user's user-agent by
            sending the following HTTP response:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 302 Found
  Location: http://example.com/rd#access_token=FJQbwq9&expires_in=3600
]]>
          </artwork>
        </figure>
      </section>

    </section>

    <section title='Obtaining an Access Token' anchor='obtaining_token'>
      <t>
        The client obtains an access token by authenticating with the authorization server and
        presenting its access grant.
      </t>
      <t>
        After obtaining authorization from the resource owner, clients request an access token
        from the authorization server's token endpoint. When requesting an access token, the
        client authenticates with the authorization server and includes the access grant
        (in the form of an authorization code, resource owner credentials, an assertion, or a
        refresh token).
      </t>
      <t>
        The location of the token endpoint can be found in the service documentation, or can be
        obtained by using [[ OAuth Discovery ]]. The token endpoint URI MAY include a query
        component, which must be retained when adding additional query parameters.
      </t>
      <t>
        Since requests to the token endpoint result in the transmission of plain text
        credentials in the HTTP request and response, the authorization server MUST require the
        use of a transport-layer mechanism when sending requests to the token endpoints. Servers
        MUST support TLS 1.2 as defined in <xref target='RFC5246' /> and MAY support addition
        mechanisms with equivalent protections.
      </t>
      <t>
        The client requests an access token by constructing a token request and making an HTTP
        <spanx style='verb'>POST</spanx> request. The client constructs the request URI by adding
        its client credentials to the request as described in
        <xref target='client_authentication' />, and includes the following parameters using the
        <spanx style='verb'>application/x-www-form-urlencoded</spanx> format in the HTTP request
        entity-body:

        <list style='hanging' hangIndent='6'>
          <t hangText='grant_type'>
            <vspace />
            REQUIRED. The access grand type included in the request. Value MUST be one of
            <spanx style='verb'>authorization_code</spanx>,
            <spanx style='verb'>user_basic_credentials</spanx>,
            <spanx style='verb'>assertion</spanx>,
            <spanx style='verb'>refresh_token</spanx>, or <spanx style='verb'>none</spanx> (which
            indicates the client is acting on behalf of itself).
          </t>
          <t hangText='scope'>
            <vspace />
            OPTIONAL. The scope of the access request expressed as a list of space-delimited
            strings. The value of the <spanx style='verb'>scope</spanx> parameter is defined
            by the authorization server. If the value contains multiple space-delimited
            strings, their order does not matter, and each string adds an additional access
            range to the requested scope. If the access grant being used already represents an
            approved scope (e.g. authorization code, assertion), the requested scope MUST be equal
            or lesser than the scope previously granted.
          </t>
        </list>
      </t>
      <t>
        In addition, the client MUST include the appropriate parameters listed for the selected
        access grant type as described in <xref target='access_grant_parameters' />.
      </t>

      <section title='Access Grant Parameters' anchor='access_grant_parameters'>

        <section title='Authorization Code'>
          <t>
            The client includes the authorization code using the
            <spanx style='verb'>authorization_code</spanx> access grant type and the following
            parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='code'>
                <vspace />
                REQUIRED. The authorization code received from the authorization server.
              </t>
              <t hangText='redirect_uri'>
                <vspace />
                REQUIRED. The redirection URI used in the initial request.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request (line breaks are for display
              purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  grant_type=authorization_code&client_id=s6BhdRkqt3&
  client_secret=gX1fBat3bV&code=i1WsRn1uB1&
  redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST verify that the authorization code, client identity,
            client secret, and redirection URI are all valid and match its stored association. If
            the request is valid, the authorization server issues a successful response as
            described in <xref target='access_token_response' />.
          </t>
        </section>

        <section title='Resource Owner Basic Credentials'>
          <t>
            The client includes the resource owner credentials using the following parameters:
            [[ add internationalization consideration for username and password ]]

            <list style='hanging' hangIndent='6'>
              <t hangText='username'>
                <vspace />
                REQUIRED. The end-user's username.
              </t>
              <t hangText='password'>
                <vspace />
                REQUIRED. The end-user's password.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request (line breaks are for
              display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded
  
  grant_type=user_basic&client_id=s6BhdRkqt3&
  client_secret=47HDu8s&username=johndoe&password=A3ddj3w
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST validate the client credentials and end-user credentials
            and if valid issues an access token response as described in
            <xref target='access_token_response' />.
          </t>
        </section>

        <section title='Assertion'>
          <t>
            The client includes the assertion using the following parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='assertion_type'>
                <vspace />
                REQUIRED. The format of the assertion as defined by the authorization server. The
                value MUST be an absolute URI.
              </t>
              <t hangText='assertion'>
                <vspace />
                REQUIRED. The assertion.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request (line breaks are for
              display purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded
  
  grant_type=assertion&client_id=s6BhdRkqt3&client_secret=diejdsks&
  assertion_type=urn%3Aoasis%3Anames%sAtc%3ASAML%3A2.0%3Aassertion&
  assertion=PHNhbWxwOl...[ommited for brevity]...ZT4%3D
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST validate the assertion and if valid issues an access
            token response as described in <xref target='access_token_response' />. The
            authorization server SHOULD NOT issue a refresh token.
          </t>
          <t>
            Authorization servers SHOULD issue access tokens with a limited lifetime and require
            clients to refresh them by requesting a new access token using the same assertion if it
            is still valid. Otherwise the client MUST obtain a new valid assertion.
          </t>
        </section>

        <section title='Refresh Token' anchor='token_refresh'>
          <t>
            The client includes the refresh token using the following parameters:

            <list style='hanging' hangIndent='6'>
              <t hangText='refresh_token'>
                <vspace />
                REQUIRED. The refresh token associated with the access token to be refreshed.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              For example, the client makes the following HTTPS request (line break are for display
              purposes only):
            </preamble>
            <artwork>
              <![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded
  
  grant_type=refresh_token&client_id=s6BhdRkqt3&
  client_secret=8eSEIpnqmM&refresh_token=n4E9O119d
]]>
            </artwork>
          </figure>
          <t>
            The authorization server MUST verify the client credentials, the validity of the
            refresh token, and that the resource owner's authorization is still valid. If the
            request is valid, the authorization server issues an access token response as described
            in <xref target='access_token_response' />. The authorization server MAY issue a new
            refresh token in which case the client MUST NOT use the previous refresh token and
            replace it with the newly issued refresh token.
          </t>
        </section>

      </section>

      <section title='Access Token Response' anchor='access_token_response'>
        <t>
          After receiving and verifying a valid and authorized access token request from the
          client, the authorization server issues the access token and optional refresh token,
          and constructs the response by adding the following parameters to the entity body of
          the HTTP response with a 200 status code (OK):
        </t>
        <t>
          The token response contains the following parameters:

          <list style='hanging' hangIndent='6'>
            <t hangText='access_token'>
              <vspace />
              REQUIRED. The access token issued by the authorization server.
            </t>
            <t hangText='expires_in'>
              <vspace />
              OPTIONAL. The duration in seconds of the access token lifetime.
            </t>
            <t hangText='refresh_token'>
              <vspace />
              OPTIONAL. The refresh token used to obtain new access tokens using the same
              end-user access grant as described in <xref target='token_refresh' />.
            </t>
            <t hangText='scope'>
              <vspace />
              OPTIONAL. The scope of the access token as a list of space-delimited strings. The
              value of the <spanx style='verb'>scope</spanx> parameter is defined by the
              authorization server. If the value contains multiple space-delimited strings,
              their order does not matter, and each string adds an additional access range to
              the requested scope.
            </t>
          </list>
        </t>
        <t>
          The parameters are including in the entity body of the HTTP response using the
          <spanx style='verb'>application/json</spanx> media type as defined by
          <xref target='RFC4627' />. The parameters are serialized into a JSON structure by
          adding each parameter at the highest structure level. Parameter names and string values
          are included as JSON strings. Numerical values are included as JSON numbers.
        </t>
        <t>
          The authorization server MUST include the HTTP <spanx style='verb'>Cache-Control</spanx>
          response header field with a value of <spanx style='verb'>no-store</spanx> in any
          response containing tokens, secrets, or other sensitive information.
        </t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store

  {
    "access_token":"SlAV32hkKG",
    "expires_in":3600,
    "refresh_token":"8xLOxBtZp8"
  }
]]>
          </artwork>
        </figure>
      </section>

      <section title='Error Response' anchor='token_error'>
        <t>
          If the token request is invalid or unauthorized, the authorization server constructs
          the response by adding the following parameter to the entity body of the HTTP
          response with a a 400 status code (Bad Request) using the
          <spanx style='verb'>application/json</spanx> media type:

          <list style='hanging' hangIndent='6'>
            <t hangText='error'>
              <vspace />
              REQUIRED. The error code as described in <xref target='error_codes' />.
            </t>
          </list>
        </t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 400 Bad Request
  Content-Type: application/json
  Cache-Control: no-store

  {
    "error":"incorrect_client_credentials"
  }
]]>
          </artwork>
        </figure>

        <section title='Error Codes' anchor='error_codes'>
          <t>
            [[ expalain each error code: ]]

            <list style='symbols'>
              <t>
                <spanx style='verb'>redirect_uri_mismatch</spanx>
              </t>
              <t>
                <spanx style='verb'>bad_authorization_code</spanx>
              </t>
              <t>
                <spanx style='verb'>invalid_client_credentials</spanx>
              </t>
              <t>
                <spanx style='verb'>unauthorized_client'</spanx> - The client is not permitted to
                use this access grant type.
              </t>
              <t>
                <spanx style='verb'>invalid_assertion</spanx>
              </t>
              <t>
                <spanx style='verb'>unknown_format</spanx>
              </t>
              <t>
                <spanx style='verb'>authorization_expired</spanx>
              </t>
              <t>
                <spanx style='verb'>multiple_credentials</spanx>
              </t>
              <t>
                <spanx style='verb'>invalid_user_credentials</spanx>
              </t>
            </list>
          </t>
        </section>

      </section>

    </section>

    <section title='Accessing a Protected Resource' anchor='access_resource'>
      <t>
        Clients access protected resources by presenting an access token to the resource server.
      </t>
      <figure>
        <preamble>
          For example:
        </preamble>
        <artwork>
          <![CDATA[
  GET /resource HTTP/1.1
  Host: server.example.com
  Authorization: Token token="vF9dft4qmT"
]]>
        </artwork>
      </figure>
      <t>
        Access tokens act as bearer tokens, where the token string acts as a shared symmetric
        secret. This requires treating the access token with the same care as other secrets (e.g.
        end-user passwords). Access tokens SHOULD NOT be sent in the clear over an insecure
        channel.
      </t>
      <t>
        However, when it is necessary to transmit bearer tokens in the clear without a secure
        channel, authorization servers SHOULD issue access tokens with limited scope and lifetime
        to reduce the potential risk from a compromised access token.
      </t>
      <t>
        Clients SHOULD NOT make authenticated requests with an access token to unfamiliar resource
        servers, especially when using bearer tokens, regardless of the presence of a secure
        channel.
      </t>
      <t>
        The methods used by the resource server to validate the access token are beyond the scope
        of this specification, but generally involve an interaction or coordination between the
        resource server and authorization server.
      </t>
      <t>
        The resource server MUST validate the access token and ensure it has not expired and
        that its scope covers the requested resource. If the token expired or is invalid, the
        resource server MUST reply with an HTTP 401 status code (Unauthorized) and include
        the HTTP <spanx style='verb'>WWW-Authenticate</spanx> response header field as described in
        <xref target='authn_header' />.
      </t>
      <figure>
        <preamble>
          For example:
        </preamble>
        <artwork>
          <![CDATA[
  HTTP/1.1 401 Unauthorized
  WWW-Authenticate: Token realm='Service', error='token_expired'
]]>
        </artwork>
      </figure>
      <t>
        Clients make authenticated token requests using the <spanx style='verb'>Authorization</spanx>
        request header field as described in <xref target='authz_header' />. Alternatively, clients
        MAY include the access token using the HTTP request URI in the query component as described
        in <xref target='query_param' />, or in the HTTP body when using the
        <spanx style='verb'>application/x-www-form-urlencoded</spanx> content type as
        described in <xref target='body_param' />.
      </t>
      <t>
        Clients SHOULD only use the request URI or body when the
        <spanx style='verb'>Authorization</spanx> request header field is not available, and MUST
        NOT use more than one method in each request. [[ specify error ]]
      </t>

      <section title='The Authorization Request Header Field' anchor='authz_header'>
        <t>
          The <spanx style='verb'>Authorization</spanx> request header field is used by clients to
          make authenticated token requests. The client uses the <spanx style='verb'>token</spanx>
          attribute to include the access token in the request.
        </t>
        <t>
          The <spanx style='verb'>Authorization</spanx> header field uses the framework defined by
          <xref target='RFC2617' /> as follows:
        </t>
        <figure>
          <artwork xml:space='preserve'><![CDATA[
  credentials    = "Token" RWS access-token [ CS 1#auth-param ]
  access-token   = "token" "=" <"> token <">
  CS             = OWS "," OWS
]]>
          </artwork>
        </figure>
      </section>

      <section title='URI Query Parameter' anchor='query_param'>
        <t>
          When including the access token in the HTTP request URI, the client adds the access
          token to the request URI query component as defined by <xref target='RFC3986' /> using
          the <spanx style='verb'>oauth_token</spanx> parameter.
        </t>
        <figure>
          <preamble>
            For example, the client makes the following HTTPS request:
          </preamble>
          <artwork>
            <![CDATA[
  GET /resource?oauth_token=vF9dft4qmT HTTP/1.1
  Host: server.example.com
]]>
          </artwork>
        </figure>
        <t>
          The HTTP request URI query can include other request-specific parameters, in which
          case, the <spanx style='verb'>oauth_token</spanx> parameters SHOULD be appended
          following the request-specific parameters, properly separated by an
          <spanx style='verb'>&amp;</spanx> character (ASCII code 38).
        </t>
        <t>
          The resource server MUST validate the access token and ensure it has not expired and
          its scope includes the requested resource. If the resource expired or is not valid, the
          resource server MUST reply with an HTTP 401 status code (Unauthorized) and include the
          HTTP <spanx style='verb'>WWW-Authenticate</spanx> response header field as described in
          <xref target='authn_header' />.
        </t>
      </section>

      <section title='Form-Encoded Body Parameter' anchor='body_param'>
        <t>
          When including the access token in the HTTP request entity-body, the client adds the
          access token to the request body using the <spanx style='verb'>oauth_token</spanx>
          parameter. The client can use this method only if the following REQUIRED conditions are
          met:

          <list style='symbols'>
            <t>
              The entity-body is single-part.
            </t>
            <t>
              The entity-body follows the encoding requirements of the
              <spanx style='verb'>application/x-www-form-urlencoded</spanx> content-type as
              defined by <xref target='W3C.REC-html401-19991224' />.
            </t>
            <t>
              The HTTP request entity-header includes the <spanx style='verb'>Content-Type</spanx>
              header field set to <spanx style='verb'>application/x-www-form-urlencoded</spanx>.
            </t>
            <t>
              The HTTP request method is <spanx style='verb'>POST</spanx>,
              <spanx style='verb'>PUT</spanx>, or <spanx style='verb'>DELETE</spanx>.
            </t>
          </list>
        </t>
        <t>
          The entity-body can include other request-specific parameters, in which case, the
          <spanx style='verb'>oauth_token</spanx> parameters SHOULD be appended following the
          request-specific parameters, properly separated by an <spanx style='verb'>&amp;</spanx>
          character (ASCII code 38).
        </t>
        <figure>
          <preamble>
            For example, the client makes the following HTTPS request:
          </preamble>
          <artwork>
            <![CDATA[
  POST /resource HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  oauth_token=vF9dft4qmT
]]>
          </artwork>
        </figure>
        <t>
          The resource server MUST validate the access token and ensure it has not expired and
          its scope includes the requested resource. If the resource expired or is not valid, the
          resource server MUST reply with an HTTP 401 status code (Unauthorized) and include the
          HTTP <spanx style='verb'>WWW-Authenticate</spanx> response header field as described in
          <xref target='authn_header' />.
        </t>
      </section>

    </section>

    <section title='The WWW-Authenticate Response Header Field' anchor='authn_header'>
      <t>
        Clients access protected resources after locating the appropriate end-user authorization
        endpoint and token endpoint and obtaining an access token. In many cases, interacting with a
        protected resource requires prior knowledge of the protected resource properties and
        methods, as well as its authentication requirements (i.e. establishing client identity,
        locating the end-user authorization and token endpoints).
      </t>
      <t>
        However, there are cases in which clients are unfamiliar with the protected resource,
        including whether the resource requires authentication. When clients attempt to access an
        unfamiliar protected resource without an access token, the resource server denies the
        request and informs the client of the required credentials using an HTTP authentication
        challenge.
      </t>
      <t>
        In addition, when receiving an invalid authenticated request, the resource server issues an
        authentication challenge including the error type and message.
      </t>

      <t>
        A resource server receiving a request for a protected resource without a valid access
        token MUST respond with a 401 (Unauthorized) or 403 (Forbidden) HTTP status code, and
        include at least one <spanx style='verb'>Token</spanx>
        <spanx style='verb'>WWW-Authenticate</spanx> response header field challenge.
      </t>
      <t>
        The <spanx style='verb'>WWW-Authenticate</spanx> header field uses the framework defined by
        <xref target='RFC2617' /> as follows:
      </t>
      <figure>
        <artwork>
          <![CDATA[
  challenge       = "Token" RWS token-challenge

  token-challenge = realm
                    [ CS error ]
                    [ CS 1#auth-param ]
                    
  error           = "error" "=" <"> token <">
]]>
        </artwork>
      </figure>

      <t>
        The <spanx style='verb'>realm</spanx> attribute is used to provide the protected
        resources partition as defined by <xref target='RFC2617' />.
      </t>
      <t>
        The <spanx style='verb'>error</spanx> attribute is used to inform the client the reason
        why an access request was declined. [[ Add list of error codes ]]
      </t>
    </section>

    <section title='Security Considerations'>
      <t>
        [[ todo ]]
      </t>
    </section>

    <section title='IANA Considerations'>
      <t>
        [[ Not Yet ]]
      </t>
    </section>

    <appendix title='Examples'>
      <t>
        [[ todo ]]
      </t>
    </appendix>

    <appendix title='Contributors'>
      <t>
        The following people contributed to preliminary versions of this document:
        Blaine Cook (BT), Brian Eaton (Google), Yaron Goland (Microsoft), Brent Goldman (Facebook),
        Raffi Krikorian (Twitter), Luke Shepard (Facebook), and Allen Tom (Yahoo!). The content and
        concepts within are a product of the OAuth community, WRAP community, and the OAuth Working
        Group.
      </t>
      <t>
        The OAuth Working Group has dozens of very active contributors who proposed ideas and
        wording for this document, including: [[ If your name is missing or you think someone
        should be added here, please send Eran a note - don't be shy ]]
      </t>
      <t>
        Michael Adams, Andrew Arnott, Dirk Balfanz, Brian Campbell, Leah Culver, Igor Faynberg,
        George Fletcher, Evan Gilbert, Justin Hart, John Kemp, Torsten Lodderstedt, Eve Maler,
        James Manger, Chuck Mortimore, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob Sayre,
        Marius Scurtescu, Justin Smith, and Franklin Tse.
      </t>
    </appendix>

    <appendix title='Acknowledgements'>
      <t>
        [[ Add OAuth 1.0a authors + WG contributors ]]
      </t>
    </appendix>

    <appendix title='Document History'>
      <t>
        [[ to be removed by RFC editor before publication as an RFC ]]
      </t>
      <t>
        -08

        <list style='symbols'>
          <t>
            Renamed verification code to authorization code.
          </t>
          <t>
            Revised terminology, structured section, added new terms.
          </t>
          <t>
            Changed flows to profiles and moved to introduction.
          </t>
          <t>
            Added support for access token rescoping.
          </t>
          <t>
            Cleaned up client credentials section.
          </t>
          <t>
            New introduction overview.
          </t>
          <t>
            Added error code for invalid username and password, and renamed error code to be more
            consistent.
          </t>
          <t>
            Added access grant type parameter to token endpoint.
          </t>
        </list>
      </t>
      <t>
        -07

        <list style='symbols'>
          <t>
            Major rewrite of entire document structure.
          </t>
          <t>
            Removed device profile.
          </t>
          <t>
            Added verification code support to user-agent flow.
          </t>
          <t>
            Removed multiple formats support, leaving JSON as the only format.
          </t>
          <t>
            Changed assertion <spanx style='verb'>assertion_format</spanx> parameter to
            <spanx style='verb'>assertion_type</spanx>.
          </t>
          <t>
            Removed <spanx style='verb'>type</spanx> parameter from token endpoint.
          </t>
        </list>
      </t>
      <t>
        -06

        <list style='symbols'>
          <t>
            Editorial changes, corrections, clarifications, etc.
          </t>
          <t>
            Removed conformance section.
          </t>
          <t>
            Moved authors section to contributors appendix.
          </t>
          <t>
            Added section on native applications.
          </t>
          <t>
            Changed error response to use the requested format. Added support for HTTP
            <spanx style='verb'>Accept</spanx> header.
          </t>
          <t>
            Flipped the order of the web server and user-agent flows.
          </t>
          <t>
            Renamed assertion flow <spanx style='verb'>format</spanx> parameter name to
            <spanx style='verb'>assertion_format</spanx> to resolve conflict.
          </t>
          <t>
            Removed the term identifier from token definitions. Added a cryptographic token
            definition.
          </t>
          <t>
            Added figure titles.
          </t>
          <t>
            Added server response 401 when client tried to authenticate using multiple credentials.
          </t>
          <t>
            Clarified support for TLS alternatives, and added requirement for TLS 1.2 support for
            token endpoint.
          </t>
          <t>
            Removed all signature and cryptography.
          </t>
          <t>
            Removed all discovery.
          </t>
          <t>
            Updated HTML4 reference.
          </t>
        </list>
      </t>
      <t>
        -05

        <list style='symbols'>
          <t>
            Corrected device example.
          </t>
          <t>
            Added client credentials parameters to the assertion flow as OPTIONAL.
          </t>
          <t>
            Added the ability to send client credentials using an HTTP authentication scheme.
          </t>
          <t>
            Initial text for the <spanx style='verb'>WWW-Authenticate</spanx> header (also added
            scope support).
          </t>
          <t>
            Change authorization endpoint to end-user endpoint.
          </t>
          <t>
            In the device flow, change the <spanx style='verb'>user_uri</spanx> parameter to
            <spanx style='verb'>verification_uri</spanx> to avoid confusion with the end-user
            endpoint.
          </t>
          <t>
            Add <spanx style='verb'>format</spanx> request parameter and support for XML and
            form-encoded responses.
          </t>
        </list>
      </t>
      <t>
        -04

        <list style='symbols'>
          <t>
            Changed all token endpoints to use <spanx style='verb'>POST</spanx>
          </t>
          <t>
            Clarified the authorization server's ability to issue a new refresh token when
            refreshing a token.
          </t>
          <t>
            Changed the flow categories to clarify the autonomous group.
          </t>
          <t>
            Changed client credentials language not to always be server-issued.
          </t>
          <t>
            Added a <spanx style='verb'>scope</spanx> response parameter.
          </t>
          <t>
            Fixed typos.
          </t>
          <t>
            Fixed broken document structure.
          </t>
        </list>
      </t>
      <t>
        -03

        <list style='symbols'>
          <t>
            Fixed typo in JSON error examples.
          </t>
          <t>
            Fixed general typos.
          </t>
          <t>
            Moved all flows sections up one level.
          </t>
        </list>
      </t>
      <t>
        -02

        <list style='symbols'>
          <t>
            Removed restriction on <spanx style='verb'>redirect_uri</spanx> including a query.
          </t>
          <t>
            Added <spanx style='verb'>scope</spanx> parameter.
          </t>
          <t>
            Initial proposal for a JSON-based token response format.
          </t>
        </list>
      </t>
      <t>
        -01

        <list style='symbols'>
          <t>
            Editorial changes based on feedback from Brian Eaton, Bill Keenan, and Chuck Mortimore.
          </t>
          <t>
            Changed device flow <spanx style='verb'>type</spanx> parameter values and switch to use
            only the token endpoint.
          </t>
        </list>
      </t>
      <t>
        -00

        <list style='symbols'>
          <t>
            Initial draft based on a combination of WRAP and OAuth 1.0a.
          </t>
        </list>
      </t>
    </appendix>

  </middle>

  <back>

    <references title='Normative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3023.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html401-19991224.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p1-messaging-09.xml'?>

      <reference anchor='NIST FIPS-180-3'>
        <front>
          <title>Secure Hash Standard (SHS). FIPS PUB 180-3, October 2008</title>
          <author>
            <organization>National Institute of Standards and Technology</organization>
          </author>
        </front>
        <format type='pdf' target='http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf' />
      </reference>

    </references>

    <references title='Informative References'>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-hammer-oauth-10.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-hardt-oauth-01.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml' ?>

    </references>

  </back>

</rfc>
