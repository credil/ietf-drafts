<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com)
     by Daniel M Kohn (private) -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc3986 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml'>
    <!ENTITY rfc4838 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4838.xml'>
    <!ENTITY rfc5050 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5050.xml'>
    <!ENTITY I-D.symington-dtnrg-bundle-metadata-block PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-symington-dtnrg-bundle-metadata-block-01'>
    <!ENTITY I-D.dtnrg-bundle-encapsulation PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.irtf-dtnrg-bundle-encapsulation.xml'>
    <!ENTITY I-D.irtf-dtnrg-bundle-security PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-irtf-dtnrg-bundle-security-05'>
    <!ENTITY ISO.9594-1.1988 PUBLIC ''
     'http://xml.resource.org/public/rfc/bibxml2/reference.ISO.9594-1.1988.xml'>
]>

<rfc category="exp" ipr="trust200902" docName="draft-pbasu-dtnrg-naming-00">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

<front>
  <title abbrev='Intentional Naming'>
    Intentional Naming in DTN
  </title>
  <author initials='P.' surname="Basu" fullname='Prithwish Basu'>
    <organization abbrev='BBN'>
      BBN Technologies
    </organization>
    <address>
      <postal>
	<street>10 Moulton Street</street>
	<city>Cambridge</city> <region>MA</region>
	<code>02138</code>
	<country>US</country>
      </postal>
      <phone>+1 617 873 7742</phone>
      <email>pbasu@bbn.com</email>
      <uri>http://www.ir.bbn.com/~pbasu/</uri>
    </address>
  </author>
  <author initials='D.' surname="Brown" fullname='Dan Brown'>
    <organization abbrev='BBN'>
    BBN Technologies
    </organization>
    <address>
      <postal>
	<street>10 Moulton Street</street>
	<city>Cambridge</city> <region>MA</region>
	<code>02138</code>
	<country>US</country>
      </postal>
      <phone>+1 617 873 7560</phone>
      <email>dbrown@bbn.com</email>
    </address>
  </author>
  <author initials='S.' surname="Polit" fullname='Stephen Polit'>
    <organization abbrev='BBN'>
    BBN Technologies
    </organization>
    <address>
      <postal>
	<street>10 Moulton Street</street>
	<city>Cambridge</city> <region>MA</region>
	<code>02138</code>
	<country>US</country>
      </postal>
      <phone>+1 617 873 2159</phone>
      <email>spolit@bbn.com</email>
     </address>
   </author>
   <author initials='R.' surname="Krishnan" fullname='Rajesh Krishnan'>
    <organization abbrev='SSCI'>
    Scientific Systems Company, Inc.
    </organization>
    <address>
      <email>krash@ieee.org</email>
    </address>
  </author>
  <date/>
  <abstract><t> This document describes an extension to the naming
  mechanism of disruption tolerant networks (RFC4838) to support
  intentional naming.  Intentional naming is a means by which a source
  node specifies the destination node(s) for a bundle in terms of
  predicates on attributes of the node(s), instead of by a canonical
  endpoint identifier (EID) of the node. Intentional naming is closely
  tied to the concept of binding, as described in RFC 4838. Since
  information required to route an intentionally named bundle may not
  be available at the source node, this information must be supplied
  at one or more subsequent nodes along the bundle's path toward its
  destination(s). The architecture required for an intentional naming
  capability in a DTN must support the notion that a bundle can make
  progress toward its destination(s) in the absence of complete
  binding information.  In this document we describe a framework for
  intentional naming in a DTN, propose a syntax for intentional names,
  and describe a distributed procedure for late or partial binding. We
  also present sample use cases for late binding and a notional name
  binding algorithm, called GRAIN, that can deliver bundles to
  intentional names with geographic and role attributes, e.g. “first
  responders within a kilometer of a specified location.”  Finally, we
  discuss the limitations in our current ability to field an ideal
  intentional naming system (i.e., one that can support generic
  intentional names), and we suggest a somewhat restrictive framework
  that is both useful and feasible to deploy.</t></abstract>
</front>

<middle>
  <section anchor="intro" title="Introduction">
    <t>
    Delay/Disruption-Tolerant Networking (DTN) is an architecture and
    a set of protocols that enable communication in environments with
    intermittent connectivity and long delays. An architecture for
    DTNs <xref target='RFC4838'/> and a bundle protocol <xref
    target='RFC5050'/> have been previously defined. This document
    describes a framework for intentional naming, an extension to the
    naming mechanism of DTNs.  In a DTN, nodes and services can
    appear, move, and disappear dynamically; not only is it impossible
    for a node to have complete information about the state of the
    names, addresses, and routes in the network, but the intended
    recipient of a bundle may not be part of the network—or even yet
    exist—when the bundle is created. Given such a flexible and
    dynamic network, it is valuable to be able to denote nodes in
    terms of attributes of the nodes, as well as by canonical DTN
    endpoint identifiers (EID). </t>
    
    <t>[This is not a new idea; for example X.500 naming <xref
    target='ISO.9594-1.1988'/> is expressed in terms of
    attribute-value pairs. Also, MIT’s Intentional Naming System has
    proposed similar ideas <xref target='INS'/>. However, the
    application of these ideas to DTNs is new.]</t>

    <t> We use the term "canonical EID of a DTN node" to refer to the
    EID of a bundle processing entity (typically a DTN routing module
    executing on that node) that is capable of receiving bundles
    addressed to that EID from other DTN nodes. Every DTN node is
    expected to possess a canonical EID.</t>

    <t> An intentional name <xref target='INS'/> is a name defined in
    terms of predicates on node attributes.</t>

    <t> Since intentional naming is so closely tied to the concept of
    binding, we will carefully define that and related concepts. For
    now we note a major difference between a DTN and a conventional
    (e.g. IPv4) network. In a conventional network, the work of
    mapping from a name to an address, and the process of routing a
    packet to that address, are separable. That is not typically
    possible in the dynamic environment of most DTNs. </t>
         
    <section title="Use Cases for Intentional Naming">
      <t> The following are some example use cases for intentional
      naming.
      <list style="numbers">
	<t> Addressing by heterogeneous network names. There are
	several namespaces currently in use in the public Internet as
	well as in other internets. These include the IP address space
	(IPv4 or IPv6), the DNS namespace, Email addresses, naming for
	non-IP based internets (telephone numbers, interplanetary
	internet, wireless sensor networks), and naming used by other
	commercial or military networks and overlays.

	Since DTN could be used for bridging heterogeneous networks, a
	sender may want to address a bundle to “the node with IPv6
	address A” even if the sender is not running an IPv6 stack or
	if a portion of the path to the destination is not an IPv6
	network.</t>

	<t> Location-based addressing. Destinations can be named in
	terms of spatial coordinates, e.g. (latitude, longitude,
	altitude). Resolving such a name may require nodes to be aware
	of both their own location and the location of other
	nodes. This form of addressing would be useful when notifying
	all users (via their nodes) in a region of an emergency, or
	for advertising a service available in a particular area.</t>

	<t> Descriptive location-based addressing. Names can be
	expressed in terms of physical addresses, or proximity to a
	well-known object or feature, e.g., “node at 10 Moulton
	Street, Cambridge, MA”, “node within 500 meters of bridge at
	(latitude, longitude)”. In addition to node location
	information, resolving such a name would require a
	geographical information system or other cartographic
	information. This name scheme would be useful like the
	previous example, but has the added advantage of using a
	descriptive name. </t>

	<t> Destination names can also be expressed in terms of
	membership in a group (“all soldiers that are members of
	Charlie company”) or some combination of a role and a location
	(“all first responders within one kilometer of (latitude,
	longitude)”, “all with rank lieutenant or higher in building
	17”). In order to resolve such names, access to group
	membership information, and knowledge of the military
	hierarchy is necessary.  If membership in a particular group
	implies the ability or function of performing a particular
	task, this naming scheme may be described as "role-based".</t>

	<t> Authorization based addressing. Names may be of the form
	“all personnel with Top Secret clearance.” Similar to
	role-based addressing, this example has additional
	implications for security. To resolve such a name we need
	access to security clearance or access control information at
	some point in the delivery process.</t>

	<t> Node-attribute based addressing. Names can be of the form
	“all nodes with more than 100GB of free storage”, “any node
	with SATCOM capability”, “node with temperature > 45 degrees
	C”, or “node with temperature > max safe operating
	temperature”. In order to resolve such names, we need access
	to information about the capabilities of the nodes. This
	naming scheme is similar to role-based naming, but instead of
	basing the delivery on the node owner’s role, delivery is
	based on the attributes of the node itself.  In each of these
	cases we want to deliver the bundle to a node that has
	particular attributes (location, temperature, authorization)
	without knowing the node’s canonical EID.</t>
      </list>
      </t>
    </section>
    
    <section title='Binding: Early and Late, Complete and Partial'>
      <t> We use the term binding as it is defined in RFC4838:
      "Binding means interpreting the SSP [scheme-specific part] of an
      EID for the purpose of carrying an associated message towards a
      destination."</t>

      <t> In an IP network binding occurs at two layers: i) the
      translation (using DNS) of a network name (e.g. yahoo.com) to an
      IP address, which is performed at the source node (The term
      early binding is often applied to this process.)  and ii) the
      translation at each hop (using ARP) of the next hop's IP address
      to a MAC address.  Both of these binding operations result in
      the encapsulation of the packet and moving to a lower layer of
      the network stack.  As noted above, these translation processes
      are completely separate from the routing processes (which occur
      at the next lower layers of the stack).  This type of binding
      occurs within a DTN as well, as bundles are conveyed across a
      convergence layer to a DTN neighbor. </t>

      <t> But intentional names (and other EIDs as well) may require
      additional information beyond the traditional cross-layer
      binding information (address) supplied to the lower layer
      router.  We want to provide routing information at successive
      hops that will be used by the DTN router to deliver the bundle.
      At some point the node-specific EID(s) of the destinations may
      be completely known.  At that time we say complete binding has
      occurred.  If that happens at the source we call it early
      binding.  If it occurs at a later node along the bundle's path,
      we call it late binding.  We anticipate that in many cases
      complete binding will never occur, and may frequently occur
      after a bundle is at (or within a single hop of) its final
      destination. </t>

      <t> Node attributes (such as roles, location, or sensed values)
      may change during the lifetime of a bundle, and the knowledge of
      these attributes may be highly distributed and not universally
      known.  Therefore, the nodes that match the intentional name
      predicate(s) may change during the bundle's lifetime.  We
      sometimes use the term "name resolution" as a synonym for "name
      binding". In order to route the bundle to its destination, we
      have to progressively resolve (i.e. provide routing information
      related to) the intentional name. When a node receives a bundle
      addressed to an intentional name, the node examines the
      intentional name, and uses its knowledge of the name to provide
      hints for DTN routing. This notion is referred to as partial
      resolution or partial binding. We use any portion of the
      intentional name from which we can extract routing information,
      record that information, and hand the bundle to a DTN router
      located on the node. As it is progressively determined, routing
      information will be recorded in the bundle's header (metadata
      extension block) and used by the DTN router. Frequently this
      information takes the form of next-hop nodes (sometimes called
      "care-of" nodes). The routing information provided at various
      nodes is intended to move the bundle "closer" to its final
      destination or to a node that can perform additional
      resolution. </t>
     
      <t> A key (and novel) benefit of late binding of intentional
      names in a DTN is persistent bundle delivery to descriptively
      named groups. Since DTN nodes persistently store and deliver
      information, bundles intended for recipients that match a
      description can be delivered to those recipients, even if the
      recipients did not satisfy the description at the time the
      bundle was created. For example, a node may transmit a bundle
      with a one-day expiration period, addressed to all nodes in a
      specified region (e.g. building or neighborhood); the bundle is
      delivered to all nodes in the region currently, as well as all
      nodes that enter the region during the next day (until the
      bundle expires).</t>

    </section>
    
    <section title='Organization of this Document'>
      <t>In the remainder of this document we describe the
      requirements and a framework for intentional name services in a
      DTN. We first discuss namespaces and ontologies, and motivate
      the degree of expressiveness needed for intentional names.  We
      discuss how name binding and routing of bundles will work
      together, and describe an architecture for achieving that. We
      then describe how intentional naming will integrate into the DTN
      architecture, and give an example (GRAIN) of a special type of
      intentional name and a resolution algorithm for such names which
      has been prototyped on the DTN reference implementation.  We
      conclude with an examination of some practical limitations to
      the successful deployment of an intentional naming capability in
      a DTN, and we suggest a more limited framework, whose deployment
      is both feasible and useful.
      </t>
    </section>
  </section>
  
  <section title="Expressiveness of Intentional Names">
    <t> Intentional naming provides a means of describing a
    destination whose name we do not [perhaps cannot] know.  It is,
    therefore, desirable for intentional names to be as expressive as
    possible, within the constraints of the system which implements
    them. As we argue below for greater expressiveness we should keep in
    mind the possible constraints that may eventually limit our
    choices.  We list a few of those below.
    <list style = "numbers">
      <t> Computational power. Expressiveness comes at the cost of
      computations.  DTN nodes with greater computational capability
      will be able to handle more expressive intentional names.  For a
      given name complexity, network nodes with adequate computational
      power must be present in sufficient numbers and locales. </t>

      <t> Storage. Nodes must be able to deal with potentially large
      amounts of data - often in a persistent manner [e.g. through
      loss of power]. </t>

      <t> Network capacity. Conveying information about intentional
      names will necessarily consume some of the network's capacity.
      Low capacity networks will have less capacity to devote for
      supporting intentional naming. Same is true for networks with
      large capacity and equally large data transmission demands.</t>

      <t> Routing complexity. Interpreting intentional names (binding)
      must be closely tied to the DTN routing strategy. All nodes must
      be able to support a routing strategy that is consistent with
      the complexity of the intentional name space. </t>

      <t> Locality of intentional naming information.  To the extent
      that information about intentional names is spread across a
      large network, more demands are placed on the DTN in all of the
      above areas - especially as it relates to scaling. </t>

      <t> Connectedness. Nodes in networks that are not well connected
      are less likely to be able to obtain useful binding information,
      or get to use it when available. </t>

      <t> Security and privacy. Complex intentional names may affect
      how we handle security issues.  And conversely, security
      considerations may constrain the domain of feasible intentional
      names. Some general privacy concerns include what nodes, etc,
      have the right to access the information needed to resolve an
      intentional name, how long is the information kept, how is it
      distributed etc.?</t>
    </list> </t>

    <t> With those concerns in mind, we now suggest the desire for a
    very expressive set of intentional names, while keeping in mind
    our likely need to be more restrictive when it comes time to think
    about deploying such a system.  We will discuss such tradeoffs
    when we define an implementation strategy for intentional
    naming. </t>

    <section title="Namespaces and Ontologies">
      <t>An ontology is a representation of a set of concepts within a
      domain and the relationships between those concepts. In terms of
      node names and descriptions, an ontology includes both the
      attributes that can be used to describe a node, the rules obeyed
      by those attributes, and the operations that can be performed on
      those attributes. An ontology is richer than a simple namespace
      — a node’s name is one of the attributes that can be part of an
      ontology. A node may have descriptions in multiple ontologies
      simultaneously; for example, a node may have IPv4, IPv6, and DNS
      names (attributes), as well as be described by a location
      ontology (which includes latitude, longitude, altitude
      attributes), and an ownership ontology (which might include the
      notions of individuals, corporations, and how a node might
      belong to a corporation and be assigned to an individual).  This
      leads us to the question of expressiveness; how powerful a naming
      system do we need?</t>
    </section>

    <section anchor='Expressive' title="Expressiveness of Names">
      <t>Our goal is for intentional names to be able to express both
      explicitly asserted attributes of a node (e.g. the node’s
      location), and derived attributes of the node (e.g. the distance
      between the node and a particular location). The syntax that we
      choose for intentional names, as well as the underlying name
      interpretation and matching algorithms we deploy, must be
      powerful enough to capture and manipulate these
      attributes. Examples of the kinds of attributes we envision
      include:</t>

      <t><list style="numbers">
	<t>Attributes and literal values: Using the examples above, we
	see that we would like to be able to specify that the
	destination node has an attribute (is-soldier), the attribute
	value matches a literal value (company == ’Charlie’), or holds
	a relationship to a literal value (temperature > 45 degrees
	C).</t>
	
	<t>Attribute relationships: In many cases it is valuable to be
	able to express relationships between attributes of node
	(e.g. "temperature > safe operating temperature", where the
	safe operating temperature itself is a node attribute and
	hence may differ from node to node).</t>

	<t>Term combinations: We want to be able to express
	conjunctions (“a AND b”), disjunctions (“a OR b”), and
	negation (“NOT c”) in intentional names.</t>
	
	<t>Derived or inferred attributes: At times we may wish to
	identify the destination(s) in terms of values derived or
	inferred from node attributes,
	e.g. within-distance-of(500m,BrooklynBridge). In order to
	determine whether this predicate is satisfied we need to know
	how to perform the derivation, either in terms of primitive
	operations available at each node
	(e.g. sqrt(sqr(my.x-bridge.x)+sqr(my.y-bridge.y))&lt;500), or
	in terms of predicates that are included in the ontology (an
	ontology that allows specification of location is likely to
	also include an operation for computing distance between
	locations).</t>

	<t>Groups of nodes with distributed attributes: One may want
	to summon a disaster relief team located nearest to the
	location of the disaster. Such a team may be composed of a
	fire-fighting unit, medical personnel, and police. A bundle
	addressed to the intentional “nearest disaster relief team”
	should reach the nearest available nodes in each class. This
	requires that the above relationship rules be captured in the
	appropriate ontology.</t>
	</list></t>

	<t>The above desiderata make it clear that, say, a simple
	string-matching scheme is insufficient for our needs, and that
	something richer is needed. We propose that an intentional
	name be described using fragments of a Horn clause <xref
	target='Horn'/> as used in logic programming. A Horn clause is
	of the form “term1 AND term2 AND … termK implies term”; here
	"term1", "term2", etc. constitute the body and "term"
	constitutes the head which is true if the body evaluates to
	true. Logic programming syntax used to represent Horn clauses
	is as follows: term :- term1, term2, ..., termK.</t>

	<t>A name (query) can be denoted by the head of a Horn clause
	which is a formula of the form "f(v1,v2,…,vK)"; or it could
	also be denoted by the body of a Horn clause, i.e., a formula
	which is a conjunction (AND) of logical terms, e.g.,
	"f(v1),g(v2,v3),h(v4)". Note that v1, v2, etc. may be
	literals, attributes, or other terms. Also, basic terms such
	as "X == 2" or "V > 4" are isomorphic to "equals(X,2)" and
	"greaterthan(V,4)".</t>

	<t>An ontology typically contains base facts denoted by single
	terms that capture relations between various attributes. Rules
	in an ontology will be denoted by Horn clauses.</t>

	<t>This structure is familiar to most programmers as well as
	sufficiently expressive for the intentional names we envision
	being used. Another advantage is that a Horn clause fragment
	can be expressed using a variety of syntactic forms, including
	an SQL-like query, a Prolog-like goal, a SPARQL query, and a
	C-like expression. We describe the exact name syntax in <xref
	target='Syntax'/>. </t>
      </section>

      <section title="Expressiveness of Ontology">
	<t>The expressiveness question applies to ontologies as well
	since they are responsible for expressing rules that encode
	the relationships between various concepts in the
	ontology. Simple examples of rules include:</t>

	<t><list style="symbols">

	  <t>A large cache is one which has maximum storage >
	  100GB. This can be encoded as the following rule:
	  largeCache(C) :- maxStorageGB(C,S), S>100.</t>

	  <t>X is near Y if they are not more than 100m apart and
	  there are no obstacles between them</t>

	  <t>A disaster relief team must contain fire fighters,
	  paramedics, and police.</t>

	  <t>A person ready to board a flight to Dallas will request
	  content about the weather there.</t>

	  <t>A local resident of a city is someone who has stayed in
	  that city for at least a year.</t>
	</list></t>

	<t>In general we intend to support the Description Logic (DL)
	subset of First Order Predicate Logic (FOPL) plus an added
	feature called Negation As Failure (NAF), which is a standard
	and useful feature in logic programming languages such as
	Prolog. NAF means that if a statement cannot be proved from
	the current knowledge base of facts (union of all knowledge
	bases in the network), then it must be false. This is the
	so-called closed world assumption.</t>
      </section>
      
    <section title="One, Any, All">
      <t>An intentional name may specify a singleton or a group,
      depending on how many reachable destinations meet the
      criteria. In such cases the sender of the bundle may wish to
      specify whether the bundle should be delivered to one, any, or
      all matching recipients. Hence, this is similar to the concept
      of minimum reception group (MRG) defined in <xref
      target='RFC4838'/> and <xref target='RFC5050'/>. We propose that
      the default behavior should be to deliver to all matching
      recipients (within bundle expiration time), and that the sender
      can override this behavior by adding a modifier to the
      intentional name.</t>

      <t>The following examples show the difference between one, any,
      and all, using notional syntax.</t>

      <t><list style="symbols">
	<t>one (president(BBN)): deliver the bundle to the current
	President of BBN. Once a copy of the bundle has been delivered
	to a particular node that meets the criteria, forwarding of
	the bundle can stop. Note that if a DTN routing protocol
	replicated the bundle prior to this delivery, copies of the
	bundle may be existing elsewhere in the network. Hence this
	semantics is to ensure certain local behavior.</t>

	<t>any (business == SushiBar AND within(1km,FenwayPark)):
	deliver the bundle to some (but not necessarily all) sushi
	bars within one kilometer of Fenway Park. The bundle should be
	forwarded to one or more nodes that meet the criteria. Similar
	to the previous example, once a bundle is delivered to a
	matching node, further forwarding should stop.</t>

	<t>all (business == SushiBar AND within(1km,FenwayPark)):
	deliver the bundle to all sushi bars within one kilometer of
	Fenway Park. The bundle should be forwarded to all nodes that
	meet the criteria. In this case, after delivering the bundle
	to a matching node, the resolution+routing algorithm may
	choose to continue forwarding it to other nodes in the
	network.</t>
      </list></t>

      <t>The first example brings up interesting questions about
      delivery semantics; the President of BBN can change over time
      and hence the delivery semantics here are that of ultimate late
      binding (i.e., if X is the current president of BBN and X
      receives the bundle, then delivery is legitimate. Also if Y was
      a president of BBN in the past when the bundle was sourced but
      is no longer the president when he receives the bundle, then Y
      is not a legitimate recipient of the bundle).</t>

      <t>Note that because bundles may be replicated in the network
      (to increase the likelihood of delivery) we cannot guarantee
      that only one copy of the bundle is delivered. The difference
      between any and one is, therefore, somewhat fuzzy. An
      intermediate node can stop forwarding an any-bundle after
      sending only one, and might forward multiple replicas of a
      bundle marked with a one-address.  In this way, one and any are
      in some sense advisory.</t>
    </section>
    
    <section title="Conflicts and Disambiguation">
      <t>In the examples above we implicitly used a number of
      different ontologies, including the IPv4 namespace, a namespace
      and ontology for location and distance, an ontology for
      temperature, and an ontology for an organization and ranks. When
      working with multiple namespaces, the issue of conflicts and
      disambiguation arises. There are at least three approaches we
      can take to handle attribute name conflicts:</t>

      <t><list style="symbols">
	<t>Enforced uniqueness: all attribute and predicate names are
	restricted to use no more than one ontology. This requires
	some sort of central authority managing the overall attribute
	and predicate namespace, e.g. ensuring that there is only one
	“rank” attribute defined across all ontologies.  In a closed
	network this might be workable, but as a DTN is, by
	definition, the union of multiple disparate networks, enforced
	uniqueness is not tenable.</t>

	<t>Implicit disambiguation: More like human language, an
	attribute or predicate name may be used in multiple
	ontologies, the only requirement being that it be clear from
	context how to interpret the attributes and predicates used in
	a name. Once again, this does not appear to be workable in a
	DTN. A geographic ontology might define location(latitude,
	longitude, altitude), and an organizational ontology might
	define location(campus, building, office), or define
	location() in terms of an individual’s position in the
	hierarchy.</t>

	<t>Explicit disambiguation: Each use of an attribute or
	predicate is explicitly linked to its ontology. This might be
	done in any number of ways, such as by prepending the name of
	the ontology to the rest of the name string, using a lexical
	scoping mechanism such as the following:
	geographic:within-distance(500m,location(-40.1,+30.7,0)) Here,
	the term “geographic” refers to the name of the geographic
	ontology that contains definitions of rules such as
	“within-distance”.  Given the above, we believe that explicit
	disambiguation is the best solution, and that is what we
	propose. (We will still need to disambiguate between ontology
	names, but this can be done using well-known techniques such
	as including the creator identity and timestamp in the
	ontology name).</t>
      </list></t>
    </section>
  </section>
  
  <section title="Binding of Intentional Names and Routing">

    <t>An intentional name is a description of a destination (which
    may be more than one node).  The goal of routing is to deliver a
    bundle to the destination.  For the router to do its job, it must
    be able to use the intentional name (more precisely the
    information derived from that name at this or previous nodes),
    along with other local information, to make an informed decision
    about how to forward the bundle.  Thus routing must be "in on the
    game" of intentional naming. The simplest solution appears to be
    the early binding case, wherein the source node identifies one or
    more canonical EIDs to which this bundle shall be sent.
    Typically, the relevant EIDs will be placed in the metadata
    extension block, and we assume the router will be able to deliver
    the bundle once it knows the EID. </t>

    <t> Curiously, it may not always be the case that completely
    resolved intentional names are easier to route than unresolved
    names.  Consider the case of a bundle headed for a node at a
    specific location (so described with an intentional name).  If I
    know recent locations of several network nodes, geographic routing
    [getting it to a closer location than me] may well be more
    feasible than routing based on a node name - especially if I
    haven't heard from that node recently. </t>

    <t> The resolution process is performed on each node by a system
    entity called a resolver.  The router and resolver must work
    together to determine the disposition of each bundle with an
    intentional name.  Under certain circumstances it may well be
    useful to complete a binding of an intentional name (to a
    canonical EID) to make the routing decision simpler. But, as we
    have seen above, it may not always be possible or useful to
    complete the binding at source.  How the router/resolver ought to
    treat an intentionally named bundle is, perhaps, the most
    complicated part of the intentional naming process.  And we will
    find that it drives most of the decisions about how to deploy an
    intentional naming system.  We list below several questions the
    router/resolver duo may need to address. </t>
    <t><list style="symbols">
      <t> Am I able to completely resolve this intentional name? </t>
      <t> Can I get the bundle closer to its destination(s) without
      performing a complete binding? [i.e. Can I use information
      already existing in the bundle header?]</t>
      <t> Can I partially resolve the name beyond what has already
      been accomplished at prior nodes? </t>
      <t> Can I send the bundle to a node that may be able to perform
      a complete or partial binding? [These are sometimes called
      care-of nodes]</t>
      <t> How expensive is each of the above operations? </t>
      <t> If more than one of the above are possible, which shall I
      do? </t>
      <t> What do I do if none of these options are available? </t>
    </list> </t>
    
    <t>What might it mean in practice to “partially resolve” a name?
    Consider the following scenario: a military commander wishes to
    send a message to some officer within a half-kilometer of the
    Harvard Bridge.  Using notional syntax, the name might be of the
    form rank=”Officer” and location=within(500m, ”Harvard Bridge
    (North)”) </t>
    
    <t>Since it is unlikely that the source will know the EID(s) of
    “officers” that satisfy the above location constraints, it is
    unlikely that we can perform early binding. [And, as we have
    noted, it may be unwise to do so.] Hence, In order to resolve the
    name we need to first determine the location of the north end of
    the Harvard Bridge, route the bundle to nodes within a
    half-kilometer of that location, and deliver the bundle to nodes
    belonging to officers. The initial resolution, of the geographic
    portion of the name, can be performed at any node with geographic
    information (e.g. the commander’s node, or a node in the command
    headquarters). This would result in a physical location, but still
    no canonical EIDs.  rank=”Officer” and location=within(500m,
    loc(42.356931,-71.092527))</t>

    <t>We would thus attempt to choose as the next hop a care-of node
    that was at or near the target location (or at least closer to the
    target location than we are). We consult a node location database
    and find that we have a link to a node close to the target, select
    that as the care-of node, and route the bundle there.</t>

    <t>In this example, the care-of node is within the target region
    and is in radio contact with all nodes in the region. It consults
    its node location database, finding all nodes within the
    region. It can then focus on resolving the first part of the
    intentional name, i.e., rank=”Officer”.</t>

    <t>The care-of node forwards the bundle to the target nodes. Each
    target node compares its rank (the rank of its owner) and either
    delivers or discards the bundle.</t>

    <t>Alternatively, nodes in the close vicinity of the care-of node
    may have shared their “rank” information with the latter (such
    information should be signed and encrypted by appropriate security
    keys). In this case, the care-of node can resolve the entire
    intentional name to the EIDs of a selected subset of nodes that
    shared their rank information earlier, specifically the ones with
    rank=”Officer”.</t>

    <t>In this way late binding, incremental resolution, and routing
    are interleaved.</t>

    <t>The goals of the proposed name resolution framework are in some
    ways similar to those of a wide-area peer-to-peer
    publish-subscribe system with the important additional requirement
    of disruption tolerance. Each node is both a publisher of, and
    subscriber to name binding information (i.e., name attributes and
    ontologies). The framework provides a distributed matching service
    that connects the subscribers to the publishers in a
    disruption-prone network environment. While several networking
    applications use the publish-subscribe paradigm at the application
    layer, we argue that this service should be available in the DTN
    network layer, i.e. alongside routing -- otherwise each
    intentional naming application would be expected to perform its
    own routing and therefore, potentially waste precious connectivity
    opportunities or network bandwidth for dissemination of redundant
    name binding information. If this service is supported in the
    network, then such dissemination can happen once and can be
    optimized for the DTN environment.</t>

    <section title="A Note on Tunneling">
      <t>Although the discussion above assumes that all nodes are
      participating in the intentional naming scheme, it is possible
      that not all nodes in a DTN will be capable of resolving
      intentional names or routing intentionally named bundles.</t>

      <t>In such a situation, a bundle may need to traverse several
      DTN hops from one resolver node to the next (and each DTN hop in
      turn may constitute several hops in the underlay
      networks). Routing of a bundle between two name resolvers that
      are not DTN-neighbors of each other can be achieved by
      tunneling, i.e. encapsulating the original user bundle in a
      control bundle that is de-capsulated once it reaches the next
      resolver node. Tunneling can be achieved by using the
      bundle-in-bundle encapsulation feature <xref
      target='I-D.irtf-dtnrg-bundle-encapsulation'/>. Tunneling is
      necessary in this scenario because the primary block of the
      bundle is immutable (otherwise it will fail the end-to-end
      security checks <xref
      target='I-D.irtf-dtnrg-bundle-security'/>), and hence there is
      no direct means of forcing the bundle to be routed to the next
      resolver EID without modifying the destination field of the
      bundle that stores the intentional name. But with the
      bundle-in-bundle feature, one can keep the original bundle
      unmodified and address the “envelope bundle” to the next
      resolver EID.</t>
    </section>
  </section>
  
  <section title="Architecture">
    <t>The previous section discusses how names may be resolved, and
    how bundles with intentionally-named destinations can be
    routed. In this section we discuss the architectural components
    and procedures followed by nodes participating in the intentional
    naming system.</t>

    <t>The major functional components of the architecture are:</t>
    <t><list style="symbols">
      <t> Name Knowledge Base Storage</t>
      <t> Knowledge Base Dissemination</t>
      <t> Resolution </t>
      <t> Routing [Although a DTN Router needs to be present even
      without intentional names, its function is greatly influenced by
      the design of the Intentional Naming System.] </t>
    </list> </t>

    <section title="Name Knowledge Base">
      <t>Each node maintains a knowledge base (KB) of ontology and
      attribute information. A KB can contain historical, current, and
      future information about bindings of intentional name attributes
      to locally registered application EIDs, or to remote care-of
      EIDs, or other intentional names.  The knowledge base can range
      from a simple look-up table, mapping intentional names to
      canonical EIDs of nodes capable of resolving names in that
      ontology, to a powerful deductive database engine (such as
      Prolog) that can infer complex derived attributes by execution
      of rules on base facts.</t>

      <t>Nodes with greater computational power and richer network
      connectivity [advantaged nodes] will be more successful at
      resolving names than resource-strapped and ill-connected
      nodes. Advantaged nodes are able to manage large name KBs and
      support high volumes of resolution queries; these nodes would
      reasonably be provisioned as gateways between different DTN
      networks. However, nodes with high computational power but with
      little connectivity (e.g., powerful notebook computers in a
      MANET) may also perform useful resolution tasks, serving as a
      resolver for nearby nodes.</t>

      <t>The range of possible knowledge base implementations is broad
      and is likely to be the subject of significant research and
      experimentation.  We offer the following features as the basis
      for an initial design:</t>

      <t><list style="numbers">
	<t>A simple lookup table mapping ontology names
	(e.g. geographic) to nodes that have advertised the
	corresponding ontology. When an ontology advertisement arrives
	it is inserted into the table. The node uses the table to
	determine where to forward bundles addressed to names
	described in that ontology.</t>
	
	<t>A lookup table mapping name attributes to canonical EIDs of
	nodes. The knowledge base can perform simple matches and
	comparisons to improve its forwarding (choice of care-of node)
	decisions. This mapping is possible if the corresponding
	ontology rules already reside on the current node.</t>
	
	<t>A deductive database that stores facts about name
	attributes as well as rules used for attribute
	derivation. This kind of KB can be used for table matching, as
	well as execute a potentially complex rule to infer the result
	from a given fact base.</t>
      </list> </t>

      <t>Note that the lookup tables may be simple in-memory
      structures, or backed by persistent relational databases,
      depending on the nature of the node and the requirements of the
      deployment. A deductive database might be implemented
      specifically for this application, or an existing inference
      engine (e.g. GNU Prolog, XSB <xref target='XSB'/>, Flora-2 <xref
      target='Flogic'/>) might be used.</t>
      
    </section>

    <section title="Dissemination">

      <t>Even though all rules in an ontology are well-known at a
      certain node, all base facts that are necessary for successful
      resolution may not be present in the local KB. Hence a
      dissemination scheme is required for distributing those facts in
      the DTN.</t>

      <t>A node that has the definition for an ontology advertises
      that fact (with appropriate version numbering and
      creation/modification times); other nodes can request a copy of
      the ontology definition, cache the fact that the ontology is
      available at the publisher node, or ignore the
      information. Nodes also publish their intentional name
      attributes, and forward along ontology advertisements and
      attributes provided to them.</t>

      <t>In certain application scenarios (especially involving highly
      disruptive networks) it may be desirable for a node to actually
      publish the ontology rules rather than just the fact that it
      possesses some specified version of the ontology rules. In this
      scenario, all nodes will cache the ontology rules and forward
      them to other nodes.</t>

      <t>We do not mandate a specific algorithm for attribute and
      ontology dissemination, although we believe that a
      geographically-bounded (or hop-count-bounded) epidemic
      dissemination will work well with the applications that we
      envision. See <xref target='Pred'/> for an example of such a
      technique.</t>

      <t>The specification of tools for the creation and management of
      attributes and ontologies is outside the scope of this document,
      although we describe (below) an API for use by such tools.</t>
    </section>

    <section title="Resolution">
      
      <t>Name resolution (also known as binding) is the process of
      mapping an intentional name to the canonical EIDs of one or more
      destination nodes, or to the canonical EIDs of one or more
      care-of nodes, or to another intentional name, or to some
      additional information that will help in the routing process.
      [Note that the notion of care-of and bundle custody transfer are
      orthogonal in principle, even though practical implementations
      may decide to tie them together.] </t>

      <t>This resolution process occurs as a result of a lookup into
      the local name knowledge base (either by a simple lookup into a
      file or an RDBMS, or by rule-based inference as mentioned
      earlier).</t>

      <t>The architecture also supports the possibility of remote
      resolution of names; a DTN node may query a remote DTN resolver
      node (e.g. if both nodes are in a well-connected component of
      the network) to determine the appropriate next care-of node, and
      then forward the bundle on.</t>

      <t> The results of the resolution process at a given node are
      typically added to the bundle's metadata extension block. </t>
    </section>

    <section title="Routing">
      <t> Routing in a DTN has been (and will continue to be) the
      subject of numerous investigations.  We note here that the
      inclusion of intentional names as legitimate bundle destinations
      places several requirements on the DTN routing functionality.
      In particular, the router must be able to identify and process
      the results of the resolution process performed on the current
      node and on prior nodes in the bundle's path.  Conversely, the
      capabilities of the DTN routers employed will place limits on
      the ability of the overall system to use intentional names.</t>
    </section>
    
  </section>

  <section title="Implementing Intentional Names on DTN">
    
    <t>We now detail our model for implementing intentional naming on
    DTN. The important points to cover are:</t>

    <t><list style="numbers">
      <t>What additional information will be stored in
      intentionally-named bundles, and where it will be stored.</t>
      
      <t>How routing will be affected.</t>
      
      <t>What new APIs will be needed.</t>
      
      <t>How applications will register for, submit, and receive,
      intentionally-named bundles.</t>
    
      <t>A syntax for intentional naming.</t>
    </list></t>

    <t>We have implemented the following in a prototype extension to
    DTN2, the DTNRG reference implementation. We note that the scope
    of this I-D does not address several issues of privacy, security,
    and trust.</t>

    <section anchor='MEB' title="Metadata Extension Block for Late Binding">

      <t>In the DTN Bundle Protocol, the destination field (of the
      primary block) is set when the bundle is created and not
      modified thereafter because the Bundle Security Protocol
      requires that the contents of the primary block not be changed
      en-route; otherwise, the bundle will fail end-to-end
      authentication checks. When a bundle is addressed to an
      intentional name, the intentional name is stored in the
      destination field that is immutable. However, as a bundle passes
      through the network, care-of nodes may wish to decorate the
      bundle with resolution information (up to and including the
      canonical EID of the destination). This information will be
      stored in a metadata extension block in the bundle. This
      metadata block will be included in the hop-by-hop authentication
      checks (e.g., mandatory BAB-HMAC ciphersuite as described in
      <xref target='I-D.irtf-dtnrg-bundle-security'/>) but not in the
      end-to-end checks (e.g., the mutable canonicalization scheme
      defined in <xref target='I-D.irtf-dtnrg-bundle-security'/>).</t>

      <t>Now we propose a metadata ontology for achieving progressive
      resolution and deferred binding. The metadata field in the
      extension block <xref
      target='I-D.symington-dtnrg-bundle-metadata-block'/> will have
      the following format:</t>
      
      <t><list style="numbers">
	<t>Next resolver EID (SDNV): The field denotes the node that
	the bundle will be sent to next. The binding algorithm is
	responsible for computing this and populating this field. This
	field could be empty as well.</t>
	
	<t>(optional) Flag denoting the current state of the bundle
	(SDNV): Currently the state indicates whether the bundle
	should be sent “point-to-point” (likely if the Next resolver
	EID field is non-empty) or should it be “flooded” (in this
	case, the Next resolver EID is likely to be empty)</t>
	
	<t>(optional) Flag denoting conditions for scoping the
	transmission of the bundle (SDNV): In simple situations this
	flag will contain a time-to-live value. In more advanced
	implementations, it could contain predicate expressions that
	can govern the spatial scope of transmission (e.g. to contain
	a flood).</t>
      </list></t>
	
      <t>Note that in the current version of the Internet-Draft, the
      metadata ontology information is assumed to be residing at every
      node that intends to participate in the deferred binding
      protocol. In future versions, we will address how such ontology
      information can be disseminated or updated on-the-fly, how
      access to such information will be controlled etc.</t>
    </section>
    
    <section title="Interaction with DTN Routing">
      
      <t>The steps for the interaction between routing and late
      binding modules are outlined in <xref target='dissfig'/> and
      <xref target='reslfig'/>. The first figure outlines the general
      process of dissemination of intentional name attributes and the
      second figure outlines the process of name resolution.</t>
      
      <t>In these figures, BPA refers to the core bundle protocol
      agent that is responsible for implementing the bundle protocol
      and the bundle security protocol. BPA interacts with other
      decision plane modules (Epidemic Router and Resolver),
      convergence layer adaptor (CLA), DTN applications (APP) and data
      storage (DS). These modules can be implemented as a single
      process or as separate processes that communicate using IPC.</t>

      <t>Dissemination: An application registers itself with the BPA
      as it normally would, adding intentional attributes and values
      (using the extended API discussed below); these attributes are
      installed in the local naming knowledge base. Attributes can
      also be received from the LB (late binding/intentional naming
      node) knowledge base of another node. It is also possible for
      the BPA to infer some of the attributes that are not specified
      by an application (e.g., location may be known to the BPA by
      other means) or determine them. Periodically, the state of this
      node’s KB is disseminated (using the epidemic router in our
      implementation) to other nodes. Note that we use the special EID
      "dtn:nbrcast" to denote all DTN neighbors of a particular node
      during the lifetime of the bundle.</t>
      
      <figure anchor="dissfig"
	      title="Steps in Dissemination of Intentional Name Attributes">
	<artwork><![CDATA[
              +---------+                4
              |   APP   |              +----+
              |         |              |    |
              +----+----+           +--+----v--+
                   |                |          |
                   | 1a       +-----+  Router  |
                   |          | 5   |          |
              +----v----+     |     +----^-----+
+-----+       |         <-----+          |
|  DS +-------+   BPA   |                |
+-----+       |         +-----+          | 3
              +----+----+     |          |
                   |          |     +----^-----+
                   | 6        | 1a  | Resolver |
                   |          | 1b  |    | 2   |
              +----v----+     |     |    <---+ |
              |         |     +---->|---+    | |
              |   CLA   |           | 1c|  +-+-+
              |         |           |   +->| KB|
              +---------+           +------+---+
		       ]]></artwork>
      </figure>

      <t><list style="empty">
	<t>(1a): APP Registration events</t>
	<t>(1b): Receive Link events or control data (from APP or
	remote LB)</t>
	<t>(1c): Update KB with received info</t>
	<t>(2): Extract/filter resolver state (S) to disseminate</t>
	<t>(3): RequestDissemination(S, dest: dtn:nbrcast)</t>
	<t>(4): Create bundle B(src=myEID, dest=dtn:nbrcast, payload=S)</t>
	<t>(5): RequestInjectBundle(B) on link L</t>
	<t>(6): Send bundle B on link L</t>
      </list></t>
      
      <t>Resolution: When a bundle arrives (in this figure, from a
      local application, although it could arrive from a remote node)
      it is first stored in the local data store (as are all bundles)
      and an EventBundleReceived event is triggered. This event is
      handled both by the local router and the resolver. The router
      directly queries the resolver and is returned one or more
      canonical EIDs for next-hop care-of nodes. The router determines
      the appropriate links to reach these nodes and requests that the
      bundle be sent to these nodes.</t>

      <t>Not pictured is the case where there are nodes that do not
      understand the intentional naming extension are located on the
      path between this node and a care-of node. In this case the
      bundle will be encapsulated (using bundle-in-bundle) and sent to
      the care-of node.</t>
 
      <figure anchor="reslfig"
	      title="Steps in the Resolution of an Intentional Name">
	<artwork><![CDATA[
              +---------+                6
              |   APP   |              +----+
              |         |              |    |
              +---^--+--+           +--+----v--+
                  |  |              |          |
               8a |  | 1      +-----+  Router  |
                  |  |        | 7a  |          |
              +---+--v--+     | 7b  +^--^---+--+
+-----+   2   |         <-----+      |  |   |
|  DS <-------+   BPA   |            |  |   |
+-----+       |         +-----+------+  | 5 | 4
              +----+----+     |         |   |
                   |          |     +---+---v--+
                   | 8b       | 3   | Resolver |
                   |          |     |    | 4a  |
              +----v----+     |     |    <---+ |
              |         |     +---->|        | |
              |   CLA   |           |      +-+-+
              |         |           |      | KB|
              +---------+           +------+---+
		       ]]></artwork>
      </figure>
      <t><list style="empty">
	<t>(1): Bundle B(dest: dtn:intent#...)</t>
	<t>(2): Store B persistently</t>
	<t>(3): EventBundleReceived(B, extension block MEB)</t> 
	<t>(4): Query local NameKB (dest, MEB)</t>
	<t>(4a) Result: canonical EID List C; app EID List A; MEB’</t>
	<t>(5): EventIntentionalNameResolved(C,A,MEB’)</t>
	<t>(6): Compute links {L} for reaching C</t>
	<t>(7a): DeliverBundleToApp(B,A)</t>
	<t>(7b): RequestSendBundle (B,L)</t>
	<t>(8a): Deliver bundle B to applications {A}</t>
	<t>(8b): Send bundle B on links {L}</t>
      </list></t>
      
    </section>

    <section title="New Interfaces">

      <t>The late binding API consists of the following parts:</t>

      <t>Methods for name resolution:</t>

      <t><list style="symbols">

	<t>Local resolution: this method queries the local name KB
	with the DTN EID in the bundle destination field and the LB
	metadata extension block in the bundle (as specified in <xref
	target='MEB'/>) as inputs. The query execution could be a
	simple database lookup or could invoke a more complex rule
	execution in a deductive database. If the query into the local
	KB returns a matching application EID registration then bundle
	delivery to that application is attempted. This process is
	referred to as application resolution.

	Since an intentional name could be bound to multiple DTN EIDs
	(multicast semantics), local resolution to a registered
	application may be inadequate. Therefore, if the name KB has
	additional intentional name to care-of EID bindings, the
	resolution query returns this list of care-of EIDs, and then
	the resolver populates the LB metadata extension block with
	these EIDs.</t>

	<t>Delivery to application: this method is used by the late
	binding module to request the BPA to deliver a bundle with an
	intentional name to a matching application registration. The
	matching is performed by the resolution component of the LB
	module.</t>

	<t>Remote resolution: these methods are for sending/receiving
	resolution requests and responses to/from a remote DTN node
	(since the process is asynchronous). Note that the local
	resolution API will be exercised at the remote resolver nodes
	before they send a resolution response to the requester.
	Methods for distributed name KB management:

	<list style="symbols">
	  
	  <t>Name update: this method is used by a DTN application to
	  register (or publish) its intentional name attributes to a
	  local name KB. Any subsequent changes to the name attributes
	  (such as locations, roles etc.) are also updated using this
	  API. This information is used by the local application
	  resolution procedure during name resolution.</t>

	  <t>Name KB dissemination: these methods are used by DTN
	  resolver nodes to send/receive portions of their name KBs
	  to/from other DTN resolver nodes. While in the most
	  primitive version, all records in the local name KB can be
	  packed in a bundle and disseminated to a remote resolver,
	  more advanced logic can be used to pack and send records
	  from the name KB selectively. This information is used by
	  the resolution module for mapping an intentionally named
	  bundle destination to a list of care-of EIDs in the
	  DTN. Conflict resolution or reconciliation at the remote
	  node is also an open topic and is domain specific.</t>

	</list></t>
      </list></t>
    </section>

    <section title="Application Delivery">

      <t>In the DTN late binding architecture, an application may
      register with the bundle protocol agent (BPA) with one or more
      intentional name attributes (e.g. role=Lieutenant). Any bundle
      with an intentional name query that matches these attributes
      should be delivered to this application. Normally, the BPA
      performs a simple lookup of the incoming bundle’s destination
      field in its registration table (this includes regular
      expression matches in the reference implementation). However, in
      the DTN late binding architecture, flat matches or even regular
      expression matches are insufficient for matching intentional
      names. Hence, the matching needs to be more general, since
      resolution rules in the name KB could map the incoming bundle
      destination EID to a specific application EID registered on this
      node. If such an event happens, the intentional naming module
      instructs the BPA to deliver the bundle to the appropriate
      application registration.</t>

    </section>

    <section anchor='Syntax' title="Syntax">

      <t>EIDs follow URI syntax (scheme:scheme-specific-part) <xref
      target='RFC3986'/><xref target='RFC5050'/>. The “dtn:” scheme
      has been provisionally registered with IANA. The scheme-specific
      part (SSP) of a DTN intentional name should be capable of
      denoting an individual DTN endpoint (node or a service) or a
      group of nodes, with potentially multiple attributes. In the
      scheme-specific-part, we propose qualifiers such as
      “intent:uni#”, “intent:any#”, and “intent:all#” for denoting
      unicast, anycast and multicast semantics respectively. The
      default is “intent#” which denotes multicast. Note that these
      semantics are in line with the semantics of the minimum
      reception group (MRG) for the respective cases defined in <xref
      target='RFC4838'/> and <xref target='RFC5050'/>.</t>

      <t>As an example, we first describe an ontology that denotes the
      space of descriptive names with location and role based
      attributes. The ontology has two attributes, role (a string
      literal) and location (an (x, y) pair) and a predicate, within,
      which takes two locations and a distance. (All ontologies have
      an EID attribute.)</t>

      <t>Using an SQL-like syntax, the node entries would look
      like</t>
      <t>create table node (EID string, role string, location
      xy_pair)</t>
      <t>insert into node (dtn://pbasu.bbn, researcher, (1, 3))</t>
      <t>insert into node (dtn://dunkin-donuts.cambridge, coffee, (3,
      47))</t>
      <t>insert into node (dtn://starbucks.cambridge, coffee, (0,
      50))</t>
      <t>insert into node (dtn://peets.cambridge, coffee, (-17,
      270))</t>
      
      <t>Assume we wish to communicate with all coffee houses within
      100 distance units of dtn://pbasu.bbn. (We have skipped units in
      these examples for reducing clutter.) This can be represented as
      a database query, which using SQL-like syntax, would look like
      the following:</t>
      <t>select EID from node where role=coffee and within(100, (1,3),
      location)</t>
      
      <t>Instead of an SQL-like syntax, we propose a Prolog-like
      syntax, in which attributes of the node are described as
      relationships. With this syntax, the facts would be in the
      form:</t>
      
      <t>role(dtn://pbasu.bbn, researcher), location(dtn://pbasu.bbn,
      (1,3))</t>

      <t>role(dtn://dunkin-donuts.cambridge,coffee),
      location(dtn://dunkin-donuts.cambridge,(3, 47))</t>

      <t>role(dtn://starbucks.cambridge, coffee),
      location(dtn://starbucks.cambridge, (0, 50))</t>

      <t>role(dtn://peets.cambridge, coffee),
      location(dtn://peets.cambridge, (-17, 270))</t>

      <t>Our query would then be expressed in the following way (using
      the Horn clause syntax proposed in <xref target='Expressive'/>):
      role(E,coffee),location(E,Loc),within(100,(1,3),Loc)</t>

      <t>This query amounts to finding some EID E where there is a
      fact (assertion) for role(E,coffee), there is a location
      (E,Loc), and the distance between Loc and (1,3) is less than
      100. Note that E denotes the mandatory variable in the
      intentional name whereas Loc is an internal variable which is
      necessary for specifying the desired rule. We express this fact
      by adding a question mark in front of the mandatory
      variable. Hence the actual intentional name that gets put in the
      destination field of the bundle looks like the following:</t>
      
      <t>dtn:intent#role(?E,coffee),location(?E,Loc),within(100,(1,3),Loc)</t>

    </section>
    
  </section>

  <section anchor='GRAIN' title="GRAIN: Gradient-Based Algorithm for Intentional Naming">

    <t>In this section we describe GRAIN, a Gradient-based Resolution
    Algorithm for Intentional Names, for resolving a class of
    intentional names and delivering bundles to those EIDs. We focus
    on name-queries for individuals or groups with certain roles
    located within a specified distance of a specified coordinate.</t>

    <t>In the following, we assume that all DTN nodes in the network
    are running a copy of GRAIN and they each have access to their
    current location information (e.g. via a GPS device). An
    intentional name query supported by GRAIN can have role, location,
    and distance attributes, e.g. company commanders (role) located
    within 1 km (distance) of 42.390501N, 71.147987W (location).</t>

    <t>GRAIN does not resolve the entire name at the source node;
    instead it performs progressive resolution as the bundle moves
    through the network to determine the ultimate destination
    endpoint(s). At the initial stages of resolution (near the source
    node), GRAIN uses the location attribute to determine one or more
    nodes closer to the eventual destination, and forwards the bundle
    to those nodes. This process continues until the bundle is within
    the region defined by the location and distance attributes. At
    that point, GRAIN begins using the balance of the attributes to
    determine how to route and deliver the bundle.</t>

    <t>A bundle can be in one of two states, STEM or FLOOD. In the
    STEM state, GRAIN routes the bundle toward the eventual
    destination while trying to use as few network resources as
    possible. When the bundle arrives within the circle defined by
    (location, distance), GRAIN switches the bundle’s state to FLOOD
    and is more liberal with the use of network resources.  When in
    FLOOD state the bundle is routed using predicate-scoped epidemic
    flooding, a variant of epidemic routing.</t>

    <t>Epidemic routing forwards a bundle to all nodes in the network
    eventually. In predicate-scoped epidemic flooding we want the
    bundle to eventually spread to nodes only located inside the
    (location, distance) circle and not those outside it. This
    constraint can be imposed by applying a predicate filter,
    "within(location, distance)", on all the forwarding paths
    determined by epidemic routing. The bundle is only forwarded to
    nodes that meet the predicate.</t>

    <t>In our implementation of GRAIN, routing is controlled by
    carrying the above state of the bundle in its metadata extension
    block (MEB).</t>

    <section title="Resolution and Routing Policies">

      <t>GRAIN supports three resolution and routing policies for
      progressive resolution:</t>
      
      <t>DTN-ROUTE: If this policy is enabled and active, then at the
      source node GRAIN determines the intermediate node closest to
      the target location. (This is possible because of the prior
      dissemination of location information, described below). The
      bundle is routed using a standard bundle routing protocol (such
      as APLS, described above). Once the bundle reaches the
      intermediate node, which is just outside the circle defined by
      (location, distance), its state is switched from STEM to FLOOD
      and it is flooded to nodes within the region by the use of
      predicate-scoped epidemic flooding (defined in <xref
      target='Pred'/>).  This ensures that we get full coverage within
      the region of interest while diminishing resource consumption to
      reach the region of interest.</t>

      <t>GEOGRAPHIC_NEAREST_NEIGHBOR: In order for DTN-ROUTE to work
      efficiently it needs up-to-date global node location
      information, which may not be readily available in disrupted
      networks. GEOGRAPHIC_NEAREST_NEIGHBOR uses local (rather than
      global) node location information to make
      resolution-plus-routing decisions. The source node resolves the
      geographic part of the intentional name to the canonical EID of
      the neighbor that is closest to the target location. GRAIN then
      forwards the bundle (using a standard bundle routing algorithm)
      to this neighbor and the resolution steps are repeated. Since
      all nodes are expected to have timely location updates from
      their neighbors, this policy is expected to make forward
      progress toward the target location until the state of the
      bundle changes to FLOOD. Subsequently, the same steps are taken
      to flood the bundle using predicate-scoping.</t>

      <t>GEOGRAPHIC_ALLNEARER_NEIGHBORS: While using minimal network
      resources in the STEM phase, the GEOGRAPHIC_NEAREST_NEIGHBOR
      policy is more prone to failure under the ordering of link
      availability events. For example, it is more likely that a
      bundle is forwarded to a neighbor that constitutes a local
      minima in the geographic routing protocol. To reduce the
      probability of this happening, and for making routing more
      robust under disconnection and mobility,
      GEOGRAPHIC_ALLNEARER_NEIGHBORS resolves the intentional name to
      a list of neighbors that are nearer to the destination. The
      bundle is then forwarded, using the epidemic routing algorithm,
      to only those neighbors. (Note that the epidemic routing
      protocol delivers a bundle to a node at most once.) These
      neighbors continue the resolution process, routing the bundle
      toward the destination, until the state of the bundle changes to
      FLOOD. The bundle forwarding path in this case looks like a
      union of paths rather than a single path as in the case of the
      previous policy. This policy works using just local information
      (unlike DTN-ROUTE), and is more robust under disruption than
      GEOGRAPHIC_NEAREST_NEIGHBOR, but consumes fewer resources than
      unconstrained epidemic flooding.</t>
      
    </section>

    <section title="Disseminating Location Information">  
      <t>In order for the above resolution schemes to work, location
      information needs to be shared among the nodes in the
      network. Under the DTN-ROUTE policy, each node periodically
      broadcasts a location update bundle to all nodes in the
      network. As the location update bundle spreads through the
      network, nodes update their databases with (location, canonical
      EID) pairs. GEOGRAPHIC_NEAREST_NEIGHBOR and
      GEOGRAPHIC_ALLNEARER_NEIGHBORS, the two policies involving
      geographic routing, only send location updates to immediate
      neighbors. This is because the resolution algorithms
      corresponding to those policies do not use any information
      beyond one hop location information.</t>
    </section>

    <section anchor='Pred' title="Predicate-scoped Epidemic Flooding">
      <t>Normally, epidemic routing spreads a bundle to all nodes in
      the network eventually. When the bundle is in the FLOOD state,
      i.e., inside the circle defined by (X,Y,D), we want the bundle
      to spread to nodes only located inside that circle and not
      outside. This can be achieved by applying a predicate filter for
      pruning the forwarding paths determined by epidemic routing, the
      predicate here being defined by “within(X,Y,D).” Since the
      vanilla version of epidemic routing does not have information
      about (X,Y,D), this is achieved by the late binding module. In
      other words, the latter performs a lookup into its name KB and
      returns only those canonical EIDs that satisfy the predicate
      “within(X,Y,D).” The epidemic router then merely forwards the
      bundle to the appropriate neighbors.  GRAIN supports three user
      selectable resolution/routing policies that help in progressive
      resolution. Numerous other policies are indeed possible, and
      these are provided as motivating examples for the need for a
      flexible naming system.</t>
    </section>
    
  </section>

  <section title="Deploying an Intentional Naming System">

    <t>In the previous sections we made an effort to define an
    Intentional Naming framework and architecture in the broadest
    possible manner, so that it might encompass the most flexible and
    potentially useful capabilities.  In those discussions we
    identified several research issues that require progress before a
    complete Intentional Naming System could be deployed.  In this
    section we identify specific issues that currently limit our
    ability to deploy an Intentional Naming System, and we describe a
    more restrictive set of capabilities that we believe will allow a
    practical yet useful Intentional Naming System to be deployed.
    </t>
    <t>The restrictions we adopt relate primarily to the expressiveness
    of intentional names, the locality of name binding information,
    and the scalability of the deployment. </t>
    
    <section title="Scalability">

      <t>The DTN environment presents several challenges for the
      scalability of name binding algorithms. First, sharing
      up-to-date resolution information in an often-disconnected or
      intermittently connected network in a scalable and timely
      fashion is challenging. The uncertainty about the currency and
      validity of resolution information typically grows
      proportionally with the distance between source and destination
      nodes, hence the probability of resolving to the correct set of
      nodes in a dynamic DTN will likely decrease with the distance
      between the source and the destination.</t>

      <t>In addition, descriptive intentional names are significantly
      richer than canonical DTN EIDs, hence the protocols need to
      scale not only with the size of the network but also with the
      size of the name-attribute space. Moreover an application
      registration may be dynamic, adding another dimension of
      complexity to the problem. Typically if a name-attribute space
      naturally lends itself to easy “aggregation” and there is a
      strong correlation between the distribution of node attributes
      and their topological location, it is more likely that we can
      develop scalable name binding algorithms. Examples include
      geographic attributes in our GRAIN algorithm, hierarchical IP
      addresses and DNS names, and static organizational
      hierarchies.</t>

      <t>In general, however, it may not be possible to aggregate
      attribute-value pairs for all namespaces. In particular, if the
      name is a conjunction of two relations or predicates, e.g.,
      "guardian(EID,S),student(S)", then the resolver nodes need to be
      able to perform a semi-join operation on the two relations
      "guardian" and "student". Since these two relations may be
      spatially distributed over the entire DTN and there is no
      location attribute in the name, performing this operation in a
      scalable manner under potential disruption is not simple. This
      is a topic for our future research.</t>
    </section>
    
    <section title="Expressiveness of Intentional Names - Revisited due
		    to Scalability Considerations">
    
      <t> In its most general form, an intentional name may include an
      arbitrary number of predicates which, together, will define the
      intended destination(s). We have presented examples of how such
      predicates may be bound to provide routing information which
      will assure bundle delivery. The presented examples do not,
      however, represent the most general case, and we now wish to
      make explicit what restrictions are necessary to assure
      reasonable name binding capability.</t>

      <t>We first motivate these with an example.  Consider an
      intentional name consisting of two predicates:
      <list style="symbols">
       <t> IS Army PFC </t>
       <t> HAS SPOUSE BORN IN New York </t>
      </list> </t>

      <t> We are addressing information to all PFCs who spouse was
      born in New York. </t>
 
      <t> Consider what types of information would be required to
      allow this bundle to get closer to the desired targets, and
      where that information might reside.  There may well be a
      database that identifies all PFCs. There is another that
      identifies all people born in New York. There are other
      databases that contain marriage (and divorce and death)
      information. Even if each of these databases was entirely
      contained in a single location (as opposed to being
      distributed); even if there were many replicas of each database,
      it would be very difficult to devise, on the fly, a strategy for
      assuring the bundle arrives at all [or even just one] desired
      destination(s). Decisions about what order to consider each of
      the predicates, how best to record intermediate results, and how
      to deal with databases that are [presumably temporarily]
      unreachable would have to be made at each hop. </t>

      <t> If we further consider the fact that one of these predicates
      may actually change over time, we see that this is a difficult
      problem indeed. But we could make the problem much simpler if we
      add an additional predicate to the intentional name:
      <list style="symbols">
	<t> IS WITHIN 100 yards of the Massachusetts State House </t>
      </list> </t>

      <t> Why does adding a condition simplify the binding operation?
      First, it greatly reduces the number of potential recipients.
      But replacing "New York" with "Edgartown" would also do that.
      What the new condition does is give us a strategy for moving the
      bundle along: Send the bundle closer and closer to the State
      House, and when you get near enough, just ask everyone to self
      assess whether they meet the conditions, or, perhaps, ask some
      local record keeper to provide information about nearby
      people. </t>

      <t> We generalize from this example by imposing the following
      two restrictions on the predicates we will allow in an
      intentional name:

      <list style="numbers">
	<t> One [and only one] of the predicates applies to an
	ontology that has either a well-defined distance function or a
	well-defined hierarchy and an end position [relative to
	distance or hierarchy].  This will be called the "primary
	ontology".  All routing information [the result of partial
	bindings] will be aimed at getting the bundle closer to the
	stated end position.</t>

	<t> Information regarding the truth of all other predicates
	must be more available the "closer" one gets to the stated end
	position.</t>
      </list></t>

      <t> The first of these allows routing progress to be made
      whenever a node is cognizant of the primary ontology.  The
      second assures that making progress with respect to that primary
      predicate will eventually result in additional information about
      the others.  The primary ontology/predicate will get the bundle
      to a neighborhood in which all other predicates can be
      evaluated.</t>

      <t> These are very severe restrictions.  But we believe they
      allow for a very useful subset of possible intentional names, as
      exemplified by the GRAIN example in <xref target='GRAIN'/> and
      <xref target='GrainPseudoCode'/>, which satisfies this
      restrictive property.</t>

      <t> Note that these restrictions by no means constitute
      necessary conditions for scalable name binding.</t>

    </section>

    <section title="Security Considerations">

      <t>A primary security issue here is that of a denial of service
      attack. This is because the intentional name in the bundle
      destination field with multicast and anycast semantics could be
      bound to large groups. So a user could construct an intentional
      name such that a bundle is flooded throughout the
      network. Moreover, the persistent nature of DTN and the deferred
      binding feature of late binding make the situation worse since
      the bundle stays in the network until it expires and it gets
      replicated (over space and time) to nodes that either satisfy
      the name attributes or can progressively resolve.</t>

      <t>Other security issues specifically pertaining to name
      resolution include:
      <list style="numbers">
	<t> How to ensure that the intentional name to canonical EID
	binding was created by a trusted party?</t>

	<t> How to ensure that the name binding information is being
	advertised and modified only by authorized nodes? </t> 

	<t> How to verify that a specific name indeed matches the
	intentional name?</t>
      </list>
      </t>

      <t>Other basic security concerns include confidentiality,
      authentication and integrity of intentional bundles. As long as
      the source of the bundle is a unique endpoint, it should be able
      to sign and encrypt the bundle and the mechanisms defined in the
      Bundle Security Protocol can be used to secure the intentionally
      named bundle. We leave this topic for future research.</t>
    </section>
  </section>

  <section title="Acknowledgments">
    <t>We thank DARPA DTN program for supporting this work (DARPA/ATO
    contract number W15P7T-05-C-P211). We also thank our BBN
    colleagues Partha Pal, Mitch Tasman, and Ram Ramanathan for
    contributing to the initial discussions on the late binding
    architecture. We thank Chris Small for his help toward making this
    document more readable.</t>
  </section>
</middle>

<back>
  <references title='Informative References'>

    <reference anchor='INS'>
      <front>
	<title>The design and implementation of an intentional naming
	system</title>
	<author initials="W." surname="Adjie-Winoto">
	  <organization>MIT</organization>
	</author>
	<author initials="E." surname="Schwartz">
	  <organization>MIT</organization>
	</author>
	<author initials="H." surname="Balakrishnan">
	  <organization>MIT</organization>
	</author>
	<author initials="J." surname="Lilley">
	  <organization>MIT</organization>
	</author>
	<date month='December' year='1999' />
      </front>
      <seriesInfo name='Proc. ACM SOSP' value='99' />
    </reference>
    
    &rfc3986;
    
    &rfc4838;

    <reference anchor='Flogic'>
      <front>
	<title>Logical Foundations of Object-Oriented and Frame-Based
	Languages system</title>
	<author initials="M." surname="Kifer">
	  <organization>SUNY Stony Brook</organization>
	</author>
	<author initials="G." surname="Lausen">
	  <organization>SUNY Stony Brook</organization>
	</author>
	<author initials="J." surname="Wu">
	  <organization>SUNY Stony Brook</organization>
	</author>
	<date month='May' year='1995' />
      </front>
      <seriesInfo name='Journal of the ACM' value='95' />
    </reference>

    <reference anchor='Horn'>
      <front>
	<title>On sentences which are true of direct unions of
	algebras.</title>
	<author initials="A." surname="Horn">
	  <organization></organization>
	</author>
	<date year='1951' />
      </front>
      <seriesInfo name='Journal of Symbolic Logic' value='16' />
    </reference>

    &rfc5050;

    &I-D.symington-dtnrg-bundle-metadata-block;

    &I-D.dtnrg-bundle-encapsulation;

    <reference anchor='XSB' target="http://xsb.sourceforge.net">
      <front>
	<title>XSB Logic Programming and Deductive Data Base
	System</title>
	<author><organization>SUNY Stony Brook</organization></author>
      </front>
    </reference>
	
    &ISO.9594-1.1988;

    &I-D.irtf-dtnrg-bundle-security;

  </references>

  <section anchor='GrainPseudoCode' title="GRAIN Pseudocode">

    <t>We present the pseudo-code for GRAIN, which provides deferred
    binding to an intentional name that possesses geographic and role
    attributes. This constitutes of the following components: (1)
    robust and efficient geographic routing to near the final
    destination; (2) predicate-scoped flooding to reach nodes that
    satisfy the location constraints in the name; and (3) delivery to
    all registered applications that satisfy both role and location
    constraints in the intentional name.</t>
    
    <t>Please note the following algorithmic details:</t>
    
    <t><list style="symbols">
      <t>The resolution/routing policy can be set to one of
      <list style="symbols">
	<t>DTN_ROUTE</t>
	<t>GEOGRAPHIC_NEAREST_NEIGHBOR</t>
	<t>GEOGRAPHIC_ALLNEARER_NEIGHBORS</t>
      </list>
      </t>
      
      <t>Bundles carry route_state, initialized to STEM;
      target_location, target_radius, and attributes (in this case, a
      set of roles).</t>
      
      <t>Each bundle carries a unique BundleID.</t>
      
      <t>When a bundle with an intentional name is submitted, the
      source node receives an event, INTENTIONAL_BUNDLE_RECEIVED.</t>
      
      <t>Intentional names contain three components: target_location,
      target_radius, attribute_set</t>
      
      <t>The algorithm uses a data structure, node_table, which holds
      information about nodes, locations, and links.</t>
      
      <t>The algorithm maintains an pending_bundle_table that holds
      pending bundles.</t>
      
      <t>The algorithm maintains an application_delivery_table listing
      bundles that have been delivered to each application.</t>
    </list></t>
    
    <section title="Main loop">
      <figure>
	<preamble>GRAIN’s main loop consists of:</preamble>
	<artwork><![CDATA[
loop forever:
  receive_message
  process_bundles
end loop
]]></artwork>
      </figure>
    </section>

    <section title="Message processing and state management">
      <figure>
	<preamble>This procedure is responsible for handling events
	as they come in, and managing GRAIN’s internal state. When a
	bundle arrives it is placed in the unresolved_bundle_table;
	bundle processing is handled in the following
	function.</preamble>
	<artwork><![CDATA[
procedure receive_message:
  accept message
  switch (message type)
    case LINK_AVAILABLE(Node:eid, Link:linkId):
      store (Node, Link) in node_table
    case LINK_UNAVAILABLE(Link:linkId):
      remove Link from node_table
    case LOCATION_DISSEMINATION(Node, loc):	
      store (Node, loc) in node_table
    case APPLICATION_REGISTRATION(A:eid):
      store (A.name, A.attribute_set) in application_table
    case APPLICATION_DEREGISTRATION(A:eid):
      remove A from application_table
    case INTENTIONAL_BUNDLE_RECEIVED(B:bundle):
      store B in unresolved_bundle_table
    case BUNDLE_EXPIRED(B:bundle):
      remove B from unresolved_bundle_table
  end switch
end procedure
]]></artwork>
      </figure>
    </section>

    <section title="Bundle processing">
      <figure>
	<preamble>We now describe how each pending bundle is
	processed. If appropriate, deliver a copy of the bundle to a
	local application. Then check to see if we should switch the
	bundle’s state from STEM to FLOOD. Last, we forward using
	the appropriate algorithm (STEM or FLOOD).</preamble>
	<artwork><![CDATA[
procedure process_bundles:
  for B in pending_bundle_table:
    deliver_locally_if_appropriate(B)
    change_from_stem_to_flood_if_appropriate(B)
    if bundle_route_state_metadata = STEM:
      do_stem_forwarding(B)
    else
      do_flood_forwarding(B)
    end if
  end for
end procedure
]]></artwork>
      </figure>
    </section>
    
    <section title="deliver_locally_if_appropriate">
      <figure>
	<preamble>If we are within the target radius, and there are any
	applications registered that match the other attributes
	present in the address, deliver the bundle to the
	application.</preamble>
	<artwork><![CDATA[	
procedure deliver_locally_if_appropriate(B)
  if dist(Me.location, B.target_location) < B.target_radius:
    for each application A in application_table:
      -- if the bundle has not yet been delivered, and matches
      -- the criteria for the application, deliver it 
      if (A.AppId, B.BundleId) not in application_delivery_table
          and B.attribute_set ⊆ A.attribute_set:
        deliver B to application A
        store (AppId, B.BundleId) in application_delivery table
      end if
    end for
  end if
end procedure
]]></artwork>
      </figure>
    </section>

    <section title="change_from_stem_to_flood_if_appropriate">
      <figure>
	<preamble>This procedure determines whether we can reach any
	nodes within the target region for the bundle. If so, we
	switch the bundle’s state to FLOOD so that from this point on
	the bundle will be flooded to all target nodes.</preamble>
	<artwork><![CDATA[
procedure change_from_stem_to_flood_if_appropriate(B)
  if B.route_state = STEM:
    for each Node in node_table:
      if dist(Node.location, B.target_location) < B.target_radius:
        B.route_state <- FLOOD
        return
      end if
    end for
  end if
end procedure
]]></artwork>
      </figure>
    </section>
    
    <section title="do_stem_forwarding">
      <figure>
	<preamble>This procedure is invoked when we are outside the
	target region, and we are working to move the bundle toward
	the target region.</preamble>
	<artwork><![CDATA[
procedure do_stem_forwarding(B)
  switch(B.routing_policy)
  case DTN_ROUTE
    forward B to known node closest to B.target_location
    remove B from unresolved_bundle_table
  case GEOGRAPHIC_NEAREST_NEIGHBOR:
    forward B to Nbr with smallest dist(Nbr, B.target_location)
    remove B from unresolved_bundle_table
  case GEOGRAPHIC_ALLNEARER_NEIGHBORS:
    for all Nbr where dist(Nbr, B.target_location) 
                       < dist(Me, B.target_location)
      forward B to Nbr
    -- Note: DO NOT remove B from unresolved_bundle_table
  end switch
end_procedure
]]></artwork>
      </figure>
    </section>

    <section title="do_flood_forwarding">
      <figure>
	<preamble>This procedure is invoked once we are within the
	target_radius for the bundle. We forward the bundle to all
	neighbors (nodes to which we have direct links) that are
	also within the target_radius.</preamble>
	<artwork><![CDATA[
procedure do_flood_forwarding(B):
  for each Node in node_table:
    if I have a direct link to Node
       and dist(Node.location, B.target_location) < B.target_radius:
      forward bundle B to Node
    end if
  end for
end_procedure
]]></artwork>
      </figure>
    </section>

    <section title="Location dissemination">
      <figure>
	<preamble>This procedure, which in a separate thread
	concurrently with the bundle processing main loop, is
	responsible for sharing/updating node location information
	with neighbors.</preamble>
	<artwork><![CDATA[
N <- delay between updates (typically 10 < N < 60)

if (routing_policy = DTN_ROUTE)
    broadcast my location to all nodes every N seconds
    forward any location update bundles I receive to all neighbors

else if (routing_policy = GEOGRAPHIC_ALLNEARER_NEIGHBORS || 
         routing_policy = GEOGRAPHIC_NEAREST_NEIGHBOR)
    send my location to all neighbors every N seconds
    do not forward location update bundles  to neighbors
end
]]></artwork>
      </figure>

    </section>
  </section>

</back>

</rfc>
