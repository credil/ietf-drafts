


SIPPING Working Group                                            V. Hilt
Internet-Draft                                                I. Widjaja
Expires: April 28, 2008                         Bell Labs/Alcatel-Lucent
                                                                D. Malas
                                                  Level 3 Communications
                                                          H. Schulzrinne
                                                     Columbia University
                                                        October 26, 2007


           Session Initiation Protocol (SIP) Overload Control
                     draft-hilt-sipping-overload-03

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on April 28, 2008.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   Overload occurs in Session Initiation Protocol (SIP) networks when
   SIP servers have insufficient resources to handle all SIP messages
   they receive.  Even though the SIP protocol provides a limited
   overload control mechanism through its 503 (Service Unavailable)



Hilt, et al.             Expires April 28, 2008                 [Page 1]

Internet-Draft              Overload Control                October 2007


   response code, SIP servers are still vulnerable to overload.  This
   document proposes new overload control mechanisms for SIP.


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  4
   3.  Design Considerations  . . . . . . . . . . . . . . . . . . . .  5
     3.1.  System Model . . . . . . . . . . . . . . . . . . . . . . .  5
     3.2.  Degree of Cooperation  . . . . . . . . . . . . . . . . . .  6
       3.2.1.  Local Overload Control . . . . . . . . . . . . . . . .  7
       3.2.2.  Hop-by-Hop . . . . . . . . . . . . . . . . . . . . . .  8
       3.2.3.  End-to-End . . . . . . . . . . . . . . . . . . . . . .  8
     3.3.  Topologies . . . . . . . . . . . . . . . . . . . . . . . .  9
     3.4.  Overload Control Method  . . . . . . . . . . . . . . . . . 11
       3.4.1.  Rate-based Overload Control  . . . . . . . . . . . . . 11
       3.4.2.  Loss-based Overload Control  . . . . . . . . . . . . . 12
       3.4.3.  Window-based Overload Control  . . . . . . . . . . . . 13
     3.5.  Overload Control Algorithms  . . . . . . . . . . . . . . . 14
     3.6.  Load Status  . . . . . . . . . . . . . . . . . . . . . . . 15
     3.7.  SIP Mechanism  . . . . . . . . . . . . . . . . . . . . . . 15
       3.7.1.  SIP Response Header  . . . . . . . . . . . . . . . . . 15
       3.7.2.  SIP Event Package  . . . . . . . . . . . . . . . . . . 16
     3.8.  Backwards Compatibility  . . . . . . . . . . . . . . . . . 17
     3.9.  Interaction with Local Overload Control  . . . . . . . . . 18
   4.  SIP Application Considerations . . . . . . . . . . . . . . . . 18
     4.1.  Responding to an Overload Indication . . . . . . . . . . . 18
     4.2.  Message Prioritization . . . . . . . . . . . . . . . . . . 18
     4.3.  Privacy Considerations . . . . . . . . . . . . . . . . . . 19
   5.  In-Band: 'Overload-Control' Header Field . . . . . . . . . . . 19
     5.1.  Generating the 'Overload-Control' Header . . . . . . . . . 19
     5.2.  Determining the 'Overload-Control' Header Value  . . . . . 21
     5.3.  Processing the 'Overload-Control' Header . . . . . . . . . 21
     5.4.  Using the 'Overload-Control' Header Value  . . . . . . . . 23
     5.5.  Rejecting Requests . . . . . . . . . . . . . . . . . . . . 23
     5.6.  Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . 24
   6.  Out-Of-Band: 'Overload-Control' Event Package  . . . . . . . . 25
     6.1.  Event Package Name . . . . . . . . . . . . . . . . . . . . 25
     6.2.  Event Package Parameters . . . . . . . . . . . . . . . . . 25
     6.3.  SUBSCRIBE Bodies . . . . . . . . . . . . . . . . . . . . . 25
     6.4.  Subscription Duration  . . . . . . . . . . . . . . . . . . 26
     6.5.  NOTIFY Bodies  . . . . . . . . . . . . . . . . . . . . . . 26
     6.6.  Subscriber generation of SUBSCRIBE requests  . . . . . . . 27
     6.7.  Notifier processing of SUBSCRIBE requests  . . . . . . . . 27
     6.8.  Notifier generation of NOTIFY requests . . . . . . . . . . 27
     6.9.  Subscriber processing of NOTIFY requests . . . . . . . . . 28
     6.10. Handling of forked requests  . . . . . . . . . . . . . . . 28



Hilt, et al.             Expires April 28, 2008                 [Page 2]

Internet-Draft              Overload Control                October 2007


     6.11. Rate of notifications  . . . . . . . . . . . . . . . . . . 28
     6.12. State Agents . . . . . . . . . . . . . . . . . . . . . . . 29
     6.13. Examples . . . . . . . . . . . . . . . . . . . . . . . . . 29
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 29
   8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 30
   Appendix A.  Acknowledgements  . . . . . . . . . . . . . . . . . . 30
   9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 31
     9.1.  Normative References . . . . . . . . . . . . . . . . . . . 31
     9.2.  Informative References . . . . . . . . . . . . . . . . . . 31
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 31
   Intellectual Property and Copyright Statements . . . . . . . . . . 33








































Hilt, et al.             Expires April 28, 2008                 [Page 3]

Internet-Draft              Overload Control                October 2007


1.  Introduction

   As with any network element, a Session Initiation Protocol (SIP) [2]
   server can suffer from overload when the number of SIP messages it
   receives exceeds the number of messages it can process.  Overload can
   pose a serious problem for a network of SIP servers.  During periods
   of overload, the throughput of a network of SIP servers can be
   significantly degraded.  In fact, overload may lead to a situation in
   which the throughput drops down to a small fraction of the original
   processing capacity.  This is often called congestion collapse.

   Overload is said to occur if a SIP server does not have sufficient
   resources to process all incoming SIP messages.  These resources may
   include CPU processing capacity, memory, network bandwidth, input/
   output, or disk resources.

   For overload control, we only consider failure cases where SIP
   servers are unable to process all SIP requests.  There are other
   cases where a SIP server can successfully process incoming requests
   but has to reject them due to other failure conditions.  For example,
   a PSTN gateway that runs out of trunk lines but still has plenty of
   capacity to process SIP messages should reject incoming INVITEs using
   a 488 (Not Acceptable Here) response [5].  Similarly, a SIP registrar
   that has lost connectivity to its registration database but is still
   capable of processing SIP messages should reject REGISTER requests
   with a 500 (Server Error) response [2].  Overload control does not
   apply to these cases and SIP provides response codes for them.

   The SIP protocol provides a limited mechanism for overload control
   through its 503 (Service Unavailable) response code.  However, this
   mechanism cannot prevent overload of a SIP server and it cannot
   prevent congestion collapse.  In fact, the use of the 503 (Service
   Unavailable) response code may cause traffic to oscillate and to
   shift between SIP servers and thereby worsen an overload condition.
   A detailed discussion of the SIP overload problem, the problems with
   the 503 (Service Unavailable) response code and the requirements for
   a SIP overload control mechanism can be found in [7].


2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].







Hilt, et al.             Expires April 28, 2008                 [Page 4]

Internet-Draft              Overload Control                October 2007


3.  Design Considerations

   This section discusses key design considerations for a SIP overload
   control mechanism.  The design goal for this mechanism is to enable a
   SIP server to control the amount of traffic it receives from its
   upstream neighbors.

3.1.  System Model

   The model shown in Figure 1 identifies fundamental components of an
   SIP overload control system:

   SIP Processor:  The SIP Processor processes SIP messages and is the
      component that is protected by overload control.
   Monitor:  The Monitor measures the current load of the SIP processor
      on the receiving entity.  It implements the mechanisms needed to
      determine the current usage of resources relevant for the SIP
      processor and reports load samples (S) to the Control Function.
   Control Function:  The Control Function implements the overload
      control mechanism on the receiving and sending entity.  The
      control function uses the load samples (S).  It determines if
      overload has occurred and a throttle (T) needs to be set to adjust
      the load sent to the SIP processor on the receiving entity.  The
      control function on the receiving entity sends load feedback (F)
      to the control function sending entity.
   Actuator:  The Actuator implements the algorithms needed to act on
      the throttles (T) and to adjust the amount of traffic forwarded to
      the receiving entity.  For example, a throttle may instruct the
      Actuator to reduce the traffic destined to the receiving entity by
      10%.  The algorithms in the Actuator then determine how the
      traffic reduction is achieved, e.g., by selecting the messages
      that will be affected and determining whether they are rejected or
      redirected.

   The type of feedback (F) conveyed from the receiving to the sending
   entity depends on the overload control method used (i.e., loss-based,
   rate-based or window-based overload control; see Section 3.4), the
   overload control algorithm Section 3.5 as well as other design
   parameters.  In any case, the feedback (F) enables the sending entity
   to adjust the amount of traffic forwarded to the receiving entity to
   a level that is acceptable to the receiving entity without causing
   overload.









Hilt, et al.             Expires April 28, 2008                 [Page 5]

Internet-Draft              Overload Control                October 2007


          Sending                Receiving
           Entity                  Entity
     +----------------+      +----------------+
     |    Server A    |      |    Server B    |
     |  +----------+  |      |  +----------+  |    -+
     |  | Control  |  |  F   |  | Control  |  |     |
     |  | Function |<-+------+--| Function |  |     |
     |  +----------+  |      |  +----------+  |     |
     |     T |        |      |       ^        |     | Overload
     |       v        |      |       | S      |     | Control
     |  +----------+  |      |  +----------+  |     |
     |  | Actuator |  |      |  | Monitor  |  |     |
     |  +----------+  |      |  +----------+  |     |
     |       |        |      |       ^        |    -+
     |       v        |      |       |        |    -+
     |  +----------+  |      |  +----------+  |     |
   <-+--|   SIP    |  |      |  |   SIP    |  |     |  SIP
   --+->|Processor |--+------+->|Processor |--+->   | System
     |  +----------+  |      |  +----------+  |     |
     +----------------+      +----------------+    -+


                Figure 1: System Model for Overload Control

3.2.  Degree of Cooperation

   A SIP request is often processed by more than one SIP server on its
   path to the destination.  Thus, a design choice for overload control
   involves the placement of overload control components (in particular
   the Monitor and Actuator) on the SIP servers on the path of a request
   and, consequently, the degree of cooperation between these SIP
   servers.  Overload control can be implemented locally (i.e., Monitor
   and Actuator on the same server), hop-by-hop (i.e., Monitor on a
   server and Actuator on its direct upstream neighbor), or end-to-end
   (i.e., Monitors on all SIP servers along the path of a request and
   one Actuator on the sender).  These configurations are show in
   Figure 2.














Hilt, et al.             Expires April 28, 2008                 [Page 6]

Internet-Draft              Overload Control                October 2007


                         +-+                    +---------+
                         v |           +------+ |         |
    +-+      +-+        +---+          |      | |        +---+
    v |      v |    //=>| C |          v      | v    //=>| C |
   +---+    +---+ //    +---+       +---+    +---+ //    +---+
   | A |===>| B |                   | A |===>| B |
   +---+    +---+ \\    +---+       +---+    +---+ \\    +---+
                    \\=>| D |                   ^    \\=>| D |
                        +---+                   |        +---+
                         ^ |                    |         |
                         +-+                    +---------+

           (a) local                      (b) hop-by-hop

      +-------+----------+
      |       ^          |
      |       |         +---+
      v       |     //=>| C |
   +---+    +---+ //    +---+
   | A |===>| B |
   +---+    +---+ \\    +---+
      ^       |     \\=>| D |
      |       |         +---+
      |       v          |
      +-------+----------+

         (c) end-to-end

    ==> SIP request flow
    <-- Overload feedback loop


              Figure 2: Degree of Cooperation between Servers

3.2.1.  Local Overload Control

   Servers can locally implement overload control mechanisms that do not
   require any cooperation with neighbor.  All overload control
   components (Monitor, Control Function, Actuator) reside on the same
   SIP element.  The goal of local overload control is to reject
   requests when overload occurs with minimal effort, i.e., before they
   are fully processed.  Since rejecting these messages requires less
   processing capacity than processing them, a server is able to
   gracefully reject excess messages instead of simply dropping them.
   However, once the number of incoming requests exceeds the server's
   capacity to reject them, the server will become overloaded.

   Local overload control does not require protocol support and is out



Hilt, et al.             Expires April 28, 2008                 [Page 7]

Internet-Draft              Overload Control                October 2007


   of scope for this document.

3.2.2.  Hop-by-Hop

   In the hop-by-hop model, a separate control loop is instantiated
   between all neighboring SIP servers that directly exchange traffic.
   I.e., the Actuator is located on the SIP server that is the direct
   upstream neighbor of the SIP server that has the corresponding
   Montitor.  This control loop is completely independent of the control
   loops between servers further up- or downstream.  In the example in
   Figure 2(b), three independent overload control loops are
   instantiated: A - B, B - C and B - D. Each loop only covers a single
   hop.  Overload feedback received from a downstream neighbor is
   therefore not forwarded further upstream.  Instead, a SIP server acts
   on this feedback, for example, by re-routing or rejecting traffic if
   needed.

   The upstream neighbor of a server instantiates a separate overload
   control loop with its upstream neighbors.  If the neighbor becomes
   overloaded, it will report this problem to its upstream neighbors,
   which again take action based on the reported feedback.  Thus, in
   hop-by-hop overload control, overload is always resolved by the
   direct upstream neighbors of the overloaded server without the need
   to involve entities that are located multiple SIP hops away.

   Hop-by-hop overload control reduces the impact of overload on a SIP
   network and, in particular, can avoid congestion collapse.  In
   addition, hop-by-hop overload control is simple and scales well to
   networks with many SIP entities.  It does not require a SIP entity to
   aggregate a large number of overload status values or keep track of
   the overload status of SIP servers it is not communicating with.

3.2.3.  End-to-End

   End-to-end overload control implements an overload control loop along
   the entire path of a SIP request, from UAC to UAS.  An end-to-end
   overload control mechanism needs to consider overload information
   from all SIP servers on the way, including all proxies and the UAS.
   It has to be able to frequently collect the overload status of all
   servers on the potential path(s) to a destination and combine this
   data into meaningful overload feedback.

   A UA or SIP server only needs to throttle requests if it knows that
   these requests will eventually be forwarded to an overloaded server.
   For example, if D is overloaded in Figure 2(c), A should only
   throttle requests it forwards to B when it knows that they will be
   forwarded to D. It should not throttle requests that will eventually
   be forwarded to C, since server C is not overloaded.  In many cases,



Hilt, et al.             Expires April 28, 2008                 [Page 8]

Internet-Draft              Overload Control                October 2007


   it is difficult for A to determine which requests will be routed to C
   and D since this depends on the local routing decision made by B.

   The main problem of end-to-end path overload control is its inherent
   complexity since a UAC or SIP server needs to monitor all potential
   paths to a destination in order to determine which requests should be
   throttled and which requests may be sent.  In addition, the routing
   decisions of a SIP server depend on local policy, which can be
   difficult to infer for an upstream neighbor.  Therefore, end-to-end
   overload control is likely to only work well in simple, well-known
   topologies (e.g., a server is known to only have one downstream
   neighbor) or if a UA/server sends many requests to the exact same
   destination.

3.3.  Topologies

   The following topologies describe four generic SIP server
   configurations, which each poses specific challenges for an overload
   control mechanism.

   In the "load balancer" configuration shown in Figure 3(a) a set of
   SIP servers (D, E and F) receives traffic from a single source A. A
   load balancer is a typical example for such a configuration.  In this
   configuration, overload control needs to prevent server A (i.e., the
   load balancer) from sending too much traffic to any of its downstream
   neighbors D, E and F. If one of the downstream neighbors becomes
   overloaded, A can direct traffic to the servers that still have
   capacity.  If one of the servers serves as a backup, it can be
   activated once one of the primary servers reaches overload.

   If A can reliably determine that D, E and F are its only downstream
   neighbors and all of them are in overload, it may choose to report
   overload to its upstream neighbor.  However, if the set of downstream
   neighbors is not fixed or only some of them are in overload then A
   cannot use overload control.  The reason is that A can still forward
   all requests destined to non-overloaded downstream neighbors.  These
   requests would be throttled as well if A would use overload control
   towards its upstream neighbors.  A should therefore reject the
   messages that are destined to its overloaded neighbors and would
   exceed their capacity as long as A is not overloaded itself.

   In the "multiple sources" configuration shown in Figure 3(b), a SIP
   server D receives traffic from multiple upstream sources A, B and C.
   Each of these sources can contribute a different amount of traffic,
   which can vary over time.  Sources may become inactive and previously
   inactive servers may start contributing traffic to D.

   If D becomes overloaded, it needs to generate feedback to reduce the



Hilt, et al.             Expires April 28, 2008                 [Page 9]

Internet-Draft              Overload Control                October 2007


   amount of traffic it receives from its upstream neighbors.  D needs
   to decide by how much each upstream neighbor should reduce traffic.
   This decision can require the consideration of the amount of traffic
   sent by each upstream neighbor and it may need to be re-adjusted as
   the traffic contributed by each upstream neighbor varies over time.

   An important goal for generating overload control feedback is to
   achieve fairness among requests sent from upstream neighbors.
   Fairness can be defined as each request that is routed to D having an
   equal chance of being processed.  However, a SIP server may also have
   a local policy that prefers some sources over others.  For example,
   it can throttle a less preferred upstream neighbor more or earlier
   than a preferred neighbor.

   In many configurations, SIP servers form a "mesh" as shown in
   Figure 3(c).  Here, multiple upstream servers A, B and C forward
   traffic to multiple alternative servers D and E. This configuration
   is a combination of the "load balancer" and "multiple sources"
   scenario.


                   +---+              +---+
                /->| D |              | A |-\
               /   +---+              +---+  \
              /                               \   +---+
       +---+-/     +---+              +---+    \->|   |
       | A |------>| E |              | B |------>| D |
       +---+-\     +---+              +---+    /->|   |
              \                               /   +---+
               \   +---+              +---+  /
                \->| F |              | C |-/
                   +---+              +---+

       (a) load balancer             (b) multiple sources

       +---+
       | A |---\                        a--\
       +---+=\  \---->+---+                 \
              \/----->| D |             b--\ \--->+---+
       +---+--/\  /-->+---+                 \---->|   |
       | B |    \/                      c-------->| D |
       +---+===\/\===>+---+                       |   |
               /\====>| E |            ...   /--->+---+
       +---+--/   /==>+---+                 /
       | C |=====/                      z--/
       +---+

             (c) mesh                   (d) edge proxy



Hilt, et al.             Expires April 28, 2008                [Page 10]

Internet-Draft              Overload Control                October 2007


                           Figure 3: Topologies

   Overload control that is based on lowering the number of messages
   contributed by a sender is not suited for servers that receive
   requests from a very large population of senders, each of which only
   infrequently sends a request.  This scenario is shown in Figure 3(d).
   An edge proxy that is connected to many UAs is a typical example for
   such a configuration.

   Since each UA typically only contributes a few requests, which are
   often related to the same call, it can't decrease its message rate to
   resolve the overload.  In such a configuration, a SIP server can
   resort to local overload control by rejecting a percentage of the
   requests it receives with 503 (Service Unavailable) responses.  Since
   there are many upstream neighbors that contribute to the overall
   load, sending 503 (Service Unavailable) to a fraction of them can
   gradually reduce load without entirely stopping all incoming traffic.
   Using 503 (Service Unavailable) towards individual sources can,
   however, not prevent overload if a large number of users places calls
   at the same time.

      OPEN ISSUE: The requirements of the "edge proxy" topology are
      different than the ones of the other topologies, which may require
      a different method for overload control.

3.4.  Overload Control Method

   The method used by an overload control mechanism to limit the amount
   of traffic forwarded to an element is an important aspect of the
   design.  We discuss the following three different types of overload
   control methods: rate-based, loss-based and window-based overload
   control.

3.4.1.  Rate-based Overload Control

   The key idea of rate-based overload control is to limit the request
   rate at which an upstream element is allowed to forward to the
   downstream neighbor.  If overload occurs, a SIP server instructs each
   upstream neighbor to send at most X requests per second.  Each
   upstream neighbor can be assigned a different rate cap.  The rate cap
   ensures that the number of requests received by a SIP server never
   increases beyond the sum of all rate caps granted to upstream
   neighbors.  It can protect a SIP server against overload even during
   load spikes if no new upstream neighbors start sending traffic.  New
   upstream neighbors need to be factored into the rate caps assigned as
   soon as they appear.  The current overall rate cap used by a SIP
   server is determined by an overload control algorithm, e.g., based on
   system load.



Hilt, et al.             Expires April 28, 2008                [Page 11]

Internet-Draft              Overload Control                October 2007


   An algorithm for the sending entity to implement a rate cap of a
   given number of requests per second X is request gapping.  After
   transmitting a request to a downstream neighbor, a server waits for
   1/X seconds before it transmits the next request to the same
   neighbor.  Requests that arrive during the waiting period are not
   forwarded and are either redirected, rejected or buffered.

   The main drawback of this mechanism is that it requires a SIP server
   to assign a certain rate cap to each of its upstream neighbors based
   on its overall capacity.  Effectively, a server assigns a share of
   its capacity to each upstream neighbor.  The server needs to ensure
   that the sum of all rate caps assigned to upstream neighbors is not
   (significantly) higher than its actual processing capacity.  This
   requires a SIP server to continuously evaluate the amount of load it
   receives from each upstream neighbor and assign a rate cap that is
   suitable for this neighbor without limiting it too much.  For
   example, in a non-overloaded situation, it could assign a rate cap
   that is 10% higher than the current number of requests received from
   this neighbor.  This rate cap needs to be adjusted if the number of
   requests generated by the upstream neighbor changes (e.g., the server
   wants to contribute a higher amount of traffic).  The cap also needs
   to be adjusted if a new upstream neighbors appears or an existing
   neighbor stops transmitting.  If the cap assigned to an upstream
   neighbor is too high, the server may still experience overload.
   However, if the cap is too low, the upstream neighbors will reject
   requests even though they could be processed by the server.  Thus,
   rate-based overload control is likely to work well only if the number
   of upstream servers is small and constant.

3.4.2.  Loss-based Overload Control

   A loss percentage enables a SIP server to ask an upstream neighbor to
   reduce the number of requests it would normally forward to this
   server by a percentage X. For example, a SIP server can ask an
   upstream neighbor to reduce the number of requests this neighbor
   would normally send by 10%.  The upstream neighbor then redirects or
   rejects X percent of the traffic that is destined for this server.
   The loss percentage is determined by an overload control algorithm,
   e.g., based on current system load.

   An algorithm for the sending entity to implement a loss percentage is
   to draw a random number between 1 and 100 for each request to be
   forwarded.  The request is not forwarded to the server if the random
   number is less than or equal to X.

   An advantage of loss-based overload control is that, the receiving
   entity does not need to track the request rate it receives from each
   upstream neighbor.  It is sufficient to monitor the overall system



Hilt, et al.             Expires April 28, 2008                [Page 12]

Internet-Draft              Overload Control                October 2007


   utilization.  To reduce load, a server can ask its upstream neighbors
   to lower the traffic forwarded by a certain percentage.  The server
   calculates this percentage by combining the loss percentage that is
   currently in use (i.e., the loss percentage the upstream neighbors
   are currently using when forwarding traffic), the current system
   utilization and the desired system utilization.  For example, if the
   server load approaches 90% and the current loss percentage is set to
   a 50% traffic reduction, then the server can decide to increase the
   loss percentage to 55% in order to get to a system utilization of
   80%.  Similarly, the server can lower the loss percentage if
   permitted by the system utilization.  This requires that system
   utilization can be accurately measured and that these measurements
   are reasonably stable.  Loss-based overload control achieves fairness
   among incoming requests if all upstream neighbors are throttled by
   the same percentage.  In this case, each request destined for an
   overloaded server has the same chance of being rejected by overload
   control.

   The main drawback of percentage throttling is that the throttle
   percentage needs to be adjusted to the current number of requests
   received by the server.  This is in particular important if the
   number of requests received fluctuates quickly.  For example, if a
   SIP server sets a throttle value of 10% at time t1 and the number of
   requests increases by 20% between time t1 and t2 (t1<t2), then the
   server will see an increase in traffic by 10% between time t1 and t2.
   This is even though all upstream neighbors have reduced traffic by
   10% as told.  Thus, percentage throttling requires an adjustment of
   the throttling percentage in response to the traffic received and may
   not always be able to prevent a server from encountering brief
   periods of overload in extreme cases.

3.4.3.  Window-based Overload Control

   The key idea of window-based overload control is to allow an entity
   to transmit a certain number of messages before it needs to receive a
   confirmation for the messages in transit.  Each sender maintains an
   overload window that limits the number of messages that can be in
   transit without being confirmed.

   Each sender maintains a unconfirmed message counter for each
   downstream neighbor it is communicating with.  For each message sent
   to the downstream neighbor, the counter is increased by one.  For
   each confirmation received, the counter is decreased by one.  The
   sender stops transmitting messages to the downstream neighbor when
   the unconfirmed message counter has reached the current window size.

   A crucial parameter for the performance of window-based overload
   control is the window size.  The windows size together with the



Hilt, et al.             Expires April 28, 2008                [Page 13]

Internet-Draft              Overload Control                October 2007


   round-trip time between sender and receiver determines the effective
   message rate that can be achieved.  Each sender has an initial window
   size it uses when first sending a request.  This window size can be
   changed based on the feedback it receives from the receiver.  The
   receiver can require a decrease in window size to throttle the sender
   or allow an increase to allow an increasing message rate.

   The sender adjusts its window size as soon as it receives the
   corresponding feedback from the receiver.  If the new window size is
   smaller than the current unconfirmed message counter, the sender
   stops transmitting messages until more messages are confirmed and the
   current unconfirmed message counter is less than the window size.

   A sender should not treat the reception of a 100 Trying response as
   an implicit confirmation for a message. 100 Trying responses are
   often created by a SIP server very early in the process and do not
   indicate that a message has been successfully processed and cleared
   from the input buffer.  If the downstream neighbor is a stateless
   proxy, it will not create 100 Trying responses at all and instead
   pass through 100 Trying responses created by the next stateful
   server.  Also, 100 Trying responses are typically only created for
   INVITE requests.  Explicit message confirmations in an overload
   feedback report do not have these problems.

   The behavior and issues of window-based overload control are similar
   to rate-based overload control, in that the total available receiver
   buffer space needs to be divided among all upstream neighbors.
   However, unlike rate-based overload control, window-based overload
   control can ensure that the receiver buffer does not overflow under
   normal conditions.  The transmission of messages by senders is
   effectively clocked by message confirmations received from the
   receiver.  A buffer overflow can occur if a large number of new
   upstream neighbors arrives at the same time.

3.5.  Overload Control Algorithms

   An important aspect of the design of overload control mechanism is
   the overload control algorithm.  The control algorithm determines
   when the amount of traffic a SIP server receives needs to be
   decreased and when it can be increased.

   Overload control algorithms have been studied to a large extent and
   many different overload control algorithms exist.  This specification
   does not mandate the use or implementation of a specific algorithm.
   However, algorithms that are used MUST be compliant with the
   semantics for overload feedback and the behavior for the upstream
   node defined in this specification.




Hilt, et al.             Expires April 28, 2008                [Page 14]

Internet-Draft              Overload Control                October 2007


      TODO: define a basline algorithm.
      OPEN ISSUE: In general, with many different overload control
      algorithms available, it seems reasonable to define a baseline
      algorithm and allow the use of other algorithms if they don't
      violate the protocol semantics.  This will also allow the
      development of future algorithms, which may lead to a better
      performance.

3.6.  Load Status

   It may be useful for a SIP server to frequently report its current
   load status to upstream neighbors.  The load status indicates to
   which degree the resources needed by a SIP server to process SIP
   messages are utilized.  An upstream neighbor can use load status to
   balance load between alternative SIP servers and to find under-
   utilized servers.  Reporting load is not intended to replace
   specialized load balancing mechanisms.

      OPEN ISSUE: reporting load status seems useful but somewhat
      orthogonal to overload control.  Reporting load has therefore been
      removed from the protocol definition below in this version of the
      draft.

3.7.  SIP Mechanism

   A SIP mechanism is needed to convey overload feedback from the
   receiving to the sending SIP entity.  A number of alternatives exist
   to implement such a mechanism.

3.7.1.  SIP Response Header

   Overload control information can be transmitted using a new SIP
   header field for overload control that is inserted into SIP
   responses.  A SIP server can add this header to the responses it is
   transmitting to inform its upstream neighbors about the current
   overload status.  Effectively, this implements an in-band signaling
   mechanism for overload control feedback.  A detailed description of
   this header is provided in Section 5.

   This approach has the following characteristics:

   o  A SIP response header is light-weight and creates very little
      overhead.  It does not require the transmission of additional
      messages for overload control and does not increase traffic in an
      overload situation.
   o  Overload control status can frequently be reported to upstream
      neighbors since it is a part of a SIP response.  This enables the
      use of this mechanism for control algorithms that update the



Hilt, et al.             Expires April 28, 2008                [Page 15]

Internet-Draft              Overload Control                October 2007


      control variable frequently, for loss-based overload control and
      for reporting non-static information such as the current load.
   o  With a response header, overload control status is inherent in SIP
      signaling and is automatically conveyed to all relevant upstream
      neighbors, i.e., neighbors that are currently contributing
      traffic.  There is no need for a SIP server to specifically track
      the set of current upstream or downstream neighbors with which it
      should exchange overload feedack.
   o  Overload status is not conveyed to inactive senders.  This avoids
      the transmission of overload feedback to inactive senders, which
      do not contribute traffic.  However, an inactive sender may start
      to transmit while the receiver is in overload.  In this case, the
      sender will receive overload feedback in the first response and
      can adjust the amount of traffic forwarded accordingly.
   o  A SIP server can limit the distribution of overload control
      information by only inserting it into responses to known upstream
      neighbors.  A SIP server can use transport level authentication
      (e.g., via TLS) with its upstream neighbors.

3.7.2.  SIP Event Package

   Overload control information can also be conveyed using a new event
   package.  The event package enables a sending entity to subscribe to
   the overload status of its downstream neighbors.  A sender creates a
   subscription to the overload status of a downstream neighbor and
   receives the current overload status in a NOTIFY request.  Downstream
   neighbors update the overload control status in subsequent NOTIFY
   requests.  The subscription is terminated when no traffic is
   exchanged any more between the two servers.  An event package
   implements an out-of-band transport for overload control information.
   A detailed description of this event package is provided in
   Section 6.

   This approach has the following characteristics:

   o  Since overload control information is conveyed outside of the SIP
      signaling flow, it is possible to decouple overload control from
      SIP signaling.  For example, it is possible to have a dedicated
      overload control manager that monitors the load on all servers in
      a server farm and provides overload control feedback to all SIP
      entities that are sending traffic to these servers.
   o  With an event package, a receiver can send updates to senders that
      are currently inactive.  Inactive senders will receive a
      notification about the overload and can refrain from sending
      traffic to this neighbor until the overload condition is resolved.
      The receiver can notify all potential senders once they are
      permitted to send traffic again.




Hilt, et al.             Expires April 28, 2008                [Page 16]

Internet-Draft              Overload Control                October 2007


   o  A SIP entity needs to set up and maintain subscriptions to
      overload control to all upstream and downstream neighbors.  A new
      subscription needs to be set up before/while a request is
      transmitted to a new downstream neighbor and subscriptions need to
      be terminated when they are not needed any more.
   o  A receiver needs to send NOTIFY messages to all upstream neighbors
      in a timely manner when the control algorithm requires a change in
      the control variable (e.g., when a SIP server is in an overload
      condition).  Depending on the number of neighbors, these NOTIFYs
      add to the amount of traffic that needs to be processed.  These
      requests can, however, be processed with high priority so that
      they will go through.
   o  A SIP server can limit the set of senders that can receive
      overload control information by authenticating subscriptions to
      this event package.
   o  This approach requires each proxy to implement a UAS/UAC to manage
      the subscriptions.

      OPEN ISSUE: We need to decide about the SIP mechanism for
      conveying overload control information.  Choosing a single
      transport mechanism might be beneficial for interoperability and
      simplicity purposes.  However, having two mechanisms (e.g., one
      for a closed network and one for SIP proxies receiving requests
      from many sources) might also be an alternative.  Section 5 and
      Section 6 provide details for the header and the event package
      alternative.

3.8.  Backwards Compatibility

   An new overload control mechanism needs to be backwards compatible so
   that it can be gradually introduced into a network and functions
   properly if only a fraction of the servers support it.

   Hop-by-hop overload control does not require that all SIP entities in
   a network support it.  It can be used effectively between two
   adjacent SIP servers if both servers support this extension and does
   not depend on the support from any other server or user agent.  The
   more SIP servers in a network support this mechanism, the more
   effective it is since it includes more of the servers in the overload
   reporting and offloading process.

   In topologies such as the ones depicted in Figure 3(b) and (c), a SIP
   server has multiple neighbors from which only some may support
   overload control.  If a server would simply use this extension for
   overload control, only those that support it would reduce traffic.
   Others would keep sending at the full rate and benefit from the
   throttling by other servers supporting this extension.  In other
   words, upstream neighbors that do not support overload control would



Hilt, et al.             Expires April 28, 2008                [Page 17]

Internet-Draft              Overload Control                October 2007


   be better off than those that do.

   A SIP server should therefore use 5xx responses towards upstream
   neighbors that do not support this specification.  The server should
   reject the same amount of requests with 5xx responses that would be
   otherwise be rejected/redirected by the upstream neighbor if it would
   support overload control.  For example, if the server has throttled
   traffic by 10%, it should reject 10% of the requests with a 5xx
   response for this neighbor.

3.9.  Interaction with Local Overload Control

   Local overload control can be used in conjunction with the mechanisms
   defined in this specification.  It provides an additional layer of
   protection against overload, for example, when upstream servers do
   not support overload control.  In general, servers should start using
   the mechanisms described here to throttle upstream neighbors before
   using local overload control to reject messages as a mechanism of
   last resort.


4.  SIP Application Considerations

4.1.  Responding to an Overload Indication

   An element may receive overload control feedback indicating that it
   needs to reduce the traffic it sends to its downstream neighbor.  An
   element can accomplish this task by sending some of the requests that
   would have gone to the overloaded element to a different destination.
   It needs to ensure, however, that this destination is not in overload
   and capable of processing the extra load.  An element can also buffer
   requests in the hope that the overload condition will resolve quickly
   and the requests still can be forwarded in time.  Finally, it can
   reject these requests.

4.2.  Message Prioritization

   Overload control can require a SIP server to prioritize messages and
   select messages that need to be rejected or redirected.  The
   selection is largely a matter of local policy.

   A SIP server SHOULD honor the Resource-Priority header field as
   defined in RFC4412 [5] if it is present in a SIP request.  The
   Resource-Priority header field enables a proxy to identify high-
   priority requests, such as emergency service requests, and preserve
   them as much as possible during times of overload.





Hilt, et al.             Expires April 28, 2008                [Page 18]

Internet-Draft              Overload Control                October 2007


4.3.  Privacy Considerations

   Providers can set up boundaries in their networks, which enforce
   topology hiding, header filtering and other functions.  These
   boundaries are often realized as proxies, back-to-back user agents
   (B2BUA), or session border controllers.  In the following we refer to
   these devices as border device.  A border device may have policies
   for disclosing overload control information based on location and
   level of privacy desired.

                                  |
         External                 |                 Internal
        +--------+           +---------+           +--------+
        | ProxyA +-----------+  B2BUA  +-----------+ ProxyB |
        +--------+           +---------+           +--------+
                                  |
                                  | domain border

           Figure 4: Example configuration for a boundary B2BUA

   It should be noted that changing overload control feedback can have a
   significant adverse effect on the overload control mechanism.  For
   example, the policy in a border device might be to remove overload
   control feedback until the feedback reaches a certain threshold.
   However, this intervention in the overload control feedback loop can
   cause an overload control algorithm to overreact, since the algorithm
   would not see any effects of the feedback generated.  Once the
   feedback passes through the filter, it would likely reduce traffic
   too much and causing the control algorithm to again steer into the
   opposite direction.  For this reason, it is NOT RECOMMENDED that a
   border device changes or partially removes overload control feedback.

   A SIP service provider may choose to remove all overload control
   information to the upstream external proxy.  This is NOT RECOMMENDED
   as it will disable protection against overload.


5.  In-Band: 'Overload-Control' Header Field

   This section defines a new SIP response header field for overload
   control, the 'Overload-Control' header.  This header provides an in-
   band SIP mechanism for conveying overload control information between
   SIP entities.

5.1.  Generating the 'Overload-Control' Header

   A SIP server can provide overload control feedback to its upstream
   neighbors by inserting a 'Overload-Control' header field into the SIP



Hilt, et al.             Expires April 28, 2008                [Page 19]

Internet-Draft              Overload Control                October 2007


   responses it is forwarding or creating.  The 'Overload-Control'
   header is a new header field defined in this specification.  The
   'Overload-Control' header can be inserted into all response types,
   including provisional, success and failure response types.

   A SIP server MAY insert an 'Overload-Control' header into all
   responses.  A SIP server MUST insert an 'Overload-Control' header
   into responses when overload control feedback is generated by the
   overload control algorithm to limit the traffic received by the
   server.  I.e. a SIP server MUST insert the 'Overload-Control' header
   when the overload control algorithm sets the 'Overload-Control'
   header to a value different from the default value.

   When using the 'Overload-Control' header, a SIP server can insert
   this header into every response.  A SIP server can also insert the
   header less frequently into responses, for example, once every x
   milliseconds.  This can be useful for SIP servers that receive a very
   high number of requests from the same upstream neighbor or if the
   overload control feedback has a very low variability and can be
   inserted with a large validity value.  In any case, a SIP server MUST
   insert an 'Overload-Control' header into a response well before the
   previous 'Overload-Control' header sent to the same upstream neighbor
   expires.

   The 'Overload-Control' header is only defined in SIP responses and
   MUST NOT be used in SIP requests.  The 'Overload-Control' header is
   only useful to the upstream neighbor of a SIP server (i.e., the
   entity that is sending requests to the SIP server) since this is the
   entity that can offload traffic by redirecting/rejecting new
   requests.  If requests are forwarded in both directions between two
   SIP servers (i.e., the roles of upstream/downstream neighbors
   change), there are also responses flowing in both directions.  Thus,
   both two SIP servers can exchange overload information.  While adding
   'Overload-Control' headers to requests may increase the frequency
   with which overload information is exchanged in these scenarios, this
   increase will rarely provide benefits and does not justify the added
   overhead and complexity needed.

   A SIP server MUST insert the address of its upstream neighbor into
   the "target" parameter of the 'Overload-Control' header.  It MUST use
   the address of the upstream neighbor found in the topmost Via header
   of the response for this purpose.

   The "target" parameter enables the receiver of a 'Overload-Control'
   header to determine if it should process the 'Overload-Control'
   header (since it was generated by its downstream neighbor) or if the
   'Overload-Control' header needs to be ignored (since it was passed
   along by an entity that does not support this extension).



Hilt, et al.             Expires April 28, 2008                [Page 20]

Internet-Draft              Overload Control                October 2007


   Effectively, the "target" parameter implements the hop-by-hop
   semantics and prevents the use of overload status information beyond
   the next hop.

      OPEN ISSUE: instead of using the address in the Via header it
      might make sense to use an application identifier similar to the
      one defined for SigComp [8].  This would also enable a SIP server
      to determine if the upstream neighbor supports this extension.

   A SIP server SHOULD add a "validity" parameter to the 'Overload-
   Control' header.  The "validity" parameter defines the time in
   milliseconds during which the information reported in the 'Overload-
   Control' header should be considered valid.  The default value of the
   "validity" parameter is 500.  A SIP server SHOULD use a shorter
   "validity" time if its overload status varies quickly and MAY use a
   longer "validity" time if this status is more stable.

   A SIP server MAY decide to add the 'Overload-Control' header field
   only to responses that are sent via a secured transport channel such
   as TLS.  The SIP server can use transport level authentication to
   identify the SIP servers, to which responses with the 'Overload-
   Control' header are sent.  This enables a SIP server to protect
   overload control information and ensure that it is only visible to
   trusted parties.  Since overload control protects a SIP server from
   overload, it is RECOMMENDED that a SIP server generally inserts
   'Overload-Control' headers into responses to all SIP servers.

5.2.  Determining the 'Overload-Control' Header Value

   The value of the 'Overload-Control' header specifies the percentage
   by which the load forwarded to this SIP server should be reduced.
   Possible values range from 0 (the traffic forwarded is reduced by 0%,
   i.e., all traffic is forwarded) to 100 (the traffic forwarded is
   reduced by 100%, i.e., no traffic forwarded).  The default value of
   this header field value is 0.  The 'Overload-Control' header value is
   determined by the overload control algorithm of the SIP server
   generating the 'Overload-Control' header.

      OPEN ISSUE: this value depends on the overload control method used
      (e.g., whether rate-based or window-based overload control is
      used).

5.3.  Processing the 'Overload-Control' Header

   A SIP entity compliant to this specification MUST remove all
   'Overload-Control' headers from the SIP messages it receives before
   forwarding the message.  A SIP entity may, of course, insert its own
   'Overload-Control' header into a SIP message.



Hilt, et al.             Expires April 28, 2008                [Page 21]

Internet-Draft              Overload Control                October 2007


   A SIP entity MUST ignore all 'Overload-Control' headers that were not
   addressed to it.  It MUST compare its own addresses with the address
   in the 'target' parameter of the 'Overload-Control' header.  If none
   of its addresses match, it MUST ignore the 'Overload-Control' header.
   This ensures that a SIP entity only processes 'Overload-Control'
   headers that were generated by its direct neighbors.

   A SIP server SHOULD store the information received in 'Overload-
   Control' headers from a downstream neighbor in a server overload-
   control table.  Each time a SIP server receives a response with an
   'Overload-Control' header from a downstream neighbor, it MUST
   overwrite the value it has stored for this neighbor with the one
   received.  Each entry in the server overload-control table has the
   following elements:

   o  Address of the server from which the 'Overload-Control' header was
      received.
   o  Time when the header was received.
   o  'Overload-Control' header value.
   o  Validity parameter value (default value if not present).

   A SIP entity SHOULD slowly fade out the contents of 'Overload-
   Control' headers that have exceeded their expiration time by
   additively decreasing the 'Overload-Control' header value until they
   reach zero.  This is achieved by using the following equation to
   access stored 'Overload-Control' header value.  Note that this
   equation is only used to access 'Overload-Control' header values.
   The result is not written back into the table.

      result = value - ((cur_t - rec_t) DIV validity) * 20

   If the result is negative, zero is used instead.  Value is the stored
   value of the 'Overload-Control' header.  Cur_t is the current time in
   milliseconds, rec_t is the time the 'Overload-Control' header was
   received.  Validity is the "validity" parameter value.  DIV is a
   function that returns the integer portion of a division.

   The idea behind this equation is to subtract 20 from the value for
   each validity period that has passed since the header was received.
   A value of 100, for example, will be reduced to 80 after the first
   validity period and it will be completely removed after 5 * validity
   milliseconds.

   A stored 'Overload-Control' header is removed from the table when the
   above equation returns zero for the 'Overload-Control' header value.






Hilt, et al.             Expires April 28, 2008                [Page 22]

Internet-Draft              Overload Control                October 2007


      OPEN ISSUE: fading out the 'Overload-Control' header value may not
      be necessary.  Instead this value can be removed when it expires.
      Fading out this value is helpful when a server has received an
      overload-control value from a downstream neighbor but does not
      send any traffic to this neighbor for some time.  By fading out
      the 'Overload-Control' header, this server would still consider
      the old value when resuming to send.  However, it might be
      reasonable to remove this value and simply allow the server to
      transmit since it will anyway use the up-to-date overload control
      feedback it receives in the first response.

5.4.  Using the 'Overload-Control' Header Value

   A SIP entity compliant to this specification MUST honor 'Overload-
   Control' header value when forwarding SIP messages to a downstream
   SIP server.

   A SIP entity applies the SIP procedures to determine the next hop SIP
   server as, e.g., described in [2] and [3].  After selecting the next
   hop server, the SIP entity MUST determine if it has a 'Overload-
   Control' header value for this server.  If it has a non-expired
   'Overload-Control' header value and this value is non-zero, the SIP
   server MUST determine if it can or cannot forward the current request
   within the current throttle conditions.

   The SIP server MAY use the following algorithm to determine if it can
   forward the request.  The SIP server draws a random number between 1
   and 100 for the current request.  If the random number is less than
   or equal to the 'Overload-Control' header value, the request is not
   forwarded.  Otherwise, the request if forwarded as usual.  Another
   algorithm for SIP entities that processes a large number of requests
   is to reject/redirect the first X of every 100 requests processed.
   Other algorithms that lead to the same result may be used as well.

   The treatment of SIP requests that cannot be forwarded to the
   selected SIP Server is a matter of local policy.  A SIP entity MAY
   try to find an alternative target or it MAY reject the request (see
   Section 5.5).

5.5.  Rejecting Requests

   A SIP server that rejects a request because of overload MUST reject
   this request with the 5xx response code defined for overload control
   (e.g., 503 (Service Unavailable) or 507 (Server Overload) [6]).  This
   response code indicates that the request did not succeed because the
   SIP servers processing the request are under overload.

   A SIP server may determine that an upstream neighbor does not support



Hilt, et al.             Expires April 28, 2008                [Page 23]

Internet-Draft              Overload Control                October 2007


   this extension.  If a SIP server is under overload, it SHOULD use 5xx
   responses to reject a fraction of requests from upstream neighbors
   that do not support this extension.  This fraction SHOULD be
   equivalent to the fraction of requests the upstream server would
   reject/redirect if it did support this extension.  This is to ensure
   that SIP entities, which do not support this extension, don't receive
   an unfair advantage over those that do.

   A SIP server that has reached overload (i.e., a load close to 100)
   SHOULD start using 5xx responses in addition to using the 'Overload-
   Control' header for all upstream neighbors.  If the proxy has reached
   a load close to 100, it needs to protect itself against overload.
   Also, it is likely that upstream proxies have ignored overload
   feedback and thus do not support this extension.

5.6.  Syntax

   This section defines the syntax of a new SIP response header, the
   'Overload-Control' header.  The 'Overload-Control' header field is
   used to provide overload control feedback from a SIP entity to its
   upstream neighbor.

   The 'Overload-Control' header contains a number between 0 and 100.
   It describes the percentage by which the traffic forwarded by
   "target" SIP entity to the SIP server generating this header should
   be reduced.  The default value for this header is 0.

   The 'target' parameter is mandatory and contains the URI of the next
   hop SIP entity for the response.  I.e., the SIP entity the response
   is forwarded to.  This is the entity that will process the 'Overload-
   Control' header.

   The 'validity' parameter is optional and contains an indication of
   how long the reporting proxy is likely to remain in the given
   overload status.

   The syntax of the 'Overload-Control' header field is:

     Overload-Control  = "Overload-Control" HCOLON ocStatus
     ocStatus          = 0-100 SEMI serverID *( SEMI ocParam )
     ocParam           = validMS | generic-param
     serverID          = "target" EQUAL SIP-URI | SIPS-URI
     validMS           = "validity" EQUAL delta-ms
     delta-ms          = 1*DIGIT

   The BNF for SIP-URI, SIPS-URI and generic-param is defined in [2].

   Table 1 extends the Tables 2 and 3 in [2].



Hilt, et al.             Expires April 28, 2008                [Page 24]

Internet-Draft              Overload Control                October 2007


     Header field       where   proxy ACK BYE CAN INV OPT REG
     ________________________________________________________
     Overload-Control     r      ard   -   o   o   o   o   o

     Header field       where   proxy NOT PRA SUB UPD MSG REF PUB
     ____________________________________________________________
     Overload-Control     r      ard   o   o   o   o   o   o   o
                    Table 1: 'Overload-Control' Header Field

   Example:

      Overload-Control: 20;target=p1.example.com;validity=500


6.  Out-Of-Band: 'Overload-Control' Event Package

   This section defines a new SIP event package for overload control.
   This event package provides a SIP mechanism for conveying overload
   control information out of band between SIP entities.

   The following sections provide the details for defining a SIP event
   package as required by RFC 3265 [4].

6.1.  Event Package Name

   The name of this event package is "overload-control".  This package
   name is carried in the Event and Allow-Events header fields, as
   defined in RFC 3265 [4].

6.2.  Event Package Parameters

   No package specific Event header field parameters are defined for
   this event package.

6.3.  SUBSCRIBE Bodies

   A SUBSCRIBE request for overload control information MAY contain a
   body.  This body would serve the purpose of filtering the overload
   control subscription.  The definition of such a body is outside the
   scope of this specification.  For example, the body might provide a
   threshold for reporting overload control information or it might
   indicate that overload control information should be reported as a
   loss-percentage or a request rate.

   A SUBSCRIBE request for the overload control package MAY be sent
   without a body.  This implies that the default subscription filtering
   policy as described in Section 6.8 has been requested.




Hilt, et al.             Expires April 28, 2008                [Page 25]

Internet-Draft              Overload Control                October 2007


6.4.  Subscription Duration

   A subscription to the overload control event package is usually
   established when a SIP server first sends a request to another SIP
   server and terminated when this server stops sending requests and
   overload control is not needed any more.

   The duration of a subscription is related to the time a signaling
   relationship exists between two servers.  In a static SIP server
   configuration (e.g., two SIP servers are configured to exchange
   messages in a service provider's network) this relationship can last
   for days or weeks as long as both servers are running.  In this
   scenario, the subscription duration is largely irrelevant.

   In a dynamic configuration (e.g., two SIP servers in different
   domains) the duration of the signaling relationship can be in the
   range of minutes or hours and might only last for the duration of a
   single session.  Since it is unknown a priori when the next SIP
   request will be transmitted from the subscriber to the notifier,
   subscriber and notifier MAY terminate a subscription to overload
   control after a period of inactivity.

   The duration of a subscription to the overload control event package
   SHOULD be longer than the duration of a typical session.  The default
   subscription duration for this event package is set to two hours.

6.5.  NOTIFY Bodies

   In this event package, the body of a notification contains the
   current overload status of the notifier.

   All subscribers and notifiers MUST support the format application/
   overload-info+xml.  The SUBSCRIBE request MAY contain an Accept
   header field.  If no such header field is present, it has a default
   value of application/overload-info+xml.  If the header field is
   present, it MUST include application/overload-info+xml, and MAY
   include any other MIME type capable of representing overload status
   information.  As defined in RFC 3265 [4], the body of notifications
   MUST be in one of the formats defined in the Accept header of the
   SUBSCRIBE request or in the default format.

      TBD: An document format for the above placeholder application/
      overload-info+xml needs to be defined.  The following document
      snippet is an example for such a format:

       <overload-control>
         <rate-limit>200</rate-limit>
       </overload-control>



Hilt, et al.             Expires April 28, 2008                [Page 26]

Internet-Draft              Overload Control                October 2007


6.6.  Subscriber generation of SUBSCRIBE requests

   The subscriber follows the general rules for generating SUBSCRIBE
   requests defined in RFC 3265 [4].

6.7.  Notifier processing of SUBSCRIBE requests

   It is RECOMMENDED that a notifier provides overload control status
   information to all subscribers and that the notifier accepts all
   subscriptions to this event package.  By denying a subscription to
   overload control, a notifier would disable overload control to this
   subscriber.  Since this subscriber would not know the current
   overload status of the notifier, it would not reduce the traffic
   forwarded when the notifier enters an overload condition.  Thus,
   denying a subscription to this event package can leave the notifier
   vulnerable to SIP overload.

   A notifier MAY authenticate and authorize subscriptions to this event
   package.  This is useful if the notifier wants to provide extended
   overload status information to certain subscribers.  For example, a
   notifier can provide detailed resource usage information to
   authenticated subscribers and only provide the current throttle
   status to all other subscribers.  The details of the authorization
   policy are at the discretion of the administrator.

6.8.  Notifier generation of NOTIFY requests

   A notifier sends a notification in response to SUBSCRIBE requests as
   defined in RFC 3265 [4].  In addition, a notifier MAY send a
   notification at any time during the subscription.  Typically, the
   notifier will send a notification every time the overload control
   status has changed.  For example, the notifier can create a notify
   every time the overload control value (e.g., the rate limit) changes.

   Overload status information is expressed in the format negotiated for
   the NOTIFY body (e.g., "application/overload-info+xml").  The
   overload status in a NOTIFY body MUST be complete.  Notifications
   that contain the deltas to previous overload status or a partial
   overload status are not supported in this event package.

   It is RECOMMENDED that the notifier returns an initial NOTIFY that
   contains at least the current overload control value immediately
   after receiving a SUBSCRIBE request.  It is RECOMMENDED that the
   notifier returns such an initial NOTIFY even if the notifier is still
   waiting for an authorization decision.  Once the subscription is
   authorized, the notifier MAY send another notification that then
   contains all information the subscriber is authorized to receive.  It
   is RECOMMENDED that the notifier accepts a subscription and creates a



Hilt, et al.             Expires April 28, 2008                [Page 27]

Internet-Draft              Overload Control                October 2007


   NOTIFY with at least the current overload control value even if the
   subscriber is not authorized to receive more information.

   The timely delivery of overload control notifications is important
   for overload control.  It is therefore RECOMMENDED that NOTIFY
   messages for this event package are sent with highest priority.
   I.e., the transmission of NOTIFY messages for this event package
   ought not to be delayed by other tasks.

6.9.  Subscriber processing of NOTIFY requests

   A subscriber MUST use the overload control state contained in a
   NOTIFY body and apply this state to all subsequent SIP messages it is
   intending to send to the respective SIP server.  The subscriber MUST
   NOT forward a higher number of SIP messages to the server than
   allowed by the current overload control state.  Details of how to
   apply overload control are discussed in Section 3.4

   A subscriber MUST use the overload state it has received for a SIP
   server until the subscriber receives another NOTIFY with an updated
   state or until the subscription is terminated.  The subscriber SHOULD
   stop using the reported overload state once the subscription is
   terminated.

   It is RECOMMENDED that the subscriber processes incoming NOTIFY
   messages for this event package with highest priority.  I.e., NOTIFY
   messages for this event package ought to be processed before other
   messages are processed.  This is to ensure that a subscriber can
   react quickly to changes in the overload control status even if the
   subscriber is currently receiving a high volume of messages.

6.10.  Handling of forked requests

   This event package allows the creation of only one dialog as a result
   of an initial SUBSCRIBE request.  The techniques to achieve this
   behavior are described in [4].

6.11.  Rate of notifications

   Keeping the rate of notifications low is important for an overload
   control mechanism to avoid creating additional traffic in an overload
   condition.  However, it is also important that an overload control
   algorithm can quickly adjust the overload control value as needed.
   Ideally, the overload control algorithm would generate a stable
   control value that rarely needs to be adjusted.

   The notifier SHOULD NOT generate NOTIFY messages at a rate faster
   once every 1 second for notifications that are triggered by a change



Hilt, et al.             Expires April 28, 2008                [Page 28]

Internet-Draft              Overload Control                October 2007


   in the control value.  The notifier SHOULD NOT generate a NOTIFY
   message at a rate faster than once every 5 seconds for all other
   notifications (i.e., for any additional information included in the
   subscription).

6.12.  State Agents

   State agents play no role in this package.

6.13.  Examples

   The following message flow illustrates how proxy A can subscribe to
   overload control status of proxy B. The flow assumes that proxy A
   does not have an active subscription to the overload control status
   of proxy B and has received an INVITE request it needs to forward to
   B.


     Proxy A             Proxy B
        |                   |
        |(1) SUBSCRIBE      |
        |------------------>|
        |(2) 200 OK         |
        |<------------------|
        |(3) NOTIFY         |
        |<------------------|
        |(4) 200 OK         |
        |------------------>|
        |(5) INVITE         |
        |------------------>|
        |(6) 200 OK         |
        |<------------------|
        |(7) ACK            |
        |------------------>|
        |                   |

      Message Details

         TBD.



7.  Security Considerations

   Overload control mechanisms can be used by an attacker to conduct a
   denial-of-service attack on a SIP entity if the attacker can pretend
   that the SIP entity is overloaded.  When such a forged overload
   indication is received by an upstream SIP entity, it will stop



Hilt, et al.             Expires April 28, 2008                [Page 29]

Internet-Draft              Overload Control                October 2007


   sending traffic to the victim.  Thus, the victim is subject to a
   denial-of-service attack.

   An attacker can create forged overload status reports by inserting
   itself into the communication between the victim and its upstream
   neighbors.  The attacker would need to add status reports indicating
   a high load to the responses passed from the victim to its upstream
   neighbor.  Proxies can prevent this attack by communicating via TLS.
   Since overload status reports have no meaning beyond the next hop,
   there is no need to secure the communication over multiple hops.

   Another way to conduct an attack is to send a message containing a
   high overload status value through a proxy that does not support this
   extension.  Since this proxy does not remove the overload status
   information, it will reach the next upstream proxy.  If the attacker
   can make the recipient believe that the overload status was created
   by its direct downstream neighbor (and not by the attacker further
   downstream) the recipient stops sending traffic to the victim.  A
   precondition for this attack is that the victim proxy does not
   support this extension since it would not pass through overload
   status information otherwise.  The attack also does not work if there
   is a stateful proxy between the attacker and the victim and only 100
   (Trying) responses are used to convey the 'Overload-Control' header.

   A malicious SIP entity could gain an advantage by pretending to
   support this specification but never reducing the amount of traffic
   it forwards to the downstream neighbor.  If its downstream neighbor
   receives traffic from multiple sources which correctly implement
   overload control, the malicious SIP entity would benefit since all
   other sources to its downstream neighbor would reduce load.

      OPEN ISSUE: the solution to this problem depends on the overload
      control algorithm.  For a fixed message rate and window-based
      overload control, it is very easy for a downstream entity to
      monitor if the upstream neighbor throttles traffic forwarded as
      directed.  For percentage throttling this is not always obvious
      since the load forwarded depends on the load received by the
      upstream neighbor.


8.  IANA Considerations

   [TBD.]


Appendix A.  Acknowledgements

   Many thanks to Rich Terpstra and Jonathan Rosenberg for their



Hilt, et al.             Expires April 28, 2008                [Page 30]

Internet-Draft              Overload Control                October 2007


   contributions to this specification.


9.  References

9.1.  Normative References

   [1]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", BCP 14, RFC 2119, March 1997.

   [2]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A.,
        Peterson, J., Sparks, R., Handley, M., and E. Schooler, "SIP:
        Session Initiation Protocol", RFC 3261, June 2002.

   [3]  Rosenberg, J. and H. Schulzrinne, "Session Initiation Protocol
        (SIP): Locating SIP Servers", RFC 3263, June 2002.

   [4]  Roach, A., "Session Initiation Protocol (SIP)-Specific Event
        Notification", RFC 3265, June 2002.

   [5]  Schulzrinne, H. and J. Polk, "Communications Resource Priority
        for the Session Initiation Protocol (SIP)", RFC 4412,
        February 2006.

   [6]  Hilt, V. and I. Widjaja, "Essential Correction to the Session
        Initiation Protocol (SIP) 503 (Service Unavailable) Response",
        draft-hilt-sip-correction-503-01 (work in progress).

9.2.  Informative References

   [7]  Rosenberg, J., "Requirements for Management of Overload in the
        Session Initiation Protocol",
        draft-rosenberg-sipping-overload-reqs-02 (work in progress),
        October 2006.

   [8]  Bormann, C., Liu, Z., Price, R., and G. Camarillo, "Applying
        Signaling Compression (SigComp) to the Session Initiation
        Protocol  (SIP)", draft-ietf-rohc-sigcomp-sip-08 (work in
        progress), September 2007.

   [9]  Rosen, B., Schulzrinne, H., Polk, J., and A. Newton, "Framework
        for Emergency Calling using Internet Multimedia",
        draft-ietf-ecrit-framework-03 (work in progress),
        September 2007.







Hilt, et al.             Expires April 28, 2008                [Page 31]

Internet-Draft              Overload Control                October 2007


Authors' Addresses

   Volker Hilt
   Bell Labs/Alcatel-Lucent
   791 Holmdel-Keyport Rd
   Holmdel, NJ  07733
   USA

   Email: volkerh@bell-labs.com


   Indra Widjaja
   Bell Labs/Alcatel-Lucent
   600-700 Mountain Avenue
   Murray Hill, NJ  07974
   USA

   Email: iwidjaja@alcatel-lucent.com


   Daryl Malas
   Level 3 Communications
   1025 Eldorado Blvd.
   Broomfield, CO
   USA

   Email: daryl.malas@level3.com


   Henning Schulzrinne
   Columbia University/Department of Computer Science
   450 Computer Science Building
   New York, NY  10027
   USA

   Phone: +1 212 939 7004
   Email: hgs@cs.columbia.edu
   URI:   http://www.cs.columbia.edu













Hilt, et al.             Expires April 28, 2008                [Page 32]

Internet-Draft              Overload Control                October 2007


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Acknowledgment

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).





Hilt, et al.             Expires April 28, 2008                [Page 33]


