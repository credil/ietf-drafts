<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" >
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="no"?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>


<rfc
   category="std"
   docName="draft-ietf-dkim-rfc4871bis-03"
   ipr="trust200902"
   obsoletes="4871">
   <front>
      <title
         abbrev="DKIM Sig RFC4871bis">DomainKeys Identified Mail (DKIM)
         Signatures</title>

      <author
         fullname="D. Crocker"
         initials="D."
         role="editor"
         surname="Crocker">
         <organization>Brandenburg InternetWorking</organization>
         <address>
            <postal>
               <street>675 Spruce Dr.</street>
               <city>Sunnyvale</city>
               <country>USA</country>
            </postal>
            <phone>+1.408.246.8253</phone>
            <email>dcrocker@bbiw.net</email>
            <uri>http://bbiw.net</uri>
         </address>
      </author>

      <author
         fullname="Tony Hansen"
         initials="T."
         role="editor"
         surname="Hansen">
         <organization>AT&amp;T Laboratories</organization>
         <address>
				<postal>
					<street>200 Laurel Ave. South</street>
					<city>Middletown</city>
					<region>NJ</region>
					<code>07748</code>
					<country>USA</country>
				</postal>
				<email>tony+dkimov@maillennium.att.com</email>
			</address>
      </author>
      
      <author
         fullname="M. Kucherawy"
         initials="M."
         role="editor"
         surname="Kucherawy">
         <organization>Cloudmark</organization>
         <address>   
            <postal>
               <street>128 King St., 2nd Floor</street>
               <city>San Francisco</city>
               <region>CA</region>
               <code>94107</code>
               <country>USA</country>
            </postal>
            
            <email>msk@cloudmark.com</email>
         </address>
      </author>


      <date
         year="2011" />


      <abstract>
         <t>DomainKeys Identified Mail (DKIM) permits a person, role, or
            organization that owns the signing domain to claim some
            responsibility for a message by associating the domain with the
            message. This can be an author's organization, an operational relay
            or one of their agents. DKIM separates the question of the identity
            of the signer of the message from the purported author of the
            message. Assertion of responsibility is validated through a
            cryptographic signature and querying the signer's domain directly to
            retrieve the appropriate public key. Message transit from author to
            recipient is through relays that typically make no substantive
            change to the message content and thus preserve the DKIM
            signature.</t>
      </abstract>
   </front>

   <middle>

      <section
         title="Introduction">

         <t>DomainKeys Identified Mail (DKIM) permits a person, role, or
            organization to claim some responsibility for a message by
            associating a domain name <xref
               target="RFC1034" /> with the message <xref
               target="RFC5322" />. This can be an author's organization, an
            operational relay or one of their agents. Assertion of
            responsibility is validated through a cryptographic signature and
            querying the signer's domain directly to retrieve the appropriate
            public key. Message transit from author to recipient is through
            relays that typically make no substantive change to the message
            content and thus preserve the DKIM signature. A message can contain
            multiple signatures, from the same or different organizations
            involved with the message. </t>

         <t>The approach taken by DKIM differs from previous approaches to
            message signing (e.g., Secure/Multipurpose Internet Mail Extensions
            (S/MIME) <xref
               target="RFC1847" />, OpenPGP <xref
               target="RFC4880" />) in that: <list
               style="symbols">
               <t>the message signature is written as a message header field so
                  that neither human recipients nor existing MUA (Mail User
                  Agent) software is confused by signature-related content
                  appearing in the message body;</t>
               <t>there is no dependency on public and private key pairs being
                  issued by well-known, trusted certificate authorities; </t>
               <t>there is no dependency on the deployment of any new Internet
                  protocols or services for public key distribution or
                  revocation;</t>
               <t>signature verification failure does not force rejection of the
                  message;</t>
               <t>no attempt is made to include encryption as part of the
                  mechanism;</t>
               <t>message archiving is not a design goal.</t>
            </list></t>

         <t>DKIM: <list
               style="symbols">
               <t>is compatible with the existing email infrastructure and
                  transparent to the fullest extent possible;</t>
               <t>requires minimal new infrastructure;</t>
               <t>can be implemented independently of clients in order to reduce
                  deployment time;</t>
               <t>can be deployed incrementally;</t>
               <t>allows delegation of signing to third parties.</t>
            </list></t>


         <section
            title="Signing Identity">

            <t>DKIM separates the question of the identity of the signer of the
               message from the purported author of the message. In particular,
               a signature includes the identity of the signer. Verifiers can
               use the signing information to decide how they want to process
               the message. The signing identity is included as part of the
               signature header field. <list>
                  <t>INFORMATIVE RATIONALE: The signing identity specified by a
                     DKIM signature is not required to match an address in any
                     particular header field because of the broad methods of
                     interpretation by recipient mail systems, including
                     MUAs.</t>
               </list></t>
         </section>

         <section
            title="Scalability">

            <t>DKIM is designed to support the extreme scalability requirements
               that characterize the email identification problem. There are
               currently over 70 million domains and a much larger number of
               individual addresses. DKIM seeks to preserve the positive aspects
               of the current email infrastructure, such as the ability for
               anyone to communicate with anyone else without introduction.</t>
         </section>

         <section
            title="Simple Key Management">

            <t>DKIM differs from traditional hierarchical public-key systems in
               that no Certificate Authority infrastructure is required; the
               verifier requests the public key from a repository in the domain
               of the claimed signer directly rather than from a third
               party.</t>

            <t>The DNS is proposed as the initial mechanism for the public keys.
               Thus, DKIM currently depends on DNS administration and the
               security of the DNS system. DKIM is designed to be extensible to
               other key fetching services as they become available.</t>

         </section>

         <section
            title="Data Integrity">

            <t>A DKIM signature associates the d= name with the computed hash of
               some or all of the message (see Section 3.7) in order to prevent
               the re-use of the signature with different messages. Verifying
               the signature asserts that the hashed content has not changed
               since it was signed, and asserts nothing else about "protecting"
               the end-to-end integrity of the message.</t>
         </section>




      </section>

      <section
         title="Terminology and Definitions">

         <t>This section defines terms used in the rest of the document. </t>

         <t>DKIM is designed to operate within the Internet Mail service, as
            defined in <xref
               target="RFC5598" />. Basic email terminology is taken from that
            specification.</t>

         <t>Syntax descriptions use Augmented BNF (ABNF) <xref
               target="RFC5234" />. </t>
         <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
            "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
            document are to be interpreted as described in <xref
               target="RFC2119" />.</t>

         <section
            title="Signers">

            <t>Elements in the mail system that sign messages on behalf of a
               domain are referred to as signers. These may be MUAs (Mail User
               Agents), MSAs (Mail Submission Agents), MTAs (Mail Transfer
               Agents), or other agents such as mailing list exploders. In
               general, any signer will be involved in the injection of a
               message into the message system in some way. The key issue is
               that a message must be signed before it leaves the administrative
               domain of the signer.</t>
         </section>

         <section
            title="Verifiers">

            <t> Elements in the mail system that verify signatures are referred
               to as verifiers. These may be MTAs, Mail Delivery Agents (MDAs),
               or MUAs. In most cases it is expected that verifiers will be
               close to an end user (reader) of the message or some consuming
               agent such as a mailing list exploder.</t>
         </section>








         <section
            title="Identity">

            <t>A person, role, or organization. In the context of DKIM, examples
               include author, author's organization, an ISP along the handling
               path, an independent trust assessment service, and a mailing list
               operator.</t>
         </section>

         <section
            title="Identifier">

            <t> A label that refers to an identity.</t>
         </section>

         <section
            title="Signing Domain Identifier (SDID)">
            <t>A single domain name that is the mandatory payload output of DKIM
               and that refers to the identity claiming responsibility for
               introduction of a message into the mail stream. For DKIM
               processing, the name has only basic domain name semantics; any
               possible owner-specific semantics are outside the scope of DKIM.
               It is specified in <xref
                  target="dkimsighead" />.</t>
         </section>


         <section
            title="Agent or User Identifier (AUID)">
            <t>A single identifier that refers to the agent or user on behalf of
               whom the Signing Domain Identifier (SDID) has taken
               responsibility. The AUID comprises a domain name and an optional
               &lt;Local-part&gt;. The domain name is the same as that used for
               the SDID or is a sub-domain of it. For DKIM processing, the
               domain name portion of the AUID has only basic domain name
               semantics; any possible owner-specific semantics are outside the
               scope of DKIM. It is specified in <xref
                  target="dkimsighead" /> .</t>
         </section>


         <section
            title="Identity Assessor">
            <t>A module that consumes DKIM's mandatory payload, which is the
               responsible Signing Domain Identifier (SDID). The module is
               dedicated to the assessment of the delivered identifier. Other
               DKIM (and non-DKIM) values can also be delivered to this module
               as well as to a more general message evaluation filtering engine.
               However, this additional activity is outside the scope of the
               DKIM signature specification.</t>
         </section>
         <section
            anchor="whitespace"
            title="Whitespace">

            <t>There are three forms of whitespace: <list
                  style="symbols">
                  <t>WSP represents simple whitespace, i.e., a space or a tab
                     character (formal definition in <xref
                        target="RFC5234" />).</t>
                  <t>LWSP is linear whitespace, defined as WSP plus CRLF (formal
                     definition in <xref
                        target="RFC5234" />).</t>
                  <t>FWS is folding whitespace. It allows multiple lines
                     separated by CRLF followed by at least one whitespace, to
                     be joined.</t>
               </list></t>

            <t>
               <figure>
                  <preamble>The formal ABNF for these are (WSP and LWSP are
                     given for information only):</preamble>
                  <artwork type="abnf"><![CDATA[WSP =   SP / HTAB
LWSP =  *(WSP / CRLF WSP)
FWS =   [*WSP CRLF] 1*WSP]]></artwork>
               </figure>
            </t>

            <t>The definition of FWS is identical to that in <xref
                  target="RFC5322" /> except for the exclusion of obs-FWS.</t>
         </section>
         <section
            title="Common ABNF Tokens">


            <t>
               <cref>errata 1596</cref>
               <figure>
                  <preamble>The following ABNF tokens are used elsewhere in this
                     document:</preamble>
                  <artwork type="abnf"><![CDATA[hyphenated-word =  ALPHA [ *(ALPHA / DIGIT / "-") (ALPHA / DIGIT) ]
ALPHADIGITPS    =  (ALPHA / DIGIT / "+" / "/")
base64string    =  ALPHADIGITPS *([FWS] ALPHADIGITPS)
                   [ [FWS] "=" [ [FWS] "=" ] ] 
hdr-name        =  field-name
qp-hdr-value    = dkim-quoted-printable    ; with "|" encoded]]></artwork>
               </figure>
            </t>

         </section>

         <section
            title="Imported ABNF Tokens">

            <t> The following tokens are imported from other RFCs as noted.
               Those RFCs should be considered definitive.</t>

            <t>The following tokens are imported from <xref
                  target="RFC5321" />: <list
                  style="symbols">
                  <t>"Local-part" (implementation warning: this permits quoted
                     strings)</t>
                  <t>"sub-domain"</t>
               </list></t>

            <t>The following tokens are imported from <xref
                  target="RFC5322" />: <list
                  style="symbols">
                  <t>"field-name" (name of a header field)</t>
                  <t>"dot-atom-text" (in the Local-part of an email address)</t>
               </list></t>

            <t>The following tokens are imported from <xref
                  target="RFC2045" />: <list
                  style="symbols">
                  <t>"qp-section" (a single line of quoted-printable-encoded
                     text)</t>
                  <t>"hex-octet" (a quoted-printable encoded octet)</t>
               </list></t>

            <t>
               <list>
                  <t>INFORMATIVE NOTE: Be aware that the ABNF in <xref
                        target="RFC2045" /> does not obey the rules of <xref
                        target="RFC5234" /> and must be interpreted accordingly,
                     particularly as regards case folding.</t>
               </list>
            </t>
            <t> Other tokens not defined herein are imported from <xref
                  target="RFC5234" />. These are intuitive primitives such as
               SP, HTAB, WSP, ALPHA, DIGIT, CRLF, etc.</t>

         </section>

         <section
            anchor="dkim-quoted-printable"
            title="DKIM-Quoted-Printable">

            <t>The DKIM-Quoted-Printable encoding syntax resembles that
               described in Quoted-Printable <xref
                  target="RFC2045" />, Section 6.7: any character MAY be encoded
               as an "=" followed by two hexadecimal digits from the alphabet
               "0123456789ABCDEF" (no lowercase characters permitted)
               representing the hexadecimal-encoded integer value of that
               character. All control characters (those with values &lt; %x20),
               8-bit characters (values &gt; %x7F), and the characters DEL
               (%x7F), SPACE (%x20), and semicolon (";", %x3B) MUST be encoded.
               Note that all whitespace, including SPACE, CR, and LF characters,
               MUST be encoded. After encoding, FWS MAY be added at arbitrary
               locations in order to avoid excessively long lines; such
               whitespace is NOT part of the value, and MUST be removed before
               decoding.</t>

            <t>
               <list>
                  <t>
                     <figure>
                        <preamble>ABNF:</preamble>
                        <artwork type="abnf"><![CDATA[
dkim-quoted-printable =  *(FWS / hex-octet / dkim-safe-char)
                            ; hex-octet is from RFC2045
dkim-safe-char        =  %x21-3A / %x3C / %x3E-7E 
                            ; '!' - ':', '<', '>' - '~'
                            ; Characters not listed as "mail-safe" in 
                            ; [RFC2049] are also not recommended.]]></artwork>
                     </figure>
                  </t>
                  <t>INFORMATIVE NOTE: DKIM-Quoted-Printable differs from
                     Quoted- Printable as defined in <xref
                        target="RFC2045" /> in several important ways: <list
                        style="numbers">
                        <t>Whitespace in the input text, including CR and LF,
                           must be encoded. <xref
                              target="RFC2045" /> does not require such
                           encoding, and does not permit encoding of CR or LF
                           characters that are part of a CRLF line break.</t>
                        <t>Whitespace in the encoded text is ignored. This is to
                           allow tags encoded using DKIM-Quoted-Printable to be
                           wrapped as needed. In particular, <xref
                              target="RFC2045" /> requires that line breaks in
                           the input be represented as physical line breaks;
                           that is not the case here.</t>
                        <t>The "soft line break" syntax ("=" as the last
                           non-whitespace character on the line) does not
                           apply.</t>
                        <t>DKIM-Quoted-Printable does not require that encoded
                           lines be no more than 76 characters long (although
                           there may be other requirements depending on the
                           context in which the encoded text is being used).</t>
                     </list></t>
               </list>
            </t>

         </section>

      </section>

      <section
         title="Protocol Elements">

         <t> Protocol Elements are conceptual parts of the protocol that are not
            specific to either signers or verifiers. The protocol descriptions
            for signers and verifiers are described in later sections (Signer
            Actions (<xref
               target="signer" />) and Verifier Actions (<xref
               target="verifier" />)). NOTE: This section must be read in the
            context of those sections.</t>

         <section
            anchor="selectors"
            title="Selectors">

            <t>To support multiple concurrent public keys per signing domain,
               the key namespace is subdivided using "selectors". For example,
               selectors might indicate the names of office locations (e.g.,
               "sanfrancisco", "coolumbeach", and "reykjavik"), the signing date
               (e.g., "january2005", "february2005", etc.), or even an
               individual user.</t>

            <t>Selectors are needed to support some important use cases. For
               example: <list
                  style="symbols">
                  <t>Domains that want to delegate signing capability for a
                     specific address for a given duration to a partner, such as
                     an advertising provider or other outsourced function.</t>
                  <t> Domains that want to allow frequent travelers to send
                     messages locally without the need to connect with a
                     particular MSA.</t>
                  <t>"Affinity" domains (e.g., college alumni associations) that
                     provide forwarding of incoming mail, but that do not
                     operate a mail submission agent for outgoing mail.</t>
               </list></t>

            <t> Periods are allowed in selectors and are component separators.
               When keys are retrieved from the DNS, periods in selectors define
               DNS label boundaries in a manner similar to the conventional use
               in domain names. Selector components might be used to combine
               dates with locations, for example, "march2005.reykjavik". In a
               DNS implementation, this can be used to allow delegation of a
               portion of the selector namespace.</t>

            <t>
               <list>
                  <t>
                     <figure>
                        <preamble>ABNF:</preamble>
                        <artwork type="abnf"><![CDATA[selector =   sub-domain *( "." sub-domain )]]></artwork>
                     </figure>
                  </t>
               </list>
            </t>

            <t>The number of public keys and corresponding selectors for each
               domain is determined by the domain owner. Many domain owners will
               be satisfied with just one selector, whereas administratively
               distributed organizations may choose to manage disparate
               selectors and key pairs in different regions or on different
               email servers.</t>

            <t>Beyond administrative convenience, selectors make it possible to
               seamlessly replace public keys on a routine basis. If a domain
               wishes to change from using a public key associated with selector
               "january2005" to a public key associated with selector
               "february2005", it merely makes sure that both public keys are
               advertised in the public-key repository concurrently for the
               transition period during which email may be in transit prior to
               verification. At the start of the transition period, the outbound
               email servers are configured to sign with the "february2005"
               private key. At the end of the transition period, the
               "january2005" public key is removed from the public-key
               repository. <list>
                  <t>INFORMATIVE NOTE: A key may also be revoked as described
                     below. The distinction between revoking and removing a key
                     selector record is subtle. When phasing out keys as
                     described above, a signing domain would probably simply
                     remove the key record after the transition period. However,
                     a signing domain could elect to revoke the key (but
                     maintain the key record) for a further period. There is no
                     defined semantic difference between a revoked key and a
                     removed key.</t>
               </list></t>

            <t>While some domains may wish to make selector values well known,
               others will want to take care not to allocate selector names in a
               way that allows harvesting of data by outside parties. For
               example, if per-user keys are issued, the domain owner will need
               to make the decision as to whether to associate this selector
               directly with the name of a registered end-user, or make it some
               unassociated random value, such as a fingerprint of the public
               key. <list>
                  <t>INFORMATIVE OPERATIONS NOTE: Reusing a selector with a new
                     key (for example, changing the key associated with a user's
                     name) makes it impossible to tell the difference between a
                     message that didn't verify because the key is no longer
                     valid versus a message that is actually forged. For this
                     reason, signers are ill-advised to reuse selectors for new
                     keys. A better strategy is to assign new keys to new
                     selectors.</t>
               </list></t>
         </section>


         <section
            anchor="tagval"
            title="Tag=Value Lists">

            <t>DKIM uses a simple "tag=value" syntax in several contexts,
               including in messages and domain signature records.</t>

            <t>Values are a series of strings containing either plain text,
               "base64" text (as defined in <xref
                  target="RFC2045" />, Section&nbsp;6.8), "qp-section" (ibid,
               Section&nbsp;6.7), or "dkim-quoted-printable" (as defined in
               Section&nbsp;2.6). The name of the tag will determine the
               encoding of each value. Unencoded semicolon (";") characters MUST
               NOT occur in the tag value, since that separates tag-specs. <list>
                  <t>INFORMATIVE IMPLEMENTATION NOTE: Although the "plain text"
                     defined below (as "tag-value") only includes 7-bit
                     characters, an implementation that wished to anticipate
                     future standards would be advised not to preclude the use
                     of UTF8-encoded text in tag=value lists. </t>
               </list></t>


            <t>
               <list>
                  <t>
                     <figure>
                        <preamble>Formally, the ABNF syntax rules are as
                           follows:</preamble>
                        <artwork type="abnf"><![CDATA[tag-list  =  tag-spec 0*( ";" tag-spec ) [ ";" ]
tag-spec  =  [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS]
tag-name  =  ALPHA 0*ALNUMPUNC
tag-value =  [ tval 0*( 1*(WSP / FWS) tval ) ]
                  ; WSP and FWS prohibited at beginning and end
tval      =  1*VALCHAR
VALCHAR   =  %x21-3A / %x3C-7E
                  ; EXCLAMATION to TILDE except SEMICOLON
ALNUMPUNC =  ALPHA / DIGIT / "_"]]></artwork>
                     </figure>
                  </t>
               </list>
            </t>

            <t>Note that WSP is allowed anywhere around tags. In particular, any
               WSP after the "=" and any WSP before the terminating ";" is not
               part of the value; however, WSP inside the value is
               significant.</t>

            <t>Tags MUST be interpreted in a case-sensitive manner. Values MUST
               be processed as case sensitive unless the specific tag
               description of semantics specifies case insensitivity.</t>

            <t>Tags with duplicate names MUST NOT occur within a single
               tag-list; if a tag name does occur more than once, the entire
               tag-list is invalid.</t>

            <t>Whitespace within a value MUST be retained unless explicitly
               excluded by the specific tag description.</t>

            <t>Tag=value pairs that represent the default value MAY be included
               to aid legibility.</t>

            <t> Unrecognized tags MUST be ignored.</t>

            <t>Tags that have an empty value are not the same as omitted tags.
               An omitted tag is treated as having the default value; a tag with
               an empty value explicitly designates the empty string as the
               value. </t>

         </section>


         <section
            anchor="sigveralg"
            title="Signing and Verification Algorithms">

            <t>DKIM supports multiple digital signature algorithms. Two
               algorithms are defined by this specification at this time:
               rsa-sha1 and rsa-sha256.
               <!-- errata 1378
		         The rsa-sha256 algorithm is the default if no algorithm 
		         is specified. Verifiers MUST implement both
               rsa-sha1 and rsa-sha256.-->
               Signers MUST implement and SHOULD sign using rsa-sha256.
               Verifiers MUST implement rsa-sha256.<list>
                  <t>INFORMATIVE NOTE: Although sha256 is strongly encouraged,
                     some senders of low-security messages (such as routine
                     newsletters) may prefer to use sha1 because of reduced CPU
                     requirements to compute a sha1 hash. In general, sha256
                     should always be used whenever possible.</t>
               </list></t>

            <section
               title="The rsa-sha1 Signing Algorithm">

               <t>The rsa-sha1 Signing Algorithm computes a message hash as
                  described in <xref
                     target="msghash" /> below using SHA-1 <xref
                     target="FIPS-180-2-2002" /> as the hash-alg. That hash is
                  then signed by the signer using the RSA algorithm (defined in
                  PKCS#1 version 1.5 <xref
                     target="RFC3447" />) as the crypt-alg and the signer's
                  private key. The hash MUST NOT be truncated or converted into
                  any form other than the native binary form before being
                  signed. The signing algorithm SHOULD use a public exponent of
                  65537.</t>
            </section>

            <section
               title="The rsa-sha256 Signing Algorithm">

               <t>The rsa-sha256 Signing Algorithm computes a message hash as
                  described in <xref
                     target="msghash" /> below using SHA-256 <xref
                     target="FIPS-180-2-2002" /> as the hash-alg. That hash is
                  then signed by the signer using the RSA algorithm (defined in
                  PKCS#1 version 1.5 <xref
                     target="RFC3447" />) as the crypt-alg and the signer's
                  private key. The hash MUST NOT be truncated or converted into
                  any form other than the native binary form before being
                  signed.</t>
            </section>

            <section
               title="Key Sizes">

               <t>Selecting appropriate key sizes is a trade-off between cost,
                  performance, and risk. Since short RSA keys more easily
                  succumb to off-line attacks, signers MUST use RSA keys of at
                  least 1024 bits for long-lived keys. Verifiers MUST be able to
                  validate signatures with keys ranging from 512 bits to 2048
                  bits, and they MAY be able to validate signatures with larger
                  keys. Verifier policies may use the length of the signing key
                  as one metric for determining whether a signature is
                  acceptable.</t>

               <t>Factors that should influence the key size choice include the
                  following: <list
                     style="symbols">
                     <t>The practical constraint that large (e.g., 4096 bit)
                        keys may not fit within a 512-byte DNS UDP response
                        packet</t>
                     <t>The security constraint that keys smaller than 1024 bits
                        are subject to off-line attacks</t>
                     <t>Larger keys impose higher CPU costs to verify and sign
                        email</t>
                     <t>Keys can be replaced on a regular basis, thus their
                        lifetime can be relatively short</t>
                     <t>The security goals of this specification are modest
                        compared to typical goals of other systems that employ
                        digital signatures</t>
                  </list></t>

               <t>See <xref
                     target="RFC3766" /> for further discussion on selecting key
                  sizes.</t>

            </section>

            <section
               title="Other Algorithms">

               <t>Other algorithms MAY be defined in the future. Verifiers MUST
                  ignore any signatures using algorithms that they do not
                  implement.</t>
            </section>
         </section>

         <section
            anchor="canon"
            title="Canonicalization">

            <t>Some mail systems modify email in transit, potentially
               invalidating a signature. For most signers, mild modification of
               email is immaterial to validation of the DKIM domain name's use.
               For such signers, a canonicalization algorithm that survives
               modest in-transit modification is preferred.</t>

            <t>Other signers demand that any modification of the email, however
               minor, result in a signature verification failure. These signers
               prefer a canonicalization algorithm that does not tolerate
               in-transit modification of the signed email.</t>

            <t>Some signers may be willing to accept modifications to header
               fields that are within the bounds of email standards such as <xref
                  target="RFC5322" />, but are unwilling to accept any
               modification to the body of messages.</t>

            <t>To satisfy all requirements, two canonicalization algorithms are
               defined for each of the header and the body: a "simple" algorithm
               that tolerates almost no modification and a "relaxed" algorithm
               that tolerates common modifications such as whitespace
               replacement and header field line rewrapping. A signer MAY
               specify either algorithm for header or body when signing an
               email. If no canonicalization algorithm is specified by the
               signer, the "simple" algorithm defaults for both header and body.
               Verifiers MUST implement both canonicalization algorithms. Note
               that the header and body may use different canonicalization
               algorithms. Further canonicalization algorithms MAY be defined in
               the future; verifiers MUST ignore any signatures that use
               unrecognized canonicalization algorithms.</t>

            <t>Canonicalization simply prepares the email for presentation to
               the signing or verification algorithm. It MUST NOT change the
               transmitted data in any way. Canonicalization of header fields
               and body are described below.</t>

            <t>NOTE: This section assumes that the message is already in
               "network normal" format (text is ASCII encoded, lines are
               separated with CRLF characters, etc.). See also <xref
                  target="normalize" /> for information about normalizing the
               message.</t>

            <section
               anchor="simpleheader"
               title="The &quot;simple&quot; Header Canonicalization Algorithm">

               <t>The "simple" header canonicalization algorithm does not change
                  header fields in any way. Header fields MUST be presented to
                  the signing or verification algorithm exactly as they are in
                  the message being signed or verified. In particular, header
                  field names MUST NOT be case folded and whitespace MUST NOT be
                  changed.</t>
            </section>

            <section
               anchor="relaxedheader"
               title="The &quot;relaxed&quot; Header Canonicalization Algorithm">

               <t>The "relaxed" header canonicalization algorithm MUST apply the
                  following steps in order: <list
                     style="symbols">
                     <t>Convert all header field names (not the header field
                        values) to lowercase. For example, convert "SUBJect:
                        AbC" to "subject: AbC".</t>
                     <t>Unfold all header field continuation lines as described
                        in <xref
                           target="RFC5322" />; in particular, lines with
                        terminators embedded in continued header field values
                        (that is, CRLF sequences followed by WSP) MUST be
                        interpreted without the CRLF. Implementations MUST NOT
                        remove the CRLF at the end of the header field
                        value.</t>
                     <t>Convert all sequences of one or more WSP characters to a
                        single SP character. WSP characters here include those
                        before and after a line folding boundary.</t>
                     <t>Delete all WSP characters at the end of each unfolded
                        header field value.</t>
                     <t>Delete any WSP characters remaining before and after the
                        colon separating the header field name from the header
                        field value. The colon separator MUST be retained.</t>
                  </list></t>
            </section>

            <section
               anchor="simplebody"
               title="The &quot;simple&quot; Body Canonicalization Algorithm">

               <t>The "simple" body canonicalization algorithm ignores all empty
                  lines at the end of the message body. An empty line is a line
                  of zero length after removal of the line terminator. If there
                  is no body or no trailing CRLF on the message body, a CRLF is
                  added. It makes no other changes to the message body. In more
                  formal terms, the "simple" body canonicalization algorithm
                  converts "0*CRLF" at the end of the body to a single
                  "CRLF".</t>

               <t>Note that a completely empty or missing body is canonicalized
                  as a single "CRLF"; that is, the canonicalized length will be
                  2 octets.</t>


               <t>
                  <cref>errata 1376</cref>The sha1 value (in base64) for an
                  empty body (canonicalized to a "CRLF") is: <figure>
                     <artwork><![CDATA[uoq1oCgLlTqpdDX/iUbLy7J1Wic=]]></artwork>
                  </figure> The sha256 value is: <figure>
                     <artwork><![CDATA[frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN/XKdLCPjaYaY=]]></artwork>
                  </figure></t>


            </section>

            <section
               anchor="relaxedbody"
               title="The &quot;relaxed&quot; Body Canonicalization Algorithm">

               <!-- <t>The "relaxed" body canonicalization algorithm: <list
                     style="symbols">
                     <t>Ignores all whitespace at the end of lines.
                        Implementations MUST NOT remove the CRLF at the end of
                        the line.</t>
                     <t>Reduces all sequences of WSP within a line to a single
                        SP character.</t>
                     <t>Ignores all empty lines at the end of the message body.
                        "Empty line" is defined in <xref
                           target="simplebody" />.</t>
		     <cref>errata 1377</cref>
                     <t>If the body is non-empty, but does not end with a CRLF,
                        a CRLF is added. (For email, this is only possible when
                        using extensions to SMTP or non-SMTP transport
                        mechanisms.)</t>
               </list></t>-->



               <t>
                  <cref>errata 1384</cref> The "relaxed" body canonicalization
                  algorithm MUST apply the following steps (a) and (b) in order:<list
                     style="letters">
                     <t>Reduce whitespace: <list
                           style="symbols">
                           <t>Ignore all whitespace at the end of lines.
                              Implementations MUST NOT remove the CRLF at the
                              end of the line.</t>
                           <t>Reduce all sequences of WSP within a line to a
                              single SP character.</t>
                        </list></t>
                     <t>Ignore all empty lines at the end of the message body.
                        "Empty line" is defined in Section 3.4.3. <cref>errata
                           1377</cref> If the body is non-empty, but does not
                        end with a CRLF, a CRLF is added. (For email, this is
                        only possible when using extensions to SMTP or non-SMTP
                        transport mechanisms.)</t>
                  </list></t>



               <t>
                  <cref>errata 1376</cref>The sha1 value (in base64) for an
                  empty body (canonicalized to a null input) is: <figure>
                     <artwork><![CDATA[2jmj7l5rSw0yVb/vlWAYkK/YBwk=]]></artwork>
                  </figure> The sha256 value is: <figure>
                     <artwork><![CDATA[47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=]]></artwork>
                  </figure></t>
               <t>
                  <list>
                     <t>INFORMATIVE NOTE: It should be noted that the relaxed
                        body canonicalization algorithm may enable certain types
                        of extremely crude "ASCII Art" attacks where a message
                        may be conveyed by adjusting the spacing between words.
                        If this is a concern, the "simple" body canonicalization
                        algorithm should be used instead.</t>
                  </list>
               </t>
            </section>

            <section
               anchor="bodylength"
               title="Body Length Limits">

               <t>A body length count MAY be specified to limit the signature
                  calculation to an initial prefix of the body text, measured in
                  octets. If the body length count is not specified, the entire
                  message body is signed. <list>
                     <t>INFORMATIVE RATIONALE: This capability is provided
                        because it is very common for mailing lists to add
                        trailers to messages (e.g., instructions how to get off
                        the list). Until those messages are also signed, the
                        body length count is a useful tool for the verifier
                        since it may as a matter of policy accept messages
                        having valid signatures with extraneous data.</t>
                     <t>INFORMATIVE IMPLEMENTATION NOTE: Using body length
                        limits enables an attack in which an attacker modifies a
                        message to include content that solely benefits the
                        attacker. It is possible for the appended content to
                        completely replace the original content in the end
                        recipient's eyes and to defeat duplicate message
                        detection algorithms. To avoid this attack, signers
                        should be wary of using this tag, and verifiers might
                        wish to ignore the tag or remove text that appears after
                        the specified content length, perhaps based on other
                        criteria.</t>
                  </list></t>

               <t>The body length count allows the signer of a message to permit
                  data to be appended to the end of the body of a signed
                  message. The body length count MUST be calculated following
                  the canonicalization algorithm; for example, any whitespace
                  ignored by a canonicalization algorithm is not included as
                  part of the body length count. Signers of MIME messages that
                  include a body length count SHOULD be sure that the length
                  extends to the closing MIME boundary string. <list>
                     <t>INFORMATIVE IMPLEMENTATION NOTE: A signer wishing to
                        ensure that the only acceptable modifications are to add
                        to the MIME postlude would use a body length count
                        encompassing the entire final MIME boundary string,
                        including the final "--CRLF". A signer wishing to allow
                        additional MIME parts but not modification of existing
                        parts would use a body length count extending through
                        the final MIME boundary string, omitting the final
                        "--CRLF". Note that this only works for some MIME types,
                        e.g., multipart&sol;mixed but not
                        multipart&sol;signed.</t>
                  </list></t>

               <t>A body length count of zero means that the body is completely
                  unsigned.</t>

               <t>Signers wishing to ensure that no modification of any sort can
                  occur should specify the "simple" canonicalization algorithm
                  for both header and body and omit the body length count.</t>
            </section>

            <section
               title="Canonicalization Examples (INFORMATIVE)">

               <t>In the following examples, actual whitespace is used only for
                  clarity. The actual input and output text is designated using
                  bracketed descriptors: "&lt;SP&gt;" for a space character,
                  "&lt;HTAB&gt;" for a tab character, and "&lt;CRLF&gt;" for a
                  carriage-return/line-feed sequence. For example, "X &lt;SP&gt;
                  Y" and "X&lt;SP&gt;Y" represent the same three characters.</t>

               <t>
                  <figure
                     align="left">
                     <preamble>Example 1: A message reading:</preamble>
                     <artwork><![CDATA[A: <SP> X <CRLF>
B <SP> : <SP> Y <HTAB><CRLF>
                <HTAB> Z <SP><SP><CRLF>
<CRLF>
<SP> C <SP><CRLF>
D <SP><HTAB><SP> E <CRLF>
<CRLF>
<CRLF>]]></artwork>
                  </figure>
               </t>

               <t>
                  <figure
                     align="left">
                     <preamble>when canonicalized using relaxed canonicalization
                        for both header and body results in a header
                        reading:</preamble>
                     <artwork><![CDATA[a:X <CRLF>
b:Y <SP> Z <CRLF>]]></artwork>
                  </figure>
               </t>

               <t>
                  <figure
                     align="left">
                     <preamble>and a body reading:</preamble>
                     <artwork><![CDATA[<SP> C <CRLF>
D <SP> E <CRLF>]]></artwork>
                  </figure>
               </t>

               <t>
                  <figure
                     align="left">
                     <preamble>Example 2: The same message canonicalized using
                        simple canonicalization for both header and body results
                        in a header reading:</preamble>
                     <artwork><![CDATA[A: <SP> X <CRLF>
B <SP> : <SP> Y <HTAB><CRLF>
       <HTAB> Z <SP><SP><CRLF>]]></artwork>
                  </figure>
               </t>

               <t>
                  <figure
                     align="left">
                     <preamble>and a body reading:</preamble>
                     <artwork><![CDATA[<SP> C <SP><CRLF>
D <SP><HTAB><SP> E <CRLF>]]></artwork>
                  </figure>
               </t>

               <t>
                  <figure
                     align="left">
                     <preamble>Example 3: When processed using relaxed header
                        canonicalization and simple body canonicalization, the
                        canonicalized version has a header of:</preamble>
                     <artwork><![CDATA[a:X <CRLF>
b:Y <SP> Z <CRLF>]]></artwork>
                  </figure>
               </t>

               <t>
                  <figure
                     align="left">
                     <preamble>and a body reading:</preamble>
                     <artwork><![CDATA[<SP> C <SP><CRLF>
D <SP><HTAB><SP> E <CRLF>]]></artwork>
                  </figure>
               </t>
            </section>
         </section>


         <section
            anchor="dkimsighead"
            title="The DKIM-Signature Header Field">

            <t>The signature of the email is stored in the DKIM-Signature header
               field. This header field contains all of the signature and key-
               fetching data. The DKIM-Signature value is a tag-list as
               described in <xref
                  target="tagval" />.</t>

            <t>The DKIM-Signature header field SHOULD be treated as though it
               were a trace header field as defined in Section&nbsp;3.6 of <xref
                  target="RFC5322" />, and hence SHOULD NOT be reordered and
               SHOULD be prepended to the message.</t>

            <t>The DKIM-Signature header field being created or verified is
               always included in the signature calculation, after the rest of
               the header fields being signed; however, when calculating or
               verifying the signature, the value of the "b=" tag (signature
               value) of that DKIM- Signature header field MUST be treated as
               though it were an empty string. Unknown tags in the
               DKIM-Signature header field MUST be included in the signature
               calculation but MUST be otherwise ignored by verifiers. Other
               DKIM-Signature header fields that are included in the signature
               should be treated as normal header fields; in particular, the
               "b=" tag is not treated specially.</t>

            <t>The encodings for each field type are listed below. Tags
               described as qp-section are encoded as described in
               Section&nbsp;6.7 of MIME Part One <xref
                  target="RFC2045" />, with the additional conversion of
               semicolon characters to "=3B"; intuitively, this is one line of
               quoted-printable encoded text. The dkim-quoted-printable syntax
               is defined in <xref
                  target="dkim-quoted-printable" />.</t>

            <t>Tags on the DKIM-Signature header field along with their type and
               requirement status are shown below. Unrecognized tags MUST be
               ignored. <list
                  style="hanging">
                  <t
                     hangText="v=">Version (MUST be included). This tag defines
                     the version of this specification that applies to the
                     signature record. It MUST have the value "1". Note that
                     verifiers must do a string comparison on this value; for
                     example, "1" is not the same as "1.0".</t>
                  <t><list>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-v-tag       = %x76 [FWS] "=" [FWS] "1"]]></artwork>
                           </figure></t>
                        <t>INFORMATIVE NOTE: DKIM-Signature version numbers are
                           expected to increase arithmetically as new versions
                           of this specification are released.</t>
                     </list></t>
                  <t
                     hangText="a=  ">The algorithm used to generate the
                     signature (plain-text; REQUIRED). Verifiers MUST support
                     "rsa-sha1" and "rsa-sha256"; signers SHOULD sign using
                     "rsa-sha256".</t>
                  <t>
                     <list>
                        <t>
                           <figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[
sig-a-tag       = %x61 [FWS] "=" [FWS] sig-a-tag-alg
sig-a-tag-alg   = sig-a-tag-k "-" sig-a-tag-h
sig-a-tag-k     = "rsa" / x-sig-a-tag-k
sig-a-tag-h     = "sha1" / "sha256" / x-sig-a-tag-h
x-sig-a-tag-k   = ALPHA *(ALPHA / DIGIT)   
                     ; for later extension
x-sig-a-tag-h   = ALPHA *(ALPHA / DIGIT)   
                     ; for later extension]]></artwork>
                           </figure>
                        </t>
                     </list>
                  </t>
                  <t
                     hangText="b=">The signature data (base64; REQUIRED).
                     Whitespace is ignored in this value and MUST be ignored
                     when reassembling the original signature. In particular,
                     the signing process can safely insert FWS in this value in
                     arbitrary places to conform to line-length limits. See
                     Signer Actions (<xref
                        target="signer" />) for how the signature is
                     computed.</t>
                  <t><list>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-b-tag       = %x62 [FWS] "=" [FWS] sig-b-tag-data
sig-b-tag-data  = base64string]]></artwork>
                           </figure></t>
                     </list></t>
                  <t
                     hangText="bh=">The hash of the canonicalized body part of
                     the message as limited by the "l=" tag (base64; REQUIRED).
                     Whitespace is ignored in this value and MUST be ignored
                     when reassembling the original signature. In particular,
                     the signing process can safely insert FWS in this value in
                     arbitrary places to conform to line-length limits. See <xref
                        target="msghash" /> for how the body hash is
                     computed.</t>
                  <t><list>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-bh-tag      = %x62 %x68 [FWS] "=" [FWS] sig-bh-tag-data
sig-bh-tag-data = base64string]]></artwork>
                           </figure></t>
                     </list></t>
                  <t
                     hangText="c=">Message canonicalization (plain-text;
                     OPTIONAL, default is "simple/simple"). This tag informs the
                     verifier of the type of canonicalization used to prepare
                     the message for signing. It consists of two names separated
                     by a "slash" (%d47) character, corresponding to the header
                     and body canonicalization algorithms respectively. These
                     algorithms are described in <xref
                        target="canon" />. If only one algorithm is named, that
                     algorithm is used for the header and "simple" is used for
                     the body. For example, "c=relaxed" is treated the same as
                     "c=relaxed/simple".</t>
                  <t><list>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-c-tag       = %x63 [FWS] "=" [FWS] sig-c-tag-alg
                  ["/" sig-c-tag-alg]
sig-c-tag-alg   = "simple" / "relaxed" / x-sig-c-tag-alg
x-sig-c-tag-alg = hyphenated-word    ; for later extension]]></artwork>
                           </figure></t>
                     </list></t>
                  <t
                     hangText="d=">The SDID claiming responsibility for an
                     introduction of a message into the mail stream (plain-text;
                     REQUIRED). Hence, the SDID value is used to form the query
                     for the public key. The SDID MUST correspond to a valid DNS
                     name under which the DKIM key record is published. The
                     conventions and semantics used by a signer to create and
                     use a specific SDID are outside the scope of the DKIM
                     Signing specification, as is any use of those conventions
                     and semantics. When presented with a signature that does
                     not meet these requirements, verifiers MUST consider the
                     signature invalid.</t>
                  <t>Internationalized domain names MUST be encoded as described
                     in <xref
                        target="RFC3490" />.</t>
                  <t><list>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[
sig-d-tag       = %x64 [FWS] "=" [FWS] domain-name
domain-name     = sub-domain 1*("." sub-domain) 
                     ; from RFC 5321 Domain, but excluding address-literal]]></artwork>
                           </figure></t>
                     </list></t>
                  <t
                     hangText="h=">Signed header fields (plain-text, but see
                     description; REQUIRED). A colon-separated list of header
                     field names that identify the header fields presented to
                     the signing algorithm. The field MUST contain the complete
                     list of header fields in the order presented to the signing
                     algorithm. The field MAY contain names of header fields
                     that do not exist when signed; nonexistent header fields do
                     not contribute to the signature computation (that is, they
                     are treated as the null input, including the header field
                     name, the separating colon, the header field value, and any
                     CRLF terminator). The field MUST NOT include the
                     DKIM-Signature header field that is being created or
                     verified, but may include others. Folding whitespace (FWS)
                     MAY be included on either side of the colon separator.
                     Header field names MUST be compared against actual header
                     field names in a case-insensitive manner. This list MUST
                     NOT be empty. See <xref
                        target="fields2sign" /> for a discussion of choosing
                     header fields to sign.</t>
                  <t><list>
                        <t>
                           <cref>errata 1461</cref><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-h-tag       = %x68 [FWS] "=" [FWS] hdr-name
                   0*( [FWS] ":" [FWS] hdr-name )]]></artwork>
                           </figure></t>
                        <t>INFORMATIVE EXPLANATION: By "signing" header fields
                           that do not actually exist, a signer can prevent
                           insertion of those header fields before verification.
                           However, since a signer cannot possibly know what
                           header fields might be created in the future, and
                           that some MUAs might present header fields that are
                           embedded inside a message (e.g., as a message/rfc822
                           content type), the security of this solution is not
                           total.</t>
                        <t>INFORMATIVE EXPLANATION: The exclusion of the header
                           field name and colon as well as the header field
                           value for non-existent header fields prevents an
                           attacker from inserting an actual header field with a
                           null value.</t>
                     </list></t>
                  <t
                     hangText="i=">The Agent or User Identifier (AUID) on behalf
                     of which the SDID is taking responsibility
                     (dkim-quoted-printable; OPTIONAL, default is an empty
                     Local-part followed by an "@" followed by the domain from
                     the "d=" tag).</t>
                  <t>The syntax is a standard email address where the Local-part
                     MAY be omitted. The domain part of the address MUST be the
                     same as, or a subdomain of, the value of the "d=" tag.</t>
                  <t>Internationalized domain names MUST be converted using the
                     steps listed in Section 4 of <xref
                        target="RFC3490" /> using the "ToASCII" function.</t>
                  <t><list>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[
sig-i-tag       = %x69 [FWS] "=" [FWS] [ Local-part ]
                           "@" domain-name]]></artwork>
                           </figure></t>
                     </list></t>
                  <t>The AUID is specified as having the same syntax as an email
                     address, but is not required to have the same semantics.
                     Notably, the domain name is not required to be registered
                     in the DNS -- so it might not resolve in a query -- and the
                     Local-part MAY be drawn from a namespace unrelated to any
                     mailbox. The details of the structure and semantics for the
                     namespace are determined by the Signer. Any knowledge or
                     use of those details by verifiers or assessors is outside
                     the scope of the DKIM Signing specification. The Signer MAY
                     choose to use the same namespace for its AUIDs as its
                     users' email addresses or MAY choose other means of
                     representing its users. However, the signer SHOULD use the
                     same AUID for each message intended to be evaluated as
                     being within the same sphere of responsibility, if it
                     wishes to offer receivers the option of using the AUID as a
                     stable identifier that is finer grained than the SDID. <list>
                        <t>INFORMATIVE NOTE: The Local-part of the "i=" tag is
                           optional because in some cases a signer may not be
                           able to establish a verified individual identity. In
                           such cases, the signer might wish to assert that
                           although it is willing to go as far as signing for
                           the domain, it is unable or unwilling to commit to an
                           individual user name within their domain. It can do
                           so by including the domain part but not the
                           Local-part of the identity.</t>
                        <t>INFORMATIVE DISCUSSION: This specification does not
                           require the value of the "i=" tag to match the
                           identity in any message header fields. This is
                           considered to be a verifier policy issue. Constraints
                           between the value of the "i=" tag and other
                           identities in other header fields seek to apply basic
                           authentication into the semantics of trust associated
                           with a role such as content author. Trust is a broad
                           and complex topic and trust mechanisms are subject to
                           highly creative attacks. The real-world efficacy of
                           any but the most basic bindings between the "i="
                           value and other identities is not well established,
                           nor is its vulnerability to subversion by an
                           attacker. Hence reliance on the use of these options
                           should be strictly limited. In particular, it is not
                           at all clear to what extent a typical end-user
                           recipient can rely on any assurances that might be
                           made by successful use of the "i=" options.</t>
                     </list></t>
                  <t
                     hangText="l=">Body length count (plain-text unsigned
                     decimal integer; OPTIONAL, default is entire body). This
                     tag informs the verifier of the number of octets in the
                     body of the email after canonicalization included in the
                     cryptographic hash, starting from 0 immediately following
                     the CRLF preceding the body. This value MUST NOT be larger
                     than the actual number of octets in the canonicalized
                     message body.</t>
                  <t><list>
                        <t>INFORMATIVE IMPLEMENTATION WARNING: Use of the "l="
                           tag might allow display of fraudulent content without
                           appropriate warning to end users. The "l=" tag is
                           intended for increasing signature robustness when
                           sending to mailing lists that both modify their
                           content and do not sign their messages. However,
                           using the "l=" tag enables attacks in which an
                           intermediary with malicious intent modifies a message
                           to include content that solely benefits the attacker.
                           It is possible for the appended content to completely
                           replace the original content in the end recipient's
                           eyes and to defeat duplicate message detection
                           algorithms. Examples are described in Security
                           Considerations <xref
                              target="security" />. To avoid this attack,
                           signers should be extremely wary of using this tag,
                           and verifiers might wish to ignore the tag or remove
                           text that appears after the specified content
                           length.</t>
                        <t>INFORMATIVE NOTE: The value of the "l=" tag is
                           constrained to 76 decimal digits. This constraint is
                           not intended to predict the size of future messages
                           or to require implementations to use an integer
                           representation large enough to represent the maximum
                           possible value, but is intended to remind the
                           implementer to check the length of this and all other
                           tags during verification and to test for integer
                           overflow when decoding the value. Implementers may
                           need to limit the actual value expressed to a value
                           smaller than 10^76, e.g., to allow a message to fit
                           within the available storage space.</t>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-l-tag    = %x6c [FWS] "=" [FWS]
               1*76DIGIT]]></artwork>
                           </figure></t>
                     </list></t>
                  <t
                     hangText="q=">A colon-separated list of query methods used
                     to retrieve the public key (plain-text; OPTIONAL, default
                     is "dns/txt"). Each query method is of the form
                     "type[/options]", where the syntax and semantics of the
                     options depend on the type and specified options. If there
                     are multiple query mechanisms listed, the choice of query
                     mechanism MUST NOT change the interpretation of the
                     signature. Implementations MUST use the recognized query
                     mechanisms in the order presented. <cref>errata 1381</cref>
                     Unrecognized query mechanisms MUST be ignored. </t>
                  <t>Currently, the only valid value is "dns/txt", which defines
                     the DNS TXT record lookup algorithm described elsewhere in
                     this document. The only option defined for the "dns" query
                     type is "txt", which MUST be included. Verifiers and
                     signers MUST support "dns/txt".</t>
                  <t><list>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-q-tag        = %x71 [FWS] "=" [FWS] sig-q-tag-method
                      *([FWS] ":" [FWS] sig-q-tag-method)
sig-q-tag-method = "dns/txt" / x-sig-q-tag-type
                   ["/" x-sig-q-tag-args]
x-sig-q-tag-type = hyphenated-word  ; for future extension
x-sig-q-tag-args = qp-hdr-value]]></artwork>
                           </figure></t>
                     </list></t>
                  <t
                     hangText="s=">The selector subdividing the namespace for
                     the "d=" (domain) tag (plain-text; REQUIRED).</t>
                  <t><list>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-s-tag    = %x73 [FWS] "=" [FWS] selector]]></artwork>
                           </figure></t>
                     </list></t>
                  <t
                     hangText="t=">Signature Timestamp (plain-text unsigned
                     decimal integer; RECOMMENDED, default is an unknown
                     creation time). The time that this signature was created.
                     The format is the number of seconds since 00:00:00 on
                     January 1, 1970 in the UTC time zone. The value is
                     expressed as an unsigned integer in decimal ASCII. This
                     value is not constrained to fit into a 31- or 32-bit
                     integer. Implementations SHOULD be prepared to handle
                     values up to at least 10^12 (until approximately AD
                     200,000; this fits into 40 bits). To avoid
                     denial-of-service attacks, implementations MAY consider any
                     value longer than 12 digits to be infinite. Leap seconds
                     are not counted. Implementations MAY ignore signatures that
                     have a timestamp in the future.</t>
                  <t><list>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-t-tag    = %x74 [FWS] "=" [FWS] 1*12DIGIT]]></artwork>
                           </figure></t>
                     </list></t>
                  <t
                     hangText="x=">Signature Expiration (plain-text unsigned
                     decimal integer; RECOMMENDED, default is no expiration).
                     The format is the same as in the "t=" tag, represented as
                     an absolute date, not as a time delta from the signing
                     timestamp. The value is expressed as an unsigned integer in
                     decimal ASCII, with the same constraints on the value in
                     the "t=" tag. Signatures MAY be considered invalid if the
                     verification time at the verifier is past the expiration
                     date. The verification time should be the time that the
                     message was first received at the administrative domain of
                     the verifier if that time is reliably available; otherwise
                     the current time should be used. The value of the "x=" tag
                     MUST be greater than the value of the "t=" tag if both are
                     present.</t>
                  <t><list>
                        <t>INFORMATIVE NOTE: The "x=" tag is not intended as an
                           anti-replay defense.</t>
                        <t>
                           <cref>errata 1380</cref>INFORMATIVE NOTE: Due to
                           clock drift, the receiver's notion of when to
                           consider the signature expired may not match exactly
                           when the sender is expecting. Receivers MAY add a
                           'fudge factor' to allow for such possible drift. </t>
                        <t><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-x-tag    = %x78 [FWS] "=" [FWS]
                              1*12DIGIT]]></artwork>
                           </figure></t>
                     </list></t>
                  <t
                     hangText="z=">Copied header fields (dkim-quoted-printable,
                     but see description; OPTIONAL, default is null). A
                     vertical-bar-separated list of selected header fields
                     present when the message was signed, including both the
                     field name and value. It is not required to include all
                     header fields present at the time of signing. This field
                     need not contain the same header fields listed in the "h="
                     tag. The header field text itself must encode the vertical
                     bar ("|", %x7C) character (i.e., vertical bars in the "z="
                     text are meta-characters, and any actual vertical bar
                     characters in a copied header field must be encoded). Note
                     that all whitespace must be encoded, including whitespace
                     between the colon and the header field value. After
                     encoding, FWS MAY be added at arbitrary locations in order
                     to avoid excessively long lines; such whitespace is NOT
                     part of the value of the header field, and MUST be removed
                     before decoding.</t>
                  <t>The header fields referenced by the "h=" tag refer to the
                     fields in the <xref
                        target="RFC5322" /> header of the message, not to any
                     copied fields in the "z=" tag. Copied header field values
                     are for diagnostic use.</t>
                  <t>Header fields with characters requiring conversion (perhaps
                     from legacy MTAs that are not <xref
                        target="RFC5322" /> compliant) SHOULD be converted as
                     described in MIME Part Three <xref
                        target="RFC2047" />.</t>
                  <t><list>
                        <t>
                           <cref>errata 1379</cref><figure>
                              <preamble>ABNF:</preamble>
                              <artwork type="abnf"><![CDATA[sig-z-tag      = %x7A [FWS] "=" [FWS] sig-z-tag-copy
                 *( "|" [FWS] sig-z-tag-copy )
sig-z-tag-copy = hdr-name [FWS] ":" qp-hdr-value]]></artwork>
                           </figure></t>
                        <t>
                           <cref>errata 1386</cref><figure
                              align="left">
                              <preamble>INFORMATIVE EXAMPLE of a signature
                                 header field spread across multiple
                                 continuation lines:</preamble>
                              <artwork><![CDATA[DKIM-Signature: v=1; a=rsa-sha256; d=example.net; s=brisbane;
   c=simple; q=dns/txt; i=@eng.example.net;
   t=1117574938; x=1118006938;
   h=from:to:subject:date;
   z=From:foo@eng.example.net|To:joe@example.com|
    Subject:demo=20run|Date:July=205,=202005=203:44:08=20PM=20-0700;
   bh=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=;
   b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZVoG4ZHRNiYzR]]></artwork>
                           </figure></t>
                     </list></t>
               </list></t>

         </section>

         <section
            anchor="keymgmt"
            title="Key Management and Representation">

            <t>Signature applications require some level of assurance that the
               verification public key is associated with the claimed signer.
               Many applications achieve this by using public key certificates
               issued by a trusted third party. However, DKIM can achieve a
               sufficient level of security, with significantly enhanced
               scalability, by simply having the verifier query the purported
               signer's DNS entry (or some security-equivalent) in order to
               retrieve the public key.</t>

            <t>DKIM keys can potentially be stored in multiple types of key
               servers and in multiple formats. The storage and format of keys
               are irrelevant to the remainder of the DKIM algorithm.</t>

            <t>Parameters to the key lookup algorithm are the type of the lookup
               (the "q=" tag), the domain of the signer (the "d=" tag of the
               DKIM- Signature header field), and the selector (the "s=" tag). <figure>
                  <artwork type="abnf"><![CDATA[public_key = dkim_find_key(q_val, d_val, s_val)]]></artwork>
               </figure></t>

            <t>This document defines a single binding, using DNS TXT records to
               distribute the keys. Other bindings may be defined in the
               future.</t>



            <section
               anchor="textrep"
               title="Textual Representation">

               <t>It is expected that many key servers will choose to present
                  the keys in an otherwise unstructured text format (for
                  example, an XML form would not be considered to be
                  unstructured text for this purpose). The following definition
                  MUST be used for any DKIM key represented in an otherwise
                  unstructured textual form.</t>

               <t>The overall syntax is a tag-list as described in <xref
                     target="tagval" />. The current valid tags are described
                  below. Other tags MAY be present and MUST be ignored by any
                  implementation that does not understand them.</t>


               <t>
                  <list
                     style="hanging">
                     <!-- <t
                        hangText="v=">Version of the DKIM key record
                        (plain-text; RECOMMENDED, default is "DKIM1"). If
                        specified, this tag MUST be set to "DKIM1" (without the
                        quotes). This tag MUST be the first tag in the record.
                        Records beginning with a "v=" tag with any other value
                        MUST be discarded. Note that verifiers must do a string
                        comparison on this value; for example, "DKIM1" is not
                        the same as "DKIM1.0".</t>

                     <t>
                        <list>
                           <t>
                              <figure>
                                 <preamble>ABNF:</preamble>
                                 <artwork type="abnf"><![CDATA[key-v-tag    = %x76 [FWS] "=" [FWS] "DKIM1"]]></artwork>
                              </figure>
                           </t>
                        </list>
                     </t>-->


                     <t
                        hangText="v=">
                        <cref>errata 1487</cref>Version of the DKIM key record
                        (plain-text; RECOMMENDED, default is "DKIM1"). If
                        specified, this tag MUST be set to "DKIM1" (without the
                        quotes). This tag MUST be the first tag in the record.
                        Records beginning with a "v=" tag with any other value
                        MUST be discarded. Note that verifiers must do a string
                        comparison on this value; for example, "DKIM1" is not
                        the same as "DKIM1.0". <list>
                           <t>ABNF: <figure>
                                 <artwork type="abnf"><![CDATA[key-v-tag    = %x76 [FWS] "=" [FWS] %x44 %x4B %x49 %x4D %x31]]></artwork>
                              </figure></t>
                        </list>
                     </t>




                     <t
                        hangText="h=">Acceptable hash algorithms (plain-text;
                        OPTIONAL, defaults to allowing all algorithms). A
                        colon-separated list of hash algorithms that might be
                        used. Signers and Verifiers MUST support the "sha256"
                        hash algorithm. Verifiers MUST also support the "sha1"
                        hash algorithm. <cref>errata 1381</cref> Unrecognized
                        hash algorithms MUST be ignored. </t>
                     <t>
                        <list>
                           <t>
                              <figure>
                                 <preamble>ABNF:</preamble>
                                 <artwork type="abnf"><![CDATA[key-h-tag       = %x68 [FWS] "=" [FWS] key-h-tag-alg
                  0*( [FWS] ":" [FWS] key-h-tag-alg )
key-h-tag-alg   = "sha1" / "sha256" / x-key-h-tag-alg
x-key-h-tag-alg = hyphenated-word   ; for future extension]]></artwork>
                              </figure>
                           </t>
                        </list>
                     </t>


                     <t
                        hangText="k=">Key type (plain-text; OPTIONAL, default is
                        "rsa"). Signers and verifiers MUST support the "rsa" key
                        type. The "rsa" key type indicates that an ASN.1
                        DER-encoded <xref
                           target="ITU-X660-1997" /> RSAPublicKey <xref
                           target="RFC3447" /> (see Sections <xref
                           target="selectors" /> and A.1.1) is being used in the
                        "p=" tag. (Note: the "p=" tag further encodes the value
                        using the base64 algorithm.) <cref>errata 1381</cref>
                        Unrecognized key types MUST be ignored. </t>

                     <t>
                        <list>
                           <t>
                              <figure>
                                 <preamble>ABNF:</preamble>
                                 <artwork type="abnf"><![CDATA[key-k-tag        = %x76 [FWS] "=" [FWS] key-k-tag-type
key-k-tag-type   = "rsa" / x-key-k-tag-type
x-key-k-tag-type = hyphenated-word   ; for future extension]]></artwork>
                              </figure>
                           </t>
                        </list>
                     </t>


                     <t
                        hangText="n=">Notes that might be of interest to a human
                        (qp-section; OPTIONAL, default is empty). No
                        interpretation is made by any program. This tag should
                        be used sparingly in any key server mechanism that has
                        space limitations (notably DNS). This is intended for
                        use by administrators, not end users.</t>

                     <t>
                        <list>
                           <t>
                              <figure>
                                 <preamble>ABNF:</preamble>
                                 <artwork type="abnf"><![CDATA[key-n-tag    = %x6e [FWS] "=" [FWS] qp-section]]></artwork>
                              </figure>
                           </t>
                        </list>
                     </t>


                     <t
                        hangText="p=">Public-key data (base64; REQUIRED). An
                        empty value means that this public key has been revoked.
                        The syntax and semantics of this tag value before being
                        encoded in base64 are defined by the "k=" tag. <list>
                           <t>INFORMATIVE RATIONALE: If a private key has been
                              compromised or otherwise disabled (e.g., an
                              outsourcing contract has been terminated), a
                              signer might want to explicitly state that it
                              knows about the selector, but all messages using
                              that selector should fail verification. Verifiers
                              should ignore any DKIM-Signature header fields
                              with a selector referencing a revoked key.</t>
                        </list></t>

                     <t>
                        <list>
                           <t>
                              <figure>
                                 <preamble>ABNF:</preamble>
                                 <artwork type="abnf"><![CDATA[key-p-tag    = %x70 [FWS] "=" [ [FWS] base64string]]]></artwork>
                              </figure>
                           </t>

                           <t>INFORMATIVE NOTE: A base64string is permitted to
                              include white space (FWS) at arbitrary places;
                              however, any CRLFs must be followed by at least
                              one WSP character. Implementors and administrators
                              are cautioned to ensure that selector TXT records
                              conform to this specification.</t>
                        </list>
                     </t>


                     <t
                        hangText="s=">Service Type (plain-text; OPTIONAL;
                        default is "*"). A colon- separated list of service
                        types to which this record applies. Verifiers for a
                        given service type MUST ignore this record if the
                        appropriate type is not listed. <cref>errata 1381,
                           1382</cref> Unrecognized service types MUST be
                        ignored. Currently defined service types are as follows: </t>

                     <t><list
                           style="hanging">
                           <t
                              hangText="* ">matches all service types</t>
                           <t
                              hangText="email ">electronic mail (not necessarily
                              limited to SMTP)</t>
                        </list> This tag is intended to constrain the use of
                        keys for other purposes, should use of DKIM be defined
                        by other services in the future.</t>

                     <t>
                        <list>
                           <t>
                              <figure>
                                 <preamble>ABNF:</preamble>
                                 <artwork type="abnf"><![CDATA[key-s-tag        = %x73 [FWS] "=" [FWS] key-s-tag-type
                   0*( [FWS] ":" [FWS] key-s-tag-type )
key-s-tag-type   = "email" / "*" / x-key-s-tag-type
x-key-s-tag-type = hyphenated-word   ; for future extension]]></artwork>
                              </figure>
                           </t>
                        </list>
                     </t>


                     <t
                        hangText="t=">Flags, represented as a colon-separated
                        list of names (plain- text; OPTIONAL, default is no
                        flags set). <cref>errata 1381</cref> Unrecognized flags
                        MUST be ignored. The defined flags are as follows: </t>
                     <t
                        hangText="y ">This domain is testing DKIM. Verifiers
                        MUST NOT treat messages from signers in testing mode
                        differently from unsigned email, even should the
                        signature fail to verify. Verifiers MAY wish to track
                        testing mode results to assist the signer.</t>

                     <t
                        hangText="s ">Any DKIM-Signature header fields using the
                        "i=" tag MUST have the same domain value on the
                        right-hand side of the "@" in the "i=" tag and the value
                        of the "d=" tag. That is, the "i=" domain MUST NOT be a
                        subdomain of "d=". Use of this flag is RECOMMENDED
                        unless subdomaining is required.</t>


                     <t>
                        <list>
                           <t>
                              <figure>
                                 <preamble>ABNF:</preamble>
                                 <artwork type="abnf"><![CDATA[key-t-tag        = %x74 [FWS] "=" [FWS] key-t-tag-flag
                   0*( [FWS] ":" [FWS] key-t-tag-flag )
key-t-tag-flag   = "y" / "s" / x-key-t-tag-flag
x-key-t-tag-flag = hyphenated-word   ; for future extension]]></artwork>
                              </figure>
                           </t>
                        </list>
                     </t>

                     <t>Unrecognized flags MUST be ignored.</t>

                  </list>
               </t>

            </section>

            <section
               title="DNS Binding">

               <t>A binding using DNS TXT records as a key service is hereby
                  defined. All implementations MUST support this binding.</t>


               <section
                  title="Namespace">

                  <t>All DKIM keys are stored in a subdomain named "_domainkey".
                     Given a DKIM-Signature field with a "d=" tag of
                     "example.com" and an "s=" tag of "foo.bar", the DNS query
                     will be for "foo.bar._domainkey.example.com". <list>
                        <t>INFORMATIVE OPERATIONAL NOTE: Wildcard DNS records
                           (e.g., *.bar._domainkey.example.com) do not make
                           sense in this context and should not be used. Note
                           also that wildcards within domains (e.g.,
                           s._domainkey.*.example.com) are not supported by the
                           DNS.</t>
                     </list></t>
               </section>

               <section
                  title="Resource Record Types for Key Storage">

                  <t> The DNS Resource Record type used is specified by an
                     option to the query-type ("q=") tag. The only option
                     defined in this base specification is "txt", indicating the
                     use of a TXT Resource Record (RR). A later extension of
                     this standard may define another RR type.</t>

                  <t>Strings in a TXT RR MUST be concatenated together before
                     use with no intervening whitespace. TXT RRs MUST be unique
                     for a particular selector name; that is, if there are
                     multiple records in an RRset, the results are
                     undefined.</t>

                  <t>TXT RRs are encoded as described in <xref
                        target="textrep" /></t>

               </section>
            </section>

         </section>

         <section
            anchor="msghash"
            title="Computing the Message Hashes">

            <t>Both signing and verifying message signatures start with a step
               of computing two cryptographic hashes over the message. Signers
               will choose the parameters of the signature as described in
               Signer Actions <xref
                  target="signer" />; verifiers will use the parameters
               specified in the DKIM- Signature header field being verified. In
               the following discussion, the names of the tags in the
               DKIM-Signature header field that either exists (when verifying)
               or will be created (when signing) are used. Note that
               canonicalization (<xref
                  target="canon" />) is only used to prepare the email for
               signing or verifying; it does not affect the transmitted email in
               any way.</t>

            <t>The signer/verifier MUST compute two hashes, one over the body of
               the message and one over the selected header fields of the
               message.</t>


            <t>Signers MUST compute them in the order shown. Verifiers MAY
               compute them in any order convenient to the verifier, provided
               that the result is semantically identical to the semantics that
               would be the case had they been computed in this order.</t>

            <t>In hash step 1, the signer/verifier MUST hash the message body,
               canonicalized using the body canonicalization algorithm specified
               in the "c=" tag and then truncated to the length specified in the
               "l=" tag. That hash value is then converted to base64 form and
               inserted into (signers) or compared to (verifiers) the "bh=" tag
               of the DKIM- Signature header field.</t>

            <t>In hash step 2, the signer/verifier MUST pass the following to
               the hash algorithm in the indicated order. <list
                  style="numbers">
                  <t>The header fields specified by the "h=" tag, in the order
                     specified in that tag, and canonicalized using the header
                     canonicalization algorithm specified in the "c=" tag. Each
                     header field MUST be terminated with a single CRLF. </t>
                  <t>The DKIM-Signature header field that exists (verifying) or
                     will be inserted (signing) in the message, with the value
                     of the "b=" tag (including all surrounding whitespace)
                     deleted (i.e., treated as the empty string), canonicalized
                     using the header canonicalization algorithm specified in
                     the "c=" tag, and without a trailing CRLF. </t>
               </list></t>

            <t>All tags and their values in the DKIM-Signature header field are
               included in the cryptographic hash with the sole exception of the
               value portion of the "b=" (signature) tag, which MUST be treated
               as the null string. All tags MUST be included even if they might
               not be understood by the verifier. The header field MUST be
               presented to the hash algorithm after the body of the message
               rather than with the rest of the header fields and MUST be
               canonicalized as specified in the "c=" (canonicalization) tag.
               The DKIM-Signature header field MUST NOT be included in its own
               h= tag, although other DKIM-Signature header fields MAY be signed
               (see <xref
                  target="multisig" />).</t>

            <t>When calculating the hash on messages that will be transmitted
               using base64 or quoted-printable encoding, signers MUST compute
               the hash after the encoding. Likewise, the verifier MUST
               incorporate the values into the hash before decoding the base64
               or quoted-printable text. However, the hash MUST be computed
               before transport level encodings such as SMTP "dot-stuffing" (the
               modification of lines beginning with a "." to avoid confusion
               with the SMTP end-of-message marker, as specified in <xref
                  target="RFC5321" />).</t>

            <t>With the exception of the canonicalization procedure described in <xref
                  target="canon" />, the DKIM signing process treats the body of
               messages as simply a string of octets. DKIM messages MAY be
               either in plain-text or in MIME format; no special treatment is
               afforded to MIME content. Message attachments in MIME format MUST
               be included in the content that is signed.</t>

            <t>
               <list>
                  <t><figure>
                        <preamble>More formally, the ABNF of the algorithm for the signature
                           is as follows:</preamble>
                        <artwork type="abnf"><![CDATA[body-hash =  bh-hash-alg (canon-body, l-param)
data-hash    =  a-hash-alg (h-headers, D-SIG, content-hash) 
signature    =  sig-alg (d-domain, selector, data-hash) ]]></artwork>
                     </figure>
                  </t>

                  <t>where: <list
                        style="hanging">
                        <t
                           hangText="body-hash:  ">is the output of a
                           function to hash the Body.</t>
                        <t
                           hangText="bh-hash-alg:  ">is the hashing algorithm
                           specified in the "bh" parameter.</t>
                        <t
                           hangText="canon-body:  ">is a canonicalized
                           representation of the body.</t>
                        <t
                           hangText="l-param:  ">is the value of the l= length
                           parameter.</t>
                        <t
                           hangText="data-hash:  ">is the output from hashing
                           the header, the DOSETA&nbhy;Signature header, and the
                           Content hash.</t>
                        <t
                           hangText="a-hash-alg:  ">is the hash algorithm
                           specified by the "a=" tag, </t>
                        <t
                           hangText="h-headers:  ">is the list of headers to be
                           signed, as specified in the h= parameter.</t>
                        <t
                           hangText="D-SIG:  ">is the canonicalized
                           DOSETA&nbhy;Signature field sans the signature value
                           itself.</t>
                        <t
                           hangText="canon-body:  ">is the canonicalized
                           Body as defined in <xref
                              target="canon" /> (excluding the
                              DKIM&nbhy;Signature field). </t>
                        <t
                           hangText="signature:  ">is the signature value
                           produced by the signing algorithm.</t>
                        <t
                           hangText="sig-alg:  ">is the signature algorithm
                           specified by the "a=" tag, </t>
                        <t
                           hangText="d-domain:  ">is the domain name specified
                           in the d= parameter.</t>
                        <t
                           hangText="selector:  ">is the value of the s=
                           selector parameter </t>
                     </list></t>
               </list>
               <list
                  style="hanging">
                  <t
                     hangText="NOTE:  ">Many digital signature APIs provide both
                     hashing and application of the RSA private key using a
                     single "sign()" primitive. When using such an API, the last
                     two steps in the algorithm would probably be combined into
                     a single call that would perform both the "a-hash-alg" and
                     the "sig-alg".</t>
               </list></t>
         </section>

         <section
            anchor="parentsig"
            title="Signing by Parent Domains">

            <t>In some circumstances, it is desirable for a domain to apply a
               signature on behalf of any of its subdomains without the need to
               maintain separate selectors (key records) in each subdomain. By
               default, private keys corresponding to key records can be used to
               sign messages for any subdomain of the domain in which they
               reside; for example, a key record for the domain example.com can
               be used to verify messages where the AUID ("i=" tag of the
               signature) is sub.example.com, or even sub1.sub2.example.com. In
               order to limit the capability of such keys when this is not
               intended, the "s" flag MAY be set in the "t=" tag of the key
               record, to constrain the validity of the domain of the AUID. If
               the referenced key record contains the "s" flag as part of the
               "t=" tag, the domain of the AUID ("i=" flag) MUST be the same as
               that of the SDID (d=) domain. If this flag is absent, the domain
               of the AUID MUST be the same as, or a subdomain of, the SDID.</t>
         </section>

         <section
            title="Relationship between SDID and AUID">

            <t>DKIM's primary task is to communicate from the Signer to a
               recipient-side Identity Assessor a single Signing Domain
               Identifier (SDID) that refers to a responsible identity. DKIM MAY
               optionally provide a single responsible Agent or User Identifier
               (AUID).</t>

            <t>Hence, DKIM's mandatory output to a receive-side Identity
               Assessor is a single domain name. Within the scope of its use as
               DKIM output, the name has only basic domain name semantics; any
               possible owner-specific semantics are outside the scope of DKIM.
               That is, within its role as a DKIM identifier, additional
               semantics cannot be assumed by an Identity Assessor.</t>

            <t>Upon successfully verifying the signature, a receive-side DKIM
               verifier MUST communicate the Signing Domain Identifier (d=) to a
               consuming Identity Assessor module and MAY communicate the Agent
               or User Identifier (i=) if present.</t>

            <t>To the extent that a receiver attempts to intuit any structured
               semantics for either of the identifiers, this is a heuristic
               function that is outside the scope of DKIM's specification and
               semantics. Hence, it is relegated to a higher-level service, such
               as a delivery handling filter that integrates a variety of inputs
               and performs heuristic analysis of them. <list>
                  <t>INFORMATIVE DISCUSSION: This document does not require the
                     value of the SDID or AUID to match an identifier in any
                     other message header field. This requirement is, instead,
                     an assessor policy issue. The purpose of such a linkage
                     would be to authenticate the value in that other header
                     field. This, in turn, is the basis for applying a trust
                     assessment based on the identifier value. Trust is a broad
                     and complex topic and trust mechanisms are subject to
                     highly creative attacks. The real-world efficacy of any but
                     the most basic bindings between the SDID or AUID and other
                     identities is not well established, nor is its
                     vulnerability to subversion by an attacker. Hence, reliance
                     on the use of such bindings should be strictly limited. In
                     particular, it is not at all clear to what extent a typical
                     end-user recipient can rely on any assurances that might be
                     made by successful use of the SDID or AUID.</t>
               </list></t>
         </section>

      </section>


      <section
         anchor="multisig"
         title="Semantics of Multiple Signatures">

         <section
            title="Example Scenarios">

            <t>There are many reasons why a message might have multiple
               signatures. For example, a given signer might sign multiple
               times, perhaps with different hashing or signing algorithms
               during a transition phase. <list>
                  <t>INFORMATIVE EXAMPLE: Suppose SHA-256 is in the future found
                     to be insufficiently strong, and DKIM usage transitions to
                     SHA-1024. A signer might immediately sign using the newer
                     algorithm, but continue to sign using the older algorithm
                     for interoperability with verifiers that had not yet
                     upgraded. The signer would do this by adding two
                     DKIM-Signature header fields, one using each algorithm.
                     Older verifiers that did not recognize SHA-1024 as an
                     acceptable algorithm would skip that signature and use the
                     older algorithm; newer verifiers could use either signature
                     at their option, and all other things being equal might not
                     even attempt to verify the other signature.</t>
               </list></t>

            <t>Similarly, a signer might sign a message including all headers
               and no "l=" tag (to satisfy strict verifiers) and a second time
               with a limited set of headers and an "l=" tag (in anticipation of
               possible message modifications in route to other verifiers).
               Verifiers could then choose which signature they preferred. <list>
                  <t>INFORMATIVE EXAMPLE: A verifier might receive a message
                     with two signatures, one covering more of the message than
                     the other. If the signature covering more of the message
                     verified, then the verifier could make one set of policy
                     decisions; if that signature failed but the signature
                     covering less of the message verified, the verifier might
                     make a different set of policy decisions.</t>
               </list></t>

            <t>Of course, a message might also have multiple signatures because
               it passed through multiple signers. A common case is expected to
               be that of a signed message that passes through a mailing list
               that also signs all messages. Assuming both of those signatures
               verify, a recipient might choose to accept the message if either
               of those signatures were known to come from trusted sources. <list>
                  <t>INFORMATIVE EXAMPLE: Recipients might choose to whitelist
                     mailing lists to which they have subscribed and that have
                     acceptable anti- abuse policies so as to accept messages
                     sent to that list even from unknown authors. They might
                     also subscribe to less trusted mailing lists (e.g., those
                     without anti-abuse protection) and be willing to accept all
                     messages from specific authors, but insist on doing
                     additional abuse scanning for other messages.</t>
               </list></t>


            <t>Another related example of multiple signers might be forwarding
               services, such as those commonly associated with academic alumni
               sites. <list>
                  <t>INFORMATIVE EXAMPLE: A recipient might have an address at
                     members.example.org, a site that has anti-abuse protection
                     that is somewhat less effective than the recipient would
                     prefer. Such a recipient might have specific authors whose
                     messages would be trusted absolutely, but messages from
                     unknown authors that had passed the forwarder's scrutiny
                     would have only medium trust.</t>
               </list></t>
         </section>

         <section
            title="Interpretation">

            <t>A signer that is adding a signature to a message merely creates a
               new DKIM-Signature header, using the usual semantics of the h=
               option. A signer MAY sign previously existing DKIM-Signature
               header fields using the method described in <xref
                  target="fields2sign" /> to sign trace header fields. <list>
                  <t>INFORMATIVE NOTE: Signers should be cognizant that signing
                     DKIM- Signature header fields may result in signature
                     failures with intermediaries that do not recognize that
                     DKIM-Signature header fields are trace header fields and
                     unwittingly reorder them, thus breaking such signatures.
                     For this reason, signing existing DKIM- Signature header
                     fields is unadvised, albeit legal.</t>
                  <t>INFORMATIVE NOTE: If a header field with multiple instances
                     is signed, those header fields are always signed from the
                     bottom up. Thus, it is not possible to sign only specific
                     DKIM-Signature header fields. For example, if the message
                     being signed already contains three DKIM-Signature header
                     fields A, B, and C, it is possible to sign all of them, B
                     and C only, or C only, but not A only, B only, A and B
                     only, or A and C only.</t>
               </list></t>

            <t>A signer MAY add more than one DKIM-Signature header field using
               different parameters. For example, during a transition period a
               signer might want to produce signatures using two different hash
               algorithms.</t>

            <t>Signers SHOULD NOT remove any DKIM-Signature header fields from
               messages they are signing, even if they know that the signatures
               cannot be verified.</t>

            <t>When evaluating a message with multiple signatures, a verifier
               SHOULD evaluate signatures independently and on their own merits.
               For example, a verifier that by policy chooses not to accept
               signatures with deprecated cryptographic algorithms would
               consider such signatures invalid. Verifiers MAY process
               signatures in any order of their choice; for example, some
               verifiers might choose to process signatures corresponding to the
               From field in the message header before other signatures. See <xref
                  target="extractsig" /> for more information about signature
               choices. <list>
                  <t>INFORMATIVE IMPLEMENTATION NOTE: Verifier attempts to
                     correlate valid signatures with invalid signatures in an
                     attempt to guess why a signature failed are ill-advised. In
                     particular, there is no general way that a verifier can
                     determine that an invalid signature was ever valid.</t>
               </list></t>

            <t>Verifiers SHOULD ignore failed signatures as though they were not
               present in the message. Verifiers SHOULD continue to check
               signatures until a signature successfully verifies to the
               satisfaction of the verifier. To limit potential
               denial-of-service attacks, verifiers MAY limit the total number
               of signatures they will attempt to verify.</t>
         </section>
      </section>


      <section
         anchor="signer"
         title="Signer Actions">

         <t>The following steps are performed in order by signers.</t>

         <section
            title="Determine Whether the Email Should Be Signed and by Whom">

            <t>A signer can obviously only sign email for domains for which it
               has a private key and the necessary knowledge of the
               corresponding public key and selector information. However, there
               are a number of other reasons beyond the lack of a private key
               why a signer could choose not to sign an email. <list>
                  <t>INFORMATIVE NOTE: Signing modules may be incorporated into
                     any portion of the mail system as deemed appropriate,
                     including an MUA, a SUBMISSION server, or an MTA. Wherever
                     implemented, signers should beware of signing (and thereby
                     asserting responsibility for) messages that may be
                     problematic. In particular, within a trusted enclave the
                     signing address might be derived from the header according
                     to local policy; SUBMISSION servers might only sign
                     messages from users that are properly authenticated and
                     authorized.</t>
                  <t>INFORMATIVE IMPLEMENTER ADVICE: SUBMISSION servers should
                     not sign Received header fields if the outgoing gateway MTA
                     obfuscates Received header fields, for example, to hide the
                     details of internal topology.</t>
               </list></t>

            <t>If an email cannot be signed for some reason, it is a local
               policy decision as to what to do with that email.</t>
         </section>

         <section
            anchor="selectpriv"
            title="Select a Private Key and Corresponding Selector Information">

            <t>This specification does not define the basis by which a signer
               should choose which private key and selector information to use.
               Currently, all selectors are equal as far as this specification
               is concerned, so the decision should largely be a matter of
               administrative convenience. Distribution and management of
               private keys is also outside the scope of this document. <list>
                  <t>INFORMATIVE OPERATIONS ADVICE: A signer should not sign
                     with a private key when the selector containing the
                     corresponding public key is expected to be revoked or
                     removed before the verifier has an opportunity to validate
                     the signature. The signer should anticipate that verifiers
                     may choose to defer validation, perhaps until the message
                     is actually read by the final recipient. In particular,
                     when rotating to a new key pair, signing should immediately
                     commence with the new private key and the old public key
                     should be retained for a reasonable validation interval
                     before being removed from the key server.</t>
               </list></t>
         </section>

         <section
            anchor="normalize"
            title="Normalize the Message to Prevent Transport Conversions">

            <t>Some messages, particularly those using 8-bit characters, are
               subject to modification during transit, notably conversion to
               7-bit form. Such conversions will break DKIM signatures. In order
               to minimize the chances of such breakage, signers SHOULD convert
               the message to a suitable MIME content transfer encoding such as
               quoted-printable or base64 as described in <xref
                  target="RFC2045" /> before signing. Such conversion is outside
               the scope of DKIM; the actual message SHOULD be converted to
               7-bit MIME by an MUA or MSA prior to presentation to the DKIM
               algorithm.</t>
            <t>Similarly, a message that is not compliant with RFC5322, RFC2045
               and RFC2047, can be subject to attempts by intermediaries to
               correct or interpret such content. See Section 8 of <xref
                  target="RFC4409" /> for examples of changes that are commonly
               made. Such "corrections" may break DKIM signatures or have other
               undesirable effects. Therefore, a verifier SHOULD NOT validate a
               message that is not compliant with those specifications. </t>

            <t>If the message is submitted to the signer with any local encoding
               that will be modified before transmission, that modification to
               canonical <xref
                  target="RFC5322" /> form MUST be done before signing. In
               particular, bare CR or LF characters (used by some systems as a
               local line separator convention) MUST be converted to the
               SMTP-standard CRLF sequence before the message is signed. Any
               conversion of this sort SHOULD be applied to the message actually
               sent to the recipient(s), not just to the version presented to
               the signing algorithm.</t>

            <t>More generally, the signer MUST sign the message as it is
               expected to be received by the verifier rather than in some local
               or internal form.</t>
         </section>

         <section
            anchor="fields2sign"
            title="Determine the Header Fields to Sign">

            <t>The From header field MUST be signed (that is, included in the
               "h=" tag of the resulting DKIM-Signature header field). Signers
               SHOULD NOT sign an existing header field likely to be
               legitimately modified or removed in transit. In particular, <xref
                  target="RFC5321" /> explicitly permits modification or removal
               of the Return-Path header field in transit. Signers MAY include
               any other header fields present at the time of signing at the
               discretion of the signer. <list>
                  <t>INFORMATIVE OPERATIONS NOTE: The choice of which header
                     fields to sign is non-obvious. One strategy is to sign all
                     existing, non- repeatable header fields. An alternative
                     strategy is to sign only header fields that are likely to
                     be displayed to or otherwise be likely to affect the
                     processing of the message at the receiver. A third strategy
                     is to sign only "well known" headers. Note that verifiers
                     may treat unsigned header fields with extreme skepticism,
                     including refusing to display them to the end user or even
                     ignoring the signature if it does not cover certain header
                     fields. For this reason, signing fields present in the
                     message such as Date, Subject, Reply-To, Sender, and all
                     MIME header fields are highly advised.</t>
               </list></t>

            <t> The DKIM-Signature header field is always implicitly signed and
               MUST NOT be included in the "h=" tag except to indicate that
               other preexisting signatures are also signed.</t>

            <t>Signers MAY claim to have signed header fields that do not exist
               (that is, signers MAY include the header field name in the "h="
               tag even if that header field does not exist in the message).
               When computing the signature, the non-existing header field MUST
               be treated as the null string (including the header field name,
               header field value, all punctuation, and the trailing CRLF). <list>
                  <t>INFORMATIVE RATIONALE: This allows signers to explicitly
                     assert the absence of a header field; if that header field
                     is added later the signature will fail.</t>
                  <t>INFORMATIVE NOTE: A header field name need only be listed
                     once more than the actual number of that header field in a
                     message at the time of signing in order to prevent any
                     further additions. For example, if there is a single
                     Comments header field at the time of signing, listing
                     Comments twice in the "h=" tag is sufficient to prevent any
                     number of Comments header fields from being appended; it is
                     not necessary (but is legal) to list Comments three or more
                     times in the "h=" tag.</t>
               </list></t>


            <t>Signers choosing to sign an existing header field that occurs
               more than once in the message (such as Received) MUST sign the
               physically last instance of that header field in the header
               block. Signers wishing to sign multiple instances of such a
               header field MUST include the header field name multiple times in
               the h= tag of the DKIM-Signature header field, and MUST sign such
               header fields in order from the bottom of the header field block
               to the top. The signer MAY include more instances of a header
               field name in h= than there are actual corresponding header
               fields to indicate that additional header fields of that name
               SHOULD NOT be added. <list>
                  <t>INFORMATIVE EXAMPLE:</t>
                  <t>If the signer wishes to sign two existing Received header
                     fields, and the existing header contains: <figure
                        align="left">
                        <artwork><![CDATA[Received: <A>
Received: <B>
Received: <c> ]]></artwork>
                     </figure>
                     <figure
                        align="left">
                        <preamble>then the resulting DKIM-Signature header field
                           should read:</preamble>
                        <artwork><![CDATA[
DKIM-Signature: ... h=Received : Received :...]]></artwork>
                     </figure> and Received header fields &lt;C&gt; and
                     &lt;B&gt; will be signed in that order.</t>
               </list></t>

            <t>Signers should be careful of signing header fields that might
               have additional instances added later in the delivery process,
               since such header fields might be inserted after the signed
               instance or otherwise reordered. Trace header fields (such as
               Received) and Resent-* blocks are the only fields prohibited by <xref
                  target="RFC5322" /> from being reordered. In particular, since
               DKIM-Signature header fields may be reordered by some
               intermediate MTAs, signing existing DKIM- Signature header fields
               is error-prone. <list>
                  <t>INFORMATIVE ADMONITION: Despite the fact that <xref
                        target="RFC5322" /> permits header fields to be
                     reordered (with the exception of Received header fields),
                     reordering of signed header fields with multiple instances
                     by intermediate MTAs will cause DKIM signatures to be
                     broken; such anti-social behavior should be avoided.</t>
                  <t>INFORMATIVE IMPLEMENTER'S NOTE: Although not required by
                     this specification, all end-user visible header fields
                     should be signed to avoid possible "indirect spamming". For
                     example, if the Subject header field is not signed, a
                     spammer can resend a previously signed mail, replacing the
                     legitimate subject with a one-line spam.</t>
               </list></t>
         </section>

         <section
            title="Recommended Signature Content">

            <t>In order to maximize compatibility with a variety of verifiers,
               it is recommended that signers follow the practices outlined in
               this section when signing a message. However, these are generic
               recommendations applying to the general case; specific senders
               may wish to modify these guidelines as required by their unique
               situations. Verifiers MUST be capable of verifying signatures
               even if one or more of the recommended header fields is not
               signed (with the exception of From, which must always be signed)
               or if one or more of the dis-recommended header fields is signed.
               Note that verifiers do have the option of ignoring signatures
               that do not cover a sufficient portion of the header or body,
               just as they may ignore signatures from an identity they do not
               trust.</t>

            <t>The following header fields SHOULD be included in the signature,
               if they are present in the message being signed: <list
                  style="symbols">
                  <t>From (REQUIRED in all signatures)</t>
                  <t>Sender, Reply-To</t>
                  <t>Subject</t>
                  <t>Date, Message-ID</t>
                  <t>To, Cc</t>
                  <t>MIME-Version</t>
                  <t>Content-Type, Content-Transfer-Encoding, Content-ID,
                     Content- Description</t>
                  <t>Resent-Date, Resent-From, Resent-Sender, Resent-To,
                     Resent-Cc, Resent-Message-ID</t>
                  <t>In-Reply-To, References</t>
                  <t>List-Id, List-Help, List-Unsubscribe, List-Subscribe,
                     List-Post, List-Owner, List-Archive</t>
               </list></t>

            <t>The following header fields SHOULD NOT be included in the
               signature: <list
                  style="symbols">
                  <t>Return-Path</t>
                  <t>Received</t>
                  <t>Comments, Keywords</t>
                  <t>Bcc, Resent-Bcc</t>
                  <t>DKIM-Signature</t>
               </list></t>

            <t>Optional header fields (those not mentioned above) normally
               SHOULD NOT be included in the signature, because of the potential
               for additional header fields of the same name to be legitimately
               added or reordered prior to verification. There are likely to be
               legitimate exceptions to this rule, because of the wide variety
               of application- specific header fields that may be applied to a
               message, some of which are unlikely to be duplicated, modified,
               or reordered.</t>

            <t>Signers SHOULD choose canonicalization algorithms based on the
               types of messages they process and their aversion to risk. For
               example, e-commerce sites sending primarily purchase receipts,
               which are not expected to be processed by mailing lists or other
               software likely to modify messages, will generally prefer
               "simple" canonicalization. Sites sending primarily
               person-to-person email will likely prefer to be more resilient to
               modification during transport by using "relaxed"
               canonicalization.</t>

            <t>Signers SHOULD NOT use "l=" unless they intend to accommodate
               intermediate mail processors that append text to a message. For
               example, many mailing list processors append "unsubscribe"
               information to message bodies. If signers use "l=", they SHOULD
               include the entire message body existing at the time of signing
               in computing the count. In particular, signers SHOULD NOT specify
               a body length of 0 since this may be interpreted as a meaningless
               signature by some verifiers.</t>
         </section>

         <section
            title="Compute the Message Hash and Signature">

            <t>The signer MUST compute the message hash as described in <xref
                  target="msghash" /> and then sign it using the selected
               public-key algorithm. This will result in a DKIM-Signature header
               field that will include the body hash and a signature of the
               header hash, where that header includes the DKIM-Signature header
               field itself.</t>

            <t>Entities such as mailing list managers that implement DKIM and
               that modify the message or a header field (for example, inserting
               unsubscribe information) before retransmitting the message SHOULD
               check any existing signature on input and MUST make such
               modifications before re-signing the message.</t>

            <t> The signer MAY elect to limit the number of bytes of the body
               that will be included in the hash and hence signed. The length
               actually hashed should be inserted in the "l=" tag of the
               DKIM-Signature header field.</t>
         </section>


         <section
            title="Insert the DKIM-Signature Header Field">

            <t>Finally, the signer MUST insert the DKIM-Signature header field
               created in the previous step prior to transmitting the email. The
               DKIM-Signature header field MUST be the same as used to compute
               the hash as described above, except that the value of the "b="
               tag MUST be the appropriately signed hash computed in the
               previous step, signed using the algorithm specified in the "a="
               tag of the DKIM- Signature header field and using the private key
               corresponding to the selector given in the "s=" tag of the
               DKIM-Signature header field, as chosen above in <xref
                  target="selectpriv" /></t>

            <t>The DKIM-Signature header field MUST be inserted before any other
               DKIM-Signature fields in the header block. <list>
                  <t>INFORMATIVE IMPLEMENTATION NOTE: The easiest way to achieve
                     this is to insert the DKIM-Signature header field at the
                     beginning of the header block. In particular, it may be
                     placed before any existing Received header fields. This is
                     consistent with treating DKIM-Signature as a trace header
                     field.</t>
               </list></t>
         </section>
      </section>


      <section
         anchor="verifier"
         title="Verifier Actions">

         <t>Since a signer MAY remove or revoke a public key at any time, it is
            recommended that verification occur in a timely manner. In many
            configurations, the most timely place is during acceptance by the
            border MTA or shortly thereafter. In particular, deferring
            verification until the message is accessed by the end user is
            discouraged.</t>

         <t>A border or intermediate MTA MAY verify the message signature(s). An
            MTA who has performed verification MAY communicate the result of
            that verification by adding a verification header field to incoming
            messages. This considerably simplifies things for the user, who can
            now use an existing mail user agent. Most MUAs have the ability to
            filter messages based on message header fields or content; these
            filters would be used to implement whatever policy the user wishes
            with respect to unsigned mail.</t>

         <t>A verifying MTA MAY implement a policy with respect to unverifiable
            mail, regardless of whether or not it applies the verification
            header field to signed messages.</t>

         <t>Verifiers MUST produce a result that is semantically equivalent to
            applying the following steps in the order listed. In practice,
            several of these steps can be performed in parallel in order to
            improve performance.</t>


         <section
            anchor="extractsig"
            title="Extract Signatures from the Message">

            <t> The order in which verifiers try DKIM-Signature header fields is
               not defined; verifiers MAY try signatures in any order they like.
               For example, one implementation might try the signatures in
               textual order, whereas another might try signatures by identities
               that match the contents of the From header field before trying
               other signatures. Verifiers MUST NOT attribute ultimate meaning
               to the order of multiple DKIM-Signature header fields. In
               particular, there is reason to believe that some relays will
               reorder the header fields in potentially arbitrary ways. <list>
                  <t>INFORMATIVE IMPLEMENTATION NOTE: Verifiers might use the
                     order as a clue to signing order in the absence of any
                     other information. However, other clues as to the semantics
                     of multiple signatures (such as correlating the signing
                     host with Received header fields) may also be
                     considered.</t>
               </list></t>

            <t>A verifier SHOULD NOT treat a message that has one or more bad
               signatures and no good signatures differently from a message with
               no signature at all; such treatment is a matter of local policy
               and is beyond the scope of this document.</t>

            <t>When a signature successfully verifies, a verifier will either
               stop processing or attempt to verify any other signatures, at the
               discretion of the implementation. A verifier MAY limit the number
               of signatures it tries to avoid denial-of-service attacks. <list>
                  <t>INFORMATIVE NOTE: An attacker could send messages with
                     large numbers of faulty signatures, each of which would
                     require a DNS lookup and corresponding CPU time to verify
                     the message. This could be an attack on the domain that
                     receives the message, by slowing down the verifier by
                     requiring it to do a large number of DNS lookups and/or
                     signature verifications. It could also be an attack against
                     the domains listed in the signatures, essentially by
                     enlisting innocent verifiers in launching an attack against
                     the DNS servers of the actual victim.</t>
               </list></t>

            <t>In the following description, text reading "return status
               (explanation)" (where "status" is one of "PERMFAIL" or
               "TEMPFAIL") means that the verifier MUST immediately cease
               processing that signature. The verifier SHOULD proceed to the
               next signature, if any is present, and completely ignore the bad
               signature. If the status is "PERMFAIL", the signature failed and
               should not be reconsidered. If the status is "TEMPFAIL", the
               signature could not be verified at this time but may be tried
               again later. A verifier MAY either defer the message for later
               processing, perhaps by queueing it locally or issuing a 451/4.7.5
               SMTP reply, or try another signature; if no good signature is
               found and any of the signatures resulted in a TEMPFAIL status,
               the verifier MAY save the message for later processing. The
               "(explanation)" is not normative text; it is provided solely for
               clarification.</t>

            <t>Verifiers SHOULD ignore any DKIM-Signature header fields where
               the signature does not validate. Verifiers that are prepared to
               validate multiple signature header fields SHOULD proceed to the
               next signature header field, should it exist. However, verifiers
               MAY make note of the fact that an invalid signature was present
               for consideration at a later step. <list>
                  <t>INFORMATIVE NOTE: The rationale of this requirement is to
                     permit messages that have invalid signatures but also a
                     valid signature to work. For example, a mailing list
                     exploder might opt to leave the original submitter
                     signature in place even though the exploder knows that it
                     is modifying the message in some way that will break that
                     signature, and the exploder inserts its own signature. In
                     this case, the message should succeed even in the presence
                     of the known-broken signature.</t>
               </list></t>

            <t>For each signature to be validated, the following steps should be
               performed in such a manner as to produce a result that is
               semantically equivalent to performing them in the indicated
               order.</t>


            <section
               anchor="validatesig"
               title="Validate the Signature Header Field">

               <t>Implementers MUST meticulously validate the format and values
                  in the DKIM-Signature header field; any inconsistency or
                  unexpected values MUST cause the header field to be completely
                  ignored and the verifier to return PERMFAIL (signature syntax
                  error). Being "liberal in what you accept" is definitely a bad
                  strategy in this security context. Note however that this does
                  not include the existence of unknown tags in a DKIM-Signature
                  header field, which are explicitly permitted. Verifiers MUST
                  ignore DKIM-Signature header fields with a "v=" tag that is
                  inconsistent with this specification and return PERMFAIL
                  (incompatible version). <list>
                     <t>INFORMATIVE IMPLEMENTATION NOTE: An implementation may,
                        of course, choose to also verify signatures generated by
                        older versions of this specification.</t>
                  </list></t>

               <t>If any tag listed as "required" in <xref
                     target="dkimsighead" /> is omitted from the DKIM-Signature
                  header field, the verifier MUST ignore the DKIM- Signature
                  header field and return PERMFAIL (signature missing required
                  tag). <list>
                     <t>INFORMATIONAL NOTE: The tags listed as required in <xref
                           target="dkimsighead" /> are "v=", "a=", "b=", "bh=",
                        "d=", "h=", and "s=". Should there be a conflict between
                        this note and <xref
                           target="dkimsighead" />, <xref
                           target="dkimsighead" /> is normative.</t>
                  </list></t>

               <t>If the DKIM-Signature header field does not contain the "i="
                  tag, the verifier MUST behave as though the value of that tag
                  were "@d", where "d" is the value from the "d=" tag.</t>

               <t>Verifiers MUST confirm that the domain specified in the "d="
                  tag is the same as or a parent domain of the domain part of
                  the "i=" tag. If not, the DKIM-Signature header field MUST be
                  ignored and the verifier should return PERMFAIL (domain
                  mismatch).</t>

               <t>If the "h=" tag does not include the From header field, the
                  verifier MUST ignore the DKIM-Signature header field and
                  return PERMFAIL (From field not signed).</t>

               <t>Verifiers MAY ignore the DKIM-Signature header field and
                  return PERMFAIL (signature expired) if it contains an "x=" tag
                  and the signature has expired.</t>

               <t>Verifiers MAY ignore the DKIM-Signature header field if the
                  domain used by the signer in the "d=" tag is not associated
                  with a valid signing entity. For example, signatures with "d="
                  values such as "com" and "co.uk" may be ignored. The list of
                  unacceptable domains SHOULD be configurable.</t>

               <t>Verifiers MAY ignore the DKIM-Signature header field and
                  return PERMFAIL (unacceptable signature header) for any other
                  reason, for example, if the signature does not sign header
                  fields that the verifier views to be essential. As a case in
                  point, if MIME header fields are not signed, certain attacks
                  may be possible that the verifier would prefer to avoid.</t>
            </section>

            <section
               title="Get the Public Key">

               <t>The public key for a signature is needed to complete the
                  verification process. The process of retrieving the public key
                  depends on the query type as defined by the "q=" tag in the
                  DKIM-Signature header field. Obviously, a public key need only
                  be retrieved if the process of extracting the signature
                  information is completely successful. Details of key
                  management and representation are described in <xref
                     target="keymgmt" />. The verifier MUST validate the key
                  record and MUST ignore any public key records that are
                  malformed.</t>

               <t>
                  <list
                     style="hanging">
                     <t
                        hangText="NOTE:"> The use of wildcard TXT records in the
                        DNS will produce a response to a DKIM query that is
                        unlikely to be valid DKIM key record. This problem
                        applies to many other types of queries, and client
                        software that processes DNS responses needs to take this
                        problem into account.</t>
                  </list>
               </t>

               <t>When validating a message, a verifier MUST perform the
                  following steps in a manner that is semantically the same as
                  performing them in the order indicated -- in some cases the
                  implementation may parallelize or reorder these steps, as long
                  as the semantics remain unchanged: <list
                     style="numbers">
                     <t>Retrieve the public key as described in <xref
                           target="keymgmt" /> using the algorithm in the "q="
                        tag, the domain from the "d=" tag, and the selector from
                        the "s=" tag.</t>
                     <t>If the query for the public key fails to respond, the
                        verifier MAY defer acceptance of this email and return
                        TEMPFAIL (key unavailable). If verification is occurring
                        during the incoming SMTP session, this MAY be achieved
                        with a 451/4.7.5 SMTP reply code. Alternatively, the
                        verifier MAY store the message in the local queue for
                        later trial or ignore the signature. Note that storing a
                        message in the local queue is subject to denial-of-
                        service attacks.</t>
                     <t> If the query for the public key fails because the
                        corresponding key record does not exist, the verifier
                        MUST immediately return PERMFAIL (no key for
                        signature).</t>
                     <t>If the query for the public key returns multiple key
                        records, the verifier may choose one of the key records
                        or may cycle through the key records performing the
                        remainder of these steps on each record at the
                        discretion of the implementer. The order of the key
                        records is unspecified. If the verifier chooses to cycle
                        through the key records, then the "return ..." wording
                        in the remainder of this section means "try the next key
                        record, if any; if none, return to try another signature
                        in the usual way".</t>
                     <t>If the result returned from the query does not adhere to
                        the format defined in this specification, the verifier
                        MUST ignore the key record and return PERMFAIL (key
                        syntax error). Verifiers are urged to validate the
                        syntax of key records carefully to avoid attempted
                        attacks. In particular, the verifier MUST ignore keys
                        with a version code ("v=" tag) that they do not
                        implement.</t>
                     <t>If the "h=" tag exists in the public key record and the
                        hash algorithm implied by the a= tag in the
                        DKIM-Signature header field is not included in the
                        contents of the "h=" tag, the verifier MUST ignore the
                        key record and return PERMFAIL (inappropriate hash
                        algorithm).</t>
                     <t>If the public key data (the "p=" tag) is empty, then
                        this key has been revoked and the verifier MUST treat
                        this as a failed signature check and return PERMFAIL
                        (key revoked). There is no defined semantic difference
                        between a key that has been revoked and a key record
                        that has been removed.</t>
                     <t>If the public key data is not suitable for use with the
                        algorithm and key types defined by the "a=" and "k="
                        tags in the DKIM- Signature header field, the verifier
                        MUST immediately return PERMFAIL (inappropriate key
                        algorithm).</t>
                  </list></t>
            </section>

            <section
               title="Compute the Verification">

               <t>Given a signer and a public key, verifying a signature
                  consists of actions semantically equivalent to the following
                  steps. <list
                     style="numbers">
                     <t>Based on the algorithm defined in the "c=" tag, the body
                        length specified in the "l=" tag, and the header field
                        names in the "h=" tag, prepare a canonicalized version
                        of the message as is described in <xref
                           target="msghash" /> (note that this version does not
                        actually need to be instantiated). When matching header
                        field names in the "h=" tag against the actual message
                        header field, comparisons MUST be case-insensitive.</t>
                     <t>Based on the algorithm indicated in the "a=" tag,
                        compute the message hashes from the canonical copy as
                        described in <xref
                           target="msghash" />.</t>
                     <t>Verify that the hash of the canonicalized message body
                        computed in the previous step matches the hash value
                        conveyed in the "bh=" tag. If the hash does not match,
                        the verifier SHOULD ignore the signature and return
                        PERMFAIL (body hash did not verify).</t>
                     <t> Using the signature conveyed in the "b=" tag, verify
                        the signature against the header hash using the
                        mechanism appropriate for the public key algorithm
                        described in the "a=" tag. If the signature does not
                        validate, the verifier SHOULD ignore the signature and
                        return PERMFAIL (signature did not verify).</t>
                     <t>Otherwise, the signature has correctly verified.</t>
                  </list>
                  <list>
                     <t>INFORMATIVE IMPLEMENTER'S NOTE: Implementations might
                        wish to initiate the public-key query in parallel with
                        calculating the hash as the public key is not needed
                        until the final decryption is calculated.
                        Implementations may also verify the signature on the
                        message header before validating that the message hash
                        listed in the "bh=" tag in the DKIM-Signature header
                        field matches that of the actual message body; however,
                        if the body hash does not match, the entire signature
                        must be considered to have failed.</t>
                  </list>
               </t>

               <t>A body length specified in the "l=" tag of the signature
                  limits the number of bytes of the body passed to the
                  verification algorithm. All data beyond that limit is not
                  validated by DKIM. Hence, verifiers might treat a message that
                  contains bytes beyond the indicated body length with
                  suspicion, such as by truncating the message at the indicated
                  body length, declaring the signature invalid (e.g., by
                  returning PERMFAIL (unsigned content)), or conveying the
                  partial verification to the policy module. <list>
                     <t>INFORMATIVE IMPLEMENTATION NOTE: Verifiers that truncate
                        the body at the indicated body length might pass on a
                        malformed MIME message if the signer used the "N-4"
                        trick (omitting the final "--CRLF") described in the
                        informative note in <xref
                           target="bodylength" />. Such verifiers may wish to
                        check for this case and include a trailing "--CRLF" to
                        avoid breaking the MIME structure. A simple way to
                        achieve this might be to append "--CRLF" to any
                        "multipart" message with a body length; if the MIME
                        structure is already correctly formed, this will appear
                        in the postlude and will not be displayed to the end
                        user.</t>
                  </list></t>

            </section>
         </section>


         <section
            title="Communicate Verification Results">

            <t>Verifiers wishing to communicate the results of verification to
               other parts of the mail system may do so in whatever manner they
               see fit. For example, implementations might choose to add an
               email header field to the message before passing it on. Any such
               header field SHOULD be inserted before any existing
               DKIM-Signature or preexisting authentication status header fields
               in the header field block. The Authentication-Results: header
               field (<xref
                  target="RFC5451" />) MAY be used for this purpose. <list>
                  <t>INFORMATIVE ADVICE to MUA filter writers: Patterns intended
                     to search for results header fields to visibly mark
                     authenticated mail for end users should verify that such
                     header field was added by the appropriate verifying domain
                     and that the verified identity matches the author identity
                     that will be displayed by the MUA. In particular, MUA
                     filters should not be influenced by bogus results header
                     fields added by attackers. To circumvent this attack,
                     verifiers may wish to delete existing results header fields
                     after verification and before adding a new header
                     field.</t>
               </list></t>
         </section>

         <section
            title="Interpret Results/Apply Local Policy">

            <t>It is beyond the scope of this specification to describe what
               actions an Identity Assessor can make, but mail carrying a
               validated SDID presents an opportunity to an Identity Assessor
               that unauthenticated email does not. Specifically, an
               authenticated email creates a predictable identifier by which
               other decisions can reliably be managed, such as trust and
               reputation. Conversely, unauthenticated email lacks a reliable
               identifier that can be used to assign trust and reputation. It is
               reasonable to treat unauthenticated email as lacking any trust
               and having no positive reputation.</t>

            <t>In general, verifiers SHOULD NOT reject messages solely on the
               basis of a lack of signature or an unverifiable signature; such
               rejection would cause severe interoperability problems. However,
               if the verifier does opt to reject such messages (for example,
               when communicating with a peer who, by prior agreement, agrees to
               only send signed messages), and the verifier runs synchronously
               with the SMTP session and a signature is missing or does not
               verify, the MTA SHOULD use a 550/5.7.x reply code.</t>

            <t>
               <figure
                  align="left">
                  <preamble>If it is not possible to fetch the public key,
                     perhaps because the key server is not available, a
                     temporary failure message MAY be generated using a
                     451/4.7.5 reply code, such as: </preamble>
                  <artwork><![CDATA[451 4.7.5 Unable to verify signature - key server unavailable]]></artwork>
               </figure>
            </t>

            <t>Temporary failures such as inability to access the key server or
               other external service are the only conditions that SHOULD use a
               4xx SMTP reply code. In particular, cryptographic signature
               verification failures MUST NOT return 4xx SMTP replies.</t>

            <t>Once the signature has been verified, that information MUST be
               conveyed to the Identity Assessor (such as an explicit allow/
               whitelist and reputation system) and/or to the end user. If the
               SDID is not the same as the address in the From: header field,
               the mail system SHOULD take pains to ensure that the actual SDID
               is clear to the reader.</t>

            <t>The verifier MAY treat unsigned header fields with extreme
               skepticism, including marking them as untrusted or even deleting
               them before display to the end user.</t>

            <t>While the symptoms of a failed verification are obvious -- the
               signature doesn't verify -- establishing the exact cause can be
               more difficult. If a selector cannot be found, is that because
               the selector has been removed, or was the value changed somehow
               in transit? If the signature line is missing, is that because it
               was never there, or was it removed by an overzealous filter? For
               diagnostic purposes, the exact reason why the verification fails
               SHOULD be made available to the policy module and possibly
               recorded in the system logs. If the email cannot be verified,
               then it SHOULD be rendered the same as all unverified email
               regardless of whether or not it looks like it was signed.</t>

         </section>

      </section>

      <section
         title="IANA Considerations">

         <t>DKIM has registered new namespaces with IANA. In all cases, new
            values are assigned only for values that have been documented in a
            published RFC that has IETF Consensus <xref
               target="RFC5226" />.</t>

         <section
            title="DKIM-Signature Tag Specifications">

            <t>A DKIM-Signature provides for a list of tag specifications. IANA
               has established the DKIM-Signature Tag Specification Registry for
               tag specifications that can be used in DKIM-Signature fields.</t>

            <t>The initial entries in the registry comprise:</t>

            <texttable
               anchor="sigtagreg"
               title="DKIM-Signature Tag Specification          Registry Initial
               Values">
               <ttcol
                  align="center">TYPE</ttcol>
               <ttcol
                  align="left">REFERENCE</ttcol>
               <c> v </c>
               <c> (this document) </c>
               <c> a </c>
               <c> (this document) </c>
               <c> b </c>
               <c> (this document) </c>
               <c> bh </c>
               <c> (this document) </c>
               <c> c </c>
               <c> (this document) </c>
               <c> d </c>
               <c> (this document) </c>
               <c> h </c>
               <c> (this document) </c>
               <c> i </c>
               <c> (this document) </c>
               <c> l </c>
               <c> (this document) </c>
               <c> q </c>
               <c> (this document) </c>
               <c> s </c>
               <c> (this document) </c>
               <c> t </c>
               <c> (this document) </c>
               <c> x </c>
               <c> (this document) </c>
               <c> z </c>
               <c> (this document) </c>
            </texttable>

         </section>

         <section
            title="DKIM-Signature Query Method Registry">

            <t>The "q=" tag-spec (specified in <xref
                  target="dkimsighead" />) provides for a list of query
               methods.</t>

            <t>IANA has established the DKIM-Signature Query Method Registry for
               mechanisms that can be used to retrieve the key that will permit
               validation processing of a message signed using DKIM.</t>

            <t>The initial entry in the registry comprises:</t>

            <texttable
               title="DKIM-Signature Query Method Registry Initial Values">
               <ttcol
                  align="center">TYPE</ttcol>
               <ttcol
                  align="center">OPTION</ttcol>
               <ttcol
                  align="left">REFERENCE</ttcol>
               <c> dns </c>
               <c> txt </c>
               <c> (this document) </c>
            </texttable>

         </section>

         <section
            title="DKIM-Signature Canonicalization Registry">

            <t>The "c=" tag-spec (specified in <xref
                  target="dkimsighead" />) provides for a specifier for
               canonicalization algorithms for the header and body of the
               message.</t>

            <t> IANA has established the DKIM-Signature Canonicalization
               Algorithm Registry for algorithms for converting a message into a
               canonical form before signing or verifying using DKIM.</t>



            <t>The initial entries in the body registry comprise:</t>

            <texttable
               title="DKIM-Signature Body Canonicalization Algorithm Registry
               Initial Values">
               <ttcol
                  align="center">TYPE</ttcol>
               <ttcol
                  align="left">REFERENCE</ttcol>
               <c> simple </c>
               <c> (this document) </c>
               <c> relaxed </c>
               <c> (this document) </c>
            </texttable>

         </section>

         <section
            title="_domainkey DNS TXT Record Tag Specifications">

            <t>A _domainkey DNS TXT record provides for a list of tag
               specifications. IANA has established the DKIM _domainkey DNS TXT
               Tag Specification Registry for tag specifications that can be
               used in DNS TXT Records.</t>

            <t>The initial entries in the registry comprise:</t>

            <texttable
               title="DKIM _domainkey DNS TXT Record Tag Specification Registry
               Initial Values">
               <ttcol
                  align="center">TYPE</ttcol>
               <ttcol
                  align="left">REFERENCE</ttcol>
               <c> v </c>
               <c> (this document) </c>
               <c> g </c>
               <c> (this document) </c>
               <c> h </c>
               <c> (this document) </c>
               <c> k </c>
               <c> (this document) </c>
               <c> n </c>
               <c> (this document) </c>
               <c> p </c>
               <c> (this document) </c>
               <c> s </c>
               <c> (this document) </c>
               <c> t </c>
               <c> (this document) </c>
            </texttable>

            <t>The initial entries in the body registry comprise:</t>

            <texttable
               title="DKIM-Signature Body Canonicalization Algorithm Registry
               Initial Values">
               <ttcol
                  align="center">TYPE</ttcol>
               <ttcol
                  align="left">REFERENCE</ttcol>
               <c> simple </c>
               <c> (this document) </c>
               <c> relaxed </c>
               <c> (this document) </c>
            </texttable>

         </section>

         <section
            title="DKIM Key Type Registry">

            <t>The "k=" &lt;key-k-tag&gt; (specified in <xref
                  target="textrep" />) and the "a=" &lt;sig- a-tag-k&gt;
               (specified in <xref
                  target="dkimsighead" />) tags provide for a list of mechanisms
               that can be used to decode a DKIM signature.</t>

            <t>IANA has established the DKIM Key Type Registry for such
               mechanisms.</t>


            <t>The initial entry in the registry comprises:</t>

            <texttable
               title="DKIM Key Type Initial Values">

               <ttcol
                  align="center">TYPE</ttcol>
               <ttcol
                  align="left">REFERENCE</ttcol>

               <c> rsa </c>
               <c>
                  <xref
                     target="RFC3447" />
               </c>
            </texttable>

         </section>

         <section
            title="DKIM Hash Algorithms Registry">

            <t>The "h=" &lt;key-h-tag&gt; (specified in <xref
                  target="textrep" />) and the "a=" &lt;sig- a-tag-h&gt;
               (specified in <xref
                  target="dkimsighead" />) tags provide for a list of mechanisms
               that can be used to produce a digest of message data.</t>

            <t>IANA has established the DKIM Hash Algorithms Registry for such
               mechanisms.</t>



            <t>The initial entries in the registry comprise:</t>

            <texttable
               title="DKIM Hash Algorithms Initial Values">

               <ttcol
                  align="center">TYPE</ttcol>
               <ttcol
                  align="left">REFERENCE</ttcol>

               <c> sha1 </c>
               <c>
                  <xref
                     target="FIPS-180-2-2002" />
               </c>
               <c> sha256 </c>
               <c>
                  <xref
                     target="FIPS-180-2-2002" />
               </c>
            </texttable>

         </section>

         <section
            title="DKIM Service Types Registry">

            <t>The "s=" &lt;key-s-tag&gt; tag (specified in <xref
                  target="textrep" />) provides for a list of service types to
               which this selector may apply.</t>

            <t>IANA has established the DKIM Service Types Registry for service
               types.</t>

            <t>The initial entries in the registry comprise:</t>

            <texttable
               title="DKIM Service Types Registry Initial Values">

               <ttcol
                  align="center">TYPE</ttcol>
               <ttcol
                  align="left">REFERENCE</ttcol>

               <c> email </c>
               <c> (this document) </c>
               <c> * </c>
               <c> (this document) </c>
            </texttable>

         </section>

         <section
            title="DKIM Selector Flags Registry">

            <t>The "t=" &lt;key-t-tag&gt; tag (specified in <xref
                  target="textrep" />) provides for a list of flags to modify
               interpretation of the selector.</t>

            <t>IANA has established the DKIM Selector Flags Registry for
               additional flags.</t>

            <t>The initial entries in the registry comprise:</t>

            <texttable
               title="DKIM Selector Flags Registry Initial Values">

               <ttcol
                  align="center">TYPE</ttcol>
               <ttcol
                  align="left">REFERENCE</ttcol>

               <c> y </c>
               <c> (this document) </c>
               <c> s </c>
               <c> (this document) </c>
            </texttable>

         </section>

         <section
            title="DKIM-Signature Header Field">

            <t>IANA has added DKIM-Signature to the "Permanent Message Header
               Fields" registry (see <xref
                  target="RFC3864" />) for the "mail" protocol, using this
               document as the reference.</t>
         </section>
      </section>


      <section
         anchor="security"
         title="Security Considerations">

         <t> It has been observed that any mechanism that is introduced that
            attempts to stem the flow of spam is subject to intensive attack.
            DKIM needs to be carefully scrutinized to identify potential attack
            vectors and the vulnerability to each. See also <xref
               target="RFC4686" />.</t>


         <section
            title="Misuse of Body Length Limits (&quot;l=&quot; Tag)">

            <t> Body length limits (in the form of the "l=" tag) are subject to
               several potential attacks.</t>


            <section
               title="Addition of New MIME Parts to Multipart/*">

               <t>If the body length limit does not cover a closing MIME
                  multipart section (including the trailing "--CRLF" portion),
                  then it is possible for an attacker to intercept a properly
                  signed multipart message and add a new body part. Depending on
                  the details of the MIME type and the implementation of the
                  verifying MTA and the receiving MUA, this could allow an
                  attacker to change the information displayed to an end user
                  from an apparently trusted source.</t>

               <t>For example, if attackers can append information to a
                  "text/html" body part, they may be able to exploit a bug in
                  some MUAs that continue to read after a "&lt;/html&gt;"
                  marker, and thus display HTML text on top of already displayed
                  text. If a message has a "multipart&sol;alternative" body
                  part, they might be able to add a new body part that is
                  preferred by the displaying MUA.</t>
            </section>

            <section
               title="Addition of new HTML content to existing content">

               <t>Several receiving MUA implementations do not cease display
                  after a ""&lt;/html&gt;"" tag. In particular, this allows
                  attacks involving overlaying images on top of existing text. <list>
                     <t>INFORMATIVE EXAMPLE: Appending the following text to an
                        existing, properly closed message will in many MUAs
                        result in inappropriate data being rendered on top of
                        existing, correct data: <list>
                           <t><figure>
                                 <artwork><![CDATA[<div style="position: relative; bottom: 350px; z-index: 2;">
<img src="http://www.ietf.org/images/ietflogo2e.gif" width=578 height=370> </div>]]>
                                 </artwork>
                              </figure></t>
                        </list></t>
                  </list></t>
            </section>
         </section>


         <section
            title="Misappropriated Private Key">

            <t>If the private key for a user is resident on their computer and
               is not protected by an appropriately secure mechanism, it is
               possible for malware to send mail as that user and any other user
               sharing the same private key. The malware would not, however, be
               able to generate signed spoofs of other signers' addresses, which
               would aid in identification of the infected user and would limit
               the possibilities for certain types of attacks involving socially
               engineered messages. This threat applies mainly to MUA-based
               implementations; protection of private keys on servers can be
               easily achieved through the use of specialized cryptographic
               hardware.</t>

            <t>A larger problem occurs if malware on many users' computers
               obtains the private keys for those users and transmits them via a
               covert channel to a site where they can be shared. The
               compromised users would likely not know of the misappropriation
               until they receive "bounce" messages from messages they are
               purported to have sent. Many users might not understand the
               significance of these bounce messages and would not take
               action.</t>

            <t>One countermeasure is to use a user-entered passphrase to encrypt
               the private key, although users tend to choose weak passphrases
               and often reuse them for different purposes, possibly allowing an
               attack against DKIM to be extended into other domains.
               Nevertheless, the decoded private key might be briefly available
               to compromise by malware when it is entered, or might be
               discovered via keystroke logging. The added complexity of
               entering a passphrase each time one sends a message would also
               tend to discourage the use of a secure passphrase.</t>

            <t>A somewhat more effective countermeasure is to send messages
               through an outgoing MTA that can authenticate the submitter using
               existing techniques (e.g., SMTP Authentication), possibly
               validate the message itself (e.g., verify that the header is
               legitimate and that the content passes a spam content check), and
               sign the message using a key appropriate for the submitter
               address. Such an MTA can also apply controls on the volume of
               outgoing mail each user is permitted to originate in order to
               further limit the ability of malware to generate bulk email.</t>

         </section>

         <section
            title="Key Server Denial-of-Service Attacks">

            <t>Since the key servers are distributed (potentially separate for
               each domain), the number of servers that would need to be
               attacked to defeat this mechanism on an Internet-wide basis is
               very large. Nevertheless, key servers for individual domains
               could be attacked, impeding the verification of messages from
               that domain. This is not significantly different from the ability
               of an attacker to deny service to the mail exchangers for a given
               domain, although it affects outgoing, not incoming, mail.</t>

            <t>A variation on this attack is that if a very large amount of mail
               were to be sent using spoofed addresses from a given domain, the
               key servers for that domain could be overwhelmed with requests.
               However, given the low overhead of verification compared with
               handling of the email message itself, such an attack would be
               difficult to mount.</t>

         </section>

         <section
            title="Attacks Against the DNS">

            <t>Since the DNS is a required binding for key services, specific
               attacks against the DNS must be considered.</t>

            <t>While the DNS is currently insecure <xref
                  target="RFC3833" />, these security problems are the
               motivation behind DNS Security (DNSSEC) <xref
                  target="RFC4033" />, and all users of the DNS will reap the
               benefit of that work.</t>

            <t>DKIM is only intended as a "sufficient" method of proving
               authenticity. It is not intended to provide strong cryptographic
               proof about authorship or contents. Other technologies such as
               OpenPGP <xref
                  target="RFC4880" /> and S/MIME <xref
                  target="RFC5751" /> address those requirements.</t>

            <t>A second security issue related to the DNS revolves around the
               increased DNS traffic as a consequence of fetching selector-based
               data as well as fetching signing domain policy. Widespread
               deployment of DKIM will result in a significant increase in DNS
               queries to the claimed signing domain. In the case of forgeries
               on a large scale, DNS servers could see a substantial increase in
               queries.</t>

            <t>A specific DNS security issue that should be considered by DKIM
               verifiers is the name chaining attack described in Section 2.3 of <xref
                  target="RFC3833" />. A DKIM verifier, while verifying a
               DKIM-Signature header field, could be prompted to retrieve a key
               record of an attacker's choosing. This threat can be minimized by
               ensuring that name servers, including recursive name servers,
               used by the verifier enforce strict checking of "glue" and other
               additional information in DNS responses and are therefore not
               vulnerable to this attack.</t>

         </section>

         <section
            title="Replay Attacks">

            <t>In this attack, a spammer sends a message to be spammed to an
               accomplice, which results in the message being signed by the
               originating MTA. The accomplice resends the message, including
               the original signature, to a large number of recipients, possibly
               by sending the message to many compromised machines that act as
               MTAs. The messages, not having been modified by the accomplice,
               have valid signatures.</t>

            <t>Partial solutions to this problem involve the use of reputation
               services to convey the fact that the specific email address is
               being used for spam and that messages from that signer are likely
               to be spam. This requires a real-time detection mechanism in
               order to react quickly enough. However, such measures might be
               prone to abuse, if for example an attacker resent a large number
               of messages received from a victim in order to make them appear
               to be a spammer.</t>

            <t>Large verifiers might be able to detect unusually large volumes
               of mails with the same signature in a short time period. Smaller
               verifiers can get substantially the same volume of information
               via existing collaborative systems.</t>

         </section>

         <section
            title="Limits on Revoking Keys">

            <t>When a large domain detects undesirable behavior on the part of
               one of its users, it might wish to revoke the key used to sign
               that user's messages in order to disavow responsibility for
               messages that have not yet been verified or that are the subject
               of a replay attack. However, the ability of the domain to do so
               can be limited if the same key, for scalability reasons, is used
               to sign messages for many other users. Mechanisms for explicitly
               revoking keys on a per-address basis have been proposed but
               require further study as to their utility and the DNS load they
               represent.</t>

         </section>

         <section
            title="Intentionally Malformed Key Records">

            <t>It is possible for an attacker to publish key records in DNS that
               are intentionally malformed, with the intent of causing a
               denial-of- service attack on a non-robust verifier
               implementation. The attacker could then cause a verifier to read
               the malformed key record by sending a message to one of its users
               referencing the malformed record in a (not necessarily valid)
               signature. Verifiers MUST thoroughly verify all key records
               retrieved from the DNS and be robust against intentionally as
               well as unintentionally malformed key records.</t>

         </section>

         <section
            title="Intentionally Malformed DKIM-Signature Header Fields">

            <t>Verifiers MUST be prepared to receive messages with malformed
               DKIM- Signature header fields, and thoroughly verify the header
               field before depending on any of its contents.</t>

         </section>

         <section
            title="Information Leakage">

            <t>An attacker could determine when a particular signature was
               verified by using a per-message selector and then monitoring
               their DNS traffic for the key lookup. This would act as the
               equivalent of a "web bug" for verification time rather than when
               the message was read.</t>

         </section>

         <section
            title="Remote Timing Attacks">

            <t>In some cases it may be possible to extract private keys using a
               remote timing attack <xref
                  target="BONEH03" />. Implementations should consider
               obfuscating the timing to prevent such attacks.</t>

         </section>

         <section
            title="Reordered Header Fields">

            <t>Existing standards allow intermediate MTAs to reorder header
               fields. If a signer signs two or more header fields of the same
               name, this can cause spurious verification errors on otherwise
               legitimate messages. In particular, signers that sign any
               existing DKIM- Signature fields run the risk of having messages
               incorrectly fail to verify.</t>

         </section>

         <section
            title="RSA Attacks">

            <t>An attacker could create a large RSA signing key with a small
               exponent, thus requiring that the verification key have a large
               exponent. This will force verifiers to use considerable computing
               resources to verify the signature. Verifiers might avoid this
               attack by refusing to verify signatures that reference selectors
               with public keys having unreasonable exponents.</t>

            <t>In general, an attacker might try to overwhelm a verifier by
               flooding it with messages requiring verification. This is similar
               to other MTA denial-of-service attacks and should be dealt with
               in a similar fashion.</t>

         </section>

         <section
            title="Inappropriate Signing by Parent Domains">

            <t>The trust relationship described in <xref
                  target="parentsig" /> could conceivably be used by a parent
               domain to sign messages with identities in a subdomain not
               administratively related to the parent. For example, the ".com"
               registry could create messages with signatures using an "i="
               value in the example.com domain. There is no general solution to
               this problem, since the administrative cut could occur anywhere
               in the domain name. For example, in the domain
               "example.podunk.ca.us" there are three administrative cuts
               (podunk.ca.us, ca.us, and us), any of which could create messages
               with an identity in the full domain. <list>
                  <t>INFORMATIVE NOTE: This is considered an acceptable risk for
                     the same reason that it is acceptable for domain
                     delegation. For example, in the example above any of the
                     domains could potentially simply delegate
                     "example.podunk.ca.us" to a server of their choice and
                     completely replace all DNS-served information. Note that a
                     verifier MAY ignore signatures that come from an unlikely
                     domain such as ".com", as discussed in <xref
                        target="validatesig" />.</t>
               </list>
            </t>

         </section>

         <section
            title="Attacks Involving Addition of Header Fields">
            <t>Many email implementations do not enforce <xref
                  target="RFC5322" /> with strictness. As discussed in <xref
                  target="normalize" /> DKIM processing is predicated on a valid
               mail message as its input. However, DKIM implementers should be
               aware of the potential effect of having loose enforcement by
               email components interacting with DKIM modules.</t>
            <t>For example, a message with multiple From: header fields violates
               Section 3.6 of <xref
                  target="RFC5322" />. With the intent of providing a better
               user experience, many agents tolerate these violations and
               deliver the message anyway. An MUA then might elect to render to
               the user the value of the last, or "top", From: field. This may
               also be done simply out of the expectation that there is only
               one, where a "find first" algorithm would have the same result.
               Such code in an MUA can be exploited to fool the user if it is
               also known that the other From: field is the one checked by
               arriving message filters. Such is the case with DKIM; although
               the From: field must be signed, a malformed message bearing more
               than one From: field might only have the first ("bottom") one
               signed, in an attempt to show the message with some "DKIM passed"
               annotation while also rendering the From: field that was not
               authenticated. (This can also be taken as a demonstration that
               DKIM is not designed to support author validation.) </t>
            <t>To resist this specific attack the signed header field list can
               include an additional reference for each field that was present
               at signing. For example, a proper message with one From: field
               could be signed using "h=From:From:..." Due to the way header
               fields are canonicalized for input to the hash function, the
               extra field references will prevent instances of the cited fields
               from being added after signing, as doing so would render the
               signature invalid. </t>
            <t>The From: field is used above to illustrate this issue, but it is
               only one of > several fields that Section 3.6 of <xref
                  target="RFC5322" /> constrains in this way. In reality any
               agent that forgives malformations, or is careless about
               identifying which parts of a message were authenticated, is open
               to exploitation.</t>
         </section>

      </section>

   </middle>

   <back>

      <references
         title="Normative References">

         <reference
            anchor="FIPS-180-2-2002">
            <front>
               <title>Secure Hash Standard</title>

               <author
                  fullname="U.S. Department of Commerce"
                  surname="U.S. Department of Commerce" />
               <date
                  month="August"
                  year="2002" />
            </front>
            <seriesInfo
               name="FIPS PUB"
               value="180-2" />
         </reference>

         <reference
            anchor="ITU-X660-1997">
            <front>
               <title>Information Technology - ASN.1 encoding rules:
                  Specification of Basic Encoding Rules (BER), Canonical
                  Encoding Rules (CER) and Distinguished Encoding Rules
                  (DER)</title>
               <author
                  fullname="ITU-T Recommendation X.660" />
               <date
                  year="1997" />
            </front>
         </reference>


         <reference
            anchor="RFC1034">
            <front>
               <title>DOMAIN NAMES - CONCEPTS AND FACILITIES</title>
               <author
                  fullname="P. Mockapetris"
                  initials="P."
                  surname="Mockapetris" />
               <date
                  month="November"
                  year="1987" />
            </front>
            <seriesInfo
               name="RFC"
               value="1034" />
         </reference>


         <reference
            anchor="RFC2045">
            <front>
               <title
                  abbrev="Internet Message Bodies">Multipurpose Internet Mail
                  Extensions (MIME) Part One: Format of Internet Message
                  Bodies</title>
               <author
                  fullname="Ned Freed"
                  initials="N."
                  surname="Freed">
                  <organization>Innosoft International, Inc.</organization>

                  <address>
<postal>
<street>1050 East Garvey Avenue South</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country>
</postal>

<phone>+1 818 919 3600</phone>
<facsimile>+1 818 919 3614</facsimile>
<email>ned@innosoft.com</email>
</address>
               </author>

               <author
                  fullname="Nathaniel S. Borenstein"
                  initials="N.S."
                  surname="Borenstein">
                  <organization>First Virtual Holdings</organization>

                  <address>
<postal>
<street>25 Washington Avenue</street>
<city>Morristown</city>
<region>NJ</region>
<code>07960</code>
<country>US</country>
</postal>

<phone>+1 201 540 8967</phone>
<facsimile>+1 201 993 3032</facsimile>
<email>nsb@nsb.fv.com</email>
</address>
               </author>

               <date
                  month="November"
                  year="1996" />

               <abstract>
                  <t>STD 11, RFC 822, defines a message representation protocol
                     specifying considerable detail about US-ASCII message
                     headers, and leaves the message content, or message body,
                     as flat US-ASCII text. This set of documents, collectively
                     called the Multipurpose Internet Mail Extensions, or MIME,
                     redefines the format of messages to allow for</t>

                  <t>(1) textual message bodies in character sets other than
                     US-ASCII,</t>

                  <t>(2) an extensible set of different formats for non-textual
                     message bodies,</t>

                  <t>(3) multi-part message bodies, and</t>

                  <t>(4) textual header information in character sets other than
                     US-ASCII.</t>

                  <t>These documents are based on earlier work documented in RFC
                     934, STD 11, and RFC 1049, but extends and revises them.
                     Because RFC 822 said so little about message bodies, these
                     documents are largely orthogonal to (rather than a revision
                     of) RFC 822.</t>

                  <t>This initial document specifies the various header fields
                     used to describe the structure of MIME messages. The second
                     document, RFC 2046, defines the general structure of the
                     MIME media typing system and defines an initial set of
                     media types. The third document, RFC 2047, describes
                     extensions to RFC 822 to allow non-US-ASCII text data in
                     Internet mail header fields. The fourth document, RFC 2048,
                     specifies various IANA registration procedures for
                     MIME-related facilities. The fifth and final document, <xref
                        target="RFC2049" />, describes MIME conformance criteria
                     as well as providing some illustrative examples of MIME
                     message formats, acknowledgements, and the
                     bibliography.</t>

                  <t>These documents are revisions of RFCs 1521, 1522, and 1590,
                     which themselves were revisions of RFCs 1341 and 1342. An
                     appendix in RFC 2049 describes differences and changes from
                     previous versions.</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="2045" />
            <format
               octets="72932"
               target="http://www.rfc-editor.org/rfc/rfc2045.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC2047">
            <front>
               <title
                  abbrev="Message Header Extensions">MIME (Multipurpose Internet
                  Mail Extensions) Part Three: Message Header Extensions for
                  Non-ASCII Text</title>
               <author
                  fullname="Keith Moore"
                  initials="K."
                  surname="Moore">
                  <organization>University of Tennessee</organization>

                  <address>
<postal>
<street>107 Ayres Hall</street>
<street>Knoxville TN 37996-1301</street>
</postal>

<email>moore@cs.utk.edu</email>
</address>
               </author>

               <date
                  month="November"
                  year="1996" />
               <area>Applications</area>
               <keyword>Amercian Standard Code for Information
                  Interchange</keyword>
               <keyword>mail</keyword>
               <keyword>multipurpose internet mail extensions</keyword>

               <abstract>
                  <t> STD 11, RFC 822, defines a message representation protocol
                     specifying considerable detail about US-ASCII message
                     headers, and leaves the message content, or message body,
                     as flat US-ASCII text. This set of documents, collectively
                     called the Multipurpose Internet Mail Extensions, or MIME,
                     redefines the format of messages to allow for <list>
                        <t> (1) textual message bodies in character sets other
                           than US-ASCII, </t>
                        <t> (2) an extensible set of different formats for
                           non-textual message bodies, </t>
                        <t> (3) multi-part message bodies, and </t>
                        <t> (4) textual header information in character sets
                           other than US-ASCII. </t>
                     </list>
                  </t>

                  <t> These documents are based on earlier work documented in
                     RFC 934, STD 11, and RFC 1049, but extends and revises
                     them. Because RFC 822 said so little about message bodies,
                     these documents are largely orthogonal to (rather than a
                     revision of) RFC 822. </t>

                  <t> This particular document is the third document in the
                     series. It describes extensions to RFC 822 to allow
                     non-US-ASCII text data in Internet mail header fields.
                     Other documents in this series include: <list
                        style="symbols">
                        <t>RFC 2045, which specifies the various headers used to
                           describe the structure of MIME messages. </t>
                        <t>RFC 2046, which defines the general structure of the
                           MIME media typing system and defines an initial set
                           of media types, </t>
                        <t>RFC 2048, which specifies various IANA registration
                           procedures for MIME-related facilities, and </t>
                        <t>RFC 2049, which describes MIME conformance criteria
                           and provides some illustrative examples of MIME
                           message formats, acknowledgements, and the
                           bibliography. </t>
                     </list>
                  </t>

                  <t> These documents are revisions of RFCs 1521, 1522, and
                     1590, which themselves were revisions of RFCs 1341 and
                     1342. An appendix in RFC 2049 describes differences and
                     changes from previous versions. </t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="2047" />
            <format
               octets="33262"
               target="http://www.rfc-editor.org/rfc/rfc2047.txt"
               type="TXT" />
            <format
               octets="52141"
               target="http://xml.resource.org/public/rfc/html/rfc2047.html"
               type="HTML" />
            <format
               octets="39330"
               target="http://xml.resource.org/public/rfc/xml/rfc2047.xml"
               type="XML" />
         </reference>

         <reference
            anchor="RFC2049">
            <front>
               <title
                  abbrev="MIME Conformance">Multipurpose Internet Mail
                  Extensions (MIME) Part Five: Conformance Criteria and
                  Examples</title>
               <author
                  fullname="Ned Freed"
                  initials="N."
                  surname="Freed">
                  <organization>Innosoft International, Inc.</organization>

                  <address>
<postal>
<street>1050 East Garvey Avenue South</street>
<street>West Covina</street>
<street>CA 91790</street>
<country>USA</country>
</postal>

<phone>+1 818 919 3600</phone>
<facsimile>+1 818 919 3614</facsimile>
<email>ned@innosoft.com</email>
</address>
               </author>

               <author
                  fullname="Nathaniel S. Borenstein"
                  initials="N.S."
                  surname="Borenstein">
                  <organization>First Virtual Holdings</organization>

                  <address>
<postal>
<street>25 Washington Avenue</street>
<street>Morristown</street>
<street>NJ 07960</street>
<country>USA</country>
</postal>

<phone>+1 201 540 8967</phone>
<facsimile>+1 201 993 3032</facsimile>
<email>nsb@nsb.fv.com</email>
</address>
               </author>

               <date
                  month="November"
                  year="1996" />
               <area>Applications</area>
               <keyword>mail</keyword>
               <keyword>multipurpose internet mail extensions</keyword>

               <abstract>
                  <t> STD 11, RFC 822, defines a message representation protocol
                     specifying considerable detail about US-ASCII message
                     headers, and leaves the message content, or message body,
                     as flat US-ASCII text. This set of documents, collectively
                     called the Multipurpose Internet Mail Extensions, or MIME,
                     redefines the format of messages to allow for <list>
                        <t> (1) textual message bodies in character sets other
                           than US-ASCII, </t>
                        <t> (2) an extensible set of different formats for
                           non-textual message bodies, </t>
                        <t> (3) multi-part message bodies, and </t>
                        <t> (4) textual header information in character sets
                           other than US-ASCII. </t>
                     </list>
                  </t>

                  <t> These documents are based on earlier work documented in
                     RFC 934, STD 11, and RFC 1049, but extends and revises
                     them. Because RFC 822 said so little about message bodies,
                     these documents are largely orthogonal to (rather than a
                     revision of) RFC 822. </t>

                  <t> The initial document in this set, RFC 2045, specifies the
                     various headers used to describe the structure of MIME
                     messages. The second document defines the general structure
                     of the MIME media typing system and defines an initial set
                     of media types. The third document, RFC 2047, describes
                     extensions to RFC 822 to allow non-US- ASCII text data in
                     Internet mail header fields. The fourth document, RFC 2048,
                     specifies various IANA registration procedures for MIME-
                     related facilities. This fifth and final document describes
                     MIME conformance criteria as well as providing some
                     illustrative examples of MIME message formats,
                     acknowledgements, and the bibliography. </t>

                  <t> These documents are revisions of RFCs 1521, 1522, and
                     1590, which themselves were revisions of RFCs 1341 and
                     1342. Appendix B of this document describes differences and
                     changes from previous versions. </t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="2049" />
            <format
               octets="51207"
               target="http://www.rfc-editor.org/rfc/rfc2049.txt"
               type="TXT" />
            <format
               octets="56682"
               target="http://xml.resource.org/public/rfc/html/rfc2049.html"
               type="HTML" />
            <format
               octets="42032"
               target="http://xml.resource.org/public/rfc/xml/rfc2049.xml"
               type="XML" />
         </reference>

         <reference
            anchor="RFC2119">
            <front>
               <title
                  abbrev="RFC Key Words">Key words for use in RFCs to Indicate
                  Requirement Levels</title>
               <author
                  fullname="Scott Bradner"
                  initials="S."
                  surname="Bradner">
                  <organization>Harvard University</organization>

                  <address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street>
</postal>

<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email>
</address>
               </author>

               <date
                  month="March"
                  year="1997" />
               <area>General</area>
               <keyword>keyword</keyword>

               <abstract>
                  <t> In many standards track documents several words are used
                     to signify the requirements in the specification. These
                     words are often capitalized. This document defines these
                     words as they should be interpreted in IETF documents.
                     Authors who follow these guidelines should incorporate this
                     phrase near the beginning of their document: <list>
                        <t> The key words "MUST", "MUST NOT", "REQUIRED",
                           "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
                           "RECOMMENDED", "MAY", and "OPTIONAL" in this document
                           are to be interpreted as described in RFC 2119. </t>
                     </list>
                  </t>

                  <t> Note that the force of these words is modified by the
                     requirement level of the document in which they are used.
                  </t>
               </abstract>
            </front>

            <seriesInfo
               name="BCP"
               value="14" />
            <seriesInfo
               name="RFC"
               value="2119" />
            <format
               octets="4723"
               target="http://www.rfc-editor.org/rfc/rfc2119.txt"
               type="TXT" />
            <format
               octets="17491"
               target="http://xml.resource.org/public/rfc/html/rfc2119.html"
               type="HTML" />
            <format
               octets="5777"
               target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"
               type="XML" />
         </reference>

         <reference
            anchor="RFC5321">
            <front>
               <title>Simple Mail Transfer Protocol</title>
               <author
                  fullname="J. Klensin"
                  initials="J."
                  surname="Klensin">
                  <organization />
               </author>

               <date
                  month="October"
                  year="2008" />

               <abstract>
                  <t>This document is a self-contained specification of the
                     basic protocol for the Internet electronic mail transport.
                     [STANDARDS TRACK]</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="5321" />
            <format
               octets="192504"
               target="http://www.rfc-editor.org/rfc/rfc5321.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC5322">
            <front>
               <title>Internet Message Format</title>
               <author
                  fullname="P. Resnick"
                  initials="P."
                  surname="Resnick">
                  <organization />
               </author>

               <date
                  month="October"
                  year="2008" />

               <abstract>
                  <t>This document specifies a syntax for text messages that are
                     sent between computer users, within the framework of
                     "electronic mail" messages. [STANDARDS TRACK]</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="5322" />
            <format
               octets="110695"
               target="http://www.rfc-editor.org/rfc/rfc5322.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC3447">
            <front>
               <title>Public-Key Cryptography Standards (PKCS) #1: RSA
                  Cryptography Specifications Version 2.1</title>
               <author
                  fullname="J. Jonsson"
                  initials="J."
                  surname="Jonsson">
                  <organization />
               </author>

               <author
                  fullname="B. Kaliski"
                  initials="B."
                  surname="Kaliski">
                  <organization />
               </author>

               <date
                  month="February"
                  year="2003" />

               <abstract>
                  <t>This memo represents a republication of PKCS #1 v2.1 from
                     RSA Laboratories' Public-Key Cryptography Standards (PKCS)
                     series, and change control is retained within the PKCS
                     process. The body of this document is taken directly from
                     the PKCS #1 v2.1 document, with certain corrections made
                     during the publication process. This memo provides
                     information for the Internet community.</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="3447" />
            <format
               octets="143173"
               target="http://www.rfc-editor.org/rfc/rfc3447.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC3490">
            <front>
               <title>Internationalizing Domain Names in Applications
                  (IDNA)</title>
               <author
                  fullname="P. Faltstrom"
                  initials="P."
                  surname="Faltstrom">
                  <organization />
               </author>

               <author
                  fullname="P. Hoffman"
                  initials="P."
                  surname="Hoffman">
                  <organization />
               </author>

               <author
                  fullname="A. Costello"
                  initials="A."
                  surname="Costello">
                  <organization />
               </author>

               <date
                  month="March"
                  year="2003" />

               <abstract>
                  <t>Until now, there has been no standard method for domain
                     names to use characters outside the ASCII repertoire. This
                     document defines internationalized domain names (IDNs) and
                     a mechanism called Internationalizing Domain Names in
                     Applications (IDNA) for handling them in a standard
                     fashion. IDNs use characters drawn from a large repertoire
                     (Unicode), but IDNA allows the non-ASCII characters to be
                     represented using only the ASCII characters already allowed
                     in so-called host names today. This backward-compatible
                     representation is required in existing protocols like DNS,
                     so that IDNs can be introduced with no changes to the
                     existing infrastructure. IDNA is only meant for processing
                     domain names, not free text. [STANDARDS TRACK]</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="3490" />
            <format
               octets="51943"
               target="http://www.rfc-editor.org/rfc/rfc3490.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC5234">
            <front>
               <title
                  abbrev="ABNF">Augmented BNF for Syntax Specifications:
                  ABNF</title>
               <author
                  fullname="Dave Crocker"
                  initials="D."
                  role="editor"
                  surname="Crocker">
                  <organization>Brandenburg InternetWorking</organization>

                  <address>
<postal>
<street>675 Spruce Dr.</street>
<city>Sunnyvale</city>
<region>CA</region>
<code>94086</code>
<country>US</country>
</postal>

<phone>+1.408.246.8253</phone>
<email>dcrocker@bbiw.net</email>
</address>
               </author>

               <author
                  fullname="Paul Overell"
                  initials="P."
                  surname="Overell">
                  <organization>THUS plc.</organization>

                  <address>
<postal>
<street>1/2 Berkeley Square, </street>
<street>99 Berkeley Street</street>
<city>Glasgow</city>
<code>G3 7HR</code>
<country>UK</country>
</postal>

<email>paul.overell@thus.net</email>
</address>
               </author>

               <date
                  month="January"
                  year="2008" />
               <keyword>ABNF</keyword>
               <keyword>Augmented</keyword>
               <keyword>Backus-Naur</keyword>
               <keyword>Form</keyword>
               <keyword>electronic</keyword>
               <keyword>mail</keyword>

               <abstract>
                  <t>Internet technical specifications often need to define a
                     formal syntax. Over the years, a modified version of
                     Backus-Naur Form (BNF), called Augmented BNF (ABNF), has
                     been popular among many Internet specifications. The
                     current specification documents ABNF. It balances
                     compactness and simplicity, with reasonable
                     representational power. The differences between standard
                     BNF and ABNF involve naming rules, repetition,
                     alternatives, order- independence, and value ranges. This
                     specification also supplies additional rule definitions and
                     encoding for a core lexical analyzer of the type common to
                     several Internet specifications. </t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="4234" />
            <format
               octets="26351"
               target="http://www.rfc-editor.org/rfc/rfc4234.txt"
               type="TXT" />
            <format
               octets="52334"
               target="http://xml.resource.org/public/rfc/html/rfc4234.html"
               type="HTML" />
            <format
               octets="37285"
               target="http://xml.resource.org/public/rfc/xml/rfc4234.xml"
               type="XML" />
         </reference>

         <reference
            anchor="RFC5598">
            <front>
               <title>Internet Mail Architecture</title>
               <author
                  fullname="D. Crocker"
                  initials="D."
                  surname="Crocker" />
               <date
                  month="July"
                  year="2009" />
            </front>
            <seriesInfo
               name="RFC"
               value="5598" />
         </reference>

      </references>

      <references
         title="Informative References">


         <reference
            anchor="BONEH03">
            <front>
               <title>Remote Timing Attacks are Practical</title>
               <author />
               <date
                  year="2003" />
            </front>
            <seriesInfo
               name="Proceedings "
               value="12th USENIX Security Symposium" />
         </reference>


         <reference
            anchor="RFC1847">
            <front>
               <title
                  abbrev="Security Multiparts">Security Multiparts for MIME:
                  Multipart/Signed and Multipart/Encrypted</title>
               <author
                  fullname="Jim Galvin"
                  initials="J."
                  surname="Galvin">
                  <organization>Trusted Information Systems</organization>

                  <address>
<postal>
<street>3060 Washington Road</street>
<city>Glenwood</city>
<region>MD</region>
<code>21738</code>
<country>US</country>
</postal>

<phone>+1 301 854 6889</phone>
<facsimile>+1 301 854 5363</facsimile>
<email>galvin@tis.com</email>
</address>
               </author>

               <author
                  fullname="Sandy Murphy"
                  initials="S."
                  surname="Murphy">
                  <organization>Trusted Information Systems</organization>

                  <address>
<postal>
<street>3060 Washington Road</street>
<city>Glenwood</city>
<region>MD</region>
<code>21738</code>
<country>US</country>
</postal>

<phone>+1 301 854 6889</phone>
<facsimile>+1 301 854 5363</facsimile>
<email>sandy@tis.com</email>
</address>
               </author>

               <author
                  fullname="Steve Crocker"
                  initials="S."
                  surname="Crocker">
                  <organization>CyberCash, Inc.</organization>

                  <address>
<postal>
<street>2086 Hunters Crest Way</street>
<city>Vienna</city>
<region>VA</region>
<code>22181</code>
<country>US</country>
</postal>

<phone>+1 703 620 1222</phone>
<facsimile>+1 703 391 2651</facsimile>
<email>crocker@cybercash.com</email>
</address>
               </author>

               <author
                  fullname="Ned Freed"
                  initials="N."
                  surname="Freed">
                  <organization>Innosoft International, Inc.</organization>

                  <address>
<postal>
<street>1050 East Garvey Avenue South</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country>
</postal>

<phone>+1 818 919 3600</phone>
<facsimile>+1 818 919 3614</facsimile>
<email>ned@innosoft.com</email>
</address>
               </author>

               <date
                  month="October"
                  year="1995" />

               <abstract>
                  <t>This document defines a framework within which security
                     services may be applied to MIME body parts. MIME, an
                     acronym for "Multipurpose Internet Mail Extensions",
                     defines the format of the contents of Internet mail
                     messages and provides for multi-part textual and
                     non-textual message bodies. The new content types are
                     subtypes of multipart: signed and encrypted. Each will
                     contain two body parts: one for the protected data and one
                     for the control information necessary to remove the
                     protection. The type and contents of the control
                     information body parts are determined by the value of the
                     protocol parameter of the enclosing multipart&sol;signed or
                     multipart&sol;encrypted content type, which is required to
                     be present.</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="1847" />
            <format
               octets="23679"
               target="http://www.rfc-editor.org/rfc/rfc1847.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC5226">
            <front>
               <title
                  abbrev="Guidelines for IANA Considerations">Guidelines for
                  Writing an IANA Considerations Section in RFCs</title>
               <author
                  fullname="Thomas Narten"
                  initials="T."
                  surname="Narten">
                  <organization>IBM Corporation</organization>

                  <address>
<postal>
<street>3039 Cornwallis Ave.</street>
<street>PO Box 12195 - BRQA/502</street>
<street>Research Triangle Park</street>
<street>NC 27709-2195</street>
</postal>

<phone>919-254-7798</phone>
<email>narten@raleigh.ibm.com</email>
</address>
               </author>

               <author
                  fullname="Harald Tveit Alvestrand"
                  initials="H.T."
                  surname="Alvestrand">
                  <organization>Maxware</organization>

                  <address>
<postal>
<street>Pirsenteret</street>
<street>N-7005 Trondheim</street>
<country>Norway</country>
</postal>

<phone>+47 73 54 57 97</phone>
<email>Harald@Alvestrand.no</email>
</address>
               </author>

               <date
                  month="May"
                  year="2008" />
               <area>General</area>
               <keyword>Internet Assigned Numbers Authority</keyword>
               <keyword>IANA</keyword>

               <abstract>
                  <t> Many protocols make use of identifiers consisting of
                     constants and other well-known values. Even after a
                     protocol has been defined and deployment has begun, new
                     values may need to be assigned (e.g., for a new option type
                     in DHCP, or a new encryption or authentication algorithm
                     for IPSec). To insure that such quantities have consistent
                     values and interpretations in different implementations,
                     their assignment must be administered by a central
                     authority. For IETF protocols, that role is provided by the
                     Internet Assigned Numbers Authority (IANA). </t>

                  <t> In order for the IANA to manage a given name space
                     prudently, it needs guidelines describing the conditions
                     under which new values can be assigned. If the IANA is
                     expected to play a role in the management of a name space,
                     the IANA must be given clear and concise instructions
                     describing that role. This document discusses issues that
                     should be considered in formulating a policy for assigning
                     values to a name space and provides guidelines to document
                     authors on the specific text that must be included in
                     documents that place demands on the IANA. </t>
               </abstract>
            </front>

            <seriesInfo
               name="BCP"
               value="26" />
            <seriesInfo
               name="RFC"
               value="5226" />
            <format
               octets="25092"
               target="http://www.rfc-editor.org/rfc/rfc5226.txt"
               type="TXT" />
            <format
               octets="37803"
               target="http://xml.resource.org/public/rfc/html/rfc5226.html"
               type="HTML" />
            <format
               octets="27060"
               target="http://xml.resource.org/public/rfc/xml/rfc5226.xml"
               type="XML" />
         </reference>

         <reference
            anchor="RFC4880">
            <front>
               <title>OpenPGP Message Format</title>
               <author
                  fullname="Jon Callas"
                  initials="J."
                  surname="Callas">
                  <organization>Network Associates, Inc.</organization>

                  <address>
<postal>
<street>3965 Freedom Circle</street>
<street>Santa Clara</street>
<street>CA 95054</street>
<country>USA</country>
</postal>

<phone>+1 408-346-5860</phone>
<email>jon@pgp.com</email>
</address>
               </author>

               <author
                  fullname="Lutz Donnerhacke"
                  initials="L."
                  surname="Donnerhacke">
                  <organization>IKS GmbH</organization>

                  <address>
<postal>
<street>Wildenbruchstr. 15</street>
<street>07745 Jena</street>
<country>Germany</country>
</postal>

<phone>+49-3641-675642</phone>
<email>lutz@iks-jena.de</email>
</address>
               </author>

               <author
                  fullname="Hal Finney"
                  initials="H."
                  surname="Finney">
                  <organization>Network Associates, Inc.</organization>

                  <address>
<postal>
<street>3965 Freedom Circle</street>
<street>Santa Clara</street>
<street>CA 95054</street>
<country>USA</country>
</postal>

<email>hal@pgp.com</email>
</address>
               </author>

               <author
                  fullname="Rodney Thayer"
                  initials="R."
                  surname="Thayer">
                  <organization>EIS Corporation</organization>

                  <address>
<postal>
<street>Clearwater</street>
<street>FL 33767</street>
<country>USA</country>
</postal>

<email>rodney@unitran.com</email>
</address>
               </author>

               <date
                  month="November"
                  year="2007" />
               <area>Security</area>
               <keyword>pretty good privacy</keyword>
               <keyword>PGP</keyword>
               <keyword>security</keyword>

               <abstract>
                  <t> This document defines many tag values, yet it doesn&apos;t
                     describe a mechanism for adding new tags (for new
                     features). Traditionally the Internet Assigned Numbers
                     Authority (IANA) handles the allocation of new values for
                     future expansion and RFCs usually define the procedure to
                     be used by the IANA. However, there are subtle (and not so
                     subtle) interactions that may occur in this protocol
                     between new features and existing features which result in
                     a significant reduction in over all security. Therefore,
                     this document does not define an extension procedure.
                     Instead requests to define new tag values (say for new
                     encryption algorithms for example) should be forwarded to
                     the IESG Security Area Directors for consideration or
                     forwarding to the appropriate IETF Working Group for
                     consideration. </t>

                  <t> This document is maintained in order to publish all
                     necessary information needed to develop interoperable
                     applications based on the OpenPGP format. It is not a
                     step-by-step cookbook for writing an application. It
                     describes only the format and methods needed to read,
                     check, generate, and write conforming packets crossing any
                     network. It does not deal with storage and implementation
                     questions. It does, however, discuss implementation issues
                     necessary to avoid security flaws. </t>

                  <t> Open-PGP software uses a combination of strong public-key
                     and symmetric cryptography to provide security services for
                     electronic communications and data storage. These services
                     include confidentiality, key management, authentication,
                     and digital signatures. This document specifies the message
                     formats used in OpenPGP. </t>
               </abstract>

               <note
                  title="IESG Note">
                  <t> This document defines many tag values, yet it doesn&apos;t
                     describe a mechanism for adding new tags (for new
                     features). Traditionally the Internet Assigned Numbers
                     Authority (IANA) handles the allocation of new values for
                     future expansion and RFCs usually define the procedure to
                     be used by the IANA. However, there are subtle (and not so
                     subtle) interactions that may occur in this protocol
                     between new features and existing features which result in
                     a significant reduction in over all security. Therefore,
                     this document does not define an extension procedure.
                     Instead requests to define new tag values (say for new
                     encryption algorithms for example) should be forwarded to
                     the IESG Security Area Directors for consideration or
                     forwarding to the appropriate IETF Working Group for
                     consideration. </t>
               </note>
            </front>

            <seriesInfo
               name="RFC"
               value="4880" />
            <format
               octets="141371"
               target="http://www.rfc-editor.org/rfc/rfc4880.txt"
               type="TXT" />
            <format
               octets="157503"
               target="http://xml.resource.org/public/rfc/html/rfc4880.html"
               type="HTML" />
            <format
               octets="137322"
               target="http://xml.resource.org/public/rfc/xml/rfc4880.xml"
               type="XML" />
         </reference>

         <reference
            anchor="RFC3766">
            <front>
               <title>Determining Strengths For Public Keys Used For Exchanging
                  Symmetric Keys</title>
               <author
                  fullname="H. Orman"
                  initials="H."
                  surname="Orman">
                  <organization />
               </author>

               <author
                  fullname="P. Hoffman"
                  initials="P."
                  surname="Hoffman">
                  <organization />
               </author>

               <date
                  month="April"
                  year="2004" />

               <abstract>
                  <t>Implementors of systems that use public key cryptography to
                     exchange symmetric keys need to make the public keys
                     resistant to some predetermined level of attack. That level
                     of attack resistance is the strength of the system, and the
                     symmetric keys that are exchanged must be at least as
                     strong as the system strength requirements. The three
                     quantities, system strength, symmetric key strength, and
                     public key strength, must be consistently matched for any
                     network protocol usage. While it is fairly easy to express
                     the system strength requirements in terms of a symmetric
                     key length and to choose a cipher that has a key length
                     equal to or exceeding that requirement, it is harder to
                     choose a public key that has a cryptographic strength
                     meeting a symmetric key strength requirement. This document
                     explains how to determine the length of an asymmetric key
                     as a function of a symmetric key strength requirement. Some
                     rules of thumb for estimating equivalent resistance to
                     large-scale attacks on various algorithms are given. The
                     document also addresses how changing the sizes of the
                     underlying large integers (moduli, group sizes, exponents,
                     and so on) changes the time to use the algorithms for key
                     exchange. This document specifies an Internet Best Current
                     Practices for the Internet Community, and requests
                     discussion and suggestions for improvements.</t>
               </abstract>
            </front>

            <seriesInfo
               name="BCP"
               value="86" />
            <seriesInfo
               name="RFC"
               value="3766" />
            <format
               octets="55939"
               target="http://www.rfc-editor.org/rfc/rfc3766.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC3833">
            <front>
               <title>Threat Analysis of the Domain Name System (DNS)</title>
               <author
                  fullname="D. Atkins"
                  initials="D."
                  surname="Atkins">
                  <organization />
               </author>

               <author
                  fullname="R. Austein"
                  initials="R."
                  surname="Austein">
                  <organization />
               </author>

               <date
                  month="August"
                  year="2004" />

               <abstract>
                  <t>Although the DNS Security Extensions (DNSSEC) have been
                     under development for most of the last decade, the IETF has
                     never written down the specific set of threats against
                     which DNSSEC is designed to protect. Among other drawbacks,
                     this cart-before-the-horse situation has made it difficult
                     to determine whether DNSSEC meets its design goals, since
                     its design goals are not well specified. This note attempts
                     to document some of the known threats to the DNS, and, in
                     doing so, attempts to measure to what extent (if any)
                     DNSSEC is a useful tool in defending against these threats.
                     This memo provides information for the Internet
                     community.</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="3833" />
            <format
               octets="39303"
               target="http://www.rfc-editor.org/rfc/rfc3833.txt"
               type="TXT" />
         </reference>


         <reference
            anchor="RFC5751">
            <front>
               <title>Secure/Multipurpose Internet Mail Extensions (S/MIME)
                  Version 3.1 Message Specification</title>
               <author
                  fullname="B. Ramsdell"
                  initials="B."
                  surname="Ramsdell">
                  <organization />
               </author>

               <date
                  month="January"
                  year="2010" />

               <abstract>
                  <t>This document defines Secure/Multipurpose Internet Mail
                     Extensions (S/MIME) version 3.1. S/MIME provides a
                     consistent way to send and receive secure MIME data.
                     Digital signatures provide authentication, message
                     integrity, and non-repudiation with proof of origin.
                     Encryption provides data confidentiality. Compression can
                     be used to reduce data size. This document obsoletes RFC
                     2633. [STANDARDS TRACK]</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="5751" />
            <format
               octets="53328"
               target="http://www.rfc-editor.org/rfc/rfc5751.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC3864">
            <front>
               <title>Registration Procedures for Message Header Fields</title>
               <author
                  fullname="G. Klyne"
                  initials="G."
                  surname="Klyne">
                  <organization />
               </author>

               <author
                  fullname="M. Nottingham"
                  initials="M."
                  surname="Nottingham">
                  <organization />
               </author>

               <author
                  fullname="J. Mogul"
                  initials="J."
                  surname="Mogul">
                  <organization />
               </author>

               <date
                  month="September"
                  year="2004" />

               <abstract>
                  <t>This specification defines registration procedures for the
                     message header fields used by Internet mail, HTTP, Netnews
                     and other applications. This document specifies an Internet
                     Best Current Practices for the Internet Community, and
                     requests discussion and suggestions for improvements.</t>
               </abstract>
            </front>

            <seriesInfo
               name="BCP"
               value="90" />
            <seriesInfo
               name="RFC"
               value="3864" />
            <format
               octets="36231"
               target="http://www.rfc-editor.org/rfc/rfc3864.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC4033">
            <front>
               <title>DNS Security Introduction and Requirements</title>
               <author
                  fullname="R. Arends"
                  initials="R."
                  surname="Arends">
                  <organization />
               </author>

               <author
                  fullname="R. Austein"
                  initials="R."
                  surname="Austein">
                  <organization />
               </author>

               <author
                  fullname="M. Larson"
                  initials="M."
                  surname="Larson">
                  <organization />
               </author>

               <author
                  fullname="D. Massey"
                  initials="D."
                  surname="Massey">
                  <organization />
               </author>

               <author
                  fullname="S. Rose"
                  initials="S."
                  surname="Rose">
                  <organization />
               </author>

               <date
                  month="March"
                  year="2005" />

               <abstract>
                  <t>The Domain Name System Security Extensions (DNSSEC) add
                     data origin authentication and data integrity to the Domain
                     Name System. This document introduces these extensions and
                     describes their capabilities and limitations. This document
                     also discusses the services that the DNS security
                     extensions do and do not provide. Last, this document
                     describes the interrelationships between the documents that
                     collectively describe DNSSEC. [STANDARDS TRACK]</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="4033" />
            <format
               octets="52445"
               target="http://www.rfc-editor.org/rfc/rfc4033.txt"
               type="TXT" />
         </reference>


         <reference
            anchor="RFC4409">
            <front>
               <title>Message Submission for Mail</title>
               <author
                  fullname="R. Gellens"
                  initials="R."
                  surname="Gellens">
                  <organization>QUALCOMM</organization>
               </author>
               <author
                  fullname="J. Klensin"
                  initials="J."
                  surname="Klensin"> </author>
               <date
                  month="April"
                  year="2006" />
            </front>
            <seriesInfo
               name="RFC"
               value="4409" />
         </reference>


         <reference
            anchor="RFC4686">
            <front>
               <title>Analysis of Threats Motivating DomainKeys Identified Mail
                  (DKIM)</title>
               <author
                  fullname="J. Fenton"
                  initials="J."
                  surname="Fenton">
                  <organization />
               </author>

               <date
                  month="September"
                  year="2006" />

               <abstract>
                  <t>This document provides an analysis of some threats against
                     Internet mail that are intended to be addressed by
                     signature-based mail authentication, in particular
                     DomainKeys Identified Mail. It discusses the nature and
                     location of the bad actors, what their capabilities are,
                     and what they intend to accomplish via their attacks. This
                     memo provides information for the Internet community.</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="4686" />
            <format
               octets="70382"
               target="http://www.rfc-editor.org/rfc/rfc4686.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC4870">
            <front>
               <title>Domain-Based Email Authentication Using Public Keys
                  Advertised in the DNS (DomainKeys)</title>
               <author
                  fullname="M. Delany"
                  initials="M."
                  surname="Delany">
                  <organization />
               </author>

               <date
                  month="May"
                  year="2007" />

               <abstract>
                  <t>"DomainKeys" creates a domain-level authentication
                     framework for email by using public key technology and the
                     DNS to prove the provenance and contents of an
                     email.&lt;/t>&lt;t> This document defines a framework for
                     digitally signing email on a per-domain basis. The ultimate
                     goal of this framework is to unequivocally prove and
                     protect identity while retaining the semantics of Internet
                     email as it is known today.&lt;/t>&lt;t> Proof and
                     protection of email identity may assist in the global
                     control of "spam" and "phishing". This memo defines a
                     Historic Document for the Internet community.</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="4870" />
            <format
               octets="87378"
               target="http://www.rfc-editor.org/rfc/rfc4870.txt"
               type="TXT" />
         </reference>


         <reference
            anchor="RFC4871">
            <front>
               <title>DomainKeys Identified Mail (DKIM) Signatures</title>
               <author
                  fullname="E. Allman"
                  initials="E."
                  surname="Allman">
                  <organization />
               </author>

               <author
                  fullname="J. Callas"
                  initials="J."
                  surname="Callas">
                  <organization />
               </author>

               <author
                  fullname="M. Delany"
                  initials="M."
                  surname="Delany">
                  <organization />
               </author>

               <author
                  fullname="M. Libbey"
                  initials="M."
                  surname="Libbey">
                  <organization />
               </author>

               <author
                  fullname="J. Fenton"
                  initials="J."
                  surname="Fenton">
                  <organization />
               </author>

               <author
                  fullname="M. Thomas"
                  initials="M."
                  surname="Thomas">
                  <organization />
               </author>

               <date
                  month="May"
                  year="2007" />

               <abstract>
                  <t>DomainKeys Identified Mail (DKIM) defines a domain-level
                     authentication framework for email using public-key
                     cryptography and key server technology to permit
                     verification of the source and contents of messages by
                     either Mail Transfer Agents (MTAs) or Mail User Agents
                     (MUAs). The ultimate goal of this framework is to permit a
                     signing domain to assert responsibility for a message, thus
                     protecting message signer identity and the integrity of the
                     messages they convey while retaining the functionality of
                     Internet email as it is known today. Protection of email
                     identity may assist in the global control of "spam" and
                     "phishing". [STANDARDS TRACK]</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="4871" />
            <format
               octets="166054"
               target="http://www.rfc-editor.org/rfc/rfc4871.txt"
               type="TXT" />
         </reference>

         <reference
            anchor="RFC5451">
            <front>
               <title>Message Header Field for Indicating Message Authentication
                  Status</title>
               <author
                  fullname="M. Kucherawy"
                  initials="M."
                  surname="Kucherawy">
                  <organization />
               </author>
               <date
                  month="April"
                  year="2009" />
               <abstract>
                  <t>This memo defines a new header field for use with
                     electronic mail messages to indicate the results of message
                     authentication efforts. Any receiver-side software, such as
                     mail filters or Mail User Agents (MUAs), may use this
                     message header field to relay that information in a
                     convenient way to users or to make sorting and filtering
                     decisions. [STANDARDS TRACK]</t>
               </abstract>
            </front>

            <seriesInfo
               name="RFC"
               value="5451" />
            <format
               octets="97404"
               target="http://www.rfc-editor.org/rfc/rfc5451.txt"
               type="TXT" />
         </reference>
      </references>


      <section
         title="Example of Use (INFORMATIVE)">

         <t>This section shows the complete flow of an email from submission to
            final delivery, demonstrating how the various components fit
            together. The key used in this example is shown in <xref
               target="createpkey" />.</t>


         <section
            title="The User Composes an Email">
            <t>
               <figure
                  anchor="usercompose"
                  title="The User Composes an Email">
                  <artwork><![CDATA[From: Joe SixPack <joe@football.example.com>
To: Suzie Q <suzie@shopping.example.net>
Subject: Is dinner ready?
Date: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)
Message-ID: <;20030712040037.46341.5F8J@football.example.com>

Hi.

We lost the game. Are you hungry yet?

Joe.]]></artwork>
               </figure>
            </t>

         </section>


         <section
            title="The Email is Signed">

            <t>
               <figure
                  align="left"
                  title="The Email is Signed">
                  <preamble>This email is signed by the example.com outbound
                     email server and now looks like this:</preamble>
                  <artwork><![CDATA[DKIM-Signature: v=1; a=rsa-sha256; s=brisbane; d=example.com;
     c=simple/simple; q=dns/txt; i=joe@football.example.com;
     h=Received : From : To : Subject : Date : Message-ID;
     bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;
     b=AuUoFEfDxTDkHlLXSZEpZj79LICEps6eda7W3deTVFOk4yAUoqOB
     4nujc7YopdG5dWLSdNg6xNAZpOPr+kHxt1IrE+NahM6L/LbvaHut
     KVdkLLkpVaVVQPzeRDI009SO2Il5Lu7rDNH6mZckBdrIx0orEtZV
     4bmp/YzhwvcubU4=;
Received: from client1.football.example.com  [192.0.2.1]
     by submitserver.example.com with SUBMISSION;
     Fri, 11 Jul 2003 21:01:54 -0700 (PDT)
From: Joe SixPack <joe@football.example.com>
To: Suzie Q <suzie@shopping.example.net>
Subject: Is dinner ready?
Date: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)
Message-ID: <20030712040037.46341.5F8J@football.example.com>

Hi.

We lost the game. Are you hungry yet?

Joe.]]></artwork>
               </figure>
            </t>

            <t>The signing email server requires access to the private key
               associated with the "brisbane" selector to generate this
               signature.</t>
         </section>


         <section
            title="The Email Signature is Verified">

            <t>The signature is normally verified by an inbound SMTP server or
               possibly the final delivery agent. However, intervening MTAs can
               also perform this verification if they choose to do so. The
               verification process uses the domain "example.com" extracted from
               the "d=" tag and the selector "brisbane" from the "s=" tag in the
               DKIM- Signature header field to form the DNS DKIM query for:
               brisbane._domainkey.example.com</t>

            <t>Signature verification starts with the physically last Received
               header field, the From header field, and so forth, in the order
               listed in the "h=" tag. Verification follows with a single CRLF
               followed by the body (starting with "Hi."). The email is
               canonically prepared for verifying with the "simple" method. The
               result of the query and subsequent verification of the signature
               is stored (in this example) in the X-Authentication-Results
               header field line. After successful verification, the email looks
               like this: <figure
                  align="left"
                  title="Successful verification">
                  <artwork><![CDATA[X-Authentication-Results: shopping.example.net
  header.from=joe@football.example.com; dkim=pass
Received: from mout23.football.example.com (192.168.1.1)
  by shopping.example.net with SMTP;
  Fri, 11 Jul 2003 21:01:59 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; s=brisbane; d=example.com;
  c=simple/simple; q=dns/txt; i=joe@football.example.com;
  h=Received : From : To : Subject : Date : Message-ID;
  bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;
  b=AuUoFEfDxTDkHlLXSZEpZj79LICEps6eda7W3deTVFOk4yAUoqOB
    4nujc7YopdG5dWLSdNg6xNAZpOPr+kHxt1IrE+NahM6L/LbvaHut
    KVdkLLkpVaVVQPzeRDI009SO2Il5Lu7rDNH6mZckBdrIx0orEtZV
    4bmp/YzhwvcubU4=;
Received: from client1.football.example.com  [192.0.2.1]
  by submitserver.example.com with SUBMISSION;
  Fri, 11 Jul 2003 21:01:54 -0700 (PDT)
From: Joe SixPack <joe@football.example.com>
To: Suzie Q <suzie@shopping.example.net>
Subject: Is dinner ready?
Date: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)
Message-ID: <20030712040037.46341.5F8J@football.example.com>

Hi.

We lost the game. Are you hungry yet?

Joe.]]></artwork>
               </figure></t>
         </section>
      </section>

      <section
         title="Usage Examples (INFORMATIVE)">

         <t> DKIM signing and validating can be used in different ways, for
            different operational scenarios. This Appendix discusses some common
            examples. <list>
               <t>NOTE: Descriptions in this Appendix are for informational
                  purposes only. They describe various ways that DKIM can be
                  used, given particular constraints and needs. In no case are
                  these examples intended to be taken as providing explanation
                  or guidance concerning DKIM specification details, when
                  creating an implementation.</t>
            </list></t>


         <section
            title="Alternate Submission Scenarios">

            <t>In the most simple scenario, a user's MUA, MSA, and Internet
               (boundary) MTA are all within the same administrative
               environment, using the same domain name. Therefore, all of the
               components involved in submission and initial transfer are
               related. However, it is common for two or more of the components
               to be under independent administrative control. This creates
               challenges for choosing and administering the domain name to use
               for signing, and for its relationship to common email identity
               header fields.</t>

            <section
               title="Delegated Business Functions">

               <t>Some organizations assign specific business functions to
                  discrete groups, inside or outside the organization. The goal,
                  then, is to authorize that group to sign some mail, but to
                  constrain what signatures they can generate. DKIM selectors
                  (the "s=" signature tag) facilitate this kind of restricted
                  authorization. Examples of these outsourced business functions
                  are legitimate email marketing providers and corporate
                  benefits providers.</t>

               <t>Here, the delegated group needs to be able to send messages
                  that are signed, using the email domain of the client company.
                  At the same time, the client often is reluctant to register a
                  key for the provider that grants the ability to send messages
                  for arbitrary addresses in the domain.</t>

               <t>There are multiple ways to administer these usage scenarios.
                  In one case, the client organization provides all of the
                  public query service (for example, DNS) administration, and in
                  another it uses DNS delegation to enable all ongoing
                  administration of the DKIM key record by the delegated
                  group.</t>

               <t>If the client organization retains responsibility for all of
                  the DNS administration, the outsourcing company can generate a
                  key pair, supplying the public key to the client company,
                  which then registers it in the query service, using a unique
                  selector. The client company retains control over the use of
                  the delegated key because it retains the ability to revoke the
                  key at any time.</t>

               <t>If the client wants the delegated group to do the DNS
                  administration, it can have the domain name that is specified
                  with the selector point to the provider's DNS server. The
                  provider then creates and maintains all of the DKIM signature
                  information for that selector. Hence, the client cannot
                  provide constraints on the Local-part of addresses that get
                  signed, but it can revoke the provider's signing rights by
                  removing the DNS delegation record.</t>

            </section>
            <section
               title="PDAs and Similar Devices">

               <t>PDAs demonstrate the need for using multiple keys per domain.
                  Suppose that John Doe wanted to be able to send messages using
                  his corporate email address, jdoe@example.com, and his email
                  device did not have the ability to make a Virtual Private
                  Network (VPN) connection to the corporate network, either
                  because the device is limited or because there are
                  restrictions enforced by his Internet access provider. If the
                  device was equipped with a private key registered for
                  jdoe@example.com by the administrator of the example.com
                  domain, and appropriate software to sign messages, John could
                  sign the message on the device itself before transmission
                  through the outgoing network of the access service
                  provider.</t>

            </section>
            <section
               title="Roaming Users">

               <t>Roaming users often find themselves in circumstances where it
                  is convenient or necessary to use an SMTP server other than
                  their home server; examples are conferences and many hotels.
                  In such circumstances, a signature that is added by the
                  submission service will use an identity that is different from
                  the user's home system.</t>

               <t>Ideally, roaming users would connect back to their home server
                  using either a VPN or a SUBMISSION server running with SMTP
                  AUTHentication on port 587. If the signing can be performed on
                  the roaming user's laptop, then they can sign before
                  submission, although the risk of further modification is high.
                  If neither of these are possible, these roaming users will not
                  be able to send mail signed using their own domain key.</t>

            </section>
            <section
               title="Independent (Kiosk) Message Submission">

               <t>Stand-alone services, such as walk-up kiosks and web-based
                  information services, have no enduring email service
                  relationship with the user, but users occasionally request
                  that mail be sent on their behalf. For example, a website
                  providing news often allows the reader to forward a copy of
                  the article to a friend. This is typically done using the
                  reader's own email address, to indicate who the author is.
                  This is sometimes referred to as the "Evite problem", named
                  after the website of the same name that allows a user to send
                  invitations to friends.</t>

               <t>A common way this is handled is to continue to put the
                  reader's email address in the From header field of the
                  message, but put an address owned by the email posting site
                  into the Sender header field. The posting site can then sign
                  the message, using the domain that is in the Sender field.
                  This provides useful information to the receiving email site,
                  which is able to correlate the signing domain with the initial
                  submission email role.</t>

               <t>Receiving sites often wish to provide their end users with
                  information about mail that is mediated in this fashion.
                  Although the real efficacy of different approaches is a
                  subject for human factors usability research, one technique
                  that is used is for the verifying system to rewrite the From
                  header field, to indicate the address that was verified. For
                  example: From: John Doe via news@news-site.com
                  &lt;jdoe@example.com&gt;. (Note that such rewriting will break
                  a signature, unless it is done after the verification pass is
                  complete.)</t>
            </section>
         </section>

         <section
            title="Alternate Delivery Scenarios">

            <t>Email is often received at a mailbox that has an address
               different from the one used during initial submission. In these
               cases, an intermediary mechanism operates at the address
               originally used and it then passes the message on to the final
               destination. This mediation process presents some challenges for
               DKIM signatures.</t>

            <section
               title="Affinity Addresses">

               <t>"Affinity addresses" allow a user to have an email address
                  that remains stable, even as the user moves among different
                  email providers. They are typically associated with college
                  alumni associations, professional organizations, and
                  recreational organizations with which they expect to have a
                  long-term relationship. These domains usually provide
                  forwarding of incoming email, and they often have an
                  associated Web application that authenticates the user and
                  allows the forwarding address to be changed. However, these
                  services usually depend on users sending outgoing messages
                  through their own service providers' MTAs. Hence, mail that is
                  signed with the domain of the affinity address is not signed
                  by an entity that is administered by the organization owning
                  that domain.</t>

               <t>With DKIM, affinity domains could use the Web application to
                  allow users to register per-user keys to be used to sign
                  messages on behalf of their affinity address. The user would
                  take away the secret half of the key pair for signing, and the
                  affinity domain would publish the public half in DNS for
                  access by verifiers.</t>

               <t>This is another application that takes advantage of user-level
                  keying, and domains used for affinity addresses would
                  typically have a very large number of user-level keys.
                  Alternatively, the affinity domain could handle outgoing mail,
                  operating a mail submission agent that authenticates users
                  before accepting and signing messages for them. This is of
                  course dependent on the user's service provider not blocking
                  the relevant TCP ports used for mail submission.</t>

            </section>

            <section
               title="Simple Address Aliasing (.forward)">

               <t>In some cases a recipient is allowed to configure an email
                  address to cause automatic redirection of email messages from
                  the original address to another, such as through the use of a
                  Unix .forward file. In this case, messages are typically
                  redirected by the mail handling service of the recipient's
                  domain, without modification, except for the addition of a
                  Received header field to the message and a change in the
                  envelope recipient address. In this case, the recipient at the
                  final address' mailbox is likely to be able to verify the
                  original signature since the signed content has not changed,
                  and DKIM is able to validate the message signature.</t>

            </section>

            <section
               title="Mailing Lists and Re-Posters">

               <t>There is a wide range of behaviors in services that take
                  delivery of a message and then resubmit it. A primary example
                  is with mailing lists (collectively called "forwarders"
                  below), ranging from those that make no modification to the
                  message itself, other than to add a Received header field and
                  change the envelope information, to those that add header
                  fields, change the Subject header field, add content to the
                  body (typically at the end), or reformat the body in some
                  manner. The simple ones produce messages that are quite
                  similar to the automated alias services. More elaborate
                  systems essentially create a new message.</t>

               <t>A Forwarder that does not modify the body or signed header
                  fields of a message is likely to maintain the validity of the
                  existing signature. It also could choose to add its own
                  signature to the message.</t>

               <t>Forwarders which modify a message in a way that could make an
                  existing signature invalid are particularly good candidates
                  for adding their own signatures (e.g.,
                  mailing-list-name@example.net). Since (re-)signing is taking
                  responsibility for the content of the message, these signing
                  forwarders are likely to be selective, and forward or re-sign
                  a message only if it is received with a valid signature or if
                  they have some other basis for knowing that the message is not
                  spoofed.</t>

               <t>A common practice among systems that are primarily
                  redistributors of mail is to add a Sender header field to the
                  message, to identify the address being used to sign the
                  message. This practice will remove any preexisting Sender
                  header field as required by <xref
                     target="RFC5322" />. The forwarder applies a new
                  DKIM-Signature header field with the signature, public key,
                  and related information of the forwarder.</t>
            </section>
         </section>
      </section>

      <section
         anchor="createpkey"
         title="Creating a Public Key (INFORMATIVE)">

         <t> The default signature is an RSA signed SHA256 digest of the
            complete email. For ease of explanation, the openssl command is used
            to describe the mechanism by which keys and signatures are managed.
            One way to generate a 1024-bit, unencrypted private key suitable for
            DKIM is to use openssl like this: <figure>
               <artwork><![CDATA[$ openssl genrsa -out rsa.private 1024]]></artwork>
            </figure> For increased security, the "-passin" parameter can also
            be added to encrypt the private key. Use of this parameter will
            require entering a password for several of the following steps.
            Servers may prefer to use hardware cryptographic support.</t>

         <t>
            <figure
               align="left">
               <preamble>The "genrsa" step results in the file rsa.private
                  containing the key information similar to this:</preamble>
               <artwork><![CDATA[-----BEGIN RSA PRIVATE KEY-----
MIICXwIBAAKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYtIxN2SnFC
jxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/RtdC2UzJ1lWT947qR+Rcac2gb
to/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB
AoGBALmn+XwWk7akvkUlqb+dOxyLB9i5VBVfje89Teolwc9YJT36BGN/l4e0l6QX
/1//6DWUTB3KI6wFcm7TWJcxbS0tcKZX7FsJvUz1SbQnkS54DJck1EZO/BLa5ckJ
gAYIaqlA9C0ZwM6i58lLlPadX/rtHb7pWzeNcZHjKrjM461ZAkEA+itss2nRlmyO
n1/5yDyCluST4dQfO8kAB3toSEVc7DeFeDhnC1mZdjASZNvdHS4gbLIA1hUGEF9m
3hKsGUMMPwJBAPW5v/U+AWTADFCS22t72NUurgzeAbzb1HWMqO4y4+9Hpjk5wvL/
eVYizyuce3/fGke7aRYw/ADKygMJdW8H/OcCQQDz5OQb4j2QDpPZc0Nc4QlbvMsj
7p7otWRO5xRa6SzXqqV3+F0VpqvDmshEBkoCydaYwc2o6WQ5EBmExeV8124XAkEA
qZzGsIxVP+sEVRWZmW6KNFSdVUpk3qzK0Tz/WjQMe5z0UunY9Ax9/4PVhp/j61bf
eAYXunajbBSOLlx4D+TunwJBANkPI5S9iylsbLs6NkaMHV6k5ioHBBmgCak95JGX
GMot/L2x0IYyMLAz6oLWh2hm7zwtb0CgOrPo1ke44hFYnfc=
-----END RSA PRIVATE KEY-----]]></artwork>
            </figure>
         </t>

         <t>
            <figure>
               <preamble>To extract the public-key component from the private
                  key, use openssl like this:</preamble>
               <artwork><![CDATA[$ openssl rsa -in rsa.private -out rsa.public -pubout -outform PEM]]></artwork>
            </figure>
         </t>

         <t>
            <figure
               align="left">
               <preamble>This results in the file rsa.public containing the key
                  information similar to this:</preamble>
               <artwork><![CDATA[-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkM
oGeLnQg1fWn7/zYtIxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/R
tdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToI
MmPSPDdQPNUYckcQ2QIDAQAB
-----END PUBLIC KEY-----]]></artwork>
            </figure>
            <figure
               align="left">
               <preamble>This public-key data (without the BEGIN and END tags)
                  is placed in the DNS:</preamble>
               <artwork><![CDATA[brisbane IN  TXT  ("v=DKIM1; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQ"
                   "KBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYt"
                   "IxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v"
                   "/RtdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhi"
                   "tdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB")]]></artwork>
            </figure>
         </t>
      </section>


      <section
         title="MUA Considerations">

         <t>When a DKIM signature is verified, the processing system sometimes
            makes the result available to the recipient user's MUA. How to
            present this information to the user in a way that helps them is a
            matter of continuing human factors usability research. The tendency
            is to have the MUA highlight the SDID, in an attempt to show the
            user the identity that is claiming responsibility for the message.
            An MUA might do this with visual cues such as graphics, or it might
            include the address in an alternate view, or it might even rewrite
            the original From address using the verified information. Some MUAs
            might indicate which header fields were protected by the validated
            DKIM signature. This could be done with a positive indication on the
            signed header fields, with a negative indication on the unsigned
            header fields, by visually hiding the unsigned header fields, or
            some combination of these. If an MUA uses visual indications for
            signed header fields, the MUA probably needs to be careful not to
            display unsigned header fields in a way that might be construed by
            the end user as having been signed. If the message has an l= tag
            whose value does not extend to the end of the message, the MUA might
            also hide or mark the portion of the message body that was not
            signed.</t>

         <t>The aforementioned information is not intended to be exhaustive. The
            MUA may choose to highlight, accentuate, hide, or otherwise display
            any other information that may, in the opinion of the MUA author, be
            deemed important to the end user.</t>
      </section>

      <section
         title="Acknowledgements">

         <t>The previous IETF version of DKIM <xref
               target="RFC4871" /> was edited by: Eric Allman, Jon Callas, Mark
            Delany, Miles Libbey, Jim Fenton and Michael Thomas.</t>
         <t>That specification was the result of an extended, collaborative
            effort, including participation by: Russ Allbery, Edwin Aoki, Claus
            Assmann, Steve Atkins, Rob Austein, Fred Baker, Mark Baugher, Steve
            Bellovin, Nathaniel Borenstein, Dave Crocker, Michael Cudahy, Dennis
            Dayman, Jutta Degener, Frank Ellermann, Patrik Faeltstroem, Mark
            Fanto, Stephen Farrell, Duncan Findlay, Elliot Gillum, Olafur
            Gu[eth]mundsson, Phillip Hallam-Baker, Tony Hansen, Sam Hartman,
            Arvel Hathcock, Amir Herzberg, Paul Hoffman, Russ Housley, Craig
            Hughes, Cullen Jennings, Don Johnsen, Harry Katz, Murray S.
            Kucherawy, Barry Leiba, John Levine, Charles Lindsey, Simon
            Longsdale, David Margrave, Justin Mason, David Mayne, Thierry
            Moreau, Steve Murphy, Russell Nelson, Dave Oran, Doug Otis, Shamim
            Pirzada, Juan Altmayer Pizzorno, Sanjay Pol, Blake Ramsdell,
            Christian Renaud, Scott Renfro, Neil Rerup, Eric Rescorla, Dave
            Rossetti, Hector Santos, Jim Schaad, the Spamhaus.org team, Malte S.
            Stretz, Robert Sanders, Rand Wacker, Sam Weiler, and Dan Wing.</t>

         <t> The earlier DomainKeys was a primary source from which DKIM was
            derived. Further information about DomainKeys is at <xref
               target="RFC4870" />.</t>
      </section>



   </back>
</rfc>
