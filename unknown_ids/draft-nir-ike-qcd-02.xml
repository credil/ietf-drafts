<?xml version="1.0"?>
<?xml-stylesheet type='text/xsl' href='./rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc symrefs="no"?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc strict="yes" ?>
<?rfc linkmailto="yes" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" >
    

<?xml-stylesheet type='text/xsl' href='./rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes" ?>
<?rfc subcompact="yes" ?>
<?rfc sortrefs="yes" ?>
<rfc ipr="full3978" docName="draft-nir-ike-qcd-02" category="std">
  <front>
    <title abbrev="Quick Crash Detection">A Quick Crash Detection Method for IKE</title>
    <author initials="Y." surname="Nir" fullname="Yoav Nir">
      <organization abbrev="Check Point">Check Point Software Technologies Ltd.</organization>
      <address>
        <postal>
          <street>5 Hasolelim st.</street>
          <city>Tel Aviv</city>
          <code>67897</code>
          <country>Israel</country>
        </postal>
        <email>ynir@checkpoint.com</email>
      </address>
    </author>
    <author initials="F." surname="Detienne" fullname="Frederic Detienne">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>De Kleetlaan, 7</street>
          <city>Diegem</city>
          <code>B-1831</code>
          <country>Belgium</country>
        </postal>
        <phone>+32 2 704 5681</phone>
        <email>fd@cisco.com</email>
      </address>
    </author>
    <author initials="P." surname="Sethi" fullname="Pratima Sethi">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>O'Shaugnessy Road, 11</street>
          <city>Bangalore</city>
          <region>Karnataka</region>
          <code>560027</code>
          <country>India</country>
        </postal>
        <phone>+91 80 4154 1654</phone>
        <email>psethi@cisco.com</email>
      </address>
    </author>
    <date year="2008"/>
    <area>Security Area</area>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t> This document describes an extension to the IKEv2 protocol that allows for faster 
        detection of SA desynchronization using a saved token.</t>
      <t> When an IPsec tunnel between two IKEv2 peers is disconnected due to a restart of one peer,
        it can take as much as several minutes for the other peer to discover that the reboot has 
        occurred, thus delaying recovery. In this text we propose an extension to the protocol, 
        that allows for recovery immediately following the restart.</t>
    </abstract>
  </front>
  <middle>
    <!-- ====================================================================== -->
    <section anchor="introduction" title="Introduction">
      <t> IKEv2, as described in <xref target="RFC4306"/> has a method for recovering from a reboot
        of one peer. As long as traffic flows in both directions, the rebooted peer should 
        re-establish the tunnels immediately. However, in many cases the rebooted peer is a VPN
        gateway that protects only servers, or else the non-rebooted peer has a dynamic IP address. 
        In such cases, the rebooted peer will not be able to re-establish the tunnels. 
        <xref target="SCR"/> describes how recovery works under RFC 4306, and explains why it 
        takes several minutes.</t> 
      <t> The method proposed here, is to send a token in the IKE_AUTH exchange that establishes 
        the tunnel. That token can be stored on the peer as part of the IKE SA. After a reboot, the 
        rebooted implementation can re-generate the token, and send it to the non-rebooted peer so 
        as to delete the IKE SA. Deleting the IKE SA results is a quick re-establishment of the 
        IPsec tunnels. This is described in <xref target="outline"/>.</t>
<!--        
      <t> Finally, <xref target="outline_stateless"/> describes a variant that does not require
        storing state on the non-rebooted peer, but does require an extra round-trip.</t>
-->        
      <section anchor="mustshouldmay" title="Conventions Used in This Document">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
          "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described
          in <xref target="RFC2119"/>.</t>
        <t> The term "token" refers to an octet string that an implementation can generate using 
          only the IKE SPIs as input. A conforming implementation MUST be able to generate the same
          token from the same input even after rebooting.</t>
        <t> The term "token maker" refers to an implementation that generates a token and sends it
          to the peer in the IKE_AUTH exchange.</t>
        <t> The term "token taker" refers to an implementation that stores such a token or a digest
          thereof, after receiving it in an IKE_AUTH exchange.</t>
      </section>
      </section>
      <section anchor="SCR" title="RFC 4306 Crash Recovery">
        <t> When one peer reboots, the other peer does not get any notification, so IPsec traffic
          can still flow. The rebooted peer will not be able to decrypt it, however, and the only
          remedy is to send an unprotected INVALID_SPI notification as described in section 3.10.1 
          of <xref target="RFC4306"/>.  That section also describes the processing of such a 
          notification: "If this Informational Message is sent outside the context of an IKE_SA, 
          it should be used by the recipient only as a "hint" that something might be wrong (because 
          it could easily be forged)."</t>
        <t> Since the INVALID_SPI can only be used as a hint, the non-rebooted peer has to determine
          whether the IPsec SA, and indeed the parent IKE SA are still valid.  The method of doing 
          this is described in section 2.4 of <xref target="RFC4306"/>. This method, called 
          "liveness check" involves sending a protected empty INFORMATIONAL message, and awaiting a 
          response. This procedure is sometimes referred to as "Dead Peer Detection" or DPD.</t>
        <t> Section 2.4 does not mandate how many times the liveness check message should be 
          retransmitted, or for how long, but does recommend the following: "It is suggested that
          messages be retransmitted at least a dozen times over a period of at least several minutes
          before giving up on an SA". Clearly, implementations differ, but all will take a significant
          amount of time.</t>
      </section>
      <section anchor="outline" title="Protocol Outline">
        <t> Supporting implementations will send a notification, called a "QCD token", as described
          in <xref target="format_notif"/> in the last packets of the IKE_AUTH exchange.  
          These are the final request and final response that contain the AUTH payloads.  The 
          generation of these tokens is a local matter for implementations, but considerations are 
          described in <xref target="tokengen"/>. Implementations that send such a token will be
          called "token makers".</t>
        <t> A supporting implementation receiving such a token SHOULD store it as part of the IKE 
          SA. Implementations that support this part of the protocol will be called "token takers".
          <xref target="operation_who"/> has considerations for which implementations need to be 
          token takers, and which should be token makers. Implementation that are not token takers 
          will silently ignore QCD tokens.</t>
        <t> When a token maker receives a protected IKE request message with unknown IKE SPIs, it 
          MUST generate a new token that is identical to the previous token, and send it to the 
          requesting peer in an unprotected IKE message as described in <xref target="format_info"/>.</t>
        <t> When a token taker receives the QCD token in an unprotected notification, it MUST verify 
          that the TOKEN_SECRET_DATA matches the token stored in the matching the IKE SA. If the 
          verification fails, or if the IKE SPIs in the message do not match any existing IKE SA,
          it SHOULD log the event. If it succeeds, it MUST delete the IKE SA associated with the 
          IKE_SPI fields, and all dependant child SAs. This event MAY also be logged. The token 
          taker MUST accept such tokens from any address, so as to allow different kinds of 
          high-availability configuration of the token maker.</t>
        <t> A supporting token taker MAY immediately create new SAs using an Initial exchange, 
          or it may wait for subsequent traffic to trigger the creation of new SAs.</t>
        <t> There is ongoing work on IKEv2 Session Resumption <xref target="resumption"/>. See 
          <xref target="int_resume"/> for a short discussion about this protocol's interaction with
          session resumption.</t>
      </section>
<!--  Commenting out the section about stateless variant
      <section anchor="outline_stateless" title="Stateless Variant Outline">
        <t> Sometimes, a QCD token is not available to the non-rebooted implementation. This can 
          happen for several reasons:<list style="symbols">
          <t> Perhaps the rebooted peer has not implemented the "token maker" part of the 
            protocol.</t>
          <t> Perhaps the non-rebooted peer is resource-constrained, and cannot spare the memory
            needed to save the token, so it did not implement the "token taker" part of the
            protocol.</t></list></t>
        <t> In such cases, we also define a stateless variant of the protocol, that does not
          require any state on the non-rebooted peer, but does require an extra round-trip.</t>
        <t> A supporting implementation will advertise this capability with a special VID payload
          as defined in <xref target="stateless_vid"/>. When such an implementation reboots and 
          sends an INVALID_SPI or INVALID_IKE_SPI notification to the non-rebooted peer, which has 
          no QCD token, the non-rebooted peer uses a CHECK_SPI notification (see 
          <xref target="intro_cspi"/>) to poll its peer about whether or not the SPI is actually 
          invalid.</t>
        <section anchor="intro_cspi" title="Introducing CHECK_SPI">
        <t> In order to achieve stateless IKE recovery, this memo introduces a new notify type 
          called CHECK_SPI.  The CHECK_SPI payload carries an SPI (IKE_SA or Child SA) and one of 
          three sub-types (QUERY, ACK, NACK).  The semantic of the CHECK_SPI subtypes is the 
          following: <list style="symbols">
          <t> QUERY: a peer queries the remote peer SA DB for the presence of the SA whose value is 
            in the payload.</t>
          <t> ACK: a peer confirms it has the SA specified in the payload.</t>
          <t> NACK: a peer confirms it does not have the SA specified in the payload.</t></list></t>
        <t> The payload format of the CHECK_SPI notify is covered in <xref target="check_fmt"/>.</t>
        </section>
        <section anchor="stateless_rec" title="Stateless Recovery">
          <t> After receiving the INVALID_SPI or INVALID_IKE_SPI notifications, the non-rebooted
            peer (called Peer Y in the figure) will send an unprotected IKE message as follows. 
            Note that Peer Y MUST NOT send this unless Peer X has advertised this capability in the
            IKE_AUTH exchange.<figure>
            <artwork><![CDATA[
   Peer X                                                  Peer Y

             HDR(A,B) INVALID_IKE_SPI(A,B)
            -------------------------------------------->

             HDR(A,B) CHECK_SPI(QUERY,(A,B)), N(Cookie)
            <--------------------------------------------

             HDR(A,B) CHECK_SPI(ACK|NACK,(A,B)), N(Cookie)
            -------------------------------------------->
            ]]></artwork>
            </figure></t>
          <t> In this figure, A & B represent the IKE SPIs, and the Cookie is a stateless cookie
            with similar considerations as the stateless cookie described in section 2.6 of RFC
            4306. The cookie SHOULD depend on the IKE SPIs and a saved secret.</t>
          <t> A similar exchange happens when the peer sends an INVALID_SPI notification:<figure>
            <artwork><![CDATA[
   Peer X                                                  Peer Y

             HDR(0,0) INVALID_SPI(a)
            -------------------------------------------->

             HDR(A,B) CHECK_SPI(QUERY,(A,B)), N(Cookie)
            <--------------------------------------------

             HDR(A,B) CHECK_SPI(ACK|NACK,(A,B)), N(Cookie)
            -------------------------------------------->
            ]]></artwork>
            </figure></t>
          <t> The difference here is that Peer Y had to locate the IKE SPIs associated with the 
            SPI mentioned in the INVALID_SPI notification.</t>
        </section>
        <section anchor="wait" title="Wait before rekey">
          <t> There exists a particular attack where a man-in-the-middle can snoop and inject 
            traffic but can not block or drop packets.  This attack can spoof INVALID_SPI 
            (allegedly from X), forcing a CHECK_SPI(QUERY) from Y. The attacker would spoof back 
            CHECK_SPI(NACK) to force an undue rekey.  Since the attacker can not block packets, the
            INVALID_SPI will also reach Alice, who will reply with CHECK_SPI(ACK).</t>
          <t> Y receives CHECK_SPI(NACK) first and MAY wait for a few msec before creating a new 
            SA.  Y will eventually receive BOTH a CHECK_SPI(ACK) and a CHECK_SPI(NACK), Which is 
            dubious.  The SIR process should then stop and log an error, saving the SA.</t>
          <t> The process is illustrated below:<figure>
            <artwork><![CDATA[
      X                 Attacker                Y
                            Inv SPI
                            ------------------>

                               CHECK_SPI(QUERY)
         <-------------------------------------

                            CHECK_SPI(NACK)
                            ------------------> Should rekey
                                                but wait a few msec

         CHECK_SPI(ACK)
         -------------------------------------> Hint of attack
                                                => no rekey
            ]]></artwork>
            </figure></t>
          <t> Ideally, the round-trip-time should be measured during the IKE exchange and Y wait 
            for a full RTT before initiating a rekey. </t>
          <t> Given that IKE itself is subject to DH computation by a man-in-the-middle, also 
            considering that SA's are dampened after creation (see <xref target="dampening"/>), the 
            staging complexity and limited interest of this attack makes it rather impractical.  An 
            implementation MAY decided to implement this final safety wait but this is strictly 
            optional.</t>
        </section>
        <section anchor="tnd" title="Throttling and Dampening">
          <t> An important aspect of the security in stateless IKE recovery has to do with 
            limiting the CPU utilization.  In order to thwart flood types denial of service attacks, 
            strict rate limiting and throttling mechanisms have to be enforced.</t>
          <t> All the notifications that are exchanged during IKE recovery SHOULD be rate limited. 
            This paragraph provides information on the way rate limiting should take place.</t>
          <section anchor="throttling" title="Invalid SPI throttling">
            <t> The sending of all Invalid SPI notifies MUST be rate limited one way or an other.  
              The rate limiting SHOULD be performed on a per peer basis but dynamic state creation 
              SHOULD be avoided as much as possible.  A recommended tradeoff is to limit the number 
              of flows that can undergo recovery at one point in time and avoid sending Invalid SPI 
              notifies for flows that are potentially already under recovery.</t>
            <t> Invalid SPI rate limiting protects against natural dangling SA occurences.  I.e. 
              normal traffic conditions may cause unrecognized SPI's to be received and this message 
              is the most important to protect.  Indeed, it is not realistic to send one 
              notification per bad ESP packet received.  On high speed links, this could mean 
              thousands of IKE notifies sent for the same offending SPI.</t>
            <t> The receiving of unauthenticated Invalid SPI notifies MUST as well be rate limited.  
              Again, the rate limiting SHOULD be performed on a per peer basis without dynamic 
              state creation.  In normal circumstances, the peer receiving Invalid SPI notifies has 
              an SA with the peer sendig those notifies and already maintains peer-related data
              structures that can help in maintaining adequate counters.</t>
            <t> Authenticated Invalid SPI notifies can be accepted without throttling.</t>
          </section>
          <section anchor="dampening" title="Dampening">
            <t> After one of the following conditions:<list style="symbols">
              <t> the natural creation or rekey of one or more SA's</t>
              <t> the recovery of one or more SA's</t>
              <t> the failure in recovering an SA owned by the local security gateway</t>
              <t> the logging of an error or warning message involving an SA owned by the local 
                security gateway </t></list></t>
            <t> The peer with which SA's were created, attempted or against which a log was emitted 
              SHOULD be dampened, which means that all the unauthenticated Invalid SPI and Check 
              SPI messages emitted by that peer MUST be ignored for a chosen duration.</t>
            <t> This protection prevents a man-in-the-middle from forcing the fast recreation of 
              SA's and potentially depleting the entropy of systems under attack. It also deals 
              efficently with race conditions that may occur after a rekey.</t>
          </section>
          <section anchor="ucontrol" title="User controls">
            <t> Because throttling at large is related to speed, the network implementation around 
              the security gateways has a major influence on the pertinence of the paremeters 
              controlling rate limiting.  It is difficult to provide good absolute values for the 
              rate limiters, considering that these are implementation dependent.</t>
            <t> As such, for the sake of fitness in practical deployments, a system implementing 
              this memo MUST provide administrative controls over the rate limiter parameters.</t>
          </section>
        </section>
      </section>
-->
      <section anchor="format" title="Formats and Exchanges">
        <section anchor="format_notif" title="Notification Format">
          <t> The notification payload called "QCD token" is formatted as follows:<figure>
            <artwork><![CDATA[
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ! Next Payload  !C!  RESERVED   !         Payload Length        !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    !  Protocol ID  !   SPI Size    ! QCD Token Notify Message Type !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    !                                                               !
    ~                       TOKEN_SECRET_DATA                       ~
    !                                                               !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]></artwork>
            </figure></t>
          <t><list style="symbols">
            <t>Protocol ID (1 octet) MUST contain 1, as this message is related to an IKE SA.</t>
            <t>SPI Size (1 octet) MUST be zero, in conformance with <xref target="RFC4306"/>.</t>
            <t>QCD Token Notify Message Type (2 octets) - MUST be xxxxx, the value assigned for QCD
              token notifications. TBA by IANA.</t>
            <t>TOKEN_SECRET_DATA (16-128 octets) contains a generated token as described in 
              <xref target="tokengen"/>.</t>
          </list></t>
        </section>
<!--        
        <section anchor="check_fmt" title="CHECK_SPI">
          <t> The notification payload called "CHECK_SPI" is formatted as follows:<figure>
            <artwork><![CDATA[
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ! Next Payload  !C!  RESERVED   !         Payload Length        !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    !  Protocol ID  !   SPI Size    ! CHECK_SPI Notify Message Type !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ! Operation     ! 
    +-+-+-+-+-+-+-+-+
            ]]></artwork>
            </figure></t>
          <t><list style="symbols">
            <t>Protocol ID (1 octet) MUST contain 1, as this message is related to an IKE SA.</t>
            <t>SPI Size (1 octet) MUST be zero, in conformance with <xref target="RFC4306"/>.</t>
            <t>CHECK_SPI Notify Message Type (2 octets) - MUST be xxxxx, the value assigned for 
              CHECK_SPI notifications. TBA by IANA.</t>
            <t>Operation (1 Octet) - This field determines the operation being performed (Query, 
              Reply_ACK, Reply_NACK)</t></list></t>
          <t> The list of operations and their corresponding value:<list style="symbols">
            <t> Query: 0</t>
            <t> Reply_ACK: 1</t>
            <t> NACK: 2</t></list></t>
        </section>
        <section anchor="stateless_vid" title="Stateless IKE Recovery VendorID">
          <t> The stateless IKE recovery VendorID or SIR_VID is as follows:</t>
          <t>"SIR STATELESS" hex: 53 49 52 20 53 54 41 54 45 4c 45 53 53</t>
          <t> This VendorID payload MUST be sent in the first IKE_AUTH message of any implementation 
            that supports the stateless variant of this protocol.</t>
        </section>
-->
        <section anchor="format_auth" title="Passing a Token in the AUTH Exchange">
          <t> For clarity, only the EAP version of an AUTH exchange will be presented here. The 
            non-EAP version is very similar. The figures below are based on appendix A.3 of
            <xref target="RFC4718"/>.<figure>
            <artwork><![CDATA[
 first request       --> IDi,
                         [N(INITIAL_CONTACT)],
                         [[N(HTTP_CERT_LOOKUP_SUPPORTED)], CERTREQ+],
                         [IDr],
                         [CP(CFG_REQUEST)],
                         [N(IPCOMP_SUPPORTED)+],
                         [N(USE_TRANSPORT_MODE)],
                         [N(ESP_TFC_PADDING_NOT_SUPPORTED)],
                         [N(NON_FIRST_FRAGMENTS_ALSO)],
                         SA, TSi, TSr,
                         [V(SIR_VID)]
                         [V+]

 first response      <-- IDr, [CERT+], AUTH,
                         EAP,
                         [V(SIR_VID)]
                         [V+]

                   / --> EAP
 repeat 1..N times |
                   \ <-- EAP

 last request        --> AUTH
                         [N(QCD_TOKEN)]

 last response       <-- AUTH,
                         [N(QCD_TOKEN)]
                         [CP(CFG_REPLY)],
                         [N(IPCOMP_SUPPORTED)],
                         [N(USE_TRANSPORT_MODE)],
                         [N(ESP_TFC_PADDING_NOT_SUPPORTED)],
                         [N(NON_FIRST_FRAGMENTS_ALSO)],
                         SA, TSi, TSr,
                         [N(ADDITIONAL_TS_POSSIBLE)],
                         [V+]
            ]]></artwork>
            </figure></t>
          <t> Note that the QCD_TOKEN notification is marked as optional because it is not required
            by this specification that every implementation be both token maker and token taker. 
            If only one peer sends the QCD token, then a reboot of the other peer will not be 
            recoverable by this method. This may be acceptable if traffic typically originates from 
            the other peer.</t>
          <t> In any case, the lack of a QCD_TOKEN notification MUST NOT be taken as an indication
            that the peer does not support this standard. Conversely, if a peer does not understand 
            this notification, it will simply ignore it. Therefore a peer MAY send this notification 
            freely, even if it does not know whether the other side supports it.</t>
          <t> The QCD_TOKEN notification is related to the IKE SA and MUST follow the AUTH payload
            and precede the Configuration payload and all payloads related to the child SA.</t>
        </section>
        <section anchor="format_rekey" title="Replacing Tokens After Rekey or Resumption">
          <t> After rekeying an IKE SA, the IKE SPIs are replaced, so the new SA also needs to have
            a token.  If only the responder in the rekey exchange is the token maker, this can be
            done before within the CREATE_CHILD_SA exchange. If the initiator is a token maker, 
            then we need an extra informational exchange.</t>
          <t> The following figure shows the CREATE_CHILD_SA exchange for rekeying the IKE SA. Only
            the responder sends a stateless token.<figure>
            <artwork><![CDATA[
   request             --> SA, Ni, [KEi]

   response            <-- SA, Nr, [KEr], N(QCD_TOKEN)            
            ]]></artwork>
            </figure></t>
          <t> If the initiator is also a token maker, it SHOULD soon initiate an INFORMATIONAL
            exchange as follows:<figure>
            <artwork><![CDATA[
   request             --> N(QCD_TOKEN)

   response            <--             
            ]]></artwork>
            </figure></t>
          <t> For session resumption, as specified in <xref target="resumption"/>, the situation is 
            similar. The responder, which is necessarily the peer that has crashed, SHOULD send a 
            new ticket within the protected payload of the IKE_SESSION_RESUME exchange. If the 
            Initiator is also a token maker, it needs to send a QCD_TOKEN in a separate 
            INFORMATIONAL exchange.</t>
        </section>
        <section anchor="format_info" title="Presenting the Token in an INFORMATIONAL Exchange">
          <t> This QCD_TOKEN notification is unprotected, and is sent as a response to a protected
            IKE request, which uses an IKE SA that is unknown. <figure>
            <artwork><![CDATA[
         request             --> N(INVALID_IKE_SPI), N(QCD_TOKEN)+
            ]]></artwork>
            </figure></t>
          <t> If child SPIs are persistently mapped to IKE SPIs as described in 
            <xref target="operation_esp"/>, we may get the following exchange in response to an 
            ESP or AH packet.<figure>
            <artwork><![CDATA[
         request             --> N(INVALID_SPI), N(QCD_TOKEN)+
            ]]></artwork>
            </figure></t>
          <t> The QCD_TOKEN and INVALID_IKE_SPI notifications are sent together to support both 
            implementations that conform to this specification and implementations that don't. 
            Similar to the description in section 2.21 of <xref target="RFC4306"/>, The IKE SPI and 
            message ID fields in the packet headers are taken from the protected IKE request.</t>
          <t> To support a periodic rollover of the secret used for token generation, the token 
            taker MUST support at least four QCD_TOKEN notifications in a single packet. The token
            is considered verified if any of the QCD_TOKEN notifications matches. The token maker 
            MAY generate up to four QCD_TOKEN notifications, based on several generations of keys.</t>
          <t> If the QCD_TOKEN verifies OK, an empty response MUST be sent. If the QCD_TOKEN 
            cannot be validated, a response SHOULD NOT be sent. <xref target="tokengen"/>
            defines token verification.</t>
        </section>
      </section>
      <section anchor="tokengen" title="Token Generation and Verification">
        <t> No token generation method is mandated by this document. A method is documented in
          <xref target="tg1"/>, but only serves as an example.</t>
        <t> The following lists the requirements from a token generation mechanism:<list style="symbols">
          <t> Tokens MUST be at least 16 octets long, and no more than 128 octets long, to 
            facilitate storage and transmission. Tokens SHOULD be indistinguishable from random data.</t>
          <t> It should not be possible for an external attacker to guess the QCD token generated
            by an implementation. Cryptographic mechanisms such as PRNG and hash functions are
            RECOMMENDED.</t>
          <t> The token maker, MUST be able to re-generate or retrieve the token based on the 
            IKE SPIs even after it reboots.</t>
        </list></t>
        <section anchor="tg1" title="A Stateless Method of Token Generation">
          <t> This describes a stateless method of generating a token:<list style="symbols">
            <t> At installation or immediately after the first boot of the IKE implementation, 32 
              random octets are generated using a secure random number generator or a PRNG.</t>
            <t> Those 32 bytes, called the "QCD_SECRET", are stored in non-volatile storage on 
              the machine, and kept indefinitely.</t>
            <t> The TOKEN_SECRET_DATA is calculated as follows:<figure>
            <artwork><![CDATA[
            
         TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R)

            ]]></artwork>
            </figure></t>
            <t> If key rollover is required by policy, the implementation MAY periodically generate
              a new QCD_SECRET and keep up to 3 previous generations. When sending an unprotected 
              QCD_TOKEN, as many as 4 notification payloads may be sent, each from a different
              QCD_SECRET.</t>
          </list></t>
        </section>
        <section anchor="toklifetime" title="Token Lifetime">
          <t> The token is associated with a single IKE SA, and SHOULD be deleted by the token taker
            when the SA is deleted or expires. More formally, the token is associated with the pair 
            (SPI-I, SPI-R).</t>
        </section>
      </section>
      <section anchor="backupgw" title="Backup Gateways">
        <t> Making crash detection and recovery quick is a worthy goal, but since rebooting a 
          gateway takes a non-zero amount of time, many implementations choose to have a stand-by 
          gateway ready to take over as soon as the primary gateway fails for any reason. </t>
        <t> If such a configuration is available, it is RECOMMENDED that the stand-by gateway be
          able to generate the same token as the active gateway. if the method described in 
          <xref target="tg1"/> is used, this means that the QCD_SECRET field is identical in both 
          gateways. This has the effect of having the crash recovery available immediately.</t>
      </section>
      <section anchor="whynot" title="Alternative Solutions">
        <section anchor="newikesa" title="Initiating a new IKE SA">
        <t> Instead of sending a QCD token, we could have the rebooted implementation start an 
          Initial exchange with the peer, including the INITIAL_CONTACT notification. This would
          have the same effect, instructing the peer to erase the old IKE SA, as well as establishing
          a new IKE SA with fewer rounds.</t>
        <t> The disadvantage here, is that in IKEv2 an authentication exchange MUST have
          a piggy-backed Child SA set up. Since our use case is such that the rebooted implementation
          does not have traffic flowing to the peer, there are no good selectors for such a Child
          SA.</t>
        <t> Additionally, when authentication is asymmetric, such as when EAP is used, it is not 
          possible for the rebooted implementation to initiate IKE.</t>
        </section>
        <section anchor="bcerts" title="Birth Certificates">
          <t> Birth Certificates is a method of crash detection that has never been formally
            defined. Bill Sommerfeld suggested this idea in a mail to the IPsec mailing list on 
            August 7, 2000, in a thread discussing methods of crash detection:<figure>
           <artwork><![CDATA[
    If we have the system sign a "birth certificate" when it 
    reboots (including a reboot time or boot sequence number), 
    we could include that with a "bad spi" ICMP error and in 
    the negotiation of the IKE SA.
           ]]></artwork>
            </figure></t>
          <t> We believe that this method would have some problems. First, it requires Alice to
            store the certificate, so as to be able to compare the public keys. That requires more
            storage than does a QCD token. Additionally, the public-key operations needed to verify 
            the self-signed certificates are more expensive for Alice.</t>
          <t> We believe that a symmetric-key operation such as proposed here is more light-weight
            and simple than that implied by the Birth Certificate idea.</t>
        </section>
      </section>
      <section anchor="int_resume" title="Interaction with Session Resumption">
        <t> Session Resumption, specified in <xref target="resumption"/> proposes to make setting 
          up a new IKE SA consume less computing resources. This is particularly useful in the case 
          of a remote access gateway that has many tunnels. A failure of such a gateway would 
          require all these many remote access clients to establish an IKE SA either with the 
          rebooted gateway or with a backup gateway. This tunnel re-establishment should occur 
          within a short period of time, creating a burden on the remote access gateway. Session
          Resumption addresses this problem by having the clients store an encrypted derivative of 
          the IKE SA for quick re-establishment.</t>
        <t> What Session Resumption does not help, is the problem of detecting that the peer 
          gateway has failed. A failed gateway may go undetected for as long as the lifetime of a 
          child SA, because IPsec does not have packet acknowledgement, and applications cannot
          signal the IPsec layer that the tunnel "does not work". Before establishing a new 
          IKE SA using Session Resumption, a client MUST ascertain that the gateway has indeed 
          failed. This could be done using either a liveness check (as in RFC 4306) or using the 
          QCD tokens described in this document.</t>
        <t> A remote access client conforming to both specifications will store QCD tokens, as well
          as the Session Resumption ticket, if provided by the gateway. A remote access gateway 
          conforming to both specifications will generate a QCD token for the client. When the 
          gateway reboots, the client will discover this in either of two ways:<list style="numbers">
          <t> The client does regular liveness checks, or else the time for some other IKE exchange
            has come. Since the gateway is still down, the IKE times out after several minutes. In 
            this case QCD does not help.</t>
          <t> Either the primary gateway or a backup gateway (see <xref target="backupgw"/>) 
            is ready and sends a QCD token to the client. In that case the client will quickly
            re-establish the IPsec tunnel, either with the rebooted primary gateway, the backup
            gateway as described in this document or another gateway as described in <xref target="resumption"/>
            </t></list></t>
          <t> The full combined protocol looks like this:<figure>
            <artwork><![CDATA[
     Initiator                Responder
     -----------              -----------
    HDR, SAi1, KEi, Ni  -->

                        <--    HDR, SAr1, KEr, Nr, [CERTREQ]

    HDR, SK {IDi, [CERT,] 
    [CERTREQ,] [IDr,]
    AUTH, N(QCD_TOKEN)
    SAi2, TSi, TSr, 
    N(TICKET_REQUEST)}  -->
                        <--    HDR, SK {IDr, [CERT,] AUTH, SAr2, TSi,
                               TSr, N(TICKET_OPAQUE) 
                               [,N(TICKET_GATEWAY_LIST)]}

             ---- Reboot -----

    HDR, {}             -->
                        <--  HDR, N(QCD_Token)
                        
    HDR, Ni, N(TICKET_OPAQUE), 
    [N+,], SK {IDi, [IDr,] 
    SAi2, TSi, TSr, 
    [CP(CFG_REQUEST)]}  -->
                        <--  HDR, SK {IDr, Nr, SAr2, [TSi, TSr],
                             [CP(CFG_REPLY)]}

    
            ]]></artwork>
            </figure></t>
      </section>
    <section anchor="operation" title="Operational Considerations">
      <section anchor="operation_who" title="Who should implement this specification">
        <t> Throughout this document, we have referred to reboot time alternatingly as the time that 
          the implementation crashes and the time when it is ready to process IPsec packets and IKE 
          exchanges. Depending on the hardware and software platforms and the cause of the reboot, 
          rebooting may take anywhere from a few seconds to several minutes. If the implementation
          is down for a long time, the benefit of this protocol extension is reduced. For this reason
          critical systems should implement backup gateways as described in <xref target="backupgw"/>.
          Note that the lower-case "should" in the previous sentence is intentional, as we do not 
          specify this in the sense of RFC 2119.</t>
        <t> Implementing the "token maker" side of QCD makes sense for IKE implementation where protected
          connections originate from the peer, such as inter-domain VPNs and remote access gateways.
          Implementing the "token taker" side of QCD makes sense for IKE implementations where protected
          connections originate, such as inter-domain VPNs and remote access clients.</t>
        <t> To clarify the requirements: <list style="symbols"> 
          <t> A remote-access client MUST be a token taker and MAY be a token maker.</t>
          <t> A remote-access gateway MAY be a token taker and MUST be a token maker.</t>
          <t> An inter-domain VPN gateway MUST be both token maker and token taker.</t></list></t>
        <t> In order to limit the effects of DoS attacks, a token taker SHOULD limit the rate
          of QCD_TOKENs verified from a particular source. </t>
        <t> If excessive amounts of IKE requests protected with unknown IKE SPIs arrive at a token
          maker, the IKE module SHOULD revert to the behavior described in section 2.21 of 
          <xref target="RFC4306"/> and either send an INVALID_IKE_SPI notification, or ignore it 
          entirely.</t>
      </section>
      <section anchor="operation_esp" title="Response to unknown child SPI">
        <t> After a reboot, it is more likely that an implementation receives IPsec packets than 
          IKE packets. In that case, the rebooted implementation will send an INVALID_SPI
          notification, triggering a liveness check.  The token will only be sent in a response to
          the liveness check, thus requiring an extra round-trip.</t>
        <t> To avoid this, an implementation that has access to non-volatile storage MAY store a 
          mapping of child SPIs to owning IKE SPIs, or to generated toekns. If such a mapping is 
          available and persistent across reboots, the rebooted implementation SHOULD respond to 
          the IPsec packet with an INVALID_SPI notification, along with the appropriate QCD_Token 
          notifications. A token taker SHOULD verify the QCD token that arrives with an INVALID_SPI 
          notification the same as if it arrived with the IKE SPIs of the parent IKE SA.</t>
        <t> However, a persistent storage module might not be updated in a timely manner, and 
          could be populated with IKE SPIs that have already been rekeyed. A token taker MUST NOT
          take an invalid QCD Token sent along with an INVALID_SPI notification as evidence that 
          the peer is either malfunctioning or attacking, but it SHOULD limit the rate at which 
          such notifications are processed.</t>
      </section>
<!--      
      <section anchor="scookie" title="Stateless IKE Recovery cookie">
          <t> The cookie information is chosen by the peer that emits it. As such, the cookie has 
            strictly no meaning for the remote peer and can thus be chosen as seen fit.  This 
            section provides recommendations on how to generate and validate those cookies.</t>
          <t> When an IKE endpoint X sends an unauthenticated CHECK_SPI, the cookie payload 
            following the notify is computed as follow:<figure>
            <artwork><![CDATA[
               Cookie = VersionIDofSecret
                        | H( SECRET | CHECK_SPI(..., Query)
                        | ip.src | ip.dst
                        | udp.src | udp.dst)
            ]]></artwork>
            </figure></t>
          <t> where <list style="symbols">
            <t> SECRET is a randomly generated secret known only to the implementation and 
              periodically changed.</t>
            <t> VersionIDofSecret should be changed whenever SECRET is regenerated.</t>
            <t> CHECK_SPI(..., Query) is the content of the CHECK_SPI notify payload where the 
              operation subtype has been set to Query (cf. <xref target="intro_cspi"/>)</t>
            <t> ip.src is the source ip address of the IKE packet.</t>
            <t> ip.dst is the destination ip address of the IKE packet.</t>
            <t> udp.src is the source udp post of the IKE packet.</t>
            <t> udp.dst is the destination udp port of the IKE packet.</t></list></t>
          <t> Upon reception of a CHECK_SPI notify (ACK or NACK) followed by a N(Cookie), a peer 
            can verify whether this is the reply to a Query it placed by recomputing the cookie and 
            comparing it to the COOKIE in the IKE message.</t>
          <t> In order to minimize the range of cryptographic attacks on SECRET, its value SHOULD 
            have a limited life time.</t>
      </section>
-->      
    </section>
      <section anchor="security" title="Security Considerations">
      <section anchor="sec_handling" title="QCD Token Handling">
        <t> Tokens MUST be hard to guess. This is critical, because if an attacker can guess the 
          token associated with the IKE SA, she can tear down the IKE SA and associated tunnels at
          will. When the token is delivered in the IKE_AUTH exchange, it is encrypted. When it is
          sent again in an unprotected notification, it is not, but that is the last time this
          token is ever used.</t>
        <t> An aggregation of some tokens generated by one peer together with the related IKE SPIs
          MUST NOT give an attacker the ability to guess other tokens. Specifically, if one peer 
          does not properly secure the QCD tokens and an attacker gains access to them, this
          attacker MUST NOT be able to guess other tokens generated by the same peer. This is the
          reason that the QCD_SECRET in <xref target="tg1"/> needs to be sufficiently long.</t>
        <t> The QCD_SECRET MUST be protected from access by other parties. Anyone gaining
          access to this value will be able to delete all the IKE SAs for this token maker.</t>
        <t> The QCD token is sent by the rebooted peer in an unprotected message. A message like 
          that is subject to modification, deletion and replay by an attacker. However, these 
          attacks will not compromise the security of either side. Modification is meaningless
          because a modified token is simply an invalid token. Deletion will only cause the 
          protocol not to work, resulting in a delay in tunnel re-establishment as described in
          <xref target="SCR"/>. Replay is also meaningless, because the IKE SA has been deleted
          after the first transmission.</t>
      </section>
      <section anchor="sec_trans" title="QCD Token Transmission">
        <t> A token maker MUST NOT send a QCD token in an unprotected message for an existing IKE
          SA. This implies that a conforming QCD token maker MUST be able to tell whether a 
          particular pair of IKE SPIs represent a valid IKE SA.</t>
        <t> This requirement is obvious and easy in the case of a single gateway. However, some 
          implementations use a load balancer to divide the load between several physical gateways.
          It MUST NOT be possible even in such a configuration to trick one gateway into sending 
          a QCD token for an IKE SA which is valid on another gateway.</t>
      </section>
<!--      
      <section anchor="sec_stateles" title="Security Considerations for the Stateless Method">
        <t> IKE recovery self-protection is discussed all along the document and contains many 
          mechanism to thwart denial of service attacks.</t>
        <t> IKE recovery is subject to a man-in-the-middle attack that can let the attacker trigger 
          a renegotiation.  It has to be noticed that an attacker able to block ESP and/or IKE 
          packets can cause IKE itself to also tear down and trigger a rekey of IKE SA's.  With 
          throttling and dampening enabled, IKE recovery is able to reduce the amount of 
          rekeys/negotiations to as low a rate as IKEv2.</t>
        <t> Overall, IKE Recovery is not more vulnerable than IKEv2 and even improves on the 
          security of IKEv2 by resynchronizing SA's more rapidly which is important with dynamic 
          polices.</t>
      </section>
-->      
      </section>
      <section anchor="iana" title="IANA Considerations">
        <t> IANA is requested to assign a notify message type from the error types range
          (43-8191) of the "IKEv2 Notify Message Types" registry with name 
          "QUICK_CRASH_DETECTION".</t>
<!--
        <t> IANA is requested to assign a notify message type from the status types range
          (16406-40959) of the "IKEv2 Notify Message Types" registry with name "CHECK_SPI".</t>
-->
      </section>      
      <section anchor="ack" title="Acknowledgements">
        <t> We would like to thank Hannes Tschofenig and Yaron Sheffer for their comments about
          Session Resumption.</t>
      </section>
      <section anchor="history" title="Change Log">
        <t> This section lists all changes in this document</t>
        <t> NOTE TO RFC EDITOR : Please remove this section in the final RFC</t>
        <section anchor="history03" title="Changes from draft-nir-ike-qcd-01">
          <t><list style="symbols">
            <t> Removed stateless method.</t>
            <t> Added discussion of rekeying and resumption.</t>
            <t> Added discussion of non-synchronized load-balanced clusters of gateways in the 
              security considerations.</t>
            <t> Other wording fixes.</t>
          </list></t>
        </section>
        <section anchor="history02" title="Changes from draft-nir-ike-qcd-00">
          <t><list style="symbols">
            <t> Merged proposal with draft-detienne-ikev2-recovery <xref target="recovery"/></t>
            <t> Changed the protocol so that the rebooted peer generates the token. This has the
              effect, that the need for persistent storage is eliminated.</t>
            <t> Added discussion of birth certificates.</t> 
          </list></t>
        </section>
        <section anchor="history01" title="Changes from draft-nir-qcr-00">
          <t><list style="symbols">
            <t> Changed name to reflect that this relates to IKE. Also changed from quick crash 
              recovery to quick crash detection to avoid confusion with IFARE.</t>
            <t> Added more operational considerations. </t>
            <t> Added interaction with IFARE.</t>
            <t> Added discussion of backup gateways.</t>
          </list></t>
        </section>
      </section>
  </middle>
  <!-- ====================================================================== -->
  <back>
    <references title="Normative References"> 
      <reference anchor='RFC2119'>
        <front>
          <title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author initials='S.' surname='Bradner' fullname='Scott Bradner'>
            <organization>Harvard University</organization>
            <address>
              <postal>
                <street>1350 Mass. Ave.</street>
                <street>Cambridge</street>
                <street>MA 02138</street>
              </postal>
              <phone>- +1 617 495 3864</phone>
              <email>sob@harvard.edu</email>
            </address>
          </author>
          <date year='1997' month='March' />
          <area>General</area>
          <keyword>keyword</keyword>
        </front>
        <seriesInfo name='BCP' value='14' />
        <seriesInfo name='RFC' value='2119' />
        <format type='TXT' octets='4723' target='ftp://ftp.isi.edu/in-notes/rfc2119.txt' />
        <format type='HTML' octets='16553' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
        <format type='XML' octets='5703' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
      </reference>
      <reference anchor='RFC4306'>
        <front>
          <title>Internet Key Exchange (IKEv2) Protocol</title>
          <author initials='C.' surname='Kaufman' fullname='C. Kaufman'>
            <organization /></author>
          <date year='2005' month='December' />
        </front>
        <seriesInfo name='RFC' value='4306' />
        <format type='TXT' target='http://www.ietf.org/rfc/rfc4306.txt' />
        <format type='HTML' target='http://xml.resource.org/public/rfc/html/rfc4306.html' />
        <format type='XML' target='http://xml.resource.org/public/rfc/xml/rfc4306.xml' />
      </reference>
      <reference anchor='RFC4718'>
        <front>
          <title>IKEv2 Clarifications and Implementation Guidelines</title>
          <author initials='P.' surname='Eronen' fullname='P. Eronen'>
            <organization>Nokia</organization></author>
          <author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
            <organization>VPN Consortium</organization></author>
          <date year='2006' month='October' />
        </front>
        <seriesInfo name='RFC' value='4718' />
        <format type='TXT' target='http://www.ietf.org/rfc/rfc4718.txt' />
        <format type='HTML' target='http://xml.resource.org/public/rfc/html/rfc4718.html' />
        <format type='XML' target='http://xml.resource.org/public/rfc/xml/rfc4718.xml' />
      </reference>
    </references>
    <references title="Informative References"> 
      <reference anchor='resumption'>
        <front>
          <title>IPsec Gateway Failover Protocol</title>
          <author initials='Y.' surname='Sheffer' fullname='Y. Sheffer'>
            <organization>Check Point</organization></author>
          <author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'>
            <organization>Nokia Siemens Networks</organization></author>
          <author initials='L.' surname='Dondeti' fullname='L. Dondeti'>
            <organization>QUALCOMM, Inc.</organization></author>
          <author initials='V.' surname='Narayanan' fullname='L. Narayanan'>
            <organization>QUALCOMM, Inc.</organization></author>
          <date year='2008' month='July' />
        </front>
        <seriesInfo name='Internet-Draft' value='draft-sheffer-ipsec-failover' />
        <format type='TXT'
          target='http://tools.ietf.org/id/draft-sheffer-ipsec-failover' />
        <format type='HTML'
          target='http://tools.ietf.org/html/draft-sheffer-ipsec-failover' />
       </reference>
      <reference anchor='recovery'>
        <front>
          <title>Safe IKE Recovery</title>
          <author initials='F.' surname='Detienne' fullname='Frederic Detienne'>
            <organization>Cisco</organization></author>
          <author initials='P.' surname='Sethi' fullname='Pratima Sethi'>
            <organization>Cisco</organization></author>
          <author initials='Y.' surname='Nir' fullname='Yoav Nir'>
            <organization>Check Point</organization></author>
          <date year='2008' month='July' />
        </front>
        <seriesInfo name='Internet-Draft' value='draft-detienne-ikev2-recovery' />
        <format type='TXT'
          target='http://tools.ietf.org/id/draft-detienne-ikev2-recovery' />
        <format type='HTML'
          target='http://tools.ietf.org/html/draft-detienne-ikev2-recovery' />
       </reference>
    </references>
    <!-- ====================================================================== -->
  </back>
</rfc>
