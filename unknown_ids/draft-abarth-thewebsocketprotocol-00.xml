<?xml version='1.0' encoding="UTF-8" ?>
<?rfc notedraftinprogress='yes'?>
<?rfc rfcprocack="yes"?>
<?rfc toc="yes"?>
<rfc ipr='trust200902' docName='draft-abarth-thewebsocketprotocol-00' category='std'>
  <front>
    <title>The WebSocket protocol</title>
    <author initials='I.F.' surname='Fette' fullname='Ian Fette'>
      <organization>Google, Inc.</organization>
      <address>
        <email>ifette+ietf@google.com</email>
        <uri>http://www.ianfette.com/</uri>
      </address>
    </author>
    <author initials='A.' surname='Barth' fullname='Adam Barth'>
      <organization>Google, Inc.</organization>
      <address>
        <email>ietf@adambarth.com</email>
        <uri>http://www.adambarth.com/</uri>
      </address>
    </author>
    <date month="January" year="2011"/>
    <area>Applications</area>
    <workgroup>HyBi Working Group</workgroup>
    <abstract>
      <t>The WebSocket protocol enables two-way communication between a user agent running untrusted code running in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the Origin-based security model commonly used by Web browsers. The protocol consists of an initial handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g. using XMLHttpRequest or &lt;iframe&gt;s and long polling).</t>
      <t>Please send feedback to the hybi@ietf.org mailing list.</t>
    </abstract>
  </front>
  <middle>
    <section title='Introduction'>
      <section title='Background'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>Historically, creating an instant messenger chat client as a Web application has required an abuse of HTTP to poll the server for updates while sending upstream notifications as distinct HTTP calls.</t>
        <t>This results in a variety of problems:
          <list style='symbols'>
            <t>The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client, and a new one for each incoming message.</t>
            <t>The wire protocol has a high overhead, with each client-to-server message having an HTTP header.</t>
            <t>The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.</t>
          </list>
        </t>
        <t>
          A simpler solution would be to use a single TCP connection for traffic in both directions. This is what the WebSocket protocol provides. Combined with the WebSocket API, it provides an alternative to HTTP polling for two-way communication from a Web page to a remote server. <xref target='WSAPI'/>
        </t>
        <t>The same technique can be used for a variety of Web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.</t>
      </section>
      <section title='Protocol overview'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The protocol has two parts: a handshake, and then the data transfer.</t>
        <t>
          The handshake from the client looks as follows:</t>
        <figure>
          <artwork>
     OPTIONS * HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Sec-WebSocket-Origin: http://example.com
     Sec-WebSocket-URL: ws://server.example.com/chat
     Sec-WebSocket-Protocol: chat, superchat
          </artwork>
        </figure>
        <t>The handshake from the server looks as follows:</t>
        <figure>
          <artwork>
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: me89jWimTRKTWwrS3aRrL53YZSo=
     Sec-WebSocket-Nonce: AQIDBAUGBwgJCgsMDQ4PEC==
     Sec-WebSocket-Protocol: chat
          </artwork>
        </figure>
        <t>The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format. The Request-Line and Status-Line productions are defined in <xref target='RFC2616'/>.
        </t>
        <t>
          After the leading line in both cases come an unordered set of headers. The meaning of these headers is specified in <xref target='handshake' /> of this document. Additional headers may also be present, such as cookies required to identify the user. The format and parsing of headers is as defined in <xref target='RFC2616'/>.
        </t>
        <t><vspace blankLines='1'/></t>
        <t>Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can, independently from the other, send data at will.</t>
        <t>Clients and servers, after a successful handshake, transfer data back and forth in conceptual units referred to in this specification as &quot;messages&quot;. A message is a complete unit of data at an application level, with the expectation that many or most applications implementing this protocol (such as web user agents) provide APIs in terms of sending and receiving messages. The websocket message does not necessarily correspond to a particular network layer framing, as a fragmented message may be coalesced, or vice versa, e.g. by an intermediary.</t>
        <t>Data is sent on the wire in the form of frames that have an associated type. Broadly speaking, there are types for textual data, which is interpreted as UTF-8 text, binary data (whose interpretation is left up to the application), and control frames, which are not intended to carry data for the application, but instead for protocol-level signaling, such as to signal that the connection should be closed. This version of the protocol defines six frame types and leaves ten reserved for future use.</t>
        <t>The WebSocket protocol uses this framing so that specifications that use the WebSocket protocol can expose such connections using an event-based mechanism instead of requiring users of those specifications to implement buffering and piecing together of messages manually.</t>
      </section>
      <section title='Opening handshake'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. To this end, the WebSocket client&apos;s handshake is an HTTP Upgrade
request:</t>
        <figure>
          <artwork>
     OPTIONS * HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Sec-WebSocket-Origin: http://example.com
     Sec-WebSocket-URL: ws://server.example.com/chat
     Sec-WebSocket-Protocol: chat, superchat
          </artwork>
        </figure>
        <t>Headers in the handshake are sent by the client in a random order; the order is not meaningful.</t>
        <t>Additional headers are used to select options in the WebSocket protocol. Options available in this version are the subprotocol selector, |Sec-WebSocket-Protocol|, and |Cookie|, which can used for sending cookies to the server (e.g. as an authentication mechanism). The |Sec-WebSocket-Protocol| request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket protocol) are acceptable to the client. The server selects one of the acceptable protocols and echoes that value in its handshake to indicate that it has selected that protocol.</t>
        <figure>
          <artwork>     Sec-WebSocket-Protocol: chat</artwork>
        </figure>
        <t>The |Sec-WebSocket-URL| header is used to identify the endpoint of the WebSocket connection, both to allow multiple domains to be served from one IP address and to allow multiple WebSocket endpoints to be served by a single server.<vspace blankLines='1'/></t>
        <t>The client includes the hostname as a part of the |Sec-WebSocket-URL| field of its handshake, so that both the client and the server can verify that they agree on which host is in use.</t>
        <t>The |Sec-WebSocket-Origin| header is used to protect against unauthorized cross-origin use of a WebSocket server by scripts using the |WebSocket| API in a Web browser. The server is informed of the script origin generating the WebSocket connection request. If the server does not wish to accept connections from this origin, it can choose to abort the connection.</t>
        <t>Finally, the server has to prove to the client that it received the client&apos;s WebSocket handshake, so that the server doesn&apos;t accept connections that are not WebSocket connections. This prevents an attacker from tricking a WebSocket server by sending it carefully-crafted packets using |XMLHttpRequest| or a |form| submission.</t>
        <t>To prove that the handshake was received, the server has to take two pieces of information and combine them to form a response. The first piece of information comes from the |Sec-WebSocket-Key| header in the client handshake:</t>
        <figure>
          <artwork>
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
          </artwork>
        </figure>
        <t>
          For this header, the server has to take the value (as present in the header, e.g. the base64-encoded version), and concatenate this with the GUID &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; in string form, which is unlikely to be used by network endpoints that do not understand the WebSocket protocol. A SHA-1 hash, base64-encoded, of this concatenation is then returned in the server&apos;s handshake <xref target='FIPS.180-2.2002' />.
        </t>
        <t>Concretely, if as in the example above, header |Sec-WebSocket-Key| had the value &quot;dGhlIHNhbXBsZSBub25jZQ==&quot;, the server would concatenate the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to form the string &quot;dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;. The server would then take the SHA-1 hash of this, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded, to give the value &quot;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&quot;.</t>
        <t>
          <vspace blankLines='1'/>
        </t>
        <t>The handshake from the server is much simpler than the client handshake. The first line is an HTTP Status-Line, with the status code 101:<vspace blankLines='1'/></t>
        <figure>
          <artwork>     HTTP/1.1 101 Switching Protocols</artwork>
        </figure>
        <t>Any status code other than 101 must be treated as a failure and the websocket connection aborted. The headers follow the status code.</t>
          <t>The |Connection| and |Upgrade| headers complete the HTTP Upgrade. The |Sec-WebSocket-Accept| header indicates whether the server is willing to accept the connection. If present, this header must include a hash of the client&apos;s nonce sent in |Sec-WebSocket-Key| along with a predefined GUID. Any other value must not be interpreted as an acceptance of the connection by the server.<vspace blankLines='1'/></t>
        <figure>
          <artwork>
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: me89jWimTRKTWwrS3aRrL53YZSo=
          </artwork>
        </figure>
        <t>These fields are checked by the Web browser when it is acting as a |WebSocket| client for scripted pages. If the |Sec-WebSocket-Accept| value does not match the expected value, or if the header is missing, or if the HTTP status code is not 101, the connection will not be established and WebSockets frames will not be sent.</t>
        <t>Option fields can also be included. In this version of the protocol, the main option field is |Sec-WebSocket-Protocol|, which indicates the subprotocol that the server has selected. Web browsers verify that the server included one of the values as was specified in the |WebSocket| constructor. A server that speaks multiple subprotocols has to make sure it selects one based on the client&apos;s handshake and specifies it in its handshake.<vspace blankLines='1'/></t>
        <figure>
          <artwork>     Sec-WebSocket-Protocol: chat</artwork>
        </figure>
        <t>The server can also set cookie-related option fields to <spanx style='emph'>set</spanx> cookies, as in HTTP.
        </t>
      </section>
      <section title='Closing handshake'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The closing handshake is far simpler than the opening handshake.</t>
        <t>Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake. Upon receiving such a frame, the other peer sends an identical frame in acknowledgement, if it hasn&apos;t already sent one. Upon receiving <spanx style='emph'>that</spanx> control frame, the first peer then closes the connection, safe in the knowledge that no further data is forthcoming.</t>
        <t>After sending a control frame indicating the connection should be closed, a peer does not send any further data; after receiving a control frame indicating the connection should be closed, a peer discards any further data received.</t>
        <t>It is safe for both peers to initiate this handshake simultaneously.</t>
        <t>The closing handshake is intended to replace the TCP closing handshake (FIN/ACK), on the basis that the TCP closing handshake is not always reliable end-to-end, especially in the presence of man-in-the-middle proxies and other intermediaries.</t>
      </section>
      <section title='Design philosophy'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The WebSocket protocol is designed on the principle that there should be minimal framing (the only framing that exists is to make the protocol frame-based instead of stream-based, and to support a distinction between Unicode text and binary frames). It is expected that metadata would be layered on top of WebSocket by the application layer, in the same way that metadata is layered on top of TCP by the application layer (HTTP).</t>
        <t>Conceptually, WebSocket is really just a layer on top of TCP that adds a Web &quot;origin&quot;-based security model for browsers; adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address; layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits; and re-implements the closing handshake in-band. Other than that, it adds nothing. Basically it is intended to be as close to just exposing raw TCP to script as possible given the constraints of the Web. It&apos;s also designed in such a way that its servers can share a port with HTTP servers, by having its handshake be a valid HTTP Upgrade handshake also.</t>
        <t>The protocol is intended to be extensible; future versions will likely introduce a mechanism to compress data and might support sending binary data.</t>
      </section>
      <section title='Security model'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The WebSocket protocol uses the origin model used by Web browsers to restrict which Web pages can contact a WebSocket server when the WebSocket protocol is used from a Web page. Naturally, when the WebSocket protocol is used by a dedicated client directly (i.e. not from a Web page through a Web browser), the origin model is not useful, as the client can provide any arbitrary origin string.</t>
        <t>This protocol is intended to fail to establish a connection with servers of pre-existing protocols like SMTP or HTTP, while allowing HTTP servers to opt-in to supporting this protocol if desired. This is achieved by having a strict and elaborate handshake, and by limiting the data that can be inserted into the connection before the handshake is finished (thus limiting how much the server can be influenced).</t>
        <t>It is similarly intended to fail to establish a connection when data from other protocols, especially HTTP, is sent to a WebSocket server, for example as might happen if an HTML |form| were submitted to a WebSocket server. This is primarily achieved by requiring that the server prove that it read the handshake, which it can only do if the handshake contains the appropriate parts which themselves can only be sent by a WebSocket handshake; in particular, fields starting with |Sec-| cannot be set by an attacker from a Web browser, even when using |XMLHttpRequest|.</t>
      </section>
      <section title='Relationship to TCP and HTTP'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The WebSocket protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.</t>
        <t>Based on the expert recommendation of the IANA, the WebSocket protocol by default uses port 80 for regular WebSocket connections and port 443 for WebSocket connections tunneled over TLS.</t>
      </section>
      <section title='Establishing a connection'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>There are several options for establishing a WebSocket connection.</t>
        <t>On the face of it, the simplest method would seem to be to use port 80 to get a direct connection to a WebSocket server. Port 80 traffic, however, will often be intercepted by man-in-the-middle HTTP proxies, which can lead to the connection failing to be established.</t>
        <t>The most reliable method, therefore, is to use TLS encryption and port 443 to connect directly to a WebSocket server. This has the advantage of being more secure; however, TLS encryption can be computationally expensive.</t>
        <t>When a connection is to be made to a port that is shared by an HTTP server (a situation that is quite likely to occur with traffic to ports 80 and 443), the connection will appear to the HTTP server or intermediary to be a regular CONNECT request. In relatively simple setups with just one IP address and a single server for all traffic to a single hostname, this might allow a practical way for systems based on the WebSocket protocol to be deployed. In more elaborate setups (e.g. with load balancers and multiple servers), a dedicated set of hosts for WebSocket connections separate from the HTTP servers is probably easier to manage.</t>
      </section>
      <section title='Subprotocols using the WebSocket protocol'>
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>The client can request that the server use a specific subprotocol by including the |Sec-Websocket-Protocol| field in its handshake. If it is specified, the server needs to include the same field and one of the selected subprotocol values in its response for the connection to be established.</t>
        <t>These subprotocol names do not need to be registered, but if a subprotocol is intended to be implemented by multiple independent WebSocket servers, potential clashes with the names of subprotocols defined independently can be avoided by using names that contain the domain name of the subprotocol&apos;s originator. For example, if Example Corporation were to create a Chat subprotocol to be implemented by many servers around the Web, they could name it &quot;chat.example.com&quot;. If the Example Organization called their competing subprotocol &quot;example.org&apos;s chat protocol&quot;, then the two subprotocols could be implemented by servers simultaneously, with the server dynamically selecting which subprotocol to use based on the value sent by the client.</t>
        <t>Subprotocols can be versioned in backwards-incompatible ways by changing the subprotocol name, e.g. going from &quot;bookings.example.net&quot; to &quot;v2.bookings.example.net&quot;. These subprotocols would be considered completely separate by WebSocket clients. Backwards-compatible versioning can be implemented by reusing the same subprotocol string but carefully designing the actual subprotocol to support this kind of extensibility.</t>
      </section>
    </section>
    <section title='Conformance requirements'>
      <t>All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.</t>
      <t>
        The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in the normative parts of this document are to be interpreted as described in RFC2119. For readability, these words do not appear in all uppercase letters in this specification. <!-- would like to replace this with upper case versions. This is just confusing. -ifette 8/29/10 --><xref target='RFC2119'/>
      </t>
      <t>Requirements phrased in the imperative as part of algorithms (such as &quot;strip any leading space characters&quot; or &quot;return false and abort these steps&quot;) are to be interpreted with the meaning of the key word (&quot;must&quot;, &quot;should&quot;, &quot;may&quot;, etc) used in introducing the algorithm.</t>
      <t>Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant.)</t>
      <t>Implementations may impose implementation-specific limits on otherwise unconstrained inputs, e.g. to prevent denial of service attacks, to guard against running out of memory, or to work around platform-specific limitations.</t>
      <t>The conformance classes defined by this specification are user agents and servers.</t>
      <section title='Terminology'>
        <t>
          <spanx style='strong'>ASCII</spanx> shall mean the character-encoding scheme defined in  <xref target='ANSI.X3-4.1986'/>.
        </t>
        <t>
          <spanx style='strong'>Converting a string to ASCII lowercase</spanx> means replacing all characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z).
        </t>
        <t>
          Comparing two strings in an <spanx style='strong'>ASCII case-insensitive</spanx> manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.
        </t>
        <t>
          The term &quot;URL&quot; is used in this section in a manner consistent with the terminology used in HTML, namely, to denote a string that might or might not be a valid URI or IRI and to which certain error handling behaviors will be applied when the string is parsed. <xref target='HTML'/>
        </t>
        <t>
          When an implementation is required to <spanx style='emph'>send</spanx> data as part of the WebSocket protocol, the implementation may delay the actual transmission arbitrarily, e.g. buffering data so as to send fewer IP packets.
        </t>
      </section>
    </section>
    <section title='WebSocket URLs' anchor='ws_urls'>
      <section title='Parsing WebSocket URLs' anchor='parsing_ws_urls'>
        <t>
          The steps to <spanx style='strong'>parse a WebSocket URL&apos;s components</spanx> from a string /url/ are as follows. These steps return either a /host/, a /port/, a /resource name/, and a /secure/ flag, or they fail.

          <list style='numbers'>
            <t>
              If the /url/ string is not an absolute URL, then fail this algorithm. <xref target='RFC3986'/> <xref target="RFC3987"/>
            </t>
            <t>
              Resolve the /url/ string using the resolve a Web address algorithm defined by the Web addresses specification, with the URL character encoding set to UTF-8. <xref target='RFC3629'/> <xref target='RFC3986'/> <xref target="RFC3987"/>
              <vspace blankLines='1'/>
              NOTE: It doesn&apos;t matter what it is resolved relative to, since we already know it is an absolute URL at this point.
            </t>
            <t>If /url/ does not have a &lt;scheme&gt; component whose value, when converted to ASCII lowercase, is either &quot;ws&quot; or &quot;wss&quot;, then fail this algorithm.</t>
            <t>If /url/ has a &lt;fragment&gt; component, then fail this algorithm.</t>
            <t>If the &lt;scheme&gt; component of /url/ is &quot;ws&quot;, set /secure/ to false; otherwise, the &lt;scheme&gt; component is &quot;wss&quot;, set /secure/ to true.</t>
            <t>Let /host/ be the value of the &lt;host&gt; component of /url/, converted to ASCII lowercase.</t>
            <t>If /url/ has a &lt;port&gt; component, then let /port/ be that component&apos;s value; otherwise, there is no explicit /port/.</t>
            <t>If there is no explicit /port/, then: if /secure/ is false, let /port/ be 80, otherwise let /port/ be 443.</t>
            <t>Let /resource name/ be the value of the &lt;path&gt; component (which might be empty) of /url/.</t>
            <t>If /resource name/ is the empty string, set it to a single character U+002F SOLIDUS (/).</t>
            <t>If /url/ has a &lt;query&gt; component, then append a single U+003F QUESTION MARK character (?) to /resource name/, followed by the value of the &lt;query&gt; component.</t>
            <t>Return /host/, /port/, /resource name/, and /secure/.</t>
          </list>
        </t>
      </section>
      <section title='Constructing WebSocket URLs'>
        <t>
          The steps to <spanx style='strong'>construct a WebSocket URL</spanx> from a /host/, a /port/, a /resource name/, and a /secure/ flag, are as follows:
          <list style='numbers'>
            <t>Let /url/ be the empty string.</t>
            <t>If the /secure/ flag is false, then append the string &quot;ws://&quot; to /url/. Otherwise, append the string &quot;wss://&quot; to /url/.</t>
            <t>Append /host/ to /url/.</t>
            <t>If the /secure/ flag is false and port is not 80, or if the /secure/ flag is true and port is not 443, then append the string &quot;:&quot; followed by /port/ to /url/.</t>
            <t>Append /resource name/ to /url/.</t>
            <t>Return /url/.</t>
          </list>
        </t>
      </section>
      <section title='Valid WebSocket URLs' anchor='valid_ws_urls'>
        <t>
          For a WebSocket URL to be considered valid, the following conditions MUST hold.
          <list style='symbols'>
            <t>The /host/ must be ASCII-only (i.e. it must have been punycode-encoded already if necessary, and MUST NOT contain any characters above U+007E).</t>
            <t>The /origin/ must not contain characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z).</t>
            <t>
              The /resource name/ string must be a non-empty string of characters in the range U+0021 to U+007E that starts with a U+002F SOLIDUS character (/).
            </t>
            <t>The various strings in /protocols/ MUST all be non-empty strings with characters in the range U+0021 to U+007E and MUST all be unique.
            </t>
          </list>
        </t>
        <t>Any WebSocket URLs not meeting the above criteria are considered invalid, and a client MUST NOT attempt to make a connection to an invalid WebSocket URL. A client SHOULD attempt to parse a URL obtained from any external source (such as a web site or a user) using the steps specified in <xref target='parsing_ws_urls'/> to obtain a valid WebSocket URL, but MUST NOT attempt to connect with such an unparsed URL, and instead only use the parsed version and only if that version is considered valid by the criteria above.
        </t>
      </section>
    </section>
    <section title='Data Framing' anchor='framing'>
      <section title='Overview'>
        <t>In the WebSocket protocol, data is transmitted using a sequence of
        frames. Frames sent from the client to the server are masked to avoid
        confusing network intermediaries, such as intercepting proxies. Frames
        sent from the server to the client are not masked.</t>

        <t>The base framing protocol defines a frame type with an opcode, a
        payload length, and designated locations for extension and application
        data, which together define the <spanx style="emph">payload</spanx>
        data. Certain bits and opcodes are reserved for future expansion of
        the protocol. As such, In the absence of extensions negotiated during
        the opening handshake (<xref target='handshake'/>), all reserved bits
        MUST be 0 and reserved opcode values MUST NOT be used.</t>

        <t>A data frame MAY be transmitted by either the client or the server
        at any time after handshake completion and before that host has
        generated a close message (<xref target="closeframe"/>).</t>
      </section>
      <section title='Client-to-Server Masking'>
        <t>The server MUST mask all frames sent to the server.</t>

        <t>The masking-key is derived from information exchanged between the
        client and the server in the handshake and is constant for the
        duration of the WebSocket connection.</t>

        <t>The masking-key is the SHA-1 hash of the concatenation of the value
        of the Sec-WebSocket-Key header (sent from the client to the server),
        the value of the Sec-WebSocket-Nonce header (sent from the server to
        the client), and the string
        &quot;61AC5F19-FBBA-4540-B96F-6561F1AB40A8&quot; (which is unique to
        the web socket protocol).</t>

        <t>For example, if the Sec-WebSocket-Key header contains the value
        &quot;dGhlIHNhbXBsZSBub25jZQ==&quot; and the Sec-WebSocket-Nonce
        header contains the value &quot;AQIDBAUGBwgJCgsMDQ4PEC==&quot;, the
        masking key is the SHA-1 hash of the string
&quot;dGhlIHNhbXBsZSBub25jZQ==AQIDBAUGBwgJCgsMDQ4PEC==61AC5F19-FBBA-4540-B96F-6561F1AB40A8&quot;,
        which is the sequence of octets 0x41 0xe1 0x4f 0x78 0x31 0x1e 0x4c
        0x34 0x28 0x3e 0x6d 0x8b 0x36 0x3b 0x88 0x48 0xd5 0x85 0x91 0xa7.</t>

        <t>Each masked frame consists of a 32-bit masking-nonce followed by
        masked-data:
        <figure>
          <artwork type='abnf'>
            <![CDATA[
  masked-frame  = masking-nonce masked-data
  masking-nonce = 4full-octet
  masked-data   = *full-octet
  full-octet    = %x00-FF
            ]]>
          </artwork>
        </figure>
        </t>

        <t>The masked-data is the clear-text frame encrypted under AES-128-CTR
        (see [TODO: Cite AES-128-CTR]) using the masking-key as the key and
        the initial counter value equal to the masking-nonce followed by 28
        zero octets.</t>

        <t>For example, octet i of the masked-data is computed from octet i of
        the clear-text frame as follows:
        <figure>
          <artwork>
            <![CDATA[
  initial-counter = masking-nonce << 96
  masked-octet-i = clear-text-octet-i XOR AES_k(initial-counter + i)
            ]]>
          </artwork>
        </figure>
        where AES_k is AES keyed with the masking-key.</t>

        <t>When preparing a masked-frame, the client MUST pick a fresh
        masking-nonce uniformly at random from the set of masking keys. The
        unpredictability of the masking-nonce is essential to prevent the
        author of malicious application data from selecting the bytes that
        appear on the wire.</t>
      </section>
      <section title='Base Framing Protocol'>
        <t>
          This wire format for the data transfer part is described by the ABNF given in detail in this section. A high level overview of the framing is given in the following figure. <xref target='RFC5234'/>
          <vspace blankLines='1'/>
        </t>
        <figure>
          <artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-------+-+-------------+-------------------------------+
  |M|R|R|R| opcode|R| Payload len |    Extended payload length    |
  |O|S|S|S|  (4)  |S|     (7)     |             (16/63)           |
  |R|V|V|V|       |V|             |   (if payload len==126/127)   |
  |E|1|2|3|       |4|             |                               |
  +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
  |     Extended payload length continued, if payload len == 127  |
  + - - - - - - - - - - - - - - - +-------------------------------+
  |                               |         Extension data        |
  +-------------------------------+ - - - - - - - - - - - - - - - +
  :                                                               :
  +---------------------------------------------------------------+
  :                       Application data                        :
  +---------------------------------------------------------------+
          </artwork>
        </figure>
        <t>
          <list style="hanging">
            <t hangText="MORE:">1 bit
              <vspace blankLines="1"/>
              Indicates more fragments follow in the current message
            </t>
            <t hangText="RSV1, RSV2, RSV3, RSV4:">1 bit each
              <vspace blankLines="1"/>
              Must be 0 unless an extension is negotiated which defines
              meanings for non-zero values
            </t>
            <t hangText="Opcode:">4 bits
              <vspace blankLines="1"/>
              Defines the interpretation of the payload data
            </t>
            <t hangText="Payload length:">7 bits
              <vspace blankLines="1"/>
              The length of the payload: if 0-125, that is the payload length.
              If 126, the following 2 bytes interpreted as a 16 bit unsigned
              integer are the payload length.  If 127, the following 8 bytes
              interpreted as a 64-bit unsigned integer (the high bit must be 0)
              are the payload length. Multibyte length quantities are expressed
              in network byte order. The payload length is the length of the
              Extension data + the length of the Application Data. The length
              of the Extension data may be zero, in which case the Payload
              length is the length of the Application data.
            </t>
            <t hangText="Extension data:">n bytes
              <vspace blankLines="1"/>
              The extension data is 0 bytes unless there is a reserved op-code
              or reserved bit present in the frame which indicates an extension
              has been negotiated. Any extension MUST specify the length of the
              extension data, or how that length may be calculated, and its use
              MUST be negotiated during the handshake.
              If present, the extension data is included in the total payload
              length.
            </t>
            <t hangText="Application data:">n bytes
              <vspace blankLines="1"/>
              Arbitrary application data, taking up the remainder of the frame
              after any extension data. The length of the Application data is
              equal to the payload length minus the length of the Extension
              data.
            </t>
          </list>
        </t>
        <t>The base framing protocol is formally defined by the following ABNF <xref target='RFC5234'/>:</t>
        <figure height="" suppress-title="false" width="" alt="" title="" align="left">
        <artwork type="abnf" height="" name="" width="" alt="" align="left" xml:space="preserve"><![CDATA[
   ws-frame               = frame-more
                            frame-rsv1
                            frame-rsv2
                            frame-rsv3
                            frame-opcode
                            frame-rsv4
                            frame-length
                            frame-extension
                            application-data;

   frame-more             = %x0 ; final frame of message
                          / %x1 ; more frames of this message follow

   frame-rsv1             = %x0 ; 1 bit, must be 0

   frame-rsv2             = %x0 ; 1 bit, must be 0

   frame-rsv3             = %x0 ; 1 bit, must be 0

   frame-opcode           = %x0 ; continuation frame
                          / %x1 ; connection close
                          / %x2 ; ping
                          / %x3 ; pong
                          / %x4 ; text frame
                          / %x5 ; binary frame
                          / %x6-F ; reserved

   frame-rsv4             = %x0 ; 1 bit, must be 0

   frame-length           = %x00-7D
                          / %x7E frame-length-16
                          / %x7F frame-length-63

   frame-length-16        = %x0000-FFFF

   frame-length-63        = %x0000000000000000-7FFFFFFFFFFFFFFF

   frame-extension        = *( %x00-FF ) ; to be defined later

   application-data       = *( %x00-FF )
]]></artwork></figure>
        <t>
        </t>
      </section>
      <section title="Fragmentation">
        <t>The following rules apply to fragmentation:
          <list style="symbols">
            <t>An unfragmented message consists of a single frame with the MORE
            bit clear and an opcode other than 0.</t>
            <t>A fragmented message consists of a single frame with the MORE
            bit set and an opcode other than 0, followed by zero or more frames
            with the MORE bit set and the opcode set to 0, and terminated by
            a single frame with the MORE bit clear and an opcode of 0.  Its
            content is the concatenation of the application data from each of
            those frames in order.</t>
            <t><spanx style="emph">Note: There is an open question as to whether
            control frames be interjected in the middle of a fragmented message.
            If so, it must be decided whether they be fragmented (which would
            require keeping a stack of "in-progress" messages).</spanx></t>
            <t>A sender MAY create fragments of any size for non control
            messages.</t>
            <t>Clients and servers MUST support receiving both fragmented and
            unfragmented messages.
            </t>
            <t>An intermediary MAY change the fragmentation of a message if the
            message uses only opcode and reserved bit values known to the
            intermediary.
            </t>
          </list>
        </t>
      </section>
      <section title="Control Frames" anchor="controlframes">
        <t>Control frames have opcodes of 0x01 (Close), 0x02 (Ping), or 0x03
        (Pong). Control frames are used to communicate state about the
        websocket.
        </t>
        <t>All control frames MUST be 125 bytes or less in length and MUST NOT
        be fragmented.</t>
        <section title="Close" anchor="closeframe">
          <t>The Close message contains an opcode of 0x01.</t>
          <t>The application MUST NOT send any more data messages after sending
          a close message.</t>
          <t>A received close message is deemed to be an acknowledgement if the
          message body matches the body of a close message previously sent by
          the receiver. Otherwise the close message is a close initiated by
          the sender.</t>
          <t>Upon receipt of an initiated close the endpoint MUST send a close
          acknowledgment. It should do so as soon as is practical.</t>
          <t>The websocket is considered fully closed when an endpoint has
          either received a close acknowledgment or sent a close
          acknowledgment.</t>
        </section>
        <section title="Ping">
          <t>The Ping message contains an opcode of 0x02.</t>
          <t>Upon receipt of a Ping message, an endpoint MUST send a Pong
          message in response. It SHOULD do so as soon as is practical. The
          message bodies of the Ping and Pong MUST be the same.</t>
        </section>
        <section title="Pong">
          <t>The Pong message contains an opcode of 0x03.</t>
          <t>Upon receipt of a Ping message, an endpoint MUST send a Pong
          message in response. It SHOULD do so as soon as is practical. The
          message bodies of the Ping and Pong MUST be the same.</t>
        </section>
      <!--
        <t>A receiver MUST take the following action upon receiving control
        frames:
          <list style="hanging">
            <t hangText="Close:">
              <vspace blankLines='1'/>
              Upon receipt of a close frame, an endpoint SHOULD send a Close
              frame to the remote recipient, if it has not already done so,
              deliver a close event to the application if necessary, and then
              close the WebSocket.</t>
            <t hangText="Ping">
              <vspace blankLines='1'/>
              Upon receipt of a Ping message, an endpoint SHOULD send a Pong
              response as soon as is practical.  The Pong response MUST contain
              the payload provided in the Ping message, though an implementation
              MAY truncate the message at an implementation-defined size which
              MUST be at least 8 <spanx style='emph'>(TBD)</spanx> bytes.
              <vspace blankLines='1'/>
              Ping frames MAY be sent as a keep-alive mechanism, but if so the
              interval SHOULD be configurable.  </t>
            <t hangText="Pong">
              <vspace blankLines='1'/>
              If a Pong message is received without a matching Ping message being
              sent, an endpoint MUST drop the connection.  Otherwise, the
              endpoint SHOULD update any liveness timer it may have for the
              connection.</t>
          </list>
        </t>
        -->
      </section>
      <section title="Data Frames">
        <t>
          All frame types not listed in <xref target="controlframes"/> are data frames, which transport
          application-layer data.  The opcode determines the interpretation of
          the application data:
          <list style="hanging">
            <t hangText="Text">
              <vspace blankLines='1'/>
              The payload data is text data encoded as UTF-8.
            </t>
            <t hangText="Binary">
              <vspace blankLines='1'/>
              The payload data is arbitrary binary data whose interpretation
              is solely up to the application layer.
            </t>
          </list>
        </t>
      </section>
      <section title="Examples">
        <t>
          <spanx style='emph'>This section is non-normative.</spanx>
        </t>
        <t>
          <list style="symbols">
            <t>
              A single-frame text message
              <list style="symbols">
                <t>0x04 0x05 "Hello"</t>
              </list>
            </t>
            <t>
              A fragmented text message
              <list style="symbols">
                <t>0x84 0x03 "Hel"</t>
                <t>0x00 0x02 "lo"</t>
              </list>
            </t>
            <t>
              Ping request and response
              <list style="symbols">
                <t>0x02 0x05 "Hello"</t>
                <t>0x03 0x05 "Hello"</t>
              </list>
            </t>
            <t>
              256 bytes binary message in a single frame
              <list style="symbols">
                <t>0x05 0x7E 0x0100 [256 bytes of binary data]</t>
              </list>
            </t>
            <t>
              64KiB binary message in a single frame
              <list style="symbols">
                <t>0x05 0x7F 0x0000000000010000 [65536 bytes of binary data]</t>
              </list>
            </t>
          </list>
        </t>
      </section>
      <section title="Extensibility">
        <t>The protocol is designed to allow for extensions, which will add
        capabilities to the base protocols. The endpoints of a connection MUST
        negotiate the use of any extensions during the
        handshake. This specification provides opcodes 0x6 through 0xF, the
        extension data field, and the frame-rsv1, frame-rsv2, frame-rsv3, and
        frame-rsv4 bits of the frame header for use by extensions.
        Below are some anticipated uses of extensions. This list is neither
        complete nor proscriptive.
          <list style="symbols">
            <t>Extension data may be placed in the payload before the
            application data.</t>
            <t>Reserved bits can be allocated for per-frame needs.</t>
            <t>Reserved opcode values can be defined.</t>
            <t>Reserved bits can be allocated to the opcode field if more
            opcode values are needed.</t>
            <t>A reserved bit or an "extension" opcode can be defined which
            allocates additional bits out of the payload area to define larger
            opcodes or more per-frame bits.</t>
          </list>
        </t>
      </section>
    </section>

    <section title='Opening Handshake' anchor='handshake'>
      <section title='Client Requirements'>
        <t>User agents running in controlled environments, e.g. browsers on
        mobile handsets tied to specific carriers, may offload the management
        of the connection to another agent on the network. In such a
        situation, the user agent for the purposes of conformance is
        considered to include both the handset software and any such
        agents.</t>

        <t>When the user agent is to <spanx style='strong'>establish a
        WebSocket connection</spanx> to a WebSocket URL /url/, it must meet
        the following requirements. In the following text, we will use terms
        from <xref target='ws_urls'/> such as &quot;/host/&quot; and
        &quot;/secure/ flag&quot; as defined in that section.
        <list style='numbers'>
          <t>The WebSocket URL and its components MUST be valid according to
          <xref target='valid_ws_urls'/>. If any of the requirements are not
          met, the client MUST fail the WebSocket connection and abort these
          steps.</t>

          <t> If the user agent already has a WebSocket connection to the
          remote host (IP address) identified by /host/, even if known by
          another name, the user agent MUST wait until that connection has
          been established or for that connection to have failed. If
          multiple connections to the same IP address are attempted
          simultaneously, the user agent MUST serialize them so that there is
          no more than one connection at a time running through the following
          steps.
          <vspace blankLines='1'/>
          If the user agent cannot determine the IP address of the remote host
          (for example because all communication is being done through a proxy
          server that performs DNS queries itself), then the user agent MUST
          assume for the purposes of this step that each host name refers to a
          distinct remote host, but should instead limit the total number of
          simultaneous connections that are not established to a reasonably
          low number (e.g., in a Web browser, to the number of tabs the user
          has open).
          <vspace blankLines='1'/>
          NOTE: This makes it harder for a script to perform a denial of
          service attack by just opening a large number of WebSocket
          connections to a remote host. A server can further reduce the load
          on itself when attacked by making use of this by pausing before
          closing the connection, as that will reduce the rate at which the
          client reconnects.
          <vspace blankLines='1'/>
          NOTE: There is no limit to the number of established WebSocket
          connections a user agent can have with a single remote host.
          Servers can refuse to connect users with an excessive number of
          connections, or disconnect resource-hogging users when suffering
          high load.</t>
          
          <t><spanx style='emph'>Proxy Usage</spanx>: If the user agent is
          configured to use a proxy when using the WebSocket protocol to
          connect to host /host/ and/or port /port/, then the user agent
          SHOULD connect to that proxy and ask it to open a TCP connection to
          the host given by /host/ and the port given by /port/.
          <list style='empty'>
            <t>EXAMPLE: For example, if the user agent uses an HTTP proxy for
            all traffic, then if it was to try to connect to port 80 on server
            example.com, it might send the following lines to the proxy
            server:
            <vspace blankLines='1'/>
            <figure>
              <artwork>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
              </artwork>
            </figure>
            </t>

            <t>If there was a password, the connection might look like:
            <vspace blankLines='1'/>
            <figure>
              <artwork>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
           Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=
              </artwork>
            </figure>
            </t>
          </list>
          If the user agent is not configured to use a proxy, then a
          direct TCP connection SHOULD be opened to the host given by
          /host/ and the port given by /port/.
          <vspace blankLines='1'/>
          NOTE: Implementations that do not expose explicit UI for selecting a
          proxy for WebSocket connections separate from other proxies are
          encouraged to use a SOCKS proxy for WebSocket connections, if
          available, or failing that, to prefer the proxy configured for HTTPS
          connections over the proxy configured for HTTP connections.
          <vspace blankLines='1'/>
          For the purpose of proxy autoconfiguration scripts, the URL to pass
          the function must be constructed from /host/, /port/, /resource
          name/, and the /secure/ flag using the steps to construct a
          WebSocket URL.
          <vspace blankLines='1'/>
          NOTE: The WebSocket protocol can be identified in proxy
          autoconfiguration scripts from the scheme (&quot;ws:&quot; for
          unencrypted connections and &quot;wss:&quot; for encrypted
          connections).</t>

          <t>If the connection could not be opened, either because a direct
          connection failed or because any proxy used returned an error, then
          the user agent MUST fail the WebSocket connection and abort the
          connection attempt.</t>

          <t> If /secure/ is true, the user agent MUST perform a TLS handshake
          over the connection. If this fails (e.g. the server&apos;s
          certificate could not be verified), then the user agent MUST fail
          the WebSocket connection and abort the connection. Otherwise, all
          further communication on this channel MUST run through the encrypted
          tunnel. <xref target='RFC2246'/>
          <vspace blankLines='1'/>
          User agents MUST use the Server Name Indication extension in the TLS
          handshake. <xref target='RFC4366'/></t>
        </list>
        </t>

        <t>Once a connection to the server has been established (including a
        connection via a proxy or over a TLS-encrypted tunnel), the client
        MUST send a handshake to the server. The handshake consists of an HTTP
        upgrade request, along with a list of required and optional headers.
        The requirements for this handshake are as follows.
        <list style='numbers'>
          <t>The handshake must be a valid HTTP request as specified by <xref
          target='RFC2616'/>.</t>

          <t>The Method of the request MUST be OPTIONS, the request target
          must be &quot;*&quot;, and the HTTP version MUST be at least 1.1.
          <vspace blankLines='1' /> The first line sent SHOULD be
          &quot;OPTIONS * HTTP/1.1&quot;</t>

          <t>The request MUST contain a &quot;Host&quot; header whose value is
          equal to the authority component of the WebSocket URL.</t>

          <t>The request MUST contain an &quot;Update&quot; header whose value
          is equal to &quot;websocket&quot;.</t>

          <t>The request MUST contain a &quot;Connection&quot; header whose
          value is equal to &quot;Upgrade&quot;.</t>

          <t>The request MUST include a header with the name
          &quot;Sec-WebSocket-Key&quot;. The value of this header MUST be a
          nonce consisting of a randomly selected 16-byte value that has been
          base64-encoded <xref target='RFC3548'/>. The nonce MUST be randomly
          selected randomly for each connection. <vspace blankLines='1'/>
          NOTE: As an example, if the randomly selected value was the sequence
          of bytes 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c
          0x0d 0x0e 0x0f 0x10, the value of the header would be
          &quot;AQIDBAUGBwgJCgsMDQ4PEC==&quot;</t>

          <t>The request MUST include a header with the name
          &quot;Sec-WebSocket-Origin&quot;. The value of this header MUST be
          the ASCII serialization of origin of the context in which the code
          establishing the connection is running [TODO: Cite
          draft-ietf-websec-origin].
          <vspace blankLines='1'/>
          As an example, if code is running on www.example.com attempting to
          establish a connection to ww2.example.com, the value of the header
          would be &quot;http://www.example.com&quot;.</t>

          <t>The request MUST include a header with the name
          &quot;Sec-WebSocket-URL&quot;. The value of this header MUST be the
          WebSocket URL to which the connection is to be made.</t>

          <t>The request MAY include a header with the name
          &quot;Sec-WebSocket-Protocol&quot;. If present, this value indicates
          the subprotocol(s) the client wishes to speak. The ABNF for the
          value of this header is 1#(token | quoted-string), where the
          definitions of /token/ and /quoted-string/ are as given in <xref
          target='RFC2616' />.</t>

          <t>The request MAY include a header with the name
          &quot;Sec-WebSocket-Extensions&quot;. If present, this value
          indicates the protocol-level extension(s) the client wishes to
          speak. The ABNF for the value of this header is 1#(token |
          quoted-string), where the definitions of /token/ and /quoted-string/
          are as given in <xref target='RFC2616' />.</t>

          <t> The request MAY include headers associated with sending cookies,
          as defined by the appropriate specifications. [TODO: Cite
          draft-ietf-httpstate-cookie]</t>
        </list>
        </t>

        <t>Once the client's opening handshake has been sent, the client MUST
        wait for a response from the server before sending any further data.
        The client MUST validate the server's response as follows:
        <list style='symbols'>
          <t>If the status code received from the server is not 101, the
          client MUST fail the WebSocket connection.</t>

          <t>If the response lacks an Upgrade header or the Upgrade header
          contains a value that is not an ASCII case-insensitive match for the
          value &quot;websocket&quot;, the client MUST fail the WebSocket
          connection.</t>

          <t>If the response lacks a Connection header or the Connection
          header contains a value that is not an ASCII case-insensitive match
          for the value &quot;Upgrade&quot;, the client MUST fail the
          WebSocket connection.</t>

          <t>If the response lacks a Sec-WebSocket-Accept header or the
          Sec-WebSocket-Accept contains a value other than the base64-encoded
          SHA-1 of the concatenation of the Sec-WebSocket-Key with the string
          &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;, the client MUST
          fail the WebSocket connection.</t>
        </list>
        </t>

        <t>Where the algorithm above requires that a user agent fail the
        WebSocket connection, the user agent may first read an arbitrary
        number of further bytes from the connection (and then discard them)
        before actually <spanx style='strong'>failing the WebSocket
        connection</spanx>. Similarly, if a user agent can show that the bytes
        read from the connection so far are such that there is no subsequent
        sequence of bytes that the server can send that would not result in
        the user agent being required to <spanx style='strong'>fail the
        WebSocket connection</spanx>, the user agent may immediately <spanx
        style='strong'>fail the WebSocket connection</spanx> without waiting
        for those bytes.</t>

        <t>NOTE: The previous paragraph is intended to make it conforming for
        user agents to implement the algorithm in subtly different ways that
        are equivalent in all ways except that they terminate the connection
        at earlier or later points. For example, it enables an implementation
        to buffer the entire handshake response before checking it, or to
        verify each field as it is received rather than collecting all the
        fields and then checking them as a block.</t>
      </section>
      <section title='Server-side requirements'>
        <t><spanx style='emph'>This section only applies to
        servers.</spanx></t>

        <t>Servers may offload the management of the connection to other
        agents on the network, for example load balancers and reverse proxies.
        In such a situation, the server for the purposes of conformance is
        considered to include all parts of the server-side infrastructure from
        the first device to terminate the TCP connection all the way to the
        server that processes requests and sends responses.</t>

        <t>EXAMPLE: For example, a data center might have a server that
        responds to Web Socket requests with an appropriate handshake, and
        then passes the connection to another server to actually process the
        data frames. For the purposes of this specification, the "server" is
        the combination of both computers.</t>

        <section title='Reading the client&apos;s opening handshake'>
          <t>When a client starts a WebSocket connection, it sends its part of
          the opening handshake. The server must parse at least part of this
          handshake in order to obtain the necessary information to generate
          the server part of the handshake.</t>

          <t>The client handshake consists of the following parts. If the
          server, while reading the handshake, finds that the client did not
          send a handshake that matches the description below, the server must
          abort the WebSocket connection.
          <list style='numbers'>
            <t>An HTTP/1.1 or higher OPTIONS request with a request target of
            &quot;*&quot;</t>

            <t>A &quot;Host&quot; header containing the server's
            authority.</t>

            <t>A &quot;Sec-WebSocket-Key&quot; header with a base64-encoded
            value that, when decoded, is 16 bytes in length.</t>

            <t>A &quot;Sec-WebSocket-Origin&quot; header.</t>

            <t>A &quot;Sec-WebSocket-URL&quot; header, with a value denoting
            the location of the resource (endpoint) requested of the server.
            If the server only supports one resource, then this can safely be
            ignored.</t>

            <t>Optionally, a &quot;Sec-WebSocket-Protocol header, with a list
            of values indicating which protocols the client would like to
            speak, ordered by preference.</t>

            <t>Optionally, a &quot;Sec-WebSocket-Extensions&quot; header, with
            a list of values indicating which extensions the client would like
            to speak.</t>

            <t>Optionally, other headers, such as those used to send cookies
            to a server. Unknown headers MUST be ignored.</t>
          </list>
          </t>
        </section>
        <section title='Sending the server&apos;s opening handshake'>
          <t>When a client establishes a WebSocket connection to a server, the
          server must complete the following steps to accept the connection
          and send the server&apos;s opening handshake.
          <list style='numbers'>
            <t>If the server supports encryption, perform a TLS handshake
            over the connection. If this fails (e.g. the client indicated a
            host name in the extended client hello &quot;server_name&quot;
            extension that the server does not host), then close the
            connection; otherwise, all further communication for the
            connection (including the server handshake) must run through the
            encrypted tunnel. <xref target='RFC2246'/></t>

            <t>Establish the following information:
            <list style='hanging'>
              <t hangText='/origin/'><vspace blankLines='0'/>
              The |Sec-WebSocket-Origin| header in the client&apos;s handshake
              indicates the origin of the script establishing the connection.
              The origin is serialized to ASCII and converted to lowercase.
              The server MAY use this information as part of a determination
              of whether to accept the incoming connection.</t>

              <t hangText='/key/'><vspace blankLines='0'/>
              The |Sec-WebSocket-Key| header in the client&apos;s handshake
              includes a base64-encoded value that, if decoded, is 16 bytes in
              length. This (encoded) value is used in the creation of the
              server&apos;s handshake to indicate an acceptance of the
              connection. It is not necessary for the server to base64-decode
              the Sec-WebSocket-Key value.</t>

              <t hangText='/resource name/'><vspace blankLines='0'/>
              An identifier for the service provided by the server. If the
              server provides multiple services, then the value should be
              derived from the resource name given in the client&apos;s
              handshake as part of the |Sec-WebSocket-URL| header.</t>

              <t hangText='/subprotocol/'><vspace blankLines='0'/>
              A (possibly empty) list representing the subprotocol the server
              is ready to use. If the server supports multiple subprotocols,
              then the value should be derived from the client&apos;s
              handshake, specifically by selecting one of the values from the
              &quot;Sec-WebSocket-Protocol&quot; field. The absence of such a
              field is equivalent to the null value. The empty string is not
              the same as the null value for these purposes.</t>

              <t hangText='/extensions/'><vspace blankLines='0'/>
              A (possibly empty) list representing the protocol-level
              extensions the server is ready to use. If the server supports
              multiple extensions, then the value should be derived from the
              client&apos;s handshake, specifically by selecting one of the
              values from the &quot;Sec-WebSocket-Extensions&quot; field. The
              absence of such a field is equivalent to the null value. The
              empty string is not the same as the null value for these
              purposes.</t>
            </list>
            </t>

            <t>If the server chooses to accept the incoming connection, it
            must reply with a valid HTTP response indicating the following.
            <list style='numbers'>
              <t>A 101 response code. Such a response could look like
              &quot;HTTP/1.1 101 Switching Protocols&quot;</t>

              <t>A &quot;Sec-WebSocket-Accept&quot; header. The value of this
              header is constructed by concatenating the value of the
              client&apos;s &quot;Sec-WebSocket-Key&quot; header in the
              client&apos;s handshake with the string
              &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;, taking the
              SHA-1 hash of this concatenated value to obtain a 20-byte value,
              and base64-encoding this 20-byte hash.
              <vspace blankLines='1'/>
              NOTE: As an example, if the value of the
              &quot;Sec-WebSocket-Key&quot; header in the client's handshake
              were &quot;dGhlIHNhbXBsZSBub25jZQ==&quot;, the server would
              append the string
              &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to form the
              string
    &quot;dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;.
              The server would then take the SHA-1 hash of this string, giving
              the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46
              0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then
              base64-encoded, to give the value
              &quot;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&quot;, which would be
              returned in the &quot;Sec-WebSocket-Accept&quot; header.</t>

              <t>A &quot;Sec-WebSocket-Nonce&quot; header. The value of this
              header MUST be a nonce consisting of a randomly selected 16-byte
              value that has been base64-encoded <xref target='RFC3548'/>. The
              nonce MUST be randomly selected randomly for each connection.
              <vspace blankLines='1'/>
              NOTE: As an example, if the randomly selected value was the
              sequence of bytes 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09
              0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, the value of the header
              would be &quot;AQIDBAUGBwgJCgsMDQ4PEC==&quot; value </t>

              <t>Optionally, a &quot;Sec-WebSocket-Protocol&quot; header,
              indicating the subprotocol, if any, the server is prepared to
              speak. The value of this header must be equal to one of the
              values specified by the client in its opening handshake.</t>

              <t>Optionally, a &quot;Sec-WebSocket-Extensions&quot; header,
              indicating the protocol level extensions, if any, the server is
              prepared to speak. The value of this header must be a subset of
              the values specified by the client in its opening handshake.</t>
            </list>
            </t>
          </list>
          </t>

          <t>This completes the server&apos;s handshake. If the server
          finishes these steps without aborting the WebSocket connection, and
          if the client does not then fail the WebSocket connection, then the
          connection is established and the server may begin sending and
          receiving data, as described in the next section.</t>
        </section>
      </section>
    </section>
    <section title='Error Handling'>
      <section title='Handling errors in UTF-8 from the server'>
        <t>When a client is to interpret a byte stream as UTF-8 but finds that the byte stream is not in fact a valid UTF-8 stream, then any bytes or sequences of bytes that are not valid UTF-8 sequences must be interpreted as a U+FFFD REPLACEMENT CHARACTER.</t>
      </section>
      <section title='Handling errors in UTF-8 from the client'>
        <t>When a server is to interpret a byte stream as UTF-8 but finds that the byte stream is not in fact a valid UTF-8 stream, behavior is undefined. A server could close the connection, convert invalid byte sequences to U+FFFD REPLACEMENT CHARACTERs, store the data verbatim, or perform application-specific processing. Subprotocols layered on the WebSocket protocol might define specific behavior for servers.</t>
      </section>
    </section>
    <section title='Closing the connection' anchor='closing_connection'>
      <section title='Client-initiated closure'>
        <t>
          Certain algorithms require the user agent to <spanx style='strong'>fail the WebSocket connection</spanx>. To do so, the user agent must close the WebSocket connection, and may report the problem to the user (which would be especially useful for developers).
        </t>
        <t>Except as indicated above or as specified by the application layer (e.g. a script using the WebSocket API), user agents should not close the connection.</t>
        <t>
          User agents must not convey any failure information to scripts in a way that would allow a script to distinguish the following situations:
          <list style='symbols'>
            <t>A server whose host name could not be resolved.</t>
            <t>A server to which packets could not successfully be routed.</t>
            <t>A server that refused the connection on the specified port.</t>
            <t>A server that did not complete the opening handshake (e.g. because it was not a WebSocket server).</t>
            <t>A WebSocket server that sent a correct opening handshake, but that specified options that caused the client to drop the connection (e.g. the server specified an origin that differed from the script&apos;s).</t>
            <t>A WebSocket server that abruptly closed the connection after successfully completing the opening handshake.</t>
          </list>
        </t>
      </section>
      <section title='Server-initiated closure'>
        <t>
          Certain algorithms require or recommend that the server <spanx style='strong'>abort the WebSocket connection</spanx> during the opening handshake. To do so, the server must simply close the WebSocket connection.
        </t>
      </section>
      <section title='Closure'>
        <t>
          To <spanx style='strong'>close the WebSocket connection</spanx>, the user agent or server must close the TCP connection, using whatever mechanism possible (e.g. either the TCP RST or FIN mechanisms). When a user agent notices that the server has closed its connection, it must immediately close its side of the connection also. Whether the user agent or the server closes the connection first, it is said that the <spanx style='strong'>WebSocket connection is closed</spanx>. If the connection was closed after the client finished the WebSocket closing handshake, then the WebSocket connection is said to have been closed <spanx style='emph'>cleanly</spanx>.
        </t>
        <t>Servers may close the WebSocket connection whenever desired. User agents should not close the WebSocket connection arbitrarily.</t>
      </section>
    </section>
    <section title="Known extensions">
      <t>Extensions provide a mechanism for implementations to opt-in to
      additional protocol features. This section defines the meaning of
      well-known extensions but implementations may use extensions defined
      separately as well.</t>
      <section title="Compression">
        <t>The registered extension token for this compression extension is
        "deflate-stream".</t>
        <t>The extension does not have any per message extension data and it
        does not define the use of any WebSocket reserved bits or op codes.</t>
        <t>Senders using this extension MUST apply RFC 1951 encodings to all
        bytes of the data stream following the handshake including both data
        and control messages. The data stream MAY include multiple blocks of
        both compressed and uncompressed types as defined by RFC 1951. <xref
        target="RFC1951"/></t>
        <t>Senders MUST NOT delay the transmission of any portion of a WebSocket
        message because the deflate encoding of the message does not end on a
        byte boundary. The encodings for adjacent messages MAY appear in the
        same byte if no delay in transmission is occurred by doing so.</t>
      </section>
    </section>
    <section title='Security considerations'>
      <t>While this protocol is intended to be used by scripts in Web pages, it can also be used directly by hosts. Such hosts are acting on their own behalf, and can therefore send fake &quot;Origin&quot; fields, misleading the server. Servers should therefore be careful about assuming that they are talking directly to scripts from known origins, and must consider that they might be accessed in unexpected ways. In particular, a server should not trust that any input is valid.</t>
      <t>EXAMPLE: For example, if the server uses input as part of SQL queries, all input text should be escaped before being passed to the SQL server, lest the server be susceptible to SQL injection.</t>
      <t>
        <vspace blankLines='1'/>
      </t>
      <t>Servers that are not intended to process input from any Web page but only for certain sites should verify the &quot;Origin&quot; field is an origin they expect, and should only respond with the corresponding &quot;Sec-WebSocket-Origin&quot; if it is an accepted origin. Servers that only accept input from one origin can just send back that value in the &quot;Sec-WebSocket-Origin&quot; field, without bothering to check the client&apos;s value.</t>
      <t>
        <vspace blankLines='1'/>
      </t>
      <t>If at any time a server is faced with data that it does not understand, or that violates some criteria by which the server determines safety of input, or when the server sees a handshake that does not correspond to the values the server is expecting (e.g. incorrect path or origin), the server should just disconnect. It is always safe to disconnect.</t>
      <t>
        <vspace blankLines='1'/>
      </t>
      <t>The biggest security risk when sending text data using this protocol is sending data using the wrong encoding. If an attacker can trick the server into sending data encoded as ISO-8859-1 verbatim (for instance), rather than encoded as UTF-8, then the attacker could inject arbitrary frames into the data stream.</t>
    </section>
    <section title='IANA considerations'>
      <section title='Registration of ws: scheme'>
        <t>
          A |ws:| URL identifies a WebSocket server and resource name.
          <list style='hanging'>
            <t hangText='URI scheme name.'>
              <vspace blankLines='0'/>ws
            </t>
            <t hangText='Status.'>
              <vspace blankLines='0'/>Permanent.
            </t>
            <t hangText='URI scheme syntax.'>
              <vspace blankLines='0'/>In ABNF terms using the terminals from the URI specifications: <xref target='RFC5234'/> <xref target='RFC3986'/><vspace blankLines='1'/><figure>
                <artwork>        &quot;ws&quot; &quot;:&quot; hier-part [ &quot;?&quot; query ]</artwork>
              </figure>

              <vspace blankLines='1'/>
              The path and query components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in RFC3986.
            </t>
            <t hangText='URI scheme semantics.'>
              <vspace blankLines='0'/>The only operation for this scheme is to open a connection using the WebSocket protocol.
            </t>
            <t hangText='Encoding considerations.'>
              <vspace blankLines='0'/>Characters in the host component that are excluded by the syntax defined above must be converted from Unicode to ASCII by applying the IDNA ToASCII algorithm to the Unicode host name, with both the AllowUnassigned and UseSTD3ASCIIRules flags set, and using the result of this algorithm as the host in the URI. <xref target='RFC3490'/>
              <vspace blankLines='1'/>
              Characters in other components that are excluded by the syntax defined above must be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI and IRI specification. <xref target='RFC3986'/> <xref target='RFC3987'/>
            </t>
            <t hangText='Applications/protocols that use this URI scheme name.'>
              <vspace blankLines='0'/>WebSocket protocol.
            </t>
            <t hangText='Interoperability considerations.'>
              <vspace blankLines='0'/>None.
            </t>
            <t hangText='Security considerations.'>
              <vspace blankLines='0'/>See &quot;Security considerations&quot; section above.
            </t>
            <t hangText='Contact.'>
              <vspace blankLines='0'/>Ian Hickson &lt;ian@hixie.ch&gt;
            </t>
            <t hangText='Author/Change controller.'>
              <vspace blankLines='0'/>Ian Hickson &lt;ian@hixie.ch&gt;
            </t>
            <t hangText='References.'>
              <vspace blankLines='0'/>This document.
            </t>
          </list>
        </t>
      </section>
      <section title='Registration of wss: scheme'>
        <t>
          A |wss:| URL identifies a WebSocket server and resource name, and indicates that traffic over that connection is to be encrypted.
          <list style='hanging'>
            <t hangText='URI scheme name.'>
              <vspace blankLines='0'/>wss
            </t>
            <t hangText='Status.'>
              <vspace blankLines='0'/>Permanent.
            </t>
            <t hangText='URI scheme syntax.'>
              <vspace blankLines='0'/>In ABNF terms using the terminals from the URI specifications: <xref target='RFC5234'/> <xref target='RFC3986'/><vspace blankLines='1'/><figure>
                <artwork>        &quot;wss&quot; &quot;:&quot; hier-part [ &quot;?&quot; query ]</artwork>
              </figure>

              <vspace blankLines='1'/>
              The path and query components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in RFC3986.
            </t>
            <t hangText='URI scheme semantics.'>
              <vspace blankLines='0'/>The only operation for this scheme is to open a connection using the WebSocket protocol, encrypted using TLS.
            </t>
            <t hangText='Encoding considerations.'>
              <vspace blankLines='0'/>Characters in the host component that are excluded by the syntax defined above must be converted from Unicode to ASCII by applying the IDNA ToASCII algorithm to the Unicode host name, with both the AllowUnassigned and UseSTD3ASCIIRules flags set, and using the result of this algorithm as the host in the URI. <xref target='RFC3490'/>
              <vspace blankLines='1'/>
              Characters in other components that are excluded by the syntax defined above must be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI and IRI specification. <xref target='RFC3986'/> <xref target='RFC3987'/>
            </t>
            <t hangText='Applications/protocols that use this URI scheme name.'>
              <vspace blankLines='0'/>WebSocket protocol over TLS.
            </t>
            <t hangText='Interoperability considerations.'>
              <vspace blankLines='0'/>None.
            </t>
            <t hangText='Security considerations.'>
              <vspace blankLines='0'/>See &quot;Security considerations&quot; section above.
            </t>
            <t hangText='Contact.'>
              <vspace blankLines='0'/>Ian Hickson &lt;ian@hixie.ch&gt;
            </t>
            <t hangText='Author/Change controller.'>
              <vspace blankLines='0'/>Ian Hickson &lt;ian@hixie.ch&gt;
            </t>
            <t hangText='References.'>
              <vspace blankLines='0'/>This document.
            </t>
          </list>
        </t>
      </section>
      <section title='Registration of the &quot;WebSocket&quot; HTTP Upgrade keyword'>
        <t>
          <list style='hanging'>
            <t hangText='Name of token.'>
              <vspace blankLines='0'/>WebSocket
            </t>
            <t hangText='Author/Change controller.'>
              <vspace blankLines='0'/>Ian Hickson &lt;ian@hixie.ch&gt;
            </t>
            <t hangText='Contact.'>
              <vspace blankLines='0'/>Ian Hickson &lt;ian@hixie.ch&gt;
            </t>
            <t hangText='References.'>
              <vspace blankLines='0'/>This document.
            </t>
          </list>
        </t>
      </section>
      <section title='Sec-WebSocket-Key and Sec-WebSocket-Nonce'>
        <t>
          This section describes two header fields for registration in the Permanent Message Header Field Registry. <xref target='RFC3864'/>
        </t>
        <t>
          <list style='hanging'>
            <t hangText='Header field name'>
              <vspace blankLines='0'/>Sec-WebSocket-Key
            </t>
            <t hangText='Applicable protocol'>
              <vspace blankLines='0'/>http
            </t>
            <t hangText='Status'>
              <vspace blankLines='0'/>reserved; do not use outside WebSocket handshake
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF
            </t>
            <t hangText='Specification document(s)'>
              <vspace blankLines='0'/> This document is the relevant specification.
            </t>
            <t hangText='Related information'>
              <vspace blankLines='0'/>None.
            </t>
          </list>
        </t>
        <t>
          <list style='hanging'>
            <t hangText='Header field name'>
              <vspace blankLines='0'/>Sec-WebSocket-Nonce
            </t>
            <t hangText='Applicable protocol'>
              <vspace blankLines='0'/>http
            </t>
            <t hangText='Status'>
              <vspace blankLines='0'/>reserved; do not use outside WebSocket handshake
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF
            </t>
            <t hangText='Specification document(s)'>
              <vspace blankLines='0'/> This document is the relevant specification.
            </t>
            <t hangText='Related information'>
              <vspace blankLines='0'/>None.
            </t>
          </list>
        </t>
        <t>The |Sec-WebSocket-Key| and |Sec-WebSocket-Nonce| headers are used in the WebSocket handshake. They are sent from the client to the server to provide part of the information used by the server to prove that it received a valid WebSocket handshake. This helps ensure that the server does not accept connections from non-Web-Socket clients (e.g. HTTP clients) that are being abused to send data to unsuspecting WebSocket servers.</t>
      </section>
      <section title='Sec-WebSocket-Location'>
        <t>
          This section describes a header field for registration in the Permanent Message Header Field Registry. <xref target='RFC3864'/>
        </t>
        <t>
          <list style='hanging'>
            <t hangText='Header field name'>
              <vspace blankLines='0'/>Sec-WebSocket-Location
            </t>
            <t hangText='Applicable protocol'>
              <vspace blankLines='0'/>http
            </t>
            <t hangText='Status'>
              <vspace blankLines='0'/>reserved; do not use outside WebSocket handshake
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF
            </t>
            <t hangText='Specification document(s)'>
              <vspace blankLines='0'/> This document is the relevant specification.
            </t>
            <t hangText='Related information'>
              <vspace blankLines='0'/>None.
            </t>
          </list>
        </t>
        <t>The |Sec-WebSocket-Location| header is used in the WebSocket handshake. It is sent from the server to the client to confirm the URL of the connection. This enables the client to verify that the connection was established to the right server, port, and path, instead of relying on the server to verify that the requested host, port, and path are correct.</t>
      </section>
      <section title='Sec-WebSocket-Origin'>
        <t>
          This section describes a header field for registration in the Permanent Message Header Field Registry. <xref target='RFC3864'/>
        </t>
        <t>
          <list style='hanging'>
            <t hangText='Header field name'>
              <vspace blankLines='0'/>Sec-WebSocket-Origin
            </t>
            <t hangText='Applicable protocol'>
              <vspace blankLines='0'/>http
            </t>
            <t hangText='Status'>
              <vspace blankLines='0'/>reserved; do not use outside WebSocket handshake
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF
            </t>
            <t hangText='Specification document(s)'>
              <vspace blankLines='0'/> This document is the relevant specification.
            </t>
            <t hangText='Related information'>
              <vspace blankLines='0'/>None.
            </t>
          </list>
        </t>
        <t>The |Sec-WebSocket-Origin| header is used in the WebSocket handshake. It is sent from the server to the client to confirm the origin of the script that opened the connection. This enables user agents to verify that the server is willing to serve the script that opened the connection.</t>
      </section>
      <section title='Sec-WebSocket-Protocol'>
        <t>
          This section describes a header field for registration in the Permanent Message Header Field Registry. <xref target='RFC3864'/>
        </t>
        <t>
          <list style='hanging'>
            <t hangText='Header field name'>
              <vspace blankLines='0'/>Sec-WebSocket-Protocol
            </t>
            <t hangText='Applicable protocol'>
              <vspace blankLines='0'/>http
            </t>
            <t hangText='Status'>
              <vspace blankLines='0'/>reserved; do not use outside WebSocket handshake
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF
            </t>
            <t hangText='Specification document(s)'>
              <vspace blankLines='0'/> This document is the relevant specification.
            </t>
            <t hangText='Related information'>
              <vspace blankLines='0'/>None.
            </t>
          </list>
        </t>
        <t>The |Sec-WebSocket-Protocol| header is used in the WebSocket handshake. It is sent from the client to the server and back from the server to the client to confirm the subprotocol of the connection. This enables scripts to both select a subprotocol and be sure that the server agreed to serve that subprotocol.</t>
      </section>


      <section title='Sec-WebSocket-Draft'>
        <t>
          This section describes a header field for registration in the Permanent Message Header Field Registry. <xref target='RFC3864'/>
        </t>
        <t>
          <list style='hanging'>
            <t hangText='Header field name'>
              <vspace blankLines='0'/>Sec-WebSocket-Draft
            </t>
            <t hangText='Applicable protocol'>
              <vspace blankLines='0'/>http
            </t>
            <t hangText='Status'>
              <vspace blankLines='0'/>reserved; do not use outside WebSocket handshake
            </t>
            <t hangText='Author/Change controller'>
              <vspace blankLines='0'/>IETF
            </t>
            <t hangText='Specification document(s)'>
              <vspace blankLines='0'/> This document is the relevant specification.
            </t>
            <t hangText='Related information'>
              <vspace blankLines='0'/>None.
            </t>
          </list>
        </t>
        <t>The |Sec-WebSocket-Draft| header is used in the WebSocket handshake. It is sent from the client to the server to indicate the draft protocol version of the connection. This enables servers to correctly interpret the handshake and subsequent data being sent from the data, and close the connection if the server cannot interpret that data in a safe manner.</t>
      </section>

    </section>
    <section title='Using the WebSocket protocol from other specifications'>
      <t>The WebSocket protocol is intended to be used by another specification to provide a generic mechanism for dynamic author-defined content, e.g. in a specification defining a scripted API.</t>
      <t>
        Such a specification first needs to &quot;establish a WebSocket connection&quot;, providing that algorithm with:
        <list style='symbols'>
          <t>The destination, consisting of a /host/ and a /port/.</t>
          <t>A /resource name/, which allows for multiple services to be identified at one host and port.</t>
          <t>A /secure/ flag, which is true if the connection is to be encrypted, and false otherwise.</t>
          <t>
            An ASCII serialization of an origin that is being made responsible for the connection. <xref target='ORIGIN'/>
          </t>
          <t>Optionally a string identifying a protocol that is to be layered over the WebSocket connection.</t>
        </list>
      </t>
      <t>The /host/, /port/, /resource name/, and /secure/ flag are usually obtained from a URL using the steps to parse a WebSocket URL&apos;s components. These steps fail if the URL does not specify a WebSocket.</t>
      <t>If a connection can be established, then it is said that the &quot;WebSocket connection is established&quot;.</t>
      <t>If at any time the connection is to be closed, then the specification needs to use the &quot;close the WebSocket connection&quot; algorithm.</t>
      <t>When the connection is closed, for any reason including failure to establish the connection in the first place, it is said that the &quot;WebSocket connection is closed&quot;.</t>
      <t>While a connection is open, the specification will need to handle the cases when &quot;a WebSocket message has been received&quot; with text /data/.</t>
      <t>To send some text /data/ to an open connection, the specification needs to &quot;send /data/ using the WebSocket&quot;.</t>
    </section>
    <section title='Acknowledgements'>
      <t>
        Special thanks are due to Ian Hickson, who was the original author and editor of this protocol. The initial design of this specification benefitted from the participation of many people in the WHATWG and WHATWG mailing list. Contributions to that specification are not tracked by section, but a list of all who contributed to that specification is given in the WHATWG HTML specification. <xref target='HTML'/>
      </t>
      <t>Special thanks also to John Tamplin for providing a significant amount of text for the Data Framing section of this specification.</t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <reference anchor='HTML' target='http://whatwg.org/html5'>
        <front>
          <title>HTML</title>
          <author initials='I.E.' surname='Hickson' fullname='Ian Hickson'>
            <organization>Google, Inc.</organization>
          </author>
          <date day="18" month="August" year="2010"/>
        </front>
      </reference>
      <reference anchor='ORIGIN' target='http://tools.ietf.org/html/draft-abarth-origin'>
        <front>
          <title>The HTTP Origin Header</title>
          <author initials='A.' surname='Barth' fullname='Adam Barth'>
            <organization>U.C. Berkeley</organization>
          </author>
          <author initials='C.' surname='Jackson' fullname='Collin Jackson'>
            <organization>Stanford University</organization>
          </author>
          <author initials='I.E.' surname='Hickson' fullname='Ian Hickson'>
            <organization>Google, Inc.</organization>
          </author>
          <date day="24" month="September" year="2009"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-abarth-origin"/>
      </reference>
      <?rfc include='reference.ANSI.X3-4.1986.xml'?>
      <?rfc include='reference.FIPS.180-2.2002.xml'?>
      <!--<?rfc include='reference.RFC.1321.xml'?>-->
      <?rfc include='reference.RFC.1951.xml'?>
      <?rfc include='reference.RFC.2109.xml'?>
      <?rfc include='reference.RFC.2119.xml'?>
      <?rfc include='reference.RFC.2246.xml'?>
      <?rfc include='reference.RFC.2616.xml'?>
      <?rfc include='reference.RFC.2965.xml'?>
      <?rfc include='reference.RFC.3490.xml'?>
      <?rfc include='reference.RFC.3548.xml'?>
      <?rfc include='reference.RFC.3629.xml'?>
      <?rfc include='reference.RFC.3864.xml'?>
      <?rfc include='reference.RFC.3986.xml'?>
      <?rfc include='reference.RFC.3987.xml'?>
      <?rfc include='reference.RFC.4366.xml'?>
      <?rfc include='reference.RFC.5234.xml'?>
<!--
      <reference anchor='WEBADDRESSES' target='http://www.w3.org/html/wg/href/draft'>
        <front>
          <title>Web addresses in HTML 5</title>
          <author initials='D.' surname='Connolly' fullname='Dan Connolly'>
            <organization>Midwest Web Sense LLC and W3C</organization>
          </author>
          <author initials='C. M.' surname='Sperberg-McQueen' fullname='C. M. Sperberg-McQueen'>
            <organization>Black Mesa Technologies LLC</organization>
          </author>
          <date day="21" month="May" year="2009"/>
        </front>
      </reference>
-->
      <reference anchor='WSAPI' target='http://dev.w3.org/html5/websockets/'>
        <front>
          <title>The Web Sockets API</title>
          <author initials='I.E.' surname='Hickson' fullname='Ian Hickson'>
            <organization>Google, Inc.</organization>
          </author>
          <date day="18" month="August" year="2010"/>
        </front>
      </reference>
    </references>
  </back>
</rfc>
