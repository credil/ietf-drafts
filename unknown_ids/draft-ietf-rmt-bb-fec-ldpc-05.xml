<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<rfc category="exp" ipr="full3978" docName="draft-ietf-rmt-bb-fec-ldpc-05.txt">

<!--
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
-->
<?xml-stylesheet type='text/xsl'
                href='http://xml.resource.org/authoring/rfc2629.xslt' ?>


<?rfc toc="yes" ?>
<?rfc symrefs="no" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

    <front>
        <title abbrev='LDPC Staircase and Triangle FEC'>
            Low Density Parity Check (LDPC) Staircase and Triangle Forward Error Correction (FEC) Schemes
        </title>
        <author initials='V.R.' surname="Roca" fullname='Vincent Roca'>
            <organization>INRIA</organization>
            <address>
                <postal>
                    <street>655, av. de l'Europe</street>
                    <street>Zirst; Montbonnot</street>
                    <city>ST ISMIER cedex</city>
                    <code>38334</code>
                    <country>France</country>
                </postal>
                <email>vincent.roca@inrialpes.fr</email>
        	<uri>http://planete.inrialpes.fr/~roca/</uri>
            </address>
        </author>
        <author initials='C.N.' surname="Neumann" fullname='Christoph Neumann'>
            <organization>Thomson Research</organization>
            <address>
                <postal>
                    <street>46, Quai A. Le Gallo</street>
                    <city>Boulogne Cedex</city>
                    <code>92648</code>
                    <country>France</country>
                </postal>
                <email>christoph.neumann@thomson.net</email>
        	<uri>http://planete.inrialpes.fr/~chneuman/</uri>
            </address>
        </author>
        <author initials='D.F.' surname="Furodet" fullname='David Furodet'>
            <organization>STMicroelectronics</organization>
            <address>
                <postal>
                    <street>12, Rue Jules Horowitz</street>
                    <street>BP217</street>
                    <city>Grenoble Cedex</city>
                    <code>38019</code>
                    <country>France</country>
                </postal>
                <email>david.furodet@st.com</email>
                <uri>http://www.st.com/</uri>
            </address>
        </author>
	
        <date day="29" month="March" year="2007"/>
        <area>Transport</area>
        <workgroup>RMT</workgroup>
        <keyword>LDPC</keyword>
        <keyword>FEC</keyword>
        <abstract>
		<t>This document describes two Fully-Specified FEC Schemes,
		LDPC-Staircase and LDPC-Triangle, and their application to the
		reliable delivery of objects on packet erasure channels.
		These systematic FEC codes belong to the well known class of
		``Low Density Parity Check'' (LDPC) codes, and are large block
		FEC codes in these sense of RFC3453. </t>
        </abstract>
    </front>

    <middle>

<section anchor="intro" title="Introduction">
<!-- ==================================== -->

<t><xref target="RFC3453">RFC 3453</xref>
introduces large block FEC codes as an alternative to small
block FEC codes like Reed-Solomon.
The main advantage of such large block codes is the possibility to operate
efficiently on source blocks of size several tens of thousands (or more)
source symbols.
The present document introduces 
the Fully-Specified FEC Encoding ID 3 that is intended to be used with
the LDPC-Staircase FEC codes, and 
the Fully-Specified FEC Encoding ID 4 that is intended to be used with
the LDPC-Triangle FEC codes
<xref target="Roca04"/><xref target="Mac03"/>.
Both schemes belong to the broad class of large block codes.</t>

<t>
LDPC codes rely on a dedicated matrix, called a "Parity Check
Matrix", at the encoding and decoding ends. The parity check matrix
defines relationships (or constraints) between the various encoding
symbols (i.e. source symbols and repair symbols), that are later used
by the decoder to reconstruct the original k source symbols if some
of them are missing. These codes are systematic, in the sense that
the encoding symbols include the source symbols in addition to the
repair symbols.</t>

<t>
Since the encoder and decoder must operate on the same parity
check matrix, information must be communicated between them as
part of the FEC Object Transmission Information.</t>

<t>
A publicly available reference implementation of these codes is available
and distributed under a GNU/LGPL license <xref target="LDPCrefimpl"/>.
</t>
</section>


<section title="Requirements notation">
<!-- ==================================== -->

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
    "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
    and "OPTIONAL" in this document are to be interpreted as
    described in <xref target="RFC2119"/>.</t>
</section>


<section title="Definitions, Notations and Abbreviations">
<!-- ================================================= -->

  <section title="Definitions">
  <!-- ==================== -->

<t>This document uses the same terms and definitions as those
specified in <xref target="fec-bb-revised"/>.
Additionally, it uses the following definitions:
<list style="empty">
<t>Encoding Symbol Group:	a group of encoding symbols that are
				sent together, within the same packet, and
				whose relationships to the source object can
				be derived from a single Encoding Symbol
				ID.</t>
<t>Source Packet:		a data packet containing only source
				symbols.</t>
<t>Repair Packet:		a data packet containing only repair
				symbols.</t>
</list>
</t>

  </section>

  <section title="Notations">
  <!-- ================== -->

<t>This document uses the following notations:
<list style="empty">
<t>L		denotes the object transfer length in bytes</t>
<t>k		denotes the source block length in symbols,
		i.e. the number of source symbols of a source block</t>
<t>n		denotes the encoding block length, i.e. the number of
		encoding symbols generated for a source block</t>
<t>E		denotes the encoding symbol length in bytes</t>
<t>B		denotes the maximum source block length in symbols,
		i.e. the maximum number of source symbols per source block</t>
<t>N		denotes the number of source blocks into which the object
		shall be partitioned</t>
<t>G		denotes the number of encoding symbols per group, i.e.
		the number of symbols sent in the same packet</t>
<t>rate		denotes the "code rate", i.e. the k/n ratio</t>
<t>max_n	denotes the maximum number of encoding symbols generated for any
		source block</t>
<t>H		denotes the parity check matrix</t>
<t>srand(s)	denotes the initialization function of the pseudo-random
		number generator, where s is the seed (s > 0)</t>
<t>rand(m)	denotes a pseudo-random number generator that returns
		a new random integer in [0; m-1] each time it is called</t>
</list></t>
  </section>

  <section title="Abbreviations">
  <!-- ====================== -->

<t>This document uses the following abbreviations:
<list style="empty">
<t>ESI:		Encoding Symbol ID</t>
<t>FEC OTI:	FEC Object Transmission Information</t>
<t>FPI:  FEC Payload ID</t>
<t>LDPC: Low Density Parity Check</t>
<t>PRNG: Pseudo Random Number Generator</t>
</list></t>
  </section>

</section>


<section title="Formats and Codes">
<!-- ========================== -->

  <section title="FEC Payload IDs" anchor="FPI">
  <!-- =========================-->

<t>The FEC Payload ID is composed of the Source Block 
   Number and the Encoding Symbol ID:</t>

<t>
<list style="empty">
<t>The Source Block Number (12 bit field) identifies from which source block
   of the object the encoding symbol(s) in the packet payload is(are) generated.
   There are a maximum of 2^^12 blocks per object. Source block numbering starts at 0.</t>

<t>The Encoding Symbol ID (20 bit field) identifies which encoding
   symbol(s) generated from the source block is(are) carried in the packet payload.
   There are a maximum of 2^^20 encoding symbols per block.
   The first k values (0 to k-1) identify source symbols, the remaining n-k
   values (k to n-k-1) identify repair symbols.</t>
</list>
</t>

<t>There MUST be exactly one FEC Payload ID per packet.
In case of an Encoding Symbol Group,
when multiple encoding symbols are sent in the same packet,
the FEC Payload ID refers to the first symbol of the packet.
The other symbols can be deduced from the ESI of the first symbol
thanks to a dedicated function, as explained in
<xref target="encoding_symbol_group"></xref>
</t>


<figure anchor="fig_fec_payload_id_for_1" title="FEC Payload ID encoding format for FEC Encoding ID 3 and 4"> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Source Block Number  |      Encoding Symbol ID (20 bits)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>


  </section>

  <section title="FEC Object Transmission Information" anchor="FEC_OTI">
  <!-- =============================================-->

    <section title="Mandatory Element">
    <!-- ============================-->
   
<t>
<list style="symbols">
   <t>FEC Encoding ID: 
   the LDPC-Staircase and LDPC-Triangle Fully-Specified FEC Schemes use
   respectively the FEC Encoding ID 3 (Staircase) and 4 (Triangle).
   </t>
</list>
</t>


    </section>

    <section title="Common Elements" anchor="common_elements">
    <!-- =========================-->

   <t> The following elements MUST be defined with the present FEC Scheme:</t>

<t>
<list style="symbols">
   <t>Transfer-Length (L): a non-negative integer indicating the length of the
      object in bytes.
      There are some restrictions on the maximum Transfer-Length that
      can be supported:
      <list style="empty">
	<t>maximum transfer length = 2^^12 * B * E</t>
      </list>
      For instance, if B=2^^19 (because of a code rate of 1/2, 
      <xref target="max_source_block_length"/>), and if E=1024 bytes,
      then the maximum transfer length is 2^^41 bytes (or 2 TB).
      The upper limit, with symbols of size 2^^16-1 bytes and a code rate
      larger or equal to 1/2, amounts to 2^^47 bytes (or 128 TB).
      </t>

   <t>Encoding-Symbol-Length (E): a non-negative integer indicating the length
      of each encoding symbol in bytes.</t>

   <t>Maximum-Source-Block-Length (B): a non-negative integer indicating the
      maximum number of source symbols in a source block.
      There are some restrictions on the maximum B value, as explained in
      <xref target='max_source_block_length'/>.
      </t>

   <t>Max-Number-of-Encoding-Symbols (max_n): a non-negative integer
      indicating the maximum number of encoding symbols generated for
      any source block.
      There are some restrictions on the maximum max_n value.
      In particular max_n is at most equal to 2^^20.
      </t>
</list>
</t>

   <t><xref target="procedures"></xref> explains how to define the values
      of each of these elements.</t>

    </section>

    <section title="Scheme-Specific Elements" anchor="scheme_specific_elt">
    <!-- ==================================-->

<t> The following elements MUST be defined with the present FEC Scheme:</t>

<t>
<list style="symbols">
    <t> G: a non-negative integer indicating the number of encoding symbols
    per group (i.e. per packet). The default value is 1, meaning that
    each packet contains exactly one symbol.
    Values greater than 1 can also be defined, as explained in
    <xref target="encoding_symbol_length"/>.
    </t>

    <t> PRNG seed: the seed is a 32 bit unsigned integer between 1 and 
    0x7FFFFFFE (i.e. 2^^31-2) inclusive. This value is used to initialize the
    Pseudo Random Number Generator (<xref target="prng"/>).
    This element is optional. Whether or not it is present in the FEC OTI
    is signaled in the associated encoding format through an appropriate
    mechanism (<xref target="FEC_OTI_encoding_format"/>).
    When the PRNG seed is not carried within the FEC OTI, it is assumed that
    encoder and decoders use another way to communicate the information,
    or use a fixed, predefined value.</t>
</list>
</t>

    </section>

    <section title="Encoding Format" anchor="FEC_OTI_encoding_format">
    <!-- =========================-->
    
    <t>This section shows two possible encoding formats of the above FEC OTI.
    The present document does not specify when or how these encoding
    formats should be used.</t>
    
        <section title="Using the General EXT_FTI Format">
        <!-- =========================-->

<t>
The FEC OTI binary format is the following, when the EXT_FTI mechanism
is used (e.g. within the ALC <xref target="draft-ietf-rmt-pi-alc-revised"/>
 or NORM <xref target="draft-ietf-rmt-pi-norm-revised"/> protocols).
</t>

<figure anchor="fig_ext_fti"
	title="EXT_FTI Header for FEC Encoding ID 3 and 4.">
    <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   HET = 64    | HEL (=4 or 5) |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                      Transfer-Length (L)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  |       G       |   B (MSB)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        B (LSB)        |   Max Nb of Enc. Symbols  (max_n)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.                       Optional PRNG seed                      .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      </artwork>
    </figure>
    
<t>
In particular:
<list style="symbols">
	<t>The HEL (Header Extension Length) indicates whether the optional
	PRNG seed is present (HEL=5) or not (HEL=4).</t>
	<t>The Transfer-Length (L) field size (48 bits) is larger than the
	size required to store the maximum transfer length
	(<xref target="common_elements"/>) for field alignment purposes.</t>
	<t>The Maximum-Source-Block-Length (B) field (20 bits)
	is split into two parts:
	the 8 most significant bits (MSB) are in the third 32-bit
	word of the EXT_FTI, and the remaining 12 least significant
	bits (LSB) are in the fourth 32-bit word.</t>
</list>
</t>

        </section>

        <section title="Using the FDT Instance (FLUTE specific)">
        <!-- =========================-->

<t>When it is desired that the FEC OTI be carried in the FDT Instance
of a FLUTE session <xref target="draft-ietf-rmt-flute-revised"/>,
the following XML attributes must be described for the associated object:
<list style="symbols">
	<t>FEC-OTI-FEC-Encoding-ID</t>
	<t>FEC-OTI-Transfer-length</t>
	<t>FEC-OTI-Encoding-Symbol-Length</t>
	<t>FEC-OTI-Maximum-Source-Block-Length</t>
	<t>FEC-OTI-Max-Number-of-Encoding-Symbols</t>
	<t>FEC-OTI-Scheme-Specific-Info</t>
</list>
The FEC-OTI-Scheme-Specific-Info contains the string resulting from
the Base64 encoding (in the XML Schema xs:base64Binary sense) of the
following value:
</t>

<figure anchor="fig_scheme_specific"
	title="FEC OTI Scheme Specific Information to be Included in the FDT Instance
	for FEC Encoding ID 3 and 4."> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        PRNG seed                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       G       |
+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
When no PRNG seed is to be carried in the FEC OTI, the seed field
MUST be set to 0 (which is not a valid seed value).
Otherwise the seed field contains a valid value as explained in
<xref target="scheme_specific_elt"/>.
</t>

<t>
After Base64 encoding, the 5 bytes of the FEC OTI Scheme Specific Information
are transformed into a string of 8 printable characters (in the 64-character
alphabet) and added to the FEC-OTI-Scheme-Specific-Info attribute.
</t>

        </section>

    </section>

  </section>

</section>


<section title="Procedures" anchor="procedures">
<!-- =================== -->

<t>This section defines procedures that are common to FEC Encoding IDs
3 and 4.</t>

  <section title="General" anchor="general">
  <!-- ================ -->

<t>
The B (maximum source block length in symbols) and
E (encoding symbol length in bytes) parameters are first determined,
as explained in the following sections.
</t>

<t>
The source object is then partitioned using the
block partitioning algorithm specified in <xref target="fec-bb-revised"/>.
To that purpose, the B, L (object transfer length in bytes), and E
arguments are provided.
As a result, the object is partitioned into N source blocks.
These blocks are numbered consecutively from 0 to N-1.
The first I source blocks consist of A_large source symbols, the
remaining N-I source blocks consist of A_small source symbols.
Each source symbol is E bytes in length, except perhaps the last
symbol which may be shorter.
</t>

<t>
For each block the actual number of encoding symbols is determined,
as explained in the following section.
</t>

<t>
Then, FEC encoding and decoding can be done block per block, independently.
To that purpose, a parity check matrix is created, that forms
a system of linear equations between the source and repair symbols of a
given block, where the basic operator is XOR.
</t>

<t>
This parity check matrix is logically divided into two parts:
the left side (from column 0 to k-1) which describes
the occurrence of each source symbol in the equation system;
and the right side (from column k to n-1) which describes
the occurrence of each repair symbol in the equation system.
An entry (a "1") in the matrix at position (i,j) (i.e.
at row i and column j) means that the symbol with ESI i
appears in equation j of the system.
The only difference between the LDPC-Staircase and LDPC-Triangle
schemes is the construction of the right sub-matrix.
</t>

<t>
When the parity symbols have been created, the sender will transmit
source and parity symbols.
The way this transmission occurs can largely impact the erasure recovery
capabilities of the LDPC-* FEC.
In particular, sending parity symbols in sequence is suboptimal.
Instead it is usually recommended the shuffle these symbols.
The interested reader will find more details in <xref target="Neumann05"/>.
</t>

<t>
The following sections detail how the B, E, and n parameters are determined
(respectively in <xref target="max_source_block_length"/>,
<xref target="encoding_symbol_length"/> and
<xref target="n-algorithm"/>),
how encoding symbol groups are created
(<xref target="encoding_symbol_group"/>),
and finally specify the PRNG
(<xref target="prng"/>).
</t>

</section>


  <section title="Determining the Maximum Source Block Length (B)"
           anchor="max_source_block_length">
  <!-- ================ -->

<t>
The B parameter (maximum source block length in symbols) depends
on several parameters:
the code rate (rate), the Encoding Symbol ID field length of the FEC
Payload ID (20 bits), as well as possible internal codec limitations.
</t>

<t>
The B parameter cannot be larger than the following values, derived
from the FEC Payload ID limitations, for a given code rate:
      <list style="empty">
	<t>max1_B = 2^^(20 - ceil(Log2(1/rate)))</t>
      </list>
</t>

<t>
Some common max1_B values are:
<list style="symbols">
	<t>rate == 1 (no repair symbol): max1_B = 2^^20 = 1,048,576</t>
	<t>1/2 &le; rate &lt; 1: max1_B = 2^^19 = 524,288 symbols</t>
	<t>1/4 &le; rate &lt; 1/2: max1_B = 2^^18 = 262,144 symbols</t>
	<t>1/8 &le; rate &lt; 1/4: max1_B = 2^^17 = 131,072 symbols</t>
</list>
</t>

<t>Additionally, a codec MAY impose other limitations on the maximum
block size. 
This is the case for instance when the codec uses internally 16 bit
unsigned integers to store the Encoding Symbol ID, since it does not enable to
store all the possible values of a 20 bit field.
In that case, if for instance 1/2 &le; rate &lt; 1, then the maximum source block
length is 2^^15.
Other limitations may also apply, for instance because of a limited working
memory size.
This decision MUST be clarified at implementation time, when the target
use case is known. This results in a max2_B limitation.</t>

<t>
Then, B is given by:
      <list style="empty">
	<t>B = min(max1_B, max2_B)</t>
      </list>
Note that this calculation is only required at the coder, since the
B parameter is communicated to the decoder through the FEC OTI.
</t>

  </section>


  <section title="Determining the Encoding Symbol Length (E) and Number of
Encoding Symbols per Group (G)"
           anchor="encoding_symbol_length">
  <!-- ================ -->


<t>
The E parameter usually depends on the maximum transmission unit on the
path (PMTU) from the source to the receivers.
In order to minimize the protocol header overhead
(e.g. the LCT/UDP/IPv4 or IPv6 headers in case of ALC), E is chosen as large
as possible.
In that case, E is chosen so that the size of a packet composed of a single
symbol (G=1) remains below but close to the PMTU.
</t>

<t>
However other considerations can exist.
For instance, the E parameter can be made a function of the object transfer
length.
Indeed, LDPC codes are known to offer better protection for large blocks.
In case of small objects, it can be advantageous to reduce the encoding
symbol length (E) in order to artificially increase the number of symbols,
and therefore the block size.
</t>

<t>
In order to minimize the protocol header overhead, several symbols can
be grouped in the same Encoding Symbol Group (i.e. G &gt; 1).
Depending on how many symbols are grouped (G) and on the packet loss rate
(G symbols are lost for each packet erasure), this strategy might or might
not be appropriate.
A balance must therefore be found.
</t>

<t>
The current specification does not mandate any value for either E or G.
The current specification only provides an example of possible choices for E and G.
Note that this choice is done by the sender.
Then the E and G parameters are communicated to the receivers thanks to
the FEC OTI.
</t>

<t>
Example:
</t>

<t>
First define the target packet payload size, pkt_sz (at most equal to the PMTU
minus the size of the various protocol headers).
The pkt_sz must be chosen in such a way that the symbol size is an
integer. This can require that pkt_sz be a multiple of 4, 8 or 16 (see the table below).
Then calculate the number of packets in the object: nb_pkts = ceil(L / pkt_sz).
Finally, thanks to nb_pkts, use the following table to find a possible G value.
</t>
<texttable>
	<preamble></preamble>
	<ttcol align='center'>Number of packets</ttcol>
	<ttcol align='center'>G</ttcol>
	<ttcol align='center'>Symbol size</ttcol>
	<ttcol align='center'>k</ttcol>
	<c>4000 &le; nb_pkts</c>
	<c>1</c>
	<c>pkt_sz</c>
	<c>4000 &le; k</c>

	<c>1000 &le; nb_pkts &lt; 4000</c>
	<c>4</c>
	<c>pkt_sz / 4</c>
	<c>4000 &le; k &lt; 16000</c>

	<c>500 &le; nb_pkts &lt; 1000</c>
	<c>8</c>
	<c>pkt_sz / 8</c>
	<c>4000 &le; k &lt; 8000</c>

	<c>1 &le; nb_pkts &lt; 500</c>
	<c>16</c>
	<c>pkt_sz / 16</c>
	<c>16 &le; k &lt; 8000</c>
</texttable>

  </section>


  <section title="Determining the Number of Encoding Symbols of a Block"
           anchor="n-algorithm">
  <!-- ================ -->

<t>The following algorithm, also called "n-algorithm", explains how to
determine the actual number of encoding symbols for a given block.</t>

<t> AT A SENDER: </t>

<t> Input:
<list style="empty">
<t>B:		Maximum source block length, for any source block.
		<xref target="max_source_block_length"/> explains how
		to determine its value.</t>

<t>k:		Current source block length. This parameter is given by the
		source blocking algorithm.</t>

<t>rate:	FEC code rate. It is provided by the user, for instance when
		starting a FLUTE sending application.
		It is expressed as a floating point value.
		The rate value must be such that the resulting number of
		encoding symbols per block is at most equal to 2^^20
		(<xref target="FPI"/>).
               	</t>
</list>
</t>

<t>
Output:
<list style="empty">

<t>max_n:	Maximum number of encoding symbols generated for any
		source block</t>

<t>n:		Number of encoding symbols generated for this source block</t>
</list>
</t>

<t>
      Algorithm:
      <list style="empty">
	<t>max_n = floor(B / rate);</t>
	<t>if (max_n &gt; 2^^20) then return an error ("invalid code rate");</t>
	<t>(NB: if B has been defined as explained in
		<xref target="max_source_block_length"/>, this
		error should never happen)</t>
	<t>n = floor(k * max_n / B);</t>
      </list>
</t>


<t>AT A RECEIVER: </t>

<t>Input:
<list style="empty">
<t>B:		Extracted from the received FEC OTI</t>
<t>max_n:	Extracted from the received FEC OTI</t>
<t>k:		Given by the source blocking algorithm</t>
</list>
</t>

<t>Output:
<list style="empty">
<t>n:		Number of encoding symbols generated for this source block</t>
</list>
</t>

<t>
      Algorithm:
      <list style="empty">
      <t>n = floor(k * max_n / B);</t> 
      </list>
</t>

  </section>


  <section title="Identifying the Symbols of an Encoding Symbol Group"
           anchor="encoding_symbol_group">
  <!-- ================ -->

<t>
When multiple encoding symbols are sent in the same packet, the
FEC Payload ID information of the packet MUST refer to the first
encoding symbol.
It MUST then be possible to identify each symbol from this single FEC Payload
ID. To that purpose, the symbols of an Encoding Symbol Group (i.e.
packet):
<list style="symbols">
<t>MUST all be either source symbols, or repair symbols.
	Therefore only source packets and repair packets are
	permitted, not mixed ones.</t>

<t>are identified by a function, sender(resp. receiver)_find_ESIs_of_group(),
	that takes as argument:
	<list style="symbols">
	<t> for a sender, the index of the Encoding Symbol Group
	(i.e. packet) that the application wants to create,</t>
	<t> for a receiver, the ESI information contained in the
	FEC Payload ID.</t>
	</list>
	and returns a list of G Encoding Symbol IDs.
	In case of a source packet, the G Encoding Symbol IDs are
	chosen consecutively, by incrementing the ESI.
	In case of a repair packet, the G repair symbols are
	chosen randomly, as explained below.</t>

<t>are stored in sequence in the packet, without any padding.
	In other words, the last byte of the i-th symbol
	is immediately followed by the first byte of (i+1)-th symbol.</t>
</list>
</t>

<t>
The system must first be initialized by creating a random permutation
of the n-k indexes.
This initialization function MUST be called immediately after creating
the parity check matrix.
More precisely, since the PRNG seed is not re-initialized, no call to
the PRNG function must have happened between the time the parity check
matrix has been initialized and the time the following initialization
function is called.
This is true both at a sender and at a receiver.

<figure>
<artwork>
int *txseqToID;
int *IDtoTxseq;

/*
 * Initialization function.
 * Warning: use only when G > 1.
 */
void
initialize_tables ()
{
    int i;
    int randInd;
    int backup;

    txseqToID = malloc((n-k) * sizeof(int));
    IDtoTxseq = malloc((n-k) * sizeof(int));
    /* initialize the two tables that map ID
     * (i.e. ESI-k) to/from TxSequence. */
    for (i = 0; i < n - k; i++) {
        IDtoTxseq[i] = i;
        txseqToID[i] = i;
    }
    /* now randomize everything */
    for (i = 0; i < n - k; i++) {
        randInd = rand(n - k);
        backup  = IDtoTxseq[i];
        IDtoTxseq[i] = IDtoTxseq[randInd];
        IDtoTxseq[randInd] = backup;
        txseqToID[IDtoTxseq[i]] =  i;
        txseqToID[IDtoTxseq[randInd]] = randInd;
    }
    return;
}
</artwork>
</figure>
</t>

<t>
It is then possible, at the sender, to determine the sequence of
G Encoding Symbol IDs that will be part of the group.

<figure>
<artwork>
/*
 * Determine the sequence of ESIs for the packet under construction
 * at a sender.
 * Warning: use only when G > 1.
 * PktIdx (IN):  index of the packet, in 
 *               {0..ceil(k/G)+ceil((n-k)/G)} range
 * ESIs[] (OUT): list of ESIs for the packet
 */
void
sender_find_ESIs_of_group (int      PktIdx,
                           ESI_t    ESIs[])
{
    int i;

    if (PktIdx < nbSourcePkts) {
        /* this is a source packet */
        ESIs[0] = PktIdx * G;
        for (i = 1; i < G; i++) {       
                ESIs[i] = (ESIs[0] + i) % k;
        }
    } else {
        /* this is a repair packet */
        for (i = 0; i < G; i++) {
            ESIs[i] =
                k +
                txseqToID[(i + (PktIdx - nbSourcePkts) * G)
                          % (n - k)];
        }
    }
    return;
}
</artwork>
</figure>
</t>

<t>
Similarly, upon receiving an Encoding Symbol Group (i.e. packet),
a receiver can determine the sequence of G Encoding Symbol IDs
from the first ESI, esi0, that is contained in the FEC Payload ID.

<figure>
<artwork>
/*
 * Determine the sequence of ESIs for the packet received.
 * Warning: use only when G > 1.
 * esi0 (IN):  : ESI contained in the FEC Payload ID
 * ESIs[] (OUT): list of ESIs for the packet
 */
void
receiver_find_ESIs_of_group (ESI_t    esi0,
                             ESI_t    ESIs[])
{
    int i;

    if (esi0 < k) {
        /* this is a source packet */
        ESIs[0] = esi0;
        for (i = 1; i < G; i++) {
            ESIs[i] = (esi0 + i) % k;
        }
    } else { 
        /* this is a repair packet */
        for (i = 0; i < G; i++) {
            ESIs[i] =
                k +
                txseqToID[(i + IDtoTxseq[esi0 - k])
                          % (n - k)];
        }
    }
}
</artwork>
</figure>
</t>

  </section>


  <section title="Pseudo Random Number Generator" anchor="prng">
  <!-- ======================================= -->

<t>
The present FEC Encoding ID relies on a pseudo-random number
generator (PRNG) that must be fully specified, in particular in order
to enable the receivers and the senders to build the same parity
check matrix.
The minimal standard generator <xref target="Park88"/> is used.
It defines a simple multiplicative congruential algorithm: Ij+1 = A * Ij
(modulo M), with the following choices: A = 7^^5 = 16807 and
M = 2^^31 - 1 = 2147483647.
Several implementations of this PRNG are known and discussed in
the literature. All of them provide the same sequence of pseudo
random numbers. A validation criteria of such a PRNG is the following:
if seed = 1, then the 10,000th value returned MUST be equal to 1043618065.
</t>

<t>
The following implementation uses the Park and Miller algorithm with the
optimization suggested by D. Carta in <xref target="Carta90"/>.

<figure>
<artwork>
unsigned long           seed;


/*
 * Initialize the PRNG with a seed between
 * 1 and 0x7FFFFFFE (i.e. 2^^31-2) inclusive.
 */
void srand (unsigned long s)
{
        if ((s > 0) && (s < 0x7FFFFFFF))
                seed = s;
        else
                exit(-1);
}

/*
 * Returns a random integer in [0; maxv-1]
 * Derived from rand31pmc, Robin Whittle,
 * September 20th, 2005.
 * http://www.firstpr.com.au/dsp/rand31/
 *      16807           multiplier constant (7^^5)
 *      0x7FFFFFFF      modulo constant (2^^31-1)
 * The inner PRNG produces a value between 1 and
 * 0x7FFFFFFE (2^^31-2) inclusive.
 * This value is then scaled between 0 and maxv-1
 * inclusive.
 */
unsigned long
rand (unsigned long maxv)
{
        unsigned long   hi, lo;

        lo = 16807 * (seed & 0xFFFF);
        hi = 16807 * (seed >> 16);  /* binary shift to right */
        lo += (hi & 0x7FFF) < < 16; /* binary shift to left */
        lo += hi >> 15;
        if (lo > 0x7FFFFFFF)
                lo -= 0x7FFFFFFF;
        seed = (long)lo;
        /* don't use modulo, least significant bits are less random
         * than most significant bits [Numerical Recipies in C] */
        return ((unsigned long)
                ((double)seed * (double)maxv / (double)0x7FFFFFFF));
}
</artwork>
</figure>
</t>

  </section>

</section>


<section title="Full Specification of the LDPC-Staircase Scheme" anchor="ldpc_staircase">
<!-- ======================================================== -->

<section title="General">
<!-- ==================================-->

<t>The LDPC-Staircase scheme is identified by the Fully-Specified FEC Encoding ID 3.
</t>

<t>
The PRNG used by the LDPC-Staircase scheme must be initialized by a seed.
This PRNG seed is an optional instance-specific FEC OTI attribute
(<xref target="scheme_specific_elt"/>).
When this PRNG seed is not carried within the FEC OTI, it is assumed that
encoder and decoders either use another way to communicate the seed value
or use a fixed, predefined value.
</t>
 
</section>

  <section title="Parity Check Matrix Creation" anchor="staircase_matrix">
  <!-- ==================================-->

<t>
The LDPC-Staircase matrix can be divided into two parts: 
the left side of the matrix defines in which equations the source symbols
are involved;
the right side of the matrix defines in which equations the repair symbols
are involved.
</t>

<t>
The left side is generated with the following algorithm:

<figure>
<artwork>
   /*
    * Derived from: "Software for Low Density Parity Check Codes"
    * Version of 2001-11-18, Radford M. Neal, Univ. of Toronto.
    * Copyright (c) 1995, 1996, 2000, 2001 by Radford M. Neal
    * http://www.cs.toronto.edu/~radford/ldpc.software.html
    */
   /* initialize a list of all possible choices in order to
    * guarantee a homogeneous "1" distribution */
   for (h = 3*k-1; h >= 0; h--) {
       u[h] = h % (n-k);
   }
   /* left limit within the list of possible choices, u[] */
   t = 0; 
   
   for (j = 0; j < k; j++) { /* for each source symbol column */
       for (h = 0; h < 3; h++) { /* add 3 "1s" */
           /* check that valid available choices remain */
           for (i = t; i < 3*k && matrix_has_entry(u[i], j); i++);
 
           if (i < 3*k) {
               /* choose one index within the list of possible
                * choices */
               do {
                   i = t + rand(3*k-t);
               } while (matrix_has_entry(u[i], j));
               matrix_insert_entry(u[i], j);

               /* replace with u[t] which has never been chosen */
               u[i] = u[t];
               t++;	        
           } else {		
               /* no choice left, choose one randomly */
               do {
                   i = rand(n-k);
               } while (matrix_has_entry(i, j));
               matrix_insert_entry(i, j);
           }
       }
   }

   /* Add extra bits to avoid rows with less than two "1s".
    * This is needed when the code rate is smaller than 2/5. */
   for (i = 0; i < n-k; i++) { /* for each row */
       if (degree_of_row(i) == 0) {
           j = rand(k);
           e = matrix_insert_entry(i, j);
       }
       if (degree_of_row(i) == 1) { 
           do { 
               j = rand(k); 
           } while (matrix_has_entry(i, j));
           matrix_insert_entry(i, j);
       }
   }
</artwork>
</figure>

The right side (the staircase) is generated by the following algorithm:

<figure>
<artwork>
   matrix_insert_entry(0, k);    /* first row */
   for (i = 1; i < n-k; i++) {   /* for the following rows */
       matrix_insert_entry(i, k+i);   /* identity */   
       matrix_insert_entry(i, k+i-1); /* staircase */ 
   }
</artwork>
</figure>
</t>

<t>
Note that just after creating this parity check matrix, when
encoding symbol groups are used (i.e. G &gt; 1), the
function initializing the two random permutation tables 
(<xref target="encoding_symbol_group"/>) MUST be called.
This is true both at a sender and at a receiver.
</t>

  </section>


  <section title="Encoding" anchor="encoding_staircase">
  <!-- ==================================-->

<t>
Thanks to the staircase matrix, repair symbol creation is straightforward:
each repair symbol is equal to the sum of all source symbols in the
associated equation, plus the previous repair symbol (except for the first repair symbol).
Therefore encoding MUST follow the natural repair symbol order:
start with the first repair symbol, and
generate repair symbol with ESI i before symbol ESI i+1.
</t>

   </section>

  <section title="Decoding" anchor="decoding_staircase">
  <!-- ==================================-->

<t>
Decoding basically consists in solving a system of n-k linear equations
whose variables are the n source and repair symbols.
Of course, the final goal is to recover the value of the k source symbols only.
</t>
<t>
To that purpose, many techniques are possible.
One of them is the following trivial algorithm <xref target="Zyablov74"/>:
given a set of linear equations, if one of them has only one
remaining unknown variable, then the value of this variable is
that of the constant term.
So, replace this variable by its value in all the remaining linear
equations and reiterate. The value of several variables can
therefore be found recursively.
Applied to LDPC FEC codes working over an erasure channel, the
parity check matrix defines a set of linear equations whose
variables are the source symbols and repair symbols.
Receiving or decoding a symbol is equivalent to having the
value of a variable.
<xref target="trivial_decoding"/> sketches a possible implementation
of this algorithm.
</t>

<t>
A Gaussian elimination (or any optimized derivative) is another
possible decoding technique. Hybrid solutions that start by using the
trivial algorithm above and finish with a Gaussian elimination are also
possible.
</t>

<t>
Because interoperability does not depend on the decoding algorithm used,
the current document does not recommend any particular technique.
This choice is left to the codec developer.
</t>

<t>
However choosing a decoding technique will have great practical impacts.
It will impact the erasure capabilities: a Gaussian elimination 
enables to solve the system with a smaller number of known symbols
compared to the trivial technique.
It will also impact the CPU load:
a Gaussian elimination requires more processing than the above trivial algorithm.
Depending on the target use case, the codec developer will
favor one feature or the other.
</t>

   </section>
   
</section>

<section title=" Full Specification of the LDPC-Triangle Scheme" anchor="ldpc_triangle">
<!-- ======================================================== -->


<section title="General">
<!-- ==================================-->
 
<t> LDPC-Triangle is identified by the Fully-Specified FEC Encoding ID 4.</t>

<t>
The PRNG used by the LDPC-Triangle scheme must be initialized by a seed.
This PRNG seed is an optional instance-specific FEC OTI attribute
(<xref target="scheme_specific_elt"/>).
When this PRNG seed is not carried within the FEC OTI, it is assumed that
encoder and decoders either use another way to communicate the seed value
or use a fixed, predefined value.
</t>

</section>


  <section title="Parity Check Matrix Creation">
  <!-- ==================================-->

<t>
The LDPC-Triangle matrix can be divided into two parts: 
the left side of the matrix defines in which equations the source symbols
are involved;
the right side of the matrix defines in which equations the repair symbols
are involved.
</t>

<t>
The left side is generated with the same algorithm as that of LDPC-Staircase
(<xref target="staircase_matrix"></xref>).
</t>

<t>
The right side (the triangle) is generated with the following algorithm:

<figure>
<artwork>
   matrix_insert_entry(0, k);    /* first row */
   for (i = 1; i < n-k; i++) {   /* for the following rows */
       matrix_insert_entry(i, k+i);   /* identity */   
       matrix_insert_entry(i, k+i-1); /* staircase */ 
       /* now fill the triangle */
       j = i-1;
       for (l = 0; l < j; l++) { /* limit the # of "1s" added */
           j = rand(j);
           matrix_insert_entry(i, k+j);
       }
   }
</artwork>
</figure>
</t>

<t>
Note that just after creating this parity check matrix, when
encoding symbol groups are used (i.e. G &gt; 1), the
function initializing the two random permutation tables 
(<xref target="encoding_symbol_group"/>) MUST be called.
This is true both at a sender and at a receiver.
</t>

  </section>


  <section title="Encoding" anchor="encoding_triangle">
  <!-- ==================================-->
<t>
Here also repair symbol creation is straightforward: each repair
symbol is equal to the sum of all source symbols in the associated equation, 
plus the repair symbols in the triangle.
Therefore encoding MUST follow the natural repair symbol order:
start with the first repair symbol, and
generate repair symbol with ESI i before symbol ESI i+1.
</t>

   </section>

     <section title="Decoding">
  <!-- ==================================-->

<t>
Decoding basically consists in solving a system of n-k linear equations,
whose variables are the n source and repair symbols.
Of course, the final goal is to recover the value of the k source symbols only.
To that purpose, many techniques are possible, as explained in
<xref target="decoding_staircase"/>.
</t>

<t>
Because interoperability does not depend on the decoding algorithm used,
the current document does not recommend any particular technique.
This choice is left to the codec implementer.
</t>

  </section>
 
</section>


<section title="Security Considerations">
<!-- ==================================== -->

<t>The security considerations for this document are the same as that
of <xref target="fec-bb-revised"/>.</t>
</section>

			<section anchor="iana-cons" title="IANA Considerations">
			<!-- =============================================== -->
<t>
Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA registration.
For general guidelines on IANA considerations as they
apply to this document, see <xref target="fec-bb-revised"/>.
This document assigns the Fully-Specified FEC Encoding ID 3 
under the ietf:rmt:fec:encoding name-space to "LDPC Staircase Codes", and
the Fully-Specified FEC Encoding ID 4
under the ietf:rmt:fec:encoding name-space to "LDPC Triangle Codes".
</t>

			</section>


<section title="Acknowledgments">
<!-- ==================================== -->
<t><xref target="n-algorithm"></xref> is derived from a previous Internet-Draft,
and we would like to thank S. Peltotalo and J. Peltotalo for their
contribution.
We would also like to thank Pascal Moniot, Laurent Fazio,
Aurelien Francillon and Shao Wenjian for their comments.</t>
</section>


    </middle>

    <back>

<references title="Normative References">
<!-- ==================================== -->


      <reference anchor="RFC2119">
	<front>
	  <title>Key words for use in RFCs to Indicate Requirement Levels</title>
	  <author initials="S." surname="Bradner">
	    <organization />
	  </author>
	  <date month="March" year="1997" />
	</front>
	<seriesInfo name="RFC" value="2119" />
	<seriesInfo name="BCP" value="14" />
      </reference>

<!--
      <reference anchor='RFC3452'>
        <front>
          <title>Forward Error Correction (FEC) Building Block</title>
          <author initials='M.' surname='Luby'>
            <organization />
          </author>
          <author initials='L.' surname='Vicisano'>
            <organization />
          </author>
          <author initials='J.' surname='Gemmell'>
            <organization />
          </author>
          <author initials='L.' surname='Rizzo'>
            <organization />
          </author>
          <author initials='M.' surname='Handley'>
            <organization />
          </author>
          <author initials='J.' surname='Crowcroft'>
            <organization />
          </author>
          <date month='December' year='2002' />
        </front>
        <seriesInfo name='RFC' value='3452' />
      </reference>
-->

      <reference anchor='fec-bb-revised'>
        <front>
          <title>Forward Error Correction (FEC) Building Block</title>
          <author initials='M.' surname='Watson'>
            <organization />
          </author>
          <author initials='M.' surname='Luby'>
            <organization />
          </author>
          <author initials='L.' surname='Vicisano'>
            <organization />
          </author>
          <date month='March' year='2007' />
        </front>
        <seriesInfo name='' value='draft-ietf-rmt-fec-bb-revised-06.txt (work in progress)' />
     </reference>

     <reference anchor="RFC3453">
        <front>
          <title>The Use of Forward Error Correction (FEC) in Reliable Multicast</title>
          <author initials="M." surname="Luby">
            <organization />
          </author>
          <author initials='L.' surname='Vicisano'>
            <organization />
          </author>
          <author initials='J.' surname='Gemmell'>
            <organization />
          </author>
          <author initials='L.' surname='Rizzo'>
            <organization />
          </author>
          <author initials='M.' surname='Handley'>
            <organization />
          </author>
          <author initials='J.' surname='Crowcroft'>
            <organization />
          </author>
          <date month="December" year="2002" />
        </front>
        <seriesInfo name="RFC" value="3453" />
     </reference>

</references>


<references title="Informative References">
<!-- ==================================== -->

      <reference anchor="Roca04">
        <front>
          <title>Design, Evaluation and Comparison of Four
		Large Block FEC Codecs: LDPC, LDGM, LDGM-Staircase and LDGM-Triangle, Plus
		a Reed-Solomon Small Block FEC Codec</title>
          <author initials="V." surname="Roca">
            <organization />
          </author>
          <author initials="C." surname="Neumann">
            <organization />
          </author>
 	  <date month="June" year="2004" />
	</front>
        <seriesInfo name="" value="INRIA Research Report RR-5225"/>
      </reference>

      <reference anchor="Neumann05">
        <front>
          <title>Impacts of Packet Scheduling and Packet Loss Distribution on FEC Performances: Observations and Recommendations</title>
          <author initials="C." surname="Neumann">
            <organization />
          </author>
          <author initials="V." surname="Roca">
            <organization />
          </author>
          <author initials="A." surname="Francillon">
            <organization />
          </author>
          <author initials="D." surname="Furodet">
            <organization />
          </author>
 	  <date month="October" year="2005" />
	</front>
        <seriesInfo name="" value="ACM CoNEXT'05 Conference, Toulouse, France
		(an extended version is available as INRIA Research Report RR-5578)"/>
      </reference>

      <reference anchor="LDPCrefimpl">
        <front>
          <title>LDPC-Staircase/LDPC-Triangle Codec Reference Implementation</title>
          <author initials="V." surname="Roca">
            <organization />
          </author>
          <author initials="C." surname="Neumann">
            <organization />
          </author>
          <author initials="J." surname="Laboure">
            <organization />
          </author>
          <date month="" year="" />
        </front>
        <seriesInfo name="" value="INRIA Rhone-Alpes and STMicroelectronics, http://planete-bcast.inrialpes.fr/" />
      </reference>

      <reference anchor="Mac03">
	<front>
	  <title>Information Theory, Inference and Learning Algorithms</title>
          <author initials="D." surname="MacKay">
            <organization />
          </author>
          <date month="" year="2003" />
        </front>
        <seriesInfo name="Cambridge University Press," value="ISBN: 0521642981" />
      </reference>

      <reference anchor="Park88">
	<front>
	  <title>Random Number Generators: Good Ones are Hard to Find</title>
          <author initials="S.K." surname="Park">
            <organization />
          </author>
          <author initials="K.W." surname="Miller">
            <organization />
          </author>
          <date month="" year="1988" />
        </front>
        <seriesInfo name="" value="Communications of the ACM, Vol. 31, No. 10, pp.1192-1201" />
      </reference>

      <reference anchor="Carta90">
	<front>
	  <title>Two Fast Implementations of the Minimal Standard Random Number Generator</title>
          <author initials="D.G." surname="Carta">
            <organization />
          </author>
          <date month="January" year="1990" />
        </front>
        <seriesInfo name="" value="Communications of the ACM, Vol. 33, No. 1, pp.87-88" />
      </reference>

      <reference anchor="Zyablov74">
	<front>
	  <title>Decoding Complexity of Low-Density Codes for Transmission in a Channel
                 with Erasures</title>
          <author initials="V.V." surname="Zyablov">
            <organization /></author>
          <author initials="M.S." surname="Pinsker">
            <organization /></author>
          <date month="January-March" year="1974" />
        </front>
        <seriesInfo name="" value="Translated from Problemy Peredachi Informatsii, Vol.10, No. 1, pp.15-28" />
      </reference>

			<reference anchor="draft-ietf-rmt-pi-alc-revised">
				<front>
					<title>Asynchronous Layered Coding (ALC) Protocol Instantiation</title>
					<author initials='M.' surname='Luby'>
						<organization />
					</author>
					<author initials="M." surname="Watson">
						<organization/>
					</author>
					<author initials='L.' surname='Vicisano'>
						<organization />
					</author>
					<date month="February" year="2007"/>
				</front>
				<seriesInfo name="" value="draft-ietf-rmt-pi-alc-revised-04.txt (work in progress)"/>
			</reference>

			<reference anchor="draft-ietf-rmt-flute-revised">
				<front>
					<title>FLUTE - File Delivery over Unidirectional Transport</title>
					<author initials='T.' surname='Paila'>
						<organization />
					</author>
					<author initials="R." surname="Walsh">
						<organization/>
					</author>
					<author initials='M.' surname='Luby'>
						<organization />
					</author>
					<author initials='R.' surname='Lehtonen'>
						<organization />
					</author>
					<author initials='V.' surname='Roca'>
						<organization />
					</author>
					<date month="January" year="2007"/>
				</front>
				<seriesInfo name="" value="draft-ietf-rmt-flute-revised-03.txt (work in progress)"/>
			</reference>

			<reference anchor="draft-ietf-rmt-pi-norm-revised">
				<front>
					<title>Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol</title>
					<author initials='B.' surname='Adamson'>
						<organization />
					</author>
					<author initials="C." surname="Bormann">
						<organization/>
					</author>
					<author initials='M.' surname='Handley'>
						<organization />
					</author>
					<author initials='J.' surname='Macker'>
						<organization />
					</author>
					<date month="March" year="2007"/>
				</front>
				<seriesInfo name="" value="draft-ietf-rmt-pi-norm-revised-04.txt (work in progress)"/>
			</reference>
</references>


<section title="Trivial Decoding Algorithm (Informative Only)" anchor="trivial_decoding">
<!-- =================================================== -->

<t>
A trivial decoding algorithm is sketched below (please see <xref target="LDPCrefimpl"/>
for the details omitted here):

<figure>
<artwork>
  Initialization: allocate a table partial_sum[n-k] of buffers, each
                  buffer being of size the symbol size. There's one
                  entry per equation since the buffers are meant to
                  store the partial sum of each equation; Reset all
                  the buffers to zero;

  /*
   * For each newly received or decoded symbol, try to make progress
   * in the decoding of the associated source block.
   * NB: in case of a symbol group (G>1), this function is called for
   * each symbol of the received packet.
   * NB: a callback function indicates to the caller that new symbol(s)
   *     has(have) been decoded.
   * new_esi  (IN):  ESI of the new symbol received or decoded
   * new_symb (IN):  Buffer of the new symbol received or decoded
   */
  void
  decoding_step(ESI_t     new_esi,
                symbol_t  *new_symb)
  {
      If (new_symb is an already decoded or received symbol) {
          Return;        /* don't waste time with this symbol */
      }

      If (new_symb is the last missing source symbol) {
          Remember that decoding is finished;
          Return;        /* work is over now... */
      }

      Create an empty list of equations having symbols decoded
      during this decoding step;

      /*
       * First add this new symbol to the partial sum of all the
       * equations where the symbol appears.
       */
      For (each equation eq in which new_symb is a variable and
           having more than one unknown variable) {

          Add new_symb to partial_sum[eq];

          Remove entry(eq, new_esi) from the H matrix;

          If (the new degree of equation eq == 1) {
              /* a new symbol can be decoded, remember the
               * equation */
              Append eq to the list of equations having symbols
              decoded during this decoding step;
          }
      }

      /*
       * Then finish with recursive calls to decoding_step() for each
       * newly decoded symbol.
       */
      For (each equation eq in the list of equations having symbols
           decoded during this decoding step) {

          /*
           * Because of the recursion below, we need to check that
           * decoding is not finished, and that the equation is
           * __still__ of degree 1
           */
          If (decoding is finished) {
              break;        /* exit from the loop */
          }

          If ((degree of equation eq == 1) {
              Let dec_esi be the ESI of the newly decoded symbol in
              equation eq;

              Remove entry(eq, dec_esi);

              Allocate a buffer, dec_symb, for this symbol and
              copy partial_sum[eq] to dec_symb;

              Inform the caller that a new symbol has been
              decoded via a callback function;

              /* finally, call this function recursively */
              decoding_step(dec_esi, dec_symb);
          }
      }

      Free the list of equations having symbols decoded;
      Return;
  }
</artwork>
</figure>
</t>


</section>



    </back>

</rfc>
