<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY RFC2617 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml">
<!ENTITY RFC2818 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml">
<!ENTITY RFC5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY RFC3492 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3492.xml">
<!ENTITY RFC3526 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3526.xml">
<!ENTITY RFC4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC3629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml">
<!ENTITY RFC5234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY RFC4346 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4346.xml">
<!ENTITY I-D.draft-altman-tls-channel-bindings SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-altman-tls-channel-bindings-03.xml">
<!ENTITY FIPS.180-2.2002 SYSTEM "http://xml.resource.org/public/rfc/bibxml2/reference.FIPS.180-2.2002.xml">
<!ENTITY ISO.10646-1.1993 SYSTEM "http://xml.resource.org/public/rfc/bibxml2/reference.ISO.10646-1.1993.xml">
<!ENTITY ITU.X690.1994 SYSTEM "http://xml.resource.org/public/rfc/bibxml2/reference.ITU.X690.1994">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->

<!-- Comment out this before submission - >
<?rfc private='Interim Draft $Rev: 126 $ draft-oiwa-http-mutualauth-03.0 (C) Yutaka Oiwa, et al.' ?>
<?rfc header='$Rev: 126 $' ?>
<?rfc footer='Interim Draft' ?>
<!-- -->

<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-oiwa-http-mutualauth-03" ipr="full3978">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
         full title is longer than 39 characters -->

    <title abbrev="Mutual Authentication Protocol for HTTP">Mutual Authentication Protocol for HTTP</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Yutaka Oiwa" initials="Y." surname="Oiwa">
      <organization abbrev="RCIS, AIST">National Institute of Advanced Industrial Science and Technology</organization>

      <address>
        <postal>
          <street>Research Center for Information Security</street>
          <street>Akihabara Daibiru #1102</street>
          <street>1-18-13 Sotokanda</street>
          <city>Chiyoda-ku</city><region>Tokyo</region>
          <country>JP</country>
        </postal>

        <phone>+81 3-5298-4722</phone>

        <email>mutual-auth-contact@m.aist.go.jp</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Hajime Watanabe" initials="H." surname="Watanabe">
      <organization abbrev="RCIS, AIST">National Institute of Advanced Industrial Science and Technology</organization>
    </author>

    <author fullname="Hiromitsu Takagi" initials="H." surname="Takagi">
      <organization abbrev="RCIS, AIST">National Institute of Advanced Industrial Science and Technology</organization>
    </author>

    <author fullname="Hirofumi Suzuki" initials="H." surname="Suzuki">
      <organization abbrev="Yahoo! Japan">Yahoo! Japan, Inc.</organization>
      <address>
        <postal>
          <street>Roppongi Hills Mori Tower</street>
          <street>6-10-1 Roppongi</street>
          <city>Minato-ku</city><region>Tokyo</region>
          <country>JP</country>
        </postal>
        <phone>+81 3-6440-6290</phone>
      </address>
    </author>

    <date year="2008" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
	 in the current day and month for you. If the year is not the current one, it is
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>HTTP, authentication</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>This document specifies the "Mutual authentication protocol for
Hyper-Text Transport Protocol".  This protocol provides true
mutual authentication between HTTP clients and servers using
simple password-based authentication.  Unlike Basic and Digest HTTP
access authentication protocol, the protocol ensures that server
knows the user's entity (encrypted password) upon successful
authentication.  This prevents common phishing attacks: phishing
attackers cannot convince users that the user has been authenticated to
the genuine website.  Furthermore, even when a user has been authenticated
against an illegitimate server, the server cannot gain any bit of
information about user's passwords. The protocol is designed
as an extension to the HTTP protocol, and the protocol design intends to replace
existing authentication mechanism such as Basic/Digest access authentications
and form-based authentications.
</t>
    </abstract>
  </front>

<middle>

<section title="Introduction">

     <t>This document specifies the "Mutual authentication protocol for
     Hyper-Text Transport Protocol".  This protocol provides true
     mutual authentication between HTTP clients and servers
     using simple password-based authentication.  Unlike <xref target="RFC2617">Basic and
     Digest HTTP access authentication protocol</xref>, the protocol ensures
     that server knows the user's entity (encrypted password)
     upon successful authentication.  This prevents common phishing
     attacks: phishing attackers cannot convince users that the user
     has been authenticated to the genuine website.  Furthermore, even
     when a user has been authenticated against an illegitimate server,
     the server cannot gain any bit of information about user's
     passwords.</t>

     <t>Recently, phishing attacks are getting more and more
     sophisticated.  Phishers not only steal user's password directly,
     but imitate successful authentication to steal user's sensitive
     information, check the password validity by forwarding the
     password to the legitimate server, or employ a man-in-the-middle
     attack to hijack user's login session.  Existing countermeasures
     such as one-time passwords cannot completely solve these
     problems.</t>

     <t>
     The protocol prevents such attacks by providing users a way to
     discriminate between true and fake web servers using their own
     passwords.  Even when a user inputs his/her password to a fake
     website, using this authentication method, any information about
     the password does not leak to the phisher, and the user certainly
     notices that the mutual authentication has failed.  Phishers
     cannot make such authentication attempt succeed, even if they
     forward received data from a user to the legitimate server or
     vice versa.  Users can safely input sensitive data to the web
     forms after confirming that the mutual authentication has
     succeeded.
     </t>

     <t>To achieve this goal, this protocol uses a mechanism in <xref target="ISO.11770-4.2006">ISO/IEC
        11770-4</xref>, a kind of PAKE (Password-Authenticated Key Exchange)
        authentication algorithms as a basis.  The use of PAKE
        mechanism allows users to use familiar ID/password based
        accesses, without fear of leaking any password information to
        the communication peer.  The protocol, as a whole, is designed
        as a natural extension to the <xref target="RFC2616">HTTP protocol</xref>.
     </t>
     <t>
        The design also considers to replace current form-based Web authentication,
        which is very vulnerable against phishing attacks.
        To this purpose, several extensions to <xref target="RFC2617">current
        HTTP authentication mechanism</xref> are introduced.
     </t>

  <section title="Requirements Language">

    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described
        in <xref target="RFC2119" />.</t>
  </section>
</section>

<section anchor="protocol-overview" title="Protocol Overview">

<t>The following sequence is a typical sequence for the first access to the resource.

<list style="symbols">
   <t>  If the server (S) has received a request for mutual-authentication
       protected resources from the Client (C) (which is not a req-A1
       nor a req-A3 message), it sends a 401-B0 message to C.
       <vspace blankLines="1" />
       When C has received a 401-B0 message, C SHOULD check validity of the message.
       If succeed, C processes the body of the message, and enables the password entry field.
   </t>
   <t>  If the user has input the username and password as a response to
       the 401-B0 message, C creates a value s_A, calculates
       the value w_A, and construct and send a req-A1 message.
   </t>

   <t>  If S has received an req-A1 message,
       S should check validity of w_A, record the received w_A value,
       and then look up the username from the
       user table. if the user is found, S prepares a
       new session id (sid), record it into a session table, and then
       construct s_B, calculate w_B, and then send an 401-B1 message.
       <vspace blankLines="1" />
       If there is no matching user found, the server SHOULD construct
       a fake w_B value, and let the protocol going on by sending an
       401-B1 message.
   </t>

   <t>  When C has received an 401-B1 message as a response for a req-A1 message,
       C should check validity of w_B, and compute z and o_A, and send
       an req-A3 message.
       <vspace blankLines="1" />
       If C receives any messages other than
       401-B1, C MUST NOT process the message body and treat
       it as a fatal communication error condition.  This case includes
       the reception of HTTP OK (200-status) message.
   </t>

   <t>  If S has received an req-A3 message, S should look up the
       received sid from the session table.  If no matching sid message
       is received, or if S has not received the corresponding req-A1
       message beforehand, S SHOULD send an 401-B0-stale message.
       <vspace blankLines="1" />
       Otherwise, S should computes o_A and check its value.
       If the validation has failed, the server SHOULD send an 401-B0
       message.
       <vspace blankLines="1" />
       If the validation has succeeded, the server SHOULD calculate
       o_B, and send a 200-B4 message.
   </t>

   <t> When C has received an 401-B0 message, it means the
       authentication has been failed, possibly due to that the wrong
       password has been given.  C MAY ignore the body of the 401-B0
       message in this case.
       <vspace blankLines="1" />
       When C has received an 200-B4 message,
       C MUST first compute the value of o_B and validate
       the value o_B sent from the server.
       If it has not verified successfully, C MUST ignore the
       body of the message, and treat it as a fatal communication error
       condition.  If it has succeed, C will process the body
       of the message.
       <vspace blankLines="1" />
       If C receives any messages other than 401-B0 or
       valid 200-B4, C MUST NOT process the message body and other headers and treat
       it as a fatal communication error condition.  This case includes
       the reception of usual HTTP OK (200-status) messages.
   </t>
   </list>
</t>

<t>
For the second or later request to the server, if the client knows that
the resource is likely to require the authentication, the client MAY
omit first unauthenticated request and send req-A1 message immediately.
In this case, the first (and only the first) response from the server MAY be a normal,
unauthenticated message, and client MAY accept such messages.
</t>
<t>
Furthermore, if client owns a valid session ID (sid), the client MAY
send a req-A3 message using existing sid.
In such cases, the server MAY have thrown out the corresponding sessions,
then the server SHOULD send a 401-B0-stale message as a response to
req-A3 message, and C SHOULD retry from constructing req-A1 message.
</t>
<t>
For more detail, see <xref target="cli-decision" />.
</t>

</section>

<section anchor="syntax" title="Message Syntax">

<t>
The Mutual authentication protocol uses four headers: WWW&nbhy;Authenticate
(in responses with status code 401), Optional&nbhy;WWW&nbhy;Authenticate (in
responses with positive status codes), Authorization (in requests),
and Authentication-info (in positive responses).  These three headers
share the common syntax described in <xref target="figure-syntax" />.
The syntax is denoted in the augmented BNF syntax defined in <xref target="RFC5234" />.
The syntax is a subset of the one described in <xref target="RFC2617" />.
</t>

<figure anchor="figure-syntax" title="the BNF syntax for the headers used in the protocol">
<artwork type="abnf">
 header           = header-name ":" [spaces] "Mutual" spaces fields
 header-name      = "WWW-Authenticate" / "Optional-WWW-Authenticate"
                  / "Authorization" / "Authentication-info"
 spaces           = 1*(" " / %x09 / %x0D.0A (" " / %x09))       ; LWSP
 fields           = field *([spaces] "," spaces field)
 field            = key "=" value
 key              = extensive-token
 extensive-token  = token / extension-token
 extension-token  = token "@" token
 token            = 1*(%x30-39 / %x41-5A / %x61-7A / "." / "-" / "_")
 value            = extensive-token / integer / hex-integer
                  / hex-fixed-number
                  / base64-fixed-number / string
 integer          = "0" / (%x31-39 *%x30-39)         ; no leading zeros
 hex-integer      = "0"
                  / ((%x31-39 / %x41-46 / %x61-66)   ; no leading zeros
                     *(%x30-39 / %x41-46 / %x61-66))
 hex-fixed-number = 1*(%x30-39 / %x41-46 / %x61-66)
 base64-fixed-number = string
 string           = %x22 *(%x20-21 / %x23-5B / %x5D-FF
                           / %x5C.22 / "\\" / "\,") %x22
</artwork>
</figure>

<section title="Tokens and Extensive-tokens">

<t>
The tokens MUST be interpreted case-insensitive, and SHOULD be sent
in the same case as shown in the specification.  When these are used
as (partial) inputs to any hash or other mathematical functions,
it MUST be used in lower-case.  All hex-fixed-number or
hex-integer numbers are also case-insensitive, and SHOULD be sent in
lower-case.
</t>

<t>
Extensive-tokens are used where the set of acceptable tokens are
extensible.  Any non-standard extensions of this protocol MUST use the
extension-tokens of format "&lt;token&gt;@&lt;domain-name&gt;", where domain-name is
the valid registered (sub-)domain name on the Internet owned by the
party who defines extensions.
</t>

</section>

<section title="Numbers" anchor="sec-numbers">

<t>
The syntax definitions of integer and
hex-integer only allow representations
which do not contain extra leading 0s.
</t>

<t>
The numbers represented as a hex-fixed-number MUST have even
characters (i.e. multiple of eight bits).  When these are generated
from cryptographic values, those SHOULD have the natural length:
if these are generated from a hash function, these lengths SHOULD
correspond to the hash size; if these are representing elements of a
mathematical group, its lengths SHOULD be the shortest which can
represent all elements in the group. See <xref target="other-values" />
for information about the length of the fields used in this specification.
Other values such as session-id
are represented in any (even) length determined by the side who
generates it first, and the same length SHALL be used throughout the
whole communications by both peers.
</t>

<t>
The numbers represented as a base64-fixed-number SHALL be generated as follows:
first, the number is converted to a big-endian octet-string
representation.  The length of the representation is determined in the
same way as above.  Then, the string is encoded by <xref target="RFC4648">the Base 64 encoding</xref>, and then
enclosed by two double-quotations.
</t>

</section>

<section title="Strings">

<t>
All strings outside ASCII or equivalent character sets SHOULD be
encoded using <xref target="RFC3629">UTF-8 encoding</xref>
of the <xref target="ISO.10646-1.1993">ISO 10646-1 character set</xref>.
Both peers SHOULD reject any invalid UTF-8 sequences which causes
decoding ambiguities (e.g. containing &lt;&quot;&gt; in the
second or later byte of the UTF-8 encoded characters).
To encode character strings, these will first be encoded according to UTF-8 without leading BOM, then
all occurrences of characters &lt;&quot;&gt; and
"\" will be escaped by prepending "\", and
two &lt;&quot;&gt;s will be put around the string.
If the contents of the strings are comma-separated values, the commas
in the values are also quoted by "\".
</t>

<t>
If strings are representing a domain name or URI which contains
non-ASCII characters, the host parts SHOULD be encoded
using puny-code defined in <xref target="RFC3492" /> instead of UTF-8, and SHOULD use lower-case ASCII characters.
</t>

<t>
For Base64-fixed-numbers, which use the string syntax, see the previous section.
</t>

</section>

</section>

<section title="Messages" anchor="messages">

<t>
In this section, formats and requirements of the headers for each
message are presented. The allowed type for values for each header
field is shown in parenthesis after the key names.  The type
"algorithm-determined" means that the acceptable value type for the
field is one of the types defined in <xref target="syntax" />, and
is determined by the value of the "algorithm" field.
</t>
<t>
Note: The term "optional" here means that omitting the field is
allowed and has specific meanings in communications (i.e.&nbsp;it is
not generally "OPTIONAL" defined in <xref target="RFC2119" />).
</t>

<section title="401-B0" anchor="401-B0">

<t>
Every 401-B0 message SHALL be a valid HTTP 401 (Authentication Required) message
containing one (and only one: hereafter not explicitly noticed)
"WWW&nbhy;Authenticate" header of the following format.
</t>

<t>
WWW-Authenticate: Mutual algorithm=xxxx, validation=xxxx,
                  realm="xxxx", stale=0
</t>

<t>
The header SHALL contain the fields with the following keys:

<list style="hanging" hangIndent="15">

<t hangText="algorithm:">(extensive-token) specifies the authentication algorithm to be used.
	    The value MUST be one of the tokens described in <xref target="algorithm" />,
	    or the tokens specified in other supplemental specification documentations.
 </t>
<t hangText="validation:">(extensive-token) specifies the method of host validation.
	    The value MUST be one of the tokens described in <xref target="validation" />,
	    or the tokens specified in other supplemental specification documentations.
 </t>
<t hangText="auth-domain:">(optional, string) specifies authentication domain,
            the set of hosts on which authentication credentials are valid.
            It MUST be one of the strings
            described in <xref target="authrealm" />.
            If the value is omitted, it is assumed to be the host part
	    of the requested URI.
</t>
<t hangText="realm:">(string) is a UTF-8 encoded string representing the name of the authentication
	    realm inside the authentication domain.
 </t>
<t hangText="pwd-hash:">(optional, extensive-token) specifies the hash algorithm
	    (referred to by ph) used for additionally hashing the password.
	    The valid tokens are

	    <list style="symbols" hangIndent="3">
	     <t> none: ph(p) = p</t>
	     <t> md5: ph(p) = MD5(p)</t>
	     <t> digest-md5: ph(p) = MD5(username | ":" | realm | ":" | p),
                the same value as MD5(A1) for "MD5" algorithm in <xref target="RFC2617" />.</t>
	     <t> sha1: ph(p) = SHA1(p)</t>
	    </list>
	    If omitted, the value "none" is assumed.
	    The use of "none" is recommended.
 </t>
<t hangText="stale:">(token) MUST be "0".
</t>
</list>
</t>

<t>
Any additional fields SHOULD NOT be contained in the header,
except those explicitly specified in supplement specifications of the "authentication algorithm".
</t>

<t>
The algorithm will determine the types and the values for w_A, w_B, o_A and o_B.
</t>

</section>

<section title="401-B0-stale">

<t>
A 401-B0-stale message is a variant of 401-B0 message, which means that
the client has sent a request message which is not for any active session.
</t>

<t>
WWW-Authenticate: Mutual algorithm=xxxx, validation=xxxx,
                  realm="xxxx", stale=1
</t>

<t>
The header MUST contain the same fields as in 401-B0, except that stale field holds the integer 1.
</t>

</section>

<section title="req-A1">

<t>
Every req-A1 message SHALL be a valid HTTP request message containing a
"Authorization" header of the following format.
</t>

<t>
Authorization: Mutual algorithm=xxxx, validation=xxxx,
               realm="xxxx", user="xxxx", wa=xxxx
</t>

<t>
The header SHALL contain the fields with the following keys:
</t>

<t>
<list style="hanging" hangIndent="15">

<t hangText="algorithm, validation, auth-domain, realm:">MUST be the same value as it is received from S.
 </t>
<t hangText="user:">(string) is the UTF-8 encoded name of the user.
 </t>
<t hangText="wa:">(algorithm-determined) is the value of w_A specified by the used algorithm.
</t>
</list>
</t>

</section>

<section title="401-B1">

<t>
Every 401-B1 message SHALL be a valid HTTP 401 (Authentication Required) message
containing a "WWW&nbhy;Authenticate" header of the following format.
</t>

<t>
WWW-Authenticate: Mutual algorithm=xxxx, validation=xxxx,
                  realm="xxxx", sid=xxxx,  wb=xxxx,
                  nc-max=x, nc-window=x, time=x, path="xxxx"
</t>

<t>
The header SHALL contain the fields with the following keys:
</t>

<t>
<list style="hanging" hangIndent="15">

<t hangText="algorithm, validation, auth-domain, realm:">MUST be the same value as it is received from C.
</t>
<t hangText="sid:">(hex-fixed-number) MUST be a session id, which is a random
	    integer.  The sid SHOULD have uniqueness of at least 80 bits or
	    the square of the maximal estimated transactions
	    concurrently available in the session table, whichever is
	    larger.  Sids are local to each authentication realm
	    concerned: the same sids for different authentication realms
	    SHOULD be treated as independent ones.
 </t>
<t hangText="wb:">(algorithm-determined) is the value of w_B specified by the algorithm.
 </t>
<t hangText="nc-max:">(hex-integer) is the maximal value of nonce counts which S accepts.
 </t>
<t hangText="nc-window:">(hex-integer) the number of available nonce slots which S will accept.
	    The value of nc-window is RECOMMENDED to be thirty-two ("20" in hex-integer) or more.
 </t>
<t hangText="time:">(integer) represents the suggested time (in
	    seconds) which C can reuse the session represented by sid. It is RECOMMENDED to be at
	    least 60. The value of this field is not directly linked to the
	    duration that S keeps track of the session represented by sid.
 </t>
<t hangText="path:">(optional, string) specifies for which path in the URI space the same
	    authentication is expected to apply.  The value is in the same format
	    as it is specified in <xref target="RFC2617" /> for the Digest authentications, and
	    clients are RECOMMENDED to recognize it.  The all path elements contained in the field MUST be
            inside the specified auth-domain: if not, client SHOULD ignore such elements.
</t>
</list>
</t>

</section>

<section title="req-A3">

<t>
Every req-A3 message SHALL be a valid HTTP request message containing a
"Authorization" header of the following format.
</t>

<t>
Authorization: Mutual algorithm=xxxx, validation=xxxx, realm="xxxx",
               sid=xxxx, nc=x, oa=xxxx
</t>

<t>
The fields contained in the header is as follows:

<list style="hanging" hangIndent="15">

<t hangText="algorithm, validation, auth-domain, realm:">MUST be the same value as it is received from S for the session.
 </t>
<t hangText="sid:">(hex-fixed-number) MUST be one of the  sid values which has been received from S.
 </t>
<t hangText="nc:">(hex-integer) is a nonce value which is unique among the requests sharing the same sid.
	    The value of nc SHOULD satisfy the following properties:
	    <list style="symbols" hangIndent="3">
	     <t> It is not larger than the nc-max value which has been
		 sent from S in the session represented by the sid.</t>
	     <t> C have not sent the same value in the same session.</t>
	     <t> It is not smaller than (largest-nc - nc-window),
		   where largest-nc is the maximal value of nc
		   which has previously been sent in the session,
		   and nc-window is the value of the nc-window field
		   which has been sent from S in the session.</t>
	    </list>
 </t>
<t hangText="oa:">(algorithm-determined) is the value of o_A specified by the algorithm.
</t>
</list>
</t>

</section>

<section title="200-B4">

<t>
Every 200-B1 message SHALL be a valid HTTP message
which is not 401 (Authentication Required) type,
containing an "Authentication-Info" header of the following format.
</t>

<t>
Authentication-Info: Mutual sid=xxxx, ob=xxxx
</t>

<t>
The fields contained in the header is as follows:
</t>

<t>
<list style="hanging" hangIndent="15">

<t hangText="sid:">(hex-fixed-number) MUST be the value received from C.
 </t>
<t hangText="ob:">(algorithm-determined) is the value of o_B specified by the algorithm.
 </t>
<t hangText="logout-timeout:">(optional, integer) is a number of seconds after which the
	    client should re-validate the user's password for the current authentication realm. As a special
	    case, the value 0 means that the client SHOULD automatically
	    forget the user-inputed password to the current
	    authentication realm and revert to the unauthenticated state (i.e.~server-initiated
	    logout).  This does not, however, mean that the long-term
	    memories for the passwords (such as password reminders and
	    auto fill-ins) should be removed.
	    If a new value of timeout is received for the same authentication realm,
	    it overrides the previous timeout.
</t>
</list>
</t>

</section>

</section>

<section title="Decision procedure for the client" anchor="cli-decision">

<t>
To securely implement the protocol, the user client must be careful
to accepting authenticated responses from the server.
</t>

<t>Clients SHOULD implement the decision procedure equivalent to the one shown below.
(Unless implementers understand what is required for the security, they should not alter this.)
The labels on the steps are for informational purpose only.

<list style="hanging" hangIndent="4">
  <t hangText="Step 1 (step_new_request):"><vspace blankLines="0" />
  If the client software needs to get a new Web resource, check
  whether the resource is expected to be inside some authentication realm for which the user
  has already authenticated.
  If yes, go to Step 2. Otherwise, go to Step 5.
  </t>

  <t hangText="Step 2:"><vspace blankLines="0" />
  Check whether there is an available sid for the authentication realm you expects.
  If there is one, go to Step 3. Otherwise, go to Step 4.
  </t>

  <t hangText="Step 3 (step_send_a3_1):"><vspace blankLines="0" />
  Send a req-A3 request.
  <list style="symbols" hangIndent="3">
   <t>If you receive a 401-B0 message with a different authentication realm than expected,
    go to Step 6.</t>
   <t>If you receive a 401-B0-stale message, go to Step 9.</t>
   <t>If you receive a 401-B0 message, go to Step 13.</t>
   <t>If you receive a valid 200-B4 message, go to Step 14.</t>
   <t>If you receive a normal response (without Mutual-specific headers), go to Step 11.</t>
  </list>
  </t>

  <t hangText="Step 4 (step_send_a1_1):"><vspace blankLines="0" />
  Send a req-A1 request.
  <list style="symbols" hangIndent="3">
   <t>If you receive a 401-B0 message with a different authentication realm than expected,
    go to Step 6.</t>
   <t>If you receive a 401-B1 message, go to Step 10.</t>
   <t>If you receive a normal response (without Mutual-specific headers), go to Step 11.</t>
  </list>
  </t>

  <t hangText="Step 5 (step_send_normal_1):"><vspace blankLines="0" />
  Send a request without any authentication headers.
  <list style="symbols" hangIndent="3">
   <t>If you receive a 401-B0 message, go to Step 6.</t>
   <t>If you receive a normal response (without Mutual-specific headers), go to Step 11.</t>
  </list>
  </t>

  <t hangText="Step 6 (step_rcvd_b0):"><vspace blankLines="0" />
  Check whether you know the user's password for the requested authentication realm.
  If yes, go to Step 7.  Otherwise, go to Step 12.</t>

  <t hangText="Step 7:"><vspace blankLines="0" />
  Check whether there is an available sid for the authentication realm you expects.
  If there is one, go to Step 8. Otherwise, go to Step 9.
  </t>

  <t hangText="Step 8 (step_send_a3):"><vspace blankLines="0" />
  Send a req-A3 request.
  <list style="symbols" hangIndent="3">
   <t>If you receive a 401-B0-stale message, go to Step 9.</t>
   <t>If you receive a 401-B0 message, go to Step 13.</t>
   <t>If you receive a valid 200-B4 message, go to Step 14.</t>
  </list>
  </t>

  <t hangText="Step 9 (step_send_a1):"><vspace blankLines="0" />
  Send a req-A1 request.
  <list style="symbols" hangIndent="3">
   <t>If you receive a 401-B1 message, go to Step 10.</t>
  </list>
  </t>

  <t hangText="Step 10 (step_rcvd_b1):"><vspace blankLines="0" />
  Send a req-A3 request.
  <list style="symbols" hangIndent="3">
   <t>If you receive a 401-B0 message, go to Step 13.</t>
   <t>If you receive a valid 200-B4 message, go to Step 14.</t>
  </list>
  </t>

  <t hangText="Step 11 (step_rcvd_normal):"><vspace blankLines="0" />
  This case means that the resource requested is out of the authenticated area.
  The client will be in "UNAUTHENTICATED" status.
  </t>

  <t hangText="Step 12 (step_rcvd_b0_unknown):"><vspace blankLines="0" />
  This case means that the resource requested requires Mutual
  authentication, and the user is not authenticated yet.  The client
  will be in "AUTH_REQUESTED" status, is RECOMMENDED to process the
  content sent from the server and ask user a username and password.
  If the user has input those, go to Step 9.
  </t>

  <t hangText="Step 13 (step_rcvd_b0_failed):"><vspace blankLines="0" />
  This case means that in some reason the authentication failed:
  possibly the password or the username is invalid for the authenticated
  resource.  Forget the password for the authentication realm and go to Step 12.
  </t>

  <t hangText="Step 14 (step_rcvd_b4):"><vspace blankLines="0" />
  This case means that the mutual authentication has been succeeded.
  The client will be in "AUTH_SUCCEEDED" status.
  </t>
</list>
</t>

<t>
All other kind of responses than shown in above procedure SHOULD be
interpreted as fatal communication error, and in such cases user
clients MUST NOT process any data (contents and other content-related headers) sent from the server.
</t>

<t>
The client software SHOULD show the three client status to the end-user.
</t>

<t>
<xref target="figure-client-dia" /> shows the full client-side state diagram.
</t>

<figure anchor="figure-client-dia" title="State diagram for clients"  src="mutual-client-dia.png" alt="">
<artwork><![CDATA[      ===========                                  -(11)------------
      NEW REQUEST                                 ( UNAUTHENTICATED )
      ===========                                  -----------------
           |                                               ^
           |                                               |normal
           v                                               |response
+(1)-------------------+ NO                         +(5)----------+
| The requested URI    |--------------------------->| send normal |
| known to be auth'ed? |                            |   request   |
+----------------------+                            +-------------+
           |YES             401-B0, 200-Opt-B0             |401-B0
           |                  with different realm         |200-Opt-B0
           |          -----------------------------------. |
           |         /                                   v v
           |        |       -(12)------------    NO  +(6)--------+
           |        |      ( AUTH_REQUESTED  )<------| user/pass |
           |        |       -----------------        |   known?  |
           |        |                                +-----------+
           |        |                                      |YES
           v        |                                      v
     +(2)--------+  |                                +(7)--------+
     | session   |  |                                | session   | NO
 NO /| available?|  |                                | available?|\
   / +-----------+  |                                +-----------+ |
  /        |YES     |                                      |YES    |
 |         |       /|                                      |       |
 |         v      / |   401-                               v       |
 |   +(3)--------+  |   B0  --(13)----------  401-B0 +(8)--------+ |
 |   |   send    |--+----->/ AUTH_REQUESTED \<-------|   send    | |
 |  /|  req-A3   |  |      \forget user/pass/        |  req-A3   | |
  \/ +-----------+ /        ----------------        /+-----------+ |
  /\           \ \/                 ^ 401-B0       |      |401-B0- |
 |  -------.    \/\  401-B0-stale   |              |      |stale  /
 |         |    /\ -----------------+--------------+----. |      /
 |         v   /  \                 |              |    v v     v
 |   +(4)--------+ |   401-B1 +(10)-------+ 401-B1 | +(9)--------+
 |   |   send    |-|--------->|   send    |<-------+-|   send    |
 | --|  req-A1   | |          |  req-A3   |        | |  req-A1   |
 |/  +-----------+ |          +-----------+        | +-----------+
 |                 |200-B4          |        200-B4|       ^
 |normal           |                |200-B4       /        |
 |response         |                v            / =================
 v                  \         -(14)---------    /  USER/PASS INPUTED
 -(11)------------   ------->( AUTH-SUCCEED )<--   =================
( UNAUTHENTICATED )           --------------
 -----------------]]>
</artwork>
</figure>

</section>

<section title="Decision procedure for the server" anchor="srv-decision">

<t>
Servers SHOULD respond to the client requests according to the following procedure:

<list style="symbols">
  <t>When the server receives a normal request:
     <list style="symbols">
       <t>If the requested resource is not protected by Mutual Authentication,
          send a normal response.</t>
       <t>If the resource is protected by Mutual Authentication,
          send a 401-B0 response.</t>
       <t>If the resource is protected by Mutual Authentication with Optional Mutual Authentication extension (<xref target="opt-mutual-auth" />), send a 200-Optional-B0 response.</t>
     </list>
  </t>
  <t>When the server receives a req-A1 request:
     <list style="symbols">
       <t>If the requested resource is not protected by Mutual Authentication,
          send a normal response.</t>
       <t>If the authentication realm specified in the req-A1 request is
          non-expected one, send a 401-B0 (or 200-Optional-B0) response.</t>
       <t>If the server cannot validate field wa, send a 401-B0 response.</t>
       <t>If the received user name is invalid, send a fake 401-B1 response.</t>
       <t>Otherwise, send a 401-B1 response.</t>
     </list>
  </t>
  <t>When the server receives a req-A3 request:
     <list style="symbols">
       <t>If the requested resource is not protected by Mutual Authentication,
          send a normal response.</t>
       <t>If the authentication realm specified in the req-A3 request is
          non-expected one, send a 401-B0 (or 200-Optional-B0) response.</t>
       <t>If the received sid is invalid, inactive or unknown, send a 
          401-B0-stale response.</t>
       <t>If the receive oa is invalid, send a 401-B0 response.</t>
       <t>If the receive oa is correct, send a 200-B4 response.</t>
     </list>
  </t>
</list>
</t>

</section>

<section title="Authentication Algorithms" anchor="algorithm">

<t>
This document specifies only one family of the authentication
algorithm.  The family consists of four authentication algorithms, which
only differ in underlying mathematical groups and security parameters.
The algorithms do not add any additional fields.  The tokens for
algorithms are
<list style="symbols">
 <t> "iso11770-4-ec-p256" for the 256-bit prime-field elliptic-curve setting.</t>
 <t> "iso11770-4-ec-p521" for the 521-bit prime-field elliptic-curve setting.</t>
 <t> "iso11770-4-dl-2048" for the 2048-bit discrete-logarithm setting.</t>
 <t> "iso11770-4-dl-4096" for the 4096-bit discrete-logarithm setting.</t>
</list>
</t>

<t>
For the elliptic-curve settings, the underlying fields and the curves used
for elliptic-curve cryptography are the prime field and the Curve P-256
and P-521, respectively, specified in the appendix of <xref target="FIPS.186-2.2000">FIPS PUB 186-2</xref>
specification.  The hash functions H are SHA-256 for P-256 curve and
SHA-512 for P-521 curve, respectively, defined in <xref target="FIPS.180-2.2002">FIPS PUB 180-2</xref>.
The representation of fields wa, wb, oa, and ob is hex-fixed-number.
</t>

<t>
For discrete-logarithm settings, the underlying groups are 2048-bit
and 4096-bit MODP groups defined in <xref target="RFC3526" /> respectively.
See <xref target="modp-groups" /> for the exact specification of the group
and associated parameters.
The hash functions H are SHA-256 for the
2048-bit field and SHA-512 for the 4096-bit field, respectively.
The representation of fields wa, wb, oa, and ob is base64-fixed-number.
</t>

<t>
The clients SHOULD support at least "iso11770-4-dl-2048"
algorithm, and are advised to support all of the above four algorithms whenever possible.
The server software implementations SHOULD support at least "iso11770-4-dl-2048"
algorithm, unless it is known that users will not use it.
</t>

<t>
This algorithm uses Key Agreement Mechanism 3 (KAM3) defined in Section 6.3 of <xref target="ISO.11770-4.2006">ISO/IEC-11770-4</xref> as a basis.
</t>

<section title="Common functions">

<t>
The password-based string pi used by this authentication is derived in the
following manner:
</t>

<t>
 pi = H(VS(algorithm) | VS(auth-domain) | VS(realm) | VS(username) | VS(ph(password)).
</t>

<t>
The values of algorithm, realm and auth-domain are taken from the values contained
in the 401-B0 message.
When pi is used in the context of an octet string, it SHALL have
the natural length derived from the size of the output of function
H (e.g. 32 octets for SHA-256).  The function ph is defined by
the value of the pwd-hash field given in a 401-B0 message.
</t>

<t>The function VI encodes natural numbers into octet strings in the following manner:
integers are represented in
big-endian radix-128 string, where each digit is represented by a octet
0x80&ndash;0xff except the last digit represented by 0x00&ndash;0x7f.
The first octet MUST NOT be 0x80.
For example, VI(i) = octet(i) for i < 128,
and VI(i) = octet(0x80 | (i &gt;&gt; 7)) | octet(i &amp; 127) for 128 &lt;= i < 16384.
This encoding is the same as the one used in the length field in <xref target="ITU.X690.1994">the ASN.1 encoding</xref>.
</t>

<t>
The function VS encodes variable-length octet string into decodable
octet string, as in the following manner:
</t>

<t>
 VS(s) = VI(length(s)) | s
</t>

<t>
where length(s) is a number of octets (not characters) in s.
</t>

<t>The function OCTETS converts an integer to corresponding radix-256
big-endian octet string having its natural length:
See <xref target="sec-numbers" /> for the definition of the "natural length".
Note that this is different from the function
GE2OS_x in <xref target="ISO.11770-4.2006" />, which takes
the shortest representation.</t>

<t>
The equations for J, w_A, T, z, and w_B are specified differently
for the discrete-logarithm setting and the elliptic-curve setting
based on <xref target="ISO.11770-4.2006" />. These equations are
defined later in this section.
</t>

<t>
The values o_A and o_B are derived by the following equation.
Note that these equations are different from ones specified in <xref target="ISO.11770-4.2006" />.
</t>

<t>
 o_A = H(octet(04) | OCTETS(w_A) | OCTETS(w_B) | OCTETS(z) | VI(nc) | VS(v))
<vspace blankLines="1" />
 o_B = H(octet(03) | OCTETS(w_A) | OCTETS(w_B) | OCTETS(z) | VI(nc) | VS(v))
</t>

</section>

<section title="Functions for discrete-logarithm settings">

<t>
In this section, the equation (x / y mod z) denotes an natural number w less than z which satisfies
(w * y) mod z = x mod z.
</t>

<t>
For the discrete-logarithm, we refer some of the domain parameters
by the following symbols:

<list style="symbols">
<t>q: for "the prime" of the group.</t>
<t>g: for "the generator" associated with the group.</t>
<t>r: for the order of the subgroup generated by g.</t>
</list>
</t>

<t>
The function J is defined as
</t>

<t>
J(pi) = g^(pi) mod q,
</t>

<t>
where g and q are domain parameters of the underlying field.
</t>

<t>
The value of w_A is derived as 
</t>

<t>
w_A = g^(s_A) mod q,
</t>

<t>
where s_A is a random integer within range [1, r-1]
and r is the size of the subgroup generated by g.
In addition, s_A MUST be larger than log(q)/log(g) 
(so that g^(s_A) > q).
</t>

<t>
The value of w_A SHALL satisfy 1 < w_A < q-1.
The server MUST check this condition upon reception.
</t>

<t>
The value of w_B is derived from J(pi) and w_A as:
</t>

<t>
w_B = (J(pi) * w_A^(H(octet(1) | OCTETS(w_A))))^s_B mod q,
</t>

<t>
where s_B is a random number within range [1, r-1].
The value of w_B MUST satisfy 1 < w_B < q-1.
If this condition is not hold, the server MUST retry
with another value of s_B.
The client MUST check this condition upon reception.
</t>

<t>
The value z in the client side is derived by the following equation:
</t>

<t>
z = w_B^((s_A + H(octet(2) | OCTETS(w_A) | OCTETS(w_B))) / (s_A * H(octet(1) | w_A) + pi) mod r) mod q.
</t>

<t>
The value z in the server side is derived by the following equation:
</t>

<t>
z = (w_A * g^(H(octet(2) | OCTETS(w_A) | OCTETS(w_B))))^s_B mod q.
</t>

</section>

<section title="Functions for elliptic-curve settings">

</section>

<t>
For the elliptic-curve setting, we refer some of the domain parameters
by the following symbols:

<list style="symbols">
<t>q: for the prime used to define the field,</t>
<t>G: for the defined point called the generator,</t>
<t>r: for the order of the subfield generated by G.</t>
</list>
</t>

<t>
The function P(p) converts a curve point p to an integer representing the point p,
by computing x * 2 + (y mod 2), where (x, y) are the coordinates of the point p.
P'(z) is the inverse of function P, that is, it converts an integer z
to a point p which satisfies P(p) = z.  If such p is exist, it is
uniquely defined.  Otherwise, z does not represent a valid curve point.
The operation [x] * p denotes an integer-multiplication of point p:
it calculates p + p + ... (x times) ... + p.
See literatures on elliptic-curve cryptography for the exact algorithms for those.
0_E represents the infinity point.
The equation (x / y mod z) denotes an natural number w less than z which satisfies
(w * y) mod z = x mod z.
</t>

<t>
the function J is defined as
</t>

<t>
J(pi) = [pi] * G.
</t>

<t>
The value of w_A is derived as 
</t>

<t>
w_A = P(W_A), where W_A = [s_A] x G.
</t>

<t>
where s_A is a random number within range [1, r-1].
The value of w_A MUST represent a valid curve point, and
W_A SHALL NOT be 0_E.  The
server MUST check this condition upon reception.
</t>

<t>
The value of w_B is derived from J(pi) and W_A = P'(w_A) as:
</t>

<t>
w_B = P(W_B), where W_B = [s_B] * (J(pi) + [H(octet(1) | OCTETS(w_A))] * W_A).
</t>

<t>
where s_B is a random number within range [1, r-1].
The value of w_B MUST represent a valid curve point and 
satisfy [4] * P'(w_B) <> 0_E.
If this condition is not hold, the server MUST retry
with another value of s_B.
The client MUST check this condition upon reception.
</t>

<t>
The value z in the client side is derived by the following equation:
</t>

<t>
z = P([(s_A + H(octet(2) | OCTETS(w_A) | OCTETS(w_B))) / (s_A * H(octet(1) | OCTETS(w_A)) + pi) mod r] * W_B), where W_B = P'(w_B).
</t>

<t>
The value z in the server side is derived by the following equation:
</t>

<t>
z = P([s_B] * (W_A + [H(octet(2) | OCTETS(w_A) | OCTETS(w_B))] * G)), where W_A = P'(w_A).
</t>

</section>

<section title="Authentication Realms" anchor="authrealm">

<t>
In this protocol, "authentication realm" is defined as the set of resources (URIs)
for which the same set of user names and passwords is valid for.
If the server requests authentication for the authentication realm 
which the client is already authenticated, the client will automatically
perform authentication  using the already-known secrets.
On the contrary, for the different authentication realms, clients SHOULD NOT 
automatically reuse the usernames and passwords for another realm.
</t>

<t>
Just like Basic and Digest access authentication protocol, Mutual
authentication protocol supports multiple, separate authentication
realms to be set up inside each hosts.  Furthermore, the protocol supports
that a single authentication realm spans over several hosts in the same
Internet domain.
</t>

<t>
Each authentication realm is defined and distinguished by the triple of an "authentication algorithm",
an "authentication domain", a "realm" parameter.  Server operators are
NOT RECOMMENDED to use the same pair of an authentication domain and a
realm for different authentication algorithms, however.
</t>

<t>
Authentication algorithms are defined in <xref target="messages" /> and <xref target="algorithm" />.
Realm parameters are just a string, as defined in <xref target="messages" />.
Authentication domains are described in the rest of this section.
</t>

<t>
An authentication domain specifies the range of hosts which the authentication realm spans over.
In the protocol, it MUST currently be one of the following strings.

<list style="symbols" hangIndent="3">
  <t>the string in format 
     "&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;", where scheme, host and
     port are the URI parts of the requested URI.
     Even if the request-URI does not have a port part, the
     string will include the one (i.e. 80 for http and 443 for https).
     Use this when authentication is only valid for specific protocol (such as https).
  </t>
  <t>The "host" part of the requested URI. This is the default value.
     Authentication realms in this kind of authentication domain will span over
     several protocols (i.e. http and https) and ports, but not over different hosts.
  </t>
  <t>String in format "*.&lt;domain-postfix&gt;", where "domain-postfix" is
     either the host part of the requested URI, or any domain in which
     the requested host is included (this means that the specification "*.example.com" is
     valid for all of hosts "www.example.com", "web.example.com" and "example.com").
     The domain-postfix must be equal to or included in a valid Internet domain assigned to
     specific organization: if the clients can know by some way (such as blacklists for HTTP cookies)
     that the specified domain is not to be assigned to any specific organization
     (e.g. "*.com" or "*.jp"), the client is RECOMMENDED to reject the authentication request.
  </t>
</list>
</t>

<t>
In the above specifications, every "scheme", "host" and "domain" MUST in lower-case.
and IDNs MUST be represented in <xref target="RFC3492">puny-code</xref>.
All "port"s MUST be in the shortest, unsigned, decimal number notation.
Not obeying these requirements will cause failure of authentication attempts.
</t>

<section title="Resolving ambiguities">
<t>
In the above definition of authentication domains, several domains will overwrap each other.
Depending on the "path" parameters given in the "401-B1" message (see <xref target="messages" />),
There may be several candidate when the client is to send a request with authentication 
credentials included (at the Steps 3 and 4 of the decision procedure shown in <xref target="cli-decision" />).
</t>

<t>
If such choices are required, the following procedure SHOULD be followed.
<list style="symbols" hangIndent="3">
  <t> If the client has previously sent a request to the same URI, and
      it remembers the authentication realm requested by 401-B0 messages at that time,
      use that realm.
  </t>
  <t>
      In other cases, use one of authentication realms which specific
      most-specific authentication domains.
      In the list of possible domain specifications shown above,
      one described earlier has priority over ones described after that.
      <vspace blankLines="1" />
      If there are several choices with different domain-postfix specifications,
      the ones which has longer domain possible has priority over ones with
      shorter domain-postfix.
  </t>
  <t>
      If there are realms with the same specifications of authentication domain,
      there is not defined priority: client can choose any one of possible choices.
  </t>
</list>
If possible, server operators are recommended to avoid such ambiguities by setting
"path" parameters properly.
</t>
</section>

</section>

<section title="Validation Methods" anchor="validation">

<t>
The "validation method" specifies a method to "relate" the mutual
authentication processed by this protocol with other authentications
already performed in the underlying layers and to prevent man-in-the-middle attacks.
It decides the value of v which is an input to authentication protocols.
</t>

<t>
The valid tokens for the validation field and corresponding values of v
are as follows:
</t>

<t>
<list style="hanging" hangIndent="15">
 <t hangText="host:"> hostname validation: v will be the ASCII string in the
       following format: "scheme://host:port", where scheme, host and port 
       are the URI parts correspond to the currently accessing resource.
       The scheme and host are lower-case, and the port is in a shortest
       decimal representation.  Even if the request-URI does not have a
       port part, v will include the one.</t>
 <t hangText="tls-cert:"> TLS certificate validation: v will be the octet string of
       the hash value of the public key certificate used in underlying
       <xref target="RFC4346">TLS</xref> (or SSL) connection.
       The hash value is defined as the value of the whole signed certificate
       (specified as "Certificate" in <xref target="RFC5280" />),
       hashed by the hash algorithm specified by the authentication algorithm used.
 </t>
 <t hangText="tls-key:"> TLS shared-key validation: v will be the octet string of
       the shared master secret negotiated in underlying TLS (or SSL) connection.</t>
</list>
</t>

<t>
If the HTTP protocol is used on unencrypted channel, the validation type
MUST be "host".  If <xref target="RFC2818">HTTP/TLS</xref> (https) protocol is
used with server certificates, the validation type MUST be either "tls-cert" or
"tls-key".  If HTTP/TLS protocol is used with anonymous
Diffie-Hellman key exchange, the validation type MUST be
"tls-key" (but see the note below).
</t>

<t>
The client MUST validate this field upon reception of 401-B0 messages.
</t>

<t>
However, when the protocol is used on web browsers with any scripting
capabilities, the anonymous Diffie-Hellman family of TLS (or SSL) cipher-suite
MUST NOT be used even if "tls-key" validated Mutual
authentication has been employed, and the certificate shown in TLS (or SSL)
negotiation MUST be verified using PKI. For other systems, if the
"tls-key" validation is used on TLS (or SSL) protocol without
certificate verification using PKI, those systems MUST ensure that all
transactions with authenticated peer servers MUST use and be validated by
the Mutual authentication protocol, regardless of the existence of the
401-B0 responses.
</t>

<t>
The protocol defines two variants for validation on TLS connections.
The method "tls-key" method is the more secure, so it is recommended
to use tls-key when applicable.  However, there are some situations
where tls-cert is more preferable.
<list style="symbols">
<t>When TLS accelerating proxies are used.  In this case, it is
difficult for the authenticating server to acquire the TLS key
information which are used between the client and the proxy.
It is not the case for client-side "tunneling" proxies using
CONNECT method extension of HTTP.
</t>
<t>When a black-box implementation of the TLS protocol is used on
either peer.
</t>
</list>
</t>

</section>

<section title="Session Management" anchor="session">

<t>
By the first 4 messages (first request, 401-B0, req-A1 and 401-B1), a
session represented by a sid is generated.  This session can be used
for 1 or more requests for resources protected by the same realm in the
same server. Note that the session management is only an inside detail of the
protocol and usually not visible to normal users.  If a session expires,
the client and server will automatically reestablish another session
without telling it to the users.
</t>

<t>
The server SHOULD accept at least one req-A3 request for each session,
given that the request reaches the server in a time window specified
by the timeout field in the 401-B1 message, and that there are
no emergent reasons (such as flooding attacks) to forget the sessions.
After that, the server MAY discard any session at any time and MAY send
401-B0-stale messages for any req-A3 requests.
</t>

<t>
The client MAY send more than one requests using a single session
specified by the sid.  However, for all such requests, the values of the
nonce-counter (nc field) MUST be different from each other.  The server
MUST check for duplication of the received nonces, and if any
duplication is detected, the server MUST discard the session and respond
by a 401-B0-stale message.
</t>

<t>
In addition, for each sessions, if the client has already sent a request
with nonce value x, it SHOULD NOT send requests with a nonce value not
larger than (x - nc-window). The server MAY reject
any requests with nonces violating this rule with 401-B0-stale responses.
This restriction enables servers to implement duplicated nonce detection
in a constant memory.
</t>

<t>
Values of nonces and nonce-related values MUST always be treated as
natural numbers within infinite range.  Implementations using fixed-width
integers or fixed-precision floating numbers MUST handle integer
overflow correctly and carefully.  Such implementations are RECOMMENDED
to accept any larger values which cannot be represented in
the fixed-width integer representations, as long as other limits such as
internal header-length restrictions are not involved.
The protocol is designed carefully so that both clients and servers
can implement the protocol only with
fixed-width integers, by rounding any
overflowed values to the maximum possible value.
</t>

</section>

<section title="Extension 1: Optional Mutual Authentication" anchor="opt-mutual-auth">

<t>
In several Web applications, users can access the same contents both as
a guest user and as a authenticated users.  In usual Web applications,
it is implemented using Cookies and custom form-based authentications.
The extension described in this section provides a replacement for
those authentication systems. The support for this extension is RECOMMENDED,
unless an authentication is mandatory for some specific applications.
</t>

<t>
Servers MAY send HTTP successful responses (response code 200, 206 and others)
containing the Optional&nbhy;WWW&nbhy;Authenticate header, when it is allowed to send
401-B0 responses and the requests do not contain Authentication-Info: headers.
Such responses are hereafter called 200-Optional-B0 responses.
</t>

<t>
HTTP/1.1 200 OK<vspace blankLines="0" />
Optional-WWW-Authenticate: Mutual algorithm=xxxx, validation=xxxx,
                           realm="xxxx", stale=0
</t>

<t>
The fields contained in the Optional&nbhy;WWW&nbhy;Authenticate header is the same as
the 401-B0 message described in <xref target="401-B0" />.
The client software supporting the mutual authentication protocol receiving
a 200-Optional-B0 message will process the contents of the message and
enables an authentication input field.
</t>

<t>
When the user input the username and password, the client resends the
request with req-A1 header.  The server MUST respond with a 401-B1
message.  In terms of the state management in <xref target="cli-decision" />,
200-Optional-B0 responses are treated as if it is 401-B0 response:
these messages SHOULD NOT be sent as a response to
req-A1 and req-A3 messages, unless the authentication realm sent from
the client or indicated by sid is different from the one which the server expects.
</t>

<t>
Servers requesting optional mutual authentication SHOULD send the path
field in 401-B1 messages with an appropriate value.  Client software
supporting optional mutual authentication MUST recognize the
field, and MUST send either req-A1 or
req-A3 request for the URI space inside the specified paths, instead
of unauthenticated requests.
</t>

</section>

<section title="Methods to extend this protocol">

<t>
If a non-standard extension to the this protocol is implemented,
it MUST use the extension-tokens defined in
<xref target="syntax" /> to avoid conflicts with this protocol and other
extensions.
</t>

<t>
Authentication algorithms other than those defined in this document
MAY use other representations for keys "wa", "wb", "oa" and "ob",
replace those keys, and/or add fields to the messages containing those
fields by supplemental specifications.  If those specifications use
keys other than shown above, it is RECOMMENDED to use
extension-tokens to avoid any key-name conflict with the future
extension of this protocol.
</t>

<t>
Extension-tokens MAY be freely used for any non-standard,
private and/or experimental uses for those fields provided that the
domain part in the token is appropriately used.
</t>

</section>

<section anchor="IANA" title="IANA Considerations">
<t>The tokens used for authentication-algorithm, pwd-hash, and
validation fields MUST be allocated by IANA.  To acquire registered
tokens, a specification for the use of such tokens MUST be available
as an RFC, as outlined in <xref target="RFC5226" />.
</t>

<t>
[More formal declarations will be added in future drafts to meet RFC 5226 requirements.]
</t>
</section>

<section anchor="Security" title="Security Considerations">

<section title="General Assumptions">

<t>
<list style="symbols">
 <t>
  The protocol is secure against passive eavesdropping and replay attacks.
  However, the protocol relies on transport security including DNS security for active attacks.
  HTTP/TLS SHOULD be used where transport security
  is not assured and data secrecy is important.
 </t>

 <t>
  When used with HTTP/TLS, the protocol gives true protection against
  active man-in-the-middle attacks for each HTTP request/response
  pair, even when the server certificate is not used or is unreliable.
  However, in such cases, JavaScript or similar scripting facilities
  can be used to affect Mutually-authenticated contents from those
  not protected by this authentication mechanism.
  This is why this memo requires that valid TLS server certificates
  MUST be presented (<xref target="validation" />).
 </t>

</list>
</t>
</section>

<section title="Implementation Considerations">

<t>
<list style="symbols">
 <t>   To securely implement the protocol, the Authentication-Info
       headers in the 200-B4 messages MUST always be validated by the
       client. If the validation is failed, the client MUST NOT process
       any content sent with the message, including the body part.
       Non-compliance to this will enable phishing attacks.
</t>

<t>
       The authentication status on the client-side SHOULD be visible to
       the users of the client.  In addition, the method for asking
       user's name and passwords SHOULD be carefully designed so that
       (1) the user can easily distinguish request of this
       authentication methods from other existing authentication
       methods such as Basic and Digest methods, and (2) the Web contents cannot
       imitate the user-interfaces of this protocol.
       <vspace blankLines="1" />
       An informational memo regarding user-interface considerations
       and recommendations for implementing this protocol will be
       separately published.
</t>

<t>
       For HTTP/TLS communications, when a web form is submitted from
       Mutually-authenticated pages with the validation methods of
       "tls-cert" to a URI which is protected by the same realm (so
       indicated by the path field), if server certificate
       has been changed since the pages has been received, the peer
       is RECOMMENDED to be revalidated using a req-A1 message with an
       "Expect: 100-continue" header.  The same applies when the
       page is received with the validation methods of "tls-key", and
       when the TLS session has been expired.
</t>

<t>
       Server-side storages of user passwords are advised to have
       the values encrypted by one-way function J(pi),
       instead of the real passwords, those hashed by ph, or pi.
</t>
</list>
</t>
</section>


<section title="Usage Considerations">

<t>
<list style="symbols">
 <t>
  The user-names inputted by user may be sent automatically to any servers
  sharing the same auth-domain.  This means that when host-type auth-domain
  is used for authentication in HTTPS site, and when an HTTP server on the
  same host requests Mutual authentication with the same realm, 
  the client will send the user-name in a clear text.
  If user-names have to kept secret against eavesdropping,
  the server must use full-scheme-type auth-domain parameter.
  On the contrary, passwords are not exposed to eavesdroppers even on HTTP requests.
 </t>
 <t>
  "Pwd_hash" field is only provided for backward compatibility
  for password databases, and using "none" function is the mostly secure choice and RECOMMENDED.
  If values other than "none" is used, you must ensure that
  the hash values of the passwords were not exposed to the public.
  Note that hashed password databases for plain-text authentications
  are usually not considered secret.
 </t>
<t>
       If the server provides several ways of storing server-side
       password database, it is advised to store the values 
       encrypted by one-way function J(pi),
       instead of the real passwords, those hashed by ph, or pi.
</t>
</list>
</t>

</section>

</section>

<section title="Notice on intellectual properties">

<t>
The National Institute of Advanced Industrial Science and Technology (AIST) and
Yahoo! Japan, Inc. has jointly submitted a patent application about the
protocol proposed in this documentation to the Patent Office of Japan.
The patent is intended to be open to any implementors of this protocol
and its variants under non-exclusive royalty-free manner once the protocol is accepted
as an Internet standard.
For the detail of the patent application and its status, please contact the author of this document.
</t>

<t>
The elliptic-curve based authentication algorithms might involve several
existing patents of third-parties.  The authors of the document take no
position regarding the validity or scope of such patents, and other patents
as well.
</t>

</section>

<section title="Acknowledgement">
<t>
We gratefully acknowledge Lepidum, Co. Ltd. for support on design and trial implementation of this protocol.
</t>

</section>

</middle>


  <!--  *****BACK MATTER ***** -->


  <back>
    <references title="Normative References">
      &RFC2119;

      &RFC2818;

      &RFC3526;

      &RFC3629;

      &RFC4346;

      &RFC4648;

      &RFC5234;

      &FIPS.180-2.2002;

      <reference anchor="FIPS.186-2.2000" target="http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf">
        <front>
          <title>Digital Signature Standard (DSS)</title>

          <author>
            <organization>National Institute of Standards and Technology</organization>
          </author>

          <date year="2000" month="January" />
        </front>
	<seriesInfo name="FIPS" value="PUB 186-2" />
      </reference>

    </references>

    <references title="Informative References">

      &RFC2616;

      &RFC2617;

      &RFC3492;

      &RFC5226;

      &RFC5280;

      &ITU.X690.1994;

      &ISO.10646-1.1993;

      &I-D.draft-altman-tls-channel-bindings;

      <reference anchor="ISO.11770-4.2006">
        <front>
          <title>Information technology &ndash; Security techniques &ndash; Key management &ndash; Part 4: Mechanisms based on weak secrets</title>
          <author>
            <organization>International Organization for Standardization</organization>
          </author>
          <date year="2006" month="May" />
        </front>
	<seriesInfo name="ISO" value="Standard 11770-4" />
      </reference>

    </references>

    <section anchor="modp-groups" title="Group parameters for discrete-logarithm based algorithms">

    <t>The MODP group used for the iso11770-4-dl-2048 algorithm is defined by the following parameters.</t>

<t>The prime is:</t>

<figure>
<artwork>
 q = 0xFFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
       29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
       EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
       E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
       EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
       C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
       83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
       670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
       E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
       DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
       15728E5A 8AACAA68 FFFFFFFF FFFFFFFF.
</artwork>
</figure>

<t>The generator is:</t>

<figure>
<artwork>
 g = 2.
</artwork>
</figure>

<t>The size of the subgroup generated by g is:</t>

<figure>
<artwork>
 r = (q - 1) / 2 =
     0x7FFFFFFF FFFFFFFF E487ED51 10B4611A 62633145 C06E0E68
       94812704 4533E63A 0105DF53 1D89CD91 28A5043C C71A026E
       F7CA8CD9 E69D218D 98158536 F92F8A1B A7F09AB6 B6A8E122
       F242DABB 312F3F63 7A262174 D31BF6B5 85FFAE5B 7A035BF6
       F71C35FD AD44CFD2 D74F9208 BE258FF3 24943328 F6722D9E
       E1003E5C 50B1DF82 CC6D241B 0E2AE9CD 348B1FD4 7E9267AF
       C1B2AE91 EE51D6CB 0E3179AB 1042A95D CF6A9483 B84B4B36
       B3861AA7 255E4C02 78BA3604 650C10BE 19482F23 171B671D
       F1CF3B96 0C074301 CD93C1D1 7603D147 DAE2AEF8 37A62964
       EF15E5FB 4AAC0B8C 1CCAA4BE 754AB572 8AE9130C 4C7D0288
       0AB9472D 45565534 7FFFFFFF FFFFFFFF.
</artwork>
</figure>

    <t>The MODP group used for the iso11770-4-dl-4096 algorithm is defined by the following parameters.</t>

<t>The prime is:</t>

<figure>
<artwork>
 q = 0xFFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
       29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
       EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
       E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
       EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
       C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
       83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
       670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B
       E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9
       DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510
       15728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64
       ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7
       ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6B
       F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C
       BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31
       43DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7
       88719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA
       2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6
       287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED
       1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA9
       93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199
       FFFFFFFF FFFFFFFF.
</artwork>
</figure>

<t>The generator is:</t>

<figure>
<artwork>
 g = 2.
</artwork>
</figure>

<t>The size of the subgroup generated by g is:</t>

<figure>
<artwork>
 r = (q - 1) / 2 =
     0x7FFFFFFF FFFFFFFF E487ED51 10B4611A 62633145 C06E0E68
       94812704 4533E63A 0105DF53 1D89CD91 28A5043C C71A026E
       F7CA8CD9 E69D218D 98158536 F92F8A1B A7F09AB6 B6A8E122
       F242DABB 312F3F63 7A262174 D31BF6B5 85FFAE5B 7A035BF6
       F71C35FD AD44CFD2 D74F9208 BE258FF3 24943328 F6722D9E
       E1003E5C 50B1DF82 CC6D241B 0E2AE9CD 348B1FD4 7E9267AF
       C1B2AE91 EE51D6CB 0E3179AB 1042A95D CF6A9483 B84B4B36
       B3861AA7 255E4C02 78BA3604 650C10BE 19482F23 171B671D
       F1CF3B96 0C074301 CD93C1D1 7603D147 DAE2AEF8 37A62964
       EF15E5FB 4AAC0B8C 1CCAA4BE 754AB572 8AE9130C 4C7D0288
       0AB9472D 45556216 D6998B86 82283D19 D42A90D5 EF8E5D32
       767DC282 2C6DF785 457538AB AE83063E D9CB87C2 D370F263
       D5FAD746 6D8499EB 8F464A70 2512B0CE E771E913 0D697735
       F897FD03 6CC50432 6C3B0139 9F643532 290F958C 0BBD9006
       5DF08BAB BD30AEB6 3B84C460 5D6CA371 047127D0 3A72D598
       A1EDADFE 707E8847 25C16890 54908400 8D391E09 53C3F36B
       C438CD08 5EDD2D93 4CE1938C 357A711E 0D4A341A 5B0A85ED
       12C1F4E5 156A2674 6DDDE16D 826F477C 97477E0A 0FDF6553
       143E2CA3 A735E02E CCD94B27 D04861D1 119DD0C3 28ADF3F6
       8FB094B8 67716BD7 DC0DEEBB 10B8240E 68034893 EAD82D54
       C9DA754C 46C7EEE0 C37FDBEE 48536047 A6FA1AE4 9A0318CC
       FFFFFFFF FFFFFFFF.
</artwork>
</figure>

    </section>

    <section anchor="other-values" title="Derived numerical values">
    <t>
    This section gives several numerical values for implementing this protocol,
    derived from the above specifications.
    The values shown in this section are for informative purpose only.
    </t>

    <texttable>
    <ttcol></ttcol>
    <ttcol>dl-2048</ttcol>
    <ttcol>dl-4096</ttcol>
    <ttcol>ec-p256</ttcol>
    <ttcol>ec-p521</ttcol>
    <ttcol></ttcol>

    <c>Size of w_A etc.</c>
    <c>2048</c>
    <c>4096</c>
    <c>257</c>
    <c>522</c>
    <c>(bits)</c>

    <c>Size of H(...)</c>
    <c>256</c>
    <c>512</c>
    <c>256</c>
    <c>512</c>
    <c>(bits)</c>

    <c>length of OCTETS(w_A) etc.</c>
    <c>256</c>
    <c>512</c>
    <c>33</c>
    <c>66</c>
    <c>(octets)</c>
    
    <c>length of wa, wb field values.</c>
    <c>346 *</c>
    <c>686 *</c>
    <c>66</c>
    <c>132</c>
    <c>(octets)</c>

    <c>length of oa, ob field values.</c>
    <c>46 *</c>
    <c>90 *</c>
    <c>64</c>
    <c>128</c>
    <c>(octets)</c>

    <c>minimum allowed s_A</c>
    <c>2048</c>
    <c>4096</c>
    <c>1</c>
    <c>1</c>
    <c></c>
    </texttable>

    <t>(The numbers marked with * include enclosing quotation marks.)</t>

    </section>

    <section anchor="notes" title="Draft Remarks from the Authors">
        <t>
          The following items are currently under consideration for future revisions by the authors.
          <list style="symbols">
           <t>Whether to use <xref target="I-D.altman-tls-channel-bindings">"TLS channel binding"</xref> for "tls-key" verification (<xref target="validation" />). Note that existing implementations of TLS should be considered to determine this.</t>
          </list>
        </t>
    </section>

    <section anchor="changelog" title="Draft Change Log">
      <section title="Changes in revision 03">
        <t>
          <list style="symbols">
            <t>Wildcard domain specifications (e.g. "*.example.com") is allowed for auth-domain parameters (<xref target="401-B0" />).</t>
	    <t>Specification of the "tls-host" verification is updated (incompatible change).</t>
            <t>State transitions fixed.</t>
            <t>Requirements for servers about w_a values clarified.</t>
            <t>RFC references are updated.</t>
          </list>
        </t>
      </section>
      <section title="Changes in revision 02">
        <t>
          <list style="symbols">
            <t>Auth-realm is extended to allow full-scheme type.</t>
            <t>A decision diagram for clients and decision procedures for servers are added.</t>
            <t>401-B1 and req-A3 messages is changed to have authentication realm information.</t>
	    <t>Bugs on equations for o_A and o_B is fixed.</t>
	    <t>Detailed equations for the whole algorithm is included.</t>
	    <t>Elliptic-curve algorithms are updated.</t>
            <t>Several clarifications and other minor updates.</t>
          </list>
        </t>
      </section>
    </section>

  </back>
</rfc>
